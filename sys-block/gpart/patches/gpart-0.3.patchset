From 610741608381635064c15030f35714dd113f76af Mon Sep 17 00:00:00 2001
From: Baruch Even <baruch@ev-en.org>
Date: Wed, 25 Nov 2015 08:17:17 +0200
Subject: [PATCH 01/11] Add LVM2 and btrfs to list of supported modules

---
 README.md | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 7cd3e2d..330821b 100644
--- a/README.md
+++ b/README.md
@@ -41,7 +41,8 @@ See file *INSTALL*.
    qnx4     | 0x4F | QNX 4.x
    beos     | 0xEB | BeOS fs
    xfs      | 0x83 | SGI XFS filesystem
-
+   btrfs    | 0x83 | BtrFS
+   LVM2     | 0x8E | LVM2
 
 
 ## Guessing modules
-- 
2.15.1

From cb2e9e61cff1a40c18a68e59ab66b304a7a6f07c Mon Sep 17 00:00:00 2001
From: Baruch Even <baruch@ev-en.org>
Date: Wed, 25 Nov 2015 08:42:35 +0200
Subject: [PATCH 02/11] Format code with clang-format (mostly)

---
 src/disku.c       |   40 +-
 src/gm_beos.c     |   31 +-
 src/gm_beos.h     |   57 +-
 src/gm_bsddl.c    |   37 +-
 src/gm_bsddl.h    |  149 +++--
 src/gm_btrfs.c    |   24 +-
 src/gm_btrfs.h    |   12 +-
 src/gm_ext2.c     |   94 +--
 src/gm_ext2.h     |    4 +-
 src/gm_fat.c      |   46 +-
 src/gm_fat.h      |    6 +-
 src/gm_hmlvm.c    |   38 +-
 src/gm_hmlvm.h    |   12 +-
 src/gm_hpfs.c     |   54 +-
 src/gm_hpfs.h     |    2 +-
 src/gm_lswap.c    |   80 ++-
 src/gm_lvm2.c     |   23 +-
 src/gm_lvm2.h     |   18 +-
 src/gm_minix.c    |   38 +-
 src/gm_minix.h    |    7 +-
 src/gm_ntfs.c     |   41 +-
 src/gm_ntfs.h     |    4 +-
 src/gm_qnx4.c     |   62 +-
 src/gm_qnx4.h     |    5 +-
 src/gm_reiserfs.c |   34 +-
 src/gm_reiserfs.h |    4 +-
 src/gm_s86dl.c    |   46 +-
 src/gm_s86dl.h    |    2 +-
 src/gm_xfs.c      |   23 +-
 src/gm_xfs.h      |    2 +-
 src/gmodules.c    |   89 +--
 src/gpart.c       | 1811 +++++++++++++++++++++++++----------------------------
 src/gpart.h       |    2 -
 src/l64seek.c     |   31 +-
 src/l64seek.h     |    2 +-
 35 files changed, 1330 insertions(+), 1600 deletions(-)

diff --git a/src/disku.c b/src/disku.c
index b918147..4a5ca02 100644
--- a/src/disku.c
+++ b/src/disku.c
@@ -15,7 +15,6 @@
  *
  */
 
-
 #include <errno.h>
 #include <stdio.h>
 #include <string.h>
@@ -36,7 +35,6 @@
 
 #include <unistd.h>
 
-
 /*
  * get disk geometry. The medium is opened for reading,
  * descriptor in d_fd.
@@ -44,26 +42,24 @@
 
 struct disk_geom *disk_geometry(disk_desc *d)
 {
-	static struct disk_geom	g;
-	uint64_t			nsects;
+	static struct disk_geom g;
+	uint64_t nsects;
 
 	memset(&g, 0, sizeof(g));
 
 #if defined(__linux__)
-	struct hd_geometry	hg;
+	struct hd_geometry hg;
 #endif
 #if defined(__FreeBSD__)
-	struct disklabel	dl;
+	struct disklabel dl;
 #endif
 
 	struct stat st;
 	int ret;
 	uint64_t lba;
 	ret = stat(d->d_dev, &st);
-	if (ret == 0)
-	{
-		if (S_ISREG(st.st_mode))
-		{
+	if (ret == 0) {
+		if (S_ISREG(st.st_mode)) {
 			nsects = st.st_size / 512;
 			if (nsects == 0)
 				pr(FATAL, EM_FATALERROR, "Not a block device image file");
@@ -77,11 +73,11 @@ struct disk_geom *disk_geometry(disk_desc *d)
 	}
 
 #if defined(__linux__)
-	if (ioctl(d->d_fd,HDIO_GETGEO,&hg) == -1)
-		pr(FATAL,EM_IOCTLFAILED,"HDIO_GETGEO",strerror(errno));
+	if (ioctl(d->d_fd, HDIO_GETGEO, &hg) == -1)
+		pr(FATAL, EM_IOCTLFAILED, "HDIO_GETGEO", strerror(errno));
 #ifdef BLKGETSIZE
-	if (ioctl(d->d_fd,BLKGETSIZE,&nsects) == -1)
-		pr(FATAL,EM_IOCTLFAILED,"BLKGETSIZE",strerror(errno));
+	if (ioctl(d->d_fd, BLKGETSIZE, &nsects) == -1)
+		pr(FATAL, EM_IOCTLFAILED, "BLKGETSIZE", strerror(errno));
 	g.d_nsecs = nsects;
 	g.d_c = nsects / (hg.heads * hg.sectors);
 #else
@@ -93,22 +89,22 @@ struct disk_geom *disk_geometry(disk_desc *d)
 #endif
 
 #if defined(__FreeBSD__)
-	struct disklabel	loclab;
-	u_int    u;
-	off_t	 o; /* total disk size */
+	struct disklabel loclab;
+	u_int u;
+	off_t o; /* total disk size */
 
 	if (ioctl(d->d_fd, DIOCGFWSECTORS, &u) == 0)
 		g.d_s = u;
 	else
 		pr(FATAL, EM_IOCTLFAILED, "DIOCGFWSECTORS", strerror(errno));
-		// loclab.d_nsectors = 63;
+	// loclab.d_nsectors = 63;
 	if (ioctl(d->d_fd, DIOCGFWHEADS, &u) == 0)
 		g.d_h = u;
 	else
 		pr(FATAL, EM_IOCTLFAILED, "DIOCGFWHEADS", strerror(errno));
 	if (ioctl(d->d_fd, DIOCGSECTORSIZE, &u) == 0)
 		if (u != 512)
-		    pr(FATAL, "sector size not a multiple of 512");
+			pr(FATAL, "sector size not a multiple of 512");
 	if (ioctl(d->d_fd, DIOCGMEDIASIZE, &o))
 		pr(FATAL, EM_IOCTLFAILED, "DIOCGMEDIASIZE", strerror(errno));
 
@@ -119,7 +115,6 @@ struct disk_geom *disk_geometry(disk_desc *d)
 	return (&g);
 }
 
-
 /*
  * tell the OS to reread a changed partition table. Do
  * nothing if there is no such possibility.
@@ -128,9 +123,8 @@ struct disk_geom *disk_geometry(disk_desc *d)
 int reread_partition_table(int fd)
 {
 #if defined(__linux__) && defined(BLKRRPART)
-	if (ioctl(fd,BLKRRPART) == -1)
-	{
-		pr(ERROR,"rereading partition table: %s",strerror(errno));
+	if (ioctl(fd, BLKRRPART) == -1) {
+		pr(ERROR, "rereading partition table: %s", strerror(errno));
 		return (0);
 	}
 #endif
diff --git a/src/gm_beos.c b/src/gm_beos.c
index 2f65586..cb9a447 100644
--- a/src/gm_beos.c
+++ b/src/gm_beos.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_beos.c -- gpart BeOS filesystem guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -22,7 +22,7 @@
 
 #include <stdio.h>
 
-int beos_init(disk_desc *d,g_module *m)
+int beos_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -30,19 +30,12 @@ int beos_init(disk_desc *d,g_module *m)
 	return (2 * 512);
 }
 
+int beos_term(disk_desc *d) { return (1); }
 
-
-int beos_term(disk_desc *d)
-{
-        return (1);
-}
-
-
-
-int beos_gfun(disk_desc *d,g_module *m)
+int beos_gfun(disk_desc *d, g_module *m)
 {
-	beos_super_block	*sb;
-	s64_t			size;
+	beos_super_block *sb;
+	s64_t size;
 
 	m->m_guess = GM_NO;
 
@@ -51,17 +44,15 @@ int beos_gfun(disk_desc *d,g_module *m)
 	 */
 
 	sb = (beos_super_block *)(d->d_sbuf + 512);
-	if ((sb->magic1 != BEOS_SUPER_BLOCK_MAGIC1) ||
-	    (sb->magic2 != BEOS_SUPER_BLOCK_MAGIC2) ||
-	    (sb->magic3 != BEOS_SUPER_BLOCK_MAGIC3))
+	if ((sb->magic1 != BEOS_SUPER_BLOCK_MAGIC1) || (sb->magic2 != BEOS_SUPER_BLOCK_MAGIC2) ||
+		(sb->magic3 != BEOS_SUPER_BLOCK_MAGIC3))
 		return (1);
 
 	/*
 	 * some consistency checks
 	 */
 
-	if ((sb->block_size != 1024) && (sb->block_size != 2048) &&
-	    (sb->block_size != 4096) && (sb->block_size != 8192))
+	if ((sb->block_size != 1024) && (sb->block_size != 2048) && (sb->block_size != 4096) && (sb->block_size != 8192))
 		return (1);
 
 	if (sb->block_size != 1 << sb->block_shift)
@@ -78,7 +69,9 @@ int beos_gfun(disk_desc *d,g_module *m)
 	 * as well later.
 	 */
 
-	size = sb->num_blocks; size *= sb->block_size; size /= d->d_ssize;
+	size = sb->num_blocks;
+	size *= sb->block_size;
+	size /= d->d_ssize;
 	m->m_guess = GM_YES;
 	m->m_part.p_typ = 0xEB;
 	m->m_part.p_start = d->d_nsb;
diff --git a/src/gm_beos.h b/src/gm_beos.h
index ba1651f..b23435d 100644
--- a/src/gm_beos.h
+++ b/src/gm_beos.h
@@ -1,6 +1,6 @@
 /*
  * gm_beos.h -- gpart BeOS filesystem guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,7 +10,7 @@
  * option) any later version.
  *
  * Created:   29.01.2001 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
@@ -63,52 +63,51 @@ typedef unsigned int __u32;
  * special type of BEOS
  */
 
-typedef s64_t		beos_off_t;
-typedef s64_t		beos_bigtime_t;
-typedef void		beos_binode_etc;
+typedef s64_t beos_off_t;
+typedef s64_t beos_bigtime_t;
+typedef void beos_binode_etc;
 
 typedef struct _beos_block_run {
-	__u32	allocation_group;
-	__u16	start;
-	__u16	len;
+	__u32 allocation_group;
+	__u16 start;
+	__u16 len;
 } beos_block_run;
 
-typedef beos_block_run	beos_inode_addr;
+typedef beos_block_run beos_inode_addr;
 
 /*
  * The Superblock Structure
  */
 
 typedef struct _beos_super_block {
-	char	name[BEOS_NAME_LENGTH];
-	__u32	magic1;
-	__u32	fs_byte_order;
+	char name[BEOS_NAME_LENGTH];
+	__u32 magic1;
+	__u32 fs_byte_order;
 
-	__u32	block_size;
-	__u32	block_shift;
+	__u32 block_size;
+	__u32 block_shift;
 
-	beos_off_t  num_blocks;
-	beos_off_t  used_blocks;
+	beos_off_t num_blocks;
+	beos_off_t used_blocks;
 
-	__u32          inode_size;
+	__u32 inode_size;
 
-	__u32          magic2;
-	__u32          blocks_per_ag;
-	__u32          ag_shift;
-	__u32          num_ags;
+	__u32 magic2;
+	__u32 blocks_per_ag;
+	__u32 ag_shift;
+	__u32 num_ags;
 
-	__u32          flags;
+	__u32 flags;
 
-	beos_block_run  log_blocks;
-	beos_off_t      log_start;
-	beos_off_t      log_end;
+	beos_block_run log_blocks;
+	beos_off_t log_start;
+	beos_off_t log_end;
 
-	__u32          magic3;
+	__u32 magic3;
 	beos_inode_addr root_dir;
 	beos_inode_addr indices;
 
-	__u32          pad[8];
-} __attribute__ ((packed)) beos_super_block;
-
+	__u32 pad[8];
+} __attribute__((packed)) beos_super_block;
 
 #endif /* _GM_BEOS_H */
diff --git a/src/gm_bsddl.c b/src/gm_bsddl.c
index 334c08b..0079ac7 100644
--- a/src/gm_bsddl.c
+++ b/src/gm_bsddl.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_bsddl.c -- gpart BSD disk label guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -17,35 +17,27 @@
 #include "gpart.h"
 #include "gm_bsddl.h"
 
-
-int bsddl_init(disk_desc *d,g_module *m)
+int bsddl_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
 	m->m_desc = "*BSD disklabel";
-	m->m_hasptbl = 1; m->m_notinext = 1;
+	m->m_hasptbl = 1;
+	m->m_notinext = 1;
 	return (BBSIZE);
 }
 
+int bsddl_term(disk_desc *d) { return (1); }
 
-
-int bsddl_term(disk_desc *d)
-{
-	return (1);
-}
-
-
-
-int bsddl_gfun(disk_desc *d,g_module *m)
+int bsddl_gfun(disk_desc *d, g_module *m)
 {
-	struct disklabel	*dl;
-	struct partition	*bsdpt;
-	unsigned short		*cp, *ep, cs1, cs2;
+	struct disklabel *dl;
+	struct partition *bsdpt;
+	unsigned short *cp, *ep, cs1, cs2;
 
 	m->m_guess = GM_NO;
 	dl = (struct disklabel *)(d->d_sbuf + LABELSECTOR * d->d_ssize);
-	if ((dl->d_magic == le32(DISKMAGIC)) && (dl->d_magic2 == le32(DISKMAGIC)))
-	{
+	if ((dl->d_magic == le32(DISKMAGIC)) && (dl->d_magic2 == le32(DISKMAGIC))) {
 		/*
 		 * partition RAW_PART(2) usually denotes the whole disk (slice)
 		 */
@@ -59,15 +51,16 @@ int bsddl_gfun(disk_desc *d,g_module *m)
 		 * of partition.
 		 */
 
-		cs1 = 0; cs2 = le16(dl->d_checksum); dl->d_checksum = 0;
+		cs1 = 0;
+		cs2 = le16(dl->d_checksum);
+		dl->d_checksum = 0;
 		cp = (unsigned short *)dl;
 		ep = (unsigned short *)&dl->d_partitions[dl->d_npartitions];
-		for ( ; cp < ep; cp++)
+		for (; cp < ep; cp++)
 			cs1 ^= le16(*cp);
 		dl->d_checksum = le16(cs2);
 
-		if ((le32(bsdpt->p_offset) == d->d_nsb) && (cs1 == cs2))
-		{
+		if ((le32(bsdpt->p_offset) == d->d_nsb) && (cs1 == cs2)) {
 			m->m_part.p_typ = 0xA5;
 			m->m_part.p_start = le32(bsdpt->p_offset);
 			m->m_part.p_size = le32(bsdpt->p_size);
diff --git a/src/gm_bsddl.h b/src/gm_bsddl.h
index aa16547..0d9bc17 100644
--- a/src/gm_bsddl.h
+++ b/src/gm_bsddl.h
@@ -1,6 +1,6 @@
 /*
  * gm_bsddl.h -- gpart BSD disk label guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,7 +10,7 @@
  * option) any later version.
  *
  * Created:   04.01.1999 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
@@ -26,66 +26,66 @@
 
 #define STANDALONE
 
-#define BBSIZE		8192	/* size of boot area, with label */
+#define BBSIZE 8192 /* size of boot area, with label */
 
 #ifdef __i386__
-#define LABELSECTOR	1			/* sector containing label */
-#define LABELOFFSET	0			/* offset of label in sector */
+#define LABELSECTOR 1 /* sector containing label */
+#define LABELOFFSET 0 /* offset of label in sector */
 #endif
 
-#ifndef	LABELSECTOR
-#define LABELSECTOR	0			/* sector containing label */
+#ifndef LABELSECTOR
+#define LABELSECTOR 0 /* sector containing label */
 #endif
 
-#ifndef	LABELOFFSET
-#define LABELOFFSET	64			/* offset of label in sector */
+#ifndef LABELOFFSET
+#define LABELOFFSET 64 /* offset of label in sector */
 #endif
 
-#define DISKMAGIC	((u_int32_t)0x82564557)	/* The disk magic number */
+#define DISKMAGIC ((u_int32_t)0x82564557) /* The disk magic number */
 #ifndef MAXPARTITIONS
-#define	MAXPARTITIONS	8
+#define MAXPARTITIONS 8
 #endif
 
-#define	LABEL_PART	2		/* partition containing label */
-#define	RAW_PART	2		/* partition containing whole disk */
-#define	SWAP_PART	1		/* partition normally containing swap */
+#define LABEL_PART 2 /* partition containing label */
+#define RAW_PART 2   /* partition containing whole disk */
+#define SWAP_PART 1  /* partition normally containing swap */
 
 struct disklabel {
-	u_int32_t d_magic;		/* the magic number */
-	u_int16_t d_type;		/* drive type */
-	u_int16_t d_subtype;		/* controller/d_type specific */
-	char	  d_typename[16];	/* type name, e.g. "eagle" */
-
-	/* 
-	 * d_packname contains the pack identifier and is returned when
-	 * the disklabel is read off the disk or in-core copy.
-	 * d_boot0 and d_boot1 are the (optional) names of the
-	 * primary (block 0) and secondary (block 1-15) bootstraps
-	 * as found in /usr/mdec.  These are returned when using
-	 * getdiskbyname(3) to retrieve the values from /etc/disktab.
-	 */
+	u_int32_t d_magic;   /* the magic number */
+	u_int16_t d_type;	/* drive type */
+	u_int16_t d_subtype; /* controller/d_type specific */
+	char d_typename[16]; /* type name, e.g. "eagle" */
+
+/*
+ * d_packname contains the pack identifier and is returned when
+ * the disklabel is read off the disk or in-core copy.
+ * d_boot0 and d_boot1 are the (optional) names of the
+ * primary (block 0) and secondary (block 1-15) bootstraps
+ * as found in /usr/mdec.  These are returned when using
+ * getdiskbyname(3) to retrieve the values from /etc/disktab.
+ */
 #if defined(KERNEL) || defined(STANDALONE)
-	char	  d_packname[16];		/* pack identifier */ 
+	char d_packname[16]; /* pack identifier */
 #else
 	union {
-		char	un_d_packname[16];	/* pack identifier */
+		char un_d_packname[16]; /* pack identifier */
 		struct {
-			char *un_d_boot0;	/* primary bootstrap name */
-			char *un_d_boot1;	/* secondary bootstrap name */
+			char *un_d_boot0; /* primary bootstrap name */
+			char *un_d_boot1; /* secondary bootstrap name */
 		} un_b;
 	} d_un;
-#define d_packname	d_un.un_d_packname
-#define d_boot0		d_un.un_b.un_d_boot0
-#define d_boot1		d_un.un_b.un_d_boot1
-#endif	/* ! KERNEL or STANDALONE */
-
-			/* disk geometry: */
-	u_int32_t d_secsize;		/* # of bytes per sector */
-	u_int32_t d_nsectors;		/* # of data sectors per track */
-	u_int32_t d_ntracks;		/* # of tracks per cylinder */
-	u_int32_t d_ncylinders;		/* # of data cylinders per unit */
-	u_int32_t d_secpercyl;		/* # of data sectors per cylinder */
-	u_int32_t d_secperunit;		/* # of data sectors per unit */
+#define d_packname d_un.un_d_packname
+#define d_boot0 d_un.un_b.un_d_boot0
+#define d_boot1 d_un.un_b.un_d_boot1
+#endif /* ! KERNEL or STANDALONE */
+
+	/* disk geometry: */
+	u_int32_t d_secsize;	/* # of bytes per sector */
+	u_int32_t d_nsectors;   /* # of data sectors per track */
+	u_int32_t d_ntracks;	/* # of tracks per cylinder */
+	u_int32_t d_ncylinders; /* # of data cylinders per unit */
+	u_int32_t d_secpercyl;  /* # of data sectors per cylinder */
+	u_int32_t d_secperunit; /* # of data sectors per unit */
 
 	/*
 	 * Spares (bad sector replacements) below are not counted in
@@ -93,15 +93,15 @@ struct disklabel {
 	 * be physical sectors which occupy space at the end of each
 	 * track and/or cylinder.
 	 */
-	u_int16_t d_sparespertrack;	/* # of spare sectors per track */
-	u_int16_t d_sparespercyl;	/* # of spare sectors per cylinder */
-	/*
-	 * Alternate cylinders include maintenance, replacement, configuration
-	 * description areas, etc.
-	 */
+	u_int16_t d_sparespertrack; /* # of spare sectors per track */
+	u_int16_t d_sparespercyl;   /* # of spare sectors per cylinder */
+								/*
+								 * Alternate cylinders include maintenance, replacement, configuration
+								 * description areas, etc.
+								 */
 	u_int32_t d_acylinders;		/* # of alt. cylinders per unit */
 
-			/* hardware characteristics: */
+	/* hardware characteristics: */
 	/*
 	 * d_interleave, d_trackskew and d_cylskew describe perturbations
 	 * in the media format used to compensate for a slow controller.
@@ -119,37 +119,36 @@ struct disklabel {
 	 * on cylinder N-1.
 	 */
 	u_int16_t d_rpm;		/* rotational speed */
-	u_int16_t d_interleave;		/* hardware sector interleave */
-	u_int16_t d_trackskew;		/* sector 0 skew, per track */
-	u_int16_t d_cylskew;		/* sector 0 skew, per cylinder */
-	u_int32_t d_headswitch;		/* head switch time, usec */
-	u_int32_t d_trkseek;		/* track-to-track seek, usec */
+	u_int16_t d_interleave; /* hardware sector interleave */
+	u_int16_t d_trackskew;  /* sector 0 skew, per track */
+	u_int16_t d_cylskew;	/* sector 0 skew, per cylinder */
+	u_int32_t d_headswitch; /* head switch time, usec */
+	u_int32_t d_trkseek;	/* track-to-track seek, usec */
 	u_int32_t d_flags;		/* generic flags */
 #define NDDATA 5
-	u_int32_t d_drivedata[NDDATA];	/* drive-type specific information */
+	u_int32_t d_drivedata[NDDATA]; /* drive-type specific information */
 #define NSPARE 5
-	u_int32_t d_spare[NSPARE];	/* reserved for future use */
-	u_int32_t d_magic2;		/* the magic number (again) */
-	u_int16_t d_checksum;		/* xor of data incl. partitions */
-
-			/* filesystem and partition information: */
-	u_int16_t d_npartitions;	/* number of partitions in following */
-	u_int32_t d_bbsize;		/* size of boot area at sn0, bytes */
-	u_int32_t d_sbsize;		/* max size of fs superblock, bytes */
-	struct	partition {		/* the partition table */
+	u_int32_t d_spare[NSPARE]; /* reserved for future use */
+	u_int32_t d_magic2;		   /* the magic number (again) */
+	u_int16_t d_checksum;	  /* xor of data incl. partitions */
+
+	/* filesystem and partition information: */
+	u_int16_t d_npartitions; /* number of partitions in following */
+	u_int32_t d_bbsize;		 /* size of boot area at sn0, bytes */
+	u_int32_t d_sbsize;		 /* max size of fs superblock, bytes */
+	struct partition {		 /* the partition table */
 		u_int32_t p_size;	/* number of sectors in partition */
-		u_int32_t p_offset;	/* starting sector */
-		u_int32_t p_fsize;	/* filesystem basic fragment size */
-		u_int8_t p_fstype;	/* filesystem type, see below */
-		u_int8_t p_frag;	/* filesystem fragments per block */
+		u_int32_t p_offset;  /* starting sector */
+		u_int32_t p_fsize;   /* filesystem basic fragment size */
+		u_int8_t p_fstype;   /* filesystem type, see below */
+		u_int8_t p_frag;	 /* filesystem fragments per block */
 		union {
-			u_int16_t cpg;	/* UFS: FS cylinders per group */
-			u_int16_t sgs;	/* LFS: FS segment shift */
+			u_int16_t cpg; /* UFS: FS cylinders per group */
+			u_int16_t sgs; /* LFS: FS segment shift */
 		} __partition_u1;
-#define	p_cpg	__partition_u1.cpg
-#define	p_sgs	__partition_u1.sgs
-	} d_partitions[MAXPARTITIONS];	/* actually may be more */
+#define p_cpg __partition_u1.cpg
+#define p_sgs __partition_u1.sgs
+	} d_partitions[MAXPARTITIONS]; /* actually may be more */
 };
 
-
 #endif /* _GM_BSDDL_H */
diff --git a/src/gm_btrfs.c b/src/gm_btrfs.c
index 309bb48..cdf0a36 100644
--- a/src/gm_btrfs.c
+++ b/src/gm_btrfs.c
@@ -19,8 +19,7 @@
 #include "gpart.h"
 #include "gm_btrfs.h"
 
-
-int btrfs_init(disk_desc *d,g_module *m)
+int btrfs_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -29,20 +28,16 @@ int btrfs_init(disk_desc *d,g_module *m)
 	return BTRFS_SUPER_INFO_OFFSET + BTRFS_SUPER_INFO_SIZE;
 }
 
-int btrfs_term(disk_desc *d)
-{
-	return (1);
-}
+int btrfs_term(disk_desc *d) { return (1); }
 
-int btrfs_gfun(disk_desc *d,g_module *m)
+int btrfs_gfun(disk_desc *d, g_module *m)
 {
 	struct btrfs_super_block *sb;
 	dos_part_entry *pt = &m->m_part;
 	s64_t psize;
 
 	m->m_guess = GM_NO;
-	sb = (struct btrfs_super_block*)
-		(d->d_sbuf + BTRFS_SUPER_INFO_OFFSET);
+	sb = (struct btrfs_super_block *)(d->d_sbuf + BTRFS_SUPER_INFO_OFFSET);
 
 	if (le64toh(sb->magic) != BTRFS_MAGIC)
 		return 1;
@@ -53,14 +48,11 @@ int btrfs_gfun(disk_desc *d,g_module *m)
 	psize = le64toh(sb->dev_item.total_bytes);
 	if (psize > btrfs_sb_offset(1)) {
 		struct btrfs_super_block sb_copy;
-		if (l64seek(d->d_fd,
-			    d->d_nsb * d->d_ssize + btrfs_sb_offset(1),
-			    SEEK_SET) == -1)
-			pr(FATAL,"btrfs: cannot seek: %s", strerror(errno));
+		if (l64seek(d->d_fd, d->d_nsb * d->d_ssize + btrfs_sb_offset(1), SEEK_SET) == -1)
+			pr(FATAL, "btrfs: cannot seek: %s", strerror(errno));
 		read(d->d_fd, &sb_copy, sizeof(sb_copy));
-		if (le64toh(sb_copy.magic) != BTRFS_MAGIC ||
-		    memcmp(sb->fsid, sb_copy.fsid, BTRFS_FSID_SIZE)) {
-			pr(MSG,"btrfs: superblock copy mismatch\n");
+		if (le64toh(sb_copy.magic) != BTRFS_MAGIC || memcmp(sb->fsid, sb_copy.fsid, BTRFS_FSID_SIZE)) {
+			pr(MSG, "btrfs: superblock copy mismatch\n");
 			return 1;
 		}
 	}
diff --git a/src/gm_btrfs.h b/src/gm_btrfs.h
index 7b3d13f..62fdf86 100644
--- a/src/gm_btrfs.h
+++ b/src/gm_btrfs.h
@@ -34,7 +34,7 @@ typedef uint8_t u8;
 
 #define BTRFS_SUPER_INFO_OFFSET (64 * 1024)
 #define BTRFS_SUPER_INFO_SIZE 4096
-#define btrfs_sb_offset(i) ((i) ? ((16*1024) << (BTRFS_SUPER_MIRROR_SHIFT * (i))) : BTRFS_SUPER_INFO_SIZE)
+#define btrfs_sb_offset(i) ((i) ? ((16 * 1024) << (BTRFS_SUPER_MIRROR_SHIFT * (i))) : BTRFS_SUPER_INFO_SIZE)
 #define BTRFS_SUPER_MIRROR_SHIFT 12
 #define BTRFS_CSUM_SIZE 32
 #define BTRFS_FSID_SIZE 16
@@ -77,7 +77,7 @@ struct btrfs_root_backup {
 	u8 csum_root_level;
 	/* future and to align */
 	u8 unused_8[10];
-} __attribute__ ((__packed__));
+} __attribute__((__packed__));
 
 #define BTRFS_UUID_SIZE 16
 struct btrfs_dev_item {
@@ -125,13 +125,13 @@ struct btrfs_dev_item {
 
 	/* uuid of FS who owns this device */
 	u8 fsid[BTRFS_UUID_SIZE];
-} __attribute__ ((__packed__));
+} __attribute__((__packed__));
 
 struct btrfs_super_block {
 	u8 csum[BTRFS_CSUM_SIZE];
 	/* the first 3 fields must match struct btrfs_header */
-	u8 fsid[BTRFS_FSID_SIZE];    /* FS specific uuid */
-	__le64 bytenr; /* this block number */
+	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
+	__le64 bytenr;			  /* this block number */
 	__le64 flags;
 	/* allowed to be different from the btrfs_header from here own down */
 	__le64 magic;
@@ -170,6 +170,6 @@ struct btrfs_super_block {
 	__le64 reserved[30];
 	u8 sys_chunk_array[BTRFS_SYSTEM_CHUNK_ARRAY_SIZE];
 	struct btrfs_root_backup super_roots[BTRFS_NUM_BACKUP_ROOTS];
-} __attribute__ ((__packed__));
+} __attribute__((__packed__));
 
 #endif /* _GM_BTRFS_H */
diff --git a/src/gm_ext2.c b/src/gm_ext2.c
index 827013c..68f97b4 100644
--- a/src/gm_ext2.c
+++ b/src/gm_ext2.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_ext2.c -- gpart ext2 guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -27,10 +27,9 @@
 #include "gpart.h"
 #include "gm_ext2.h"
 
-
-int ext2_init(disk_desc *d,g_module *m)
+int ext2_init(disk_desc *d, g_module *m)
 {
-	int		bsize = SUPERBLOCK_SIZE;
+	int bsize = SUPERBLOCK_SIZE;
 
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -40,32 +39,23 @@ int ext2_init(disk_desc *d,g_module *m)
 	 * of the superblock size or vice versa.
 	 */
 
-	if (((d->d_ssize > bsize) && (d->d_ssize % bsize)) ||
-	    ((d->d_ssize < bsize) && (bsize % d->d_ssize)))
-	{
-		pr(ERROR,"ext2_init: cannot work on that sector size");
+	if (((d->d_ssize > bsize) && (d->d_ssize % bsize)) || ((d->d_ssize < bsize) && (bsize % d->d_ssize))) {
+		pr(ERROR, "ext2_init: cannot work on that sector size");
 		return (0);
 	}
 	m->m_desc = "Linux ext2";
 	return (SUPERBLOCK_OFFSET + SUPERBLOCK_SIZE);
 }
 
+int ext2_term(disk_desc *d) { return (1); }
 
-
-int ext2_term(disk_desc *d)
+int ext2_gfun(disk_desc *d, g_module *m)
 {
-	return (1);
-}
-
-
-
-int ext2_gfun(disk_desc *d,g_module *m)
-{
-	struct ext2fs_sb	*sb, *sparesb;
-	int			psize, bsize = 1024;
-	s64_t			ls, ofs;
-	dos_part_entry		*pt = &m->m_part;
-	byte_t			*ubuf, *sbuf;
+	struct ext2fs_sb *sb, *sparesb;
+	int psize, bsize = 1024;
+	s64_t ls, ofs;
+	dos_part_entry *pt = &m->m_part;
+	byte_t *ubuf, *sbuf;
 
 	m->m_guess = GM_NO;
 	sb = (struct ext2fs_sb *)(d->d_sbuf + SUPERBLOCK_OFFSET);
@@ -76,12 +66,12 @@ int ext2_gfun(disk_desc *d,g_module *m)
 	 * first some plausability checks.
 	 */
 
-	if (sb->s_free_blocks_count >= sb->s_blocks_count) return (1);
-	if (sb->s_free_inodes_count >= sb->s_inodes_count) return (1);
-	if (sb->s_errors &&
-	    (sb->s_errors != EXT2_ERRORS_CONTINUE) &&
-	    (sb->s_errors != EXT2_ERRORS_RO) &&
-	    (sb->s_errors != EXT2_ERRORS_PANIC))
+	if (sb->s_free_blocks_count >= sb->s_blocks_count)
+		return (1);
+	if (sb->s_free_inodes_count >= sb->s_inodes_count)
+		return (1);
+	if (sb->s_errors && (sb->s_errors != EXT2_ERRORS_CONTINUE) && (sb->s_errors != EXT2_ERRORS_RO) &&
+		(sb->s_errors != EXT2_ERRORS_PANIC))
 		return (1);
 	if (sb->s_state & ~(EXT2_VALID_FS | EXT2_ERROR_FS))
 		return (1);
@@ -97,10 +87,11 @@ int ext2_gfun(disk_desc *d,g_module *m)
 	 * yet they also shouldn't be too large.
 	 */
 
-	if (d->d_nsecs)
-	{
-		ls = sb->s_blocks_count; ls *= bsize;
-		ls /= d->d_ssize; ls += d->d_nsb;
+	if (d->d_nsecs) {
+		ls = sb->s_blocks_count;
+		ls *= bsize;
+		ls /= d->d_ssize;
+		ls += d->d_nsb;
 		if (ls > d->d_nsecs)
 			return (1);
 	}
@@ -109,12 +100,18 @@ int ext2_gfun(disk_desc *d,g_module *m)
 	 * ext2fs supports 1024, 2048 and 4096b blocks.
 	 */
 
-	switch (sb->s_log_block_size)
-	{
-		case BSIZE_1024 : bsize = 1024; break;
-		case BSIZE_2048 : bsize = 2048; break;
-		case BSIZE_4096 : bsize = 4096; break;
-		default:          return (1);
+	switch (sb->s_log_block_size) {
+	case BSIZE_1024:
+		bsize = 1024;
+		break;
+	case BSIZE_2048:
+		bsize = 2048;
+		break;
+	case BSIZE_4096:
+		bsize = 4096;
+		break;
+	default:
+		return (1);
 	}
 
 	/*
@@ -122,7 +119,7 @@ int ext2_gfun(disk_desc *d,g_module *m)
 	 * but ext3 usually has s_max_mnt_count==-1
 	 */
 
-	if ((sb->s_max_mnt_count!=-1)&&(sb->s_mnt_count > sb->s_max_mnt_count + 20))
+	if ((sb->s_max_mnt_count != -1) && (sb->s_mnt_count > sb->s_max_mnt_count + 20))
 		return (1);
 
 	/*
@@ -131,17 +128,20 @@ int ext2_gfun(disk_desc *d,g_module *m)
 	 */
 
 	if ((ls = l64tell(d->d_fd)) == -1)
-		pr(FATAL,"ext2: cannot seek: %s",strerror(errno));
-	ls /= d->d_ssize; ls -= d->d_nsb; ls *= d->d_ssize;
-	ofs = sb->s_blocks_per_group + sb->s_first_data_block; ofs *= bsize;
-	if (l64seek(d->d_fd,ofs - ls,SEEK_CUR) == -1)
-		pr(FATAL,"ext2: cannot seek: %s",strerror(errno));
+		pr(FATAL, "ext2: cannot seek: %s", strerror(errno));
+	ls /= d->d_ssize;
+	ls -= d->d_nsb;
+	ls *= d->d_ssize;
+	ofs = sb->s_blocks_per_group + sb->s_first_data_block;
+	ofs *= bsize;
+	if (l64seek(d->d_fd, ofs - ls, SEEK_CUR) == -1)
+		pr(FATAL, "ext2: cannot seek: %s", strerror(errno));
 
 	psize = getpagesize();
 	ubuf = alloc(SUPERBLOCK_SIZE + psize);
-	sbuf = align(ubuf,psize);
-	if (read(d->d_fd,sbuf,SUPERBLOCK_SIZE) != SUPERBLOCK_SIZE)
-		pr(FATAL,"ext2: cannot read spare super block");
+	sbuf = align(ubuf, psize);
+	if (read(d->d_fd, sbuf, SUPERBLOCK_SIZE) != SUPERBLOCK_SIZE)
+		pr(FATAL, "ext2: cannot read spare super block");
 	sparesb = (struct ext2fs_sb *)sbuf;
 
 	/*
diff --git a/src/gm_ext2.h b/src/gm_ext2.h
index 823cebc..f2c2c00 100644
--- a/src/gm_ext2.h
+++ b/src/gm_ext2.h
@@ -1,6 +1,6 @@
 /*
  * gm_ext2.h -- gpart ext2 guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,7 +10,7 @@
  * option) any later version.
  *
  * Created:   04.01.1999 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
diff --git a/src/gm_fat.c b/src/gm_fat.c
index 9fde0bf..5ac07ab 100644
--- a/src/gm_fat.c
+++ b/src/gm_fat.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_fat.c -- gpart fat guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -17,8 +17,7 @@
 #include "gpart.h"
 #include "gm_fat.h"
 
-
-int fat_init(disk_desc *d,g_module *m)
+int fat_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -27,28 +26,22 @@ int fat_init(disk_desc *d,g_module *m)
 	return (sizeof(struct fat_boot_sector));
 }
 
+int fat_term(disk_desc *d) { return (1); }
 
-
-int fat_term(disk_desc *d)
-{
-        return (1);
-}
-
-
-
-int fat_gfun(disk_desc *d,g_module *m)
+int fat_gfun(disk_desc *d, g_module *m)
 {
-	struct fat_boot_sector	*sb = (struct fat_boot_sector *)d->d_sbuf;
-	dos_part_entry		*pt = &m->m_part;
-	unsigned long		nsecs = 0;
-	unsigned char		ig1, ig2, media;
-	int			sectsize, fat32 = 0, fat12 = 0;
-	s64_t			size = 0;
+	struct fat_boot_sector *sb = (struct fat_boot_sector *)d->d_sbuf;
+	dos_part_entry *pt = &m->m_part;
+	unsigned long nsecs = 0;
+	unsigned char ig1, ig2, media;
+	int sectsize, fat32 = 0, fat12 = 0;
+	s64_t size = 0;
 
 	m->m_guess = GM_NO;
-	ig1 = sb->ignored[0]; ig2 = sb->ignored[2]; media = sb->media;
-	if ((ig1 == 0xeb) && (ig2 == 0x90) && ((media == 0xf8) || (media == 0xfc)))
-	{
+	ig1 = sb->ignored[0];
+	ig2 = sb->ignored[2];
+	media = sb->media;
+	if ((ig1 == 0xeb) && (ig2 == 0x90) && ((media == 0xf8) || (media == 0xfc))) {
 		if (*((unsigned short *)d->d_sbuf + 255) != le16(DOSPTMAGIC))
 			return (1);
 
@@ -76,7 +69,6 @@ int fat_gfun(disk_desc *d,g_module *m)
 			return (1);
 		m->m_guess = GM_YES;
 
-
 		/*
 		 * what happens when the fat sectsize != medium sectsize?
 		 * I don't know. I just say no now.
@@ -84,14 +76,14 @@ int fat_gfun(disk_desc *d,g_module *m)
 
 		if (sectsize != d->d_ssize)
 			m->m_guess = GM_NO;
-		size = nsecs; size *= sectsize; size /= 1024;
-		if (size >= 32768)
-		{
+		size = nsecs;
+		size *= sectsize;
+		size /= 1024;
+		if (size >= 32768) {
 			pt->p_typ = 0x06;
 			if (fat32)
 				pt->p_typ = d->d_lba ? 0x0C : 0x0B;
-		}
-		else
+		} else
 			pt->p_typ = fat12 ? 0x01 : 0x04;
 		pt->p_size = nsecs;
 	}
diff --git a/src/gm_fat.h b/src/gm_fat.h
index d205d9c..116ae26 100644
--- a/src/gm_fat.h
+++ b/src/gm_fat.h
@@ -1,6 +1,6 @@
 /*
  * gm_fat.h -- gpart fat guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,20 +10,18 @@
  * option) any later version.
  *
  * Created:   04.01.1999 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
 #ifndef _GM_FAT_H
 #define _GM_FAT_H
 
-
 /*
  * FAT partition boot sector information, taken from the Linux
  * kernel sources.
  */
 
-
 /* imported from asm/types.h */
 typedef __signed__ char __s8;
 typedef unsigned char __u8;
diff --git a/src/gm_hmlvm.c b/src/gm_hmlvm.c
index 2a3d411..3d97751 100644
--- a/src/gm_hmlvm.c
+++ b/src/gm_hmlvm.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_hmlvm.c -- gpart Linux LVM physical volume guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -20,8 +20,7 @@
 #include "gpart.h"
 #include "gm_hmlvm.h"
 
-
-int hmlvm_init(disk_desc *d,g_module *m)
+int hmlvm_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -30,27 +29,18 @@ int hmlvm_init(disk_desc *d,g_module *m)
 	return (LVM_PV_DISK_BASE + LVM_PV_DISK_SIZE);
 }
 
+int hmlvm_term(disk_desc *d) { return (1); }
 
-
-int hmlvm_term(disk_desc *d)
-{
-	return (1);
-}
-
-
-
-int hmlvm_gfun(disk_desc *d,g_module *m)
+int hmlvm_gfun(disk_desc *d, g_module *m)
 {
-	pv_disk_t		*pv;
-	dos_part_entry		*pt = &m->m_part;
-	unsigned int		size;
-	s64_t			s;
+	pv_disk_t *pv;
+	dos_part_entry *pt = &m->m_part;
+	unsigned int size;
+	s64_t s;
 
 	m->m_guess = GM_NO;
 	pv = (pv_disk_t *)&d->d_sbuf[LVM_PV_DISK_BASE];
-	if ((strncmp((char *)pv->id,LVM_ID,sizeof(pv->id)) == 0) &&
-	    ((pv->version == 1) || (pv->version == 2)))
-	{
+	if ((strncmp((char *)pv->id, LVM_ID, sizeof(pv->id)) == 0) && ((pv->version == 1) || (pv->version == 2))) {
 		/*
 		 * looks like a physical volume header. Do the usual
 		 * consistency checks.
@@ -68,12 +58,10 @@ int hmlvm_gfun(disk_desc *d,g_module *m)
 			return (1);
 
 		size = pv->pe_size / LVM_MIN_PE_SIZE * LVM_MIN_PE_SIZE;
-		if ((pv->pe_size != size) ||
-		    (pv->pe_size < LVM_MIN_PE_SIZE) ||
-		    (pv->pe_size > LVM_MAX_PE_SIZE))
+		if ((pv->pe_size != size) || (pv->pe_size < LVM_MIN_PE_SIZE) || (pv->pe_size > LVM_MAX_PE_SIZE))
 			return (1);
 
-		if (pv->pe_total > ( pv->pe_on_disk.size / sizeof ( disk_pe_t)))
+		if (pv->pe_total > (pv->pe_on_disk.size / sizeof(disk_pe_t)))
 			return (1);
 		if (pv->pe_allocated > pv->pe_total)
 			return (1);
@@ -84,7 +72,9 @@ int hmlvm_gfun(disk_desc *d,g_module *m)
 
 		m->m_guess = GM_YES;
 		pt->p_start = d->d_nsb;
-		s = pv->pv_size; s *= 512; s /= d->d_ssize;
+		s = pv->pv_size;
+		s *= 512;
+		s /= d->d_ssize;
 		pt->p_size = s;
 		pt->p_typ = 0x8E;
 	}
diff --git a/src/gm_hmlvm.h b/src/gm_hmlvm.h
index 46b919c..1e08928 100644
--- a/src/gm_hmlvm.h
+++ b/src/gm_hmlvm.h
@@ -1,6 +1,6 @@
 /*
  * gm_hmlvm.h -- gpart Linux LVM physical volume guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,7 +10,7 @@
  * option) any later version.
  *
  * Created:   29.08.1999 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
@@ -66,8 +66,8 @@ typedef struct {
 
 /* disk */
 typedef struct {
-	uint8_t id[2];		/* Identifier */
-	uint16_t version;		/* HM lvm version */
+	uint8_t id[2];	/* Identifier */
+	uint16_t version; /* HM lvm version */
 	lvm_disk_data_t pv_on_disk;
 	lvm_disk_data_t vg_on_disk;
 	lvm_disk_data_t pv_uuidlist_on_disk;
@@ -75,12 +75,12 @@ typedef struct {
 	lvm_disk_data_t pe_on_disk;
 	uint8_t pv_uuid[NAME_LEN];
 	uint8_t vg_name[NAME_LEN];
-	uint8_t system_id[NAME_LEN];	/* for vgexport/vgimport */
+	uint8_t system_id[NAME_LEN]; /* for vgexport/vgimport */
 	uint32_t pv_major;
 	uint32_t pv_number;
 	uint32_t pv_status;
 	uint32_t pv_allocatable;
-	uint32_t pv_size;		/* HM */
+	uint32_t pv_size; /* HM */
 	uint32_t lv_cur;
 	uint32_t pe_size;
 	uint32_t pe_total;
diff --git a/src/gm_hpfs.c b/src/gm_hpfs.c
index e50659e..fca9077 100644
--- a/src/gm_hpfs.c
+++ b/src/gm_hpfs.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_hpfs.c -- gpart hpfs guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -22,11 +22,9 @@
 #include "gpart.h"
 #include "gm_hpfs.h"
 
-#define OS2SECTSIZE		512
+#define OS2SECTSIZE 512
 
-
-
-int hpfs_init(disk_desc *d,g_module *m)
+int hpfs_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -35,45 +33,37 @@ int hpfs_init(disk_desc *d,g_module *m)
 	return (OS2SECTSIZE);
 }
 
+int hpfs_term(disk_desc *d) { return (1); }
 
-
-int hpfs_term(disk_desc *d)
+int hpfs_gfun(disk_desc *d, g_module *m)
 {
-        return (1);
-}
-
-
-
-int hpfs_gfun(disk_desc *d,g_module *m)
-{
-	struct hpfs_boot_block	*bb = (struct hpfs_boot_block *)d->d_sbuf;
-	struct hpfs_super_block	*sb;
-	s64_t			s;
-	size_t			psize;
-	byte_t			*ubuf, *sbuf;
+	struct hpfs_boot_block *bb = (struct hpfs_boot_block *)d->d_sbuf;
+	struct hpfs_super_block *sb;
+	s64_t s;
+	size_t psize;
+	byte_t *ubuf, *sbuf;
 
 	m->m_guess = GM_NO;
-	if (	(bb->sig_28h == 0x28) &&
-		(strncmp((char *)bb->sig_hpfs,"HPFS    ",8) == 0) &&
-		(bb->magic == le16(0xaa55)) &&
-		(bb->bytes_per_sector == le16(OS2SECTSIZE)))
-	{
+	if ((bb->sig_28h == 0x28) && (strncmp((char *)bb->sig_hpfs, "HPFS    ", 8) == 0) && (bb->magic == le16(0xaa55)) &&
+		(bb->bytes_per_sector == le16(OS2SECTSIZE))) {
 		/*
 		 * looks like a hpfs boot sector. Test hpfs superblock
 		 * at sector offset 16 (from start of partition).
 		 */
 
 		if ((s = l64tell(d->d_fd)) == -1)
-			pr(FATAL,"hpfs: cannot seek: %s",strerror(errno));
-		s /= d->d_ssize; s -= d->d_nsb; s *= d->d_ssize;
-		if (l64seek(d->d_fd,16 * OS2SECTSIZE - s,SEEK_CUR) == -1)
-			pr(FATAL,"hpfs: cannot seek: %s",strerror(errno));
+			pr(FATAL, "hpfs: cannot seek: %s", strerror(errno));
+		s /= d->d_ssize;
+		s -= d->d_nsb;
+		s *= d->d_ssize;
+		if (l64seek(d->d_fd, 16 * OS2SECTSIZE - s, SEEK_CUR) == -1)
+			pr(FATAL, "hpfs: cannot seek: %s", strerror(errno));
 
 		psize = getpagesize();
 		ubuf = alloc(OS2SECTSIZE + psize);
-		sbuf = align(ubuf,psize);
-		if (read(d->d_fd,sbuf,OS2SECTSIZE) != OS2SECTSIZE)
-			pr(FATAL,"hpfs: cannot read super block");
+		sbuf = align(ubuf, psize);
+		if (read(d->d_fd, sbuf, OS2SECTSIZE) != OS2SECTSIZE)
+			pr(FATAL, "hpfs: cannot read super block");
 		sb = (struct hpfs_super_block *)sbuf;
 		if (sb->magic != le32(SB_MAGIC))
 			goto out;
@@ -88,7 +78,7 @@ int hpfs_gfun(disk_desc *d,g_module *m)
 		m->m_part.p_start = d->d_nsb;
 		m->m_part.p_size = s;
 		m->m_guess = GM_YES;
-out:
+	out:
 		free((void *)ubuf);
 	}
 	return (1);
diff --git a/src/gm_hpfs.h b/src/gm_hpfs.h
index b06e82e..eaa0942 100644
--- a/src/gm_hpfs.h
+++ b/src/gm_hpfs.h
@@ -1,6 +1,6 @@
 /*
  * gm_hpfs.h -- gpart hpfs guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
diff --git a/src/gm_lswap.c b/src/gm_lswap.c
index e7f4f55..30c013e 100644
--- a/src/gm_lswap.c
+++ b/src/gm_lswap.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_lswap.c -- gpart linux swap guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -18,14 +18,11 @@
 #include <string.h>
 #include "gpart.h"
 
+static char *sigs[] = {"SWAP-SPACE", "SWAPSPACE2"};
+static int pszs[] = {4096, 8192};
+static int siglen = 10;
 
-static char		*sigs[] = { "SWAP-SPACE", "SWAPSPACE2" };
-static int		pszs[] = { 4096, 8192 };
-static int		siglen = 10;
-
-
-
-int lswap_init(disk_desc *d,g_module *m)
+int lswap_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -40,31 +37,24 @@ int lswap_init(disk_desc *d,g_module *m)
 	return (8192);
 }
 
+int lswap_term(disk_desc *d) { return (1); }
 
-
-int lswap_term(disk_desc *d)
-{
-        return (1);
-}
-
-
-
-int lswap_gfun(disk_desc *d,g_module *m)
+int lswap_gfun(disk_desc *d, g_module *m)
 {
-	char		*sig = 0;
-	int		i, j, pagesize, vers;
-	byte_t		*p, b;
-	s64_t		np = 0;
-	dos_part_entry	*pt = &m->m_part;
-
-	m->m_guess = GM_NO; pagesize = vers = 0;
-	for (i = 0; (pagesize == 0) && (i < sizeof(sigs)/sizeof(char *)); i++)
-		for (j = 0; j < sizeof(pszs)/sizeof(int); j++)
-		{
+	char *sig = 0;
+	int i, j, pagesize, vers;
+	byte_t *p, b;
+	s64_t np = 0;
+	dos_part_entry *pt = &m->m_part;
+
+	m->m_guess = GM_NO;
+	pagesize = vers = 0;
+	for (i = 0; (pagesize == 0) && (i < sizeof(sigs) / sizeof(char *)); i++)
+		for (j = 0; j < sizeof(pszs) / sizeof(int); j++) {
 			sig = (char *)(d->d_sbuf + pszs[j] - siglen);
-			if (strncmp(sig,sigs[i],siglen) == 0)
-			{
-				pagesize = pszs[j]; vers = i;
+			if (strncmp(sig, sigs[i], siglen) == 0) {
+				pagesize = pszs[j];
+				vers = i;
 				break;
 			}
 		}
@@ -83,31 +73,31 @@ int lswap_gfun(disk_desc *d,g_module *m)
 		np = (p - d->d_sbuf) * 8;
 		for (b = *p; (b & 0x01) == 1; b >>= 1)
 			np++;
-	}
-	else if (vers == 1) /* Linux > 2.2.X swap partitions */
+	} else if (vers == 1) /* Linux > 2.2.X swap partitions */
 	{
-		struct swapinfo
-		{
-			char		bootbits[1024];
-			unsigned int	version;
-			unsigned int	last_page;
-			unsigned int	nr_badpages;
-			unsigned int	padding[125];
-			unsigned int	badpages[1];
+		struct swapinfo {
+			char bootbits[1024];
+			unsigned int version;
+			unsigned int last_page;
+			unsigned int nr_badpages;
+			unsigned int padding[125];
+			unsigned int badpages[1];
 		} *info = (struct swapinfo *)d->d_sbuf;
 
 		if (info->version != 1)
 			return (1);
 		np = 1 + info->last_page;
-	}
-	else
+	} else
 		return (1);
 
 	if (np >= 10) /* mkswap(8) says this */
 	{
-		np *= pagesize; np /= d->d_ssize;
-		m->m_guess = GM_YES; pt->p_typ = 0x82;
-		pt->p_start = d->d_nsb; pt->p_size = np;
+		np *= pagesize;
+		np /= d->d_ssize;
+		m->m_guess = GM_YES;
+		pt->p_typ = 0x82;
+		pt->p_start = d->d_nsb;
+		pt->p_size = np;
 	}
 	return (1);
 }
diff --git a/src/gm_lvm2.c b/src/gm_lvm2.c
index 23a66b8..4dff3b4 100644
--- a/src/gm_lvm2.c
+++ b/src/gm_lvm2.c
@@ -18,8 +18,7 @@
 #include "gpart.h"
 #include "gm_lvm2.h"
 
-
-int lvm2_init(disk_desc *d,g_module *m)
+int lvm2_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -28,16 +27,9 @@ int lvm2_init(disk_desc *d,g_module *m)
 	return SECTOR_SIZE + LABEL_SIZE;
 }
 
+int lvm2_term(disk_desc *d) { return (1); }
 
-
-int lvm2_term(disk_desc *d)
-{
-	return (1);
-}
-
-
-
-int lvm2_gfun(disk_desc *d,g_module *m)
+int lvm2_gfun(disk_desc *d, g_module *m)
 {
 	struct label_header *lh;
 	struct pv_header *pvh;
@@ -46,14 +38,13 @@ int lvm2_gfun(disk_desc *d,g_module *m)
 	byte_t *p = d->d_sbuf + SECTOR_SIZE;
 
 	m->m_guess = GM_NO;
-	lh = (struct label_header*)p;
-	if (strncmp((char*)lh->id, LABEL_ID, sizeof(lh->id)) ||
-	    strncmp((char*)lh->type, LVM2_LABEL, sizeof(lh->type)))
+	lh = (struct label_header *)p;
+	if (strncmp((char *)lh->id, LABEL_ID, sizeof(lh->id)) || strncmp((char *)lh->type, LVM2_LABEL, sizeof(lh->type)))
 		return 1;
 
-	pvh = (struct pv_header*) ((char*)lh + le32toh(lh->offset_xl));
+	pvh = (struct pv_header *)((char *)lh + le32toh(lh->offset_xl));
 	pv_size = le64toh(pvh->device_size_xl);
-	pv_size /=  d->d_ssize;
+	pv_size /= d->d_ssize;
 	if (d->d_nsecs != 0 && pv_size > d->d_nsecs - d->d_nsb)
 		return 1;
 
diff --git a/src/gm_lvm2.h b/src/gm_lvm2.h
index 0bf4966..183f39f 100644
--- a/src/gm_lvm2.h
+++ b/src/gm_lvm2.h
@@ -40,26 +40,26 @@ typedef unsigned int uint32_t;
 /* On disk - 32 bytes */
 struct label_header {
 	int8_t id[8];		/* LABELONE */
-	uint64_t sector_xl;	/* Sector number of this label */
+	uint64_t sector_xl; /* Sector number of this label */
 	uint32_t crc_xl;	/* From next field to end of sector */
-	uint32_t offset_xl;	/* Offset from start of struct to contents */
+	uint32_t offset_xl; /* Offset from start of struct to contents */
 	int8_t type[8];		/* LVM2 001 */
-} __attribute__ ((packed));
+} __attribute__((packed));
 
 struct disk_locn {
-        uint64_t offset;        /* Offset in bytes to start sector */
-        uint64_t size;          /* Bytes */
-} __attribute__ ((packed));
+	uint64_t offset; /* Offset in bytes to start sector */
+	uint64_t size;   /* Bytes */
+} __attribute__((packed));
 
 struct pv_header {
 	int8_t pv_uuid[ID_LEN];
 
 	/* This size can be overridden if PV belongs to a VG */
-	uint64_t device_size_xl;	/* Bytes */
+	uint64_t device_size_xl; /* Bytes */
 
 	/* NULL-terminated list of data areas followed by */
 	/* NULL-terminated list of metadata area headers */
-	struct disk_locn disk_areas_xl[0];	/* Two lists */
-} __attribute__ ((packed));
+	struct disk_locn disk_areas_xl[0]; /* Two lists */
+} __attribute__((packed));
 
 #endif /* _GM_LVM2_H */
diff --git a/src/gm_minix.c b/src/gm_minix.c
index 98b1ac4..8d06c7d 100644
--- a/src/gm_minix.c
+++ b/src/gm_minix.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_minix.c -- gpart minix guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -17,8 +17,7 @@
 #include "gpart.h"
 #include "gm_minix.h"
 
-
-int minix_init(disk_desc *d,g_module *m)
+int minix_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -26,21 +25,14 @@ int minix_init(disk_desc *d,g_module *m)
 	return (2 * BLOCK_SIZE);
 }
 
+int minix_term(disk_desc *d) { return (1); }
 
-
-int minix_term(disk_desc *d)
-{
-        return (1);
-}
-
-
-
-int minix_gfun(disk_desc *d,g_module *m)
+int minix_gfun(disk_desc *d, g_module *m)
 {
-	long				version = 0;
-	struct minix_super_block	*ms;
-	byte_t				*p;
-	unsigned long			zones, size;
+	long version = 0;
+	struct minix_super_block *ms;
+	byte_t *p;
+	unsigned long zones, size;
 
 	ms = (struct minix_super_block *)(d->d_sbuf + BLOCK_SIZE);
 	m->m_guess = GM_NO;
@@ -64,18 +56,18 @@ int minix_gfun(disk_desc *d,g_module *m)
 	 * was found should be zeroed out.
 	 */
 
-	for (p = d->d_sbuf + BLOCK_SIZE + sizeof(struct minix_super_block);
-		p < d->d_sbuf + 2 * BLOCK_SIZE; p++)
+	for (p = d->d_sbuf + BLOCK_SIZE + sizeof(struct minix_super_block); p < d->d_sbuf + 2 * BLOCK_SIZE; p++)
 		if (*p)
 			return (1);
 
 	zones = (version == MINIX_V2) ? ms->s_zones : ms->s_nzones;
-	size = zones << ms->s_log_zone_size; size *= BLOCK_SIZE;
+	size = zones << ms->s_log_zone_size;
+	size *= BLOCK_SIZE;
 
-        m->m_guess = GM_YES;
-        m->m_part.p_typ = (version == MINIX_V2) ? 0x81 : 0x80;
-        m->m_part.p_start = d->d_nsb;
-        m->m_part.p_size = size / d->d_ssize;
+	m->m_guess = GM_YES;
+	m->m_part.p_typ = (version == MINIX_V2) ? 0x81 : 0x80;
+	m->m_part.p_start = d->d_nsb;
+	m->m_part.p_size = size / d->d_ssize;
 
 	return (1);
 }
diff --git a/src/gm_minix.h b/src/gm_minix.h
index ce028b4..013fad8 100644
--- a/src/gm_minix.h
+++ b/src/gm_minix.h
@@ -1,6 +1,6 @@
 /*
  * gm_minix.h -- gpart minix guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,19 +10,17 @@
  * option) any later version.
  *
  * Created:   04.01.1999 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
 #ifndef _GM_MINIX_H
 #define _GM_MINIX_H
 
-
 /*
  * Minix filesystem structures, taken from the Linux kernel.
  */
 
-
 /* imported from asm/types.h */
 typedef __signed__ char __s8;
 typedef unsigned char __u8;
@@ -106,5 +104,4 @@ struct minix_super_block {
 	__u32 s_zones;
 };
 
-
 #endif /* _GM_MINIX_H */
diff --git a/src/gm_ntfs.c b/src/gm_ntfs.c
index 25bdaad..3e87a73 100644
--- a/src/gm_ntfs.c
+++ b/src/gm_ntfs.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_ntfs.c -- gpart ntfs guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -21,9 +21,9 @@
 #include "gpart.h"
 #include "gm_ntfs.h"
 
-#define NTFS_SECTSIZE	512
+#define NTFS_SECTSIZE 512
 
-int ntfs_init(disk_desc *d,g_module *m)
+int ntfs_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -33,25 +33,16 @@ int ntfs_init(disk_desc *d,g_module *m)
 	return (NTFS_SECTSIZE); /* The ntfs driver in Linux just assumes so */
 }
 
+int ntfs_term(disk_desc *d) { return (1); }
 
-
-int ntfs_term(disk_desc *d)
+int ntfs_gfun(disk_desc *d, g_module *m)
 {
-        return (1);
-}
-
-
-
-int ntfs_gfun(disk_desc *d,g_module *m)
-{
-	int	mft_clusters_per_record;
-	s64_t	size, ls;
-        byte_t	*ubuf, *sbuf;
-
+	int mft_clusters_per_record;
+	s64_t size, ls;
+	byte_t *ubuf, *sbuf;
 
 	m->m_guess = GM_NO;
-	if (IS_NTFS_VOLUME(d->d_sbuf))
-	{
+	if (IS_NTFS_VOLUME(d->d_sbuf)) {
 		/*
 		 * ntfs detection is quite weak, should come before
 		 * fat or hpfs.
@@ -73,14 +64,14 @@ int ntfs_gfun(disk_desc *d,g_module *m)
 		 * sector must be counted).
 		 */
 
-		ls = d->d_nsb + size; ls *= d->d_ssize;
-		if (l64seek(d->d_fd,ls,SEEK_SET) >= 0)
-		{
+		ls = d->d_nsb + size;
+		ls *= d->d_ssize;
+		if (l64seek(d->d_fd, ls, SEEK_SET) >= 0) {
 			ubuf = alloc(NTFS_SECTSIZE + getpagesize());
-			sbuf = align(ubuf,getpagesize());
-			if (read(d->d_fd,sbuf,NTFS_SECTSIZE) != NTFS_SECTSIZE)
-				pr(FATAL,"ntfs: cannot read backup boot sector");
-			if (memcmp(d->d_sbuf,sbuf,NTFS_SECTSIZE) == 0)
+			sbuf = align(ubuf, getpagesize());
+			if (read(d->d_fd, sbuf, NTFS_SECTSIZE) != NTFS_SECTSIZE)
+				pr(FATAL, "ntfs: cannot read backup boot sector");
+			if (memcmp(d->d_sbuf, sbuf, NTFS_SECTSIZE) == 0)
 				size += 1;
 			free((void *)ubuf);
 		}
diff --git a/src/gm_ntfs.h b/src/gm_ntfs.h
index 9aef640..c63f2c5 100644
--- a/src/gm_ntfs.h
+++ b/src/gm_ntfs.h
@@ -1,6 +1,6 @@
 /*
  * gm_ntfs.h -- gpart ntfs guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,7 +10,7 @@
  * option) any later version.
  *
  * Created:   04.01.1999 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
diff --git a/src/gm_qnx4.c b/src/gm_qnx4.c
index f13cbe6..9b8e43c 100644
--- a/src/gm_qnx4.c
+++ b/src/gm_qnx4.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_qnx4.c -- gpart qnx4 guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -22,8 +22,7 @@
 
 #include <stdio.h>
 
-
-int qnx4_init(disk_desc *d,g_module *m)
+int qnx4_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -32,22 +31,15 @@ int qnx4_init(disk_desc *d,g_module *m)
 	return (2 * QNX4_BLOCK_SIZE);
 }
 
+int qnx4_term(disk_desc *d) { return (1); }
 
-
-int qnx4_term(disk_desc *d)
-{
-        return (1);
-}
-
-
-
-int qnx4_gfun(disk_desc *d,g_module *m)
+int qnx4_gfun(disk_desc *d, g_module *m)
 {
-	struct qnx4_super_block	*sb;
-	struct qnx4_inode_entry	*rootdir, bitmap;
-	int			rd, rl, i, j, psize, found;
-	s64_t			ls, ofs, size;
-	byte_t			*ubuf, *sbuf;
+	struct qnx4_super_block *sb;
+	struct qnx4_inode_entry *rootdir, bitmap;
+	int rd, rl, i, j, psize, found;
+	s64_t ls, ofs, size;
+	byte_t *ubuf, *sbuf;
 
 	m->m_guess = GM_NO;
 
@@ -55,7 +47,7 @@ int qnx4_gfun(disk_desc *d,g_module *m)
 	 * check QNX signature
 	 */
 
-	if (memcmp(d->d_sbuf + 4,QNX4_BOOTSECT_SIG,strlen(QNX4_BOOTSECT_SIG)))
+	if (memcmp(d->d_sbuf + 4, QNX4_BOOTSECT_SIG, strlen(QNX4_BOOTSECT_SIG)))
 		return (1);
 	sb = (struct qnx4_super_block *)(d->d_sbuf + QNX4_BLOCK_SIZE);
 	if (*sb->RootDir.di_fname != '/')
@@ -67,40 +59,40 @@ int qnx4_gfun(disk_desc *d,g_module *m)
 
 	psize = getpagesize();
 	ubuf = alloc(QNX4_BLOCK_SIZE + psize);
-	sbuf = align(ubuf,psize);
+	sbuf = align(ubuf, psize);
 
 	found = 0;
 
 	rd = le32(sb->RootDir.di_first_xtnt.xtnt_blk) - 1;
 	rl = le32(sb->RootDir.di_first_xtnt.xtnt_size);
 
-	for (j = 0; j < rl; j++)
-	{
+	for (j = 0; j < rl; j++) {
 		if ((ls = l64tell(d->d_fd)) == -1)
-			pr(FATAL,"qnx4: cannot seek: %s",strerror(errno));
-		ls /= d->d_ssize; ls -= d->d_nsb; ls *= d->d_ssize;
-		ofs = rd + j; ofs *= QNX4_BLOCK_SIZE;
-		if (l64seek(d->d_fd,ofs - ls,SEEK_CUR) == -1)
-			pr(FATAL,"qnx4: cannot seek: %s",strerror(errno));
-		if (read(d->d_fd,sbuf,QNX4_BLOCK_SIZE) != QNX4_BLOCK_SIZE)
-			pr(FATAL,"qnx4: cannot read root dir entry");
+			pr(FATAL, "qnx4: cannot seek: %s", strerror(errno));
+		ls /= d->d_ssize;
+		ls -= d->d_nsb;
+		ls *= d->d_ssize;
+		ofs = rd + j;
+		ofs *= QNX4_BLOCK_SIZE;
+		if (l64seek(d->d_fd, ofs - ls, SEEK_CUR) == -1)
+			pr(FATAL, "qnx4: cannot seek: %s", strerror(errno));
+		if (read(d->d_fd, sbuf, QNX4_BLOCK_SIZE) != QNX4_BLOCK_SIZE)
+			pr(FATAL, "qnx4: cannot read root dir entry");
 
 		/*
 		 * find the ".bitmap" entry
 		 */
 
-		for (i = 0; i < QNX4_INODES_PER_BLOCK; i++)
-		{
-			rootdir = (struct qnx4_inode_entry *) (sbuf + i * QNX4_DIR_ENTRY_SIZE);
-			if (rootdir->di_fname && !strncmp(rootdir->di_fname,QNX4_BITMAP_NAME,strlen(QNX4_BITMAP_NAME)))
-			{
-				memcpy(&bitmap,rootdir,sizeof(struct qnx4_inode_entry));
+		for (i = 0; i < QNX4_INODES_PER_BLOCK; i++) {
+			rootdir = (struct qnx4_inode_entry *)(sbuf + i * QNX4_DIR_ENTRY_SIZE);
+			if (rootdir->di_fname && !strncmp(rootdir->di_fname, QNX4_BITMAP_NAME, strlen(QNX4_BITMAP_NAME))) {
+				memcpy(&bitmap, rootdir, sizeof(struct qnx4_inode_entry));
 				found = 1;
 			}
 		}
 	}
 
-	if (! found)
+	if (!found)
 		return (1);
 
 	size = le32(bitmap.di_size) * 8 - 6;
diff --git a/src/gm_qnx4.h b/src/gm_qnx4.h
index 3de6654..a4b7ef0 100644
--- a/src/gm_qnx4.h
+++ b/src/gm_qnx4.h
@@ -1,6 +1,6 @@
 /*
  * gm_qnx4.h -- gpart qnx4 guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -10,7 +10,7 @@
  * option) any later version.
  *
  * Created:   04.01.2001 <mb@ichabod.han.de>
- * Modified:  
+ * Modified:
  *
  */
 
@@ -88,5 +88,4 @@ struct qnx4_super_block {
 	struct qnx4_inode_entry AltBoot;
 };
 
-
 #endif /* _GM_QNX4_H */
diff --git a/src/gm_reiserfs.c b/src/gm_reiserfs.c
index 4017da3..0a35042 100644
--- a/src/gm_reiserfs.c
+++ b/src/gm_reiserfs.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_reiserfs.c -- gpart ReiserFS guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -22,8 +22,7 @@
 #include "gpart.h"
 #include "gm_reiserfs.h"
 
-
-int reiserfs_init(disk_desc *d,g_module *m)
+int reiserfs_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -32,26 +31,18 @@ int reiserfs_init(disk_desc *d,g_module *m)
 	return (REISERFS_FIRST_BLOCK * 1024 + SB_V35_SIZE);
 }
 
+int reiserfs_term(disk_desc *d) { return (1); }
 
-
-int reiserfs_term(disk_desc *d)
-{
-	return (1);
-}
-
-
-
-int reiserfs_gfun(disk_desc *d,g_module *m)
+int reiserfs_gfun(disk_desc *d, g_module *m)
 {
-	struct reiserfs_super_block_v35	*sb;
-	dos_part_entry			*pt = &m->m_part;
-	s64_t				size;
+	struct reiserfs_super_block_v35 *sb;
+	dos_part_entry *pt = &m->m_part;
+	s64_t size;
 
 	m->m_guess = GM_NO;
 	sb = (struct reiserfs_super_block_v35 *)(d->d_sbuf + REISERFS_FIRST_BLOCK * 1024);
-	if (strncmp(sb->s_magic,REISERFS_SUPER_V35_MAGIC,12) == 0 || 
-	    strncmp(sb->s_magic,REISERFS_SUPER_V36_MAGIC,12) == 0)
-	{
+	if (strncmp(sb->s_magic, REISERFS_SUPER_V35_MAGIC, 12) == 0 ||
+		strncmp(sb->s_magic, REISERFS_SUPER_V36_MAGIC, 12) == 0) {
 		/*
 		 * sanity checks.
 		 */
@@ -62,8 +53,7 @@ int reiserfs_gfun(disk_desc *d,g_module *m)
 		if (sb->s_block_count < REISERFS_MIN_BLOCK_AMOUNT)
 			return (1);
 
-		if ((sb->s_state != REISERFS_VALID_FS) &&
-		    (sb->s_state != REISERFS_ERROR_FS))
+		if ((sb->s_state != REISERFS_VALID_FS) && (sb->s_state != REISERFS_ERROR_FS))
 			return (1);
 
 		if (sb->s_oid_maxsize % 2) /* must be even */
@@ -81,7 +71,9 @@ int reiserfs_gfun(disk_desc *d,g_module *m)
 
 		m->m_guess = GM_YES;
 		pt->p_start = d->d_nsb;
-		size = sb->s_block_count; size *= sb->s_blocksize; size /= d->d_ssize;
+		size = sb->s_block_count;
+		size *= sb->s_blocksize;
+		size /= d->d_ssize;
 		pt->p_size = (unsigned long)size;
 		pt->p_typ = 0x83;
 	}
diff --git a/src/gm_reiserfs.h b/src/gm_reiserfs.h
index c653d16..170cd83 100644
--- a/src/gm_reiserfs.h
+++ b/src/gm_reiserfs.h
@@ -1,6 +1,6 @@
 /*
  * gm_reiserfs.h -- gpart ReiserFS guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
@@ -70,7 +70,7 @@ struct reiserfs_super_block_v35
 
 struct reiserfs_super_block_v36 {
 	struct reiserfs_super_block_v35 s_v35;
-	__u32 s_inode_generation; 
+	__u32 s_inode_generation;
 	__u32 s_flags;
 	char s_uuid[16];
 	char s_label[16];
diff --git a/src/gm_s86dl.c b/src/gm_s86dl.c
index 4831798..73b1d25 100644
--- a/src/gm_s86dl.c
+++ b/src/gm_s86dl.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_s86dl.c -- gpart solaris/x86 disklabel guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -17,8 +17,7 @@
 #include "gpart.h"
 #include "gm_s86dl.h"
 
-
-int s86dl_init(disk_desc *d,g_module *m)
+int s86dl_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -27,36 +26,27 @@ int s86dl_init(disk_desc *d,g_module *m)
 	return (512 + sizeof(struct solaris_x86_vtoc));
 }
 
+int s86dl_term(disk_desc *d) { return (1); }
 
-
-int s86dl_term(disk_desc *d)
-{
-        return (1);
-}
-
-
-
-int s86dl_gfun(disk_desc *d,g_module *m)
+int s86dl_gfun(disk_desc *d, g_module *m)
 {
-	struct solaris_x86_vtoc		*svtoc;
-	struct solaris_x86_slice	*ws = 0, *rs = 0;
-	int				i;
+	struct solaris_x86_vtoc *svtoc;
+	struct solaris_x86_slice *ws = 0, *rs = 0;
+	int i;
 
 	m->m_guess = GM_NO;
 	svtoc = (struct solaris_x86_vtoc *)(d->d_sbuf + 512);
-	if ((svtoc->v_sanity != SOLARIS_X86_VTOC_SANE) ||
-	    (svtoc->v_version != SOLARIS_X86_V_VERSION))
+	if ((svtoc->v_sanity != SOLARIS_X86_VTOC_SANE) || (svtoc->v_version != SOLARIS_X86_V_VERSION))
 		return (1);
 
 	for (i = 0; i < SOLARIS_X86_NUMSLICE; i++)
-		switch (svtoc->v_slice[i].s_tag)
-		{
-			case SOLARIS_X86_V_ROOT :
-				rs = &svtoc->v_slice[i];
-				break;
-			case SOLARIS_X86_V_BACKUP :
-				ws = &svtoc->v_slice[i];
-				break;
+		switch (svtoc->v_slice[i].s_tag) {
+		case SOLARIS_X86_V_ROOT:
+			rs = &svtoc->v_slice[i];
+			break;
+		case SOLARIS_X86_V_BACKUP:
+			ws = &svtoc->v_slice[i];
+			break;
 		}
 
 	/*
@@ -73,11 +63,9 @@ int s86dl_gfun(disk_desc *d,g_module *m)
 		return (1);
 	if ((rs->s_start < ws->s_start) || (rs->s_size > ws->s_size))
 		return (1);
-	if (ws->s_flag && (ws->s_flag != SOLARIS_X86_V_UNMNT) &&
-	    (ws->s_flag != SOLARIS_X86_V_RONLY))
+	if (ws->s_flag && (ws->s_flag != SOLARIS_X86_V_UNMNT) && (ws->s_flag != SOLARIS_X86_V_RONLY))
 		return (1);
-	if (rs->s_flag && (rs->s_flag != SOLARIS_X86_V_UNMNT) &&
-	    (rs->s_flag != SOLARIS_X86_V_RONLY))
+	if (rs->s_flag && (rs->s_flag != SOLARIS_X86_V_UNMNT) && (rs->s_flag != SOLARIS_X86_V_RONLY))
 		return (1);
 
 	/*
diff --git a/src/gm_s86dl.h b/src/gm_s86dl.h
index ab54c29..3bbd976 100644
--- a/src/gm_s86dl.h
+++ b/src/gm_s86dl.h
@@ -1,6 +1,6 @@
 /*
  * gm_s86dl.h -- gpart solaris/x86 disklabel guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
diff --git a/src/gm_xfs.c b/src/gm_xfs.c
index 8e8d268..800f8fb 100644
--- a/src/gm_xfs.c
+++ b/src/gm_xfs.c
@@ -1,4 +1,4 @@
-/*      
+/*
  * gm_xfs.c -- gpart SGI xfs guessing module
  *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
@@ -18,8 +18,7 @@
 #include "gpart.h"
 #include "gm_xfs.h"
 
-
-int xfs_init(disk_desc *d,g_module *m)
+int xfs_init(disk_desc *d, g_module *m)
 {
 	if ((d == 0) || (m == 0))
 		return (0);
@@ -28,19 +27,12 @@ int xfs_init(disk_desc *d,g_module *m)
 	return (512);
 }
 
+int xfs_term(disk_desc *d) { return (1); }
 
-
-int xfs_term(disk_desc *d)
-{
-	return (1);
-}
-
-
-
-int xfs_gfun(disk_desc *d,g_module *m)
+int xfs_gfun(disk_desc *d, g_module *m)
 {
-	xfs_sb_t		*sb;
-	s64_t			size;
+	xfs_sb_t *sb;
+	s64_t size;
 
 	m->m_guess = GM_NO;
 	sb = (xfs_sb_t *)d->d_sbuf;
@@ -58,8 +50,7 @@ int xfs_gfun(disk_desc *d,g_module *m)
 	if ((sb->sb_imax_pct > 100) || (sb->sb_sectsize <= 0))
 		return (1);
 
-	if ((be16(sb->sb_inodesize) < XFS_DINODE_MIN_SIZE) ||
-	    (be16(sb->sb_inodesize) > XFS_DINODE_MAX_SIZE))
+	if ((be16(sb->sb_inodesize) < XFS_DINODE_MIN_SIZE) || (be16(sb->sb_inodesize) > XFS_DINODE_MAX_SIZE))
 		return (1);
 
 	if (be32(sb->sb_blocksize) != 1 << sb->sb_blocklog)
diff --git a/src/gm_xfs.h b/src/gm_xfs.h
index a7d96c3..81a9d65 100644
--- a/src/gm_xfs.h
+++ b/src/gm_xfs.h
@@ -1,6 +1,6 @@
 /*
  * gm_xfs.h -- gpart SGI xfs guessing module header
- * 
+ *
  * gpart (c) 1999-2001 Michail Brzitwa <mb@ichabod.han.de>
  * Guess PC-type hard disk partitions.
  *
diff --git a/src/gmodules.c b/src/gmodules.c
index d2f849e..544b4a2 100644
--- a/src/gmodules.c
+++ b/src/gmodules.c
@@ -20,79 +20,60 @@
 #include <string.h>
 #include "gpart.h"
 
+static g_module *g_head;
+static int g_count;
 
-static g_module		*g_head;
-static int		g_count;
-
-
-
-g_module *g_mod_head()
-{
-	return (g_head);
-}
-
-
-
-int g_mod_count()
-{
-	return (g_count);
-}
-
+g_module *g_mod_head() { return (g_head); }
 
+int g_mod_count() { return (g_count); }
 
 void g_mod_list()
 {
-	g_module	*m;
+	g_module *m;
 
-	pr(MSG,"Module\tWeight\n");
+	pr(MSG, "Module\tWeight\n");
 	for (m = g_head; m; m = m->m_next)
-		pr(MSG,"%s\t(%3.1f)\n",m->m_name,m->m_weight);
-	pr(MSG,"\n");
+		pr(MSG, "%s\t(%3.1f)\n", m->m_name, m->m_weight);
+	pr(MSG, "\n");
 }
 
-
-
 void g_mod_delete(g_module *m)
 {
-	if (m)
-	{
-		if (m->m_name) free((void *)m->m_name);
+	if (m) {
+		if (m->m_name)
+			free((void *)m->m_name);
 		free(m);
 		g_count--;
 	}
 }
 
-
-
 void g_mod_deleteall()
 {
-	g_module	*m;
+	g_module *m;
 
-	while (g_head)
-	{
-		m = g_head->m_next; g_mod_delete(g_head); g_head = m;
+	while (g_head) {
+		m = g_head->m_next;
+		g_mod_delete(g_head);
+		g_head = m;
 	}
 }
 
-
-
 /*
- * set weight of module and re-insert as head. 
+ * set weight of module and re-insert as head.
  */
 
-g_module *g_mod_setweight(char *name,float weight)
+g_module *g_mod_setweight(char *name, float weight)
 {
-	g_module	*m, *prev = 0;
+	g_module *m, *prev = 0;
 
 	for (m = g_head; m; m = m->m_next)
-		if (strcmp(m->m_name,name) == 0)
+		if (strcmp(m->m_name, name) == 0)
 			break;
 		else
 			prev = m;
 	if (m == 0)
 		return (0);
-	if (prev)
-	{
+	if (prev) {
 		prev->m_next = m->m_next;
 		m->m_next = g_head;
 		g_head = m;
@@ -101,23 +82,18 @@ g_module *g_mod_setweight(char *name,float weight)
 	return (g_head);
 }
 
-
-
-g_module *g_mod_lookup(int how,char *name)
+g_module *g_mod_lookup(int how, char *name)
 {
-	g_module	*m;
+	g_module *m;
 
-	if (g_head == 0)
-	{
+	if (g_head == 0) {
 		if (how == GM_LOOKUP)
 			return (0);
 		g_head = (g_module *)alloc(sizeof(g_module));
 		m = g_head;
-	}
-	else
-	{
+	} else {
 		for (m = g_head; m->m_next; m = m->m_next)
-			if (strcmp(m->m_name,name) == 0)
+			if (strcmp(m->m_name, name) == 0)
 				return (m);
 		if (how == GM_LOOKUP)
 			return (0);
@@ -125,8 +101,9 @@ g_module *g_mod_lookup(int how,char *name)
 		m = m->m_next;
 	}
 	if ((m->m_name = strdup(name)) == 0)
-		pr(FATAL,"out of memory in strdup");
-	m->m_weight = 1.0; g_count++;
+		pr(FATAL, "out of memory in strdup");
+	m->m_weight = 1.0;
+	g_count++;
 	return (m);
 }
 
@@ -148,10 +125,10 @@ void g_mod_addinternals()
 		} \
 	} while (0);
 
-	/*
-	 * If no weights are given on the command line, the order
-	 * is somehow important.
-	 */
+/*
+ * If no weights are given on the command line, the order
+ * is somehow important.
+ */
 
 #define G_MODULE(mod) GMODINS(mod)
 G_MODULES
diff --git a/src/gpart.c b/src/gpart.c
index 8555f66..936ceb0 100644
--- a/src/gpart.c
+++ b/src/gpart.c
@@ -13,7 +13,7 @@
  * Modified:  11.06.1999 <mb@ichabod.han.de>
  *            Handle disk read errors.
  *            Minor fixes.
- * 
+ *
  *            29.06.1999 <mb@ichabod.han.de>
  *            Made every disk read/write buffer aligned to pagesize.
  *
@@ -21,7 +21,7 @@
  *            Default scan increment now 's'.
  *            Extended ptbl boundary condition now depends on scan
  *            increment.
- * 
+ *
  *            26.02.2000 <mb@ichabod.han.de>
  *            Default scan increment 'h' again.
  *            Fixed faulty head boundary condition.
@@ -45,7 +45,6 @@
  *
  */
 
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
@@ -58,317 +57,304 @@
 #include <sys/types.h>
 #include "gpart.h"
 
+static const char *gpart_version = PACKAGE_NAME " v" VERSION;
 
-static const char	*gpart_version = PACKAGE_NAME " v" VERSION;
-
-
-int		f_check = 0, f_verbose = 0, f_dontguess = 0, f_fast = 1;
-int		f_getgeom = 1, f_interactive = 0, f_quiet = 0, f_testext = 1;
-int		f_skiperrors = 1, berrno = 0;
-int		(*boundary_fun)(disk_desc *,s64_t);
-unsigned long	increment = 's', gc = 0, gh = 0, gs = 0;
-s64_t		skipsec = 0, maxsec = 0;
-FILE		*logfile = 0;
-
-
+int f_check = 0, f_verbose = 0, f_dontguess = 0, f_fast = 1;
+int f_getgeom = 1, f_interactive = 0, f_quiet = 0, f_testext = 1;
+int f_skiperrors = 1, berrno = 0;
+int (*boundary_fun)(disk_desc *, s64_t);
+unsigned long increment = 's', gc = 0, gh = 0, gs = 0;
+s64_t skipsec = 0, maxsec = 0;
+FILE *logfile = 0;
 
 void usage()
 {
-	FILE		*fp = stderr;
-
-	fprintf(fp,"Usage: %s [options] device\n",PACKAGE_NAME);
-	fprintf(fp,"Options: [-b <backup MBR>][-C c,h,s][-c][-d][-E][-e][-f][-g][-h][-i]\n");
-	fprintf(fp,"         [-K <last sector>][-k <# of sectors>][-L][-l <log file>]\n");
-	fprintf(fp,"         [-n <increment>][-q][-s <sector-size>]\n");
-	fprintf(fp,"         [-V][-v][-W <device>][-w <module-name,weight>]\n");
-	fprintf(fp,"%s (c) 1999-2001 Michail Brzitwa <michail@brzitwa.de>.\n",gpart_version);
-	fprintf(fp,"Guess PC-type hard disk partitions.\n\n");
-	fprintf(fp,"Options:\n");
-	fprintf(fp," -b  Save a backup of the original MBR to specified file.\n");
-	fprintf(fp," -C  Set c/h/s to be used in the scan.\n");
-	fprintf(fp," -c  Check/compare mode.\n");
-	fprintf(fp," -d  Do not start the guessing loop.\n");
-	fprintf(fp," -E  Do not try to identify extended partition tables.\n");
-	fprintf(fp," -e  Do not skip disk read errors.\n");
-	fprintf(fp," -f  Full scan.\n");
-	fprintf(fp," -g  Do not try to get the disk geometry.\n");
-	fprintf(fp," -h  Show this help.\n");
-	fprintf(fp," -i  Run interactively (ask for confirmation).\n");
-	fprintf(fp," -K  Scan only up to given sector.\n");
-	fprintf(fp," -k  Skip sectors before scan.\n");
-	fprintf(fp," -L  List available modules and their weights, then exit.\n");
-	fprintf(fp," -l  Logfile name.\n");
-	fprintf(fp," -n  Scan increment: number or 's' sector, 'h' head, 'c' cylinder.\n");
-	fprintf(fp," -q  Run quiet (however log file is written if specified).\n");
-	fprintf(fp," -s  Sector size to use (disable sector size probing).\n");
-	fprintf(fp," -V  Show version.\n");
-	fprintf(fp," -v  Verbose mode. Can be given more than once.\n");
-	fprintf(fp," -W  Write guessed primary partition table to given device or file.\n");
-	fprintf(fp," -w  Weight factor of module.\n");
-	fprintf(fp,"\n");
+	FILE *fp = stderr;
+
+	fprintf(fp, "Usage: %s [options] device\n", PACKAGE_NAME);
+	fprintf(fp, "Options: [-b <backup MBR>][-C c,h,s][-c][-d][-E][-e][-f][-g][-h][-i]\n");
+	fprintf(fp, "         [-K <last sector>][-k <# of sectors>][-L][-l <log file>]\n");
+	fprintf(fp, "         [-n <increment>][-q][-s <sector-size>]\n");
+	fprintf(fp, "         [-V][-v][-W <device>][-w <module-name,weight>]\n");
+	fprintf(fp, "%s (c) 1999-2001 Michail Brzitwa <michail@brzitwa.de>.\n", gpart_version);
+	fprintf(fp, "Guess PC-type hard disk partitions.\n\n");
+	fprintf(fp, "Options:\n");
+	fprintf(fp, " -b  Save a backup of the original MBR to specified file.\n");
+	fprintf(fp, " -C  Set c/h/s to be used in the scan.\n");
+	fprintf(fp, " -c  Check/compare mode.\n");
+	fprintf(fp, " -d  Do not start the guessing loop.\n");
+	fprintf(fp, " -E  Do not try to identify extended partition tables.\n");
+	fprintf(fp, " -e  Do not skip disk read errors.\n");
+	fprintf(fp, " -f  Full scan.\n");
+	fprintf(fp, " -g  Do not try to get the disk geometry.\n");
+	fprintf(fp, " -h  Show this help.\n");
+	fprintf(fp, " -i  Run interactively (ask for confirmation).\n");
+	fprintf(fp, " -K  Scan only up to given sector.\n");
+	fprintf(fp, " -k  Skip sectors before scan.\n");
+	fprintf(fp, " -L  List available modules and their weights, then exit.\n");
+	fprintf(fp, " -l  Logfile name.\n");
+	fprintf(fp, " -n  Scan increment: number or 's' sector, 'h' head, 'c' cylinder.\n");
+	fprintf(fp, " -q  Run quiet (however log file is written if specified).\n");
+	fprintf(fp, " -s  Sector size to use (disable sector size probing).\n");
+	fprintf(fp, " -V  Show version.\n");
+	fprintf(fp, " -v  Verbose mode. Can be given more than once.\n");
+	fprintf(fp, " -W  Write guessed primary partition table to given device or file.\n");
+	fprintf(fp, " -w  Weight factor of module.\n");
+	fprintf(fp, "\n");
 }
 
-
-
-void pr(int type,char *fmt,...)
+void pr(int type, char *fmt, ...)
 {
-	va_list		vl;
-	static char	msg[512];
-
-	va_start(vl,fmt); vsnprintf(msg,511,fmt,vl); va_end(vl); msg[511] = 0;
-	switch (type)
-	{
-		case FATAL :
-			g_mod_deleteall();
-			if (! f_quiet) fprintf(stderr,EM_FATALERROR,msg);
-			if (logfile)
-			{
-				fprintf(logfile,EM_FATALERROR,msg);
-				fclose(logfile);
-			}
-			exit(1);
-		case ERROR :
-			if (! f_quiet) fprintf(stderr,EM_SIMPLEERROR,msg);
-			if (logfile) fprintf(logfile,EM_SIMPLEERROR,msg);
-			break;
-		case WARN :
-			if (! f_quiet) fprintf(stderr,EM_WARNING,msg);
-			if (logfile) fprintf(logfile,EM_WARNING,msg);
-			break;
-		case MSG :
-			if (! f_quiet) fputs(msg,stdout); fflush(stdout);
-			if (logfile) fputs(msg,logfile);
-			break;
+	va_list vl;
+	static char msg[512];
+
+	va_start(vl, fmt);
+	vsnprintf(msg, 511, fmt, vl);
+	va_end(vl);
+	msg[511] = 0;
+	switch (type) {
+	case FATAL:
+		g_mod_deleteall();
+		if (!f_quiet)
+			fprintf(stderr, EM_FATALERROR, msg);
+		if (logfile) {
+			fprintf(logfile, EM_FATALERROR, msg);
+			fclose(logfile);
+		}
+		exit(1);
+	case ERROR:
+		if (!f_quiet)
+			fprintf(stderr, EM_SIMPLEERROR, msg);
+		if (logfile)
+			fprintf(logfile, EM_SIMPLEERROR, msg);
+		break;
+	case WARN:
+		if (!f_quiet)
+			fprintf(stderr, EM_WARNING, msg);
+		if (logfile)
+			fprintf(logfile, EM_WARNING, msg);
+		break;
+	case MSG:
+		if (!f_quiet)
+			fputs(msg, stdout);
+		fflush(stdout);
+		if (logfile)
+			fputs(msg, logfile);
+		break;
 	}
-	if (logfile) fflush(logfile);
+	if (logfile)
+		fflush(logfile);
 }
 
-
-
 byte_t *alloc(ssize_t s)
 {
-	byte_t		*p = (byte_t *)malloc(s);
+	byte_t *p = (byte_t *)malloc(s);
 
 	if (p == 0)
-		pr(FATAL,EM_MALLOCFAILED,s);
-	memset(p,0,s);
+		pr(FATAL, EM_MALLOCFAILED, s);
+	memset(p, 0, s);
 	return (p);
 }
 
-
-
 /*
  * read nsecs blocks of ssize bytes from fd
  */
 
-ssize_t bread(int fd,byte_t *buf,size_t ssize,size_t nsecs)
+ssize_t bread(int fd, byte_t *buf, size_t ssize, size_t nsecs)
 {
-	ssize_t		cs = 0, nr = 0;
+	ssize_t cs = 0, nr = 0;
 
-	for ( ; nsecs > 0; nsecs--)
-	{
-		if ((nr = read(fd,buf,ssize)) == -1)
-		{
+	for (; nsecs > 0; nsecs--) {
+		if ((nr = read(fd, buf, ssize)) == -1) {
 			berrno = errno;
 			return ((cs == 0) ? -1 : cs);
 		}
-		cs += nr; buf += nr;
+		cs += nr;
+		buf += nr;
 		if (nr < ssize)
 			break;
 	}
 	return (cs);
 }
 
-
-
 static int yesno(char *q)
 {
-	int		ch = 0;
-	char		buf[3];
-
-	pr(MSG,q); pr(MSG," %s : ",DM_YESNO);
-	if (fgets(buf,3,stdin)) ch = *buf; pr(MSG,"\n");
-	return (strchr(DM_YES,ch) == 0 ? 0 : 1);
+	int ch = 0;
+	char buf[3];
+
+	pr(MSG, q);
+	pr(MSG, " %s : ", DM_YESNO);
+	if (fgets(buf, 3, stdin))
+		ch = *buf;
+	pr(MSG, "\n");
+	return (strchr(DM_YES, ch) == 0 ? 0 : 1);
 }
 
-
-
-static long number_or_quit(char *m,long lo,long up)
+static long number_or_quit(char *m, long lo, long up)
 {
-	char		buf[32];
-	long		num = -1;
+	char buf[32];
+	long num = -1;
 
-	pr(MSG,m); pr(MSG,DM_NUMORQUIT,lo,up);
-	if (fgets(buf,32,stdin))
-	{
-		if (strchr(DM_QUIT,*buf))
+	pr(MSG, m);
+	pr(MSG, DM_NUMORQUIT, lo, up);
+	if (fgets(buf, 32, stdin)) {
+		if (strchr(DM_QUIT, *buf))
 			return (-1);
-		num = strtoul(buf,0,0);
+		num = strtoul(buf, 0, 0);
 		if (errno == ERANGE)
 			return (-1);
 	}
 	return (num);
 }
 
-
-
 /*
  * get three comma separated strings.
  */
 
-static int get_csep_arg(char *arg,char **p1,char **p2,char **p3)
+static int get_csep_arg(char *arg, char **p1, char **p2, char **p3)
 {
-	char		*p;
-
-	if (p1) *p1 = arg; else return (0);
-	if ((p = strchr(arg,',')) == 0) return (0);
-	*p = 0; arg = p + 1;
-	if (p2) *p2 = arg; else return (1);
-	if (p3)
-	{
-		if ((p = strchr(arg,',')) == 0) return (0);
-		*p = 0; *p3 = p + 1;
+	char *p;
+
+	if (p1)
+		*p1 = arg;
+	else
+		return (0);
+	if ((p = strchr(arg, ',')) == 0)
+		return (0);
+	*p = 0;
+	arg = p + 1;
+	if (p2)
+		*p2 = arg;
+	else
+		return (1);
+	if (p3) {
+		if ((p = strchr(arg, ',')) == 0)
+			return (0);
+		*p = 0;
+		*p3 = p + 1;
 	}
 	return (1);
 }
 
-
-
 /*
  * partition type list, taken from *BSD i386 fdisk, cfdisk etc.
  */
 
 static char *get_part_type(int type)
 {
-	int		i;
-	struct
-	{
-		int	t;
-		char	*n;
-	} ptypes[] =
-	{
-		{ 0x00, "unused" },
-		{ 0x01, "Primary DOS with 12 bit FAT" },
-		{ 0x02, "XENIX / filesystem" },
-		{ 0x03, "XENIX /usr filesystem" },
-		{ 0x04, "Primary DOS with 16 bit FAT (<= 32MB)" },
-		{ 0x05, "Extended DOS" },
-		{ 0x06, "Primary 'big' DOS (> 32MB)" },
-		{ 0x07, "OS/2 HPFS, NTFS, QNX or Advanced UNIX" },
-		{ 0x08, "AIX filesystem" },
-		{ 0x09, "AIX boot partition or Coherent" },
-		{ 0x0A, "OS/2 Boot Manager or OPUS" },
-		{ 0x0B, "DOS or Windows 95 with 32 bit FAT" },
-		{ 0x0C, "DOS or Windows 95 with 32 bit FAT, LBA" },
-		{ 0x0E, "Primary 'big' DOS (> 32MB, LBA)" },
-		{ 0x0F, "Extended DOS, LBA" },
-		{ 0x10, "OPUS" },
-		{ 0x11, "Hidden DOS with 12 bit FAT" },
-		{ 0x12,	"Compaq Diagnostics" },
-		{ 0x14, "Hidden DOS with 16 bit FAT (<= 32MB)" },
-		{ 0x16, "Hidden 'big' DOS (> 32MB)" },
-		{ 0x17, "OS/2 Boot Manager HPFS" },
-		{ 0x18, "AST special Windows swap file" },
-		{ 0x24, "NEC MS-DOS 3.x" },
-		{ 0x3C, "PowerQuest PartitionMagic recovery partition" },
-		{ 0x40, "VENIX 286" },
-		{ 0x4D, "QNX4.x" },
-		{ 0x4E, "QNX4.x 2nd part" },
-		{ 0x4F, "QNX4.x 3rd part" },
-		{ 0x50, "DM" },
-		{ 0x51, "DM" },
-		{ 0x51, "DM" },
-		{ 0x52, "CP/M or Microport SysV/AT" },
-		{ 0x55, "EZ Drive" },
-		{ 0x56, "GB" },
-		{ 0x61, "SpeedStor" },
-		{ 0x63, "ISC UNIX, other System V/386, GNU HURD or Mach" },
-		{ 0x64, "Novell Netware 2.xx" },
-		{ 0x65, "Novell Netware 3.xx" },
-		{ 0x70, "DiskSecure Multi-Boot" },
-		{ 0x75, "PCIX" },
-		{ 0x80, "Minix V1" },
-		{ 0x81, "Minix V2/Linux" },
-		{ 0x82, "Linux swap or Solaris/x86" },
-		{ 0x83, "Linux ext2 filesystem" },
-		{ 0x85, "Extended Linux" },
-		{ 0x86, "FAT16 volume/stripe set" },
-		{ 0x8E, "Linux LVM physical volume" },
-		{ 0x93, "Amoeba filesystem" },
-		{ 0x94, "Amoeba bad block table" },
-		{ 0xA5, "FreeBSD/NetBSD/386BSD" },
-		{ 0xA6, "OpenBSD" },
-		{ 0xA7, "NEXTSTEP" },
-		{ 0xB7, "BSDI BSD/386 filesystem" },
-		{ 0xB8, "BSDI BSD/386 swap" },
-		{ 0xC7, "Syrinx" },
-		{ 0xDB, "Concurrent CPM or C.DOS or CTOS" },
-		{ 0xE1, "SpeedStor 12-bit FAT extended" },
-		{ 0xE3, "Speed" },
-		{ 0xE4, "SpeedStor 16-bit FAT" },
-		{ 0xEB, "BeOS fs" },
-		{ 0xF1, "SpeedStor" },
-		{ 0xF2, "DOS 3.3+ Secondary" },
-		{ 0xF4, "SpeedStor" },
-		{ 0xFD, "Linux raid autodetect" },
-		{ 0xFE, "LANstep" },
-		{ 0xFF, "BBT (Bad Blocks Table)" }
-	};
-
-	for (i = 0; i < sizeof(ptypes)/sizeof(ptypes[0]); i++)
+	int i;
+	struct {
+		int t;
+		char *n;
+	} ptypes[] = {{0x00, "unused"},
+				  {0x01, "Primary DOS with 12 bit FAT"},
+				  {0x02, "XENIX / filesystem"},
+				  {0x03, "XENIX /usr filesystem"},
+				  {0x04, "Primary DOS with 16 bit FAT (<= 32MB)"},
+				  {0x05, "Extended DOS"},
+				  {0x06, "Primary 'big' DOS (> 32MB)"},
+				  {0x07, "OS/2 HPFS, NTFS, QNX or Advanced UNIX"},
+				  {0x08, "AIX filesystem"},
+				  {0x09, "AIX boot partition or Coherent"},
+				  {0x0A, "OS/2 Boot Manager or OPUS"},
+				  {0x0B, "DOS or Windows 95 with 32 bit FAT"},
+				  {0x0C, "DOS or Windows 95 with 32 bit FAT, LBA"},
+				  {0x0E, "Primary 'big' DOS (> 32MB, LBA)"},
+				  {0x0F, "Extended DOS, LBA"},
+				  {0x10, "OPUS"},
+				  {0x11, "Hidden DOS with 12 bit FAT"},
+				  {0x12, "Compaq Diagnostics"},
+				  {0x14, "Hidden DOS with 16 bit FAT (<= 32MB)"},
+				  {0x16, "Hidden 'big' DOS (> 32MB)"},
+				  {0x17, "OS/2 Boot Manager HPFS"},
+				  {0x18, "AST special Windows swap file"},
+				  {0x24, "NEC MS-DOS 3.x"},
+				  {0x3C, "PowerQuest PartitionMagic recovery partition"},
+				  {0x40, "VENIX 286"},
+				  {0x4D, "QNX4.x"},
+				  {0x4E, "QNX4.x 2nd part"},
+				  {0x4F, "QNX4.x 3rd part"},
+				  {0x50, "DM"},
+				  {0x51, "DM"},
+				  {0x51, "DM"},
+				  {0x52, "CP/M or Microport SysV/AT"},
+				  {0x55, "EZ Drive"},
+				  {0x56, "GB"},
+				  {0x61, "SpeedStor"},
+				  {0x63, "ISC UNIX, other System V/386, GNU HURD or Mach"},
+				  {0x64, "Novell Netware 2.xx"},
+				  {0x65, "Novell Netware 3.xx"},
+				  {0x70, "DiskSecure Multi-Boot"},
+				  {0x75, "PCIX"},
+				  {0x80, "Minix V1"},
+				  {0x81, "Minix V2/Linux"},
+				  {0x82, "Linux swap or Solaris/x86"},
+				  {0x83, "Linux ext2 filesystem"},
+				  {0x85, "Extended Linux"},
+				  {0x86, "FAT16 volume/stripe set"},
+				  {0x8E, "Linux LVM physical volume"},
+				  {0x93, "Amoeba filesystem"},
+				  {0x94, "Amoeba bad block table"},
+				  {0xA5, "FreeBSD/NetBSD/386BSD"},
+				  {0xA6, "OpenBSD"},
+				  {0xA7, "NEXTSTEP"},
+				  {0xB7, "BSDI BSD/386 filesystem"},
+				  {0xB8, "BSDI BSD/386 swap"},
+				  {0xC7, "Syrinx"},
+				  {0xDB, "Concurrent CPM or C.DOS or CTOS"},
+				  {0xE1, "SpeedStor 12-bit FAT extended"},
+				  {0xE3, "Speed"},
+				  {0xE4, "SpeedStor 16-bit FAT"},
+				  {0xEB, "BeOS fs"},
+				  {0xF1, "SpeedStor"},
+				  {0xF2, "DOS 3.3+ Secondary"},
+				  {0xF4, "SpeedStor"},
+				  {0xFD, "Linux raid autodetect"},
+				  {0xFE, "LANstep"},
+				  {0xFF, "BBT (Bad Blocks Table)"}};
+
+	for (i = 0; i < sizeof(ptypes) / sizeof(ptypes[0]); i++)
 		if (type == ptypes[i].t)
 			return (ptypes[i].n);
 	return (0);
 }
 
-
-
 static int is_ext_parttype(dos_part_entry *p)
 {
-	return (p->p_size && ((p->p_typ == 0x05) ||
-		(p->p_typ == 0x0F) || (p->p_typ == 0x85)));
+	return (p->p_size && ((p->p_typ == 0x05) || (p->p_typ == 0x0F) || (p->p_typ == 0x85)));
 }
 
-
-
-static int is_sane_partentry(disk_desc *d,dos_part_entry *p,int c)
+static int is_sane_partentry(disk_desc *d, dos_part_entry *p, int c)
 {
-	if (p->p_start >= d->d_nsecs)
-	{
-		if (c) pr(WARN,EM_PSTART2BIG,get_part_type(p->p_typ));
+	if (p->p_start >= d->d_nsecs) {
+		if (c)
+			pr(WARN, EM_PSTART2BIG, get_part_type(p->p_typ));
 		return (0);
 	}
-	if (p->p_size > d->d_nsecs)
-	{
-		if (c) pr(WARN,EM_PSIZE2BIG,get_part_type(p->p_typ));
+	if (p->p_size > d->d_nsecs) {
+		if (c)
+			pr(WARN, EM_PSIZE2BIG, get_part_type(p->p_typ));
 		return (0);
 	}
-	if (p->p_start + p->p_size > d->d_nsecs)
-	{
-		if (c) pr(WARN,EM_PEND2BIG,get_part_type(p->p_typ));
+	if (p->p_start + p->p_size > d->d_nsecs) {
+		if (c)
+			pr(WARN, EM_PEND2BIG, get_part_type(p->p_typ));
 		return (0);
 	}
-	if (p->p_flag && (p->p_flag != DOSPARTACTIVE))
-	{
-		if (c) pr(WARN,EM_STRANGEPTYPE,get_part_type(p->p_typ));
+	if (p->p_flag && (p->p_flag != DOSPARTACTIVE)) {
+		if (c)
+			pr(WARN, EM_STRANGEPTYPE, get_part_type(p->p_typ));
 		return (0);
 	}
 	return (1);
 }
 
-
-
-static int is_real_parttype(dos_part_entry *p)
-{
-	return (!is_ext_parttype(p) && p->p_typ && get_part_type(p->p_typ));
-}
-
-
+static int is_real_parttype(dos_part_entry *p) { return (!is_ext_parttype(p) && p->p_typ && get_part_type(p->p_typ)); }
 
 static int no_of_ext_partitions(dos_part_entry *p)
 {
-	dos_part_entry	*t;
-	int		ne = 0;
+	dos_part_entry *t;
+	int ne = 0;
 
 	for (t = &p[0]; t <= &p[NDOSPARTS - 1]; t++)
 		if (is_ext_parttype(t))
@@ -376,12 +362,10 @@ static int no_of_ext_partitions(dos_part_entry *p)
 	return (ne);
 }
 
-
-
 static int no_of_real_partitions(dos_part_entry *p)
 {
-	dos_part_entry	*t;
-	int		nr = 0;
+	dos_part_entry *t;
+	int nr = 0;
 
 	for (t = &p[0]; t <= &p[NDOSPARTS - 1]; t++)
 		if (is_real_parttype(t))
@@ -389,47 +373,48 @@ static int no_of_real_partitions(dos_part_entry *p)
 	return (nr);
 }
 
-
-
 /*
  * Test similarity of partition types
  */
 
-static int is_same_partition_type(dos_part_entry *p1,dos_part_entry *p2)
+static int is_same_partition_type(dos_part_entry *p1, dos_part_entry *p2)
 {
-	int		ret = 0;
-
-	switch (p1->p_typ)
-	{
-		case 0x01: case 0x11:
-			ret = (p2->p_typ == 0x06) || (p2->p_typ == 0x0E);
-			break;
-
-		case 0x06: case 0x0E: case 0x16:
-			ret = (p2->p_typ == 0x06) || (p2->p_typ == 0x0E) || (p2->p_typ == 0x16);
-			break;
-
-		case 0x05: case 0x0F:
-			ret = (p2->p_typ == 0x05) || (p2->p_typ == 0x0F);
-			break;
-
-		case 0x0B: case 0x0C:
-			ret = (p2->p_typ == 0x0B) || (p2->p_typ == 0x0C);
-			break;
-
-		case 0x8E: case 0xFE:
-			ret = (p2->p_typ == 0x8E) || (p2->p_typ == 0xFE);
-			break;
-
-		default :
-			ret = p1->p_typ == p2->p_typ;
-			break;
+	int ret = 0;
+
+	switch (p1->p_typ) {
+	case 0x01:
+	case 0x11:
+		ret = (p2->p_typ == 0x06) || (p2->p_typ == 0x0E);
+		break;
+
+	case 0x06:
+	case 0x0E:
+	case 0x16:
+		ret = (p2->p_typ == 0x06) || (p2->p_typ == 0x0E) || (p2->p_typ == 0x16);
+		break;
+
+	case 0x05:
+	case 0x0F:
+		ret = (p2->p_typ == 0x05) || (p2->p_typ == 0x0F);
+		break;
+
+	case 0x0B:
+	case 0x0C:
+		ret = (p2->p_typ == 0x0B) || (p2->p_typ == 0x0C);
+		break;
+
+	case 0x8E:
+	case 0xFE:
+		ret = (p2->p_typ == 0x8E) || (p2->p_typ == 0xFE);
+		break;
+
+	default:
+		ret = p1->p_typ == p2->p_typ;
+		break;
 	}
 	return (ret);
 }
 
-
-
 /*
  * detecting an extended ptbl isn't unambiguous, the boot code
  * preceding the ptbl should be zeroed but isn't always. The
@@ -438,11 +423,11 @@ static int is_same_partition_type(dos_part_entry *p1,dos_part_entry *p2)
  * entries.
  */
 
-static int is_ext_parttable(disk_desc *d,byte_t *buf)
+static int is_ext_parttable(disk_desc *d, byte_t *buf)
 {
-	int		r, e;
-	byte_t		*magic;
-	dos_part_entry	*p, *t;
+	int r, e;
+	byte_t *magic;
+	dos_part_entry *p, *t;
 
 	p = (dos_part_entry *)(buf + DOSPARTOFF);
 	magic = (byte_t *)&p[NDOSPARTS];
@@ -454,7 +439,7 @@ static int is_ext_parttable(disk_desc *d,byte_t *buf)
 	 */
 
 	for (t = p; t <= &p[NDOSPARTS - 1]; t++)
-		if (! is_sane_partentry(d,t,0))
+		if (!is_sane_partentry(d, t, 0))
 			return (0);
 
 	/*
@@ -467,21 +452,16 @@ static int is_ext_parttable(disk_desc *d,byte_t *buf)
 	return ((r == 1) && ((e == 0) || (e == 1)));
 }
 
-
-
-static void fillin_dos_chs(disk_desc *d,dos_part_entry *p,s64_t offset)
+static void fillin_dos_chs(disk_desc *d, dos_part_entry *p, s64_t offset)
 {
-	unsigned long	n;
+	unsigned long n;
 
 	n = p->p_start;
-	if (n > 1023 * d->d_dg.d_h * d->d_dg.d_s)
-	{
+	if (n > 1023 * d->d_dg.d_h * d->d_dg.d_s) {
 		p->p_ssect = d->d_dg.d_s | ((1023 >> 2) & 0xc0);
 		p->p_shd = d->d_dg.d_h - 1;
 		p->p_scyl = 1023 & 0xff;
-	}
-	else
-	{
+	} else {
 		p->p_ssect = (n % d->d_dg.d_s) + 1;
 		n /= d->d_dg.d_s;
 		p->p_shd = n % d->d_dg.d_h;
@@ -490,14 +470,11 @@ static void fillin_dos_chs(disk_desc *d,dos_part_entry *p,s64_t offset)
 		p->p_ssect |= (n >> 2) & 0xc0;
 	}
 	n = p->p_size + p->p_start - 1;
-	if (n > 1023 * d->d_dg.d_h * d->d_dg.d_s)
-	{
+	if (n > 1023 * d->d_dg.d_h * d->d_dg.d_s) {
 		p->p_esect = d->d_dg.d_s | ((1023 >> 2) & 0xc0);
 		p->p_ehd = d->d_dg.d_h - 1;
 		p->p_ecyl = 1023 & 0xff;
-	}
-	else
-	{
+	} else {
 		p->p_esect = (n % d->d_dg.d_s) + 1;
 		n /= d->d_dg.d_s;
 		p->p_ehd = n % d->d_dg.d_h;
@@ -507,100 +484,94 @@ static void fillin_dos_chs(disk_desc *d,dos_part_entry *p,s64_t offset)
 	}
 }
 
-
-
-static void u_to_chs(disk_desc *d,unsigned long u,long *c,long *h,long *s)
+static void u_to_chs(disk_desc *d, unsigned long u, long *c, long *h, long *s)
 {
-	struct disk_geom	*g = &d->d_dg;
+	struct disk_geom *g = &d->d_dg;
 
 	*c = *h = *s = 0;
-	if (g->d_h && g->d_s && u)
-	{
+	if (g->d_h && g->d_s && u) {
 		*c = u / (g->d_h * g->d_s);
 		*h = (u / g->d_s) % g->d_h;
-		*s = u %  g->d_s + 1;
+		*s = u % g->d_s + 1;
 	}
 }
 
-
-
-static int on_cyl_boundary(disk_desc *d,s64_t sec)
+static int on_cyl_boundary(disk_desc *d, s64_t sec)
 {
-	struct disk_geom	*g = &d->d_dg;
+	struct disk_geom *g = &d->d_dg;
 
 	if (g->d_h && g->d_s)
 		return ((sec % (g->d_h * g->d_s)) == 0);
 	return (1);
 }
 
-
-
-static int on_head_boundary(disk_desc *d,s64_t sec)
+static int on_head_boundary(disk_desc *d, s64_t sec)
 {
-	struct disk_geom	*g = &d->d_dg;
+	struct disk_geom *g = &d->d_dg;
 
 	if (g->d_s)
 		return ((sec % g->d_s) == 0);
 	return (1);
 }
 
-
-
-static void print_partition(disk_desc *d,dos_part_entry *p,int inset,s64_t offset)
+static void print_partition(disk_desc *d, dos_part_entry *p, int inset, s64_t offset)
 {
-	long			i, c = 0, h = 0, s = 0;
-	s64_t			size;
-	char			*ptyp = get_part_type(p->p_typ);
+	long i, c = 0, h = 0, s = 0;
+	s64_t size;
+	char *ptyp = get_part_type(p->p_typ);
 
-#define indent(s)	for (i = 0; i < s; i++) pr(MSG,"   ")
+#define indent(s)                                                                                                      \
+	for (i = 0; i < s; i++)                                                                                            \
+	pr(MSG, "   ")
 
-	size = p->p_size; s2mb(d,size);
+	size = p->p_size;
+	s2mb(d, size);
 	indent(inset);
-	pr(MSG,PM_PT_TYPE,p->p_typ,p->p_typ,ptyp ? ptyp : "UNKNOWN");
+	pr(MSG, PM_PT_TYPE, p->p_typ, p->p_typ, ptyp ? ptyp : "UNKNOWN");
 	if (p->p_flag == DOSPARTACTIVE)
-		pr(MSG," (BOOT)");
-	pr(MSG,"\n");
+		pr(MSG, " (BOOT)");
+	pr(MSG, "\n");
 
 	indent(inset);
-	pr(MSG,PM_PT_SIZE,size,(s64_t)p->p_size);
-	size = p->p_start; size += offset; size += p->p_size;
-	if (size) size -= 1;
-	pr(MSG," s(%qd-%qd)\n",(s64_t)p->p_start + offset,size);
+	pr(MSG, PM_PT_SIZE, size, (s64_t)p->p_size);
+	size = p->p_start;
+	size += offset;
+	size += p->p_size;
+	if (size)
+		size -= 1;
+	pr(MSG, " s(%qd-%qd)\n", (s64_t)p->p_start + offset, size);
 
 	indent(inset);
-	pr(MSG,PM_PT_CHS,
-		DOSCYL(p->p_scyl,p->p_ssect),p->p_shd,DOSSEC(p->p_ssect),
-		DOSCYL(p->p_ecyl,p->p_esect),p->p_ehd,DOSSEC(p->p_esect));
-	if (size) u_to_chs(d,p->p_start + offset,&c,&h,&s);
-	pr(MSG," (%ld/%ld/%ld)-",c,h,s);
-	if (size) u_to_chs(d,p->p_start + offset + p->p_size - 1,&c,&h,&s);
-	pr(MSG,"(%ld/%ld/%ld)r\n",c,h,s);
-
-	if (f_verbose > 0)
-	{
+	pr(MSG, PM_PT_CHS, DOSCYL(p->p_scyl, p->p_ssect), p->p_shd, DOSSEC(p->p_ssect), DOSCYL(p->p_ecyl, p->p_esect),
+	   p->p_ehd, DOSSEC(p->p_esect));
+	if (size)
+		u_to_chs(d, p->p_start + offset, &c, &h, &s);
+	pr(MSG, " (%ld/%ld/%ld)-", c, h, s);
+	if (size)
+		u_to_chs(d, p->p_start + offset + p->p_size - 1, &c, &h, &s);
+	pr(MSG, "(%ld/%ld/%ld)r\n", c, h, s);
+
+	if (f_verbose > 0) {
 		indent(inset);
-		pr(MSG,PM_PT_HEX);
+		pr(MSG, PM_PT_HEX);
 		for (i = 0; i < sizeof(dos_part_entry); i++)
-			pr(MSG," %02X",((byte_t *)p)[i]);
-		pr(MSG,"\n");
+			pr(MSG, " %02X", ((byte_t *)p)[i]);
+		pr(MSG, "\n");
 	}
-	pr(MSG,"\n");
+	pr(MSG, "\n");
 }
 
-
-
-static void print_ext_partitions(disk_desc *d,s64_t offset)
+static void print_ext_partitions(disk_desc *d, s64_t offset)
 {
-	dos_part_table	*pt = d->d_pt.t_ext;
-	dos_part_entry	*p;
-	s64_t		extst = 0;
+	dos_part_table *pt = d->d_pt.t_ext;
+	dos_part_entry *p;
+	s64_t extst = 0;
 
-	for ( ; pt; pt = pt->t_ext)
-	{
-		pr(MSG,PM_EXTPART);
+	for (; pt; pt = pt->t_ext) {
+		pr(MSG, PM_EXTPART);
 		for (p = pt->t_parts; p <= &pt->t_parts[NDOSPARTS - 1]; p++)
 			if (is_real_parttype(p))
-				print_partition(d,p,1,offset + extst);
+				print_partition(d, p, 1, offset + extst);
 
 		for (p = pt->t_parts; p <= &pt->t_parts[NDOSPARTS - 1]; p++)
 			if (is_ext_parttype(p))
@@ -608,129 +579,108 @@ static void print_ext_partitions(disk_desc *d,s64_t offset)
 	}
 }
 
-
-
-static void print_ptable(disk_desc *d,dos_part_table *pt,int pr_ext)
+static void print_ptable(disk_desc *d, dos_part_table *pt, int pr_ext)
 {
-	int		n;
+	int n;
 
-	for (n = 0; n < NDOSPARTS; n++)
-	{
-		pr(MSG,PM_PRIMPART,n + 1);
-		print_partition(d,&pt->t_parts[n],0,0);
+	for (n = 0; n < NDOSPARTS; n++) {
+		pr(MSG, PM_PRIMPART, n + 1);
+		print_partition(d, &pt->t_parts[n], 0, 0);
 		if (pr_ext && is_ext_parttype(&pt->t_parts[n]))
-			print_ext_partitions(d,pt->t_parts[n].p_start);
+			print_ext_partitions(d, pt->t_parts[n].p_start);
 	}
 }
 
-
-
 static void print_disk_desc(disk_desc *d)
 {
-	s64_t		s;
-
-	pr(MSG,PM_DEVDESC1,d->d_dev,d->d_ssize);
-	if (f_getgeom)
-	{
-		s = d->d_nsecs; s2mb(d,s);
-		pr(MSG,PM_DEVDESC2,
-			d->d_dg.d_c,d->d_dg.d_h,d->d_dg.d_s,
-			d->d_lba ? "(LBA) " : " ",
-			d->d_nsecs,s);
+	s64_t s;
+
+	pr(MSG, PM_DEVDESC1, d->d_dev, d->d_ssize);
+	if (f_getgeom) {
+		s = d->d_nsecs;
+		s2mb(d, s);
+		pr(MSG, PM_DEVDESC2, d->d_dg.d_c, d->d_dg.d_h, d->d_dg.d_s, d->d_lba ? "(LBA) " : " ", d->d_nsecs, s);
 	}
-	pr(MSG,"\n");
+	pr(MSG, "\n");
 	if (d->d_pt.t_magic != le16(DOSPTMAGIC))
-		pr(WARN,EM_STRANGEPTBLMAGIC,d->d_pt.t_magic);
-	print_ptable(d,&d->d_pt,1);
+		pr(WARN, EM_STRANGEPTBLMAGIC, d->d_pt.t_magic);
+	print_ptable(d, &d->d_pt, 1);
 }
 
-
-
 static void print_mboot_block(disk_desc *d)
 {
-	int		n, m, cols = 16;
-	byte_t		*boot = d->d_pt.t_boot;
+	int n, m, cols = 16;
+	byte_t *boot = d->d_pt.t_boot;
 
-	pr(MSG,PM_MBRPRINT,d->d_dev);
-	for (n = 0; n < DOSPARTOFF - cols; n += cols)
-	{
-		pr(MSG,"   %04X:  ",n);
+	pr(MSG, PM_MBRPRINT, d->d_dev);
+	for (n = 0; n < DOSPARTOFF - cols; n += cols) {
+		pr(MSG, "   %04X:  ", n);
 		for (m = n; m < n + cols; m++)
-			pr(MSG," %02x",boot[m]);
-		pr(MSG,"\n          ");
+			pr(MSG, " %02x", boot[m]);
+		pr(MSG, "\n          ");
 		for (m = n; m < n + cols; m++)
-			pr(MSG," %c ",isprint(boot[m]) ? boot[m] : '.');
-		pr(MSG,"\n");
+			pr(MSG, " %c ", isprint(boot[m]) ? boot[m] : '.');
+		pr(MSG, "\n");
 	}
 }
 
-
-
-static void read_part_table(disk_desc *d,s64_t sec,byte_t *where)
+static void read_part_table(disk_desc *d, s64_t sec, byte_t *where)
 {
-	ssize_t		rd;
-	size_t		psize;
-	byte_t		*ubuf, *buf;
+	ssize_t rd;
+	size_t psize;
+	byte_t *ubuf, *buf;
 
 	psize = getpagesize();
 	ubuf = alloc(MAXSSIZE + psize);
-	buf = align(ubuf,psize);
+	buf = align(ubuf, psize);
 	sec *= d->d_ssize;
-	if (l64seek(d->d_fd,sec,SEEK_SET) == -1)
-		pr(FATAL,EM_SEEKFAILURE,d->d_dev);
+	if (l64seek(d->d_fd, sec, SEEK_SET) == -1)
+		pr(FATAL, EM_SEEKFAILURE, d->d_dev);
 
 	if (d->d_ssize < 512)
-		rd = bread(d->d_fd,buf,d->d_ssize,512 / d->d_ssize);
+		rd = bread(d->d_fd, buf, d->d_ssize, 512 / d->d_ssize);
 	else
-		rd = bread(d->d_fd,buf,d->d_ssize,1);
+		rd = bread(d->d_fd, buf, d->d_ssize, 1);
 
 	if (rd == -1)
-		pr(FATAL,EM_PTBLREAD);
-	memcpy(where,buf,512);
+		pr(FATAL, EM_PTBLREAD);
+	memcpy(where, buf, 512);
 	free((void *)ubuf);
 }
 
-
-
-static void read_ext_part_table(disk_desc *d,dos_part_table *pt)
+static void read_ext_part_table(disk_desc *d, dos_part_table *pt)
 {
-	dos_part_entry	*p, *ep;
-	s64_t		epsize, epstart, epoffset;
-	int		epcount;
+	dos_part_entry *p, *ep;
+	s64_t epsize, epstart, epoffset;
+	int epcount;
 
 	epsize = epstart = epoffset = epcount = 0;
-	while (1)
-	{
+	while (1) {
 		ep = 0;
 		for (p = pt->t_parts; p <= &pt->t_parts[NDOSPARTS - 1]; p++)
-			if (is_ext_parttype(p))
-			{
-				if (ep == 0)
-				{
+			if (is_ext_parttype(p)) {
+				if (ep == 0) {
 					ep = p;
 					break;
 				}
-				pr(ERROR,EM_TOOMANYEXTP);
+				pr(ERROR, EM_TOOMANYEXTP);
 			}
 
 		if (ep == 0)
 			return;
 		if (++epcount > 128) /* arbitrary maximum */
 		{
-			pr(ERROR,EM_TOOMANYLOGP,128);
+			pr(ERROR, EM_TOOMANYLOGP, 128);
 			return;
 		}
-		if (epstart == 0)
-		{
+		if (epstart == 0) {
 			epstart = ep->p_start;
 			epsize = ep->p_size;
 			epoffset = 0;
-		}
-		else
+		} else
 			epoffset = ep->p_start;
-		if (epoffset > epsize)
-		{
-			pr(ERROR,EM_EPILLEGALOFS);
+		if (epoffset > epsize) {
+			pr(ERROR, EM_EPILLEGALOFS);
 			return;
 		}
 
@@ -739,50 +689,48 @@ static void read_ext_part_table(disk_desc *d,dos_part_table *pt)
 		 */
 
 		pt->t_ext = (dos_part_table *)alloc(sizeof(dos_part_table));
-		read_part_table(d,epstart + epoffset,(pt = pt->t_ext)->t_boot);
-		if (! is_ext_parttable(d,pt->t_boot))
-		{
-			pr(ERROR,EM_INVXPTBL,epstart + epoffset);
+		read_part_table(d, epstart + epoffset, (pt = pt->t_ext)->t_boot);
+		if (!is_ext_parttable(d, pt->t_boot)) {
+			pr(ERROR, EM_INVXPTBL, epstart + epoffset);
 			return;
 		}
 	}
 }
 
-
-
 static void free_disk_desc(disk_desc *d)
 {
-	dos_part_table	*pt;
-	dos_guessed_pt	*pg;
-	void		*t;
-
-	for (pt = d->d_pt.t_ext; pt; )
-	{
-		t = pt->t_ext; free((void *)pt); pt = t;
+	dos_part_table *pt;
+	dos_guessed_pt *pg;
+	void *t;
+
+	for (pt = d->d_pt.t_ext; pt;) {
+		t = pt->t_ext;
+		free((void *)pt);
+		pt = t;
 	}
-	for (pt = d->d_gpt.t_ext; pt; )
-	{
-		t = pt->t_ext; free((void *)pt); pt = t;
+	for (pt = d->d_gpt.t_ext; pt;) {
+		t = pt->t_ext;
+		free((void *)pt);
+		pt = t;
 	}
-	for (pg = d->d_gl; pg; )
-	{
-		t = pg->g_next; free((void *)pg); pg = t;
+	for (pg = d->d_gl; pg;) {
+		t = pg->g_next;
+		free((void *)pg);
+		pg = t;
 	}
 	free((void *)d);
 }
 
-
-
-static disk_desc *get_disk_desc(char *dev,int sectsize)
+static disk_desc *get_disk_desc(char *dev, int sectsize)
 {
-	byte_t		*ubuf, *buf;
-	disk_desc	*d;
-	int		psize, ssize;
+	byte_t *ubuf, *buf;
+	disk_desc *d;
+	int psize, ssize;
 	struct disk_geom *dg;
 
 	psize = getpagesize();
 	ubuf = alloc(MAXSSIZE + psize);
-	buf = align(ubuf,psize);
+	buf = align(ubuf, psize);
 	d = (disk_desc *)alloc(sizeof(disk_desc));
 
 	/*
@@ -790,44 +738,39 @@ static disk_desc *get_disk_desc(char *dev,int sectsize)
 	 * special file or just a regular file.
 	 */
 
-	if ((d->d_fd = open(dev,O_RDONLY)) == -1)
-		pr(FATAL,EM_OPENFAIL,dev,strerror(errno));
+	if ((d->d_fd = open(dev, O_RDONLY)) == -1)
+		pr(FATAL, EM_OPENFAIL, dev, strerror(errno));
 
 	/*
 	 * try to test for sector sizes (doesn't work under many systems).
 	 */
 
 	if (sectsize > MAXSSIZE)
-		pr(FATAL,EM_WRONGSECTSIZE,MAXSSIZE);
+		pr(FATAL, EM_WRONGSECTSIZE, MAXSSIZE);
 
-	if (sectsize)
-	{
-		ssize = bread(d->d_fd,buf,sectsize,1);
+	if (sectsize) {
+		ssize = bread(d->d_fd, buf, sectsize, 1);
 		if (ssize != sectsize)
-			pr(FATAL,EM_FAILSSIZEATTEMPT,sectsize);
+			pr(FATAL, EM_FAILSSIZEATTEMPT, sectsize);
 		d->d_ssize = sectsize;
-	}
-	else
-	{
-		for (d->d_ssize = MINSSIZE; d->d_ssize <= MAXSSIZE; d->d_ssize *= 2)
-		{
-			if (l64seek(d->d_fd,0,SEEK_SET) == -1)
-				pr(FATAL,EM_SEEKFAILURE,dev);
-			ssize = bread(d->d_fd,buf,d->d_ssize,1);
+	} else {
+		for (d->d_ssize = MINSSIZE; d->d_ssize <= MAXSSIZE; d->d_ssize *= 2) {
+			if (l64seek(d->d_fd, 0, SEEK_SET) == -1)
+				pr(FATAL, EM_SEEKFAILURE, dev);
+			ssize = bread(d->d_fd, buf, d->d_ssize, 1);
 			if (ssize == d->d_ssize)
 				break;
 		}
 		if (ssize == -1)
-			pr(FATAL,EM_CANTGETSSIZE,dev);
+			pr(FATAL, EM_CANTGETSSIZE, dev);
 	}
 
 	d->d_dev = dev;
-	read_part_table(d,0,d->d_pt.t_boot);
-	if (f_getgeom)
-	{
+	read_part_table(d, 0, d->d_pt.t_boot);
+	if (f_getgeom) {
 		if ((dg = disk_geometry(d)) == 0)
-			pr(FATAL,EM_CANTGETGEOM);
-		memcpy(&d->d_dg,dg,sizeof(struct disk_geom));
+			pr(FATAL, EM_CANTGETGEOM);
+		memcpy(&d->d_dg, dg, sizeof(struct disk_geom));
 
 		d->d_nsecs = dg->d_nsecs;
 
@@ -835,18 +778,21 @@ static disk_desc *get_disk_desc(char *dev,int sectsize)
 		 * command line geometry overrides
 		 */
 
-		if (gc) d->d_dg.d_c = gc;
-		if (gh) d->d_dg.d_h = gh;
-		if (gs) d->d_dg.d_s = gs;
-	}
-	else
-	{
+		if (gc)
+			d->d_dg.d_c = gc;
+		if (gh)
+			d->d_dg.d_h = gh;
+		if (gs)
+			d->d_dg.d_s = gs;
+	} else {
 		d->d_dg.d_c = gc;
 		d->d_dg.d_h = gh;
 		d->d_dg.d_s = gs;
 	}
-	if (d->d_dg.d_c < 1024) d->d_dosc = 1;
-	if ((d->d_dg.d_h > 16) || (d->d_dg.d_s > 63)) d->d_lba = 1;
+	if (d->d_dg.d_c < 1024)
+		d->d_dosc = 1;
+	if ((d->d_dg.d_h > 16) || (d->d_dg.d_s > 63))
+		d->d_lba = 1;
 
 	if (gh && gc && gs) {
 		/* Override number of sectors with command line parameters */
@@ -855,40 +801,35 @@ static disk_desc *get_disk_desc(char *dev,int sectsize)
 		d->d_nsecs *= d->d_dg.d_s;
 	}
 
-	read_ext_part_table(d,&d->d_pt);
+	read_ext_part_table(d, &d->d_pt);
 	close(d->d_fd);
 	free((void *)ubuf);
 	return (d);
 }
 
-
-
-static void add_guessed_p(disk_desc *d,dos_part_entry *p,int cnt)
+static void add_guessed_p(disk_desc *d, dos_part_entry *p, int cnt)
 {
-	dos_guessed_pt	*gpt;
+	dos_guessed_pt *gpt;
 
 	if (d->d_gl == 0)
 		gpt = d->d_gl = (dos_guessed_pt *)alloc(sizeof(dos_guessed_pt));
-	else
-	{
-		for (gpt = d->d_gl; gpt->g_next; gpt = gpt->g_next)	
+	else {
+		for (gpt = d->d_gl; gpt->g_next; gpt = gpt->g_next)
 			;
 		gpt->g_next = (dos_guessed_pt *)alloc(sizeof(dos_guessed_pt));
 		gpt = gpt->g_next;
 	}
 
 	gpt->g_ext = (cnt > 1);
-	for ( ; cnt > 0; cnt--)
-		memcpy(&gpt->g_p[cnt-1],&p[cnt-1],sizeof(dos_part_entry));
+	for (; cnt > 0; cnt--)
+		memcpy(&gpt->g_p[cnt - 1], &p[cnt - 1], sizeof(dos_part_entry));
 	gpt->g_sec = d->d_nsb;
 }
 
-
-
-static g_module *get_best_guess(g_module **g,int count)
+static g_module *get_best_guess(g_module **g, int count)
 {
-	int		mx, i;
-	float		bestg = 0.0;
+	int mx, i;
+	float bestg = 0.0;
 
 	/*
 	 * up to now the best guess is simple that one which
@@ -903,51 +844,46 @@ static g_module *get_best_guess(g_module **g,int count)
 	return ((bestg > 0.0) ? g[mx] : 0);
 }
 
-
-
-static int mod_is_aligned(disk_desc *d,g_module *m)
+static int mod_is_aligned(disk_desc *d, g_module *m)
 {
-	s64_t		al;
-
-	switch (m->m_align)
-	{
-		case 'h' :
-			return (on_head_boundary(d,d->d_nsb));
-
-		case 'c' :
-			return (on_cyl_boundary(d,d->d_nsb));
-
-		case 1 :
-		case 's' :
-			return (1);
-		default :
-			if (m->m_align > 0)
-			{
-				al = d->d_nsb; al %= m->m_align;
-				return (al == 0);
-			}
-			break;
+	s64_t al;
+
+	switch (m->m_align) {
+	case 'h':
+		return (on_head_boundary(d, d->d_nsb));
+
+	case 'c':
+		return (on_cyl_boundary(d, d->d_nsb));
+
+	case 1:
+	case 's':
+		return (1);
+	default:
+		if (m->m_align > 0) {
+			al = d->d_nsb;
+			al %= m->m_align;
+			return (al == 0);
+		}
+		break;
 	}
 	return (1);
 }
 
-
-
 /*
  * the main guessing loop.
  */
 
 static void do_guess_loop(disk_desc *d)
 {
-	g_module	*m, **guesses;
-	unsigned long	incr = 0;
-	int		nsecs, in_ext = 0, end_of_ext = 0, psize;
-	ssize_t		rd, bsize = d->d_ssize;
-	s64_t		bincr, noffset, start;
-	byte_t		*ubuf;
+	g_module *m, **guesses;
+	unsigned long incr = 0;
+	int nsecs, in_ext = 0, end_of_ext = 0, psize;
+	ssize_t rd, bsize = d->d_ssize;
+	s64_t bincr, noffset, start;
+	byte_t *ubuf;
 
-	if ((d->d_fd = open(d->d_dev,O_RDONLY)) == -1)
-		pr(FATAL,EM_OPENFAIL,d->d_dev,strerror(errno));
+	if ((d->d_fd = open(d->d_dev, O_RDONLY)) == -1)
+		pr(FATAL, EM_OPENFAIL, d->d_dev, strerror(errno));
 
 	/*
 	 * initialize modules. Each should return the minimum
@@ -955,24 +891,30 @@ static void do_guess_loop(disk_desc *d)
 	 */
 
 	for (m = g_mod_head(); m; m = m->m_next)
-		if (m->m_init)
-		{
-			int	sz;
+		if (m->m_init) {
+			int sz;
 
-			if ((sz = (*m->m_init)(d,m)) <= 0)
-				pr(ERROR,EM_MINITFAILURE,m->m_name);
-			bsize = max(sz,bsize);
+			if ((sz = (*m->m_init)(d, m)) <= 0)
+				pr(ERROR, EM_MINITFAILURE, m->m_name);
+			bsize = max(sz, bsize);
 		}
 
 	if (bsize % d->d_ssize)
 		bsize += d->d_ssize - bsize % d->d_ssize;
 	nsecs = bsize / d->d_ssize;
-	switch (increment)
-	{
-		case 's' : incr = 1; break;
-		case 'h' : incr = d->d_dg.d_s; break;
-		case 'c' : incr = d->d_dg.d_s * d->d_dg.d_h; break;
-		default  : incr = increment; break;
+	switch (increment) {
+	case 's':
+		incr = 1;
+		break;
+	case 'h':
+		incr = d->d_dg.d_s;
+		break;
+	case 'c':
+		incr = d->d_dg.d_s * d->d_dg.d_h;
+		break;
+	default:
+		incr = increment;
+		break;
 	}
 	if (incr == 0)
 		incr = 1;
@@ -980,15 +922,15 @@ static void do_guess_loop(disk_desc *d)
 	boundary_fun = (incr == 1) ? on_head_boundary : on_cyl_boundary;
 	psize = getpagesize();
 	ubuf = alloc(bsize + psize);
-	d->d_sbuf = align(ubuf,psize);
+	d->d_sbuf = align(ubuf, psize);
 	d->d_nsb = 0;
 	bincr = incr * d->d_ssize;
 
 	start = skipsec ? skipsec : d->d_dg.d_s;
 	d->d_nsb = start - incr;
 	start *= d->d_ssize;
-	if (l64seek(d->d_fd,start,SEEK_SET) == -1)
-		pr(FATAL,EM_SEEKFAILURE,d->d_dev);
+	if (l64seek(d->d_fd, start, SEEK_SET) == -1)
+		pr(FATAL, EM_SEEKFAILURE, d->d_dev);
 
 	/*
 	 * do the work: read blocks, distribute to modules, check
@@ -996,18 +938,20 @@ static void do_guess_loop(disk_desc *d)
 	 */
 
 	guesses = (g_module **)alloc(g_mod_count() * sizeof(g_module *));
-	pr(MSG,DM_STARTSCAN);
+	pr(MSG, DM_STARTSCAN);
 
 scanloop:
-	while ((rd = bread(d->d_fd,d->d_sbuf,d->d_ssize,nsecs)) == bsize)
-	{
-		int		mod, have_ext = 0;
-		g_module	*bg;
-		s64_t		sz, ofs;
-
-		d->d_nsb += incr; noffset = 0;
-		ofs = d->d_nsb; s2mb(d,ofs);
-		if (maxsec && (d->d_nsb > maxsec)) break;
+	while ((rd = bread(d->d_fd, d->d_sbuf, d->d_ssize, nsecs)) == bsize) {
+		int mod, have_ext = 0;
+		g_module *bg;
+		s64_t sz, ofs;
+
+		d->d_nsb += incr;
+		noffset = 0;
+		ofs = d->d_nsb;
+		s2mb(d, ofs);
+		if (maxsec && (d->d_nsb > maxsec))
+			break;
 
 		/*
 		 * reset modules
@@ -1016,11 +960,11 @@ scanloop:
 		for (m = g_mod_head(); m; m = m->m_next)
 			m->m_skip = 0;
 
-guessit:
-		bg = 0; mod = 0;
-		for (m = g_mod_head(); m; m = m->m_next)
-		{
-			if (m->m_skip || (in_ext && m->m_notinext) || !mod_is_aligned(d,m))
+	guessit:
+		bg = 0;
+		mod = 0;
+		for (m = g_mod_head(); m; m = m->m_next) {
+			if (m->m_skip || (in_ext && m->m_notinext) || !mod_is_aligned(d, m))
 				continue;
 
 			/*
@@ -1029,84 +973,76 @@ guessit:
 			 * saved.
 			 */
 
-			memset(&m->m_part,0,sizeof(dos_part_entry));
-			m->m_guess = GM_NO; l64opush(d->d_fd);
-			if ((*m->m_gfun)(d,m) && (m->m_guess * m->m_weight >= GM_PERHAPS))
+			memset(&m->m_part, 0, sizeof(dos_part_entry));
+			m->m_guess = GM_NO;
+			l64opush(d->d_fd);
+			if ((*m->m_gfun)(d, m) && (m->m_guess * m->m_weight >= GM_PERHAPS))
 				guesses[mod++] = m;
 			if ((sz = l64opop(d->d_fd)) != l64tell(d->d_fd))
-				l64seek(d->d_fd,sz,SEEK_SET);
+				l64seek(d->d_fd, sz, SEEK_SET);
 		}
 
 		/*
 		 * now fetch the best guess.
 		 */
 
-		if (mod && (bg = get_best_guess(guesses,mod)))
-		{
+		if (mod && (bg = get_best_guess(guesses, mod))) {
 			noffset = bg->m_part.p_size;
-			fillin_dos_chs(d,&bg->m_part,0);
+			fillin_dos_chs(d, &bg->m_part, 0);
 		}
 
 		/*
 		 * extended partition begin?
 		 */
 
-		if (f_testext && boundary_fun(d,d->d_nsb) &&
-		    (!bg || !bg->m_hasptbl) && is_ext_parttable(d,d->d_sbuf))
-		{
-			dos_part_entry	*p;
-			int		no_ext;
+		if (f_testext && boundary_fun(d, d->d_nsb) && (!bg || !bg->m_hasptbl) && is_ext_parttable(d, d->d_sbuf)) {
+			dos_part_entry *p;
+			int no_ext;
 
 			p = (dos_part_entry *)(d->d_sbuf + DOSPARTOFF);
 			no_ext = no_of_ext_partitions(p);
-			if (! in_ext)
-			{
-				pr(MSG,PM_POSSIBLEEXTPART,ofs);
-				in_ext = 1; end_of_ext = 0; noffset = 0;
-			}
-			else if (no_ext == 0)
+			if (!in_ext) {
+				pr(MSG, PM_POSSIBLEEXTPART, ofs);
+				in_ext = 1;
+				end_of_ext = 0;
+				noffset = 0;
+			} else if (no_ext == 0)
 				end_of_ext = 1;
 
-			if (in_ext)
-			{
-				if (f_interactive)
-				{
+			if (in_ext) {
+				if (f_interactive) {
 					if (yesno(DM_ACCEPTGUESS))
-						add_guessed_p(d,p,have_ext = NDOSPARTS);
-					else
-						if (mod && bg)
-						{
-							bg->m_skip = 1;
-							goto guessit;
-						}
-				}
-				else
-					add_guessed_p(d,p,have_ext = NDOSPARTS);
+						add_guessed_p(d, p, have_ext = NDOSPARTS);
+					else if (mod && bg) {
+						bg->m_skip = 1;
+						goto guessit;
+					}
+				} else
+					add_guessed_p(d, p, have_ext = NDOSPARTS);
 			}
 		}
 
-		if (! have_ext && noffset)
-		{
-			sz = noffset; s2mb(d,sz);
-			if (in_ext) pr(MSG,"   ");
-			pr(MSG,PM_POSSIBLEPART,bg->m_desc ? bg->m_desc : bg->m_name,sz,ofs);
+		if (!have_ext && noffset) {
+			sz = noffset;
+			s2mb(d, sz);
+			if (in_ext)
+				pr(MSG, "   ");
+			pr(MSG, PM_POSSIBLEPART, bg->m_desc ? bg->m_desc : bg->m_name, sz, ofs);
 			if (f_verbose)
-				print_partition(d,&bg->m_part,in_ext ? 1 : 0,0);
+				print_partition(d, &bg->m_part, in_ext ? 1 : 0, 0);
 			if (f_interactive)
-				if (! yesno(DM_ACCEPTGUESS))
-				{
+				if (!yesno(DM_ACCEPTGUESS)) {
 					noffset = 0;
-					if (mod && bg)
-					{
+					if (mod && bg) {
 						bg->m_skip = 1;
 						goto guessit;
 					}
 				}
 
-			if (noffset)
-			{
-				add_guessed_p(d,&bg->m_part,1);
-				if (end_of_ext) in_ext = 0;
+			if (noffset) {
+				add_guessed_p(d, &bg->m_part, 1);
+				if (end_of_ext)
+					in_ext = 0;
 			}
 		}
 
@@ -1115,18 +1051,17 @@ guessit:
 		 * backwards).
 		 */
 
-		if (noffset && f_fast)
-		{
+		if (noffset && f_fast) {
 			if (noffset % incr)
 				noffset += incr - noffset % incr;
 			d->d_nsb += noffset - incr;
-			noffset -= nsecs; noffset *= d->d_ssize;
-			if (l64seek(d->d_fd,noffset,SEEK_CUR) == -1)
-				pr(FATAL,EM_SEEKFAILURE,d->d_dev);
-		}
-		else if (bincr)
-			if (l64seek(d->d_fd,bincr - bsize,SEEK_CUR) == -1)
-				pr(FATAL,EM_SEEKFAILURE,d->d_dev);
+			noffset -= nsecs;
+			noffset *= d->d_ssize;
+			if (l64seek(d->d_fd, noffset, SEEK_CUR) == -1)
+				pr(FATAL, EM_SEEKFAILURE, d->d_dev);
+		} else if (bincr)
+			if (l64seek(d->d_fd, bincr - bsize, SEEK_CUR) == -1)
+				pr(FATAL, EM_SEEKFAILURE, d->d_dev);
 	}
 
 	/*
@@ -1134,42 +1069,43 @@ guessit:
 	 */
 
 	if ((rd > 0) && (rd < bsize))
-		if (d->d_nsb + nsecs + 1 < d->d_nsecs)
-		{
+		if (d->d_nsb + nsecs + 1 < d->d_nsecs) {
 			/*
 			 * short read not at end of disk
 			 */
 
-			pr(f_skiperrors ? WARN : FATAL,EM_SHORTBREAD,d->d_nsb,rd,bsize);
-			noffset = l64tell(d->d_fd); noffset /= d->d_ssize;
+			pr(f_skiperrors ? WARN : FATAL, EM_SHORTBREAD, d->d_nsb, rd, bsize);
+			noffset = l64tell(d->d_fd);
+			noffset /= d->d_ssize;
 			noffset *= d->d_ssize;
-			if (l64seek(d->d_fd,noffset,SEEK_SET) == -1)
-				pr(FATAL,EM_SEEKFAILURE,d->d_dev);
+			if (l64seek(d->d_fd, noffset, SEEK_SET) == -1)
+				pr(FATAL, EM_SEEKFAILURE, d->d_dev);
 			d->d_nsb = l64tell(d->d_fd) / d->d_ssize - incr;
 			goto scanloop;
 		}
 
-	if (rd == -1)
-	{
+	if (rd == -1) {
 		/*
 		 * EIO is ignored (skipping current sector(s))
 		 */
 
-		if (f_skiperrors && (berrno == EIO))
-		{
-			pr(WARN,EM_BADREADIO,d->d_nsb);
-			noffset = l64tell(d->d_fd); noffset /= d->d_ssize;
-			noffset += incr; noffset *= d->d_ssize;
-			if (l64seek(d->d_fd,noffset,SEEK_SET) == -1)
-				pr(FATAL,EM_SEEKFAILURE,d->d_dev);
+		if (f_skiperrors && (berrno == EIO)) {
+			pr(WARN, EM_BADREADIO, d->d_nsb);
+			noffset = l64tell(d->d_fd);
+			noffset /= d->d_ssize;
+			noffset += incr;
+			noffset *= d->d_ssize;
+			if (l64seek(d->d_fd, noffset, SEEK_SET) == -1)
+				pr(FATAL, EM_SEEKFAILURE, d->d_dev);
 			d->d_nsb = l64tell(d->d_fd) / d->d_ssize - incr;
 			goto scanloop;
 		}
-		pr(FATAL,EM_READERROR,d->d_dev,d->d_nsb,strerror(berrno));
+		pr(FATAL, EM_READERROR, d->d_dev, d->d_nsb, strerror(berrno));
 	}
 
-	pr(MSG,DM_ENDSCAN);
-	if (guesses) free((void *)guesses);
+	pr(MSG, DM_ENDSCAN);
+	if (guesses)
+		free((void *)guesses);
 
 	for (m = g_mod_head(); m; m = m->m_next)
 		if (m->m_term)
@@ -1178,158 +1114,136 @@ guessit:
 	close(d->d_fd);
 }
 
-
-
-static void edit_partition(disk_desc *d,dos_part_entry *p)
+static void edit_partition(disk_desc *d, dos_part_entry *p)
 {
-	char		ans[32];
-	int		n;
-	unsigned long	val;
-
-	while (1)
-	{
-		pr(MSG,DM_NOCHECKWARNING);
-		pr(MSG,PM_EDITITEM1,p->p_start);
-		pr(MSG,PM_EDITITEM2,p->p_size);
-		pr(MSG,PM_EDITITEM3,p->p_typ,get_part_type(p->p_typ));
-		if ((n = number_or_quit(DM_EDITWHICHITEM,1,3)) < 0)
+	char ans[32];
+	int n;
+	unsigned long val;
+
+	while (1) {
+		pr(MSG, DM_NOCHECKWARNING);
+		pr(MSG, PM_EDITITEM1, p->p_start);
+		pr(MSG, PM_EDITITEM2, p->p_size);
+		pr(MSG, PM_EDITITEM3, p->p_typ, get_part_type(p->p_typ));
+		if ((n = number_or_quit(DM_EDITWHICHITEM, 1, 3)) < 0)
 			break;
 		if ((n < 1) || (n > 3))
 			continue;
-		pr(MSG,"Enter value for %d : ",n);
-		if (fgets(ans,32,stdin))
-		{
-			val = strtoul(ans,0,0);
-			switch (n)
-			{
-				case 1:
-					p->p_start = val;
-					fillin_dos_chs(d,p,0);
-					break;
-				case 2:
-					p->p_size = val;
-					fillin_dos_chs(d,p,0);
-					break;
-				case 3:
-					p->p_typ = val & 0xFF;
-					break;
+		pr(MSG, "Enter value for %d : ", n);
+		if (fgets(ans, 32, stdin)) {
+			val = strtoul(ans, 0, 0);
+			switch (n) {
+			case 1:
+				p->p_start = val;
+				fillin_dos_chs(d, p, 0);
+				break;
+			case 2:
+				p->p_size = val;
+				fillin_dos_chs(d, p, 0);
+				break;
+			case 3:
+				p->p_typ = val & 0xFF;
+				break;
 			}
 		}
 	}
 }
 
-
-
-static int make_mbr_backup(disk_desc *d,char *bfile)
+static int make_mbr_backup(disk_desc *d, char *bfile)
 {
-	int		fd, ret = 0;
+	int fd, ret = 0;
 
-	if ((fd = open(bfile, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) < 0)
+	if ((fd = open(bfile, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0)
 		return (ret);
 
-	if (write(fd,d->d_pt.t_boot,512) == 512)
+	if (write(fd, d->d_pt.t_boot, 512) == 512)
 		ret = 1;
 	close(fd);
 	return (ret);
 }
 
-
-
-static void write_primary_ptbl(disk_desc *d,char *dev)
+static void write_primary_ptbl(disk_desc *d, char *dev)
 {
-	struct stat	sbuf;
-	byte_t		*ptbl, *uptbl;
-	int		fd, doesntexist = 0, n;
+	struct stat sbuf;
+	byte_t *ptbl, *uptbl;
+	int fd, doesntexist = 0, n;
 
 	uptbl = alloc(d->d_ssize + getpagesize());
-	ptbl = align(uptbl,getpagesize());
+	ptbl = align(uptbl, getpagesize());
 
-	if (stat(dev,&sbuf) == -1)
-	{
+	if (stat(dev, &sbuf) == -1) {
 		if (errno != ENOENT)
-			pr(FATAL,EM_STATFAILURE,dev,strerror(errno));
+			pr(FATAL, EM_STATFAILURE, dev, strerror(errno));
 		else
 			doesntexist = 1;
 	}
-	fd = open(dev,O_WRONLY | (doesntexist ? O_CREAT | O_EXCL : 0),0660);
+	fd = open(dev, O_WRONLY | (doesntexist ? O_CREAT | O_EXCL : 0), 0660);
 	if (fd == -1)
-		pr(FATAL,EM_OPENFAIL,dev,strerror(errno));
-	if (l64seek(fd,0,SEEK_SET) == -1)
-		pr(FATAL,EM_SEEKFAILURE,dev);
+		pr(FATAL, EM_OPENFAIL, dev, strerror(errno));
+	if (l64seek(fd, 0, SEEK_SET) == -1)
+		pr(FATAL, EM_SEEKFAILURE, dev);
 
 	/*
 	 * is there a guessed partition table?
 	 */
 
-	if (d->d_gpt.t_magic == le16(DOSPTMAGIC))
-	{
+	if (d->d_gpt.t_magic == le16(DOSPTMAGIC)) {
 		/*
 		 * ask if table should be hand-edited
 		 */
 
 		if (yesno(DM_EDITPTBL))
-			while (1)
-			{
-				if ((n = number_or_quit(DM_EDITWHICHPART,1,NDOSPARTS)) < 0)
+			while (1) {
+				if ((n = number_or_quit(DM_EDITWHICHPART, 1, NDOSPARTS)) < 0)
 					break;
 				if ((n >= 1) && (n <= NDOSPARTS))
-					edit_partition(d,&d->d_gpt.t_parts[n - 1]);
+					edit_partition(d, &d->d_gpt.t_parts[n - 1]);
 				else
 					break;
-				print_ptable(d,&d->d_gpt,0);
+				print_ptable(d, &d->d_gpt, 0);
 			}
 
-
 		/*
 		 * ask for the active partition.
 		 */
 
-		while (1)
-		{
-			if ((n = number_or_quit(DM_ACTWHICHPART,1,NDOSPARTS)) < 0)
+		while (1) {
+			if ((n = number_or_quit(DM_ACTWHICHPART, 1, NDOSPARTS)) < 0)
 				break;
-			if ((n >= 1) && (n <= NDOSPARTS) && 
-			    get_part_type(d->d_gpt.t_parts[n].p_typ))
-			{
+			if ((n >= 1) && (n <= NDOSPARTS) && get_part_type(d->d_gpt.t_parts[n].p_typ)) {
 				d->d_gpt.t_parts[n - 1].p_flag = DOSPARTACTIVE;
 				break;
 			}
 		}
 
-		if (yesno(DM_WRITEIT))
-		{
-			memcpy(ptbl,d->d_pt.t_boot,DOSPARTOFF);
-			memcpy(ptbl + DOSPARTOFF,d->d_gpt.t_parts,NDOSPARTS * sizeof(dos_part_entry) + 2);
-			if (write(fd,ptbl,d->d_ssize) != d->d_ssize)
-				pr(FATAL,EM_PTBLWRITE);
-
-			if (S_ISBLK(sbuf.st_mode) || S_ISCHR(sbuf.st_mode))
-			{
-				sync(); sleep(1); sync();
+		if (yesno(DM_WRITEIT)) {
+			memcpy(ptbl, d->d_pt.t_boot, DOSPARTOFF);
+			memcpy(ptbl + DOSPARTOFF, d->d_gpt.t_parts, NDOSPARTS * sizeof(dos_part_entry) + 2);
+			if (write(fd, ptbl, d->d_ssize) != d->d_ssize)
+				pr(FATAL, EM_PTBLWRITE);
+
+			if (S_ISBLK(sbuf.st_mode) || S_ISCHR(sbuf.st_mode)) {
+				sync();
+				sleep(1);
+				sync();
 				reread_partition_table(fd);
-				pr(WARN,DM_ASKTOREBOOT);
+				pr(WARN, DM_ASKTOREBOOT);
 			}
-		}
-		else
-			pr(MSG,DM_NOTWRITTEN);
+		} else
+			pr(MSG, DM_NOTWRITTEN);
 	}
 	close(fd);
 	free((void *)uptbl);
 }
 
-
-
-static void warn_invalid(disk_desc *d,dos_part_entry *p,char *w)
+static void warn_invalid(disk_desc *d, dos_part_entry *p, char *w)
 {
-	if (f_verbose > 1)
-	{
-		pr(MSG,EM_PINVALID,w);
-		print_partition(d,p,0,0);
+	if (f_verbose > 1) {
+		pr(MSG, EM_PINVALID, w);
+		print_partition(d, p, 0, 0);
 	}
 }
 
-
-
 /*
  * after having gathered a list of possible partitions they
  * have to be checked for consistency. This routine must be
@@ -1338,47 +1252,47 @@ static void warn_invalid(disk_desc *d,dos_part_entry *p,char *w)
 
 static int check_partition_list(disk_desc *d)
 {
-	dos_guessed_pt	*gp, *prev;
-	dos_part_entry	*p, *rp, *ep, *lep;
-	int		n, npp, epp, maxp, in_ext;
-	s64_t		size, ofs;
+	dos_guessed_pt *gp, *prev;
+	dos_part_entry *p, *rp, *ep, *lep;
+	int n, npp, epp, maxp, in_ext;
+	s64_t size, ofs;
 
 	p = rp = ep = lep = 0;
 
-	pr(MSG,DM_STARTCHECK);
+	pr(MSG, DM_STARTCHECK);
 
 	/*
 	 * 1. pass: discard overlapping entries. This means
 	 * that the first entry is assumed to be ok.
 	 */
 
-	ofs = 0; prev = 0; npp = 0;
-	for (gp = d->d_gl; gp; gp = gp->g_next)
-	{
-		if (gp->g_ext || gp->g_inv) continue;
+	ofs = 0;
+	prev = 0;
+	npp = 0;
+	for (gp = d->d_gl; gp; gp = gp->g_next) {
+		if (gp->g_ext || gp->g_inv)
+			continue;
 		p = &gp->g_p[0];
 		if (gp == d->d_gl)
 			ofs = p->p_start + p->p_size;
-		else
-		{
-			if (p->p_start < ofs)
-			{
+		else {
+			if (p->p_start < ofs) {
 				/*
 				 * overlap. unlink and discard.
 				 */
 
 				prev->g_next = gp->g_next;
 				free((void *)gp);
-				gp = prev; npp++;
-			}
-			else
+				gp = prev;
+				npp++;
+			} else
 				ofs += p->p_size;
 		}
 		prev = gp;
 	}
 
 	if (npp)
-		pr(WARN,EM_DISCARDOVLP,npp);
+		pr(WARN, EM_DISCARDOVLP, npp);
 
 	/*
 	 * 2. pass: decide type of every partition,
@@ -1386,73 +1300,67 @@ static int check_partition_list(disk_desc *d)
 	 */
 
 	size = 0;
-	in_ext = npp = epp = 0; maxp = NDOSPARTS;
-	for (n = 1, gp = d->d_gl; gp; gp = gp->g_next, n++)
-	{
-		if (gp->g_inv) continue;
-		if (gp->g_ext)
-		{
-			if (gp->g_next == 0)
-			{
+	in_ext = npp = epp = 0;
+	maxp = NDOSPARTS;
+	for (n = 1, gp = d->d_gl; gp; gp = gp->g_next, n++) {
+		if (gp->g_inv)
+			continue;
+		if (gp->g_ext) {
+			if (gp->g_next == 0) {
 				/*
 				 * ext ptbl without logical p.
 				 */
 
 				gp->g_inv = 1;
-				warn_invalid(d,p,EM_P_EATEND);
+				warn_invalid(d, p, EM_P_EATEND);
 				break;
 			}
-			if (! in_ext)
-			{
+			if (!in_ext) {
 				/*
 				 * new extended p. chain.
 				 */
 
-				if (no_of_ext_partitions(gp->g_p) == 0)
-				{
+				if (no_of_ext_partitions(gp->g_p) == 0) {
 					gp->g_inv = 1;
-					warn_invalid(d,p,EM_P_EWLP);
+					warn_invalid(d, p, EM_P_EWLP);
 					continue;
 				}
 
-				in_ext = 1; epp++;
-				if (maxp >= NDOSPARTS) maxp--;
+				in_ext = 1;
+				epp++;
+				if (maxp >= NDOSPARTS)
+					maxp--;
 
 				/*
 				 * already had one?
 				 */
 
-				if (epp > 1)
-				{
+				if (epp > 1) {
 					gp->g_inv = 1;
-					warn_invalid(d,p,EM_P_MTOE);
+					warn_invalid(d, p, EM_P_MTOE);
 					continue;
 				}
-
 			}
 			if (no_of_ext_partitions(gp->g_p) == 0)
 				in_ext = 0;
 			rp = 0;
-			for (p = &gp->g_p[0]; p <= &gp->g_p[NDOSPARTS - 1]; p++)
-			{
+			for (p = &gp->g_p[0]; p <= &gp->g_p[NDOSPARTS - 1]; p++) {
 				if (is_real_parttype(p))
 					rp = p;
 				else if (is_ext_parttype(p) && (n == 1))
 					size = p->p_start;
 			}
 			gp = gp->g_next;
-			if (gp->g_ext)
-			{
+			if (gp->g_ext) {
 				/*
 				 * should not happen: a supposedly logical
 				 * partition which is an extended p itself.
 				 */
 
 				gp->g_inv = 1;
-				warn_invalid(d,p,EM_P_LISAE);
+				warn_invalid(d, p, EM_P_LISAE);
 				continue;
-			}
-			else
+			} else
 				gp->g_log = 1;
 
 			/*
@@ -1461,61 +1369,51 @@ static int check_partition_list(disk_desc *d)
 			 */
 
 			p = &gp->g_p[0];
-			if (is_real_parttype(p) && is_same_partition_type(rp,p) &&
-			    (rp->p_size >= p->p_size))
-			{
-				if (! is_sane_partentry(d,p,1))
+			if (is_real_parttype(p) && is_same_partition_type(rp, p) && (rp->p_size >= p->p_size)) {
+				if (!is_sane_partentry(d, p, 1))
 					gp->g_inv = 1;
 				else
 					size += gp->g_p[0].p_size + 1;
-			}
-			else
-			{
+			} else {
 				gp->g_inv = 1;
-				warn_invalid(d,p,EM_P_UTS);
+				warn_invalid(d, p, EM_P_UTS);
 			}
-		}
-		else if (! in_ext)
-		{
+		} else if (!in_ext) {
 			/*
 			 * primary entry.
 			 */
 
-			gp->g_prim = 1; p = &gp->g_p[0];
-			if (n == 1) size = p->p_start;
-			if (npp++ >= maxp)
-			{
+			gp->g_prim = 1;
+			p = &gp->g_p[0];
+			if (n == 1)
+				size = p->p_start;
+			if (npp++ >= maxp) {
 				gp->g_inv = 1;
-				warn_invalid(d,p,EM_P_2MANYPP);
-			}
-			else
-			{
-				if (! is_sane_partentry(d,p,1))
-				{
+				warn_invalid(d, p, EM_P_2MANYPP);
+			} else {
+				if (!is_sane_partentry(d, p, 1)) {
 					gp->g_inv = 1;
-					warn_invalid(d,p,EM_P_NOTSANE);
-				}
-				else
+					warn_invalid(d, p, EM_P_NOTSANE);
+				} else
 					size += p->p_size;
 			}
-		}
-		else
-		{
+		} else {
 			/*
 			 * in_ext && !gp->g_ext. This means the end
 			 * of the logical partition chain hasn't been
 			 * found. Reset it.
 			 */
 
-			in_ext = 0; gp->g_inv = 1;
-			warn_invalid(d,p,EM_P_ENDNOTF);
+			in_ext = 0;
+			gp->g_inv = 1;
+			warn_invalid(d, p, EM_P_ENDNOTF);
 		}
 	}
 
 	if (epp > 1)
-		pr(WARN,EM_TOOMANYXPTS,epp);
+		pr(WARN, EM_TOOMANYXPTS, epp);
 	if (npp > maxp)
-		pr(WARN,EM_TOOMANYPPTS,maxp,npp);
+		pr(WARN, EM_TOOMANYPPTS, maxp, npp);
 
 	/*
 	 * 3. pass: check logical partition chain. Logical
@@ -1523,19 +1421,18 @@ static int check_partition_list(disk_desc *d)
 	 * link chain are marked orphaned.
 	 */
 
-	in_ext = size = ofs = 0; lep = 0;
-	for (gp = d->d_gl; gp; gp = gp->g_next)
-	{
-		if (gp->g_inv) continue;
-		if (gp->g_ext)
-		{
-			if (! in_ext)
-			{
-				in_ext = 1; ofs = gp->g_sec;
+	in_ext = size = ofs = 0;
+	lep = 0;
+	for (gp = d->d_gl; gp; gp = gp->g_next) {
+		if (gp->g_inv)
+			continue;
+		if (gp->g_ext) {
+			if (!in_ext) {
+				in_ext = 1;
+				ofs = gp->g_sec;
 			}
 			rp = ep = 0;
-			for (p = &gp->g_p[0]; p <= &gp->g_p[NDOSPARTS - 1]; p++)
-			{
+			for (p = &gp->g_p[0]; p <= &gp->g_p[NDOSPARTS - 1]; p++) {
 				if (is_real_parttype(p))
 					rp = p;
 				else if (is_ext_parttype(p))
@@ -1545,7 +1442,8 @@ static int check_partition_list(disk_desc *d)
 			if (lep && rp)
 				if (gp->g_sec != ofs + lep->p_start)
 					gp->g_next->g_orph = 1;
-			if (ep) lep = ep;
+			if (ep)
+				lep = ep;
 			gp = gp->g_next;
 		}
 	}
@@ -1561,19 +1459,24 @@ static int check_partition_list(disk_desc *d)
 	else
 		size = ofs = 0;
 
-	for (gp = d->d_gl; gp; gp = gp->g_next)
-	{
-		if (gp->g_ext) continue;
+	for (gp = d->d_gl; gp; gp = gp->g_next) {
+		if (gp->g_ext)
+			continue;
 		p = &gp->g_p[0];
-		if (gp->g_log) pr(MSG,"   ");
-		pr(MSG,"Partition(%s): ",get_part_type(p->p_typ));
-		if (gp->g_inv)  pr(MSG,PM_G_INVALID);
-		if (gp->g_orph) pr(MSG,PM_G_ORPHANED);
-		if (gp->g_prim) pr(MSG,PM_G_PRIMARY);
-		if (gp->g_log)  pr(MSG,PM_G_LOGICAL);
-		pr(MSG,"\n"); 
+		if (gp->g_log)
+			pr(MSG, "   ");
+		pr(MSG, "Partition(%s): ", get_part_type(p->p_typ));
+		if (gp->g_inv)
+			pr(MSG, PM_G_INVALID);
+		if (gp->g_orph)
+			pr(MSG, PM_G_ORPHANED);
+		if (gp->g_prim)
+			pr(MSG, PM_G_PRIMARY);
+		if (gp->g_log)
+			pr(MSG, PM_G_LOGICAL);
+		pr(MSG, "\n");
 		if (f_verbose > 1)
-			print_partition(d,p,gp->g_log ? 1 : 0,0);
+			print_partition(d, p, gp->g_log ? 1 : 0, 0);
 	}
 
 	/*
@@ -1581,31 +1484,29 @@ static int check_partition_list(disk_desc *d)
 	 */
 
 	in_ext = n = 0;
-	memset(&d->d_gpt,0,sizeof(dos_part_table));
-	for (gp = d->d_gl; gp; gp = gp->g_next)
-	{
-		if (n >= NDOSPARTS) break;
-		if (gp->g_inv) continue;
-		if (gp->g_ext)
-		{
-			if (! in_ext)
-			{
+	memset(&d->d_gpt, 0, sizeof(dos_part_table));
+	for (gp = d->d_gl; gp; gp = gp->g_next) {
+		if (n >= NDOSPARTS)
+			break;
+		if (gp->g_inv)
+			continue;
+		if (gp->g_ext) {
+			if (!in_ext) {
 				in_ext = 1;
-				if (size && ofs)
-				{
+				if (size && ofs) {
 					p = &d->d_gpt.t_parts[n++];
 					p->p_start = ofs;
 					p->p_typ = 0x05;
 					p->p_typ = d->d_lba ? 0x0F : 0x05;
 					p->p_size = size;
-					fillin_dos_chs(d,p,0);
+					fillin_dos_chs(d, p, 0);
 				}
 			}
 			gp = gp->g_next;
 			continue;
 		}
 		if (gp->g_prim)
-			memcpy(&d->d_gpt.t_parts[n++],&gp->g_p[0],sizeof(dos_part_entry));
+			memcpy(&d->d_gpt.t_parts[n++], &gp->g_p[0], sizeof(dos_part_entry));
 	}
 
 	/*
@@ -1614,15 +1515,12 @@ static int check_partition_list(disk_desc *d)
 	 * write_primary_ptbl that it seems to be ok.
 	 */
 
-	ep = 0; npp = 0;
-	for (n = 0; n < NDOSPARTS; n++)
-	{
+	ep = 0;
+	npp = 0;
+	for (n = 0; n < NDOSPARTS; n++) {
 		p = &d->d_gpt.t_parts[n];
-		if (ep && p->p_typ)
-		{
-			if ((ep->p_start + ep->p_size > p->p_start) ||
-			    ! is_sane_partentry(d,p,1))
-			{
+		if (ep && p->p_typ) {
+			if ((ep->p_start + ep->p_size > p->p_start) || !is_sane_partentry(d, p, 1)) {
 				/*
 				 * zis is not funny. Perhaps the p. list
 				 * can be re-checked but for now only
@@ -1630,27 +1528,22 @@ static int check_partition_list(disk_desc *d)
 				 */
 
 				npp++;
-				if (f_verbose > 2)
-				{
-					pr(WARN,EM_PINCONS);
-					print_partition(d,p,0,0);
+				if (f_verbose > 2) {
+					pr(WARN, EM_PINCONS);
+					print_partition(d, p, 0, 0);
 				}
 			}
 		}
 		ep = p;
 	}
-	if (npp == 0)
-	{
+	if (npp == 0) {
 		d->d_gpt.t_magic = le16(DOSPTMAGIC);
-		pr(MSG,"Ok.\n");
-	}
-	else
-		pr(MSG,DM_NOOFINCONS,npp);
+		pr(MSG, "Ok.\n");
+	} else
+		pr(MSG, DM_NOOFINCONS, npp);
 	return (npp);
 }
 
-
-
 /*
  * compare both existing and guessed partition tables.
  * The order of the ptbl entries is not important (the
@@ -1660,15 +1553,13 @@ static int check_partition_list(disk_desc *d)
 
 static int compare_parttables(disk_desc *d)
 {
-	int		ret, i, j, diff;
-	byte_t		*pr, *pg;
+	int ret, i, j, diff;
+	byte_t *pr, *pg;
 
 	ret = 0;
-	for (i = 0; i < NDOSPARTS; i++)
-	{
+	for (i = 0; i < NDOSPARTS; i++) {
 		pr = (byte_t *)&d->d_pt.t_parts[i];
-		for (j = 0; j < NDOSPARTS; j++)
-		{
+		for (j = 0; j < NDOSPARTS; j++) {
 			pg = (byte_t *)&d->d_gpt.t_parts[j];
 
 			/*
@@ -1676,128 +1567,137 @@ static int compare_parttables(disk_desc *d)
 			 * in the comparison.
 			 */
 
-			diff = memcmp(pr + 1,pg + 1,sizeof(dos_part_entry) - 1);
-			if (diff == 0) break;
+			diff = memcmp(pr + 1, pg + 1, sizeof(dos_part_entry) - 1);
+			if (diff == 0)
+				break;
 		}
-		if (diff) ret++;
+		if (diff)
+			ret++;
 	}
 	return (ret);
 }
 
-
-
 /*
  * main
  */
 
-int main(int ac,char **av)
+int main(int ac, char **av)
 {
-	char		*optstr = "b:C:cdEefghiK:k:Ll:n:qs:t:VvW:w:";
-	char		*p1, *p2, *p3, *odev = 0, *backup = 0;
-	int		opt, sectsize = 0, no_of_incons = 0;
-	disk_desc	*d;
-
+	char *optstr = "b:C:cdEefghiK:k:Ll:n:qs:t:VvW:w:";
+	char *p1, *p2, *p3, *odev = 0, *backup = 0;
+	int opt, sectsize = 0, no_of_incons = 0;
+	disk_desc *d;
 
 	g_mod_addinternals();
-	while ((opt = getopt(ac,av,optstr)) != -1)
-		switch (opt)
-		{
-			case 'b' :
-				backup = optarg; break;
-			case 'C' :
-				if (! get_csep_arg(optarg,&p1,&p2,&p3))
-				{
-					usage();
-					return (EXIT_FAILURE);
-				}
-				gc = strtoul(p1,0,0);
-				if (errno == ERANGE) pr(FATAL,EM_INVVALUE);
-				gh = strtoul(p2,0,0);
-				if (errno == ERANGE) pr(FATAL,EM_INVVALUE);
-				gs = strtoul(p3,0,0);
-				if (errno == ERANGE) pr(FATAL,EM_INVVALUE);
-				break;
-			case 'c' :
-				f_check = 1; break;
-			case 'd' :
-				f_dontguess = 1; break;
-			case 'E' :
-				f_testext = 0; break;
-			case 'e' :
-				f_skiperrors = 0; break;
-			case 'f' :
-				f_fast = 0; break;
-			case 'g' :
-				f_getgeom = 0; break;
-			case 'i' :
-				f_interactive = 1; break;
-			case 'K' :
-				maxsec = strtoul(optarg,0,0);
-				if ((maxsec <= 0) || (errno == ERANGE))
-					pr(FATAL,EM_INVVALUE);
-				break;
-			case 'k' :
-				/* strtos64? */
-				skipsec = strtoul(optarg,0,0);
-				if (errno == ERANGE) pr(FATAL,EM_INVVALUE);
-				break;
-			case 'n' :
-				if ((*optarg == 's') || (*optarg == 'h') ||
-					(*optarg == 'c'))
-					increment = *optarg;
-				else
-				{
-					increment = strtoul(optarg,0,0);
-					if (errno == ERANGE)
-						pr(FATAL,EM_INVVALUE);
-				}
-				break;
-			case 'l' :
-				if (logfile) fclose(logfile);
-				if ((logfile = fopen(optarg,"w")) == 0)
-					pr(FATAL,EM_OPENLOG,optarg);
-				break;
-			case 'L' :
-				g_mod_list();
-				return (EXIT_SUCCESS);
-			case 'q' :
-				f_quiet = 1; break;
-			case 's' :
-				if ((sectsize = atoi(optarg)) <= 0)
-					pr(FATAL,"sector size must be >= 0");
-				break;
-			case 'v' :
-				f_verbose++; break;
-			case 'V' :
-				fprintf(stderr,"%s\n",gpart_version);
-				return (EXIT_SUCCESS);
-			case 'w' :
-				if (! get_csep_arg(optarg,&p1,&p2,0))
-				{
-					usage();
-					return (EXIT_FAILURE);
-				}
-				if (! g_mod_setweight(p1,atof(p2)))
-					pr(FATAL,EM_NOSUCHMOD,p1);
-				break;
-			case 'W' :
-				odev = optarg;
-				break;
-			case '?' :
-			case 'h' :
-			default :
-				usage(); return (EXIT_FAILURE);
+	while ((opt = getopt(ac, av, optstr)) != -1)
+		switch (opt) {
+		case 'b':
+			backup = optarg;
+			break;
+		case 'C':
+			if (!get_csep_arg(optarg, &p1, &p2, &p3)) {
+				usage();
+				return (EXIT_FAILURE);
+			}
+			gc = strtoul(p1, 0, 0);
+			if (errno == ERANGE)
+				pr(FATAL, EM_INVVALUE);
+			gh = strtoul(p2, 0, 0);
+			if (errno == ERANGE)
+				pr(FATAL, EM_INVVALUE);
+			gs = strtoul(p3, 0, 0);
+			if (errno == ERANGE)
+				pr(FATAL, EM_INVVALUE);
+			break;
+		case 'c':
+			f_check = 1;
+			break;
+		case 'd':
+			f_dontguess = 1;
+			break;
+		case 'E':
+			f_testext = 0;
+			break;
+		case 'e':
+			f_skiperrors = 0;
+			break;
+		case 'f':
+			f_fast = 0;
+			break;
+		case 'g':
+			f_getgeom = 0;
+			break;
+		case 'i':
+			f_interactive = 1;
+			break;
+		case 'K':
+			maxsec = strtoul(optarg, 0, 0);
+			if ((maxsec <= 0) || (errno == ERANGE))
+				pr(FATAL, EM_INVVALUE);
+			break;
+		case 'k':
+			/* strtos64? */
+			skipsec = strtoul(optarg, 0, 0);
+			if (errno == ERANGE)
+				pr(FATAL, EM_INVVALUE);
+			break;
+		case 'n':
+			if ((*optarg == 's') || (*optarg == 'h') || (*optarg == 'c'))
+				increment = *optarg;
+			else {
+				increment = strtoul(optarg, 0, 0);
+				if (errno == ERANGE)
+					pr(FATAL, EM_INVVALUE);
+			}
+			break;
+		case 'l':
+			if (logfile)
+				fclose(logfile);
+			if ((logfile = fopen(optarg, "w")) == 0)
+				pr(FATAL, EM_OPENLOG, optarg);
+			break;
+		case 'L':
+			g_mod_list();
+			return (EXIT_SUCCESS);
+		case 'q':
+			f_quiet = 1;
+			break;
+		case 's':
+			if ((sectsize = atoi(optarg)) <= 0)
+				pr(FATAL, "sector size must be >= 0");
+			break;
+		case 'v':
+			f_verbose++;
+			break;
+		case 'V':
+			fprintf(stderr, "%s\n", gpart_version);
+			return (EXIT_SUCCESS);
+		case 'w':
+			if (!get_csep_arg(optarg, &p1, &p2, 0)) {
+				usage();
+				return (EXIT_FAILURE);
+			}
+			if (!g_mod_setweight(p1, atof(p2)))
+				pr(FATAL, EM_NOSUCHMOD, p1);
+			break;
+		case 'W':
+			odev = optarg;
+			break;
+		case '?':
+		case 'h':
+		default:
+			usage();
+			return (EXIT_FAILURE);
 		}
 
-	if ((optind + 1) != ac)
-	{
+	if ((optind + 1) != ac) {
 		usage();
 		return (EXIT_FAILURE);
 	}
 
-	if (f_dontguess) f_check = 0;
-	if (f_check)
-	{
+	if (f_dontguess)
+		f_check = 0;
+	if (f_check) {
 		f_quiet = 1;
 		f_dontguess = 0;
 		odev = 0;
@@ -1805,32 +1705,33 @@ int main(int ac,char **av)
 	if (f_quiet)
 		f_interactive = 0;
 
-	sync(); d = get_disk_desc(av[optind],sectsize);
+	sync();
+	d = get_disk_desc(av[optind], sectsize);
 	if (f_verbose > 0)
 		print_disk_desc(d);
 	if (f_verbose > 2)
 		print_mboot_block(d);
 
-	if (! f_dontguess)
-	{
-		sleep(1); sync();
+	if (!f_dontguess) {
+		sleep(1);
+		sync();
 		do_guess_loop(d);
 		no_of_incons = check_partition_list(d);
-		pr(MSG,DM_GUESSEDPTBL);
-		print_ptable(d,&d->d_gpt,0);
+		pr(MSG, DM_GUESSEDPTBL);
+		print_ptable(d, &d->d_gpt, 0);
 
 		if ((no_of_incons == 0) && f_check)
 			no_of_incons = compare_parttables(d);
 
-		if ((no_of_incons == 0) && odev)
-		{
+		if ((no_of_incons == 0) && odev) {
 			if (backup)
-				make_mbr_backup(d,backup);
-			write_primary_ptbl(d,odev);
+				make_mbr_backup(d, backup);
+			write_primary_ptbl(d, odev);
 		}
 	}
 	free_disk_desc(d);
-	if (logfile) fclose(logfile);
+	if (logfile)
+		fclose(logfile);
 
 	return (f_check ? no_of_incons : 0);
 }
diff --git a/src/gpart.h b/src/gpart.h
index d973d65..e6e213c 100644
--- a/src/gpart.h
+++ b/src/gpart.h
@@ -26,8 +26,6 @@
 
 typedef uint8_t byte_t;
 
-
-
 #define le16(x) htole16(x)
 #define be16(x) htobe16(x)
 #define le32(x) htole32(x)
diff --git a/src/l64seek.c b/src/l64seek.c
index a9df80a..2d75a17 100644
--- a/src/l64seek.c
+++ b/src/l64seek.c
@@ -17,36 +17,28 @@
 #include "config.h" /* for large file support */
 #include "l64seek.h"
 
-
-#define OSTACKLEN	16
-static struct
-{
-	s64_t		fpos;
-	int		fd;
+#define OSTACKLEN 16
+static struct {
+	s64_t fpos;
+	int fd;
 } ostck[OSTACKLEN];
-static int		osptr = -1;
-
-
+static int osptr = -1;
 
-off64_t l64seek(int fd,off64_t offset,int whence)
+off64_t l64seek(int fd, off64_t offset, int whence)
 {
-	off64_t		ret = (off64_t)-1;
+	off64_t ret = (off64_t)-1;
 
-	ret = lseek(fd,offset,whence);
+	ret = lseek(fd, offset, whence);
 
 	return (ret);
 }
 
-
-
 int l64opush(int fd)
 {
-	s64_t		fpos;
+	s64_t fpos;
 
-	if (osptr < OSTACKLEN - 1)
-	{
-		if ((fpos = l64tell(fd)) >= 0)
-		{
+	if (osptr < OSTACKLEN - 1) {
+		if ((fpos = l64tell(fd)) >= 0) {
 			ostck[++osptr].fd = fd;
 			ostck[osptr].fpos = fpos;
 			return (1);
@@ -55,7 +47,6 @@ int l64opush(int fd)
 	return (0);
 }
 
-
 s64_t l64opop(int fd)
 {
 	if ((osptr >= 0) && (ostck[osptr].fd == fd))
diff --git a/src/l64seek.h b/src/l64seek.h
index 669b655..5e8dc4b 100644
--- a/src/l64seek.h
+++ b/src/l64seek.h
@@ -31,7 +31,7 @@ typedef loff_t off64_t;
 typedef off64_t s64_t;
 
 off64_t l64seek(int fd, off64_t offset, int whence);
-#define l64tell(fd) l64seek(fd,0,SEEK_CUR)
+#define l64tell(fd) l64seek(fd, 0, SEEK_CUR)
 int l64opush(int);
 s64_t l64opop(int);
 
-- 
2.15.1

From 3b13b2f1c15ce1efd3144671495de4522b4ba282 Mon Sep 17 00:00:00 2001
From: Baruch Even <baruch@ev-en.org>
Date: Wed, 25 Nov 2015 08:58:10 +0200
Subject: [PATCH 03/11] Speed up by reading larger chunks

Based on work initiated by mwilck
---
 src/gpart.c | 26 ++++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/gpart.c b/src/gpart.c
index 936ceb0..2008dde 100644
--- a/src/gpart.c
+++ b/src/gpart.c
@@ -162,19 +162,25 @@ byte_t *alloc(ssize_t s)
 
 ssize_t bread(int fd, byte_t *buf, size_t ssize, size_t nsecs)
 {
-	ssize_t cs = 0, nr = 0;
-
-	for (; nsecs > 0; nsecs--) {
-		if ((nr = read(fd, buf, ssize)) == -1) {
+	const size_t total = ssize * nsecs;
+	size_t read_bytes = 0;
+
+	while (read_bytes < total) {
+		ssize_t ret = read(fd, buf + read_bytes, total - read_bytes);
+		if (ret > 0)
+			read_bytes += ret;
+		else if (ret == 0) {
+			return read_bytes;
+		} else {
+			// ret < 0, an error case
+			if (errno == EINTR)
+				continue; // Rogue signal interruption, retry
 			berrno = errno;
-			return ((cs == 0) ? -1 : cs);
-		}
-		cs += nr;
-		buf += nr;
-		if (nr < ssize)
 			break;
+		}
 	}
-	return (cs);
+
+	return read_bytes ? read_bytes : -1;
 }
 
 static int yesno(char *q)
-- 
2.15.1

From 06132088cd07ec9d8e35ccb8ab049e608098f747 Mon Sep 17 00:00:00 2001
From: Martin Wilck <mwilck@arcor.de>
Date: Thu, 19 Nov 2015 23:24:43 +0100
Subject: [PATCH 04/11] gpart: use posix_fadvise to increase reading speed

Use fadvise to tell the OS to try readahead.
---
 configure.ac | 2 +-
 src/gpart.c  | 4 ++++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 6eca1de..21dfc00 100644
--- a/configure.ac
+++ b/configure.ac
@@ -26,7 +26,7 @@ AC_TYPE_UINT8_T
 
 # Checks for library functions.
 AC_FUNC_MALLOC
-AC_CHECK_FUNCS([getpagesize memset strchr strdup strerror strtoul])
+AC_CHECK_FUNCS([getpagesize memset strchr strdup strerror strtoul posix_fadvise])
 
 # Configure system services.
 AC_SYS_LARGEFILE
diff --git a/src/gpart.c b/src/gpart.c
index 2008dde..171d640 100644
--- a/src/gpart.c
+++ b/src/gpart.c
@@ -891,6 +891,10 @@ static void do_guess_loop(disk_desc *d)
 	if ((d->d_fd = open(d->d_dev, O_RDONLY)) == -1)
 		pr(FATAL, EM_OPENFAIL, d->d_dev, strerror(errno));
 
+#if HAVE_POSIX_FADVISE
+	posix_fadvise(d->d_fd, 0, 0, POSIX_FADV_SEQUENTIAL);
+	posix_fadvise(d->d_fd, 0, 0, POSIX_FADV_WILLNEED);
+#endif /* HAVE_POSIX_FADVISE */
 	/*
 	 * initialize modules. Each should return the minimum
 	 * size in bytes it wants to receive for a test.
-- 
2.15.1

From b037b39e923a4c13bb21bb5270962995e001273d Mon Sep 17 00:00:00 2001
From: Martin Wilck <mwilck@arcor.de>
Date: Fri, 20 Nov 2015 00:17:13 +0100
Subject: [PATCH 05/11] gpart: avoid superfluous seek calls

The l64opush() logic would cause 2 lseek() syscalls per guess loop.
By simply seeking back after every probing call, we do with a single
seek() call.
---
 src/gpart.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/gpart.c b/src/gpart.c
index 171d640..3b44a75 100644
--- a/src/gpart.c
+++ b/src/gpart.c
@@ -954,12 +954,13 @@ scanloop:
 	while ((rd = bread(d->d_fd, d->d_sbuf, d->d_ssize, nsecs)) == bsize) {
 		int mod, have_ext = 0;
 		g_module *bg;
-		s64_t sz, ofs;
+		s64_t sz, ofs, fpos;
 
 		d->d_nsb += incr;
 		noffset = 0;
 		ofs = d->d_nsb;
 		s2mb(d, ofs);
+		fpos = d->d_nsb * d->d_ssize + bsize;
 		if (maxsec && (d->d_nsb > maxsec))
 			break;
 
@@ -980,16 +981,14 @@ scanloop:
 			/*
 			 * because a gmodule is allowed to seek on
 			 * d->d_fd the current file position must be
-			 * saved.
+			 * restored after calling it.
 			 */
 
 			memset(&m->m_part, 0, sizeof(dos_part_entry));
 			m->m_guess = GM_NO;
-			l64opush(d->d_fd);
 			if ((*m->m_gfun)(d, m) && (m->m_guess * m->m_weight >= GM_PERHAPS))
 				guesses[mod++] = m;
-			if ((sz = l64opop(d->d_fd)) != l64tell(d->d_fd))
-				l64seek(d->d_fd, sz, SEEK_SET);
+			l64seek(d->d_fd, fpos, SEEK_SET);
 		}
 
 		/*
-- 
2.15.1

From 0529a52485411be351bb75d628edc187a53c0e40 Mon Sep 17 00:00:00 2001
From: Baruch Even <baruch@ev-en.org>
Date: Wed, 25 Nov 2015 23:02:38 +0200
Subject: [PATCH 06/11] Fix crash on a non-disk device

Closes #9
---
 src/disku.c | 96 ++++++++++++++++++++++++++++++++-----------------------------
 1 file changed, 51 insertions(+), 45 deletions(-)

diff --git a/src/disku.c b/src/disku.c
index 4a5ca02..6c7e86b 100644
--- a/src/disku.c
+++ b/src/disku.c
@@ -35,60 +35,30 @@
 
 #include <unistd.h>
 
-/*
- * get disk geometry. The medium is opened for reading,
- * descriptor in d_fd.
- */
-
-struct disk_geom *disk_geometry(disk_desc *d)
-{
-	static struct disk_geom g;
-	uint64_t nsects;
-
-	memset(&g, 0, sizeof(g));
-
 #if defined(__linux__)
+static void os_disk_geometry(disk_desc *d, struct disk_geom *g)
+{
 	struct hd_geometry hg;
-#endif
-#if defined(__FreeBSD__)
-	struct disklabel dl;
-#endif
-
-	struct stat st;
-	int ret;
-	uint64_t lba;
-	ret = stat(d->d_dev, &st);
-	if (ret == 0) {
-		if (S_ISREG(st.st_mode)) {
-			nsects = st.st_size / 512;
-			if (nsects == 0)
-				pr(FATAL, EM_FATALERROR, "Not a block device image file");
-			lba = nsects - 1;
-			g.d_h = (lba / 63) % 255;
-			g.d_s = lba % 63 + 1;
-			g.d_c = lba / (255 * 63);
-			g.d_nsecs = nsects;
-			return (&g);
-		}
-	}
+	uint64_t nsects;
 
-#if defined(__linux__)
 	if (ioctl(d->d_fd, HDIO_GETGEO, &hg) == -1)
 		pr(FATAL, EM_IOCTLFAILED, "HDIO_GETGEO", strerror(errno));
+	else {
+		g->d_h = hg.heads;
+		g->d_s = hg.sectors;
+		g->d_c = hg.cylinders;
+	}
 #ifdef BLKGETSIZE
 	if (ioctl(d->d_fd, BLKGETSIZE, &nsects) == -1)
 		pr(FATAL, EM_IOCTLFAILED, "BLKGETSIZE", strerror(errno));
-	g.d_nsecs = nsects;
-	g.d_c = nsects / (hg.heads * hg.sectors);
-#else
-	g.d_c = hg.cylinders;
-#endif
-	g.d_h = hg.heads;
-	g.d_s = hg.sectors;
-
+	else
+		g->d_c = nsects / (hg.heads * hg.sectors);
 #endif
-
-#if defined(__FreeBSD__)
+}
+#elif defined(__FreeBSD__)
+static void os_disk_geometry(disk_desc *d, struct disk_geom *g)
+{
+	struct disklabel dl;
 	struct disklabel loclab;
 	u_int u;
 	off_t o; /* total disk size */
@@ -110,8 +80,44 @@ struct disk_geom *disk_geometry(disk_desc *d)
 
 	g.d_nsecs = o / u;
 	g.d_c = g.d_nsecs / g.d_h / g.d_s;
+}
+#else
+#error Only Linux and FreeBSD supported
 #endif
 
+/*
+ * get disk geometry. The medium is opened for reading,
+ * descriptor in d_fd.
+ */
+
+struct disk_geom *disk_geometry(disk_desc *d)
+{
+	static struct disk_geom g;
+	uint64_t nsects;
+
+	memset(&g, 0, sizeof(g));
+
+	struct stat st;
+	int ret;
+	uint64_t lba;
+	ret = stat(d->d_dev, &st);
+	if (ret == 0) {
+		// We have something, we'll use it for a first fill of the data
+		nsects = st.st_size / 512;
+		if (nsects == 0)
+			pr(FATAL, EM_FATALERROR, "Not a block device image file");
+		lba = nsects - 1;
+		g.d_h = (lba / 63) % 255;
+		g.d_s = lba % 63 + 1;
+		g.d_c = lba / (255 * 63);
+		g.d_nsecs = nsects;
+
+		// If it is a regular file there is no reason to try anything else
+		if (S_ISREG(st.st_mode))
+			return (&g);
+	}
+
+	os_disk_geometry(d, &g);
 	return (&g);
 }
 
-- 
2.15.1

From cbdefb633797ccfbc86ec4c6268292f20621d20f Mon Sep 17 00:00:00 2001
From: Baruch Even <baruch@ev-en.org>
Date: Wed, 25 Nov 2015 23:11:22 +0200
Subject: [PATCH 07/11] Real fix for crash

Now we can work on a block device properly, closes #9 properly.
---
 src/disku.c | 36 +++++++++++++++++++++---------------
 1 file changed, 21 insertions(+), 15 deletions(-)

diff --git a/src/disku.c b/src/disku.c
index 6c7e86b..d50cebf 100644
--- a/src/disku.c
+++ b/src/disku.c
@@ -35,6 +35,16 @@
 
 #include <unistd.h>
 
+static void geometry_from_num_sectors(struct disk_geom *g, uint64_t nsects)
+{
+	const uint64_t lba = nsects - 1;
+
+	g->d_h = (lba / 63) % 255;
+	g->d_s = lba % 63 + 1;
+	g->d_c = lba / (255 * 63);
+	g->d_nsecs = nsects;
+}
+
 #if defined(__linux__)
 static void os_disk_geometry(disk_desc *d, struct disk_geom *g)
 {
@@ -51,8 +61,12 @@ static void os_disk_geometry(disk_desc *d, struct disk_geom *g)
 #ifdef BLKGETSIZE
 	if (ioctl(d->d_fd, BLKGETSIZE, &nsects) == -1)
 		pr(FATAL, EM_IOCTLFAILED, "BLKGETSIZE", strerror(errno));
-	else
-		g->d_c = nsects / (hg.heads * hg.sectors);
+	else {
+		if (hg.heads && hg.sectors)
+			g->d_c = nsects / (hg.heads * hg.sectors);
+		else
+			geometry_from_num_sectors(g, nsects);
+	}
 #endif
 }
 #elif defined(__FreeBSD__)
@@ -94,27 +108,19 @@ struct disk_geom *disk_geometry(disk_desc *d)
 {
 	static struct disk_geom g;
 	uint64_t nsects;
+	struct stat st;
+	int ret;
 
 	memset(&g, 0, sizeof(g));
 
-	struct stat st;
-	int ret;
-	uint64_t lba;
 	ret = stat(d->d_dev, &st);
-	if (ret == 0) {
+	if (ret == 0 && S_ISREG(st.st_mode)) {
 		// We have something, we'll use it for a first fill of the data
 		nsects = st.st_size / 512;
 		if (nsects == 0)
 			pr(FATAL, EM_FATALERROR, "Not a block device image file");
-		lba = nsects - 1;
-		g.d_h = (lba / 63) % 255;
-		g.d_s = lba % 63 + 1;
-		g.d_c = lba / (255 * 63);
-		g.d_nsecs = nsects;
-
-		// If it is a regular file there is no reason to try anything else
-		if (S_ISREG(st.st_mode))
-			return (&g);
+		geometry_from_num_sectors(&g, nsects);
+		return (&g);
 	}
 
 	os_disk_geometry(d, &g);
-- 
2.15.1

From 5fa7b6f405ae651af06a50e85c80cc2a76116538 Mon Sep 17 00:00:00 2001
From: Baruch Even <baruch@ev-en.org>
Date: Thu, 26 Nov 2015 22:51:47 +0200
Subject: [PATCH 08/11] Respect configure --docdir option

Closes #10
---
 Makefile.am | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Makefile.am b/Makefile.am
index 51932b2..72b5914 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,6 +1,5 @@
 AUTOMAKE_OPTIONS = foreign
 SUBDIRS = src man
 
-docdir = $(datadir)/doc/@PACKAGE@
 doc_DATA = Changes README.md
 EXTRA_DIST = Changes README.md
-- 
2.15.1

From deffb405040d6f70682657bcf930f92e2a9a7458 Mon Sep 17 00:00:00 2001
From: Baruch Even <baruch@ev-en.org>
Date: Sat, 28 Nov 2015 20:48:00 +0200
Subject: [PATCH 09/11] Use new travis build system

---
 .travis.yml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.travis.yml b/.travis.yml
index ddffe97..0b7d5c4 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,4 +1,5 @@
 language: c
+sudo: false
 
 script: ./autogen.sh && make
 
-- 
2.15.1

From b25626882ebfb407de5a688cec7291c77c5af5aa Mon Sep 17 00:00:00 2001
From: Sergiu Puscas <srg.pscs@gmail.com>
Date: Tue, 18 Apr 2017 10:50:46 +0300
Subject: [PATCH 10/11] fixed README table

---
 README.md | 50 +++++++++++++++++++++++++-------------------------
 1 file changed, 25 insertions(+), 25 deletions(-)

diff --git a/README.md b/README.md
index 330821b..414b652 100644
--- a/README.md
+++ b/README.md
@@ -21,28 +21,28 @@ See file *INSTALL*.
 
 ## Currently recognized partitions/filesystems types
 
-   Modname  | Typ  | Description
-   :--------|:----:|:------------
-   fat      | 0x01 | Primary DOS with 12 bit FAT
-            | 0x04 | Primary DOS with 16 bit FAT (<= 32MB)
-            | 0x06 | Primary 'big' DOS (> 32MB)
-            | 0x0B | DOS or Windows 95 with 32 bit FAT
-            | 0x0C | DOS or Windows 95 with 32 bit FAT, LBA
-   ntfs     | 0x07 | OS/2 HPFS, NTFS, QNX or Advanced UNIX
-   hpfs     | 0x07 | OS/2 HPFS, NTFS, QNX or Advanced UNIX
-   ext2     | 0x83 | Linux ext2 filesystem
-   lswap    | 0x82 | Linux swap
-   bsddl    | 0xA5 | FreeBSD/NetBSD/386BSD
-   s86dl    | 0x82 | Solaris/x86 disklabel
-   minix    | 0x80 | Minix V1
-            | 0x81 | Minix V2
-   reiserfs | 0x83 | ReiserFS filesystem
-   hmlvm    | 0xFE | Linux LVM physical volumes
-   qnx4     | 0x4F | QNX 4.x
-   beos     | 0xEB | BeOS fs
-   xfs      | 0x83 | SGI XFS filesystem
-   btrfs    | 0x83 | BtrFS
-   LVM2     | 0x8E | LVM2
+   Modname    | Typ  | Description
+   :----------|:----:|:------------
+   | fat      | 0x01 | Primary DOS with 12 bit FAT
+   |          | 0x04 | Primary DOS with 16 bit FAT (<= 32MB)
+   |          | 0x06 | Primary 'big' DOS (> 32MB)
+   |          | 0x0B | DOS or Windows 95 with 32 bit FAT
+   |          | 0x0C | DOS or Windows 95 with 32 bit FAT, LBA
+   | ntfs     | 0x07 | OS/2 HPFS, NTFS, QNX or Advanced UNIX
+   | hpfs     | 0x07 | OS/2 HPFS, NTFS, QNX or Advanced UNIX
+   | ext2     | 0x83 | Linux ext2 filesystem
+   | lswap    | 0x82 | Linux swap
+   | bsddl    | 0xA5 | FreeBSD/NetBSD/386BSD
+   | s86dl    | 0x82 | Solaris/x86 disklabel
+   | minix    | 0x80 | Minix V1
+   |          | 0x81 | Minix V2
+   | reiserfs | 0x83 | ReiserFS filesystem
+   | hmlvm    | 0xFE | Linux LVM physical volumes
+   | qnx4     | 0x4F | QNX 4.x
+   | beos     | 0xEB | BeOS fs
+   | xfs      | 0x83 | SGI XFS filesystem
+   | btrfs    | 0x83 | BtrFS
+   | LVM2     | 0x8E | LVM2
 
 
 ## Guessing modules
@@ -106,12 +106,12 @@ Here is a sample `gpart -v` run on my first IDE hard disk
        hex:  80 01 01 00 06 FE 3F 3F 3F 00 00 00 01 B0 0F 00
 
 >   `size`: the size of the partition in megabytes, number of
->   sectors and the sector range.  
+>   sectors and the sector range.
 >   `chs`: the partition table chs range (`d`) and the real one
 >   (`r`). If the number of cylinders is less than 1024, both
->   are identical.  
+>   are identical.
 >   `hex`: the hexadecimal representation of the partition entry
->   as found in the partition table.  
+>   as found in the partition table.
 
 ...
 
-- 
2.15.1

From c0015ad5e56df8bc20e88ee5074e9f3e6e3d849d Mon Sep 17 00:00:00 2001
From: sfanxiang <sfanxiang@gmail.com>
Date: Sun, 31 Dec 2017 22:19:40 +0800
Subject: [PATCH 11/11] add support for Haiku

---
 src/disku.c   | 28 +++++++++++++++++++++++++++-
 src/gpart.c   | 17 +++++++++++++++++
 src/gpart.h   | 30 ++++++++++++++++++++++++++++++
 src/l64seek.h |  4 ++++
 4 files changed, 78 insertions(+), 1 deletion(-)

diff --git a/src/disku.c b/src/disku.c
index d50cebf..1761210 100644
--- a/src/disku.c
+++ b/src/disku.c
@@ -33,6 +33,11 @@
 #include <sys/disk.h>
 #endif
 
+#if defined(__HAIKU__)
+#include <drivers/Drivers.h>
+#include <fcntl.h>
+#endif
+
 #include <unistd.h>
 
 static void geometry_from_num_sectors(struct disk_geom *g, uint64_t nsects)
@@ -95,8 +100,29 @@ static void os_disk_geometry(disk_desc *d, struct disk_geom *g)
 	g.d_nsecs = o / u;
 	g.d_c = g.d_nsecs / g.d_h / g.d_s;
 }
+#elif defined(__HAIKU__)
+static void os_disk_geometry(disk_desc *d, struct disk_geom *g)
+{
+	device_geometry geom;
+	int fd;
+
+	if ((fd = open(d->d_dev, O_RDONLY)) < 0)
+		pr(FATAL, EM_OPENFAIL, d->d_dev, strerror(errno));
+
+	if (ioctl(fd, B_GET_GEOMETRY, &geom, sizeof(geom)) < 0) {
+		close(fd);
+		pr(FATAL, EM_IOCTLFAILED, "B_GET_GEOMETRY", strerror(errno));
+	}
+
+	close(fd);
+
+	g->d_c = geom.cylinder_count;
+	g->d_h = geom.head_count;
+	g->d_s = geom.sectors_per_track;
+	g->d_nsecs = ((uint64_t)g->d_c) * g->d_h * g->d_s;
+}
 #else
-#error Only Linux and FreeBSD supported
+#error Only Linux, FreeBSD and Haiku are supported
 #endif
 
 /*
diff --git a/src/gpart.c b/src/gpart.c
index 3b44a75..71aef4a 100644
--- a/src/gpart.c
+++ b/src/gpart.c
@@ -175,6 +175,10 @@ ssize_t bread(int fd, byte_t *buf, size_t ssize, size_t nsecs)
 			// ret < 0, an error case
 			if (errno == EINTR)
 				continue; // Rogue signal interruption, retry
+#ifdef __HAIKU__
+			if (errno == EINVAL)
+				return read_bytes;	// on Haiku, EOF causes EINVAL
+#endif
 			berrno = errno;
 			break;
 		}
@@ -504,20 +508,28 @@ static void u_to_chs(disk_desc *d, unsigned long u, long *c, long *h, long *s)
 
 static int on_cyl_boundary(disk_desc *d, s64_t sec)
 {
+#ifndef __HAIKU__
 	struct disk_geom *g = &d->d_dg;
 
 	if (g->d_h && g->d_s)
 		return ((sec % (g->d_h * g->d_s)) == 0);
 	return (1);
+#else
+	return (1);
+#endif
 }
 
 static int on_head_boundary(disk_desc *d, s64_t sec)
 {
+#ifndef __HAIKU__
 	struct disk_geom *g = &d->d_dg;
 
 	if (g->d_s)
 		return ((sec % g->d_s) == 0);
 	return (1);
+#else
+	return (1);
+#endif
 }
 
 static void print_partition(disk_desc *d, dos_part_entry *p, int inset, s64_t offset)
@@ -936,8 +948,13 @@ static void do_guess_loop(disk_desc *d)
 	d->d_nsb = 0;
 	bincr = incr * d->d_ssize;
 
+#ifdef __HAIKU__
+	start = skipsec ? skipsec : incr;
+#else
 	start = skipsec ? skipsec : d->d_dg.d_s;
+#endif
 	d->d_nsb = start - incr;
+
 	start *= d->d_ssize;
 	if (l64seek(d->d_fd, start, SEEK_SET) == -1)
 		pr(FATAL, EM_SEEKFAILURE, d->d_dev);
diff --git a/src/gpart.h b/src/gpart.h
index e6e213c..3b59e35 100644
--- a/src/gpart.h
+++ b/src/gpart.h
@@ -26,6 +26,36 @@
 
 typedef uint8_t byte_t;
 
+#ifdef __HAIKU__
+#	if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#		define htole16(x) (x)
+#		define htobe16(x) __builtin_bswap16(x)
+#		define htole32(x) (x)
+#		define htobe32(x) __builtin_bswap32(x)
+#		define htole64(x) (x)
+#		define htobe64(x) __builtin_bswap64(x)
+#		define le16toh(x) (x)
+#		define be16toh(x) __builtin_bswap16(x)
+#		define le32toh(x) (x)
+#		define be32toh(x) __builtin_bswap32(x)
+#		define le64toh(x) (x)
+#		define be64toh(x) __builtin_bswap64(x)
+#	else
+#		define htole16(x) __builtin_bswap16(x)
+#		define htobe16(x) (x)
+#		define htole32(x) __builtin_bswap32(x)
+#		define htobe32(x) (x)
+#		define htole64(x) __builtin_bswap64(x)
+#		define htobe64(x) (x)
+#		define le16toh(x) __builtin_bswap16(x)
+#		define be16toh(x) (x)
+#		define le32toh(x) __builtin_bswap32(x)
+#		define be32toh(x) (x)
+#		define le64toh(x) __builtin_bswap64(x)
+#		define be64toh(x) (x)
+#	endif
+#endif
+
 #define le16(x) htole16(x)
 #define be16(x) htobe16(x)
 #define le32(x) htole32(x)
diff --git a/src/l64seek.h b/src/l64seek.h
index 5e8dc4b..b2324b6 100644
--- a/src/l64seek.h
+++ b/src/l64seek.h
@@ -27,6 +27,10 @@
  * offsets.
  */
 
+#ifdef __HAIKU__
+typedef off_t loff_t;
+#endif
+
 typedef loff_t off64_t;
 typedef off64_t s64_t;
 
-- 
2.15.1

