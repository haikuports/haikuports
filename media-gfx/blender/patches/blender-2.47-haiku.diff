Index: intern/ghost/SConscript
===================================================================
--- intern/ghost/SConscript	(revision 19951)
+++ intern/ghost/SConscript	(working copy)
@@ -14,14 +14,22 @@
     for f in pf:
         sources.remove('intern' + os.sep + f + 'Win32.cpp')
         sources.remove('intern' + os.sep + f + 'Carbon.cpp')
+        sources.remove('intern' + os.sep + f + 'Haiku.cpp')
 elif window_system in ('win32-vc', 'win32-mingw', 'cygwin', 'linuxcross'):
     for f in pf:
         sources.remove('intern' + os.sep + f + 'X11.cpp')
         sources.remove('intern' + os.sep + f + 'Carbon.cpp')
+        sources.remove('intern' + os.sep + f + 'Haiku.cpp')
 elif window_system == 'darwin':
     for f in pf:
         sources.remove('intern' + os.sep + f + 'Win32.cpp')
         sources.remove('intern' + os.sep + f + 'X11.cpp')
+        sources.remove('intern' + os.sep + f + 'Haiku.cpp')
+elif window_system == 'haiku1':
+    for f in pf:
+        sources.remove('intern' + os.sep + f + 'Win32.cpp')
+        sources.remove('intern' + os.sep + f + 'X11.cpp')
+        sources.remove('intern' + os.sep + f + 'Carbon.cpp')
 else:
     print "Unknown window system specified."
     Exit()
Index: intern/ghost/intern/GHOST_ISystem.cpp
===================================================================
--- intern/ghost/intern/GHOST_ISystem.cpp	(revision 19951)
+++ intern/ghost/intern/GHOST_ISystem.cpp	(working copy)
@@ -42,12 +42,12 @@
 
 #ifdef WIN32
 #	include "GHOST_SystemWin32.h"
+#elif __APPLE__
+#	include "GHOST_SystemCarbon.h"
+#elif __HAIKU__
+#	include "GHOST_SystemHaiku.h"
 #else
-#	ifdef __APPLE__
-#		include "GHOST_SystemCarbon.h"
-#	else
-#		include "GHOST_SystemX11.h"
-#	endif
+#	include "GHOST_SystemX11.h"
 #endif
 
 
@@ -60,13 +60,13 @@
 	if (!m_system) {
 #ifdef WIN32
 		m_system = new GHOST_SystemWin32 ();
+#elif __APPLE__
+        m_system = new GHOST_SystemCarbon ();
+#elif __HAIKU__
+		m_system = new GHOST_SystemHaiku ();
 #else
-#	ifdef __APPLE__
-        m_system = new GHOST_SystemCarbon ();
-#	else 
 		m_system = new GHOST_SystemX11 ();
-#	endif
-#endif 
+#endif
 		success = m_system != 0 ? GHOST_kSuccess : GHOST_kFailure;
 	}
 	else {
Index: intern/ghost/intern/GHOST_SystemHaiku.cpp
===================================================================
--- intern/ghost/intern/GHOST_SystemHaiku.cpp	(revision 0)
+++ intern/ghost/intern/GHOST_SystemHaiku.cpp	(revision 0)
@@ -0,0 +1,114 @@
+#include "GHOST_Debug.h"
+#include "GHOST_SystemHaiku.h"
+#include "GHOST_WindowHaiku.h"
+#include "GHOST_WindowManager.h"
+
+#include <stdio.h>
+
+GHOST_SystemHaiku::GHOST_SystemHaiku()
+	: fDisplayManager(NULL),
+	fApplication(NULL)
+{
+}
+
+GHOST_TSuccess
+GHOST_SystemHaiku::init()
+{
+	GHOST_PRINT("GHOST_SystemHaiku::init()\n");
+	
+	if (GHOST_kSuccess != GHOST_System::init()) {
+		printf("GHOST_SystemHaiku::init() : GHOST_System::init() failed!\n");;
+		return GHOST_kFailure;
+	}
+
+	fApplication = new BApplication("application/x-vnd.GHOST-BApplication");
+	fDisplayManager = new GHOST_DisplayManagerHaiku();	
+	
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_SystemHaiku::exit()
+{
+	GHOST_PRINT("GHOST_SystemHaiku::exit()\n");
+	fApplication->Quit();
+	return GHOST_System::exit();
+}
+
+GHOST_TUns8
+GHOST_SystemHaiku::getNumDisplays() const
+{
+	GHOST_TUns8 numDisplays;
+	fDisplayManager->getNumDisplays(numDisplays);
+	return numDisplays;
+}
+
+void
+GHOST_SystemHaiku::getMainDisplayDimensions(GHOST_TUns32& width, GHOST_TUns32& height) const
+{
+	//GHOST_PRINT("GHOST_SystemHaiku::getMainDisplayDimensions()\n");
+	GHOST_DisplaySetting setting;
+	fDisplayManager->getDisplaySetting((GHOST_TUns8)0, (GHOST_TInt32)0, setting);
+	width = setting.xPixels;
+	height = setting.yPixels;
+}
+
+GHOST_IWindow*
+GHOST_SystemHaiku::createWindow(
+		const STR_String& title,
+		GHOST_TInt32 left, GHOST_TInt32 top, GHOST_TUns32 width, GHOST_TUns32 height,
+		GHOST_TWindowState state, GHOST_TDrawingContextType type,
+		const bool stereoVisual)
+{
+	GHOST_WindowHaiku* window = new GHOST_WindowHaiku(
+		this, title, left, top, width, height, state, type, stereoVisual);
+
+	m_windowManager->addWindow(window);
+
+	return window;
+}
+
+bool
+GHOST_SystemHaiku::processEvents(bool waitForEvent)
+{
+	// TODO
+	//GHOST_PRINT("TODO GHOST_SystemHaiku::processEvents()");
+	return true;
+}
+
+GHOST_TSuccess
+GHOST_SystemHaiku::getCursorPosition(GHOST_TInt32& x, GHOST_TInt32& y) const
+{
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_SystemHaiku::setCursorPosition(GHOST_TInt32 x, GHOST_TInt32 y) const
+{
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_SystemHaiku::getModifierKeys(GHOST_ModifierKeys& keys) const
+{
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_SystemHaiku::getButtons(GHOST_Buttons& buttons) const
+{
+	return GHOST_kFailure;
+}
+
+GHOST_TUns8*
+GHOST_SystemHaiku::getClipboard(int flag) const
+{
+	// TODO
+	return NULL;
+}
+
+void
+GHOST_SystemHaiku::putClipboard(GHOST_TInt8 *buffer, int flag) const
+{
+	// TODO
+}
Index: intern/ghost/intern/GHOST_NDOFManager.cpp
===================================================================
--- intern/ghost/intern/GHOST_NDOFManager.cpp	(revision 19951)
+++ intern/ghost/intern/GHOST_NDOFManager.cpp	(working copy)
@@ -28,7 +28,7 @@
 // the variable is outside the class because it must be accessed from plugin
 static volatile GHOST_TEventNDOFData currentNdofValues = {0,0,0,0,0,0,0,0,0,0,0};
 
-#if !defined(_WIN32) && !defined(__APPLE__)
+#if !defined(_WIN32) && !defined(__APPLE__) && !defined(__HAIKU__)
 #include "GHOST_SystemX11.h"
 #endif
 
@@ -76,7 +76,7 @@
 #if 0
        	printf("%i client \n", Pid);
 #endif
-		#if defined(_WIN32) || defined(__APPLE__)
+		#if defined(_WIN32) || defined(__APPLE__) || defined(__HAIKU__)
 			m_DeviceHandle = ndofDeviceOpen((void *)&currentNdofValues);    
 		#else
 			GHOST_SystemX11 *sys;
Index: intern/ghost/intern/GHOST_DisplayManagerHaiku.cpp
===================================================================
--- intern/ghost/intern/GHOST_DisplayManagerHaiku.cpp	(revision 0)
+++ intern/ghost/intern/GHOST_DisplayManagerHaiku.cpp	(revision 0)
@@ -0,0 +1,104 @@
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "GHOST_Debug.h"
+#include "GHOST_DisplayManagerHaiku.h"
+
+#include <Screen.h>
+
+GHOST_DisplayManagerHaiku::GHOST_DisplayManagerHaiku(void) {
+}
+
+GHOST_DisplayManagerHaiku::~GHOST_DisplayManagerHaiku(void) {
+}
+
+GHOST_TSuccess
+GHOST_DisplayManagerHaiku::initialize(void) {
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_DisplayManagerHaiku::getNumDisplays(GHOST_TUns8& numDisplays) const {
+	/* For now, we only support one screen. */
+	numDisplays = 1;
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_DisplayManagerHaiku::getNumDisplaySettings(GHOST_TUns8 display, GHOST_TInt32& numSettings) const {
+	GHOST_ASSERT(display < 1, "GHOST_DisplayManagerHaiku::getNumDisplaySettings() : Single display support only!\n");
+	numSettings = GHOST_TInt32( 1 );
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_DisplayManagerHaiku::getDisplaySetting(GHOST_TUns8 display, GHOST_TInt32 index, GHOST_DisplaySetting& setting) const {
+	GHOST_ASSERT(display < 1, "GHOST_DisplayManagerHaiku::getDisplaySetting() : Single display support only!\n");
+	GHOST_ASSERT(index < 1, "GHOST_DisplayManagerHaiku::getDisplaySetting() : Single display setting support only!\n");
+
+	BScreen screen;
+	if (!screen.IsValid())
+		return GHOST_kFailure;
+	
+	color_space cspace;	
+	cspace = screen.ColorSpace();
+	
+	switch (cspace)
+	{
+		case B_CMAP8 :
+		{
+			setting.bpp = 8;
+			break;
+		}
+		case B_RGB15 :
+		case B_RGBA15 :
+		{
+			setting.bpp = 15;
+			break;
+		}
+		case B_RGB16 :
+		{
+			setting.bpp = 16;
+			break;
+		}
+		case B_RGB32 :
+		case B_RGBA32 :
+		{
+			setting.bpp = 32;
+			break;
+		}
+		default :
+		{
+			setting.bpp = 16;
+		}
+	}
+	
+	display_mode mode;
+	screen.GetMode(&mode);
+	
+	float total_size = mode.timing.h_total * mode.timing.v_total;
+	float refresh_rate = floor((((float)mode.timing.pixel_clock * 1000.0) / ((float)total_size)));
+	
+	setting.xPixels = mode.timing.h_display;
+	setting.yPixels = mode.timing.v_display;
+	setting.frequency = (GHOST_TUns32)refresh_rate;
+
+#ifdef GHOST_DEBUG
+	printf("GHOST_DisplayManagerHaiku::getDisplaySetting() : %ldx%ldx%d refresh_rate:%luHz\n",
+		setting.xPixels, setting.yPixels, setting.bpp, setting.frequency);
+#endif
+
+	return GHOST_kSuccess;		
+}
+
+GHOST_TSuccess
+GHOST_DisplayManagerHaiku::getCurrentDisplaySetting(GHOST_TUns8 display, GHOST_DisplaySetting& setting) const {
+	return getDisplaySetting(display, (GHOST_TInt32)0, setting);
+}
+
+GHOST_TSuccess
+GHOST_DisplayManagerHaiku::setCurrentDisplaySetting(GHOST_TUns8 display, const GHOST_DisplaySetting& setting) {
+	GHOST_PRINT("TODO GHOST_DisplayManagerHaiku::setCurrentDisplaySetting() : TODO\n");
+	return GHOST_kFailure;
+}
Index: intern/ghost/intern/GHOST_WindowHaiku.h
===================================================================
--- intern/ghost/intern/GHOST_WindowHaiku.h	(revision 0)
+++ intern/ghost/intern/GHOST_WindowHaiku.h	(revision 0)
@@ -0,0 +1,216 @@
+#ifndef _GHOST_WINDOW_HAIKU_H_
+#define _GHOST_WINDOW_HAIKU_H_
+
+#include "GHOST_System.h"
+#include "GHOST_Window.h"
+
+#include <GLView.h>
+
+class GHOSTBWindow;
+
+class GHOST_WindowHaiku : public GHOST_Window
+{
+public:
+	/**
+	 * Constructor.
+	 * Creates a new window and opens it.
+	 * To check if the window was created properly, use the getValid() method.
+	 * @param title		The text shown in the title bar of the window.
+	 * @param left		The coordinate of the left edge of the window.
+	 * @param top		The coordinate of the top edge of the window.
+	 * @param width		The width the window.
+	 * @param heigh		The height the window.
+	 * @param state		The state the window is initially opened with.
+	 * @param type		The type of drawing context installed in this window.
+	 * @param stereoVisual	Stereo visual for quad buffered stereo.
+	 */
+	GHOST_WindowHaiku(
+		GHOST_System* system,
+		const STR_String& title, 
+		GHOST_TInt32 left,
+		GHOST_TInt32 top,
+		GHOST_TUns32 width,
+		GHOST_TUns32 height,
+		GHOST_TWindowState state,
+		GHOST_TDrawingContextType type = GHOST_kDrawingContextTypeNone,
+		const bool stereoVisual = false);
+
+	/**
+	 * Returns indication as to whether the window is valid.
+	 * @return The validity of the window.
+	 */
+	virtual	bool getValid() const;
+
+	/**
+	 * Sets the title displayed in the title bar.
+	 * @param title	The title to display in the title bar.
+	 */
+	virtual void setTitle(const STR_String& title);
+
+	/**
+	 * Returns the title displayed in the title bar.
+	 * @param title	The title displayed in the title bar.
+	 */
+	virtual void getTitle(STR_String& title) const;
+
+	/**
+	 * Returns the window rectangle dimensions.
+	 * These are screen coordinates.
+	 * @param bounds The bounding rectangle of the window.
+	 */
+	virtual	void getWindowBounds(GHOST_Rect& bounds) const;
+	
+	/**
+	 * Returns the client rectangle dimensions.
+	 * The left and top members of the rectangle are always zero.
+	 * @param bounds The bounding rectangle of the client area of the window.
+	 */
+	virtual	void getClientBounds(GHOST_Rect& bounds) const;
+
+	/**
+	 * Resizes client rectangle width.
+	 * @param width The new width of the client area of the window.
+	 */
+	virtual	GHOST_TSuccess setClientWidth(GHOST_TUns32 width);
+
+	/**
+	 * Resizes client rectangle height.
+	 * @param height The new height of the client area of the window.
+	 */
+	virtual	GHOST_TSuccess setClientHeight(GHOST_TUns32 height);
+
+	/**
+	 * Resizes client rectangle.
+	 * @param width		The new width of the client area of the window.
+	 * @param height	The new height of the client area of the window.
+	 */
+	virtual	GHOST_TSuccess setClientSize(GHOST_TUns32 width, GHOST_TUns32 height);
+
+	/**
+	 * Converts a point in screen coordinates to client rectangle coordinates
+	 * @param inX	The x-coordinate on the screen.
+	 * @param inY	The y-coordinate on the screen.
+	 * @param outX	The x-coordinate in the client rectangle.
+	 * @param outY	The y-coordinate in the client rectangle.
+	 */
+	virtual	void screenToClient(GHOST_TInt32 inX, GHOST_TInt32 inY, GHOST_TInt32& outX, GHOST_TInt32& outY) const;
+
+	/**
+	 * Converts a point in screen coordinates to client rectangle coordinates
+	 * @param inX	The x-coordinate in the client rectangle.
+	 * @param inY	The y-coordinate in the client rectangle.
+	 * @param outX	The x-coordinate on the screen.
+	 * @param outY	The y-coordinate on the screen.
+	 */
+	virtual	void clientToScreen(GHOST_TInt32 inX, GHOST_TInt32 inY, GHOST_TInt32& outX, GHOST_TInt32& outY) const;
+
+	/**
+	 * Returns the state of the window (normal, minimized, maximized).
+	 * @return The state of the window.
+	 */
+	virtual GHOST_TWindowState getState() const;
+
+	/**
+	 * Sets the state of the window (normal, minimized, maximized).
+	 * @param state The state of the window.
+	 * @return Indication of success.
+	 */
+	virtual GHOST_TSuccess setState(GHOST_TWindowState state);
+
+	/**
+	 * Sets the order of the window (bottom, top).
+	 * @param order The order of the window.
+	 * @return Indication of success.
+	 */
+	virtual GHOST_TSuccess setOrder(GHOST_TWindowOrder order);
+
+	/**
+	 * Swaps front and back buffers of a window.
+	 * @return	A boolean success indicator.
+	 */
+	virtual GHOST_TSuccess swapBuffers();
+
+	/**
+	 * Activates the drawing context of this window.
+	 * @return	A boolean success indicator.
+	 */
+	virtual GHOST_TSuccess activateDrawingContext();
+
+	/**
+	 * Invalidates the contents of this window.
+	 * @return Indication of success.
+	 */
+	virtual GHOST_TSuccess invalidate();
+
+	/**
+	 * Returns the tablet data (pressure etc).
+	 * @return The tablet data (pressure etc).
+	 */
+	virtual const GHOST_TabletData* GetTabletData();
+
+	/**
+	 * Tries to install a rendering context in this window.
+	 * @param type	The type of rendering context installed.
+	 * @return Indication as to whether installation has succeeded.
+	 */
+	virtual GHOST_TSuccess installDrawingContext(GHOST_TDrawingContextType type);
+
+	/**
+	 * Removes the current drawing context.
+	 * @return Indication as to whether removal has succeeded.
+	 */
+	virtual GHOST_TSuccess removeDrawingContext();
+
+	/**
+	 * Sets the cursor visibility on the window using
+	 * native window system calls.
+	 */
+	virtual GHOST_TSuccess setWindowCursorVisibility(bool visible);
+	
+	/**
+	 * Sets the cursor shape on the window using
+	 * native window system calls.
+	 */
+	virtual GHOST_TSuccess setWindowCursorShape(GHOST_TStandardCursor shape);
+
+	/**
+	 * Sets the cursor shape on the window using
+	 * native window system calls.
+	 */
+	virtual GHOST_TSuccess setWindowCustomCursorShape(GHOST_TUns8 bitmap[16][2], GHOST_TUns8 mask[16][2],
+							 int hotX, int hotY);
+	
+	virtual GHOST_TSuccess setWindowCustomCursorShape(GHOST_TUns8 *bitmap, GHOST_TUns8 *mask, 
+						int szx, int szy, int hotX, int hotY, int fg, int bg);
+						
+private:
+	GHOSTBWindow* fWindow;
+};
+
+#include <Window.h>
+
+class GHOSTBWindow : public BWindow
+{
+public:
+	GHOSTBWindow(GHOST_System* system, GHOST_Window* window,
+		BRect frame, const char* title,
+		window_look look, window_feel feel, uint32 flags,
+		uint32 workspace = B_CURRENT_WORKSPACE);
+
+	virtual void DispatchMessage(BMessage* msg, BHandler* target);
+
+	void InstantiateContext();
+
+	BGLView* View() { return fView; };
+
+private:
+	GHOST_System* fGSystem;
+
+	GHOST_Window* fGWindow;
+
+	BGLView* fView;
+	
+	int32 fLastMouseButton;
+};
+
+#endif // _GHOST_WINDOW_HAIKU_H_
Index: intern/ghost/intern/GHOST_SystemHaiku.h
===================================================================
--- intern/ghost/intern/GHOST_SystemHaiku.h	(revision 0)
+++ intern/ghost/intern/GHOST_SystemHaiku.h	(revision 0)
@@ -0,0 +1,139 @@
+#ifndef _GHOST_SYSTEM_HAIKU_H_
+#define _GHOST_SYSTEM_HAIKU_H_
+
+#include "GHOST_System.h"
+#include "../GHOST_Types.h"
+#include "GHOST_DisplayManagerHaiku.h"
+
+#include <Application.h>
+
+/**
+ * Haiku GHOST_System implementation
+ * @author	Michael Weirauch
+ * @date	2008-10-04
+ * @see		GHOST_System
+ */
+class GHOST_SystemHaiku : public GHOST_System
+{
+public:
+	GHOST_SystemHaiku();
+
+	/**
+	 * Initialize the system.
+	 * @return Indication of success.
+	 */
+	virtual GHOST_TSuccess init();
+
+	/**
+	 * Shut the system down.
+	 * @return Indication of success.
+	 */
+	virtual GHOST_TSuccess exit();
+
+	/***************************************************************************************
+	 ** Display/window management functionality
+	 ***************************************************************************************/
+
+	/**
+	 * Returns the number of displays on this system.
+	 * @return The number of displays.
+	 */
+	virtual	GHOST_TUns8 getNumDisplays() const;
+	
+		/**
+	 * Returns the dimensions of the main display on this system.
+	 * @return The dimension of the main display.
+	 */
+	virtual void getMainDisplayDimensions(GHOST_TUns32& width, GHOST_TUns32& height) const;
+	
+	/**
+	 * Create a new window.
+	 * The new window is added to the list of windows managed. 
+	 * Never explicitly delete the window, use disposeWindow() instead.
+	 * @param	title	The name of the window (displayed in the title bar of the window if the OS supports it).
+	 * @param	left		The coordinate of the left edge of the window.
+	 * @param	top		The coordinate of the top edge of the window.
+	 * @param	width		The width the window.
+	 * @param	height		The height the window.
+	 * @param	state		The state of the window when opened.
+	 * @param	type		The type of drawing context installed in this window.
+	 * @param	stereoVisual	Create a stereo visual for quad buffered stereo.
+	 * @return	The new window (or 0 if creation failed).
+	 */
+	virtual GHOST_IWindow* createWindow(
+		const STR_String& title,
+		GHOST_TInt32 left, GHOST_TInt32 top, GHOST_TUns32 width, GHOST_TUns32 height,
+		GHOST_TWindowState state, GHOST_TDrawingContextType type,
+		const bool stereoVisual);
+
+	/***************************************************************************************
+	 ** Event management functionality
+	 ***************************************************************************************/
+
+	/**
+	 * Retrieves events from the system and stores them in the queue.
+	 * @param waitForEvent Flag to wait for an event (or return immediately).
+	 * @return Indication of the presence of events.
+	 */
+	virtual bool processEvents(bool waitForEvent);
+
+	/***************************************************************************************
+	 ** Cursor management functionality
+	 ***************************************************************************************/
+
+	/**
+	 * Returns the current location of the cursor (location in screen coordinates)
+	 * @param x			The x-coordinate of the cursor.
+	 * @param y			The y-coordinate of the cursor.
+	 * @return			Indication of success.
+	 */
+	virtual GHOST_TSuccess getCursorPosition(GHOST_TInt32& x, GHOST_TInt32& y) const;
+
+	/**
+	 * Updates the location of the cursor (location in screen coordinates).
+	 * Not all operating systems allow the cursor to be moved (without the input device being moved).
+	 * @param x			The x-coordinate of the cursor.
+	 * @param y			The y-coordinate of the cursor.
+	 * @return			Indication of success.
+	 */
+	virtual GHOST_TSuccess setCursorPosition(GHOST_TInt32 x, GHOST_TInt32 y) const;
+	
+	/***************************************************************************************
+	 ** Other (internal) functionality.
+	 ***************************************************************************************/
+
+	/**
+	 * Returns the state of all modifier keys.
+	 * @param keys	The state of all modifier keys (true == pressed).
+	 * @return		Indication of success.
+	 */
+	virtual GHOST_TSuccess getModifierKeys(GHOST_ModifierKeys& keys) const;
+
+	/**
+	 * Returns the state of the mouse buttons (ouside the message queue).
+	 * @param buttons	The state of the buttons.
+	 * @return			Indication of success.
+	 */
+	virtual GHOST_TSuccess getButtons(GHOST_Buttons& buttons) const;
+	
+	/**
+	 * Returns the selection buffer
+	 * @param flag		Only used on X11
+	 * @return 		Returns the clipboard data
+	 */
+	 virtual GHOST_TUns8* getClipboard(int flag) const;
+
+	/**
+	 * Put data to the Clipboard
+	 * @param buffer	The buffer to copy to the clipboard
+	 * @param flag	The clipboard to copy too only used on X11
+	 */
+	virtual void putClipboard(GHOST_TInt8 *buffer, int flag) const;
+
+private:
+	GHOST_DisplayManagerHaiku* fDisplayManager;
+
+	BApplication* fApplication;
+};
+
+#endif /* _GHOST_SYSTEM_HAIKU_H_ */
Index: intern/ghost/intern/GHOST_DisplayManagerHaiku.h
===================================================================
--- intern/ghost/intern/GHOST_DisplayManagerHaiku.h	(revision 0)
+++ intern/ghost/intern/GHOST_DisplayManagerHaiku.h	(revision 0)
@@ -0,0 +1,75 @@
+#ifndef _GHOST_DISPLAY_MANAGER_HAIKU_H_
+#define _GHOST_DISPLAY_MANAGER_HAIKU_H_
+
+#include "GHOST_DisplayManager.h"
+
+class GHOST_SystemHaiku;
+
+/**
+ * Haiku GHOST_DisplayManager implementation
+ * @author	Michael Weirauch
+ * @date	2008-10-04
+ * @see		GHOST_DisplayManager
+ */
+class GHOST_DisplayManagerHaiku : public GHOST_DisplayManager {
+public:
+	/**
+	 * Constructor.
+	 */
+	GHOST_DisplayManagerHaiku(void);
+	
+	/**
+	 * Destructor.
+	 */
+	~GHOST_DisplayManagerHaiku(void);
+
+	/**
+	 * Initializes the list with devices and settings.
+	 * @return Indication of success.
+	 */
+	GHOST_TSuccess initialize(void);
+
+	/**
+	 * Returns the number of display devices on this system.
+	 * @param numDisplays The number of displays on this system.
+	 * @return Indication of success.
+	 */
+	GHOST_TSuccess getNumDisplays(GHOST_TUns8& numDisplays) const;
+
+	/**
+	 * Returns the number of display settings for this display device.
+	 * @param display The index of the display to query with 0 <= display < getNumDisplays().
+	 * @param setting The number of settings of the display device with this index.
+	 * @return Indication of success.
+	 */
+	GHOST_TSuccess getNumDisplaySettings(GHOST_TUns8 display, GHOST_TInt32& numSettings) const;
+
+	/**
+	 * Returns the current setting for this display device. 
+	 * @param display The index of the display to query with 0 <= display < getNumDisplays().
+	 * @param index	  The setting index to be returned.
+	 * @param setting The setting of the display device with this index.
+	 * @return Indication of success.
+	 */
+	GHOST_TSuccess getDisplaySetting(GHOST_TUns8 display, GHOST_TInt32 index, GHOST_DisplaySetting& setting) const;
+
+	/**
+	 * Returns the current setting for this display device. 
+	 * @param display The index of the display to query with 0 <= display < getNumDisplays().
+	 * @param setting The current setting of the display device with this index.
+	 * @return Indication of success.
+	 */
+	GHOST_TSuccess getCurrentDisplaySetting(GHOST_TUns8 display, GHOST_DisplaySetting& setting) const;
+
+	/**
+	 * Changes the current setting for this display device.
+	 * The setting given to this method is matched againts the available diplay settings.
+	 * The best match is activated (@see findMatch()).
+	 * @param display The index of the display to query with 0 <= display < getNumDisplays().
+	 * @param setting The setting of the display device to be matched and activated.
+	 * @return Indication of success.
+	 */
+	GHOST_TSuccess setCurrentDisplaySetting(GHOST_TUns8 display, const GHOST_DisplaySetting& setting);
+};
+
+#endif /* _GHOST_DISPLAY_MANAGER_HAIKU_H_ */
Index: intern/ghost/intern/GHOST_WindowHaiku.cpp
===================================================================
--- intern/ghost/intern/GHOST_WindowHaiku.cpp	(revision 0)
+++ intern/ghost/intern/GHOST_WindowHaiku.cpp	(revision 0)
@@ -0,0 +1,555 @@
+#include "GHOST_Debug.h"
+#include "GHOST_Event.h"
+#include "GHOST_EventButton.h"
+#include "GHOST_EventCursor.h"
+#include "GHOST_EventWheel.h"
+#include "GHOST_Window.h"
+#include "GHOST_WindowHaiku.h"
+
+#include <Application.h>
+
+GHOST_WindowHaiku::GHOST_WindowHaiku(
+		GHOST_System* system,
+		const STR_String& title, 
+		GHOST_TInt32 left,
+		GHOST_TInt32 top,
+		GHOST_TUns32 width,
+		GHOST_TUns32 height,
+		GHOST_TWindowState state,
+		GHOST_TDrawingContextType type,
+		const bool stereoVisual)
+	: GHOST_Window(title,left,top,width,height,state,type,stereoVisual),
+	fWindow(NULL)
+{
+#ifdef GHOST_DEBUG
+	printf("GHOST_WindowHaiku::GHOST_WindowHaiku(%s)\n", (const char*)title);
+#endif
+	BRect frame(left, top, left + width, top + height);
+	fWindow = new GHOSTBWindow(
+		system,
+		this,
+		frame,
+		title,
+		B_TITLED_WINDOW_LOOK,
+		B_NORMAL_WINDOW_FEEL, 0);
+	// TODO respect state input param!
+	fWindow->Show();
+}
+
+bool
+GHOST_WindowHaiku::getValid() const
+{
+	GHOST_PRINT("GHOST_WindowHaiku::getValid()\n");
+	return NULL != fWindow;
+}
+
+void
+GHOST_WindowHaiku::setTitle(const STR_String& title)
+{
+	fWindow->SetTitle(title);
+}
+
+void
+GHOST_WindowHaiku::getTitle(STR_String& title) const
+{
+	const char* wTitle = fWindow->Title();
+	if (!wTitle)
+		title = wTitle;
+}
+
+void
+GHOST_WindowHaiku::getWindowBounds(GHOST_Rect& bounds) const
+{
+	BRect windowBounds = fWindow->Frame();
+	bounds.set(
+		windowBounds.left,
+		windowBounds.top,
+		windowBounds.right,
+		windowBounds.bottom);
+}
+
+void
+GHOST_WindowHaiku::getClientBounds(GHOST_Rect& bounds) const
+{
+	BRect windowBounds = fWindow->Bounds();
+	bounds.set(
+		0,
+		0,
+		windowBounds.right,
+		windowBounds.bottom);
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setClientWidth(GHOST_TUns32 width)
+{
+	BRect bounds = fWindow->Bounds();
+	fWindow->ResizeTo(width, bounds.bottom);
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setClientHeight(GHOST_TUns32 height)
+{
+	BRect bounds = fWindow->Bounds();
+	fWindow->ResizeTo(bounds.right, height);
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setClientSize(GHOST_TUns32 width, GHOST_TUns32 height)
+{
+	fWindow->ResizeTo(width, height);
+	return GHOST_kSuccess;
+}
+
+void
+GHOST_WindowHaiku::screenToClient(GHOST_TInt32 inX, GHOST_TInt32 inY, GHOST_TInt32& outX, GHOST_TInt32& outY) const
+{
+	//GHOST_PRINT("GHOST_WindowHaiku::screenToClient()\n");
+	
+	/*
+	 * The mouse coordinates fired in GHOSTBWindow are
+	 * already in client coordinates.
+	 */
+	outX = inX;
+	outY = inY;
+}
+
+void
+GHOST_WindowHaiku::clientToScreen(GHOST_TInt32 inX, GHOST_TInt32 inY, GHOST_TInt32& outX, GHOST_TInt32& outY) const
+{
+	// TODO
+	GHOST_PRINT("GHOST_WindowHaiku::clientToScreen() : TODO\n");
+}
+
+GHOST_TWindowState
+GHOST_WindowHaiku::getState() const
+{
+	// TODO other states
+	if (fWindow->IsMinimized())
+		return GHOST_kWindowStateMinimized;
+	else
+		return GHOST_kWindowStateNormal;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setState(GHOST_TWindowState state)
+{
+	// TODO
+	GHOST_PRINT("GHOST_WindowHaiku::setState() : TODO\n");
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setOrder(GHOST_TWindowOrder order)
+{
+	// TODO
+	GHOST_PRINT("GHOST_WindowHaiku::setOrder() : TODO\n");
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::swapBuffers()
+{
+	if (m_drawingContextType == GHOST_kDrawingContextTypeOpenGL) {
+		GHOST_PRINT("GHOST_WindowHaiku::swapBuffers(Success)\n");
+		fWindow->View()->SwapBuffers();
+		return GHOST_kSuccess;
+	}
+	GHOST_PRINT("GHOST_WindowHaiku::swapBuffers(No openGL context)\n");
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::activateDrawingContext()
+{
+	// TODO investigate
+	if (m_drawingContextType == GHOST_kDrawingContextTypeOpenGL) {
+		GHOST_PRINT("GHOST_WindowHaiku::activateDrawingContext(OK) : INVESTIGATE\n");
+		// seems both things are not needed. just SwapBuffers() seems ok.
+		//fWindow->View()->LockGL();
+		// FIXME aquire/makecurrent the context here?
+		//fWindow->InstantiateContext();
+		return GHOST_kSuccess;
+	}
+	GHOST_PRINT("GHOST_WindowHaiku::activateDrawingContext(Failure) : INVESTIGATE\n");
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::invalidate()
+{
+	// TODO investigate
+	GHOST_PRINT("GHOST_WindowHaiku::invalidate()\n");
+	fWindow->UpdateIfNeeded();
+	return GHOST_kSuccess;
+}
+
+const GHOST_TabletData*
+GHOST_WindowHaiku::GetTabletData()
+{
+	// TODO
+	return NULL;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::installDrawingContext(GHOST_TDrawingContextType type)
+{
+	// TODO
+	GHOST_PRINT("GHOST_WindowHaiku::installDrawingContext() : TODO\n");
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::removeDrawingContext()
+{
+	// TODO investigate
+	GHOST_PRINT("GHOST_WindowHaiku::removeDrawingContext() : TODO\n");
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setWindowCursorVisibility(bool visible)
+{
+	GHOST_PRINT("GHOST_WindowHaiku::setWindowCursorVisibility()\n");
+	if (visible)
+		be_app->ShowCursor();
+	else
+		be_app->HideCursor();
+	
+	return GHOST_kSuccess;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setWindowCursorShape(GHOST_TStandardCursor shape)
+{
+	// TODO
+	GHOST_PRINT("GHOST_WindowHaiku::setWindowCursorShape() : TODO\n");
+	return GHOST_kFailure;
+}
+
+GHOST_TSuccess
+GHOST_WindowHaiku::setWindowCustomCursorShape(GHOST_TUns8 bitmap[16][2], GHOST_TUns8 mask[16][2],
+							 int hotX, int hotY)
+{
+	// TODO
+	GHOST_PRINT("GHOST_WindowHaiku::setWindowCustomCursorShape() : TODO\n");
+	return GHOST_kFailure;
+}
+							 
+GHOST_TSuccess
+GHOST_WindowHaiku::setWindowCustomCursorShape(GHOST_TUns8 *bitmap, GHOST_TUns8 *mask, 
+						int szx, int szy, int hotX, int hotY, int fg, int bg)
+{
+	// TODO
+	GHOST_PRINT("GHOST_WindowHaiku::setWindowCustomCursorShape() : TODO\n");
+	return GHOST_kFailure;
+}
+
+/*
+ * GHOSTBWindow
+ */
+
+GHOSTBWindow::GHOSTBWindow(GHOST_System* system, GHOST_Window* window,
+	BRect frame, const char* title,
+	window_look look, window_feel feel, uint32 flags,
+	uint32 workspace)
+	: BWindow(frame, title, look, feel, flags, workspace),
+	fGSystem(system),
+	fGWindow(window),
+	fView(NULL),
+	fLastMouseButton(0)
+{
+	InstantiateContext();
+}
+
+void
+GHOSTBWindow::InstantiateContext() {
+	fView = new BGLView(
+		Bounds(),
+		"GHOST.BGLView",
+		B_FOLLOW_ALL,
+		0,
+		BGL_RGB | BGL_DOUBLE | BGL_DEPTH | BGL_ALPHA | BGL_STENCIL
+		);
+	AddChild(fView);
+}
+
+void
+GHOSTBWindow::DispatchMessage(
+	BMessage* msg, BHandler* target)
+{
+	GHOST_Event* event = NULL;
+	bool dispatch = true;
+	switch (msg->what)
+	{
+//		case B_KEY_DOWN :
+//		case B_KEY_UP :
+//		{			
+//			int8 bbyte = 0;
+//			int32 bkey = 0;
+//			
+//			msg->FindInt8( "byte", &bbyte );
+//			msg->FindInt32( "key", &bkey );
+//			
+//			GHOST_TKey gkey = GHOST_kKeyUnknown;
+//			
+//			if( ( bbyte >= 'A' ) && ( bbyte <= 'Z' ) )
+//			{
+//				gkey = GHOST_TKey( bbyte - 'A' + int( GHOST_kKeyA ) );
+//			}
+//			else if( ( bbyte >= 'a' ) && ( bbyte <= 'z' ) )
+//			{
+//				gkey = GHOST_TKey( bbyte - 'a' + int( GHOST_kKeyA ) );
+//			}
+//			else if( ( bkey >= B_F1_KEY ) && ( bkey <= B_F12_KEY ) )
+//			{
+//				gkey = GHOST_TKey( bkey - B_F1_KEY + int( GHOST_kKeyF1 ) );
+//			}
+//			else
+//			{				
+//				/* multibyte character recognition could go in here */
+//				
+//				if( gkey == GHOST_kKeyUnknown )
+//				{
+//					switch( bkey )
+//					{
+//						/* Numpad keys */
+//						case 0x64 :		gkey = GHOST_kKeyNumpad0;			break;
+//						case 0x58 :		gkey = GHOST_kKeyNumpad1;			break;
+//						case 0x59 :		gkey = GHOST_kKeyNumpad2;			break;
+//						case 0x5a :		gkey = GHOST_kKeyNumpad3;			break;
+//						case 0x48 :		gkey = GHOST_kKeyNumpad4;			break;
+//						case 0x49 :		gkey = GHOST_kKeyNumpad5;			break;
+//						case 0x4a :		gkey = GHOST_kKeyNumpad6;			break;
+//						case 0x37 :		gkey = GHOST_kKeyNumpad7;			break;
+//						case 0x38 :		gkey = GHOST_kKeyNumpad8;			break;
+//						case 0x39 :		gkey = GHOST_kKeyNumpad9;			break;
+//						case 0x65 :		gkey = GHOST_kKeyNumpadPeriod;		break;
+//						case 0x5b :		gkey = GHOST_kKeyNumpadEnter;		break;
+//						case 0x3a :		gkey = GHOST_kKeyNumpadPlus;		break;
+//						case 0x25 :		gkey = GHOST_kKeyNumpadMinus;		break;
+//						case 0x24 :		gkey = GHOST_kKeyNumpadAsterisk;	break;
+//						case 0x23 :		gkey = GHOST_kKeyNumpadSlash;		break;
+//
+// 						/* Other keys */
+//						case 0x1e :		gkey = GHOST_kKeyBackSpace;			break;
+//						case 0x26 :		gkey = GHOST_kKeyTab;				break;
+//						case 0x47 :		gkey = GHOST_kKeyEnter;				break;
+//						case 0x1  :		gkey = GHOST_kKeyEsc;				break;
+//						case 0x5e :		gkey = GHOST_kKeySpace;				break;
+//						
+// 						/* Arrow keys */
+// 						case 0x61 : 	gkey = GHOST_kKeyLeftArrow;			break;
+// 						case 0x63 :		gkey = GHOST_kKeyRightArrow;		break;
+// 						case 0x57 :		gkey = GHOST_kKeyUpArrow;			break;
+// 						case 0x62 :		gkey = GHOST_kKeyDownArrow;			break;
+// 						
+// 						/* Navigation keys */
+// 						case 0x1f :		gkey = GHOST_kKeyInsert;			break;
+// 						case 0x32 :		gkey = GHOST_kKeyDelete;			break;
+// 						case 0x20 :		gkey = GHOST_kKeyHome;				break;
+// 						case 0x35 : 	gkey = GHOST_kKeyEnd;				break;
+// 						case 0x21 :		gkey = GHOST_kKeyUpPage;			break;
+// 						case 0x36 :		gkey = GHOST_kKeyDownPage;			break;
+//					}
+//				}
+//				
+//				if( gkey == GHOST_kKeyUnknown )
+//				{
+//					switch( bbyte )
+//					{
+//						/* normal Number keys */
+//						case 0x30 :		gkey = GHOST_kKey0;					break;
+//						case 0x31 :		gkey = GHOST_kKey1;					break;
+//						case 0x32 :		gkey = GHOST_kKey2;					break;
+//						case 0x33 :		gkey = GHOST_kKey3;					break;
+//						case 0x34 :		gkey = GHOST_kKey4;					break;
+//						case 0x35 :		gkey = GHOST_kKey5;					break;
+//						case 0x36 :		gkey = GHOST_kKey6;					break;
+//						case 0x37 :		gkey = GHOST_kKey7;					break;
+//						case 0x38 :		gkey = GHOST_kKey8;					break;
+//						case 0x39 :		gkey = GHOST_kKey9;					break;
+//						
+//						/* additional keys */
+//						case 0x22 : 	gkey = GHOST_kKeyQuote;				break;
+// 						case 0x2c :		gkey = GHOST_kKeyComma;				break;
+// 						case 0x2d :		gkey = GHOST_kKeyMinus;				break;
+// 						case 0x2e :		gkey = GHOST_kKeyPeriod;			break;
+//						case 0x2f :		gkey = GHOST_kKeySlash;				break;
+//						case 0x3b :		gkey = GHOST_kKeySemicolon;			break;
+//						case 0x3d : 	gkey = GHOST_kKeyEqual;				break;
+//						case 0x5b :		gkey = GHOST_kKeyLeftBracket;		break;
+//						case 0x5c :		gkey = GHOST_kKeyBackslash;			break;
+//						case 0x5d :		gkey = GHOST_kKeyRightBracket;		break;
+//						case 0x60 :		gkey = GHOST_kKeyAccentGrave;		break;
+//					}
+//				}
+//
+//				/* Unhandled GHOST keys: */
+//				// GHOST_kKeyLineFeed ?
+//				// GHOST_kKeyClear ?
+//			}
+//			
+//			GHOST_TEventType type;
+//			if( msg->what == B_KEY_DOWN )
+//				type = GHOST_kEventKeyDown;
+//			else
+//				type = GHOST_kEventKeyUp;
+//			
+//			fWindowZETA->getSystemZETA()->pushEvent(
+//				new GHOST_EventKey(
+//					fWindowZETA->getSystemZETA()->getMilliSeconds(),
+//					type,
+//					fWindowZETA,
+//					gkey,
+//					bbyte ) );
+//			
+//			/* needs to be forwarded */
+//			BWindow::DispatchMessage( msg, target );
+//			
+//			break;
+//		}
+		case B_MOUSE_DOWN :
+		case B_MOUSE_UP :
+		{
+			GHOST_TButtonMask bmask = GHOST_kButtonMaskLeft;
+			int32 buttons;
+			msg->FindInt32("buttons", &buttons);
+			
+			/*
+			 * As the B_MOUSE_UP message doesnt tell which button was released,
+			 * we store the last button further below in fLastMouseButton.
+			 * When we receive the B_MOUSE_UP, we switch(fLastMouseButton)
+			 * instead against buttons.
+			 */
+			
+			switch(msg->what == B_MOUSE_DOWN ? buttons : fLastMouseButton)
+			{
+				case B_PRIMARY_MOUSE_BUTTON :
+				{
+					bmask = GHOST_kButtonMaskLeft;
+					break;
+				}
+				case B_SECONDARY_MOUSE_BUTTON :
+				{
+					bmask = GHOST_kButtonMaskRight;
+					break;
+				}
+				case B_TERTIARY_MOUSE_BUTTON :
+				{
+					bmask = GHOST_kButtonMaskMiddle;
+					break;
+				}
+			}
+			
+			GHOST_TEventType type;			
+			if (msg->what == B_MOUSE_DOWN)
+			{
+				fLastMouseButton = buttons;
+				type = GHOST_kEventButtonDown;
+			}
+			else
+			{
+				type = GHOST_kEventButtonUp;
+			}
+			
+			// FIXME use message time????????
+			event = new GHOST_EventButton(
+					fGSystem->getMilliSeconds(),
+					type,
+					fGWindow,
+					bmask);
+			break;
+		}
+		case B_MOUSE_MOVED :
+		{
+			BPoint point;
+			msg->FindPoint("where", &point);
+			
+			// FIXME use message time????????
+			event = new GHOST_EventCursor(
+					fGSystem->getMilliSeconds(),
+					GHOST_kEventCursorMove,
+					fGWindow,
+					point.x,
+					point.y);
+			break;
+		}
+		case B_MOUSE_WHEEL_CHANGED :
+		{
+			float value;
+			msg->FindFloat("be:wheel_delta_y", &value);
+				
+			//value *= 3;	/* dunno if to unprecise */
+			
+			// FIXME use message time????????
+			event = new GHOST_EventWheel(
+					fGSystem->getMilliSeconds(),
+					fGWindow,
+					floor(value));
+			break;
+		}
+		case B_WINDOW_ACTIVATED :
+		{
+			bool active;
+			msg->FindBool("active", &active);
+			
+			GHOST_TEventType type;
+			if (active)
+				type = GHOST_kEventWindowActivate;
+			else
+				type = GHOST_kEventWindowDeactivate;
+			
+			// FIXME use message time????????
+			event = new GHOST_Event(
+					fGSystem->getMilliSeconds(),
+					type,
+					fGWindow);
+			dispatch = false; // FIXME WHY?
+			break;
+		}
+		case B_WINDOW_RESIZED :
+		{
+			// FIXME use message time????????
+			event = new GHOST_Event(
+					fGSystem->getMilliSeconds(),
+					GHOST_kEventWindowSize,
+					fGWindow);
+			break;
+		}
+		case B_QUIT_REQUESTED :
+		{
+			// FIXME use message time????????
+			event = new GHOST_Event(
+					fGSystem->getMilliSeconds(),
+					GHOST_kEventWindowClose,
+					fGWindow);
+			/* Don't dispatch. */
+			dispatch = false;
+			break;
+		}
+		case _UPDATE_ :
+		case _UPDATE_IF_NEEDED_ :
+		{
+			// FIXME use message time????????
+			event = new GHOST_Event(
+					fGSystem->getMilliSeconds(),
+					GHOST_kEventWindowUpdate,
+					fGWindow);
+			break;
+		}
+		default :
+		{
+			BWindow::DispatchMessage(msg, target);
+		}
+	}
+	
+	if (dispatch) {
+		BWindow::DispatchMessage(msg, target);
+	}
+	
+	if (event) {
+		fGSystem->pushEvent(event);
+	}
+}
Index: source/blender/imbuf/intern/imbuf.h
===================================================================
--- source/blender/imbuf/intern/imbuf.h	(revision 19951)
+++ source/blender/imbuf/intern/imbuf.h	(working copy)
@@ -51,7 +51,7 @@
 #include <sys/mman.h>
 #endif
 
-#if !defined(WIN32) && !defined(__BeOS)
+#if !defined(WIN32) && !defined(__BeOS) && !defined(__HAIKU__)
 #define O_BINARY 0
 #endif
 
Index: source/blender/blenlib/intern/storage.c
===================================================================
--- source/blender/blenlib/intern/storage.c	(revision 19951)
+++ source/blender/blenlib/intern/storage.c	(working copy)
@@ -47,7 +47,7 @@
 #include <time.h>
 #include <sys/stat.h>
 
-#if defined (__sun__) || defined (__sun)
+#if defined (__sun__) || defined (__sun) || defined(__HAIKU__)
 #include <sys/statvfs.h> /* Other modern unix os's should probably use this also */
 #elif !defined(__FreeBSD__) && !defined(linux) && (defined(__sgi) || defined(__sparc) || defined(__sparc__))
 #include <sys/statfs.h>
@@ -77,7 +77,7 @@
 
 
 #include <fcntl.h>
-#if !defined(__BeOS) && !defined(WIN32)
+#if !defined(__BeOS) && !defined(WIN32) && !defined(__HAIKU__)
 #include <sys/mtio.h>			/* tape comando's */
 #endif
 #include <string.h>			/* strcpy etc.. */
@@ -179,7 +179,7 @@
 	return (double) (freec*bytesps*sectorspc);
 #else
 
-#if defined (__sun__) || defined (__sun)
+#if defined (__sun__) || defined (__sun) || defined(__HAIKU__)
 	struct statvfs disk;
 #else
 	struct statfs disk;
@@ -204,7 +204,7 @@
 	return -1;
 #endif
 
-#if defined (__sun__) || defined (__sun)
+#if defined (__sun__) || defined (__sun) || defined(__HAIKU__)
 	if (statvfs(name, &disk)) return(-1);	
 #elif !defined(__FreeBSD__) && !defined(linux) && (defined (__sgi) || defined(__sparc) || defined(__sparc__))
 	/* WARNING - This may not be supported by geeneric unix os's - Campbell */
Index: config/haiku1-config.py
===================================================================
--- config/haiku1-config.py	(revision 0)
+++ config/haiku1-config.py	(revision 0)
@@ -0,0 +1,191 @@
+import os
+import subprocess
+import sys
+
+HAIKU_DEVELOP_DIR = '/boot/develop'
+HAIKU_DEVELOP_LIB = HAIKU_DEVELOP_DIR + '/lib/x86' # TODO arch
+HAIKU_DEVELOP_INCLUDE = HAIKU_DEVELOP_DIR + '/headers'
+HAIKU_DEVELOP_INCLUDE_OS = HAIKU_DEVELOP_INCLUDE + '/os'
+HAIKU_DEVELOP_INCLUDE_3RDPARTY = HAIKU_DEVELOP_INCLUDE + '/3rdparty'
+HAIKU_COMMON_DIR = '/boot/common'
+HAIKU_COMMON_LIB = HAIKU_COMMON_DIR + '/lib'
+HAIKU_COMMON_INCLUDE = HAIKU_COMMON_DIR + '/include'
+
+WITH_BF_VERSE = 'false'
+BF_VERSE_INCLUDE = "#extern/verse/dist"
+
+BF_PYTHON = HAIKU_COMMON_DIR
+BF_PYTHON_VERSION = '2.5'
+BF_PYTHON_INC = HAIKU_COMMON_INCLUDE + '/python' + BF_PYTHON_VERSION
+BF_PYTHON_BINARY = BF_PYTHON + '/bin/python' + BF_PYTHON_VERSION
+BF_PYTHON_LIB = 'python' + BF_PYTHON_VERSION
+BF_PYTHON_LIBPATH = HAIKU_COMMON_LIB
+pipe = subprocess.Popen(['python' + BF_PYTHON_VERSION + '-config', '--ldflags'], stdout=subprocess.PIPE)
+BF_PYTHON_LINKFLAGS = pipe.communicate()[0]
+pipe.stdout.close()
+
+WITH_BF_OPENAL = 'false' # TODO
+#BF_OPENAL = '/usr'
+#BF_OPENAL_INC = '${BF_OPENAL}/include'
+#BF_OPENAL_LIB = 'openal'
+# some distros have a separate libalut
+# if you get linker complaints, you need to uncomment the line below
+# BF_OPENAL_LIB = 'openal alut'  
+
+WITH_BF_SDL = 'true' # setting is ignored
+BF_SDL = HAIKU_COMMON_DIR
+BF_SDL_INC = HAIKU_COMMON_INCLUDE + '/SDL'
+BF_SDL_LIB = 'SDL'
+
+WITH_BF_FMOD = 'false' # TODO
+##BF_FMOD = LIBDIR + '/fmod'
+
+WITH_BF_OPENEXR = 'false' # TODO
+#BF_OPENEXR = '/usr'
+# when compiling with your own openexr lib you might need to set...
+# BF_OPENEXR_INC = '${BF_OPENEXR}/include/OpenEXR ${BF_OPENEXR}/include'
+
+#BF_OPENEXR_INC = '${BF_OPENEXR}/include/OpenEXR'
+#BF_OPENEXR_LIB = 'Half IlmImf Iex Imath '
+# BF_OPENEXR_LIBPATH = '${BF_OPENEXR}/lib'
+
+WITH_BF_DDS = 'true'
+
+WITH_BF_JPEG = 'true' # setting is ignored
+BF_JPEG = HAIKU_COMMON_DIR
+BF_JPEG_INC = HAIKU_COMMON_INCLUDE
+BF_JPEG_LIB = 'jpeg'
+BF_JPEG_LIBPATH = HAIKU_COMMON_LIB
+
+WITH_BF_PNG = 'true'
+BF_PNG = HAIKU_DEVELOP_DIR
+BF_PNG_INC = HAIKU_DEVELOP_INCLUDE_3RDPARTY
+BF_PNG_LIB = 'png'
+
+WITH_BF_TIFF = 'true' # setting is ignored
+BF_TIFF = HAIKU_COMMON_DIR
+BF_TIFF_INC = HAIKU_COMMON_INCLUDE
+
+WITH_BF_ZLIB = 'true'
+BF_ZLIB = HAIKU_DEVELOP_DIR
+BF_ZLIB_INC = HAIKU_DEVELOP_INCLUDE_3RDPARTY
+BF_ZLIB_LIB = 'z'
+
+WITH_BF_INTERNATIONAL = 'false' # TODO
+
+#BF_GETTEXT = '/usr'
+#BF_GETTEXT_INC = '${BF_GETTEXT}/include'
+#BF_GETTEXT_LIB = 'gettextlib'
+#BF_GETTEXT_LIBPATH = '${BF_GETTEXT}/lib'
+
+WITH_BF_FTGL = 'false' # TODO
+#BF_FTGL = '#extern/bFTGL'
+#BF_FTGL_INC = '${BF_FTGL}/include'
+#BF_FTGL_LIB = 'extern_ftgl'
+
+WITH_BF_GAMEENGINE='false' # TODO
+
+WITH_BF_ODE = 'false'
+##BF_ODE = LIBDIR + '/ode'
+BF_ODE_INC = BF_ODE + '/include'
+BF_ODE_LIB = BF_ODE + '/lib/libode.a'
+
+WITH_BF_BULLET = 'true'
+BF_BULLET = '#extern/bullet2/src'
+BF_BULLET_INC = '${BF_BULLET}'
+BF_BULLET_LIB = 'extern_bullet'
+
+BF_SOLID = '#extern/solid'
+BF_SOLID_INC = '${BF_SOLID}'
+BF_SOLID_LIB = 'extern_solid'
+
+WITH_BF_YAFRAY = 'true'
+
+#WITH_BF_NSPR = 'true'
+#BF_NSPR = $(LIBDIR)/nspr
+#BF_NSPR_INC = -I$(BF_NSPR)/include -I$(BF_NSPR)/include/nspr
+#BF_NSPR_LIB = 
+
+# Uncomment the following line to use Mozilla inplace of netscape
+#CPPFLAGS += -DMOZ_NOT_NET
+# Location of MOZILLA/Netscape header files...
+#BF_MOZILLA = $(LIBDIR)/mozilla
+#BF_MOZILLA_INC = -I$(BF_MOZILLA)/include/mozilla/nspr -I$(BF_MOZILLA)/include/mozilla -I$(BF_MOZILLA)/include/mozilla/xpcom -I$(BF_MOZILLA)/include/mozilla/idl
+#BF_MOZILLA_LIB =
+# Will fall back to look in BF_MOZILLA_INC/nspr and BF_MOZILLA_LIB
+# if this is not set.
+#
+# Be paranoid regarding library creation (do not update archives)
+#BF_PARANOID = 'true'
+
+# enable freetype2 support for text objects
+WITH_BF_FREETYPE = 'false'
+#BF_FREETYPE = '/usr'
+#BF_FREETYPE_INC = '${BF_FREETYPE}/include ${BF_FREETYPE}/include/freetype2'
+#BF_FREETYPE_LIB = 'freetype'
+
+WITH_BF_QUICKTIME = 'false'
+#BF_QUICKTIME = '/usr/local'
+#BF_QUICKTIME_INC = '${BF_QUICKTIME}/include'
+
+WITH_BF_ICONV = 'false' # TODO
+##BF_ICONV = LIBDIR + "/iconv"
+#BF_ICONV_INC = '${BF_ICONV}/include'
+#BF_ICONV_LIB = 'iconv'
+#BF_ICONV_LIBPATH = '${BF_ICONV}/lib'
+
+WITH_BF_BINRELOC = 'false' # TODO?
+
+# enable ffmpeg  support
+WITH_BF_FFMPEG = 'false'  # -DWITH_FFMPEG
+#BF_FFMPEG = '#extern/ffmpeg'
+#BF_FFMPEG_LIB = ''
+# Uncomment the following two lines to use system's ffmpeg
+# BF_FFMPEG = '/usr'
+# BF_FFMPEG_LIB = 'avformat avcodec swscale avutil'
+#BF_FFMPEG_INC = '${BF_FFMPEG}/include'
+#BF_FFMPEG_LIBPATH='${BF_FFMPEG}/lib'
+
+# Mesa Libs should go here if your using them as well....
+WITH_BF_STATICOPENGL = 'false'
+#BF_OPENGL = '/usr'
+BF_OPENGL_INC = '${HAIKU_DEVELOP_INCLUDE_OS}/opengl'
+BF_OPENGL_LIB = 'GL'
+BF_OPENGL_LIBPATH = '${HAIKU_DEVELOP_LIB}'
+#BF_OPENGL_LIB_STATIC = '${BF_OPENGL}/libGL.a ${BF_OPENGL}/libGLU.a ${BF_OPENGL}/libXxf86vm.a ${BF_OPENGL}/libX11.a ${BF_OPENGL}/libXi.a ${BF_OPENGL}/libXext.a ${BF_OPENGL}/libXxf86vm.a'
+
+##
+CC = 'gcc'
+CXX = 'g++'
+
+# TODO CHECK ALL VALUES!
+##CCFLAGS = ['-pipe','-fPIC','-funsigned-char','-fno-strict-aliasing']
+
+##CPPFLAGS = ['-DXP_UNIX']
+##CXXFLAGS = ['-pipe','-fPIC','-funsigned-char','-fno-strict-aliasing']
+REL_CFLAGS = ['-O2']
+REL_CCFLAGS = ['-O2']
+##BF_DEPEND = 'true'
+##
+##AR = ar
+##ARFLAGS = ruv
+##ARFLAGSQUIET = ru
+##
+##C_WARN = '-Wall -Wno-char-subscripts -Wdeclaration-after-statement'
+
+##CC_WARN = '-Wall'
+
+##FIX_STUBS_WARNINGS = -Wno-unused
+
+LLIBS = 'stdc++ network be'
+##LOPTS = --dynamic
+##DYNLDFLAGS = -shared $(LDFLAGS)
+
+#BF_PROFILE_FLAGS = ['-pg','-g']
+#BF_PROFILE = 'false'
+
+BF_DEBUG = 'false'
+BF_DEBUG_FLAGS = '-g'
+
+BF_BUILDDIR = '../build-' + sys.platform
+BF_INSTALLDIR='../install-' + sys.platform
Index: extern/glew/src/glew.c
===================================================================
--- extern/glew/src/glew.c	(revision 19951)
+++ extern/glew/src/glew.c	(working copy)
@@ -32,7 +32,7 @@
 #include <GL/glew.h>
 #if defined(_WIN32)
 #  include <GL/wglew.h>
-#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)
+#elif (!defined(__APPLE__) || defined(GLEW_APPLE_GLX)) && !defined(__HAIKU__)
 #  include <GL/glxew.h>
 #endif
 
@@ -86,7 +86,7 @@
 }
 #endif /* __APPLE__ */
 
-#if defined(__sgi) || defined (__sun)
+#if defined(__sgi) || defined (__sun) || defined(__HAIKU__)
 #include <dlfcn.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -107,7 +107,7 @@
   else
     return dlsym(h, (const char*)name);
 }
-#endif /* __sgi || __sun */
+#endif /* __sgi || __sun || __HAIKU__ */
 
 /*
  * Define glewGetProcAddress.
@@ -118,7 +118,7 @@
 #  if defined(__APPLE__)
 #    define glewGetProcAddress(name) NSGLGetProcAddress(name)
 #  else
-#    if defined(__sgi) || defined(__sun)
+#    if defined(__sgi) || defined(__sun) || defined(__HAIKU__)
 #      define glewGetProcAddress(name) dlGetProcAddress(name)
 #    else /* __linux */
 #      define glewGetProcAddress(name) (*glXGetProcAddressARB)(name)
@@ -6422,7 +6422,7 @@
   return GLEW_OK;
 }
 
-#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)
+#elif (!defined(__APPLE__) || defined(GLEW_APPLE_GLX)) && !defined(__HAIKU__)
 
 PFNGLXGETCURRENTDISPLAYPROC __glewXGetCurrentDisplay = NULL;
 
@@ -7139,7 +7139,7 @@
   return GLEW_OK;
 }
 
-#endif /* !__APPLE__ || GLEW_APPLE_GLX */
+#endif /* (!defined(__APPLE__) || defined(GLEW_APPLE_GLX)) && !defined(__HAIKU__) */
 
 /* ------------------------------------------------------------------------ */
 
@@ -7176,7 +7176,7 @@
 
 #if defined(_WIN32)
 extern GLenum wglewContextInit (void);
-#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX) /* _UNIX */
+#elif (!defined(__APPLE__) || defined(GLEW_APPLE_GLX)) && !defined(__HAIKU__)
 extern GLenum glxewContextInit (void);
 #endif /* _WIN32 */
 
@@ -7186,7 +7186,7 @@
   if ( (r = glewContextInit()) ) return r;
 #if defined(_WIN32)
   return wglewContextInit();
-#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX) /* _UNIX */
+#elif (!defined(__APPLE__) || defined(GLEW_APPLE_GLX)) && !defined(__HAIKU__)
   return glxewContextInit();
 #else
   return r;
@@ -9429,7 +9429,7 @@
   return ret;
 }
 
-#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)
+#elif (!defined(__APPLE__) || defined(GLEW_APPLE_GLX)) && !defined(__HAIKU__)
 
 #if defined(GLEW_MX)
 GLboolean glxewContextIsSupported (GLXEWContext* ctx, const char* name)
