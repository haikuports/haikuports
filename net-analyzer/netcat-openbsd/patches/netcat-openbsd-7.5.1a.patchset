From 9b15294448d4aae4e5de0a855987fd42ef67b9fe Mon Sep 17 00:00:00 2001
From: Christof Meerwald <cmeerw@cmeerw.org>
Date: Mon, 22 Dec 2025 11:48:07 +0000
Subject: [PATCH] conditionally support IPTOS options


diff --git a/netcat-openbsd-19366e25d99290a6f3e76893a7196356ceed4cc2/netcat.c b/netcat-openbsd-19366e25d99290a6f3e76893a7196356ceed4cc2/netcat.c
index 8cc37f6..4df7d7f 100644
--- a/netcat-openbsd-19366e25d99290a6f3e76893a7196356ceed4cc2/netcat.c
+++ b/netcat-openbsd-19366e25d99290a6f3e76893a7196356ceed4cc2/netcat.c
@@ -1721,7 +1721,9 @@ process_tos_opt(char *s, int *val)
 		{ "af41",		IPTOS_DSCP_AF41 },
 		{ "af42",		IPTOS_DSCP_AF42 },
 		{ "af43",		IPTOS_DSCP_AF43 },
+#ifdef IPTOS_PREC_CRITIC_ECP
 		{ "critical",		IPTOS_PREC_CRITIC_ECP },
+#endif
 		{ "cs0",		IPTOS_DSCP_CS0 },
 		{ "cs1",		IPTOS_DSCP_CS1 },
 		{ "cs2",		IPTOS_DSCP_CS2 },
@@ -1731,10 +1733,16 @@ process_tos_opt(char *s, int *val)
 		{ "cs6",		IPTOS_DSCP_CS6 },
 		{ "cs7",		IPTOS_DSCP_CS7 },
 		{ "ef",			IPTOS_DSCP_EF },
+#ifdef IPTOS_PREC_INTERNETCONTROL
 		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
+#endif
+#ifdef IPTOS_LOWCOST
 		{ "lowcost",		IPTOS_LOWCOST },
+#endif
 		{ "lowdelay",		IPTOS_LOWDELAY },
+#ifdef IPTOS_PREC_NETCONTROL
 		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
+#endif
 		{ "reliability",	IPTOS_RELIABILITY },
 		{ "throughput",		IPTOS_THROUGHPUT },
 		{ NULL,			-1 },
-- 
2.51.0

From 42f64ae1365c6356123adff915b5c7c147ea2d34 Mon Sep 17 00:00:00 2001
From: Christof Meerwald <cmeerw@cmeerw.org>
Date: Fri, 2 Jan 2026 13:25:47 +0000
Subject: [PATCH] Work around missing accept4/SOCK_NONBLOCK/SOCK_CLOEXEC

---
 netcat.c | 41 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 40 insertions(+), 1 deletion(-)

diff --git a/netcat.c b/netcat.c
index 4df7d7f..3a50cfa 100644
--- a/netcat.c
+++ b/netcat.c
@@ -596,8 +596,20 @@ main(int argc, char *argv[])
 				int connfd;
 
 				len = sizeof(cliaddr);
+#ifdef SOCK_NONBLOCK
 				connfd = accept4(s, (struct sockaddr *)&cliaddr,
 				    &len, SOCK_NONBLOCK);
+#else
+				connfd = accept(s, (struct sockaddr *)&cliaddr,
+				    &len);
+				if (connfd != -1) {
+					int flags = fcntl(connfd, F_GETFL, 0);
+					if (fcntl(connfd, F_SETFL, flags | O_NONBLOCK) < 0 ) {
+						close(connfd);
+						connfd = -1;
+					}
+				}
+#endif
 				if (connfd == -1) {
 					/* For now, all errnos are fatal */
 					err(1, "accept");
@@ -768,16 +780,31 @@ unix_connect(char *path)
 		return -1;
 
 	if (uflag) {
+#ifdef SOCK_CLOEXEC
 		if ((s = unix_bind(unix_dg_tmp_socket, SOCK_CLOEXEC)) == -1)
+#else
+		if ((s = unix_bind(unix_dg_tmp_socket, 0)) == -1)
+#endif
 			return -1;
 	} else {
-		if ((s = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)) == 
+#ifdef SOCK_CLOEXEC
+		if ((s = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)) ==
+#else
+		if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) ==
+#endif
 		    -1) {
 			errx(1, "create unix socket failed");
 			return -1;
 		}
 	}
 
+#ifndef SOCK_CLOEXEC
+	if (fcntl(s, F_SETFL, fcntl(s, F_GETFL, 0) | O_CLOEXEC) < 0 ) {
+		close(s);
+		return -1;
+	}
+#endif
+
 	if (connect(s, (struct sockaddr *)&s_un, addrlen) == -1) {
 		save_errno = errno;
 		warn("unix connect failed");
@@ -848,9 +875,21 @@ remote_connect(const char *host, const char *port, struct addrinfo hints,
 		    port, gai_strerror(error));
 
 	for (res = res0; res; res = res->ai_next) {
+#ifdef SOCK_NONBLOCK
 		if ((s = socket(res->ai_family, res->ai_socktype |
 		    SOCK_NONBLOCK, res->ai_protocol)) == -1)
 			continue;
+#else
+		int flags;
+		if ((s = socket(res->ai_family, res->ai_socktype,
+		    res->ai_protocol)) == -1)
+			continue;
+		flags = fcntl(s, F_GETFL, 0);
+		if (fcntl(s, F_SETFL, flags | O_NONBLOCK) < 0 ) {
+			close(s);
+			continue;
+		}
+#endif
 
 		/* Bind to a local port or source address if specified. */
 		if (sflag || pflag) {
-- 
2.52.0

