From 72457f676895a9c39147df8660ffbce01bfb694d Mon Sep 17 00:00:00 2001
From: begasus <begasus@gmail.com>
Date: Sun, 21 May 2017 17:08:44 +0200
Subject: fix path for libincludedir


diff --git a/libzip.pc.in b/libzip.pc.in
index d51b0ab..fae05fb 100644
--- a/libzip.pc.in
+++ b/libzip.pc.in
@@ -3,6 +3,7 @@ exec_prefix=${prefix}
 bindir=@bindir@
 libdir=@libdir@
 includedir=@includedir@
+libincludedir=@includedir@
 
 zipcmp=${bindir}/zipcmp
 
-- 
2.50.1


From 4fc5430b01f94363677394c873f0e860fe1c3e50 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Thu, 11 May 2023 09:23:45 +0200
Subject: search fts in libbsd


diff --git a/CMakeLists.txt b/CMakeLists.txt
index b79873b..dda5da0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -145,6 +145,7 @@ if(HAVE_FTS_H)
   check_function_exists(fts_open HAVE_FTS_OPEN)
   if(NOT HAVE_FTS_OPEN)
     check_library_exists(fts fts_open "" HAVE_LIB_FTS)
+    check_library_exists(bsd fts_open "" HAVE_LIB_BSD)
   else(NOT HAVE_FTS_OPEN)
     set(HAVE_LIB_FTS "" CACHE INTERNAL "")
   endif(NOT HAVE_FTS_OPEN)
@@ -155,7 +156,11 @@ endif(HAVE_FTS_H)
 if(HAVE_LIB_FTS)
   set(FTS_LIB fts CACHE INTERNAL "")
 else()
-  set(FTS_LIB "" CACHE INTERNAL "")
+  if(HAVE_LIB_BSD)
+    set(FTS_LIB bsd CACHE INTERNAL "")
+  else()
+    set(FTS_LIB "" CACHE INTERNAL "")
+  endif()
 endif()
 
 check_include_files(stdbool.h HAVE_STDBOOL_H)
-- 
2.50.1


From a4e23756bf9c98a5fa3abab6cfe733d469dcf58e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joachim=20Mairb=C3=B6ck?= <j.mairboeck@gmail.com>
Date: Tue, 26 Aug 2025 18:05:10 +0200
Subject: gcc2 fixes


diff --git a/examples/add-compressed-data.c b/examples/add-compressed-data.c
index 5db37a3..869c199 100644
--- a/examples/add-compressed-data.c
+++ b/examples/add-compressed-data.c
@@ -124,6 +124,7 @@ main(int argc, char *argv[]) {
     zip_source_t *src, *src_comp;
     zip_t *za;
     int err;
+    zip_error_t error;
 
     if (argc != 2) {
         fprintf(stderr, "usage: %s archive\n", argv[0]);
@@ -146,7 +147,6 @@ main(int argc, char *argv[]) {
         exit(1);
     }
 
-    zip_error_t error;
     if ((src_comp = create_layered_compressed_source(src, uncompressed_size, crc, compression_method, &error)) == NULL) {
         fprintf(stderr, "%s: cannot create layered source: %s\n", argv[0], zip_error_strerror(&error));
         zip_source_free(src);
diff --git a/examples/autoclose-archive.c b/examples/autoclose-archive.c
index d236f0a..bb2c008 100644
--- a/examples/autoclose-archive.c
+++ b/examples/autoclose-archive.c
@@ -96,6 +96,7 @@ main(int argc, char *argv[]) {
     zip_source_t *src, *src_autoclose;
     zip_t *z_source, *z_destination;
     int err;
+    zip_error_t error;
 
     if (argc != 4) {
         fprintf(stderr, "usage: %s destination-archive source-archive source-file\n", argv[0]);
@@ -126,7 +127,6 @@ main(int argc, char *argv[]) {
         exit(1);
     }
 
-    zip_error_t error;
     if ((src_autoclose = create_layered_autoclose(src, z_source, &error)) == NULL) {
         fprintf(stderr, "%s: cannot create layered source: %s\n", argv[0], zip_error_strerror(&error));
         zip_source_free(src);
diff --git a/lib/zip_dirent.c b/lib/zip_dirent.c
index 5ea8d6d..ef5824b 100644
--- a/lib/zip_dirent.c
+++ b/lib/zip_dirent.c
@@ -1232,6 +1232,8 @@ bool
 _zip_dirent_apply_attributes(zip_dirent_t *de, zip_file_attributes_t *attributes, bool force_zip64) {
     zip_uint16_t length;
     bool has_changed = false;
+    zip_uint16_t version_needed;
+    zip_int16_t version_madeby = 63 | (de->version_madeby & 0xff00);
 
     if (attributes->valid & ZIP_FILE_ATTRIBUTES_GENERAL_PURPOSE_BIT_FLAGS) {
         zip_uint16_t mask = attributes->general_purpose_bit_mask & ZIP_FILE_ATTRIBUTES_GENERAL_PURPOSE_BIT_FLAGS_ALLOWED_MASK;
@@ -1256,7 +1258,6 @@ _zip_dirent_apply_attributes(zip_dirent_t *de, zip_file_attributes_t *attributes
         }
     }
 
-    zip_uint16_t version_needed;
     if (de->comp_method == ZIP_CM_LZMA) {
         version_needed = 63;
     }
@@ -1288,7 +1289,6 @@ _zip_dirent_apply_attributes(zip_dirent_t *de, zip_file_attributes_t *attributes
         has_changed = true;
     }
 
-    zip_int16_t version_madeby = 63 | (de->version_madeby & 0xff00);
     if ((de->changed & ZIP_DIRENT_ATTRIBUTES) == 0 && (attributes->valid & ZIP_FILE_ATTRIBUTES_HOST_SYSTEM)) {
         version_madeby = (version_madeby & 0xff) | (zip_uint16_t)(attributes->host_system << 8);
     }
@@ -1357,4 +1357,4 @@ zip_dirent_get_last_mod_mtime(zip_dirent_t *de) {
     }
 
     return de->last_mod_mtime;
-}
\ No newline at end of file
+}
diff --git a/lib/zip_source_file_stdio_named.c b/lib/zip_source_file_stdio_named.c
index 1a5ca22..449e1da 100644
--- a/lib/zip_source_file_stdio_named.c
+++ b/lib/zip_source_file_stdio_named.c
@@ -293,6 +293,7 @@ static int create_temp_file(zip_source_file_context_t *ctx, bool create_file) {
     zip_os_stat_t st;
     int fd = 0;
     char *start, *end;
+    size_t temp_size = strlen(ctx->fname) + 13;
     
     if (zip_os_stat(ctx->fname, &st) == 0) {
         mode = st.st_mode;
@@ -301,7 +302,6 @@ static int create_temp_file(zip_source_file_context_t *ctx, bool create_file) {
         mode = -1;
     }
     
-    size_t temp_size = strlen(ctx->fname) + 13;
     if ((temp = (char *)malloc(temp_size)) == NULL) {
         zip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);
         return -1;
diff --git a/ossfuzz/zip_write_encrypt_aes256_file_fuzzer.c b/ossfuzz/zip_write_encrypt_aes256_file_fuzzer.c
index 2ad8855..787a6da 100644
--- a/ossfuzz/zip_write_encrypt_aes256_file_fuzzer.c
+++ b/ossfuzz/zip_write_encrypt_aes256_file_fuzzer.c
@@ -25,20 +25,22 @@ LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
     const char *file = "filename";
     int error = 0;
     struct zip *archive;
+    struct zip_source *source;
+    int index;
 
     (void)remove(path);
     if ((archive = zip_open(path, ZIP_CREATE, &error)) == NULL) {
         return -1;
     }
 
-    struct zip_source *source = zip_source_buffer(archive, data, size, 0);
+    source = zip_source_buffer(archive, data, size, 0);
     if (source == NULL) {
         fprintf(stderr, "failed to create source buffer. %s\n", zip_strerror(archive));
         zip_discard(archive);
         return -1;
     }
 
-    int index = (int)zip_file_add(archive, file, source, ZIP_FL_OVERWRITE);
+    index = (int)zip_file_add(archive, file, source, ZIP_FL_OVERWRITE);
     if (index < 0) {
         fprintf(stderr, "failed to add file to archive: %s\n", zip_strerror(archive));
         zip_source_free(source);
diff --git a/ossfuzz/zip_write_encrypt_pkware_file_fuzzer.c b/ossfuzz/zip_write_encrypt_pkware_file_fuzzer.c
index ed1704a..212a194 100644
--- a/ossfuzz/zip_write_encrypt_pkware_file_fuzzer.c
+++ b/ossfuzz/zip_write_encrypt_pkware_file_fuzzer.c
@@ -26,20 +26,22 @@ LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
     const char *file = "filename";
     int error = 0;
     struct zip *archive;
+    struct zip_source *source;
+    int index;
 
     (void)remove(path);
     if ((archive = zip_open(path, ZIP_CREATE, &error)) == NULL) {
         return -1;
     }
 
-    struct zip_source *source = zip_source_buffer(archive, data, size, 0);
+    source = zip_source_buffer(archive, data, size, 0);
     if (source == NULL) {
         fprintf(stderr, "failed to create source buffer. %s\n", zip_strerror(archive));
         zip_discard(archive);
         return -1;
     }
 
-    int index = (int)zip_file_add(archive, file, source, ZIP_FL_OVERWRITE);
+    index = (int)zip_file_add(archive, file, source, ZIP_FL_OVERWRITE);
     if (index < 0) {
         fprintf(stderr, "failed to add file to archive: %s\n", zip_strerror(archive));
         zip_discard(archive);
diff --git a/src/zipcmp.c b/src/zipcmp.c
index 536e9b2..6ee5d5f 100644
--- a/src/zipcmp.c
+++ b/src/zipcmp.c
@@ -411,6 +411,7 @@ list_directory(const char *name, struct archive *a) {
     size_t prefix_length;
     size_t name_length;
     char* normalized_name;
+    char *const names[2] = {NULL, NULL};
 
     name_length = strlen(name);
     if (name_length == 0) {
@@ -433,7 +434,7 @@ list_directory(const char *name, struct archive *a) {
 
     prefix_length = name_length + 1;
 
-    char *const names[2] = {normalized_name, NULL};
+    names[0] = normalized_name;
 
     if ((fts = fts_open(names, FTS_NOCHDIR | FTS_LOGICAL, NULL)) == NULL) {
         fprintf(stderr, "%s: can't open directory '%s': %s\n", progname, name, strerror(errno));
@@ -480,12 +481,13 @@ list_directory(const char *name, struct archive *a) {
 
             if (ent->fts_info == FTS_D) {
                 char *dir_name;
+                size_t dir_name_size;
 
                 if (ent->fts_path[prefix_length - 1] == '\0') {
                     break;
                 }
 
-                size_t dir_name_size = strlen(ent->fts_path + prefix_length) + 2;
+                dir_name_size = strlen(ent->fts_path + prefix_length) + 2;
                 dir_name = malloc(dir_name_size);
                 if (dir_name == NULL) {
                     fprintf(stderr, "%s: malloc failure\n", progname);
diff --git a/src/ziptool.c b/src/ziptool.c
index 6666ecb..53f5fc1 100644
--- a/src/ziptool.c
+++ b/src/ziptool.c
@@ -532,12 +532,13 @@ set_archive_comment(char *argv[]) {
 static int
 set_archive_flag(char *argv[]) {
     int flag = parse_archive_flag(argv[0]);
+    int value;
     if (flag < 0) {
         fprintf(stderr, "invalid archive flag '%s'\n", argv[0]);
         return -1;
     }
 
-    int value = strcasecmp(argv[1], "1") == 0 || strcasecmp(argv[1], "true") == 0 || strcasecmp(argv[1], "yes") == 0;
+    value = strcasecmp(argv[1], "1") == 0 || strcasecmp(argv[1], "true") == 0 || strcasecmp(argv[1], "yes") == 0;
 
     if (zip_set_archive_flag(za, flag, value) < 0) {
         fprintf(stderr, "can't set archive flag '%s' to %d: %s\n", argv[0], value, zip_strerror(za));
@@ -1138,6 +1139,8 @@ static const char* encode_filename(const char* name) {
 }
 
 static const char* decode_filename(const char* name) {
+    unsigned char *t = (unsigned char*)filename_buffer;
+    const char *s = name;
     if (!hex_encoded_filenames) {
         return name;
     }
@@ -1149,8 +1152,6 @@ static const char* decode_filename(const char* name) {
     // TODO: check that strlen(name) % 2 == 0
     // TODO: check with strspn that s is all hex digits
 
-    unsigned char *t = (unsigned char*)filename_buffer;
-    const char *s = name;
     while (*s != '\0') {
         *(t++) = (HEX2BIN(s[0]) << 4) | HEX2BIN(s[1]);
         s += 2;
-- 
2.50.1


From 32213250c5f3fb7d7fd5d7db0edace6488243845 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joachim=20Mairb=C3=B6ck?= <j.mairboeck@gmail.com>
Date: Tue, 26 Aug 2025 18:06:03 +0200
Subject: disable rpath


diff --git a/CMakeLists.txt b/CMakeLists.txt
index dda5da0..4a74bb3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -295,7 +295,7 @@ if(WIN32)
 endif(WIN32)
 
 # rpath handling: use rpath in installed binaries
-if(NOT CMAKE_SYSTEM_NAME MATCHES Linux)
+if(NOT (CMAKE_SYSTEM_NAME MATCHES Linux OR HAIKU))
   set(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
 endif()
-- 
2.50.1

