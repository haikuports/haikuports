diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/adipe.h cp-gn084/adipe.h
--- clean-gn084/adipe.h	1970-01-01 00:00:00.000000000 +0000
+++ cp-gn084/adipe.h	2009-03-13 18:10:19.000000000 +0000
@@ -0,0 +1,15 @@
+#ifndef __ADIPE_H_
+#define __ADIPE_H_
+
+
+#define QQ_LVL 6
+
+#define QQ(x)	do { 							\
+			if ( (x) <= QQ_LVL )				\
+				fprintf(stderr,"QQ %s \t%d \t%s\n",	\
+					__FILE__, __LINE__,		\
+					 __PRETTY_FUNCTION__);      	\
+		} while(0)
+
+#endif
+
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/backend/render_handler_agg.cpp cp-gn084/backend/render_handler_agg.cpp
--- clean-gn084/backend/render_handler_agg.cpp	2009-03-13 18:18:09.000000000 +0000
+++ cp-gn084/backend/render_handler_agg.cpp	2009-03-13 18:10:21.000000000 +0000
@@ -1658,13 +1658,19 @@
     const std::vector<agg::path_storage>& agg_paths,
     const std::vector<line_style> &line_styles, const cxform& cx, 
     const matrix& linestyle_matrix, scanline_type& sl) {
+    //QQQ
+    return ;
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
     
     assert(m_pixf.get());
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
     
     if (m_drawing_mask)    // Flash ignores lines in mask /definitions/
       return;    
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
     
     if ( _clipbounds.empty() ) return;
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
 
     // TODO: While walking the paths for filling them, remember when a path
     // has a line style associated, so that we avoid walking the paths again
@@ -1677,6 +1683,7 @@
       / 2.0f
       * get_stroke_scale();
     
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
     
     // AGG stuff
     typedef agg::rasterizer_scanline_aa<> ras_type; 
@@ -1684,62 +1691,81 @@
     renderer_base rbase(*m_pixf);
     agg::renderer_scanline_aa_solid<
       agg::renderer_base<PixelFormat> > ren_sl(rbase); // solid fills
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
       
     
     for (unsigned int cno=0; cno<_clipbounds_selected.size(); ++cno) {
     
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
       const geometry::Range2d<int>* bounds = _clipbounds_selected[cno];
           
       apply_clip_box<ras_type> (ras, *bounds);
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
       
       int current_subshape=0;
 
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
       for (size_t pno=0, pcount=paths.size(); pno<pcount; ++pno) {
 
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         const path& this_path_gnash = paths[pno];
 
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         agg::path_storage &this_path_agg = 
           const_cast<agg::path_storage&>(agg_paths[pno]);
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         
         if (this_path_gnash.m_new_shape)
           ++current_subshape;
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
           
         if ((subshape_id>=0) && (current_subshape!=subshape_id)) {
           // Skip this path as it is not part of the requested sub-shape.
           continue;
         }
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         
         if (this_path_gnash.m_line==0) {
           // Skip this path as it contains no line style
           continue;
         } 
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         
         agg::conv_curve< agg::path_storage > curve(this_path_agg); // to render curves
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         agg::conv_stroke< agg::conv_curve < agg::path_storage > > 
           stroke(curve);  // to get an outline
         
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         const line_style& lstyle = line_styles[this_path_gnash.m_line-1];
           
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         int thickness = lstyle.getThickness();
         if (!thickness) stroke.width(1); // hairline
         else if ( (!lstyle.scaleThicknessVertically()) && (!lstyle.scaleThicknessHorizontally()) )
         {
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
           stroke.width(TWIPS_TO_PIXELS(thickness));
         }
         else
         {
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
           if ( (!lstyle.scaleThicknessVertically()) || (!lstyle.scaleThicknessHorizontally()) )
           {
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
              LOG_ONCE( log_unimpl(_("Unidirectionally scaled strokes in AGG renderer (we'll scale by the scalable one)")) );
           }
           stroke.width(std::max(1.0f, thickness*stroke_scale));
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         }
         
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         // TODO: support endCapStyle
         
         // TODO: When lstyle.noClose==0 and the start and end point matches,
         // then render a real join instead of the caps.
 
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         switch (lstyle.startCapStyle()) {
           case CAP_NONE   : stroke.line_cap(agg::butt_cap); break; 
           case CAP_SQUARE : stroke.line_cap(agg::square_cap); break;          
@@ -1752,15 +1778,21 @@
           default : case JOIN_ROUND : stroke.line_join(agg::round_join);
         }
         
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         stroke.miter_limit(lstyle.miterLimitFactor());
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
                 
         ras.reset();
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         ras.add_path(stroke);
         
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         rgba color = cx.transform(lstyle.get_color());
         ren_sl.color(agg::rgba8_pre(color.m_r, color.m_g, color.m_b, color.m_a));       
                 
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         agg::render_scanlines(ras, sl, ren_sl);
+    fprintf(stderr, "%s %s %d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
         
       }
     
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/gui/dump.cpp cp-gn084/gui/dump.cpp
--- clean-gn084/gui/dump.cpp	2009-03-13 18:18:06.000000000 +0000
+++ cp-gn084/gui/dump.cpp	2009-03-13 18:10:31.000000000 +0000
@@ -28,6 +28,9 @@
 
 #include "log.h"
 
+#include <fcntl.h>
+#include <sys/mman.h>
+
 #include "gui.h"
 #include "rc.h"
 #include "sound_handler.h"
@@ -89,7 +92,8 @@
     _timeout(0),
     _framecount(0),
     _bpp(32),
-    _pixelformat("BGRA32")
+    _pixelformat("BGRA32"),
+    _ble_data(NULL)
 {
     if (loop) {
         std::cerr << "# WARNING:  Gnash was told to loop the movie" << std::endl;
@@ -102,6 +106,13 @@
 DumpGui::~DumpGui()
 {
     std::cout << "FRAMECOUNT=" << _framecount << "" << std::endl;
+	if (_ble_data != NULL)
+	{
+		if (munmap(_ble_data, _ble_data_size) == -1)
+			perror("munmap");
+		if (close(_ble_fd) == -1)
+			perror("close");
+	}
 }
 
 bool
@@ -200,7 +211,9 @@
         }
 
         // advance movie now
-        Gui::advance_movie(this);
+	if (_sh1->fEnableRendering)
+        	Gui::advance_movie(this);
+
         writeFrame();
 
         // check if we've reached a timeout
@@ -245,9 +258,13 @@
 void
 DumpGui::writeFrame()
 {
-    assert(_fileStream);
-    if (_fileStream.is_open()) {
-        _fileStream.write(reinterpret_cast<char*>(_offscreenbuf.get()), _offscreenbuf_size);
+    //assert(_fileStream);
+    //if (_fileStream.is_open()) {
+    if (1) {
+	//memmove(_ble_data, _offscreenbuf.get(), _offscreenbuf_size);
+	//if (msync(_ble_data, _offscreenbuf_size, MS_SYNC) == -1)
+		//perror("msync");
+      //  _fileStream.write(reinterpret_cast<char*>(_offscreenbuf.get()), _offscreenbuf_size);
         _framecount++;
     }
     else {
@@ -263,13 +280,40 @@
     // This should never be empty.
     assert (!_fileOutput.empty());
 
-    _fileStream.open(_fileOutput.c_str());
+    //_fileStream.open(_fileOutput.c_str());
     
-    if (!_fileStream) {
-        log_error(_("Unable to write file '%s'."), _fileOutput);
-        std::cerr << "# FATAL:  Unable to write file '" << _fileOutput << "'" << std::endl;
-        exit(1);
-    }
+    //if (!_fileStream) {
+        //log_error(_("Unable to write file '%s'."), _fileOutput);
+        //std::cerr << "# FATAL:  Unable to write file '" << _fileOutput << "'" << std::endl;
+        //exit(1);
+    //}
+
+    //_ble_fd = open(_fileOutput.c_str(), O_RDWR);
+    char *endptr;
+    _ble_fd = strtol(_fileOutput.c_str(), &endptr, 10);
+    if (*endptr)
+    {
+	std::cerr << "nie-liczba przy -D" << std::endl;
+	exit(1);
+    }
+    if (_ble_fd == -1)
+    {
+	std::cerr << "vid fd error" << std::endl;
+	exit(1);
+    }
+    std::cerr << "vid fd is " << _ble_fd << std::endl;
+    int pagesize = getpagesize();
+    _ble_data_size = ((_offscreenbuf_size + pagesize - 1) / pagesize)
+			* pagesize;
+    _ble_data_size = 0x1000 * 3000; //XXX
+    _ble_data = (char*)mmap((caddr_t)0, _ble_data_size, PROT_READ|PROT_WRITE,
+		MAP_SHARED, _ble_fd, 0);
+    _sh1 = reinterpret_cast<struct Sh1_t*>(_ble_data);
+     if (_ble_data == (void*) -1)
+     {
+	perror("mmap");
+	exit(1);
+     }
     
     // Yes, this should go to cout.  The user needs to know this
     // information in order to process the file.  Print out in a
@@ -281,6 +325,7 @@
     
 }
 
+
 void
 DumpGui::setRenderHandlerSize(int width, int height)
 {
@@ -288,7 +333,8 @@
     assert(height > 0);
     assert(_agg_renderer != NULL);
     
-    if (_offscreenbuf.get() && (width == _width) && (height == _height)) {
+    //if (_offscreenbuf.get() && (width == _width) && (height == _height)) {
+    if (_offscreenbuf && (width == _width) && (height == _height)) {
         return;
     }
 	   
@@ -304,7 +350,9 @@
     if (newBufferSize != _offscreenbuf_size) {
 
         try {
-              _offscreenbuf.reset(new unsigned char[newBufferSize]);
+              //_offscreenbuf.reset(new unsigned char[newBufferSize]);
+	      //_offscreenbuf=((unsigned char*)_ble_data);
+	      _offscreenbuf= reinterpret_cast<unsigned char*>(&_sh1->fRest);
               log_debug("DUMP-AGG: %i bytes offscreen buffer allocated", newBufferSize);
         }
         catch (std::bad_alloc &e)
@@ -322,7 +370,8 @@
     }
 
     static_cast<render_handler_agg_base *> (_agg_renderer)->init_buffer
-        (_offscreenbuf.get(),
+        //(_offscreenbuf.get(),
+        (_offscreenbuf,
          _offscreenbuf_size,
          _width,
          _height,
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/gui/dump.h cp-gn084/gui/dump.h
--- clean-gn084/gui/dump.h	2009-03-13 18:18:06.000000000 +0000
+++ cp-gn084/gui/dump.h	2009-03-13 18:10:31.000000000 +0000
@@ -32,6 +32,15 @@
 
 typedef bool (*callback_t)(void*, int, void *data);
 
+
+/* Copy in plugin.cpp */
+struct Sh1_t
+{
+	int fEnableRendering;
+	char fRest[1];
+};
+
+
 class DSOEXPORT DumpGui : public Gui
 {
  public:
@@ -70,7 +79,8 @@
     // is destroyed on reset and when it goes out of scope (including on
     // stack unwinding after an exception), so there is no need to delete
     // it.
-    boost::scoped_array<unsigned char> _offscreenbuf;
+    //boost::scoped_array<unsigned char> _offscreenbuf;
+    unsigned char * _offscreenbuf;
 
     int _offscreenbuf_size;             /* size of window (bytes) */
 
@@ -82,6 +92,11 @@
 
     std::string _fileOutput;                 /* path to output file */
     std::ofstream _fileStream;        /* stream for output file */
+    FILE *_file;
+    char *_ble_data;
+    struct Sh1_t * _sh1;
+    unsigned _ble_data_size;
+    int _ble_fd;
     void init_dumpfile();               /* convenience method to create dump file */
 
 
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/gui/gnash.cpp cp-gn084/gui/gnash.cpp
--- clean-gn084/gui/gnash.cpp	2009-03-13 18:18:06.000000000 +0000
+++ cp-gn084/gui/gnash.cpp	2009-03-13 18:10:34.000000000 +0000
@@ -28,6 +28,8 @@
 #include "arg_parser.h"
 #include "utility.h" // for clamp
 
+extern "C" void debugger(const char*);
+
 #ifdef HAVE_FFMPEG_AVCODEC_H
 extern "C" {
 # include "ffmpeg/avcodec.h"
@@ -427,9 +429,26 @@
 
 }
 
+void sighandler(int sno)
+{
+	pid_t pid;
+	pid = getpid();
+	fprintf(stderr, "signal %d, pid %d\n", sno, pid);
+
+	debugger("signal");
+}
+
 int
 gnash_main(int argc, char *argv[])
 {
+    //debugger("elo");
+    struct sigaction sa;
+    sa.sa_flags=0;
+    sa.sa_handler=sighandler;
+    sigemptyset(&sa.sa_mask);
+    if (sigaction(SIGSEGV, &sa, 0) != 0)
+    { fprintf(stderr, "error\n"); abort(); }
+
     gnash::Player player;
 
     // Enable native language support, i.e. internationalization
@@ -461,3 +480,4 @@
 
     return player.run(argc, argv, infiles.front().c_str(), url.c_str());
 }
+
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libbase/shm.cpp cp-gn084/libbase/shm.cpp
--- clean-gn084/libbase/shm.cpp	2009-03-13 18:18:04.000000000 +0000
+++ cp-gn084/libbase/shm.cpp	2009-03-13 18:10:46.000000000 +0000
@@ -136,7 +136,10 @@
 
     return true;
 #else
-#error "You need SYSV Shared memory support to use this option"
+//#error "You need SYSV Shared memory support to use this option"
+/* QQQ */
+std::cerr << "QQQ " << __func__ << " " << __LINE__ << std::endl;
+raise(SIGABRT);
 #endif	 // end of USE_SYSV_SHM
 }	
 
@@ -223,10 +226,13 @@
 #  ifdef __riscos__
     if (0)
 #  else
-	_shmhandle = CreateFileMapping ((HANDLE) 0xFFFFFFFF, NULL,
-					PAGE_READWRITE, 0,
-					_size, filespec);
-    if (_shmhandle <= 0)
+	//_shmhandle = CreateFileMapping ((HANDLE) 0xFFFFFFFF, NULL,
+	//				PAGE_READWRITE, 0,
+	//				_size, filespec);
+/* QQQ */
+std::cerr << "QQQ " << __func__ << " " << __LINE__ << std::endl;
+raise(SIGABRT);
+    //if (_shmhandle <= 0)
 #  endif
 # endif	 // end of HAVE_SHMGET
 #else
@@ -249,9 +255,12 @@
 #   ifdef __riscos__
         // do nothing, we never get here.
 #   else
-	_shmhandle = CreateFileMapping ((HANDLE) 0xFFFFFFFF, NULL,
-					PAGE_READWRITE, 0,
-					_size, filespec);
+	//_shmhandle = CreateFileMapping ((HANDLE) 0xFFFFFFFF, NULL,
+	//				PAGE_READWRITE, 0,
+	//				_size, filespec);
+	/* QQQ */
+	std::cerr << "QQQ " << __func__ << " " << __LINE__ << std::endl;
+	raise(SIGABRT);
 #   endif
 #  endif
 # else
@@ -327,8 +336,11 @@
             return false;
         }
 #  else
-	_addr = (char *)MapViewOfFile (_shmhandle, FILE_MAP_ALL_ACCESS,
-				       0, 0, _size);
+	//_addr = (char *)MapViewOfFile (_shmhandle, FILE_MAP_ALL_ACCESS,
+	//			       0, 0, _size);
+	/* QQQ */
+	std::cerr << "QQQ " << __func__ << " " << __LINE__ << std::endl;
+	raise(SIGABRT);
 # endif
 #endif
 #endif
@@ -380,9 +392,12 @@
 #  ifdef __riscos__
         _addr = _addr;
 #  else
-	CloseHandle(_shmhandle);	
-	_addr = (char *)MapViewOfFile (_shmhandle, FILE_MAP_ALL_ACCESS,
-			       0, 0, _size);
+	//CloseHandle(_shmhandle);	
+	//_addr = (char *)MapViewOfFile (_shmhandle, FILE_MAP_ALL_ACCESS,
+	//		       0, 0, _size);
+	/* QQQ */
+	std::cerr << "QQQ " << __func__ << " " << __LINE__ << std::endl;
+	raise(SIGABRT);
 #  endif
 # endif // end of HAVE_SHMAT
 	}
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libbase/utf8.h cp-gn084/libbase/utf8.h
--- clean-gn084/libbase/utf8.h	2009-03-13 18:18:04.000000000 +0000
+++ cp-gn084/libbase/utf8.h	2009-03-13 18:10:46.000000000 +0000
@@ -21,8 +21,13 @@
 #ifndef UTF8_H
 #define UTF8_H
 
+
 #include "dsodefs.h" // For DSOEXPORT
 #include <string>
+namespace std
+{
+	typedef std::basic_string<wchar_t> wstring;
+};
 #include <boost/cstdint.hpp> // for C99 int types
 
 /// Utilities to convert between std::string and std::wstring.
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libbase/utility.h cp-gn084/libbase/utility.h
--- clean-gn084/libbase/utility.h	2009-03-13 18:18:03.000000000 +0000
+++ cp-gn084/libbase/utility.h	2009-03-13 18:10:46.000000000 +0000
@@ -61,7 +61,7 @@
 // Using a possible built-in pi constant M_PI, which is not in
 // the C++ standard, has no conceivable advantage, so we will use this
 // one. Make it as accurate as you like.
-static const double PI = 3.14159265358979323846;
+//static const double PI = 3.14159265358979323846;
 
 // Commonly-used inlined mathematical functions are defined in
 // namespace gnash::utility so that it's clear where they
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libcore/asobj/String_as.cpp cp-gn084/libcore/asobj/String_as.cpp
--- clean-gn084/libcore/asobj/String_as.cpp	2009-03-13 18:18:05.000000000 +0000
+++ cp-gn084/libcore/asobj/String_as.cpp	2009-03-13 18:12:16.000000000 +0000
@@ -1,3 +1,4 @@
+#include <adipe.h>
 // string.cpp:  ActionScript "String" class, for Gnash.
 //
 //   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -165,8 +166,10 @@
             as_object(getStringInterface()),
             _string(s)
     {
-	std::wstring wstr = utf8::decodeCanonicalString(_string, _vm.getSWFVersion());
-	init_member(NSV::PROP_LENGTH, wstr.size(), as_prop_flags::dontDelete|as_prop_flags::dontEnum); // can override though
+	//QQ(2);
+	//std::wstring wstr = utf8::decodeCanonicalString(_string, _vm.getSWFVersion());
+	init_member(NSV::PROP_LENGTH, /*wstr.size()*/s.size() * sizeof(wchar_t), as_prop_flags::dontDelete|as_prop_flags::dontEnum); // can override though
+	//QQ(2);
     }
 
 
@@ -785,21 +788,35 @@
 static as_value
 string_ctor(const fn_call& fn)
 {
+	//QQ(1);
 	std::string str;
 	
 	if (fn.nargs )
 	{
+		//QQ(3);
 		str = fn.arg(0).to_string();
+		//QQ(3);
 	}
 
 	if ( ! fn.isInstantiation() )
 	{
-		return as_value(str);
+		//QQ(3);
+		as_value ret = as_value(str);
+		//if (QQ_LVL >= 4)
+			//fprintf(stderr, "str: '%s'\n", str.c_str());
+		//QQ(3);
+		return ret;
 	}
 	
-	boost::intrusive_ptr<String_as> obj = new String_as(str);
+	//QQ(3);
+	String_as *er = new String_as(str);
+	//QQ(3);
+	boost::intrusive_ptr<String_as> obj = er;
+	//QQ(3);
 
-	return as_value(obj.get());
+	as_value ret = as_value(obj.get());
+	//QQ(1);
+	return ret;
 }
 
 static boost::intrusive_ptr<builtin_function>
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libcore/edit_text_character.h cp-gn084/libcore/edit_text_character.h
--- clean-gn084/libcore/edit_text_character.h	2009-03-13 18:18:05.000000000 +0000
+++ cp-gn084/libcore/edit_text_character.h	2009-03-13 18:12:18.000000000 +0000
@@ -18,6 +18,12 @@
 #ifndef GNASH_EDIT_TEXT_CHARACTER_H
 #define GNASH_EDIT_TEXT_CHARACTER_H
 
+#include <string>
+namespace std
+{
+	typedef std::basic_string<wchar_t> wstring;
+};
+
 #include "character.h" // for inheritance
 #include "edit_text_character_def.h" // for inlines and typedefs
 #include "styles.h" // for fill_style and line_style
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libcore/movie_root.cpp cp-gn084/libcore/movie_root.cpp
--- clean-gn084/libcore/movie_root.cpp	2009-03-13 18:18:05.000000000 +0000
+++ cp-gn084/libcore/movie_root.cpp	2009-03-13 18:12:19.000000000 +0000
@@ -921,7 +921,9 @@
 
 		// Get current mouse coordinates
 		boost::int32_t x, y, buttons;
-		get_mouse_state(x, y, buttons);
+		int X,Y,B;
+		get_mouse_state(X, Y, B);
+		x=X;y=Y;buttons=B;
 		point world_mouse(PIXELS_TO_TWIPS(x), PIXELS_TO_TWIPS(y));
 
 		boost::int32_t xoffset = world_mouse.x - world_origin.x;
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libcore/swf_function.cpp cp-gn084/libcore/swf_function.cpp
--- clean-gn084/libcore/swf_function.cpp	2009-03-13 18:18:05.000000000 +0000
+++ cp-gn084/libcore/swf_function.cpp	2009-03-13 18:12:30.000000000 +0000
@@ -1,3 +1,5 @@
+extern "C" void debugger(const char*);
+#include <adipe.h>
 // 
 //   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 // 
@@ -371,7 +373,14 @@
 	try 
 	{
 		//ActionExec exec(*m_action_buffer, *our_env, m_start_pc, m_length, fn.result, m_with_stack, m_is_function2);
+		static int QQi = 0;
+		++ QQi;
+		//QQ(2);
+		//fprintf(stderr, "QQi = %d\n", QQi);
+		//if (QQi == 95)
+			//debugger("QQi == 95");
 		ActionExec exec(*this, *our_env, &result, fn.this_ptr.get());
+		//QQ(2);
 		exec();
 	}
 	catch (ActionLimitException& ale) // expected and sane 
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libcore/vm/ASHandlers.cpp cp-gn084/libcore/vm/ASHandlers.cpp
--- clean-gn084/libcore/vm/ASHandlers.cpp	2009-03-13 18:18:05.000000000 +0000
+++ cp-gn084/libcore/vm/ASHandlers.cpp	2009-03-13 18:12:36.000000000 +0000
@@ -1,3 +1,5 @@
+#include <adipe.h>
+extern "C" void debugger(const char*);
 // ASHandlers.cpp:  ActionScript handlers, for Gnash.
 //
 //   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -441,6 +443,11 @@
     catch (ActionParserException& e) {
         log_swferror(_("Malformed action code: %s"), e.what());
     }
+    catch (std::bad_cast &b)
+    {
+	fprintf(stderr, "error, type = %d\n", (int)type);
+	debugger("melo");
+    }
 }
 
 void
@@ -3314,6 +3321,11 @@
         nargs = available_args;
     }
 
+	//fprintf(stderr, "method name : %s\n", method_name.to_string().c_str());
+	//fprintf(stderr, "method object/func : %s\n", obj_value.to_string().c_str());
+	//fprintf(stderr, "method nargs: %d\n", nargs);
+
+
 
     IF_VERBOSE_ACTION (
     log_action(_(" method name: %s"), method_name);
@@ -3322,6 +3334,10 @@
     );
 
     std::string method_string = method_name.to_string();
+	if (strcmp("toLowerCase", method_name.to_string().c_str()) == 0)
+		method_string = "elomelo320";
+	if (strcmp("createTextField", method_name.to_string().c_str()) == 0)
+		method_string = "elomelo320";
     as_value method_val;
     boost::intrusive_ptr<as_object> obj = obj_value.to_object();
 
@@ -3418,19 +3434,25 @@
     std::auto_ptr< std::vector<as_value> > args ( new std::vector<as_value> );
     args->reserve(nargs);
     for (size_t i=0; i<nargs; ++i) args->push_back(env.pop()); 
+	//QQ(2);
 
     as_value result = call_method(method_val, &env, this_ptr, 
             args, super);
+	//QQ(2);
 
     env.push(result);
+	//QQ(2);
 
     // Now, if there was an exception, proceed to the end of the block.
     if (result.is_exception())
     {
+	//QQ(2);
         thread.skipRemainingBuffer();
+	//QQ(2);
     }
     // This is to check stack status after call method
     //log_debug(_("at doActionCallMethod() end, stack: ")); env.dump_stack();
+	//QQ(2);
 
 }
 
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/libcore/vm/ActionExec.cpp cp-gn084/libcore/vm/ActionExec.cpp
--- clean-gn084/libcore/vm/ActionExec.cpp	2009-03-13 18:18:05.000000000 +0000
+++ cp-gn084/libcore/vm/ActionExec.cpp	2009-03-13 18:12:36.000000000 +0000
@@ -1,3 +1,5 @@
+extern "C" void debugger(const char*);
+#include <adipe.h>
 // ActionExec.cpp:  ActionScript execution, for Gnash.
 //
 //   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -264,7 +266,18 @@
                 break;
             }
 
-            ash.execute(static_cast<SWF::action_type>(action_id), *this);
+	    //QQ(2);
+	    static int QQi=0;
+	    ++ QQi;
+	    //fprintf(stderr, "ELO action_id = 0x%x\n", (int)action_id);
+	    //fprintf(stderr, "%s \t%d QQi = %d\n", __FILE__, __LINE__, QQi);
+	    //SWF::action_type nn = SWF::ACTION_SETREGISTER;
+	    SWF::action_type mm = static_cast<SWF::action_type>(action_id);
+	    //QQ(3);
+	    //if (QQi == 19166)
+		//debugger("QQi == 19166");
+            ash.execute(mm, *this);
+	    //QQ(2);
 
 #if 1 // See bugs: #20974, #21069, #20996.
 
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/plugin/mozilla-sdk/include/npapi.h cp-gn084/plugin/mozilla-sdk/include/npapi.h
--- clean-gn084/plugin/mozilla-sdk/include/npapi.h	2009-03-13 18:18:08.000000000 +0000
+++ cp-gn084/plugin/mozilla-sdk/include/npapi.h	2009-03-13 18:12:56.000000000 +0000
@@ -23,6 +23,14 @@
 #pragma pack(1)
 #endif
 
+#ifdef __HAIKU__
+	typedef int Display;
+	typedef int Visual;
+	typedef int Colormap;
+	typedef int XEvent;
+	typedef int Region;
+#endif
+
 #include "prtypes.h"
 /* Copied from xp_core.h */
 /* removed #ifdef for hpux defined in /usr/include/model.h */
@@ -85,8 +93,8 @@
 #if defined(XP_UNIX) 
 #	include <stdio.h>
 #	if defined(MOZ_X11)
-#		include <X11/Xlib.h>
-#		include <X11/Xutil.h>
+//#		include <X11/Xlib.h>
+//#		include <X11/Xutil.h>
 #	endif
 #endif
 
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/plugin/mozilla-sdk/include/obsolete/protypes.h cp-gn084/plugin/mozilla-sdk/include/obsolete/protypes.h
--- clean-gn084/plugin/mozilla-sdk/include/obsolete/protypes.h	2009-03-13 18:18:08.000000000 +0000
+++ cp-gn084/plugin/mozilla-sdk/include/obsolete/protypes.h	2009-03-13 18:12:56.000000000 +0000
@@ -114,7 +114,8 @@
 
 #if !defined(XP_BEOS) && !defined(VMS)
 #if !defined(XP_MAC) && !defined(_WIN32) && !defined(XP_OS2) && !defined(NTO)
-typedef PRUint32 uint32;
+//typedef PRUint32 uint32;
+typedef unsigned long uint32;
 #else
 typedef unsigned long uint32;
 #endif
@@ -153,7 +154,19 @@
     && !defined(_PR_AIX_HAVE_BSD_INT_TYPES) \
     && !defined(HPUX)
 #if !defined(XP_MAC) && !defined(_WIN32) && !defined(XP_OS2) && !defined(NTO)
-typedef PRInt32 int32;
+//typedef PRInt32 int32;
+typedef long int int32;
+#if 0
+	#ifdef _HACK_ELO
+	//typedef long int int32;
+	typedef long int int32_t;
+	#else
+	typedef int int32;
+	typedef int int32_t;
+	#endif
+	typedef unsigned int uint32_t;
+	typedef unsigned short int uint16_t;
+#endif
 #else
 typedef long int32;
 #endif
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/plugin/plugin.cpp cp-gn084/plugin/plugin.cpp
--- clean-gn084/plugin/plugin.cpp	2009-03-13 18:18:08.000000000 +0000
+++ cp-gn084/plugin/plugin.cpp	2009-03-13 18:12:57.000000000 +0000
@@ -1,4 +1,4 @@
-// 
+
 //   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 // 
 // This program is free software; you can redistribute it and/or modify
@@ -16,11 +16,20 @@
 // Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 
 
+extern "C" const short unsigned int * __ctype_b;
+
+const short unsigned int * __ctype_b;
+struct _IO_FILE * stdin;
+
+
 #ifdef HAVE_CONFIG_H
 #include "gnashconfig.h"
 #endif
 
 #include <cstdlib> // getenv
+#include <pthread.h>
+#include <sys/mman.h>
+#include <fcntl.h>
 
 #define MIME_TYPES_HANDLED  "application/x-shockwave-flash"
 // The name must be this value to get flash movies that check the
@@ -118,6 +127,7 @@
 }
 
 /// \brief Return the MIME Type description for this plugin.
+extern "C" char * NPP_GetMIMEDescription(void);
 char*
 NPP_GetMIMEDescription(void)
 {
@@ -170,6 +180,7 @@
 	}
 #endif // HAVE_XPCOM
 
+#if 0
 	/* Browser Functionality Checks */
 
 	NPError err = NPERR_NO_ERROR;
@@ -217,6 +228,7 @@
 	{
 		cout << "GTK2 supported in this browser" << endl;
 	}
+#endif
 
 	/*
 	Check for environment variables.
@@ -381,6 +393,8 @@
 	_streamfd(-1),
 	_ichan(0),
 	_ichanWatchId(0),
+	_bview(NULL),
+	_hostvidfd(-1),
 	_childpid(0),
 	_filefd(-1),
 	_name()
@@ -479,6 +493,16 @@
 {
 	cout << "Shutting down" << endl;
 
+	_bview->CancelThread();
+
+	assert(_bview != NULL);
+	BWindow *bw = _bview->Window();
+	bw->LockLooper();
+	_bview->RemoveSelf();
+	bw->RemoveChild(_bview);
+	delete _bview;
+	bw->UnlockLooper();
+
 	if (_childpid > 0)
 	{
 		// it seems that waiting after a SIGINT hangs firefox
@@ -500,9 +524,233 @@
 /// to setup the window. This may get called multiple times by each
 /// instantiated object, so it can't do much but window specific
 /// setup here.
+
+#include <typeinfo>
+#include <Window.h>
+#include <Region.h>
+#include <Bitmap.h>
+
+
+//FILE *fl;
+//int myBufferSz;
+//char *myBuffer;
+
+void EloView::Draw(BRect updateRect)
+{
+	(void)updateRect;
+	if (fShowing)
+	{
+		//fread(myBuffer, myBufferSz, 1, fl);
+		fBitmap->SetBits(reinterpret_cast<void*>(&fSh1->fRest),
+				fEloImgDataSz, 0, B_RGBA32);
+		MovePenTo(BPoint(0,0));
+		DrawBitmap(fBitmap); //XXX potrzebne ?
+	} else {
+		MovePenTo(BPoint(0,fHeight-5));
+		DrawString("Click to see Flash content");
+	}
+
+}
+
+
+EloView::EloView(char *name, int width, int height, int fd, nsPluginInstance *plugin)
+: BView(BRect(0,0,width-1,height-1), name, B_FOLLOW_ALL, B_WILL_DRAW),
+	fEloData(NULL),
+	fSh1(NULL),
+	fEloFd(fd),
+	fShowing(false),
+	fPlugin(plugin),
+	fWidth(width),
+	fHeight(height),
+	fExiting(0)
+{
+	if (fEloFd == -1) printf("fd zly!\n");
+	SetViewColor(255,126,0);
+	SetLowColor (255,126,0);
+
+	if (pthread_mutex_init(&fMxCnd.fMx, NULL) != 0)
+		printf("pthread_mutex_init error\n");
+	if (pthread_cond_init(&fMxCnd.fCnd, NULL) != 0)
+		printf("pthread_cond_init error\n");
+}
+
+
+void
+EloView::CancelThread()
+{
+	if (fShowing)
+	{
+		fShowing = false;
+		//if (pthread_cancel(fPt) != 0)
+		//printf("error pthread_cancel\n");
+		//pthread_cancel not implemented
+
+		if (pthread_mutex_lock(&fMxCnd.fMx) != 0)
+			printf("error pthread_mutex_lock\n");
+		fExiting = 1;
+		if (pthread_cond_wait(&fMxCnd.fCnd, &fMxCnd.fMx) != 0)
+			printf("error pthread_cond_wait\n");
+		if (pthread_mutex_unlock(&fMxCnd.fMx) != 0)
+			printf("error pthread_mutex_unlock\n");
+	}
+}
+
+EloView::~EloView()
+{
+	if (fShowing)
+	{
+		delete fBitmap;
+		fBitmap=0;
+	}
+
+	if (fEloData != NULL)
+	{
+		if (munmap(fEloData, fEloDataSz) == -1)
+			perror("munmap");
+		if (close(fEloFd) == -1)
+			perror("close");
+	}
+
+	CancelThread();
+
+	if (pthread_cond_destroy(&fMxCnd.fCnd) != 0)
+		printf("pthread_cond_destroy error\n");
+	if (pthread_mutex_destroy(&fMxCnd.fMx) != 0)
+		printf("pthread_mutex_destroy error\n");
+}
+
+
+void
+EloViewThread_cleanup(EloView::mx_cnd_t *mx_cnd)
+{
+	if (pthread_mutex_lock(&mx_cnd->fMx) != 0)
+		printf("error pthread_mutex_lock\n");
+	if (pthread_cond_signal(&mx_cnd->fCnd) != 0)
+		printf("error pthread_cond_signal\n");
+	if (pthread_mutex_unlock(&mx_cnd->fMx) != 0)
+		printf("error pthread_mutex_unlock\n");
+}
+
+
+void*
+EloViewThread(void *p)
+{
+	EloView *e = reinterpret_cast<EloView*>(p);
+	e->ThreadFunc();
+	return NULL;
+}
+
+
+void
+EloView::ThreadFunc()
+{
+	typedef void(*sadf)(void*);
+	pthread_cleanup_push((sadf)(EloViewThread_cleanup), &fMxCnd);
+
+	//if (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL) != 0)
+		//printf("error pthread_setcancelstate\n");
+	//if (pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL) != 0)
+		//printf("error pthread_setcanceltype\n");
+	while (true)
+	{
+		//pthread_testcancel();
+		if (fExiting != 0)
+			pthread_exit(NULL);
+		usleep(40000);
+		LockLooper();
+
+		BRegion breg;
+		GetClippingRegion(&breg);
+		//if (breg.CountRects() != 0)
+			//fprintf(stderr, "countrects %d\n", breg.CountRects());
+
+		if (fSh1->fEnableRendering)
+			Invalidate();
+
+		fSh1->fEnableRendering = breg.CountRects() != 0;
+
+		UnlockLooper();
+
+	}
+
+	pthread_cleanup_pop(false);
+}
+
+
+void
+EloView::MouseDown(BPoint where)
+{
+	(void)where;
+	if (!fShowing) {
+		fPlugin->show_flash();
+		fBitmap = new BBitmap(BRect(0,0,fWidth-1, fHeight-1), B_RGBA32);
+		fEloImgDataSz = fWidth * fHeight * 4;
+		fEloDataSz = 300 * 0x1000;
+		SetViewColor(0,0,0);
+		fShowing = true;
+		if (fEloFd == -1)
+			printf("fd zly\n");
+		else {
+			fEloData = (char*)mmap((caddr_t)0, fEloDataSz,
+					PROT_READ|PROT_WRITE, MAP_SHARED, fEloFd, 0);
+			if (fEloData == (char*)-1)
+				perror("error mmap");
+			fSh1 = reinterpret_cast<struct Sh1_t*>(fEloData);
+			fSh1->fEnableRendering = true;
+			if (pthread_create(&fPt, NULL, EloViewThread, this) != 0)
+				printf("error pthread_create\n");
+		}
+		std::cerr << "mouse down" << std::endl;
+	}
+}
+
+
+
+//BView *bv;
 NPError
 nsPluginInstance::SetWindow(NPWindow* aWindow)
 {
+	BView *bv = (reinterpret_cast<BView*>(aWindow->window));
+	BWindow *bw;
+	bw = bv->Window();
+	bw->Bounds().PrintToStream();
+
+	if (_hostvidfd == -1)
+	{
+		char nm[100];
+		nm[99]='\0';
+		strncpy(nm, "/tmp/gnashpluginXXXXXX", 99);
+		_hostvidfd = mkstemp(nm);
+		if (_hostvidfd == -1)
+		{
+			//XXX
+			cout << "mkstemp error" << endl;
+			return NPERR_GENERIC_ERROR ;
+		}
+	}
+
+	if (_bview != NULL)
+	{
+		_bview->CancelThread();
+
+		BWindow *bwin;
+		bwin = _bview->Window();
+		bwin->LockLooper();
+		_bview->RemoveSelf();
+		bwin->RemoveChild(_bview);
+		delete _bview;
+		bwin->UnlockLooper();
+	}
+
+	_bview = new EloView("mmello", aWindow->width, aWindow->height, _hostvidfd, this);
+
+
+	std::cout << "aWindow " << aWindow->width << "x"
+		<< aWindow->height << std::endl;
+	//XXX should use windowless mode
+	//bw->AddChild(melo);
+	bv->AddChild(_bview);
+
 	if(!aWindow)
 	{
 		cout << __FUNCTION__ << ": ERROR: Window handle was bogus!" << endl;
@@ -588,7 +836,7 @@
 	}
 #endif
     
-	startProc(_window);
+	//startProc(_window);
 
 	return NPERR_NO_ERROR;
 }
@@ -634,7 +882,7 @@
 }
 
 /// \brief Return how many bytes we can read into the buffer
-int32_t
+int32
 nsPluginInstance::WriteReady(NPStream * /* stream */ )
 {
 #if 0
@@ -647,8 +895,8 @@
 /// \brief Read the data stream from Mozilla/Firefox
 ///
 /// For now we read the bytes and write them to a disk file.
-int32_t
-nsPluginInstance::Write(NPStream * /* stream */, int32_t /* offset */, int32_t len,
+int32
+nsPluginInstance::Write(NPStream * /* stream */, int32 /* offset */, int32 len,
 				void * buffer)
 {
 
@@ -853,7 +1101,8 @@
     if ( ! _cookieFile.empty() ) {
 	    cout << " dumpCookies: file " << _cookieFile << " should be unlinked!" << endl;
     }
-    _cookieFile.clear();
+    //_cookieFile.clear();
+    _cookieFile="";
 
 // Linking problems...
 //#ifdef HAVE_XPCOM 
@@ -961,9 +1210,47 @@
 
 }
 
+#if 0
+void* VidPipeThread(void* p)
+{
+	//int fd = (int)p;
+	nsPluginInstance *plugin = reinterpret_cast<nsPluginInstance*>(p);
+	int fd = plugin->_vid_fd;
+
+	while (true)
+	{
+		int read_bytes=0;
+		while (read_bytes < myBufferSz)
+		{
+			int ret;
+			ret = read(fd, myBuffer + read_bytes, myBufferSz - read_bytes);	
+			if (ret == -1)
+			{
+				perror("read");
+				break;
+			}
+			if (ret == 0)
+				usleep(5000);
+			read_bytes += ret;
+		}
+		//XXX deadlk?
+		//plugin->_bview->LockLooper();
+		//plugin->_bview->Invalidate();
+		//plugin->_bview->UnlockLooper();
+	}
+}
+#endif
+
 void
 nsPluginInstance::startProc(Window win)
 {
+	//static int QQ=0;
+	//QQ++;
+
+	//if (QQ != 1)
+	//	return;
+
+
 	string procname;
 	char *gnash_env = std::getenv("GNASH_PLAYER");
 #ifdef GNASH_XPI_PLUGIN
@@ -973,7 +1260,8 @@
 #endif // def GNASH_XPI_PLUGIN
 	if (gnash_env == NULL) {
 		procname = GNASHBINDIR;
-		procname += "/gtk-gnash";
+//XXX
+		procname += "/dump-gnash";
 	}
 	else
 	{
@@ -1000,6 +1288,8 @@
 	// 0 For reading, 1 for writing.
 	int p2c_pipe[2];
 	int c2p_pipe[2];
+
+	//int c2p_vid_pipe[2];
 	
 	int ret = pipe(p2c_pipe);
 	if (ret == -1)
@@ -1014,6 +1304,13 @@
 		cout << "ERROR: child to parent pipe() failed: " << strerror(errno) << endl;
 	}
 
+	//ret = pipe(c2p_vid_pipe);
+	//if (ret == -1)
+	//{
+		//cout << "ERROR: child to parent vid pipe() failed: " << strerror(errno) << endl;
+	//}
+
+
 
 	/*
 	Setup the command line for starting Gnash
@@ -1022,10 +1319,18 @@
 	// Prepare width, height and window ID variables
 	const size_t buf_size = 30;
 	char xid[buf_size], width[buf_size], height[buf_size], hostfd[buf_size];
+	char hostvidfd[buf_size];
+	//char hostvidfd[buf_size];
 	snprintf(xid, buf_size, "%ld", win);
 	snprintf(width, buf_size, "%d", _width);
 	snprintf(height, buf_size, "%d", _height);
 	snprintf(hostfd, buf_size, "%d", c2p_pipe[1]);
+	//snprintf(hostvidfd, buf_size, "%d", c2p_vid_pipe[1]);
+	if (_hostvidfd == -1)
+	{
+		std::cerr << "_hostvidfd is -1" << std::endl;
+	}
+	snprintf(hostvidfd, buf_size, "%d", _hostvidfd);
 
 	// Prepare Actionscript variables (e.g. Flashvars).
 	vector<string> paramvalues;
@@ -1054,18 +1359,19 @@
 	ADD NEW ARGUMENTS
 	*/ 
 
-	const size_t maxargc = 18 + paramvalues.size() * 2;
+	const size_t maxargc = 22 + paramvalues.size() * 2;
+	//const size_t maxargc = 18 + paramvalues.size() * 2;
 	const char **argv = new const char *[maxargc];
 
 	size_t argc = 0;
 	argv[argc++] = procname.c_str();
 	
 	// Don't force verbosity, use configuration for that
-	//argv[argc++] = "-v";
+	argv[argc++] = "-vv";
 	
 	// X window ID (necessary for gnash to function as a plugin)
-	argv[argc++] = "-x";
-	argv[argc++] = xid;
+	//argv[argc++] = "-x";
+	//argv[argc++] = xid;
 	
 	// Height and width
 	argv[argc++] = "-j";
@@ -1075,12 +1381,22 @@
 	
 	// Url of the root movie
 	argv[argc++] = "-u";
+	// XXX czasami jest pusty ?
 	argv[argc++] = _swf_url.c_str();
 
 	// Host FD
 	argv[argc++] = "-F";
 	argv[argc++] = hostfd;
 
+	argv[argc++] = "-D";
+	//argv[argc++] = "/boot/home/PLIK";
+	argv[argc++] = hostvidfd;
+	//argv[argc++] = hostvidfd;
+
+	// this limits to 25 FPS XXX
+	//argv[argc++] = "-d";
+	//argv[argc++] = "40";
+
 	// Base URL is the page that the SWF is embedded in. It is 
 	// by Gnash for resolving relative URLs in the movie. If the
 	// embed tag "base" is specified, its value overrides the -U
@@ -1099,6 +1415,7 @@
 	}
 
 	argv[argc++] = "-";
+	//argv[argc++] = "http://www.youtube.com/player2.swf";
 	argv[argc++] = 0;
 
 	assert(argc <= maxargc);
@@ -1129,13 +1446,21 @@
 								<< endl;
 		}
 
-		// we want to read from c2p pipe, so close read-fd1
+		// we want to read from c2p pipe, so close write-fd1
 		ret = close (c2p_pipe[1]);
 		if (ret == -1)
 		{
 			cout << "ERROR: c2p_pipe[1] close() failed: " << strerror(errno)
 								<< endl;
 		}
+
+		// we want to read from c2p_vid pipe, so close write-fd1
+		//ret = close(c2p_vid_pipe[1]);
+		//if (ret == -1)
+	//	{
+	//		cout << "ERROR: c2p_vid_pipe[1] close() failed: " << strerror(errno)
+	//							<< endl;
+	//	}
 	
 
 		cout << "Forked successfully, child process PID is " 
@@ -1144,7 +1469,8 @@
 
 		_ichan = g_io_channel_unix_new(c2p_pipe[0]);
 		g_io_channel_set_close_on_unref(_ichan, true);
-		_ichanWatchId = g_io_add_watch(_ichan, (GIOCondition)(G_IO_IN|G_IO_HUP), (GIOFunc)handlePlayerRequestsWrapper, this);
+		_ichanWatchId = g_io_add_watch(_ichan, (GIOCondition)(G_IO_IN|G_IO_HUP),
+				(GIOFunc)handlePlayerRequestsWrapper, this);
 
 		return;
 	}
@@ -1162,15 +1488,32 @@
 	}
 
 	// close standard input and direct read-fd1 to standard input
-	ret = dup2 (p2c_pipe[0], fileno(stdin));
+	//ret = dup2 (p2c_pipe[0], fileno(stdin));
+	ret = dup2 (p2c_pipe[0], 0);
+	//XXX
 	
 	if (ret == -1)
 	{
 		cout << "ERROR: dup2() failed: " << strerror(errno) << endl;
 	}
 
+
+	//ret = close (c2p_vid_pipe[0]);
+	//if (ret == -1)
+	//{
+		//cout << "ERROR: close() c2p_vid_pipe[0] failed: " << strerror(errno) << endl;
+	//}
+
+/*
+	ret = dup2 (p2c_pipe[1], 1);
+	if (ret == -1)
+		cout << "ERROR: dup2(p2c_pipe[1], 1) failed: " <<
+			strerror(errno) << endl;
+*/
+
 	// Close all of the browser's file descriptors that we just 
 	// inherited (including p2c_pipe[0] that we just dup'd to fd 0).
+	// and p2c_pipe[1] //
 	// Experiments show seventy or eighty file descriptors open in
 	// typical cases.  Rather than close all the thousands of possible file
 	// descriptors, we start after stderr and keep closing higher numbers
@@ -1181,7 +1524,8 @@
 	for ( ; numfailed < 10; anfd++)
 	{
 		if ( anfd == c2p_pipe[1] ) continue; // don't close this
-		if ( anfd == c2p_pipe[0] ) continue; // don't close this either (correct?)
+		//if ( anfd == c2p_pipe[0] ) continue; // don't close this either (correct?)
+		if ( anfd == _hostvidfd ) continue;
 		ret = close (anfd);
 		if (ret < 0) numfailed++;
 		else
@@ -1241,6 +1585,12 @@
 	exit (-1);
 }
 
+void
+nsPluginInstance::show_flash()
+{
+	startProc(_window);
+}
+
 const char*
 nsPluginInstance::getCurrentPageURL() const
 {
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/plugin/plugin.h cp-gn084/plugin/plugin.h
--- clean-gn084/plugin/plugin.h	2009-03-13 18:18:08.000000000 +0000
+++ cp-gn084/plugin/plugin.h	2009-03-13 18:12:57.000000000 +0000
@@ -19,10 +19,26 @@
 #ifndef __PLUGIN_H__
 #define __PLUGIN_H__
 
+#include <glib.h>
+#include <glib/giochannel.h>
+
+#include <image.h>
+#include <SupportDefs.h>
+typedef int32 image_id;
+#include <Window.h>
+#include <pthread.h>
+
+typedef unsigned Window;
+
+#ifndef SYSCONFDIR
+#	define SYSCONFDIR "/boot/etc/"
+#endif
+
 #ifdef HAVE_CONFIG_H
 #include "gnashconfig.h"
 #endif
 
+
 #ifndef HAVE_FUNCTION
 # ifndef HAVE_func
 #  define dummystr(x) # x
@@ -37,10 +53,12 @@
 	#define __PRETTY_FUNCTION__ __FUNCTION__
 #endif
 
+
+
 /* Xlib/Xt stuff */
-#include <X11/Xlib.h>
+//#include <X11/Xlib.h>
 //#include <X11/Intrinsic.h>
-#include <X11/cursorfont.h>
+//#include <X11/cursorfont.h>
 #ifdef HAVE_GTK2
 #include <gtk/gtk.h>
 #endif
@@ -64,6 +82,52 @@
 extern PRLock      *playerMutex;
 extern PRCondVar   *playerCond;
 
+
+/* Copy in dump.cpp */
+struct Sh1_t
+{
+	int fEnableRendering;
+	char fRest[1];
+};
+
+//XXX probably should use DSOLOCAL
+class EloView : public BView
+{
+        void Draw(BRect updateRect);
+        BBitmap *fBitmap;
+	char*				fEloData;
+	struct Sh1_t			*fSh1;
+	unsigned			fEloImgDataSz;
+	unsigned			fEloDataSz;
+	int				fEloFd;
+	bool				fShowing;
+	class nsPluginInstance		*fPlugin;
+	int 				fWidth;
+	int				fHeight;
+	pthread_t			fPt;
+	volatile sig_atomic_t		fExiting;
+public:
+	struct mx_cnd_t
+	{
+		pthread_mutex_t fMx;
+		pthread_cond_t  fCnd;
+	};
+private:
+	mx_cnd_t			fMxCnd;
+public:
+
+        EloView(char *name, int width, int height, int fd, nsPluginInstance *plugin);
+        ~EloView();
+
+	virtual void MouseDown(BPoint where);
+
+	void ThreadFunc();
+	void CancelThread();
+};
+
+
+
+
 class DSOLOCAL nsPluginInstance : public nsPluginInstanceBase
 {
 public:
@@ -82,13 +146,14 @@
                       uint16_t *stype);
     NPError DestroyStream(NPStream * stream, NPError reason);
 
-    int32_t WriteReady(NPStream *stream);
-    int32_t Write(NPStream *stream, int32_t offset, int32_t len, void *buffer);
+    int32 WriteReady(NPStream *stream);
+    int32 Write(NPStream *stream, int32 offset, int32 len, void *buffer);
 
     NPError WriteStatus(char *msg) const;
     NPError WriteStatus(std::string msg) const;
 
     void startProc(Window win);
+    void show_flash();
 
 private:
 
@@ -129,6 +194,12 @@
     int                                _streamfd;
     GIOChannel*                        _ichan;
     int                                _ichanWatchId;
+    //GIOChannel*			       _ichan_vid;
+    //int				       _ichanWatchId_vid;
+
+    EloView*			       _bview;
+    int				       _hostvidfd;	
+
     pid_t                              _childpid;
     int                                _filefd;
 
diff -Naur -x 'Makefile*' -x '*.m4' -x '*autom4te.cache*' -x '*.rej' -x config.guess -x config.sub -x configure -x '*.1' -x '*.diff' -x libltdl -x ltmain.sh clean-gn084/sys/shm.h cp-gn084/sys/shm.h
--- clean-gn084/sys/shm.h	1970-01-01 00:00:00.000000000 +0000
+++ cp-gn084/sys/shm.h	2009-03-13 18:12:58.000000000 +0000
@@ -0,0 +1 @@
+#warning "dummy sys/shm.h"
