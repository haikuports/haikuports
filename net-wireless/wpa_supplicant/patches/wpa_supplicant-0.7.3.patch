diff -urN wpa_supplicant-0.7.3/src/crypto/aes-internal-dec.c wpa_supplicant-0.7.3-haiku/src/crypto/aes-internal-dec.c
--- wpa_supplicant-0.7.3/src/crypto/aes-internal-dec.c	2010-09-07 17:43:39.064749568 +0200
+++ wpa_supplicant-0.7.3-haiku/src/crypto/aes-internal-dec.c	2011-07-01 17:41:33.033292288 +0200
@@ -32,7 +32,7 @@
  *
  * @return	the number of rounds for the given cipher key size.
  */
-void rijndaelKeySetupDec(u32 rk[/*44*/], const u8 cipherKey[])
+static void rijndaelKeySetupDec(u32 rk[/*44*/], const u8 cipherKey[])
 {
 	int Nr = 10, i, j;
 	u32 temp;
diff -urN wpa_supplicant-0.7.3/src/crypto/aes-internal-enc.c wpa_supplicant-0.7.3-haiku/src/crypto/aes-internal-enc.c
--- wpa_supplicant-0.7.3/src/crypto/aes-internal-enc.c	2010-09-07 17:43:39.065536000 +0200
+++ wpa_supplicant-0.7.3-haiku/src/crypto/aes-internal-enc.c	2011-07-01 17:42:10.033292288 +0200
@@ -27,7 +27,7 @@
 #include "crypto.h"
 #include "aes_i.h"
 
-void rijndaelEncrypt(const u32 rk[/*44*/], const u8 pt[16], u8 ct[16])
+static void rijndaelEncrypt(const u32 rk[/*44*/], const u8 pt[16], u8 ct[16])
 {
 	u32 s0, s1, s2, s3, t0, t1, t2, t3;
 	const int Nr = 10;
diff -urN wpa_supplicant-0.7.3/src/drivers/driver_bsd.c wpa_supplicant-0.7.3-haiku/src/drivers/driver_bsd.c
--- wpa_supplicant-0.7.3/src/drivers/driver_bsd.c	2010-09-07 17:43:39.009699328 +0200
+++ wpa_supplicant-0.7.3-haiku/src/drivers/driver_bsd.c	2011-09-27 18:32:01.953679872 +0200
@@ -48,9 +48,28 @@
 #if __NetBSD__
 #include <net80211/ieee80211_netbsd.h>
 #endif
+#ifdef __HAIKU__
+#include <NetworkNotifications.h>
+
+#include <net/if.h>
+#include <net/if_media.h>
+#include <net/ethernet.h>
+#include <sys/sockio.h>
+
+#include "net80211/ieee80211.h"
+#include "net80211/ieee80211_ioctl.h"
+#include "net80211/ieee80211_crypto.h"
+#endif /* __HAIKU__ */
 
 #include "l2_packet/l2_packet.h"
 
+
+#ifdef __HAIKU__
+void haiku_unregister_events(void *drv);
+int haiku_register_events(void *ctx, void *drv, const char *ifname,
+	void **events, void (*callback)(void *ctx, void *drv, int opcode));
+#endif
+
 struct bsd_driver_data {
 	struct hostapd_data *hapd;	/* back pointer */
 
@@ -65,6 +84,9 @@
 	int	prev_roaming;	/* roaming state to restore on deinit */
 	int	prev_privacy;	/* privacy state to restore on deinit */
 	int	prev_wpa;	/* wpa state to restore on deinit */
+#ifdef __HAIKU__
+	void	*events;
+#endif
 };
 
 /* Generic functions for hostapd and wpa_supplicant */
@@ -82,7 +104,7 @@
 	ireq.i_data = (void *) arg;
 	ireq.i_len = arg_len;
 
-	if (ioctl(drv->sock, SIOCS80211, &ireq) < 0) {
+	if (ioctl(drv->sock, SIOCS80211, &ireq, sizeof(ireq)) < 0) {
 		wpa_printf(MSG_ERROR, "ioctl[SIOCS80211, op=%u, val=%u, "
 			   "arg_len=%u]: %s", op, val, arg_len,
 			   strerror(errno));
@@ -103,8 +125,8 @@
 	ireq->i_len = arg_len;
 	ireq->i_data = arg;
 
-	if (ioctl(drv->sock, SIOCG80211, ireq) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCS80211, op=%u, "
+	if (ioctl(drv->sock, SIOCG80211, ireq, sizeof(*ireq)) < 0) {
+		wpa_printf(MSG_ERROR, "ioctl[SIOCG80211, op=%u, "
 			   "arg_len=%u]: %s", op, arg_len, strerror(errno));
 		return -1;
 	}
@@ -144,7 +166,7 @@
 	os_memset(&ifr, 0, sizeof(ifr));
 	os_strlcpy(ifr.ifr_name, drv->ifname, sizeof(ifr.ifr_name));
 	ifr.ifr_data = (void *)&nwid;
-	if (ioctl(drv->sock, SIOCG80211NWID, &ifr) < 0 ||
+	if (ioctl(drv->sock, SIOCG80211NWID, &ifr, sizeof(ifr)) < 0 ||
 	    nwid.i_len > IEEE80211_NWID_LEN)
 		return -1;
 	os_memcpy(ssid, nwid.i_nwid, nwid.i_len);
@@ -167,7 +189,7 @@
 	os_memset(&ifr, 0, sizeof(ifr));
 	os_strlcpy(ifr.ifr_name, drv->ifname, sizeof(ifr.ifr_name));
 	ifr.ifr_data = (void *)&nwid;
-	return ioctl(drv->sock, SIOCS80211NWID, &ifr);
+	return ioctl(drv->sock, SIOCS80211NWID, &ifr, sizeof(ifr));
 #else
 	return set80211var(drv, IEEE80211_IOC_SSID, ssid, ssid_len);
 #endif
@@ -182,7 +204,7 @@
 	os_memset(&ifmr, 0, sizeof(ifmr));
 	os_strlcpy(ifmr.ifm_name, drv->ifname, sizeof(ifmr.ifm_name));
 
-	if (ioctl(drv->sock, SIOCGIFMEDIA, &ifmr) < 0) {
+	if (ioctl(drv->sock, SIOCGIFMEDIA, &ifmr, sizeof(ifmr)) < 0) {
 		wpa_printf(MSG_ERROR, "%s: SIOCGIFMEDIA %s", __func__,
 			   strerror(errno));
 		return -1;
@@ -201,7 +223,7 @@
 	os_strlcpy(ifr.ifr_name, drv->ifname, sizeof(ifr.ifr_name));
 	ifr.ifr_media = media;
 
-	if (ioctl(drv->sock, SIOCSIFMEDIA, &ifr) < 0) {
+	if (ioctl(drv->sock, SIOCSIFMEDIA, &ifr, sizeof(ifr)) < 0) {
 		wpa_printf(MSG_ERROR, "%s: SIOCSIFMEDIA %s", __func__,
 			   strerror(errno));
 		return -1;
@@ -258,13 +280,14 @@
 static int
 bsd_ctrl_iface(void *priv, int enable)
 {
+#ifndef __HAIKU__
 	struct bsd_driver_data *drv = priv;
 	struct ifreq ifr;
 
 	os_memset(&ifr, 0, sizeof(ifr));
 	os_strlcpy(ifr.ifr_name, drv->ifname, sizeof(ifr.ifr_name));
 
-	if (ioctl(drv->sock, SIOCGIFFLAGS, &ifr) < 0) {
+	if (ioctl(drv->sock, SIOCGIFFLAGS, &ifr, sizeof(ifr)) < 0) {
 		perror("ioctl[SIOCGIFFLAGS]");
 		return -1;
 	}
@@ -274,10 +297,11 @@
 	else
 		ifr.ifr_flags &= ~IFF_UP;
 
-	if (ioctl(drv->sock, SIOCSIFFLAGS, &ifr) < 0) {
+	if (ioctl(drv->sock, SIOCSIFFLAGS, &ifr, sizeof(ifr)) < 0) {
 		perror("ioctl[SIOCSIFFLAGS]");
 		return -1;
 	}
+#endif
 
 	return 0;
 }
@@ -487,6 +511,7 @@
 				   IEEE80211_MLME_UNAUTHORIZE, 0, addr);
 }
 
+#ifndef __HAIKU__
 static void
 bsd_new_sta(void *priv, void *ctx, u8 addr[IEEE80211_ADDR_LEN])
 {
@@ -513,6 +538,7 @@
 no_ie:
 	drv_event_assoc(ctx, addr, iebuf, ielen);
 }
+#endif // !__HAIKU__
 
 static int
 bsd_send_eapol(void *priv, const u8 *addr, const u8 *data, size_t data_len,
@@ -551,7 +577,7 @@
 	os_memset(&creq, 0, sizeof(creq));
 	os_strlcpy(creq.i_name, drv->ifname, sizeof(creq.i_name));
 	creq.i_channel = channel;
-	return ioctl(drv->sock, SIOCS80211CHANNEL, &creq);
+	return ioctl(drv->sock, SIOCS80211CHANNEL, &creq, sizeof(creq));
 #else /* SIOCS80211CHANNEL */
 	return set80211param(priv, IEEE80211_IOC_CHANNEL, channel);
 #endif /* SIOCS80211CHANNEL */
@@ -644,7 +670,7 @@
 }
 
 
-static int 
+static int
 bsd_flush(void *priv)
 {
 	u8 allsta[IEEE80211_ADDR_LEN];
@@ -859,7 +885,7 @@
 	struct ieee80211_bssid bs;
 
 	os_strlcpy(bs.i_name, drv->ifname, sizeof(bs.i_name));
-	if (ioctl(drv->sock, SIOCG80211BSSID, &bs) < 0)
+	if (ioctl(drv->sock, SIOCG80211BSSID, &bs, sizeof(bs)) < 0)
 		return -1;
 	os_memcpy(bssid, bs.i_bssid, sizeof(bs.i_bssid));
 	return 0;
@@ -979,7 +1005,7 @@
 	wpa_printf(MSG_DEBUG,
 		"%s: ssid '%.*s' wpa ie len %u pairwise %u group %u key mgmt %u"
 		, __func__
-		   , (unsigned int) params->ssid_len, params->ssid
+		, (int) params->ssid_len, params->ssid
 		, (unsigned int) params->wpa_ie_len
 		, params->pairwise_suite
 		, params->group_suite
@@ -1130,6 +1156,23 @@
 #endif /* IEEE80211_IOC_SCAN_MAX_SSID */
 }
 
+#ifdef __HAIKU__
+static void
+wpa_driver_haiku_event(void *ctx, void *drv, int opcode)
+{
+	switch (opcode) {
+		case B_NETWORK_WLAN_JOINED:
+			wpa_supplicant_event(ctx, EVENT_ASSOC, NULL);
+			break;
+		case B_NETWORK_WLAN_LEFT:
+			wpa_supplicant_event(ctx, EVENT_DISASSOC, NULL);
+			break;
+		case B_NETWORK_WLAN_SCANNED:
+			wpa_supplicant_event(ctx, EVENT_SCAN_RESULTS, NULL);
+			break;
+	}
+}
+#else // !__HAIKU__
 static void
 wpa_driver_bsd_event_receive(int sock, void *ctx, void *sock_ctx)
 {
@@ -1242,6 +1285,7 @@
 		break;
 	}
 }
+#endif	// !__HAIKU__
 
 static void
 wpa_driver_bsd_add_scan_entry(struct wpa_scan_results *res,
@@ -1260,7 +1304,11 @@
 	if (result == NULL)
 		return;
 	os_memcpy(result->bssid, sr->isr_bssid, ETH_ALEN);
+#ifdef __HAIKU__
+	result->freq = sr->isr_chan.ic_freq;
+#else
 	result->freq = sr->isr_freq;
+#endif
 	result->beacon_int = sr->isr_intval;
 	result->caps = sr->isr_capinfo;
 	result->qual = sr->isr_rssi;
@@ -1319,7 +1367,7 @@
 
 	pos = buf;
 	rest = len;
-	while (rest >= sizeof(struct ieee80211req_scan_result)) {
+	while (rest >= (int) sizeof(struct ieee80211req_scan_result)) {
 		sr = (struct ieee80211req_scan_result *)pos;
 		wpa_driver_bsd_add_scan_entry(res, sr);
 		pos += sr->isr_len;
@@ -1431,11 +1479,18 @@
 	drv->sock = socket(PF_INET, SOCK_DGRAM, 0);
 	if (drv->sock < 0)
 		goto fail1;
+#ifndef __HAIKU__
 	drv->route = socket(PF_ROUTE, SOCK_RAW, 0);
 	if (drv->route < 0)
 		goto fail;
 	eloop_register_read_sock(drv->route,
 		wpa_driver_bsd_event_receive, ctx, drv);
+#else
+	if (haiku_register_events(ctx, drv, ifname, &drv->events,
+			wpa_driver_haiku_event) != 0) {
+		goto fail;
+	}
+#endif
 
 	drv->ctx = ctx;
 	os_strlcpy(drv->ifname, ifname, sizeof(drv->ifname));
@@ -1478,7 +1533,11 @@
 	struct bsd_driver_data *drv = priv;
 
 	wpa_driver_bsd_set_wpa(drv, 0);
+#ifndef __HAIKU__
 	eloop_unregister_read_sock(drv->route);
+#else
+	haiku_unregister_events(drv->events);
+#endif
 
 	/* NB: mark interface down */
 	bsd_ctrl_iface(drv, 0);
diff -urN wpa_supplicant-0.7.3/src/drivers/driver_haiku_events.cpp wpa_supplicant-0.7.3-haiku/src/drivers/driver_haiku_events.cpp
--- wpa_supplicant-0.7.3/src/drivers/driver_haiku_events.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/src/drivers/driver_haiku_events.cpp	2011-09-27 18:54:15.247726080 +0200
@@ -0,0 +1,103 @@
+/*
+ * WPA Supplicant - Haiku event handling routines
+ * Copyright (c) 2010, Axel DÃ¶rfler, axeld@pinc-software.de.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ *
+ * This file can be used as a starting point for layer2 packet implementation.
+ */
+
+#include <Application.h>
+#include <Looper.h>
+#include <String.h>
+
+#include <net_notifications.h>
+
+#include <new>
+
+
+class EventLooper : public BLooper {
+public:
+	EventLooper(void *context, void *driverData, const char *interfaceName,
+		void (*callback)(void *, void *, int))
+		:
+		fContext(context),
+		fDriverData(driverData),
+		fInterfaceName(interfaceName),
+		fCallback(callback),
+		fQuitting(false)
+	{
+		start_watching_network(B_WATCH_NETWORK_WLAN_CHANGES, this);
+	}
+
+	virtual ~EventLooper()
+	{
+		fQuitting = true;
+		stop_watching_network(this);
+	}
+
+protected:
+	virtual void MessageReceived(BMessage *message)
+	{
+		if (message->what != B_NETWORK_MONITOR) {
+			BLooper::MessageReceived(message);
+			return;
+		}
+
+		if (fQuitting)
+			return;
+
+		BString interfaceName;
+		if (message->FindString("interface", &interfaceName) != B_OK)
+			return;
+
+		if (fInterfaceName.FindFirst(interfaceName) < 0) {
+			// The notification is for some other interface
+			return;
+		}
+
+		message->AddPointer("callback", (void *)fCallback);
+		message->AddPointer("context", fContext);
+		message->AddPointer("data", fDriverData);
+		be_app->PostMessage(message);
+	}
+
+private:
+	void *fContext;
+	void *fDriverData;
+	BString fInterfaceName;
+	void (*fCallback)(void *, void *, int);
+	bool fQuitting;
+};
+
+
+extern "C" void
+haiku_unregister_events(void *events)
+{
+	EventLooper *eventLooper = (EventLooper *)events;
+	if (eventLooper->Lock())
+		eventLooper->Quit();
+}
+
+
+extern "C" int
+haiku_register_events(void *ctx, void *drv, const char *ifname, void **events,
+	void (*callback)(void *ctx, void *drv, int opcode))
+{
+	EventLooper *eventLooper = new(std::nothrow) EventLooper(ctx, drv, ifname,
+		callback);
+	if (eventLooper == NULL)
+		return B_NO_MEMORY;
+
+	eventLooper->Run();
+
+	*events = eventLooper;
+	return 0;
+}
diff -urN wpa_supplicant-0.7.3/src/drivers/drivers.mak wpa_supplicant-0.7.3-haiku/src/drivers/drivers.mak
--- wpa_supplicant-0.7.3/src/drivers/drivers.mak	2010-09-07 17:43:39.012058624 +0200
+++ wpa_supplicant-0.7.3-haiku/src/drivers/drivers.mak	2011-09-27 17:40:51.542638080 +0200
@@ -45,9 +45,15 @@
 endif
 DRV_CFLAGS += -DCONFIG_DRIVER_BSD
 DRV_OBJS += ../src/drivers/driver_bsd.o
+ifneq ($(CONFIG_L2_PACKET), haiku)
 CONFIG_L2_FREEBSD=y
 CONFIG_DNET_PCAP=y
 endif
+endif
+
+ifeq ($(CONFIG_L2_PACKET), haiku)
+DRV_OBJS += ../src/drivers/driver_haiku_events.o
+endif
 
 ifdef CONFIG_DRIVER_TEST
 DRV_CFLAGS += -DCONFIG_DRIVER_TEST
diff -urN wpa_supplicant-0.7.3/src/l2_packet/l2_packet_haiku.c wpa_supplicant-0.7.3-haiku/src/l2_packet/l2_packet_haiku.c
--- wpa_supplicant-0.7.3/src/l2_packet/l2_packet_haiku.c	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/src/l2_packet/l2_packet_haiku.c	2011-09-27 18:49:59.729284608 +0200
@@ -0,0 +1,235 @@
+/*
+ * WPA Supplicant - Layer2 packet handling for Haiku
+ * Copyright (c) 2010, Axel DÃ¶rfler, axeld@pinc-software.de.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ *
+ * This file can be used as a starting point for layer2 packet implementation.
+ */
+
+#include "includes.h"
+
+#include "common.h"
+#include "eloop.h"
+#include "l2_packet.h"
+
+#include <net/ethernet.h>
+#include <net/if_dl.h>
+#include <sys/sockio.h>
+
+
+struct l2_packet_data {
+	char ifname[IF_NAMESIZE];
+	union {
+		struct sockaddr_dl link_address;
+		struct sockaddr_storage link_storage;
+	};
+	void (*rx_callback)(void *ctx, const u8 *src_addr,
+			    const u8 *buf, size_t len);
+	void *rx_callback_ctx;
+	int l2_hdr; /* whether to include layer 2 (Ethernet) header data
+		     * buffers */
+	int rx_fd;
+	int tx_fd;
+};
+
+
+int l2_packet_get_own_addr(struct l2_packet_data *l2, u8 *addr)
+{
+	os_memcpy(addr, LLADDR(&l2->link_address), ETH_ALEN);
+	return 0;
+}
+
+
+#if 0
+static void
+dump_block(const u8* buffer, int size, const char* prefix)
+{
+	const int DUMPED_BLOCK_SIZE = 16;
+	int i;
+
+	for (i = 0; i < size;) {
+		int start = i;
+
+		printf("%s%04x ", prefix, i);
+		for (; i < start + DUMPED_BLOCK_SIZE; i++) {
+			if (!(i % 4))
+				printf(" ");
+
+			if (i >= size)
+				printf("  ");
+			else
+				printf("%02x", *(unsigned char*)(buffer + i));
+		}
+		printf("  ");
+
+		for (i = start; i < start + DUMPED_BLOCK_SIZE; i++) {
+			if (i < size) {
+				char c = buffer[i];
+
+				if (c < 30)
+					printf(".");
+				else
+					printf("%c", c);
+			} else
+				break;
+		}
+		printf("\n");
+	}
+}
+#endif
+
+
+int l2_packet_send(struct l2_packet_data *l2, const u8 *dst_addr, u16 proto,
+		   const u8 *buf, size_t len)
+{
+	int result = -1;
+	struct sockaddr_dl to;
+
+	if (l2 == NULL)
+		return -1;
+
+	if (l2->l2_hdr) {
+		int result = send(l2->tx_fd, buf, len, 0);
+		if (result < 0)
+			printf("l2_packet_send failed to send: %s", strerror(errno));
+		return result;
+	}
+
+	memset(&to, 0, sizeof(struct sockaddr_dl));
+	to.sdl_len = sizeof(struct sockaddr_dl);
+	to.sdl_family = AF_LINK;
+	to.sdl_e_type = htons(proto);
+	to.sdl_alen = ETHER_ADDR_LEN;
+	memcpy(LLADDR(&to), dst_addr, ETHER_ADDR_LEN);
+
+	result = sendto(l2->tx_fd, buf, len, 0, (struct sockaddr*)&to,
+		sizeof(struct sockaddr_dl));
+	if (result < 0)
+		printf("l2_packet_send failed to send: %s", strerror(errno));
+
+	return result;
+}
+
+
+static void l2_packet_receive(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	struct l2_packet_data *l2 = eloop_ctx;
+	struct sockaddr_dl from;
+	socklen_t fromLength = sizeof(struct sockaddr_dl);
+	ssize_t bytesReceived;
+	u8 buffer[2300];
+
+	bytesReceived = recvfrom(l2->rx_fd, buffer, sizeof(buffer), MSG_TRUNC,
+				 (struct sockaddr*)&from, &fromLength);
+
+	if (bytesReceived <= 0)
+		return;
+
+	l2->rx_callback(l2->rx_callback_ctx, LLADDR(&from), buffer, bytesReceived);
+}
+
+
+struct l2_packet_data * l2_packet_init(
+	const char *ifname, const u8 *own_addr, unsigned short protocol,
+	void (*rx_callback)(void *ctx, const u8 *src_addr,
+			    const u8 *buf, size_t len),
+	void *rx_callback_ctx, int l2_hdr)
+{
+	struct l2_packet_data *l2;
+	struct ifreq request;
+
+	/* check if the interface exists */
+	if (if_nametoindex(ifname) == 0)
+		return NULL;
+
+	l2 = os_zalloc(sizeof(struct l2_packet_data));
+	if (l2 == NULL)
+		return NULL;
+	os_strlcpy(l2->ifname, ifname, sizeof(l2->ifname));
+	l2->rx_callback = rx_callback;
+	l2->rx_callback_ctx = rx_callback_ctx;
+	l2->l2_hdr = l2_hdr;
+
+	/* open connection for sending and receiving frames */
+	l2->tx_fd = socket(AF_LINK, SOCK_DGRAM, 0);
+	if (l2->tx_fd < 0)
+		goto err1;
+
+	/* retrieve link address */
+	strlcpy(request.ifr_name, ifname, IF_NAMESIZE);
+	if (ioctl(l2->tx_fd, SIOCGIFADDR, &request, sizeof(struct ifreq)) < 0)
+		goto err2;
+
+	memcpy(&l2->link_address, &request.ifr_addr, request.ifr_addr.sa_len);
+
+	if (l2_hdr) {
+		/* we need to preserve the L2 header - this is only
+		   possible by using a dedicated socket.
+		 */
+
+		/* open connection for monitoring frames */
+		l2->rx_fd = socket(AF_LINK, SOCK_DGRAM, 0);
+		if (l2->rx_fd < 0)
+			goto err2;
+
+		/* start monitoring */
+		if (ioctl(l2->rx_fd, SIOCSPACKETCAP, &request,
+			  sizeof(struct ifreq)) < 0)
+			goto err2;
+	} else {
+		/* bind to protocol */
+		l2->link_address.sdl_e_type = htons(protocol);
+
+		if (bind(l2->tx_fd, (struct sockaddr *)&l2->link_address,
+				((struct sockaddr *)&l2->link_address)->sa_len) < 0)
+			goto err2;
+
+		/* we can use the same socket to receive our packets */
+		l2->rx_fd = l2->tx_fd;
+	}
+
+	eloop_register_read_sock(l2->rx_fd, l2_packet_receive, l2, NULL);
+
+	return l2;
+
+err2:
+	close(l2->tx_fd);
+err1:
+	os_free(l2);
+	return NULL;
+}
+
+
+void l2_packet_deinit(struct l2_packet_data *l2)
+{
+	if (l2 == NULL)
+		return;
+
+	if (l2->rx_fd >= 0) {
+		eloop_unregister_read_sock(l2->rx_fd);
+		/* TODO: close connection */
+	}
+
+	os_free(l2);
+}
+
+
+int l2_packet_get_ip_addr(struct l2_packet_data *l2, char *buf, size_t len)
+{
+	/* TODO: get interface IP address */
+	return -1;
+}
+
+
+void l2_packet_notify_auth_start(struct l2_packet_data *l2)
+{
+	/* This function can be left empty */
+}
diff -urN wpa_supplicant-0.7.3/src/utils/common.h wpa_supplicant-0.7.3-haiku/src/utils/common.h
--- wpa_supplicant-0.7.3/src/utils/common.h	2010-09-07 17:43:39.048234496 +0200
+++ wpa_supplicant-0.7.3-haiku/src/utils/common.h	2011-07-01 17:39:20.061079552 +0200
@@ -59,6 +59,14 @@
 }
 #endif /* __APPLE__ */
 
+#if defined(__HAIKU__)
+#include <endian.h>
+#include <net/if.h>
+#define bswap_16 __swap_int16
+#define bswap_32 __swap_int32
+#define bswap_64 __swap_int64
+#endif /* __HAIKU__ */
+
 #ifdef CONFIG_TI_COMPILER
 #define __BIG_ENDIAN 4321
 #define __LITTLE_ENDIAN 1234
diff -urN wpa_supplicant-0.7.3/src/utils/os_unix.c wpa_supplicant-0.7.3-haiku/src/utils/os_unix.c
--- wpa_supplicant-0.7.3/src/utils/os_unix.c	2010-09-07 17:43:39.048496640 +0200
+++ wpa_supplicant-0.7.3-haiku/src/utils/os_unix.c	2011-07-02 18:19:53.552599552 +0200
@@ -135,9 +135,9 @@
 
 int os_daemonize(const char *pid_file)
 {
-#ifdef __uClinux__
+#if defined(__uClinux__) || defined(__HAIKU__)
 	return -1;
-#else /* __uClinux__ */
+#else /* __uClinux__ || __HAIKU__ */
 	if (os_daemon(0, 0)) {
 		perror("daemon");
 		return -1;
@@ -152,7 +152,7 @@
 	}
 
 	return -0;
-#endif /* __uClinux__ */
+#endif /* __uClinux__ || __HAIKU__ */
 }
 
 
diff -urN wpa_supplicant-0.7.3/src/utils/wpa_debug.h wpa_supplicant-0.7.3-haiku/src/utils/wpa_debug.h
--- wpa_supplicant-0.7.3/src/utils/wpa_debug.h	2010-09-07 17:43:39.047448064 +0200
+++ wpa_supplicant-0.7.3-haiku/src/utils/wpa_debug.h	2011-07-02 18:17:43.390332416 +0200
@@ -79,7 +79,7 @@
 static inline void wpa_hexdump_buf(int level, const char *title,
 				   const struct wpabuf *buf)
 {
-	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
+	wpa_hexdump(level, title, (u8 *)wpabuf_head(buf), wpabuf_len(buf));
 }
 
 /**
@@ -100,7 +100,7 @@
 static inline void wpa_hexdump_buf_key(int level, const char *title,
 				       const struct wpabuf *buf)
 {
-	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
+	wpa_hexdump_key(level, title, (u8 *)wpabuf_head(buf), wpabuf_len(buf));
 }
 
 /**
diff -urN wpa_supplicant-0.7.3/src/utils/wpabuf.h wpa_supplicant-0.7.3-haiku/src/utils/wpabuf.h
--- wpa_supplicant-0.7.3/src/utils/wpabuf.h	2010-09-07 17:43:39.048496640 +0200
+++ wpa_supplicant-0.7.3-haiku/src/utils/wpabuf.h	2011-07-02 18:16:39.086769664 +0200
@@ -85,7 +85,7 @@
 
 static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
 {
-	return wpabuf_head(buf);
+	return (u8 *)wpabuf_head(buf);
 }
 
 /**
@@ -102,36 +102,36 @@
 
 static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
 {
-	return wpabuf_mhead(buf);
+	return (u8 *)wpabuf_mhead(buf);
 }
 
 static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
 {
-	u8 *pos = wpabuf_put(buf, 1);
+	u8 *pos = (u8 *)wpabuf_put(buf, 1);
 	*pos = data;
 }
 
 static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
 {
-	u8 *pos = wpabuf_put(buf, 2);
+	u8 *pos = (u8 *)wpabuf_put(buf, 2);
 	WPA_PUT_LE16(pos, data);
 }
 
 static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
 {
-	u8 *pos = wpabuf_put(buf, 2);
+	u8 *pos = (u8 *)wpabuf_put(buf, 2);
 	WPA_PUT_BE16(pos, data);
 }
 
 static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
 {
-	u8 *pos = wpabuf_put(buf, 3);
+	u8 *pos = (u8 *)wpabuf_put(buf, 3);
 	WPA_PUT_BE24(pos, data);
 }
 
 static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
 {
-	u8 *pos = wpabuf_put(buf, 4);
+	u8 *pos = (u8 *)wpabuf_put(buf, 4);
 	WPA_PUT_BE32(pos, data);
 }
 
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/.config wpa_supplicant-0.7.3-haiku/wpa_supplicant/.config
--- wpa_supplicant-0.7.3/wpa_supplicant/.config	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/.config	2011-09-27 19:04:17.648019968 +0200
@@ -0,0 +1,120 @@
+# for OpenSSL
+CFLAGS += -I/boot/common/include
+LIBS += -L/boot/common/lib
+
+# for private Haiku headers
+CFLAGS += -I/system/develop/headers/private/libs/compat/freebsd_network/compat
+CFLAGS += -I/system/develop/headers/private/libs/compat/freebsd_wlan
+CFLAGS += -I/system/develop/headers/private/net
+CFLAGS += -Wno-multichar
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+CONFIG_DRIVER_BSD=y
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+#CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+#CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+#CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+#CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+#CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+#CONFIG_EAP_TTLS=y
+
+# EAP-GTC
+#CONFIG_EAP_GTC=y
+
+# EAP-OTP
+#CONFIG_EAP_OTP=y
+
+# LEAP
+#CONFIG_EAP_LEAP=y
+
+# Wi-Fi Protected Setup (WPS)
+#CONFIG_WPS=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+#CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+#CONFIG_SMARTCARD=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+#CONFIG_CTRL_IFACE=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=none
+
+# Remove configuration write functionality (i.e., to allow the configuration
+# file to be updated based on runtime configuration changes). The runtime
+# configuration can still be changed, the changes are just not going to be
+# persistent over restarts. This option can be used to reduce code size by
+# about 3.5 kB.
+CONFIG_NO_CONFIG_WRITE=y
+
+# Remove support for configuration blobs to reduce code size by about 1.5 kB.
+CONFIG_NO_CONFIG_BLOBS=y
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+CONFIG_MAIN=main_haiku
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+#CONFIG_OS=haiku
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+#CONFIG_ELOOP=eloop
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+CONFIG_L2_PACKET=haiku
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# Enable mitigation against certain attacks against TKIP by delaying Michael
+# MIC error reports by a random amount of time between 0 and 60 seconds
+#CONFIG_DELAYED_MIC_ERROR_REPORT=y
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/Makefile wpa_supplicant-0.7.3-haiku/wpa_supplicant/Makefile
--- wpa_supplicant-0.7.3/wpa_supplicant/Makefile	2010-09-07 17:43:39.014417920 +0200
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/Makefile	2011-10-05 21:46:19.671088640 +0200
@@ -579,9 +579,11 @@
 NEED_EAP_COMMON=y
 ifdef CONFIG_DYNAMIC_EAP_METHODS
 CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
+ifneq ($(CONFIG_L2_PACKET), haiku)
 LIBS += -ldl -rdynamic
 endif
 endif
+endif
 
 ifdef CONFIG_AP
 NEED_80211_COMMON=y
@@ -898,11 +900,23 @@
 ifdef CONFIG_SMARTCARD
 ifndef CONFIG_NATIVE_WINDOWS
 ifneq ($(CONFIG_L2_PACKET), freebsd)
+ifneq ($(CONFIG_L2_PACKET), haiku)
 LIBS += -ldl
 endif
 endif
 endif
 endif
+endif
+
+ifeq ($(CONFIG_L2_PACKET), haiku)
+OBJS += WirelessConfigDialog.o
+OBJS += notify_haiku.o
+LIBS += -lnetwork -lbe
+LIBS_c += -lnetwork
+ifeq ($(shell $(CC) -dumpversion | cut -d. -f1), 4)
+LIBS += -lstdc++
+endif
+endif
 
 ifndef TLS_FUNCS
 OBJS += ../src/crypto/tls_none.o
@@ -1270,13 +1284,21 @@
 wpa_priv: $(BCHECK) $(OBJS_priv)
 	$(LDO) $(LDFLAGS) -o wpa_priv $(OBJS_priv) $(LIBS)
 
+ifneq ($(CONFIG_L2_PACKET), haiku)
 wpa_supplicant: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
 	$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
+else
+wpa_supplicant: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
+	$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
+	rc -o wpa_supplicant.rsrc wpa_supplicant.rdef
+	xres -o wpa_supplicant wpa_supplicant.rsrc
+	mimeset -F wpa_supplicant
+endif
 
 eapol_test: .config $(OBJS_t)
 	$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
 
-preauth_test: .config $(OBJS_t2) 
+preauth_test: .config $(OBJS_t2)
 	$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
 
 wpa_passphrase: $(OBJS_p)
@@ -1329,6 +1351,10 @@
 	$(Q)$(CC) -c -o $@ $(CFLAGS) $<
 	@$(E) "  CC " $<
 
+%.o: %.cpp
+	$(Q)$(CC) -c -o $@ $(CFLAGS) $<
+	@$(E) "  CPP " $<
+
 wpa_supplicant.exe: wpa_supplicant
 	mv -f $< $@
 wpa_cli.exe: wpa_cli
@@ -1346,13 +1372,13 @@
 	$(STRIP) $(WINALL)
 
 wpa_gui/Makefile:
-	qmake -o wpa_gui/Makefile wpa_gui/wpa_gui.pro 
+	qmake -o wpa_gui/Makefile wpa_gui/wpa_gui.pro
 
 wpa_gui: wpa_gui/Makefile
 	$(MAKE) -C wpa_gui
 
 wpa_gui-qt4/Makefile:
-	qmake -o wpa_gui-qt4/Makefile wpa_gui-qt4/wpa_gui.pro 
+	qmake -o wpa_gui-qt4/Makefile wpa_gui-qt4/wpa_gui.pro
 
 wpa_gui-qt4/lang/wpa_gui_de.qm: wpa_gui-qt4/lang/wpa_gui_de.ts
 	lrelease wpa_gui-qt4/wpa_gui.pro
@@ -1375,6 +1401,6 @@
 	$(MAKE) -C ../src clean
 	$(MAKE) -C dbus clean
 	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL) eapol_test preauth_test
-	rm -f wpa_priv
+	rm -f wpa_priv *.rsrc
 
 -include $(OBJS:%.o=%.d)
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/WirelessConfigDialog.cpp wpa_supplicant-0.7.3-haiku/wpa_supplicant/WirelessConfigDialog.cpp
--- wpa_supplicant-0.7.3/wpa_supplicant/WirelessConfigDialog.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/WirelessConfigDialog.cpp	2011-09-27 18:52:47.483131392 +0200
@@ -0,0 +1,255 @@
+/*
+ * WPA Supplicant - Wireless Config Dialog
+ * Copyright (c) 2011, Michael Lotz <mmlr@mlotz.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#include <Button.h>
+#include <GridLayout.h>
+#include <GridView.h>
+#include <GroupLayout.h>
+#include <GroupView.h>
+#include <MenuField.h>
+#include <MenuItem.h>
+#include <NetworkDevice.h>
+#include <PopUpMenu.h>
+#include <SpaceLayoutItem.h>
+#include <TextControl.h>
+#include <Window.h>
+#include <View.h>
+
+#include <new>
+
+static const uint32 kMessageCancel = 'btcl';
+static const uint32 kMessageOk = 'btok';
+
+
+class WirelessConfigView : public BView {
+public:
+	WirelessConfigView()
+		:
+		BView("WirelessConfigView", B_WILL_DRAW),
+		fPassword(NULL)
+	{
+		SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));
+
+		BGroupLayout* rootLayout = new(std::nothrow) BGroupLayout(B_VERTICAL);
+		if (rootLayout == NULL)
+			return;
+
+		SetLayout(rootLayout);
+
+		BGridView* controls = new(std::nothrow) BGridView();
+		if (controls == NULL)
+			return;
+
+		BGridLayout* layout = controls->GridLayout();
+
+		float inset = ceilf(be_plain_font->Size() * 0.7);
+		rootLayout->SetInsets(inset, inset, inset, inset);
+		rootLayout->SetSpacing(inset);
+		layout->SetSpacing(inset, inset);
+
+		fNetworkName = new(std::nothrow) BTextControl("Network Name:", "",
+			NULL);
+		if (fNetworkName == NULL)
+			return;
+
+		layout->AddItem(fNetworkName->CreateLabelLayoutItem(), 0, 0);
+		layout->AddItem(fNetworkName->CreateTextViewLayoutItem(), 1, 0);
+
+		BPopUpMenu* authMenu = new(std::nothrow) BPopUpMenu("authMode");
+		if (authMenu == NULL)
+			return;
+
+		fAuthOpen = new(std::nothrow) BMenuItem("Open", NULL);
+		authMenu->AddItem(fAuthOpen);
+		fAuthWEP = new(std::nothrow) BMenuItem("WEP", NULL);
+		authMenu->AddItem(fAuthWEP);
+		fAuthWPA = new(std::nothrow) BMenuItem("WPA/WPA2", NULL);
+		authMenu->AddItem(fAuthWPA);
+
+		BMenuField* authMenuField = new(std::nothrow) BMenuField(
+			"Authentication:", authMenu);
+		if (authMenuField == NULL)
+			return;
+
+		layout->AddItem(authMenuField->CreateLabelLayoutItem(), 0, 1);
+		layout->AddItem(authMenuField->CreateMenuBarLayoutItem(), 1, 1);
+
+		fPassword = new(std::nothrow) BTextControl("Password:", "", NULL);
+		if (fPassword == NULL)
+			return;
+
+		BLayoutItem* layoutItem = fPassword->CreateTextViewLayoutItem();
+		layoutItem->SetExplicitMinSize(BSize(fPassword->StringWidth(
+				"0123456789012345678901234567890123456789") + inset,
+			B_SIZE_UNSET));
+
+		layout->AddItem(fPassword->CreateLabelLayoutItem(), 0, 2);
+		layout->AddItem(layoutItem, 1, 2);
+
+		BGroupView* buttons = new(std::nothrow) BGroupView(B_HORIZONTAL);
+		if (buttons == NULL)
+			return;
+
+		fCancelButton = new(std::nothrow) BButton("Cancel",
+			new BMessage(kMessageCancel));
+		buttons->GroupLayout()->AddView(fCancelButton);
+
+		buttons->GroupLayout()->AddItem(BSpaceLayoutItem::CreateGlue());
+
+		fOkButton = new(std::nothrow) BButton("OK", new BMessage(kMessageOk));
+		buttons->GroupLayout()->AddView(fOkButton);
+
+		rootLayout->AddView(controls);
+		rootLayout->AddView(buttons);
+	}
+
+	virtual void
+	AttachedToWindow()
+	{
+		fCancelButton->SetTarget(Window());
+		fOkButton->SetTarget(Window());
+	}
+
+	void
+	SetUp(BString& networkName, uint32 authMode, BString& password)
+	{
+		fNetworkName->SetText(networkName);
+
+		switch (authMode) {
+			default:
+			case B_NETWORK_AUTHENTICATION_NONE:
+				fAuthOpen->SetMarked(true);
+				break;
+			case B_NETWORK_AUTHENTICATION_WEP:
+				fAuthWEP->SetMarked(true);
+				break;
+			case B_NETWORK_AUTHENTICATION_WPA:
+			case B_NETWORK_AUTHENTICATION_WPA2:
+				fAuthWPA->SetMarked(true);
+				break;
+		}
+
+		fPassword->SetText(password);
+	}
+
+	void
+	Complete(BString& networkName, uint32& authMode, BString& password)
+	{
+		networkName = fNetworkName->Text();
+
+		authMode = B_NETWORK_AUTHENTICATION_NONE;
+		if (fAuthWEP->IsMarked())
+			authMode = B_NETWORK_AUTHENTICATION_WEP;
+		else if (fAuthWPA->IsMarked())
+			authMode = B_NETWORK_AUTHENTICATION_WPA;
+
+		password = fPassword->Text();
+	}
+
+private:
+	BTextControl* fNetworkName;
+	BMenuItem* fAuthOpen;
+	BMenuItem* fAuthWEP;
+	BMenuItem* fAuthWPA;
+	BTextControl* fPassword;
+	BButton* fCancelButton;
+	BButton* fOkButton;
+};
+
+
+class WirelessConfigWindow : public BWindow {
+public:
+	WirelessConfigWindow(BRect frame)
+		:
+		BWindow(BRect(50, 50, 269, 302), "Connect Wireless Network",
+			B_TITLED_WINDOW, B_NOT_RESIZABLE | B_ASYNCHRONOUS_CONTROLS
+				| B_NOT_ZOOMABLE | B_AUTO_UPDATE_SIZE_LIMITS),
+		fConfigView(NULL),
+		fDoneSem(-1),
+		fResult(B_ERROR)
+	{
+		fDoneSem = create_sem(0, "wireless config done");
+		if (fDoneSem < 0)
+			return;
+
+		BLayout* layout = new(std::nothrow) BGroupLayout(B_HORIZONTAL);
+		if (layout == NULL)
+			return;
+
+		SetLayout(layout);
+
+		fConfigView = new(std::nothrow) WirelessConfigView();
+		if (fConfigView == NULL)
+			return;
+
+		layout->AddView(fConfigView);
+	}
+
+	virtual
+	~WirelessConfigWindow()
+	{
+		if (fDoneSem >= 0)
+			delete_sem(fDoneSem);
+	}
+
+	virtual void
+	MessageReceived(BMessage* message)
+	{
+		switch (message->what) {
+			case kMessageCancel:
+			case kMessageOk:
+				fResult = message->what == kMessageCancel ? B_CANCELED : B_OK;
+				release_sem(fDoneSem);
+				return;
+		}
+
+		BWindow::MessageReceived(message);
+	}
+
+	status_t
+	WaitForDialog(BString& networkName, uint32& authMode, BString& password)
+	{
+		fConfigView->SetUp(networkName, authMode, password);
+
+		CenterOnScreen();
+		Show();
+
+		while (acquire_sem(fDoneSem) == B_INTERRUPTED);
+
+		status_t result = fResult;
+		fConfigView->Complete(networkName, authMode, password);
+
+		LockLooper();
+		Quit();
+		return result;
+	}
+
+private:
+	WirelessConfigView* fConfigView;
+	sem_id fDoneSem;
+	status_t fResult;
+};
+
+
+status_t
+wireless_config_dialog(BString& networkName, uint32& authMode,
+	BString& password)
+{
+	WirelessConfigWindow* configWindow
+		= new(std::nothrow) WirelessConfigWindow(BRect(100, 100, 200, 200));
+	if (configWindow == NULL)
+		return B_NO_MEMORY;
+
+	return configWindow->WaitForDialog(networkName, authMode, password);
+}
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/WirelessConfigDialog.h wpa_supplicant-0.7.3-haiku/wpa_supplicant/WirelessConfigDialog.h
--- wpa_supplicant-0.7.3/wpa_supplicant/WirelessConfigDialog.h	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/WirelessConfigDialog.h	2011-09-27 02:07:06.396099584 +0200
@@ -0,0 +1,2 @@
+status_t wireless_config_dialog(BString& networkName, uint32& authMode,
+	BString& password);
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/bss.c wpa_supplicant-0.7.3-haiku/wpa_supplicant/bss.c
--- wpa_supplicant-0.7.3/wpa_supplicant/bss.c	2010-09-07 17:43:39.017563648 +0200
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/bss.c	2011-07-02 18:17:31.991166464 +0200
@@ -147,7 +147,7 @@
 static int are_ies_equal(const struct wpa_bss *old,
 			 const struct wpa_scan_res *new, u32 ie)
 {
-	const u8 *old_ie, *new_ie;
+	const u8 *old_ie = NULL, *new_ie = NULL;
 	struct wpabuf *old_ie_buff = NULL;
 	struct wpabuf *new_ie_buff = NULL;
 	int new_ie_len, old_ie_len, ret, is_multi;
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/config.c wpa_supplicant-0.7.3-haiku/wpa_supplicant/config.c
--- wpa_supplicant-0.7.3/wpa_supplicant/config.c	2010-09-07 17:43:39.025690112 +0200
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/config.c	2011-09-27 19:01:24.422838272 +0200
@@ -1876,6 +1876,7 @@
 }
 
 
+#ifndef NO_CONFIG_WRITE
 /**
  * wpa_config_get_all - Get all options from network configuration
  * @ssid: Pointer to network configuration data
@@ -1935,7 +1936,6 @@
 }
 
 
-#ifndef NO_CONFIG_WRITE
 /**
  * wpa_config_get - Get a variable in network configuration
  * @ssid: Pointer to network configuration data
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/main_haiku.cpp wpa_supplicant-0.7.3-haiku/wpa_supplicant/main_haiku.cpp
--- wpa_supplicant-0.7.3/wpa_supplicant/main_haiku.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/main_haiku.cpp	2011-10-06 11:48:00.422051840 +0200
@@ -0,0 +1,750 @@
+/*
+ * WPA Supplicant / Haiku entrypoint
+ * Copyright (c) 2011, Michael Lotz <mmlr@mlotz.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#include <Application.h>
+#include <Locker.h>
+#include <MessageQueue.h>
+#include <MessageRunner.h>
+#include <NetworkDevice.h>
+#include <ObjectList.h>
+#include <String.h>
+
+#include <net_notifications.h>
+
+#include "WirelessConfigDialog.h"
+#include "WPASupplicant.h" // private header currently inside Haiku
+
+#include <new>
+
+extern "C" {
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "common/defs.h"
+
+#include "config.h"
+#include "notify.h"
+#include "notify_haiku.h"
+#include "wpa_supplicant_i.h"
+}
+
+extern "C" {
+#include <net/if_types.h>
+#include <net80211/ieee80211_ioctl.h>
+#include <sys/sockio.h>
+}
+
+
+static const uint32 kMsgJoinTimeout = 'jnto';
+
+
+typedef	bool (*StateChangeCallback)(const wpa_supplicant *interface,
+	BMessage *message, void *data);
+
+
+class StateChangeWatchingEntry {
+public:
+								StateChangeWatchingEntry(
+									const wpa_supplicant *interface,
+									StateChangeCallback callback,
+									void *data);
+
+		bool					Match(const wpa_supplicant *interface,
+									StateChangeCallback callback,
+									void *data);
+
+		bool					MessageReceived(
+									const wpa_supplicant *interface,
+									BMessage *message);
+
+private:
+		const wpa_supplicant *	fInterface;
+		StateChangeCallback		fCallback;
+		void *					fData;
+};
+
+
+StateChangeWatchingEntry::StateChangeWatchingEntry(
+	const wpa_supplicant *interface, StateChangeCallback callback, void *data)
+	:
+	fInterface(interface),
+	fCallback(callback),
+	fData(data)
+{
+}
+
+
+bool
+StateChangeWatchingEntry::Match(const wpa_supplicant *interface,
+	StateChangeCallback callback, void *data)
+{
+	return fInterface == interface && fCallback == callback && fData == data;
+}
+
+
+bool
+StateChangeWatchingEntry::MessageReceived(const wpa_supplicant *interface,
+	BMessage *message)
+{
+	if (interface != fInterface)
+		return false;
+
+	return fCallback(interface, message, fData);
+}
+
+
+class WPASupplicantApp : public BApplication {
+public:
+								WPASupplicantApp();
+virtual							~WPASupplicantApp();
+
+		status_t				InitCheck();
+
+virtual	void					ReadyToRun();
+virtual	void					MessageReceived(BMessage *message);
+
+		status_t				RunSupplicantInMainThread();
+
+private:
+static	int32					_SupplicantThread(void *data);
+static	void					_EventLoopProcessEvents(int sock,
+									void *eventLoopContext, void *data);
+
+		status_t				_EnqueueAndNotify(BMessage *message);
+		status_t				_NotifyEventLoop();
+
+		status_t				_JoinNetwork(BMessage *message);
+		status_t				_LeaveNetwork(BMessage *message);
+
+		status_t				_NotifyNetworkEvent(BMessage *message);
+
+static	bool					_InterfaceStateChangeCallback(
+									const wpa_supplicant *interface,
+									BMessage *message, void *data);
+
+		status_t				_StartWatchingInterfaceChanges(
+									const wpa_supplicant *interface,
+									StateChangeCallback callback, void *data);
+		status_t				_StopWatchingInterfaceChanges(
+									const wpa_supplicant *interface,
+									StateChangeCallback callback, void *data);
+		void					_NotifyInterfaceStateChanged(BMessage *message);
+
+		status_t				fInitStatus;
+		thread_id				fSupplicantThread;
+		BMessageQueue			fEventQueue;
+
+		int						fNotifySockets[2];
+
+		BObjectList<StateChangeWatchingEntry>
+								fWatchingEntryList;
+		BLocker					fWatchingEntryListLocker;
+
+		wpa_global *			fWPAGlobal;
+		wpa_params				fWPAParameters;
+};
+
+
+WPASupplicantApp::WPASupplicantApp()
+	:
+	BApplication(kWPASupplicantSignature),
+	fInitStatus(B_NO_INIT),
+	fSupplicantThread(-1),
+	fWPAGlobal(NULL)
+{
+	fNotifySockets[0] = fNotifySockets[1] = -1;
+
+	fInitStatus = BApplication::InitCheck();
+	if (fInitStatus != B_OK)
+		return;
+
+	memset(&fWPAParameters, 0, sizeof(fWPAParameters));
+	//fWPAParameters.wpa_debug_level = MSG_DEBUG;
+
+	fWPAGlobal = wpa_supplicant_init(&fWPAParameters);
+	if (fWPAGlobal == NULL) {
+		fInitStatus = B_ERROR;
+		return;
+	}
+
+	if (socketpair(AF_LOCAL, SOCK_STREAM, 0, fNotifySockets) != 0) {
+		fInitStatus = errno;
+		return;
+	}
+}
+
+
+WPASupplicantApp::~WPASupplicantApp()
+{
+	if (fWPAGlobal == NULL)
+		return;
+
+	wpa_supplicant_terminate_proc(fWPAGlobal);
+
+	// Wake the event loop up so it'll process the quit request and exit.
+	_NotifyEventLoop();
+
+	int32 result;
+	wait_for_thread(fSupplicantThread, &result);
+
+	wpa_supplicant_deinit(fWPAGlobal);
+
+	close(fNotifySockets[0]);
+	close(fNotifySockets[1]);
+}
+
+
+status_t
+WPASupplicantApp::InitCheck()
+{
+	return fInitStatus;
+}
+
+
+void
+WPASupplicantApp::ReadyToRun()
+{
+	fSupplicantThread = spawn_thread(_SupplicantThread,
+		"wpa_supplicant thread", B_NORMAL_PRIORITY, this);
+	if (fSupplicantThread < 0 || resume_thread(fSupplicantThread))
+		PostMessage(B_QUIT_REQUESTED);
+}
+
+
+void
+WPASupplicantApp::MessageReceived(BMessage *message)
+{
+	switch (message->what) {
+		case kMsgWPAJoinNetwork:
+		{
+			uint32 authMode = B_NETWORK_AUTHENTICATION_NONE;
+			status_t status = message->FindUInt32("authentication", &authMode);
+			if (status != B_OK || !message->HasString("name")
+				|| (authMode > B_NETWORK_AUTHENTICATION_NONE
+					&& !message->HasString("password"))) {
+
+				BString password = message->FindString("password");
+				BString networkName = message->FindString("name");
+
+				status = wireless_config_dialog(networkName, authMode,
+					password);
+				if (status != B_OK) {
+					BMessage reply;
+					reply.AddInt32("status", status);
+					message->SendReply(&reply);
+					return;
+				}
+
+				message->RemoveName("authentication");
+				message->AddUInt32("authentication", authMode);
+				message->RemoveName("password");
+				message->AddString("password", password);
+				message->RemoveName("name");
+				message->AddString("name", networkName);
+			}
+
+			_EnqueueAndNotify(DetachCurrentMessage());
+				// The event processing code will send the reply.
+			return;
+		}
+
+		case kMsgWPALeaveNetwork:
+		{
+			_EnqueueAndNotify(DetachCurrentMessage());
+				// The event processing code will send the reply.
+			return;
+		}
+
+		case B_NETWORK_MONITOR:
+		{
+			_EnqueueAndNotify(DetachCurrentMessage());
+			return;
+		}
+
+		case kMsgSupplicantStateChanged:
+		{
+			_NotifyInterfaceStateChanged(message);
+			return;
+		}
+
+		case kMsgJoinTimeout:
+		{
+			const wpa_supplicant *interface;
+			if (message->FindPointer("interface", (void **)&interface) != B_OK)
+				return;
+
+			StateChangeCallback callback;
+			if (message->FindPointer("callback", (void **)&callback) != B_OK)
+				return;
+
+			void *data;
+			if (message->FindPointer("data", (void **)&data) != B_OK)
+				return;
+
+			if (_StopWatchingInterfaceChanges(interface, callback, data)
+					== B_OK) {
+				// The watch entry was still there, so no reply has been sent
+				// yet. We do that now by calling the callback with the timeout
+				// message.
+				callback(interface, message, data);
+			}
+
+			return;
+		}
+	}
+
+	BApplication::MessageReceived(message);
+}
+
+
+int32
+WPASupplicantApp::_SupplicantThread(void *data)
+{
+	WPASupplicantApp *app = (WPASupplicantApp *)data;
+
+	// Register our notify socket with the polling event loop.
+	if (eloop_register_read_sock(app->fNotifySockets[0],
+			_EventLoopProcessEvents, app->fWPAGlobal, app) != 0) {
+		return B_ERROR;
+	}
+
+	wpa_supplicant_run(app->fWPAGlobal);
+
+	eloop_unregister_read_sock(app->fNotifySockets[0]);
+
+	// There are two reasons why the supplicant thread quit:
+	// 1.	The event loop was terminated because of a signal or error and the
+	//		application is still there and running.
+	// 2.	The app has quit and stopped the event loop.
+	//
+	// In case of 2. we're done, but in case of 1. we need to quit the still
+	// running application. We use the app messenger to reach the app if it is
+	// still running. If it already quit the SendMessage() will simply fail.
+
+	be_app_messenger.SendMessage(B_QUIT_REQUESTED);
+	return B_OK;
+}
+
+
+status_t
+WPASupplicantApp::_EnqueueAndNotify(BMessage *message)
+{
+	if (!fEventQueue.Lock())
+		return B_ERROR;
+
+	fEventQueue.AddMessage(message);
+	fEventQueue.Unlock();
+
+	return _NotifyEventLoop();
+}
+
+
+status_t
+WPASupplicantApp::_NotifyEventLoop()
+{
+	// This will interrupt the event loop and cause the message queue to be
+	// processed through the installed handler.
+	uint8 byte = 0;
+	ssize_t written = write(fNotifySockets[1], &byte, sizeof(byte));
+	if (written < 0)
+		return written;
+
+	return written == sizeof(byte) ? B_OK : B_ERROR;
+}
+
+
+void
+WPASupplicantApp::_EventLoopProcessEvents(int sock, void *eventLoopContext,
+	void *data)
+{
+	// This function is called from the event loop only.
+
+	WPASupplicantApp *app = (WPASupplicantApp *)data;
+
+	uint8 bytes[25];
+	read(app->fNotifySockets[0], bytes, sizeof(bytes));
+		// discard them, they are just here to wake the event loop
+
+	BMessageQueue &queue = app->fEventQueue;
+	if (!queue.Lock())
+		return;
+
+	while (true) {
+		BMessage *message = queue.FindMessage((int32)0);
+		if (message == NULL)
+			break;
+
+		queue.RemoveMessage(message);
+
+		bool needsReply = false;
+		bool deleteMessage = true;
+		status_t status = B_MESSAGE_NOT_UNDERSTOOD;
+		switch (message->what) {
+			case kMsgWPAJoinNetwork:
+				status = app->_JoinNetwork(message);
+				needsReply = status != B_OK;
+				deleteMessage = needsReply;
+				break;
+
+			case kMsgWPALeaveNetwork:
+				status = app->_LeaveNetwork(message);
+				needsReply = status != B_OK;
+				deleteMessage = needsReply;
+				break;
+
+			case B_NETWORK_MONITOR:
+				app->_NotifyNetworkEvent(message);
+				break;
+		}
+
+		if (needsReply) {
+			BMessage reply;
+			reply.AddInt32("status", status);
+			message->SendReply(&reply);
+		}
+
+		if (deleteMessage)
+			delete message;
+	}
+
+	queue.Unlock();
+}
+
+
+status_t
+WPASupplicantApp::_JoinNetwork(BMessage *message)
+{
+	const char *interfaceName = NULL;
+	status_t status = message->FindString("device", &interfaceName);
+	if (status != B_OK)
+		return status;
+
+	// Check if we already registered this interface.
+	wpa_supplicant *interface = wpa_supplicant_get_iface(fWPAGlobal,
+		interfaceName);
+	if (interface == NULL) {
+		wpa_interface interfaceOptions;
+		memset(&interfaceOptions, 0, sizeof(wpa_interface));
+
+		interfaceOptions.ifname = interfaceName;
+
+		interface = wpa_supplicant_add_iface(fWPAGlobal, &interfaceOptions);
+		if (interface == NULL)
+			return B_NO_MEMORY;
+	} else {
+		// Disable everything
+		wpa_supplicant_disable_network(interface, NULL);
+
+		// Try to remove any previous network
+		wpa_ssid *network = wpa_config_get_network(interface->conf, 0);
+		if (network != NULL) {
+			wpas_notify_network_removed(interface, network);
+			wpa_config_remove_network(interface->conf, network->id);
+		}		
+	}
+
+	const char *networkName = NULL;
+	status = message->FindString("name", &networkName);
+	if (status != B_OK)
+		return status;
+
+	uint32 authMode = B_NETWORK_AUTHENTICATION_NONE;
+	status = message->FindUInt32("authentication", &authMode);
+	if (status != B_OK)
+		return status;
+
+	const char *password = NULL;
+	if (authMode > B_NETWORK_AUTHENTICATION_NONE) {
+		status = message->FindString("password", &password);
+		if (status != B_OK)
+			return status;
+	}
+
+	wpa_ssid *network = wpa_config_add_network(interface->conf);
+	if (network == NULL)
+		return B_NO_MEMORY;
+
+	wpas_notify_network_added(interface, network);
+
+	network->disabled = 1;
+	wpa_config_set_network_defaults(network);
+
+	// Fill in the info from the join request
+
+	// The format includes the quotes
+	BString value;
+	value = "\"";
+	value += networkName;
+	value += "\"";
+	int result = wpa_config_set(network, "ssid", value.String(), 0);
+
+	if (result == 0)
+		result = wpa_config_set(network, "scan_ssid", "1", 1);
+
+	if (authMode >= B_NETWORK_AUTHENTICATION_WPA) {
+		if (result == 0)
+			result = wpa_config_set(network, "proto", "WPA RSN", 2);
+		if (result == 0)
+			result = wpa_config_set(network, "key_mgmt", "WPA-PSK", 3);
+		if (result == 0)
+			result = wpa_config_set(network, "pairwise", "CCMP TKIP NONE", 4);
+		if (result == 0) {
+			result = wpa_config_set(network, "group",
+				"CCMP TKIP WEP104 WEP40", 5);
+		}
+	} else {
+		// Open or WEP.
+		if (result == 0)
+			result = wpa_config_set(network, "key_mgmt", "NONE", 6);
+	}
+
+	if (result == 0) {
+		if (authMode == B_NETWORK_AUTHENTICATION_WEP) {
+			if (strncmp("0x", password, 2) == 0) {
+				// interpret as hex key
+				// TODO: make this non-ambiguous
+				result = wpa_config_set(network, "wep_key0", password + 2, 7);
+			} else {
+				value = "\"";
+				value += password;
+				value += "\"";
+				result = wpa_config_set(network, "wep_key0", value.String(), 8);
+			}
+
+			if (result == 0)
+				result = wpa_config_set(network, "wep_tx_keyidx", "0", 9);
+		} else if (authMode >= B_NETWORK_AUTHENTICATION_WPA) {
+			// WPA/WPA2
+			value = "\"";
+			value += password;
+			value += "\"";
+			result = wpa_config_set(network, "psk", value.String(), 10);
+
+			if (result == 0) {
+				// We need to actually "apply" the PSK
+				wpa_config_update_psk(network);
+			}
+		}
+	}
+
+	if (result != 0) {
+		wpas_notify_network_removed(interface, network);
+		wpa_config_remove_network(interface->conf, network->id);
+		return B_ERROR;
+	}
+
+	// Set up watching for the completion event
+	_StartWatchingInterfaceChanges(interface, _InterfaceStateChangeCallback,
+		message);
+
+	// Now attempt to connect
+	wpa_supplicant_select_network(interface, network);
+
+	// Use a message runner to return a timeout and stop watching after a while
+	BMessage timeout(kMsgJoinTimeout);
+	timeout.AddPointer("interface", interface);
+	timeout.AddPointer("callback", (void *)_InterfaceStateChangeCallback);
+	timeout.AddPointer("data", message);
+
+	BMessageRunner::StartSending(be_app_messenger, &timeout,
+		15 * 1000 * 1000, 1);
+
+	return B_OK;
+}
+
+
+status_t
+WPASupplicantApp::_LeaveNetwork(BMessage *message)
+{
+	const char *interfaceName = NULL;
+	status_t status = message->FindString("device", &interfaceName);
+	if (status != B_OK)
+		return status;
+
+	wpa_supplicant *interface = wpa_supplicant_get_iface(fWPAGlobal,
+		interfaceName);
+	if (interface == NULL)
+		return B_ENTRY_NOT_FOUND;
+
+	if (wpa_supplicant_remove_iface(fWPAGlobal, interface) != 0)
+		return B_ERROR;
+
+	return B_OK;
+}
+
+
+status_t
+WPASupplicantApp::_NotifyNetworkEvent(BMessage *message)
+{
+	// Verify that the interface is still there.
+	BString interfaceName;
+	if (message->FindString("interface", &interfaceName) != B_OK)
+		return B_ERROR;
+
+	interfaceName.Prepend("/dev/");
+	wpa_supplicant *interface = wpa_supplicant_get_iface(fWPAGlobal,
+		interfaceName.String());
+	if (interface == NULL)
+		return B_ENTRY_NOT_FOUND;
+
+	void (*callback)(void *context, void *data, int opcode) = NULL;
+	status_t result = message->FindPointer("callback", (void **)&callback);
+	if (result != B_OK)
+		return result;
+
+	void *context = NULL;
+	result = message->FindPointer("context", &context);
+	if (result != B_OK)
+		return result;
+
+	void *data = NULL;
+	message->FindPointer("data", &data);
+
+	callback(context, data, message->FindInt32("opcode"));
+	return B_OK;
+}
+
+
+bool
+WPASupplicantApp::_InterfaceStateChangeCallback(const wpa_supplicant *interface,
+	BMessage *message, void *data)
+{
+	// We wait for the completion state notification
+	// TODO: We should also use the disconnect as an error case when joining,
+	// but due to the event queue being serialized any disconnect happening
+	// due to a new connect attempt would trigger that state. Either we need
+	// to have the disconnect happen synchronously before joining again or
+	// we need a way to discern one disconnect from the other, for example if
+	// there was a way to tell from which network we disconnected.
+
+	BMessage *originalMessage = (BMessage *)data;
+
+	int32 newState;
+	status_t result = B_ERROR;
+	if (message->what == kMsgJoinTimeout)
+		result = B_TIMED_OUT;
+	else if (message->FindInt32("newState", &newState) == B_OK) {
+		switch (newState) {
+			case WPA_COMPLETED:
+			{
+				if (originalMessage->what != kMsgWPAJoinNetwork)
+					return false;
+
+				result = B_OK;
+				break;
+			}
+
+			case WPA_DISCONNECTED:
+			{
+				if (originalMessage->what != kMsgWPALeaveNetwork)
+					return false;
+
+				result = B_OK;
+				break;
+			}
+
+			default:
+				return false;
+		}
+	}
+
+	BMessage reply;
+	reply.AddInt32("status", result);
+	originalMessage->SendReply(&reply);
+	delete originalMessage;
+	return true;
+}
+
+
+status_t
+WPASupplicantApp::_StartWatchingInterfaceChanges(
+	const wpa_supplicant *interface, StateChangeCallback callback, void *data)
+{
+	StateChangeWatchingEntry *entry
+		= new(std::nothrow) StateChangeWatchingEntry(interface, callback, data);
+	if (entry == NULL)
+		return B_NO_MEMORY;
+
+	if (!fWatchingEntryListLocker.Lock()) {
+		delete entry;
+		return B_ERROR;
+	}
+
+	status_t result = B_OK;
+	if (!fWatchingEntryList.AddItem(entry)) {
+		result = B_ERROR;
+		delete entry;
+	}
+
+	fWatchingEntryListLocker.Unlock();
+	return result;
+}
+
+
+status_t
+WPASupplicantApp::_StopWatchingInterfaceChanges(
+	const wpa_supplicant *interface, StateChangeCallback callback, void *data)
+{
+	if (!fWatchingEntryListLocker.Lock())
+		return B_ERROR;
+
+	bool found = false;
+	for (int32 i = 0; i < fWatchingEntryList.CountItems(); i++) {
+		if (fWatchingEntryList.ItemAt(i)->Match(interface, callback, data)) {
+			delete fWatchingEntryList.RemoveItemAt(i);
+			found = true;
+			i--;
+		}
+	}
+
+	fWatchingEntryListLocker.Unlock();
+	return found ? B_OK : B_ENTRY_NOT_FOUND;
+}
+
+
+void
+WPASupplicantApp::_NotifyInterfaceStateChanged(BMessage *message)
+{
+	const wpa_supplicant *interface;
+	if (message->FindPointer("interface", (void **)&interface) != B_OK)
+		return;
+
+	if (!fWatchingEntryListLocker.Lock())
+		return;
+
+	for (int32 i = 0; i < fWatchingEntryList.CountItems(); i++) {
+		StateChangeWatchingEntry *entry = fWatchingEntryList.ItemAt(i);
+		if (entry->MessageReceived(interface, message)) {
+			delete fWatchingEntryList.RemoveItemAt(i);
+			i--;
+		}
+	}
+
+	fWatchingEntryListLocker.Unlock();
+}
+
+
+int
+main(int argc, char *argv[])
+{
+	WPASupplicantApp *app = new(std::nothrow) WPASupplicantApp();
+	if (app == NULL)
+		return B_NO_MEMORY;
+	if (app->InitCheck() != B_OK)
+		return app->InitCheck();
+
+	app->Run();
+	delete app;
+	return 0;
+}
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/notify.c wpa_supplicant-0.7.3-haiku/wpa_supplicant/notify.c
--- wpa_supplicant-0.7.3/wpa_supplicant/notify.c	2010-09-07 17:43:39.032768000 +0200
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/notify.c	2011-10-05 21:46:35.427032576 +0200
@@ -26,6 +26,10 @@
 #include "scan.h"
 #include "notify.h"
 
+#ifdef __HAIKU__
+#include "notify_haiku.h"
+#endif
+
 int wpas_notify_supplicant_initialized(struct wpa_global *global)
 {
 #ifdef CONFIG_DBUS
@@ -81,6 +85,10 @@
 
 	/* notify the new DBus API */
 	wpas_dbus_signal_prop_changed(wpa_s, WPAS_DBUS_PROP_STATE);
+
+#ifdef __HAIKU__
+	wpa_supplicant_haiku_notify_state_change(wpa_s, new_state, old_state);
+#endif
 }
 
 
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/notify_haiku.cpp wpa_supplicant-0.7.3-haiku/wpa_supplicant/notify_haiku.cpp
--- wpa_supplicant-0.7.3/wpa_supplicant/notify_haiku.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/notify_haiku.cpp	2011-10-06 00:35:25.644874240 +0200
@@ -0,0 +1,37 @@
+/*
+ * WPA Supplicant / Haiku notification functions
+ * Copyright (c) 2011, Michael Lotz <mmlr@mlotz.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+extern "C" {
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "common/defs.h"
+#include "config.h"
+
+#include "notify_haiku.h"
+}
+
+#include <Application.h>
+#include <Message.h>
+
+
+void
+wpa_supplicant_haiku_notify_state_change(struct wpa_supplicant *wpa_s,
+	enum wpa_states new_state, enum wpa_states old_state)
+{
+	BMessage message(kMsgSupplicantStateChanged);
+	message.AddPointer("interface", wpa_s);
+	message.AddInt32("oldState", old_state);
+	message.AddInt32("newState", new_state);
+	be_app->PostMessage(&message);
+}
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/notify_haiku.h wpa_supplicant-0.7.3-haiku/wpa_supplicant/notify_haiku.h
--- wpa_supplicant-0.7.3/wpa_supplicant/notify_haiku.h	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/notify_haiku.h	2011-10-06 00:43:14.880541696 +0200
@@ -0,0 +1,26 @@
+/*
+ * WPA Supplicant / Haiku notification functions
+ * Copyright (c) 2011, Michael Lotz <mmlr@mlotz.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#ifndef NOTIFY_HAIKU_H
+#define NOTIFY_HAIKU_H
+
+static const uint32_t kMsgSupplicantStateChanged = 'stch';
+
+struct wpa_supplicant;
+enum wpa_states;
+
+void wpa_supplicant_haiku_notify_state_change(struct wpa_supplicant *wpa_s,
+	enum wpa_states new_state, enum wpa_states old_state);
+
+#endif
diff -urN wpa_supplicant-0.7.3/wpa_supplicant/wpa_supplicant.rdef wpa_supplicant-0.7.3-haiku/wpa_supplicant/wpa_supplicant.rdef
--- wpa_supplicant-0.7.3/wpa_supplicant/wpa_supplicant.rdef	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.7.3-haiku/wpa_supplicant/wpa_supplicant.rdef	2011-07-02 23:08:16.688652288 +0200
@@ -0,0 +1,15 @@
+resource app_signature "application/x-vnd.malinen-wpa_supplicant";
+
+resource app_flags B_EXCLUSIVE_LAUNCH | B_BACKGROUND_APP;
+
+resource app_version {
+	major  = 0,
+	middle = 7,
+	minor  = 3,
+
+	variety = B_APPV_DEVELOPMENT,
+	internal = 0,
+
+	short_info = "wpa_supplicant",
+	long_info = "wpa_supplicant Â© 2003-2010, Jouni Malinen <j@w1.fi>"
+};
