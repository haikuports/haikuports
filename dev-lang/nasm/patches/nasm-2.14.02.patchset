From 4f2b8256a735d00ef50d76abeb56b772d8f3b2ed Mon Sep 17 00:00:00 2001
From: trungnt2910 <trungnt282910@gmail.com>
Date: Wed, 22 Jan 2020 19:42:41 +0700
Subject: Fixed source code to build on gcc 7.3

There have been major changes in nasm's headers since version 2.3
This fixes code in some headers so that it builds on Haiku's gcc
while preserving its portability.

diff --git a/asm/directiv.h b/asm/directiv.h
index 20a6424..8c907be 100644
--- a/asm/directiv.h
+++ b/asm/directiv.h
@@ -55,6 +55,10 @@ enum directive {
 extern const struct perfect_hash directive_hash;
 extern const char * const directive_tbl[38];
 
+#ifdef __HAIKU__
+const char * invalid_enum_str(int);
+#endif
+
 static inline enum directive directive_find(const char *str)
 {
     return perfhash_find(&directive_hash, str);
diff --git a/include/nasm.h b/include/nasm.h
index 020e363..e7e32cd 100644
--- a/include/nasm.h
+++ b/include/nasm.h
@@ -575,6 +575,14 @@ enum eval_hint { /* values for `hinttype' */
     EAH_SUMMED   = 3        /* base and index are summed into index */
 };
 
+#ifdef __HAIKU__
+/* 
+ * Declarations from header that the compiler
+ * fails to recognize on Haiku
+ */
+typedef uint16_t  decoflags_t;
+#endif
+
 typedef struct operand { /* operand to an instruction */
     opflags_t       type;       /* type of operand */
     int             disp_size;  /* 0 means default; 16; 32; 64 */
@@ -745,10 +753,16 @@ struct pragma_facility {
  */
 struct pragma {
     const struct pragma_facility *facility;
-    const char *facility_name;  /* Facility name exactly as entered by user */
-    const char *opname;         /* First word after the facility name */
-    const char *tail;           /* Anything after the operation */
-    enum directive opcode;     /* Operation as a D_ directives constant */
+    const char *facility_name;	/* Facility name exactly as entered by user */
+    const char *opname;			/* First word after the facility name */
+    const char *tail;			/* Anything after the operation */
+    #ifndef __HAIKU__
+    enum directive opcode;		/* Operation as a D_ directives constant */
+    #else
+    int opcode					/* 	gcc on Haiku fails to recognize directive
+    							 *	while redeclaring it produce type conflicts
+    							 */
+    #endif
 };
 
 /*
diff --git a/include/nasmlib.h b/include/nasmlib.h
index e57d0e6..2de867e 100644
--- a/include/nasmlib.h
+++ b/include/nasmlib.h
@@ -47,6 +47,9 @@
 #ifdef HAVE_STRINGS_H
 # include <strings.h>
 #endif
+#ifdef __HAIKU__
+#include <stdbool.h>
+#endif
 
 /*
  * tolower table -- avoids a function call on some platforms.
@@ -72,6 +75,21 @@ extern unsigned char nasm_tolower_tab[256];
  * passed a NULL pointer; nasm_free will do nothing if it is passed
  * a NULL pointer.
  */
+#ifdef __HAIKU__
+/*
+ * gcc on Haiku fails to resolve safe_alloc and all other macros,
+   but still supports __ATTRIBUTE__.
+ */
+void * __attribute__((returns_nonnull)) __attribute__((malloc)) __attribute__((alloc_size(1))) nasm_malloc(size_t);
+void * __attribute__((returns_nonnull)) __attribute__((malloc)) __attribute__((alloc_size(1))) nasm_zalloc(size_t);
+void * __attribute__((returns_nonnull)) __attribute__((malloc)) __attribute__((alloc_size(1,2))) nasm_calloc(size_t, size_t);
+void * __attribute__((returns_nonnull)) __attribute__((alloc_size(2))) nasm_realloc(void *, size_t);
+void nasm_free(void *);
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) nasm_strdup(const char *);
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) nasm_strndup(const char *, size_t);
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) nasm_strcat(const char *one, const char *two);
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) __attribute__((sentinel)) nasm_strcatn(const char *one, ...);
+#else
 void * safe_malloc(1) nasm_malloc(size_t);
 void * safe_malloc(1) nasm_zalloc(size_t);
 void * safe_malloc2(1,2) nasm_calloc(size_t, size_t);
@@ -81,6 +99,7 @@ char * safe_alloc nasm_strdup(const char *);
 char * safe_alloc nasm_strndup(const char *, size_t);
 char * safe_alloc nasm_strcat(const char *one, const char *two);
 char * safe_alloc end_with_null nasm_strcatn(const char *one, ...);
+#endif
 
 /* Assert the argument is a pointer without evaluating it */
 #define nasm_assert_pointer(p) ((void)sizeof(*(p)))
@@ -113,7 +132,12 @@ void nasm_write(const void *, size_t, FILE *);
 /*
  * NASM assert failure
  */
+#ifdef __HAIKU__
+#include <stdnoreturn.h>
+noreturn void __attribute__((cold)) nasm_assert_failed(const char *, int, const char *);
+#else
 fatal_func nasm_assert_failed(const char *, int, const char *);
+#endif
 #define nasm_assert(x)                                          \
     do {                                                        \
         if (unlikely(!(x)))                                     \
@@ -150,18 +174,30 @@ const char *invalid_enum_str(int);
 #elif defined(HAVE_STRICMP)
 #define nasm_stricmp stricmp
 #else
+#ifdef __HAIKU__
+int __attribute__((pure)) nasm_stricmp(const char *, const char *);
+#else
 int pure_func nasm_stricmp(const char *, const char *);
 #endif
+#endif
 
 #if defined(HAVE_STRNCASECMP)
 #define nasm_strnicmp strncasecmp
 #elif defined(HAVE_STRNICMP)
 #define nasm_strnicmp strnicmp
 #else
+#ifdef __HAIKU__
+int __attribute__((pure)) nasm_strnicmp(const char *, const char *, size_t);
+#else
 int pure_func nasm_strnicmp(const char *, const char *, size_t);
 #endif
+#endif
 
+#ifdef __HAIKU__
+int __attribute__((pure)) nasm_memicmp(const char *, const char *, size_t);
+#else
 int pure_func nasm_memicmp(const char *, const char *, size_t);
+#endif
 
 #if defined(HAVE_STRSEP)
 #define nasm_strsep strsep
@@ -292,6 +328,7 @@ char *nasm_trim_spaces(char *p);
 char *nasm_get_word(char *p, char **tail);
 char *nasm_opt_val(char *p, char **opt, char **val);
 
+#ifndef __HAIKU__
 /*
  * Converts a relative pathname rel_path into an absolute path name.
  *
@@ -305,8 +342,22 @@ char * safe_alloc nasm_realpath(const char *rel_path);
 char * safe_alloc nasm_dirname(const char *path);
 char * safe_alloc nasm_basename(const char *path);
 char * safe_alloc nasm_catfile(const char *dir, const char *path);
+#else
+/*
+ * Haiku-specific prototypes
+ */
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) nasm_realpath(const char *rel_path);
+
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) nasm_dirname(const char *path);
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) nasm_basename(const char *path);
+char * __attribute__((returns_nonnull)) __attribute__((malloc)) nasm_catfile(const char *dir, const char *path);
+#endif
 
+#ifdef __HAIKU__
+const char * __attribute__((pure)) prefix_name(int);
+#else
 const char * pure_func prefix_name(int);
+#endif
 
 /*
  * Wrappers around fopen()... for future change to a dedicated structure
@@ -353,7 +404,11 @@ off_t nasm_file_size_by_path(const char *pathname);
 bool nasm_file_time(time_t *t, const char *pathname);
 void fwritezero(off_t bytes, FILE *fp);
 
+#ifdef __HAIKU__
+static inline bool __attribute__((const)) overflow_general(int64_t value, int bytes)
+#else
 static inline bool const_func overflow_general(int64_t value, int bytes)
+#endif
 {
     int sbit;
     int64_t vmax, vmin;
@@ -368,7 +423,11 @@ static inline bool const_func overflow_general(int64_t value, int bytes)
     return value < vmin || value > vmax;
 }
 
+#ifdef __HAIKU__
+static inline bool __attribute__((const)) overflow_signed(int64_t value, int bytes)
+#else
 static inline bool const_func overflow_signed(int64_t value, int bytes)
+#endif
 {
     int sbit;
     int64_t vmax, vmin;
@@ -382,8 +441,11 @@ static inline bool const_func overflow_signed(int64_t value, int bytes)
 
     return value < vmin || value > vmax;
 }
-
+#ifdef __HAIKU__
+static inline bool __attribute__((const)) overflow_unsigned(int64_t value, int bytes)
+#else
 static inline bool const_func overflow_unsigned(int64_t value, int bytes)
+#endif
 {
     int sbit;
     int64_t vmax, vmin;
@@ -398,7 +460,11 @@ static inline bool const_func overflow_unsigned(int64_t value, int bytes)
     return value < vmin || value > vmax;
 }
 
+#ifdef __HAIKU__
+static inline int64_t __attribute__((const)) signed_bits(int64_t value, int bits)
+#else
 static inline int64_t const_func signed_bits(int64_t value, int bits)
+#endif
 {
     if (bits < 64) {
         value &= ((int64_t)1 << bits) - 1;
diff --git a/include/opflags.h b/include/opflags.h
index 28bb236..b80c9b0 100644
--- a/include/opflags.h
+++ b/include/opflags.h
@@ -177,6 +177,15 @@
 #define REG_CLASS_OPMASK        GEN_REG_CLASS(8)
 #define REG_CLASS_BND           GEN_REG_CLASS(9)
 
+#ifdef __HAIKU__
+/* 
+ * Declarations from header that the compiler
+ * fails to recognize on Haiku
+ */
+typedef uint64_t opflags_t;
+extern const opflags_t nasm_reg_flags[];
+#endif
+
 static inline bool is_class(opflags_t class, opflags_t op)
 {
 	return !(class & ~op);
diff --git a/include/strlist.h b/include/strlist.h
index e00fc1f..5e88d4c 100644
--- a/include/strlist.h
+++ b/include/strlist.h
@@ -44,6 +44,10 @@
 
 #include "nasmlib.h"
 
+#ifdef __HAIKU__
+#include <stdbool.h>
+#endif
+
 typedef struct string_list {
     struct string_list  *next;
     char                str[1];
-- 
2.19.0

