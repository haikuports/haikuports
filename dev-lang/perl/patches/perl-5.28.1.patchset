From 3db6700b9b3faaa2b0afaba91e53383929653ecb Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sun, 22 Sep 2013 14:52:03 +0200
Subject: Tell perl that BFS has a link count of 1


diff --git a/cpan/File-Temp/lib/File/Temp.pm b/cpan/File-Temp/lib/File/Temp.pm
index 817c6d9..c3298a6 100644
--- a/cpan/File-Temp/lib/File/Temp.pm
+++ b/cpan/File-Temp/lib/File/Temp.pm
@@ -1425,7 +1425,8 @@ sub unlink0 {
     # On NFS the link count may still be 1 but we can't know that
     # we are on NFS.  Since we can't be sure, we'll defer it
 
-    return 1 if $fh[3] == 0 || $^O eq 'cygwin';
+    # On haiku, the link count seems to be always 1 (at least for BFS)
+    return 1 if $fh[3] == 0 || $^O eq 'cygwin' || $^O eq 'haiku';
   }
   # fall-through if we can't unlink now
   _deferred_unlink($fh, $path, 0);
-- 
2.21.0


From 4eabb29aee8c3a2d888e70123e554a5f28dd2f85 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sun, 22 Sep 2013 14:52:53 +0200
Subject: Haiku defines, but does not implement O_EXLOCK


diff --git a/cpan/File-Temp/t/lock.t b/cpan/File-Temp/t/lock.t
index ff8c7f9..4364bf6 100644
--- a/cpan/File-Temp/t/lock.t
+++ b/cpan/File-Temp/t/lock.t
@@ -8,7 +8,8 @@ use Fcntl;
 BEGIN {
 # see if we have O_EXLOCK
   eval { &Fcntl::O_EXLOCK; };
-  if ($@) {
+  if ($@  || $^O eq 'haiku') {
+    # haiku doesn't implement O_EXLOCK yet (but it defines the value)
     plan skip_all => 'Do not seem to have O_EXLOCK';
   } else {
     plan tests => 4;
-- 
2.21.0


From bac2c3f2d94428de753f69c061882830dbc347a2 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sun, 22 Sep 2013 14:53:40 +0200
Subject: haiku sets all its specifics via Configure


diff --git a/hints/haiku.sh b/hints/haiku.sh
index fa8ebe5..0f09f53 100644
--- a/hints/haiku.sh
+++ b/hints/haiku.sh
@@ -1,44 +1 @@
-# Haiku hints file
-# $Id$
-
-case "$prefix" in
-'') prefix="/boot/common" ;;
-*) ;; # pass the user supplied value through
-esac
-
-libpth='/boot/home/config/lib /boot/common/lib /system/lib'
-usrinc='/boot/develop/headers/posix'
-locinc='/boot/home/config/include /boot/common/include /boot/develop/headers'
-
-libc='/system/lib/libroot.so'
-libs='-lnetwork'
-
-# Use Haiku's malloc() by default.
-case "$usemymalloc" in
-'') usemymalloc='n' ;;
-esac
-
-# Haiku generally supports hard links, but the default file system (BFS)
-# doesn't. So better avoid using hard links.
-d_link='undef'
-dont_use_nlink='define'
-
-# The array syserrlst[] is useless for the most part.
-# Large negative numbers really kind of suck in arrays.
-d_syserrlst='undef'
-
-# Haiku uses gcc.
-cc="gcc"
-ld='gcc'
-
-# The runtime loader library path variable is LIBRARY_PATH.
-case "$ldlibpthname" in
-'') ldlibpthname=LIBRARY_PATH ;;
-esac
-
-# as of alpha 4.1 (at the latest) some symbols are versioned,
-# confusing the nm lookup
-case "$usenm" in
-'') usenm='undef' ;;
-esac
-
+# haiku sets all its specifics via Configure
-- 
2.21.0


From ca22cd63f9ca9539a7093e74bc78204f13f3c6e2 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sun, 22 Sep 2013 14:54:15 +0200
Subject: Tell perl that Haiku needs haikuish.h installed as well


diff --git a/installperl b/installperl
index 3bf79d2..5cb6b3f 100755
--- a/installperl
+++ b/installperl
@@ -381,6 +381,11 @@ elsif ($Is_Cygwin) { # On Cygwin symlink it to CORE to make Makefile happy
 
     # AIX needs perl.exp installed as well.
     push(@corefiles,'perl.exp') if $^O eq 'aix';
+    if ($^O eq 'haiku') {
+	# Haiku needs haikuish.h installed as well.
+	mkpath("$installarchlib/CORE/haiku", $opts{verbose}, 0777);
+	push(@corefiles,'haiku/haikuish.h');
+    }
 }
 
 
-- 
2.21.0


From 84218cf7e177c3c172016daa255956e4a200d71f Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sun, 22 Sep 2013 14:55:13 +0200
Subject: Fix handling of exit codes on Haiku


diff --git a/t/run/exit.t b/t/run/exit.t
index ce3270e..cab9a79 100644
--- a/t/run/exit.t
+++ b/t/run/exit.t
@@ -55,18 +55,18 @@ is( ${^CHILD_ERROR_NATIVE}, $native_success,  'Normal exit ${^CHILD_ERROR_NATIVE
 if (!$vms_exit_mode) {
   my $posix_ok = eval { require POSIX; };
   my $wait_macros_ok = defined &POSIX::WIFEXITED;
-  eval { POSIX::WIFEXITED(${^CHILD_ERROR_NATIVE}) };
+  eval { POSIX::WIFEXITED($?) };
   $wait_macros_ok = 0 if $@;
   $exit = run('exit 42');
   is( $exit >> 8, 42,             'Non-zero exit' );
   is( $exit, $?,                  'Non-zero exit $?' );
-  isnt( !${^CHILD_ERROR_NATIVE}, 0, 'Non-zero exit ${^CHILD_ERROR_NATIVE}' );
+  isnt( ${^CHILD_ERROR_NATIVE}, 0, 'Non-zero exit ${^CHILD_ERROR_NATIVE}' );
   SKIP: {
     skip("No POSIX", 3) unless $posix_ok;
     skip("No POSIX wait macros", 3) unless $wait_macros_ok;
-    ok(POSIX::WIFEXITED(${^CHILD_ERROR_NATIVE}), "WIFEXITED");
-    ok(!POSIX::WIFSIGNALED(${^CHILD_ERROR_NATIVE}), "WIFSIGNALED");
-    is(POSIX::WEXITSTATUS(${^CHILD_ERROR_NATIVE}), 42, "WEXITSTATUS");
+    ok(POSIX::WIFEXITED($?), "WIFEXITED");
+    ok(!POSIX::WIFSIGNALED($?), "WIFSIGNALED");
+    is(POSIX::WEXITSTATUS($?), 42, "WEXITSTATUS");
   }
 
   SKIP: {
@@ -85,9 +85,9 @@ if (!$vms_exit_mode) {
     SKIP: {
       skip("No POSIX", 3) unless $posix_ok;
       skip("No POSIX wait macros", 3) unless $wait_macros_ok;
-      ok(!POSIX::WIFEXITED(${^CHILD_ERROR_NATIVE}), "WIFEXITED");
-      ok(POSIX::WIFSIGNALED(${^CHILD_ERROR_NATIVE}), "WIFSIGNALED");
-      is(POSIX::WTERMSIG(${^CHILD_ERROR_NATIVE}), 15, "WTERMSIG");
+      ok(!POSIX::WIFEXITED($?), "WIFEXITED");
+      ok(POSIX::WIFSIGNALED($?), "WIFSIGNALED");
+      is(POSIX::WTERMSIG($?), 15, "WTERMSIG");
     }
   }
 
-- 
2.21.0


From b935e9ef50b380b18511c12f3496e4f35a1bd460 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sun, 22 Sep 2013 15:00:44 +0200
Subject: Fix include path of errno.h


diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
index d565f31..f0ee43b 100644
--- a/ext/Errno/Errno_pm.PL
+++ b/ext/Errno/Errno_pm.PL
@@ -139,7 +139,7 @@ sub get_files {
 	$file{$linux_errno_h} = 1;
     } elsif ($^O eq 'haiku') {
 	# hidden in a special place
-	$file{'/boot/develop/headers/posix/errno.h'} = 1;
+	$file{'/boot/system/develop/headers/posix/errno.h'} = 1;
 
     } elsif ($^O eq 'vos') {
 	# avoid problem where cpp returns non-POSIX pathnames
-- 
2.21.0


From 519a5e068966c7d04c8796d6e73d8c5d5ae01a9d Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sat, 28 Sep 2013 13:46:42 +0200
Subject: Adjust ExtUtils::MakeMaker for PM-Haiku.

* MakeMaker-projects trying to install into 'site-perl' while specifying
  PREFIX would end up using a wrong 'site-perl' prefix.
* Split MM_Haiku.pm off MM_BeOS.pm, implementing Haiku-specific overrides
  for MakeMaker.

diff --git a/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM.pm b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM.pm
index b2c360b..c91c3c8 100644
--- a/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM.pm
+++ b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM.pm
@@ -60,7 +60,8 @@ if( $^O eq 'MSWin32' ) {
 $Is{UWIN}   = $^O =~ /^uwin(-nt)?$/;
 $Is{Cygwin} = $^O eq 'cygwin';
 $Is{NW5}    = $Config{osname} eq 'NetWare';  # intentional
-$Is{BeOS}   = ($^O =~ /beos/i or $^O eq 'haiku');
+$Is{BeOS}   = $^O =~ /beos/i;
+$Is{Haiku}  = $^O eq 'haiku';
 $Is{DOS}    = $^O eq 'dos';
 if( $Is{NW5} ) {
     $^O = 'NetWare';
diff --git a/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
new file mode 100644
index 0000000..81e5f99
--- /dev/null
+++ b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
@@ -0,0 +1,70 @@
+package ExtUtils::MM_Haiku;
+
+use strict;
+
+=head1 NAME
+
+ExtUtils::MM_Haiku - methods to override UN*X behaviour in ExtUtils::MakeMaker
+
+=head1 SYNOPSIS
+
+ use ExtUtils::MM_Haiku;	# Done internally by ExtUtils::MakeMaker if needed
+
+=head1 DESCRIPTION
+
+See ExtUtils::MM_Unix for a documentation of the methods provided
+there. This package overrides the implementation of these methods, not
+the semantics.
+
+=over 4
+
+=cut
+
+use ExtUtils::MakeMaker::Config;
+use File::Spec;
+require ExtUtils::MM_Any;
+require ExtUtils::MM_Unix;
+
+our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
+our $VERSION = '6.66';
+
+
+=item os_flavor
+
+Haiku is Haiku.
+
+=cut
+
+sub os_flavor {
+    return('Haiku');
+}
+
+=head3 init_INSTALL_from_PREFIX
+
+  $mm->init_INSTALL_from_PREFIX;
+
+=cut
+
+sub init_INSTALL_from_PREFIX {
+    my $self = shift;
+
+	# If a prefix has been given from outside, the default implementation
+	# will set PERLPREFIX, SITEPREFIX and VENDORPREFIX to identical values,
+	# but due to the way how Haiku's package management works, PERLPREFIX
+	# and VENDORPREFIX are not writable at all (as they're being populated
+	# from installed packages via package-fs). SITEPREFIX, however needs to
+	# be set to a path which can be written to (since site packages are
+	# expected to be installed "manually") - so we make sure it points
+	# to a 'non-packaged'-folder:
+    my $prefixGiven = $self->{PREFIX};
+	$self->SUPER::init_INSTALL_from_PREFIX();
+	if ($prefixGiven) {
+        $self->{SITEPREFIX} = '$(PREFIX)/non-packaged';
+    } 
+}
+
+=back
+
+1;
+__END__
+
-- 
2.21.0


From 014cd8b9ff8639d212e1f29dec307f58cd5d0e83 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Tue, 8 Oct 2013 22:16:37 +0200
Subject: Avoid using -rpath for dynamic modules.


diff --git a/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
index 81e5f99..25ace13 100644
--- a/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
+++ b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
@@ -65,6 +65,33 @@ sub init_INSTALL_from_PREFIX {
 
 =back
 
+=head3 init_others
+
+    $MM->init_others();
+
+Initializes the macro definitions having to do with compiling and
+linking used by tools_other() and places them in the $MM object.
+
+If there is no description, its the same as the parameter to
+WriteMakefile() documented in ExtUtils::MakeMaker.
+
+=cut
+
+sub init_others {
+    my $self = shift;
+
+	$self->SUPER::init_others();
+
+	# Don't use run-time paths for libraries required by dynamic
+	# modules on Haiku, as that wouldn't work should a library be moved
+	# (for instance because the package has been activated somewhere else).
+    $self->{LD_RUN_PATH} = "";
+
+    return;
+}
+
+=back
+
 1;
 __END__
 
-- 
2.21.0


From 9b18cb650121876c6a7087fb2c0fcc7a958ce537 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Tue, 8 Oct 2013 22:17:26 +0200
Subject: Add script sitecustomize.pl for setting up @INC as we need it.


diff --git a/sitecustomize.pl b/sitecustomize.pl
new file mode 100644
index 0000000..a321e51
--- /dev/null
+++ b/sitecustomize.pl
@@ -0,0 +1,36 @@
+#! perl
+
+use Config;
+
+# Remove all compiled-in paths referring to Perl's installation dir
+# and replace them with a static set of paths that implement the intended
+# searching order:
+my @ourINC = (
+	"/boot/home/config/lib/perl5/$Config{version}/$Config{archname}",
+	"/boot/home/config/lib/perl5/$Config{version}",
+	"/boot/home/config/non-packaged/lib/perl5/site_perl/$Config{version}/$Config{archname}",
+	"/boot/home/config/non-packaged/lib/perl5/site_perl/$Config{version}",
+	"/boot/home/config/lib/perl5/vendor_perl/$Config{version}/$Config{archname}",
+	"/boot/home/config/lib/perl5/vendor_perl/$Config{version}",
+	"/boot/home/config/lib/perl5/vendor_perl",
+	"/boot/system/lib/perl5/$Config{version}/$Config{archname}",
+	"/boot/system/lib/perl5/$Config{version}",
+	"/boot/system/non-packaged/lib/perl5/site_perl/$Config{version}/$Config{archname}",
+	"/boot/system/non-packaged/lib/perl5/site_perl/$Config{version}",
+	"/boot/system/lib/perl5/vendor_perl/$Config{version}/$Config{archname}",
+	"/boot/system/lib/perl5/vendor_perl/$Config{version}",
+	"/boot/system/lib/perl5/vendor_perl",
+);
+my @newINC;
+my $removedPerlPaths;
+foreach my $inc (@INC) {
+	if ($inc =~ m[^/packages/perl-$Config{version}-\d+/.self/]o) {
+		if (! $removedPerlPaths) {
+			push @newINC, @ourINC;
+			$removedPerlPaths = 1;
+		}
+		next;
+	}
+	push @newINC, $inc;
+}
+@INC = @newINC;
-- 
2.21.0


From 3764128c11b9d4327d08c99e714d4226dc8d96e0 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Wed, 9 Oct 2013 20:29:38 +0200
Subject: Fix initialization check for CPAN.

* On Haiku, only the site-lib directories will ever be writable,
  as the others read-only. This avoids CPAN asking for a way to
  circumvent unwritable lib dirs.

diff --git a/cpan/CPAN/lib/CPAN/FirstTime.pm b/cpan/CPAN/lib/CPAN/FirstTime.pm
index 49fa8ab..bc701d8 100644
--- a/cpan/CPAN/lib/CPAN/FirstTime.pm
+++ b/cpan/CPAN/lib/CPAN/FirstTime.pm
@@ -2068,6 +2068,12 @@ sub _print_urllist {
 }
 
 sub _can_write_to_libdirs {
+    if ($^O eq 'haiku') {
+    	# on Haiku, the other dirs are never writable, as they are
+    	# being populated by packagefs
+        return -w $Config{installsitelib}
+            && -w $Config{installsitearch}
+    }
     return -w $Config{installprivlib}
         && -w $Config{installarchlib}
         && -w $Config{installsitelib}
-- 
2.21.0


From a64e11a378dd9adcdba97af967f94306e8ebd763 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Sun, 13 Oct 2013 17:32:50 +0200
Subject: Add support for HAIKU_USE_VENDOR_DIRECTORIES.

* Adjust MakeMaker to automatically switch to vendor directories if
  requested via HAIKU_USE_VENDOR_DIRECTORIES.

diff --git a/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
index 25ace13..8a04ead 100644
--- a/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
+++ b/cpan/ExtUtils-MakeMaker/lib/ExtUtils/MM_Haiku.pm
@@ -29,21 +29,20 @@ our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
 our $VERSION = '6.66';
 
 
-=item os_flavor
-
-Haiku is Haiku.
-
-=cut
-
 sub os_flavor {
     return('Haiku');
 }
 
-=head3 init_INSTALL_from_PREFIX
+sub init_main {
+    my $self = shift;
 
-  $mm->init_INSTALL_from_PREFIX;
+    # switch to vendor directories if requested.
+    if ($ENV{'HAIKU_USE_VENDOR_DIRECTORIES'}) {
+        $self->{INSTALLDIRS} ||= 'vendor';
+    }
 
-=cut
+    $self->SUPER::init_main();
+}
 
 sub init_INSTALL_from_PREFIX {
     my $self = shift;
@@ -63,20 +62,6 @@ sub init_INSTALL_from_PREFIX {
     } 
 }
 
-=back
-
-=head3 init_others
-
-    $MM->init_others();
-
-Initializes the macro definitions having to do with compiling and
-linking used by tools_other() and places them in the $MM object.
-
-If there is no description, its the same as the parameter to
-WriteMakefile() documented in ExtUtils::MakeMaker.
-
-=cut
-
 sub init_others {
     my $self = shift;
 
@@ -90,8 +75,6 @@ sub init_others {
     return;
 }
 
-=back
-
 1;
 __END__
 
-- 
2.21.0


From a4dbb9ef2b1c5e42b5b17a55c11cb2988856842c Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Fri, 9 Jun 2017 21:30:33 +0200
Subject: disable fstack-protector for Haiku


diff --git a/Configure b/Configure
index 3be9f05..e5c3c0a 100755
--- a/Configure
+++ b/Configure
@@ -5493,6 +5493,7 @@ default|recommended)
 	# thing. (NWC)
 	case "$osname" in
 	amigaos) ;; # -fstack-protector builds but doesn't work
+	haiku) ;; # -fstack-protector builds but doesn't work
 	*)	case "$gccversion" in
 		?*)	set stack-protector-strong -fstack-protector-strong
 			eval $checkccflag
-- 
2.21.0


From 7c1c6508a5be3606e9c4d77041eba0e57b5666ac Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Wed, 14 Mar 2018 21:33:54 +0100
Subject: sitecustomize.pl: use the shortVersion for site and vendor.


diff --git a/sitecustomize.pl b/sitecustomize.pl
index a321e51..76c0e46 100644
--- a/sitecustomize.pl
+++ b/sitecustomize.pl
@@ -8,17 +8,17 @@ use Config;
 my @ourINC = (
 	"/boot/home/config/lib/perl5/$Config{version}/$Config{archname}",
 	"/boot/home/config/lib/perl5/$Config{version}",
-	"/boot/home/config/non-packaged/lib/perl5/site_perl/$Config{version}/$Config{archname}",
-	"/boot/home/config/non-packaged/lib/perl5/site_perl/$Config{version}",
-	"/boot/home/config/lib/perl5/vendor_perl/$Config{version}/$Config{archname}",
-	"/boot/home/config/lib/perl5/vendor_perl/$Config{version}",
+	"/boot/home/config/non-packaged/lib/perl5/site_perl/$Config{revision}.$Config{patchlevel}/$Config{archname}",
+	"/boot/home/config/non-packaged/lib/perl5/site_perl/$Config{revision}.$Config{patchlevel}",
+	"/boot/home/config/lib/perl5/vendor_perl/$Config{revision}.$Config{patchlevel}/$Config{archname}",
+	"/boot/home/config/lib/perl5/vendor_perl/$Config{revision}.$Config{patchlevel}",
 	"/boot/home/config/lib/perl5/vendor_perl",
 	"/boot/system/lib/perl5/$Config{version}/$Config{archname}",
 	"/boot/system/lib/perl5/$Config{version}",
-	"/boot/system/non-packaged/lib/perl5/site_perl/$Config{version}/$Config{archname}",
-	"/boot/system/non-packaged/lib/perl5/site_perl/$Config{version}",
-	"/boot/system/lib/perl5/vendor_perl/$Config{version}/$Config{archname}",
-	"/boot/system/lib/perl5/vendor_perl/$Config{version}",
+	"/boot/system/non-packaged/lib/perl5/site_perl/$Config{revision}.$Config{patchlevel}/$Config{archname}",
+	"/boot/system/non-packaged/lib/perl5/site_perl/$Config{revision}.$Config{patchlevel}",
+	"/boot/system/lib/perl5/vendor_perl/$Config{revision}.$Config{patchlevel}/$Config{archname}",
+	"/boot/system/lib/perl5/vendor_perl/$Config{revision}.$Config{patchlevel}",
 	"/boot/system/lib/perl5/vendor_perl",
 );
 my @newINC;
-- 
2.21.0


From 7e4b9dd12eba09d7d0df167ab8576ef6db9e4308 Mon Sep 17 00:00:00 2001
From: Tony Cook <tony@develop-help.com>
Date: Tue, 7 Aug 2018 15:34:06 +1000
Subject: (perl #133326) fix and clarify handling of recurs_sv.

There were a few problems:

- the purpose of recur_sv wasn't clear, I believe I understand it
  now from looking at where recur_sv was actually being used.
  Frankly the logic of the code itself was hard to follow, apparently
  only counting a level if the recur_sv was equal to the current
  SV.

  Fixed by adding some documentation to recur_sv in the context
  structure.  The logic has been re-worked (see below) to hopefully
  make it more understandable.

- the conditional checks for inc/decrementing recur_depth didn't
  match between the beginnings and ends of the store_array() and
  store_hash() handlers didn't match, since recur_sv was both
  explicitly modified by those functions and implicitly modified
  in their recursive calls to process elements.

  Fixing by storing the starting value of cxt->recur_sv locally
  testing against that instead of against the value that might be
  modified recursively.

- the checks in store_ref(), store_array(), store_l?hash() were
  over complex, obscuring their purpose.

  Fixed by:
   - always count a recursion level in store_ref() and store the
     RV in recur_sv
   - only count a recursion level in the array/hash handlers if
     the SV didn't match.
   - skip the check against cxt->entry, if we're in this code
     we could be recursing, so we want to detect it.

- (after the other changes) the recursion checks in store_hash()/
  store_lhash() only checked the limit if the SV didn't match the
  recur_sv, which horribly broke things.

  Fixed by:
   - Now only make the depth increment conditional, and always
     check against the limit if one is set.

(cherry picked from commit 120060c86e233cb9f588314214137f3ed1b48e2a)

diff --git a/dist/Storable/Storable.xs b/dist/Storable/Storable.xs
index 6a90e24..f6df32b 100644
--- a/dist/Storable/Storable.xs
+++ b/dist/Storable/Storable.xs
@@ -418,6 +418,24 @@ typedef struct stcxt {
     SV *(**retrieve_vtbl)(pTHX_ struct stcxt *, const char *);	/* retrieve dispatch table */
     SV *prev;			/* contexts chained backwards in real recursion */
     SV *my_sv;			/* the blessed scalar who's SvPVX() I am */
+
+    /* recur_sv:
+
+       A hashref of hashrefs or arrayref of arrayrefs is actually a
+       chain of four SVs, eg for an array ref containing an array ref:
+
+         RV -> AV (element) -> RV -> AV
+
+       To make this depth appear natural from a perl level we only
+       want to count this as two levels, so store_ref() stores it's RV
+       into recur_sv and store_array()/store_hash() will only count
+       that level if the AV/HV *isn't* recur_sv.
+
+       We can't just have store_hash()/store_array() not count that
+       level, since it's possible for XS code to store an AV or HV
+       directly as an element (though perl code trying to access such
+       an object will generally croak.)
+     */
     SV *recur_sv;               /* check only one recursive SV */
     int in_retrieve_overloaded; /* performance hack for retrieving overloaded objects */
     int flags;			/* controls whether to bless or tie objects */
@@ -431,8 +449,13 @@ typedef struct stcxt {
 
 #define RECURSION_TOO_DEEP() \
     (cxt->max_recur_depth != -1 && ++cxt->recur_depth > cxt->max_recur_depth)
+
+/* There's cases where we need to check whether the hash recursion
+   limit has been reached without bumping the recursion levels, so the
+   hash check doesn't bump the depth.
+*/
 #define RECURSION_TOO_DEEP_HASH() \
-    (cxt->max_recur_depth_hash != -1 && ++cxt->recur_depth > cxt->max_recur_depth_hash)
+    (cxt->max_recur_depth_hash != -1 && cxt->recur_depth > cxt->max_recur_depth_hash)
 #define MAX_DEPTH_ERROR "Max. recursion depth with nested structures exceeded"
 
 static int storable_free(pTHX_ SV *sv, MAGIC* mg);
@@ -2360,21 +2383,20 @@ static int store_ref(pTHX_ stcxt_t *cxt, SV *sv)
     } else
         PUTMARK(is_weak ? SX_WEAKREF : SX_REF);
 
-    TRACEME(("recur_depth %" IVdf ", recur_sv (0x%" UVxf ")", cxt->recur_depth,
-             PTR2UV(cxt->recur_sv)));
-    if (cxt->entry && cxt->recur_sv == sv) {
-        if (RECURSION_TOO_DEEP()) {
+    cxt->recur_sv = sv;
+
+    TRACEME((">ref recur_depth %" IVdf ", recur_sv (0x%" UVxf ") max %" IVdf, cxt->recur_depth,
+             PTR2UV(cxt->recur_sv), cxt->max_recur_depth));
+    if (RECURSION_TOO_DEEP()) {
 #if PERL_VERSION < 15
-            cleanup_recursive_data(aTHX_ (SV*)sv);
+        cleanup_recursive_data(aTHX_ (SV*)sv);
 #endif
-            CROAK((MAX_DEPTH_ERROR));
-        }
+        CROAK((MAX_DEPTH_ERROR));
     }
-    cxt->recur_sv = sv;
 
     retval = store(aTHX_ cxt, sv);
-    if (cxt->entry && cxt->recur_sv == sv && cxt->recur_depth > 0) {
-        TRACEME(("recur_depth --%" IVdf, cxt->recur_depth));
+    if (cxt->max_recur_depth != -1 && cxt->recur_depth > 0) {
+        TRACEME(("<ref recur_depth --%" IVdf, cxt->recur_depth));
         --cxt->recur_depth;
     }
     return retval;
@@ -2635,6 +2657,7 @@ static int store_array(pTHX_ stcxt_t *cxt, AV *av)
     UV len = av_len(av) + 1;
     UV i;
     int ret;
+    SV *const recur_sv = cxt->recur_sv;
 
     TRACEME(("store_array (0x%" UVxf ")", PTR2UV(av)));
 
@@ -2659,9 +2682,9 @@ static int store_array(pTHX_ stcxt_t *cxt, AV *av)
         TRACEME(("size = %d", (int)l));
     }
 
-    TRACEME(("recur_depth %" IVdf ", recur_sv (0x%" UVxf ")", cxt->recur_depth,
-             PTR2UV(cxt->recur_sv)));
-    if (cxt->entry && cxt->recur_sv == (SV*)av) {
+    TRACEME((">array recur_depth %" IVdf ", recur_sv (0x%" UVxf ") max %" IVdf, cxt->recur_depth,
+             PTR2UV(cxt->recur_sv), cxt->max_recur_depth));
+    if (recur_sv != (SV*)av) {
         if (RECURSION_TOO_DEEP()) {
             /* with <= 5.14 it recurses in the cleanup also, needing 2x stack size */
 #if PERL_VERSION < 15
@@ -2670,7 +2693,6 @@ static int store_array(pTHX_ stcxt_t *cxt, AV *av)
             CROAK((MAX_DEPTH_ERROR));
         }
     }
-    cxt->recur_sv = (SV*)av;
 
     /*
      * Now store each item recursively.
@@ -2701,9 +2723,12 @@ static int store_array(pTHX_ stcxt_t *cxt, AV *av)
             return ret;
     }
 
-    if (cxt->entry && cxt->recur_sv == (SV*)av && cxt->recur_depth > 0) {
-        TRACEME(("recur_depth --%" IVdf, cxt->recur_depth));
-        --cxt->recur_depth;
+    if (recur_sv != (SV*)av) {
+        assert(cxt->max_recur_depth == -1 || cxt->recur_depth > 0);
+        if (cxt->max_recur_depth != -1 && cxt->recur_depth > 0) {
+            TRACEME(("<array recur_depth --%" IVdf, cxt->recur_depth));
+            --cxt->recur_depth;
+        }
     }
     TRACEME(("ok (array)"));
 
@@ -2766,6 +2791,7 @@ static int store_hash(pTHX_ stcxt_t *cxt, HV *hv)
 #endif
                          ) ? 1 : 0);
     unsigned char hash_flags = (SvREADONLY(hv) ? SHV_RESTRICTED : 0);
+    SV * const recur_sv = cxt->recur_sv;
 
     /* 
      * Signal hash by emitting SX_HASH, followed by the table length.
@@ -2817,17 +2843,17 @@ static int store_hash(pTHX_ stcxt_t *cxt, HV *hv)
         TRACEME(("size = %d, used = %d", (int)l, (int)HvUSEDKEYS(hv)));
     }
 
-    TRACEME(("recur_depth %" IVdf ", recur_sv (0x%" UVxf ")", cxt->recur_depth,
-             PTR2UV(cxt->recur_sv)));
-    if (cxt->entry && cxt->recur_sv == (SV*)hv) {
-        if (RECURSION_TOO_DEEP_HASH()) {
+    TRACEME((">hash recur_depth %" IVdf ", recur_sv (0x%" UVxf ") max %" IVdf, cxt->recur_depth,
+             PTR2UV(cxt->recur_sv), cxt->max_recur_depth_hash));
+    if (recur_sv != (SV*)hv && cxt->max_recur_depth_hash != -1) {
+        ++cxt->recur_depth;
+    }
+    if (RECURSION_TOO_DEEP_HASH()) {
 #if PERL_VERSION < 15
-            cleanup_recursive_data(aTHX_ (SV*)hv);
+        cleanup_recursive_data(aTHX_ (SV*)hv);
 #endif
-            CROAK((MAX_DEPTH_ERROR));
-        }
+        CROAK((MAX_DEPTH_ERROR));
     }
-    cxt->recur_sv = (SV*)hv;
 
     /*
      * Save possible iteration state via each() on that table.
@@ -3107,8 +3133,9 @@ static int store_hash(pTHX_ stcxt_t *cxt, HV *hv)
     TRACEME(("ok (hash 0x%" UVxf ")", PTR2UV(hv)));
 
  out:
-    if (cxt->entry && cxt->recur_sv == (SV*)hv && cxt->recur_depth > 0) {
-        TRACEME(("recur_depth --%" IVdf , cxt->recur_depth));
+    assert(cxt->max_recur_depth_hash != -1 && cxt->recur_depth > 0);
+    TRACEME(("<hash recur_depth --%" IVdf , cxt->recur_depth));
+    if (cxt->max_recur_depth_hash != -1 && recur_sv != (SV*)hv && cxt->recur_depth > 0) {
         --cxt->recur_depth;
     }
     HvRITER_set(hv, riter);		/* Restore hash iterator state */
@@ -3221,6 +3248,7 @@ static int store_lhash(pTHX_ stcxt_t *cxt, HV *hv, unsigned char hash_flags)
 #ifdef DEBUGME
     UV len = (UV)HvTOTALKEYS(hv);
 #endif
+    SV * const recur_sv = cxt->recur_sv;
     if (hash_flags) {
         TRACEME(("store_lhash (0x%" UVxf ") (flags %x)", PTR2UV(hv),
                  (int) hash_flags));
@@ -3231,15 +3259,15 @@ static int store_lhash(pTHX_ stcxt_t *cxt, HV *hv, unsigned char hash_flags)
 
     TRACEME(("recur_depth %" IVdf ", recur_sv (0x%" UVxf ")", cxt->recur_depth,
              PTR2UV(cxt->recur_sv)));
-    if (cxt->entry && cxt->recur_sv == (SV*)hv) {
-        if (RECURSION_TOO_DEEP_HASH()) {
+    if (recur_sv != (SV*)hv && cxt->max_recur_depth_hash != -1) {
+        ++cxt->recur_depth;
+    }
+    if (RECURSION_TOO_DEEP_HASH()) {
 #if PERL_VERSION < 15
-            cleanup_recursive_data(aTHX_ (SV*)hv);
+        cleanup_recursive_data(aTHX_ (SV*)hv);
 #endif
-            CROAK((MAX_DEPTH_ERROR));
-        }
+        CROAK((MAX_DEPTH_ERROR));
     }
-    cxt->recur_sv = (SV*)hv;
 
     array = HvARRAY(hv);
     for (i = 0; i <= (Size_t)HvMAX(hv); i++) {
@@ -3252,7 +3280,7 @@ static int store_lhash(pTHX_ stcxt_t *cxt, HV *hv, unsigned char hash_flags)
                 return ret;
         }
     }
-    if (cxt->entry && cxt->recur_sv == (SV*)hv && cxt->recur_depth > 0) {
+    if (recur_sv == (SV*)hv && cxt->max_recur_depth_hash != -1 && cxt->recur_depth > 0) {
         TRACEME(("recur_depth --%" IVdf, cxt->recur_depth));
         --cxt->recur_depth;
     }
diff --git a/dist/Storable/t/recurse.t b/dist/Storable/t/recurse.t
index fa8be0b..63fde90 100644
--- a/dist/Storable/t/recurse.t
+++ b/dist/Storable/t/recurse.t
@@ -20,7 +20,7 @@ use Storable qw(freeze thaw dclone);
 
 $Storable::flags = Storable::FLAGS_COMPAT;
 
-use Test::More tests => 38;
+use Test::More tests => 39;
 
 package OBJ_REAL;
 
@@ -364,5 +364,17 @@ else {
         dclone $t;
     };
     like $@, qr/Max\. recursion depth with nested structures exceeded/,
-      'Caught href stack overflow '.MAX_DEPTH*2;
+      'Caught href stack overflow '.MAX_DEPTH_HASH*2;
+}
+
+{
+    # perl #133326
+    my @tt;
+    #$Storable::DEBUGME=1;
+    for (1..16000) {
+        my $t = [[[]]];
+        push @tt, $t;
+    }
+    ok(eval { dclone \@tt; 1 },
+       "low depth structure shouldn't be treated as nested");
 }
-- 
2.21.0


From 517d79b3f74b6093e527d2e417d76ff8079506c9 Mon Sep 17 00:00:00 2001
From: Tony Cook <tony@develop-help.com>
Date: Tue, 4 Dec 2018 15:11:17 +1100
Subject: (perl #133708) remove build-time probing for stack limits for
 Storable


diff --git a/Makefile.SH b/Makefile.SH
index 5197009..93f4ae1 100755
--- a/Makefile.SH
+++ b/Makefile.SH
@@ -176,15 +176,11 @@ esac
 
 : is Cwd static or dynamic
 static_cwd='define'
-storable_limit_dep=''
-storable_type=''
 list_util_dep='$(PERL_EXE)'
 for f in $dynamic_ext; do
    case $f in
        Cwd) static_cwd='undef' ;;
        List/Util) list_util_dep=lib/auto/List/Util/Util.$dlext ;;
-       Storable) storable_limit_dep=lib/auto/Storable/Storable.$dlext
-                 storable_type='dynamic' ;;
    esac
 done
 
@@ -221,7 +217,6 @@ for f in $static_ext; do
 $this_target: lib/auto/List/Util/Util\$(LIB_EXT)" ;;
 	Unicode/Normalize) extra_dep="$extra_dep
 $this_target: uni.data" ;;
-        Storable) storable_type='static' ;;
     esac
 done
 
@@ -1158,26 +1153,6 @@ no_install no-install: install-notify
 install: install-all
 !NO!SUBS!
 
-if test "$storable_type" != "" ; then
-
-case "$static_cwd" in
-undef) storable_limit_dep="$storable_limit_dep lib/auto/Cwd/Cwd.$dlext" ;;
-esac
-
-$spitshell >>$Makefile <<EOT
-
-dist/Storable/lib/Storable/Limit.pm : \$(PERL_EXE) dist/Storable/stacksize $storable_limit_dep
-	cd dist/Storable ; \$(LDLIBPTH) \$(MAKE) lib/Storable/Limit.pm
-
-lib/Storable/Limit.pm : dist/Storable/lib/Storable/Limit.pm
-	test -d lib/Storable || mkdir lib/Storable
-	cp dist/Storable/lib/Storable/Limit.pm lib/Storable/Limit.pm
-EOT
-
-common_build_deps="$common_build_deps lib/Storable/Limit.pm"
-
-fi
-
 for name in all notify silent strip verbose; do
     flags="--$name";
     flags=`echo $flags | sed -e 's/--all//'`
diff --git a/dist/Storable/Makefile.PL b/dist/Storable/Makefile.PL
index 6977505..60af5d2 100644
--- a/dist/Storable/Makefile.PL
+++ b/dist/Storable/Makefile.PL
@@ -12,13 +12,7 @@ use Config;
 use File::Copy qw(move copy);
 use File::Spec;
 
-unlink "lib/Storable/Limit.pm";
-
 my $pm = { 'Storable.pm' => '$(INST_ARCHLIB)/Storable.pm' };
-unless ($ENV{PERL_CORE}) {
-    # the core Makefile takes care of this for core builds
-    $pm->{"lib/Storable/Limit.pm"} = '$(INST_ARCHLIB)/Storable/Limit.pm';
-}
 
 WriteMakefile(
     NAME                => 'Storable',
@@ -81,21 +75,7 @@ sub xlinkext {
 }
 
 sub depend {
-    my $extra_deps = "";
-    my $options = "";
-    if ($ENV{PERL_CORE}) {
-        $options = "--core";
-    }
-    else {
-        # blib.pm needs arch/lib
-        $extra_deps = ' Storable.pm';
-    }
-    my $linktype = uc($_[0]->{LINKTYPE});
-    my $limit_pm = File::Spec->catfile('lib', 'Storable', 'Limit.pm');
     "
-$limit_pm : stacksize \$(INST_$linktype)$extra_deps
-	\$(MKPATH) \$(INST_LIB)
-	\$(FULLPERLRUNINST) stacksize $options
 
 release : dist
 	git tag \$(VERSION)
@@ -105,18 +85,6 @@ release : dist
 "
 }
 
-sub test {
-    my ($self, %attr) = @_;
-
-    my $out = $self->SUPER::test(%attr);
-
-    if ($ENV{PERL_CORE}) {
-        $out =~ s!^(test(?:db)?_(?:static|dynamic)\b.*)!$1 lib/Storable/Limit.pm!gm;
-    }
-
-    $out;
-}
-
 sub postamble {
 '
 all :: Storable.pm
diff --git a/dist/Storable/__Storable__.pm b/dist/Storable/__Storable__.pm
index 71c669d..e5a655e 100644
--- a/dist/Storable/__Storable__.pm
+++ b/dist/Storable/__Storable__.pm
@@ -32,8 +32,6 @@ our $VERSION = '3.08';
 our $recursion_limit;
 our $recursion_limit_hash;
 
-do "Storable/Limit.pm";
-
 $recursion_limit = 512
   unless defined $recursion_limit;
 $recursion_limit_hash = 256
@@ -941,13 +939,13 @@ There are a few things you need to know, however:
 
 =item *
 
-Since Storable 3.05 we probe for the stack recursion limit for references,
+From Storable 3.05 to 3.13 we probed for the stack recursion limit for references,
 arrays and hashes to a maximal depth of ~1200-35000, otherwise we might
 fall into a stack-overflow.  On JSON::XS this limit is 512 btw.  With
 references not immediately referencing each other there's no such
 limit yet, so you might fall into such a stack-overflow segfault.
 
-This probing and the checks performed have some limitations:
+This probing and the checks we performed have some limitations:
 
 =over
 
@@ -955,7 +953,9 @@ This probing and the checks performed have some limitations:
 
 the stack size at build time might be different at run time, eg. the
 stack size may have been modified with ulimit(1).  If it's larger at
-run time Storable may fail the freeze() or thaw() unnecessarily.
+run time Storable may fail the freeze() or thaw() unnecessarily.  If
+it's larger at build time Storable may segmentation fault when
+processing a deep structure at run time.
 
 =item *
 
@@ -970,6 +970,8 @@ stack without triggering Storable's recursion protection.
 
 =back
 
+So these now have simple defaults rather than probing at build-time.
+
 You can control the maximum array and hash recursion depths by
 modifying C<$Storable::recursion_limit> and
 C<$Storable::recursion_limit_hash> respectively.  Either can be set to
diff --git a/dist/Storable/stacksize b/dist/Storable/stacksize
index 7abd3a8..27bd826 100644
--- a/dist/Storable/stacksize
+++ b/dist/Storable/stacksize
@@ -1,18 +1,17 @@
 #!/usr/bin/perl
 # binary search maximum stack depth for arrays and hashes
-# and store it in lib/Storable/Limit.pm
+# and report it to stdout as code to set the limits
 
 use Config;
 use Cwd;
 use File::Spec;
 use strict;
 
-my $fn = "lib/Storable/Limit.pm";
 my $ptrsize = $Config{ptrsize};
 my ($bad1, $bad2) = (65001, 25000);
 sub QUIET () {
     (defined $ENV{MAKEFLAGS} and $ENV{MAKEFLAGS} =~ /\b(s|silent|quiet)\b/
-     and !defined($ENV{TRAVIS}))
+     and !defined($ENV{TRAVIS})) || @ARGV && $ARGV[0] eq "-q"
       ? 1 : 0
 }
 sub PARALLEL () {
@@ -44,61 +43,28 @@ elsif (system("ulimit -c 0 ;") == 0) {
     # try to prevent core dumps
     $prefix = "ulimit -c 0 ; ";
 }
-if (@ARGV and $ARGV[0] eq '--core') {
-    $ENV{PERL_CORE} = 1;
-}
 my $PERL = $^X;
-if ($ENV{PERL_CORE}) {
-    my $path;
-    my $ldlib = $Config{ldlibpthname};
-    if (-d 'dist/Storable') {
-        chdir 'dist/Storable';
-        $PERL = "../../$PERL" unless $PERL =~ m|^/|;
-    }
-    if ($ldlib) {
-        $path = getcwd()."/../..";
-    }
-    if ($^O eq 'MSWin32' and -d '../dist/Storable') {
-        chdir '..\dist\Storable';
-        $PERL = "..\\..\\$PERL" unless $PERL =~ /^[A-Za-z]:\\/;
-    }
-    $PERL = "\"$PERL\"" if $PERL =~ / /;
-    if ($ldlib and $ldlib ne 'PATH') {
-        $PERL = "$ldlib=$path $PERL";
-    }
-}
-
--d "lib" or mkdir "lib";
--d "lib/Storable" or mkdir "lib/Storable";
-
 if ($^O eq "MSWin32") {
     require Win32;
     my ($str, $major, $minor) = Win32::GetOSVersion();
     if ($major < 6 || $major == 6 && $minor < 1) {
-	print "Using defaults for older Win32\n";
+	print "# Using defaults for older Win32\n";
 	write_limits(500, 256);
 	exit;
     }
 }
 my ($n, $good, $bad, $found) =
     (65000, 100, $bad1, undef);
-print "probe for max. stack sizes...\n" unless QUIET;
+print "# probe for max. stack sizes...\n" unless QUIET;
 # -I. since we're run before pm_to_blib (which is going to copy the
 # file we create) and need to load our Storable.pm, not the already
 # installed Storable.pm
-my $mblib = '-Mblib -I.';
-if ($ENV{PERL_CORE}) {
-    if ($^O eq 'MSWin32') {
-        $mblib = '-I..\..\lib\auto -I..\..\lib';
-    } else {
-        $mblib = '-I../../lib/auto -I../../lib';
-    }
+my $mblib = '';
+if (-d 'blib'}) {
+    $mblib = '-Mblib -I.';
 }
-if (PARALLEL) {
-    # problem with parallel builds. wait for INST_DYNAMIC linking to be done.
-    # the problem is the RM_F INST_DYNAMIC race.
-    print "parallel build race - wait for linker ...\n" unless QUIET;
-    sleep(2.0);
+elsif (-f "Configure") {
+    $mblib = '-Ilib';
 }
 
 sub cmd {
@@ -113,7 +79,7 @@ sub cmd {
 sub good {
     my $i = shift; # this passed
     my $j = $i + abs(int(($bad - $i) / 2));
-    print "Storable: determining recursion limit: $i passed, try more $j ...\n" unless QUIET;
+    print "# Storable: determining recursion limit: $i passed, try more $j ...\n" unless QUIET;
     $good = $i;
     if ($j <= $i) {
         $found++;
@@ -124,7 +90,7 @@ sub good {
 sub bad {
     my $i = shift; # this failed
     my $j = $i - abs(int(($i - $good) / 2));
-    print "Storable: determining recursion limit: $i too big, try less $j ...\n" unless QUIET;
+    print "# Storable: determining recursion limit: $i too big, try less $j ...\n" unless QUIET;
     $bad = $i;
     if ($j >= $i) {
         $j = $good;
@@ -158,7 +124,7 @@ while (!$found) {
         $n = bad($n);
     }
 }
-print "MAX_DEPTH = $n\n" unless QUIET;
+print "# MAX_DEPTH = $n\n" unless QUIET;
 my $max_depth = $n;
 
 ($n, $good, $bad, $found) =
@@ -182,13 +148,13 @@ if ($max_depth == $bad1-1
     and $n == $bad2-1)
 {
     # more likely the shell. travis docker ubuntu, mingw e.g.
-    print "Error: Apparently your system(SHELLSTRING) cannot catch stack overflows\n"
+    print "# Apparently your system(SHELLSTRING) cannot catch stack overflows\n"
       unless QUIET;
     $max_depth = 512;
     $n = 256;
     print "MAX_DEPTH = $max_depth\n" unless QUIET;
 }
-print "MAX_DEPTH_HASH = $n\n" unless QUIET;
+print "# MAX_DEPTH_HASH = $n\n" unless QUIET;
 my $max_depth_hash = $n;
 
 # Previously this calculation was done in the macro, calculate it here
@@ -199,7 +165,7 @@ my $max_depth_hash = $n;
 # several apparently random failures here, eg. working in one
 # configuration, but not in a very similar configuration.
 $max_depth = int(0.6 * $max_depth);
-$max_depth_hash = int(0.6 * $max_depth);
+$max_depth_hash = int(0.6 * $max_depth_hash);
 
 my $stack_reserve = $^O eq "MSWin32" ? 32 : 16;
 if ($] ge "5.016" && !($^O eq "cygwin" && $ptrsize == 8)) {
@@ -217,16 +183,11 @@ write_limits($max_depth, $max_depth_hash);
 
 sub write_limits {
     my ($max_depth, $max_depth_hash) = @_;
-    my $f;
-    open $f, ">", $fn or die "$fn $!";
-    print $f <<EOS;
+    print <<EOS;
 # bisected by stacksize
 \$Storable::recursion_limit = $max_depth
   unless defined \$Storable::recursion_limit;
 \$Storable::recursion_limit_hash = $max_depth_hash
   unless defined \$Storable::recursion_limit_hash;
-1;
 EOS
-    close $f
-      or die "Failed to close $fn: $!\n";
 }
diff --git a/dist/Storable/t/recurse.t b/dist/Storable/t/recurse.t
index 63fde90..b5967a0 100644
--- a/dist/Storable/t/recurse.t
+++ b/dist/Storable/t/recurse.t
@@ -318,9 +318,11 @@ is($refcount_ok, 1, "check refcount");
 # Small 64bit systems fail with 1200 (c++ debugging), with gcc 3000.
 # Optimized 64bit allows up to 33.000 recursion depth.
 # with asan the limit is 255 though.
+
+local $Storable::recursion_limit = 30;
+local $Storable::recursion_limit_hash = 20;
 sub MAX_DEPTH () { Storable::stack_depth() }
 sub MAX_DEPTH_HASH () { Storable::stack_depth_hash() }
-sub OVERFLOW () { 35000 }
 {
     my $t;
     print "# max depth ", MAX_DEPTH, "\n";
diff --git a/win32/GNUmakefile b/win32/GNUmakefile
index 05193a1..afc18ec 100644
--- a/win32/GNUmakefile
+++ b/win32/GNUmakefile
@@ -1168,7 +1168,7 @@ CFG_VARS	=					\
 
 .PHONY: all info
 
-all : info rebasePE Extensions_nonxs $(PERLSTATIC) PostExt
+all : info rebasePE Extensions_nonxs $(PERLSTATIC)
 
 info :
 	@echo # CCTYPE=$(CCTYPE)
@@ -1612,16 +1612,6 @@ Extensions_clean :
 Extensions_realclean :
 	-if exist $(MINIPERL) $(MINIPERL) -I..\lib ..\make_ext.pl "MAKE=$(PLMAKE)" --dir=$(CPANDIR) --dir=$(DISTDIR) --dir=$(EXTDIR) --all --target=realclean
 
-PostExt : ..\lib\Storable\Limit.pm
-
-# we need the exe, perl(ver).dll, and the Exporter, Storable, Win32 extensions
-# rebasePE most of that, including adjustment for static builds, so we
-# just need non-xs extensions
-..\lib\Storable\Limit.pm : rebasePE Extensions_nonxs
-	$(PLMAKE) -C ..\dist\Storable lib\Storable\Limit.pm
-	if not exist ..\lib\Storable mkdir ..\lib\Storable
-	copy ..\dist\Storable\lib\Storable\Limit.pm ..\lib\Storable\Limit.pm
-
 # all PE files need to be built by the time this target runs, PP files can still
 # be running in parallel like UNIDATAFILES, this target a placeholder for the
 # future
diff --git a/win32/Makefile b/win32/Makefile
index 1e245f7..a4776dd 100644
--- a/win32/Makefile
+++ b/win32/Makefile
@@ -939,7 +939,7 @@ CFG_VARS	=					\
 #
 
 all : .\config.h ..\git_version.h $(GLOBEXE) $(CONFIGPM) \
-	$(UNIDATAFILES) MakePPPort $(PERLEXE) Extensions_nonxs Extensions PostExt \
+	$(UNIDATAFILES) MakePPPort $(PERLEXE) Extensions_nonxs Extensions \
 	$(PERLSTATIC)
 	@echo	Everything is up to date. '$(MAKE_BARE) test' to run test suite.
 
@@ -1225,13 +1225,6 @@ Extensions_clean:
 Extensions_realclean: 
 	-if exist $(MINIPERL) $(MINIPERL) -I..\lib ..\make_ext.pl "MAKE=$(MAKE)" --dir=$(CPANDIR) --dir=$(DISTDIR) --dir=$(EXTDIR) --all --target=realclean
 
-PostExt: ..\lib\Storable\Limit.pm
-
-..\lib\Storable\Limit.pm: $(PERLEXE) Extensions
-	cd ..\dist\Storable && $(MAKE) lib\Storable\Limit.pm
-	if not exist ..\lib\Storable mkdir ..\lib\Storable
-	copy ..\dist\Storable\lib\Storable\Limit.pm ..\lib\Storable\Limit.pm
-
 #-------------------------------------------------------------------------------
 
 doc: $(PERLEXE) ..\pod\perltoc.pod
@@ -1310,7 +1303,6 @@ distclean: realclean
 	-del /f $(LIBDIR)\Time\HiRes.pm
 	-del /f $(LIBDIR)\Unicode\Normalize.pm
 	-del /f $(LIBDIR)\Math\BigInt\FastCalc.pm
-	-del /f $(LIBDIR)\Storable.pm $(LIBDIR)\Storable\Limit.pm
 	-del /f $(LIBDIR)\Win32.pm
 	-del /f $(LIBDIR)\Win32CORE.pm
 	-del /f $(LIBDIR)\Win32API\File.pm
diff --git a/win32/makefile.mk b/win32/makefile.mk
index a6072a9..15b148d 100644
--- a/win32/makefile.mk
+++ b/win32/makefile.mk
@@ -1139,7 +1139,7 @@ CFG_VARS	=					\
 # Top targets
 #
 
-all : CHECKDMAKE rebasePE Extensions_nonxs $(PERLSTATIC) PostExt
+all : CHECKDMAKE rebasePE Extensions_nonxs $(PERLSTATIC)
 
 ..\regcomp$(o) : ..\regnodes.h ..\regcharclass.h
 
@@ -1563,17 +1563,6 @@ rebasePE : Extensions $(PERLDLL) $(NORMALIZE_DYN) $(PERLEXE)
 .ENDIF
 	$(NOOP)
 
-PostExt : ..\lib\Storable\Limit.pm
-	$(NOOP)
-
-# we need the exe, perl(ver).dll, and the Exporter, Storable, Win32 extensions
-# rebasePE most of that, including adjustment for static builds, so we
-# just need non-xs extensions
-..\lib\Storable\Limit.pm : rebasePE Extensions_nonxs
-	cd ..\dist\Storable && $(MAKE) lib\Storable\Limit.pm
-	if not exist ..\lib\Storable mkdir ..\lib\Storable
-	copy ..\dist\Storable\lib\Storable\Limit.pm ..\lib\Storable\Limit.pm
-
 #-------------------------------------------------------------------------------
 
 
@@ -1648,7 +1637,7 @@ distclean: realclean
 	-del /f $(LIBDIR)\Time\HiRes.pm
 	-del /f $(LIBDIR)\Unicode\Normalize.pm
 	-del /f $(LIBDIR)\Math\BigInt\FastCalc.pm
-	-del /f $(LIBDIR)\Storable.pm $(LIBDIR)\Storable\Limit.pm
+	-del /f $(LIBDIR)\Storable.pm
 	-del /f $(LIBDIR)\Win32.pm
 	-del /f $(LIBDIR)\Win32CORE.pm
 	-del /f $(LIBDIR)\Win32API\File.pm
-- 
2.21.0


From 8b7162312646bf1ac283e8765dd328d049f170c8 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Thu, 25 Apr 2019 23:19:43 +0200
Subject: locale.c: cast to char before comparing with a char constant.


diff --git a/locale.c b/locale.c
index 5b6460a..dc7cb0b 100644
--- a/locale.c
+++ b/locale.c
@@ -4927,7 +4927,7 @@ Perl__is_cur_LC_category_utf8(pTHX_ int category)
         Copy(delimited, utf8ness_cache, input_name_len_with_overhead - 1, char);
         utf8ness_cache[input_name_len_with_overhead - 1] = is_utf8 + '0';
 
-        if ((PL_locale_utf8ness[strlen(PL_locale_utf8ness)-1]
+        if ((char)(PL_locale_utf8ness[strlen(PL_locale_utf8ness)-1]
                                                 & (PERL_UINTMAX_T) ~1) != '0')
         {
             Perl_croak(aTHX_
-- 
2.21.0

