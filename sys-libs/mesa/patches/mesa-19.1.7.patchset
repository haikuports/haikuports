From f632aac9385cfe02f5bfe762d93e60b5b46f2c77 Tue Sep 17 00:00:00 2019
From: Ken Mays <kmays2000@gmail.com>
Date: Tue, Sep 17 2019 18:34:08 +0000
Subject: Haiku 19.1.7 patch

diff --git a/src/gallium/state_trackers/hgl/hgl.c.older b/src/gallium/state_trackers/hgl/hgl.c
index bbc477a..2294538 100644
--- a/src/gallium/state_trackers/hgl/hgl.c.older
+++ b/src/gallium/state_trackers/hgl/hgl.c
@@ -44,7 +44,8 @@ hgl_st_context(struct st_context_iface *stctxi)
 
 
 // Perform a safe void to hgl_buffer cast
-static inline struct hgl_buffer*
+//static inline struct hgl_buffer*
+struct hgl_buffer*
 hgl_st_framebuffer(struct st_framebuffer_iface *stfbi)
 {
 	struct hgl_buffer* buffer;
@@ -62,8 +63,10 @@ hgl_st_framebuffer_flush_front(struct st_context_iface *stctxi,
 	CALLED();
 
 	//struct hgl_context* context = hgl_st_context(stctxi);
-	//struct hgl_buffer* buffer = hgl_st_context(stfbi);
-
+	// struct hgl_buffer* buffer = hgl_st_context(stfbi);
+	struct hgl_buffer* buffer = hgl_st_framebuffer(stfbi);
+	//buffer->surface
+	
 	#if 0
 	struct stw_st_framebuffer *stwfb = stw_st_framebuffer(stfb);
 	mtx_lock(&stwfb->fb->mutex);
@@ -281,7 +284,8 @@ hgl_create_st_manager(struct hgl_context* context)
 	//manager->display = dpy;
 	manager->screen = context->screen;
 	manager->get_param = hgl_st_manager_get_param;
-
+	manager->st_manager_private = (void *)context;
+	
 	return manager;
 }
 
diff --git a/src/gallium/targets/haiku-softpipe/GalliumContext.cpp.older b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
index 0356f65..d9be790 100644
--- a/src/gallium/targets/haiku-softpipe/GalliumContext.cpp.older
+++ b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
@@ -26,6 +26,7 @@
 #include "sw/hgl/hgl_sw_winsys.h"
 #include "util/u_atomic.h"
 #include "util/u_memory.h"
+#include "util/u_framebuffer.h"
 
 #include "target-helpers/inline_sw_helper.h"
 #include "target-helpers/inline_debug_helper.h"
@@ -332,36 +333,17 @@ GalliumContext::SwapBuffers(context_id contextID)
 		ERROR("%s: context not found\n", __func__);
 		return B_ERROR;
 	}
-
-	// TODO: Where did st_notify_swapbuffers go?
-	//st_notify_swapbuffers(context->draw->stfbi);
-
 	context->st->flush(context->st, ST_FLUSH_FRONT, NULL);
 
-	struct st_context *stContext = (struct st_context*)context->st;
-
-	unsigned nColorBuffers = stContext->state.framebuffer.nr_cbufs;
-	for (unsigned i = 0; i < nColorBuffers; i++) {
-		pipe_surface* surface = stContext->state.framebuffer.cbufs[i];
-		if (!surface) {
-			ERROR("%s: Color buffer %d invalid!\n", __func__, i);
-			continue;
-		}
-
-		TRACE("%s: Flushing color buffer #%d\n", __func__, i);
-
-		// We pass our destination bitmap to flush_fronbuffer which passes it
-		// to the private winsys display call.
-		fScreen->flush_frontbuffer(fScreen, surface->texture, 0, 0,
-			context->bitmap, NULL);
+	struct hgl_buffer* buffer = hgl_st_framebuffer(context->draw->stfbi);
+	pipe_surface* surface = buffer->surface;
+	if (!surface) {
+		ERROR("%s: Invalid drawable surface!\n", __func__);
+		return B_ERROR;
 	}
 
-	#if 0
-	// TODO... should we flush the z stencil buffer?
-	pipe_surface* zSurface = stContext->state.framebuffer.zsbuf;
-	fScreen->flush_frontbuffer(fScreen, zSurface->texture, 0, 0,
+	fScreen->flush_frontbuffer(fScreen, surface->texture, 0, 0,
 		context->bitmap, NULL);
-	#endif
 
 	return B_OK;
 }
diff --git a/src/gallium/state_trackers/hgl/hgl_context.h.older b/src/gallium/state_trackers/hgl/hgl_context.h
index 5acb2f0..c5995f1 100644
--- a/src/gallium/state_trackers/hgl/hgl_context.h.older
+++ b/src/gallium/state_trackers/hgl/hgl_context.h
@@ -39,6 +39,8 @@ struct hgl_buffer
 	unsigned mask;
 
 	struct pipe_screen* screen;
+	struct pipe_surface* surface;
+
 	enum pipe_texture_target target;
 	struct pipe_resource* textures[ST_ATTACHMENT_COUNT];
 
@@ -80,6 +82,8 @@ struct hgl_context
 	struct hgl_buffer* read;
 };
 
+// hgl_buffer from statetracker interface
+struct hgl_buffer* hgl_st_framebuffer(struct st_framebuffer_iface *stfbi);
 
 // hgl state_tracker api
 struct st_api* hgl_create_st_api(void);
From 5939a7f627d4444ecd144ea1e0fa6b63dda8981b Mon Sep 17 00:00:00 2001
From: Augustin Cavalier <waddlesplash@gmail.com>
Date: Tue, 28 Aug 2018 21:32:38 -0400
Subject: BGLView: Make LockGL recursive.

This is the BeOS behavior, and the behavior of TinyGL's BGLView implementation
also. Fixes Flurry and other applications crashing.

Also initialize fRenderer in the constructor.

diff --git a/src/hgl/GLView.cpp.older b/src/hgl/GLView.cpp
index 9ae5b5c..9e01dcc 100644
--- a/src/hgl/GLView.cpp.older
+++ b/src/hgl/GLView.cpp
@@ -51,6 +51,7 @@ BGLView::BGLView(BRect rect, const char* name, ulong resizingMode, ulong mode,
 	fDitherMap(NULL)
 {
 	fRoster = new GLRendererRoster(this, options);
+	fRenderer = fRoster->GetRenderer();
 }
 
 
@@ -68,7 +69,7 @@ BGLView::LockGL()
 	// TODO: acquire the OpenGL API lock it on this glview
 
 	fDisplayLock.Lock();
-	if (fRenderer)
+	if (fRenderer != NULL && fDisplayLock.CountLocks() == 1)
 		fRenderer->LockGL();
 }
 
@@ -76,7 +77,7 @@ BGLView::LockGL()
 void
 BGLView::UnlockGL()
 {
-	if (fRenderer)
+	if (fRenderer != NULL && fDisplayLock.CountLocks() == 1)
 		fRenderer->UnlockGL();
 	fDisplayLock.Unlock();
 
@@ -189,7 +190,6 @@ BGLView::AttachedToWindow()
 	for (BView* view = this; view != NULL; view = view->Parent())
 		view->ConvertToParent(&fBounds);
 
-	fRenderer = fRoster->GetRenderer();
 	if (fRenderer != NULL) {
 		// Jackburton: The following code was commented because it doesn't look
 		// good in "direct" mode:
