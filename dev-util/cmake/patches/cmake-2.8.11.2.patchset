From b9cf2352503777e90fec9db9416f4bf6c793b1f4 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Sat, 5 Oct 2013 16:26:02 +0200
Subject: Several fixes to Haiku platform module

 * Do not define BEOS anymore (this includes workarounds which we don't
	need most of the time in Haiku, so we prefer opt-in IF(HAIKU) in the
	cmake files instead).
 * On the other hand, do define UNIX (we are trying to be compliant) and
	HAIKU (there is still a number of things we don't do like the
	average UNIX clone)
 * Do not use UnixPaths, as our filesystem hierarchy isn't anything like
	what it expects.
 * Do not use -nostart, which the compiler doesn't know about anymore.
	This used to be an Haiku extension to gcc, and is equivalent to
	-shared which is the default gcc option.
 * While "dl" functions are provided in libroot, this is always
	implicitly linked so there is no need to tell cmake about it.
 * Forcing position-independent code is not needed, so remove it.
 * On the other hand, include appropriate linker options for executables
	and shared libraries.
 * Support for the two available compilers in Haiku (gcc2 and gcc4) and
	pick the right headers and libraries according to the currently
	selected one.
 * With the adoption of the package manager, the directory layout was
	changed. Tell cmake where to look for header files and libraries.
 * As we don't define BEOS anymore, enable the workaround we still need
	for HAIKU as well. This is the lack of a libm (it is part of the
	implicitly linked in libroot)

diff --git a/Modules/FindLua51.cmake b/Modules/FindLua51.cmake
index a2bf0c0..770e93a 100644
--- a/Modules/FindLua51.cmake
+++ b/Modules/FindLua51.cmake
@@ -54,7 +54,7 @@ find_library(LUA_LIBRARY
 
 if(LUA_LIBRARY)
   # include the math library for Unix
-  if(UNIX AND NOT APPLE AND NOT BEOS)
+  if(UNIX AND NOT APPLE AND NOT BEOS AND NOT HAIKU)
     find_library(LUA_MATH_LIBRARY m)
     set( LUA_LIBRARIES "${LUA_LIBRARY};${LUA_MATH_LIBRARY}" CACHE STRING "Lua Libraries")
   # For Windows and Mac, don't need to explicitly include the math library
diff --git a/Modules/Platform/Haiku.cmake b/Modules/Platform/Haiku.cmake
index 8987783..825f851 100644
--- a/Modules/Platform/Haiku.cmake
+++ b/Modules/Platform/Haiku.cmake
@@ -1,22 +1,123 @@
-set(BEOS 1)
+# process only once
+if(HAIKU)
+  return()
+endif()
+
+set(HAIKU 1)
+set(UNIX 1)
 
-set(CMAKE_DL_LIBS root be)
-set(CMAKE_C_COMPILE_OPTIONS_PIC "-fPIC")
-set(CMAKE_C_COMPILE_OPTIONS_PIE "-fPIE")
+set(CMAKE_DL_LIBS "")
 set(CMAKE_SHARED_LIBRARY_C_FLAGS "-fPIC")
-set(CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS "-nostart")
+set(CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS "-shared")
 set(CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG "-Wl,-rpath,")
 set(CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG_SEP ":")
+set(CMAKE_SHARED_LIBRARY_RPATH_LINK_C_FLAG "-Wl,-rpath-link,")
 set(CMAKE_SHARED_LIBRARY_SONAME_C_FLAG "-Wl,-soname,")
+set(CMAKE_EXE_EXPORTS_C_FLAG "-Wl,--export-dynamic")
+
+# Determine, if the C or C++ compiler is configured for a secondary
+# architecture. If so, that will change the search paths we set below. We check
+# whether the compiler's library search paths contain a
+# "/boot/system/develop/lib/<subdir>/", which we assume to be the secondary
+# architecture specific subdirectory and extract the name of the architecture
+# accordingly.
+set(__HAIKU_COMPILER ${CMAKE_C_COMPILER})
+
+if(NOT __HAIKU_COMPILER)
+  set(__HAIKU_COMPILER ${CMAKE_CXX_COMPILER})
+endif()
+
+execute_process(
+  COMMAND ${__HAIKU_COMPILER} -print-search-dirs
+  OUTPUT_VARIABLE _HAIKU_SEARCH_DIRS
+  OUTPUT_STRIP_TRAILING_WHITESPACE)
+
+string(REGEX MATCH ".*\nlibraries: =?([^\n]*:)?/boot/system/develop/lib/([^/]*)/(:[^\n]*)?\n.*" _dummy "\n${_HAIKU_SEARCH_DIRS}\n")
+set(CMAKE_HAIKU_SECONDARY_ARCH "${CMAKE_MATCH_2}")
+
+if(NOT CMAKE_HAIKU_SECONDARY_ARCH)
+  set(CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR "")
+  unset(CMAKE_HAIKU_SECONDARY_ARCH)
+else()
+  set(CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR "/${CMAKE_HAIKU_SECONDARY_ARCH}")
+
+  # Override CMAKE_*LIBRARY_ARCHITECTURE. This will cause FIND_LIBRARY to search
+  # the libraries in the correct subdirectory first. It still isn't completely
+  # correct, since the parent directories shouldn't be searched at all. The
+  # primary architecture library might still be found, if there isn't one
+  # installed for the secondary architecture or it is installed in a less
+  # specific location.
+  set(CMAKE_LIBRARY_ARCHITECTURE ${CMAKE_HAIKU_SECONDARY_ARCH})
+  set(CMAKE_C_LIBRARY_ARCHITECTURE ${CMAKE_HAIKU_SECONDARY_ARCH})
+  set(CMAKE_CXX_LIBRARY_ARCHITECTURE ${CMAKE_HAIKU_SECONDARY_ARCH})
+endif()
+
+list(APPEND CMAKE_SYSTEM_PREFIX_PATH
+  /boot/common/non-packaged
+  /boot/common
+  /boot/system
+  )
+
+LIST(APPEND CMAKE_HAIKU_COMMON_INCLUDE_DIRECTORIES
+  /boot/common/non-packaged/develop/headers${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  /boot/common/develop/headers${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  /boot/system/develop/headers/os
+  /boot/system/develop/headers/os/app
+  /boot/system/develop/headers/os/device
+  /boot/system/develop/headers/os/drivers
+  /boot/system/develop/headers/os/game
+  /boot/system/develop/headers/os/interface
+  /boot/system/develop/headers/os/kernel
+  /boot/system/develop/headers/os/locale
+  /boot/system/develop/headers/os/mail
+  /boot/system/develop/headers/os/media
+  /boot/system/develop/headers/os/midi
+  /boot/system/develop/headers/os/midi2
+  /boot/system/develop/headers/os/net
+  /boot/system/develop/headers/os/opengl
+  /boot/system/develop/headers/os/storage
+  /boot/system/develop/headers/os/support
+  /boot/system/develop/headers/os/translation
+  /boot/system/develop/headers/os/add-ons/graphics
+  /boot/system/develop/headers/os/add-ons/input_server
+  /boot/system/develop/headers/os/add-ons/screen_saver
+  /boot/system/develop/headers/os/add-ons/tracker
+  /boot/system/develop/headers/os/be_apps/Deskbar
+  /boot/system/develop/headers/os/be_apps/NetPositive
+  /boot/system/develop/headers/os/be_apps/Tracker
+  /boot/system/develop/headers/3rdparty
+  /boot/system/develop/headers/bsd
+  /boot/system/develop/headers/glibc
+  /boot/system/develop/headers/gnu
+  /boot/system/develop/headers/posix
+  /boot/system/develop/headers${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  )
+IF (CMAKE_HAIKU_SECONDARY_ARCH)
+  LIST(APPEND CMAKE_HAIKU_COMMON_INCLUDE_DIRECTORIES
+    /boot/system/develop/headers
+    )
+ENDIF (CMAKE_HAIKU_SECONDARY_ARCH)
+
+LIST(APPEND CMAKE_HAIKU_C_INCLUDE_DIRECTORIES
+  ${CMAKE_HAIKU_COMMON_INCLUDE_DIRECTORIES}
+  )
+
+LIST(APPEND CMAKE_HAIKU_CXX_INCLUDE_DIRECTORIES
+  ${CMAKE_HAIKU_COMMON_INCLUDE_DIRECTORIES})
+
+LIST(APPEND CMAKE_SYSTEM_INCLUDE_PATH ${CMAKE_HAIKU_C_INCLUDE_DIRECTORIES})
+
+LIST(APPEND CMAKE_HAIKU_DEVELOP_LIB_DIRECTORIES
+  /boot/common/non-packaged/develop/lib${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  /boot/common/develop/lib${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  /boot/system/develop/lib${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  )
+
+LIST(APPEND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES
+  ${CMAKE_HAIKU_DEVELOP_LIB_DIRECTORIES}
+  )
 
-include(Platform/UnixPaths)
-list(APPEND CMAKE_SYSTEM_PREFIX_PATH /boot/common)
-list(APPEND CMAKE_SYSTEM_INCLUDE_PATH /boot/common/include)
-list(APPEND CMAKE_SYSTEM_LIBRARY_PATH /boot/common/lib)
-list(APPEND CMAKE_SYSTEM_PROGRAM_PATH /boot/common/bin)
-list(APPEND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES /boot/common/lib)
-list(APPEND CMAKE_SYSTEM_INCLUDE_PATH /boot/develop/headers/3rdparty)
-list(APPEND CMAKE_SYSTEM_LIBRARY_PATH /boot/develop/lib/x86)
+LIST(APPEND CMAKE_SYSTEM_LIBRARY_PATH ${CMAKE_HAIKU_DEVELOP_LIB_DIRECTORIES})
 
 if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
   set(CMAKE_INSTALL_PREFIX "/boot/common" CACHE PATH
diff --git a/Tests/Complex/Library/CMakeLists.txt b/Tests/Complex/Library/CMakeLists.txt
index 5c43052..f00cbd6 100644
--- a/Tests/Complex/Library/CMakeLists.txt
+++ b/Tests/Complex/Library/CMakeLists.txt
@@ -51,7 +51,7 @@ define_property(
   FULL_DOCS "A simple etst proerty that means nothign and is used for nothing"
   )
 set_target_properties(CMakeTestCLibraryShared PROPERTIES FOO BAR)
-if(NOT BEOS AND NOT WIN32)  # No libm on BeOS.
+if(NOT BEOS AND NOT WIN32 AND NOT HAIKU)  # No libm on BeOS.
   set_target_properties(CMakeTestCLibraryShared PROPERTIES LINK_FLAGS "-lm")
 endif()
 get_target_property(FOO_BAR_VAR CMakeTestCLibraryShared FOO)
diff --git a/Tests/ComplexOneConfig/Library/CMakeLists.txt b/Tests/ComplexOneConfig/Library/CMakeLists.txt
index 5c43052..f00cbd6 100644
--- a/Tests/ComplexOneConfig/Library/CMakeLists.txt
+++ b/Tests/ComplexOneConfig/Library/CMakeLists.txt
@@ -51,7 +51,7 @@ define_property(
   FULL_DOCS "A simple etst proerty that means nothign and is used for nothing"
   )
 set_target_properties(CMakeTestCLibraryShared PROPERTIES FOO BAR)
-if(NOT BEOS AND NOT WIN32)  # No libm on BeOS.
+if(NOT BEOS AND NOT WIN32 AND NOT HAIKU)  # No libm on BeOS.
   set_target_properties(CMakeTestCLibraryShared PROPERTIES LINK_FLAGS "-lm")
 endif()
 get_target_property(FOO_BAR_VAR CMakeTestCLibraryShared FOO)
-- 
1.8.3.4


From 99381ca06fb2d010a7b12ec413855f1c3a99c2c8 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Sat, 5 Oct 2013 16:31:36 +0200
Subject: Remove use of B_COMMON_DIRECTORY

 * The common directory was removed in Haiku. Applications are now
	installed in the system directory.

diff --git a/Source/CPack/cmCPackGenerator.cxx b/Source/CPack/cmCPackGenerator.cxx
index 7cc1522..de394a6 100644
--- a/Source/CPack/cmCPackGenerator.cxx
+++ b/Source/CPack/cmCPackGenerator.cxx
@@ -26,7 +26,8 @@
 #include <algorithm>
 
 #if defined(__HAIKU__)
-#include <StorageKit.h>
+#include <FindDirectory.h>
+#include <StorageDefs.h>
 #endif
 
 //----------------------------------------------------------------------
@@ -1263,14 +1264,14 @@ const char* cmCPackGenerator::GetInstallPath()
   this->InstallPath += "-";
   this->InstallPath += this->GetOption("CPACK_PACKAGE_VERSION");
 #elif defined(__HAIKU__)
-  BPath dir;
-  if (find_directory(B_COMMON_DIRECTORY, &dir) == B_OK)
+  char dir[B_PATH_NAME_LENGTH];
+  if (find_directory(B_SYSTEM_DIRECTORY, -1, false, dir, sizeof(dir)) == B_OK)
     {
-    this->InstallPath = dir.Path();
+    this->InstallPath = dir;
     }
   else
     {
-    this->InstallPath = "/boot/common";
+    this->InstallPath = "/boot/system";
     }
 #else
   this->InstallPath = "/usr/local/";
diff --git a/Source/cmExportCommand.cxx b/Source/cmExportCommand.cxx
index 1cc1754..fcb66a7 100644
--- a/Source/cmExportCommand.cxx
+++ b/Source/cmExportCommand.cxx
@@ -20,7 +20,8 @@
 #include "cmExportBuildFileGenerator.h"
 
 #if defined(__HAIKU__)
-#include <StorageKit.h>
+#include <FindDirectory.h>
+#include <StorageDefs.h>
 #endif
 
 cmExportCommand::cmExportCommand()
@@ -305,14 +306,15 @@ void cmExportCommand::StorePackageRegistryDir(std::string const& package,
                                               const char* hash)
 {
 #if defined(__HAIKU__)
-  BPath dir;
-  if (find_directory(B_USER_SETTINGS_DIRECTORY, &dir) != B_OK)
+  char dir[B_PATH_NAME_LENGTH];
+  if (find_directory(B_USER_SETTINGS_DIRECTORY, -1, false, dir, sizeof(dir)) !=
+      B_OK)
     {
     return;
     }
-  dir.Append("cmake/packages");
-  dir.Append(package.c_str());
-  std::string fname = dir.Path();
+  std::string fname = dir;
+  fname += "/cmake/packages/";
+  fname += package;
 #else
   const char* home = cmSystemTools::GetEnv("HOME");
   if(!home)
diff --git a/Source/cmFindPackageCommand.cxx b/Source/cmFindPackageCommand.cxx
index aa3a73d..1d6530f 100644
--- a/Source/cmFindPackageCommand.cxx
+++ b/Source/cmFindPackageCommand.cxx
@@ -19,7 +19,9 @@
 #endif
 
 #if defined(__HAIKU__)
-#include <StorageKit.h>
+#include <string.h>
+#include <FindDirectory.h>
+#include <StorageDefs.h>
 #endif
 
 void cmFindPackageNeedBackwardsCompatibility(const std::string& variable,
@@ -1584,12 +1586,14 @@ void cmFindPackageCommand::AddPrefixesUserRegistry()
 #if defined(_WIN32) && !defined(__CYGWIN__)
   this->LoadPackageRegistryWinUser();
 #elif defined(__HAIKU__)
-  BPath dir;
-  if (find_directory(B_USER_SETTINGS_DIRECTORY, &dir) == B_OK)
-    {
-    dir.Append("cmake/packages");
-    dir.Append(this->Name.c_str());
-    this->LoadPackageRegistryDir(dir.Path());
+  char dir[B_PATH_NAME_LENGTH];
+  if (find_directory(B_USER_SETTINGS_DIRECTORY, -1, false, dir, sizeof(dir)) ==
+      B_OK)
+    {
+    std::string fname = dir;
+    fname += "/cmake/packages/";
+    fname += Name;
+    this->LoadPackageRegistryDir(fname);
     }
 #else
   if(const char* home = cmSystemTools::GetEnv("HOME"))
diff --git a/Source/cmLocalGenerator.cxx b/Source/cmLocalGenerator.cxx
index ee5b9d8..1369dab 100644
--- a/Source/cmLocalGenerator.cxx
+++ b/Source/cmLocalGenerator.cxx
@@ -37,7 +37,8 @@
 #include <assert.h>
 
 #if defined(__HAIKU__)
-#include <StorageKit.h>
+#include <FindDirectory.h>
+#include <StorageDefs.h>
 #endif
 
 cmLocalGenerator::cmLocalGenerator()
@@ -354,16 +355,16 @@ void cmLocalGenerator::GenerateInstallRules()
     prefix = prefix_win32.c_str();
     }
 #elif defined(__HAIKU__)
+  char dir[B_PATH_NAME_LENGTH];
   if (!prefix)
     {
-    BPath dir;
-    if (find_directory(B_COMMON_DIRECTORY, &dir) == B_OK)
+    if (find_directory(B_SYSTEM_DIRECTORY, -1, false, dir, sizeof(dir)) == B_OK)
       {
-      prefix = dir.Path();
+      prefix = dir;
       }
     else
       {
-      prefix = "/boot/common";
+      prefix = "/boot/system";
       }
     }
 #else
-- 
1.8.3.4


From c9b1d5be9feb7d1d22f4aa6ef83edd4fb62ff97d Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Sat, 5 Oct 2013 16:33:52 +0200
Subject: Remove useless preprocessor checks

 * Haiku does not define __BEOS__ anymore, so there is no need to guard
	these BeOS specific workaround for Haiku.
 * The workaround themselves are not needed for Haiku as it has much
	better POSIX compatibility than BeOS did.

diff --git a/Source/kwsys/SystemTools.cxx b/Source/kwsys/SystemTools.cxx
index 8b25d60..51dba3c 100644
--- a/Source/kwsys/SystemTools.cxx
+++ b/Source/kwsys/SystemTools.cxx
@@ -152,11 +152,6 @@ public:
 #define _chdir chdir
 #endif
 
-#if defined(__HAIKU__)
-#include <os/kernel/OS.h>
-#include <os/storage/Path.h>
-#endif
-
 #if defined(__BEOS__) && !defined(__ZETA__)
 #include <be/kernel/OS.h>
 #include <be/storage/Path.h>
diff --git a/Utilities/cmcurl/CMake/CurlTests.c b/Utilities/cmcurl/CMake/CurlTests.c
index d74a4f0..c5ba7c2 100644
--- a/Utilities/cmcurl/CMake/CurlTests.c
+++ b/Utilities/cmcurl/CMake/CurlTests.c
@@ -38,7 +38,7 @@ main ()
 # define PLATFORM_AIX_V3
 #endif
 
-#if defined(PLATFORM_SUNOS4) || defined(PLATFORM_AIX_V3) || (defined(__BEOS__) && !defined(__HAIKU__))
+#if defined(PLATFORM_SUNOS4) || defined(PLATFORM_AIX_V3) || defined(__BEOS__)
 #error "O_NONBLOCK does not work on this platform"
 #endif
   int socket;
diff --git a/Utilities/cmcurl/select.c b/Utilities/cmcurl/select.c
index 51adbcf..82f9dc2 100644
--- a/Utilities/cmcurl/select.c
+++ b/Utilities/cmcurl/select.c
@@ -39,7 +39,7 @@
 #error "We can't compile without select() support!"
 #endif
 
-#if defined(__BEOS__) && !defined(__HAIKU__)
+#if defined(__BEOS__)
 /* BeOS has FD_SET defined in socket.h */
 #include <socket.h>
 #endif
diff --git a/Utilities/cmzlib/zconf.h b/Utilities/cmzlib/zconf.h
index 6eb52d1..7a3b6fd 100644
--- a/Utilities/cmzlib/zconf.h
+++ b/Utilities/cmzlib/zconf.h
@@ -237,7 +237,7 @@
 #  endif
 #endif
 
-#if defined (__BEOS__) && !defined (__HAIKU__)
+#if defined (__BEOS__)
 #  ifdef ZLIB_DLL
 #    ifdef ZLIB_INTERNAL
 #      define ZEXPORT   __declspec(dllexport)
diff --git a/Utilities/cmzlib/zutil.h b/Utilities/cmzlib/zutil.h
index 74ef1f8..3053cd8 100644
--- a/Utilities/cmzlib/zutil.h
+++ b/Utilities/cmzlib/zutil.h
@@ -147,12 +147,6 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 #  define OS_CODE  0x0f
 #endif
 
-/* Haiku defines both __HAIKU__ and __BEOS__ (for now) */
-/* many BeOS workarounds are no longer needed in Haiku */
-#if defined(__HAIKU__) && defined(__BEOS__)
-#undef __BEOS__
-#endif
-
 #if defined(_BEOS_) || defined(RISCOS) 
 #  define fdopen(fd,mode) NULL /* No fdopen() */
 #endif
-- 
1.8.3.4


From 22ebddf5e418d248b74a966096e7c75400dba422 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Sat, 5 Oct 2013 16:59:25 +0200
Subject: Include files cleanup

 * No need to use a different path from the BeOS one, which still works.

diff --git a/Source/cmCTest.cxx b/Source/cmCTest.cxx
index 322a6a2..2aaedec 100644
--- a/Source/cmCTest.cxx
+++ b/Source/cmCTest.cxx
@@ -53,14 +53,10 @@
 #include <cm_zlib.h>
 #include <cmsys/Base64.h>
 
-#if defined(__BEOS__)
+#if defined(__BEOS__) || defined(__HAIKU__)
 #include <be/kernel/OS.h>   /* disable_debugger() API. */
 #endif
 
-#if defined(__HAIKU__)
-#include <os/kernel/OS.h>   /* disable_debugger() API. */
-#endif
-
 
 #define DEBUGOUT std::cout << __LINE__ << " "; std::cout
 #define DEBUGERR std::cerr << __LINE__ << " "; std::cerr
diff --git a/Source/kwsys/testDynamicLoader.cxx b/Source/kwsys/testDynamicLoader.cxx
index 61c1572..fc0215e 100644
--- a/Source/kwsys/testDynamicLoader.cxx
+++ b/Source/kwsys/testDynamicLoader.cxx
@@ -15,14 +15,10 @@
 #include KWSYS_HEADER(ios/iostream)
 #include KWSYS_HEADER(stl/string)
 
-#if defined(__BEOS__)
+#if defined(__BEOS__) || defined(__HAIKU__)
 #include <be/kernel/OS.h>  /* disable_debugger() API. */
 #endif
 
-#if defined(__HAIKU__)
-#include <os/kernel/OS.h>  /* disable_debugger() API. */
-#endif
-
 // Work-around CMake dependency scanning limitation.  This must
 // duplicate the above list of headers.
 #if 0
-- 
1.8.3.4


From 81f62c78a541298c4f989eade02bf48f8206fab2 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Sat, 5 Oct 2013 17:01:03 +0200
Subject: FindSDL: Fix broken include paths

 * I asked the CMake community about this, and they couldn't even figure
out how this worked even on other platforms.

diff --git a/Modules/FindSDL.cmake b/Modules/FindSDL.cmake
index fec142e..6adec1f 100644
--- a/Modules/FindSDL.cmake
+++ b/Modules/FindSDL.cmake
@@ -70,7 +70,7 @@
 find_path(SDL_INCLUDE_DIR SDL.h
   HINTS
     ENV SDLDIR
-  PATH_SUFFIXES include/SDL include/SDL12 include/SDL11 include
+  PATH_SUFFIXES SDL SDL12 SDL11
 )
 
 # SDL-1.1 is the name used by FreeBSD ports...
-- 
1.8.3.4


From fd48834c43e75c3b151afb046f3a9025ab29adb7 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Mon, 14 Oct 2013 09:35:02 +0200
Subject: Enable command-line length limitation on Haiku.


diff --git a/Source/cmNinjaNormalTargetGenerator.cxx b/Source/cmNinjaNormalTargetGenerator.cxx
index 7e48cd7..3d15900 100644
--- a/Source/cmNinjaNormalTargetGenerator.cxx
+++ b/Source/cmNinjaNormalTargetGenerator.cxx
@@ -563,7 +563,7 @@ void cmNinjaNormalTargetGenerator::WriteLinkStatement()
       cmSystemTools::GetEnv(forceRspFile) == 0) {
 #ifdef _WIN32
     commandLineLengthLimit = 8000 - linkRuleLength;
-#elif defined(__linux) || defined(__APPLE__)
+#elif defined(__linux) || defined(__APPLE__) || defined(__HAIKU__)
     // for instance ARG_MAX is 2096152 on Ubuntu or 262144 on Mac
     commandLineLengthLimit = ((int)sysconf(_SC_ARG_MAX))-linkRuleLength-1000;
 #else
-- 
1.8.3.4


From f37bdac542180d045d1bf213ee6d78ed0f46684a Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Thu, 17 Oct 2013 19:27:38 +0200
Subject: Enable ELF support on Haiku

 * The Ninja build system can't work with CPack when this is missing
 * This is used to modify ELF files and change the rpath inside them
when installing or packaging them.

diff --git a/Source/CMakeLists.txt b/Source/CMakeLists.txt
index f0519fe..7dc55db 100644
--- a/Source/CMakeLists.txt
+++ b/Source/CMakeLists.txt
@@ -15,7 +15,14 @@ CHECK_INCLUDE_FILE("elf.h" HAVE_ELF_H)
 if(HAVE_ELF_H)
   set(CMAKE_USE_ELF_PARSER 1)
 else()
-  set(CMAKE_USE_ELF_PARSER)
+  # Non-standard filename for Haiku, works all the same
+  CHECK_INCLUDE_FILE("elf32.h" HAVE_ELF32_H 
+	  "-I/system/develop/headers/private/system -I/system/develop/headers/private/system/arch/x86")
+  if(HAVE_ELF32_H)
+    set(CMAKE_USE_ELF_PARSER 1)
+  else()
+    set(CMAKE_USE_ELF_PARSER)
+  endif()
 endif()
 
 set(EXECUTABLE_OUTPUT_PATH ${CMake_BIN_DIR})
@@ -400,6 +407,14 @@ if(APPLE)
   target_link_libraries(CMakeLib "-framework CoreFoundation")
 endif()
 
+# On Haiku, elf32.h is hidden in the "private" include dir
+if(HAIKU)
+	include_directories(
+		"/system/develop/headers/private/system"
+		"/system/develop/headers/private/system/arch/x86"
+	)
+endif()
+
 # On some platforms we need the rpcrt4 library for the VS 7 generators.
 if(CMAKE_BUILD_ON_VISUAL_STUDIO OR MINGW)
   target_link_libraries(CMakeLib rpcrt4)
@@ -505,6 +520,12 @@ if(UNIX)
     )
 endif()
 
+if(HAIKU)
+  set(CPACK_SRCS ${CPACK_SRCS}
+	  CPack/cmCPackHpkgGenerator.cxx
+  )
+endif()
+
 if(WIN32)
   set(CPACK_SRCS ${CPACK_SRCS}
     CPack/WiX/cmCPackWIXGenerator.cxx
diff --git a/Source/elf.h b/Source/elf.h
new file mode 100644
index 0000000..6b868bb
--- /dev/null
+++ b/Source/elf.h
@@ -0,0 +1,42 @@
+/*
+ * 
+ * /boot/common/include/elf.h
+ * 
+ * -I/system/develop/headers/private/system
+ * -I/system/develop/headers/private/system/arch_x86
+ *
+ * As found on other platforms, for benefit of GHC Haskell compiler, 
+ * Donn
+ * */
+
+#ifdef __HAIKU__
+
+#include <elf32.h>
+#include <elf64.h>
+
+typedef struct Elf32_Ehdr Elf32_Ehdr;
+typedef struct Elf32_Shdr Elf32_Shdr;
+typedef struct Elf32_Sym Elf32_Sym;
+typedef struct Elf32_Rel Elf32_Rel;
+typedef struct Elf32_Rela Elf32_Rela;
+
+#define ELFMAG0 0x7F
+#define ELFMAG1 'E'
+#define ELFMAG2 'L'
+#define ELFMAG3 'F'
+
+#define ET_NONE 0
+#define ET_REL 1
+#define ET_EXEC 2
+#define ET_DYN 3
+#define ET_CORE 4
+
+#define EM_386 3
+#define EM_SPARC 2
+#define EM_PPC 20
+
+#else
+
+#include_next <elf.h>
+
+#endif
-- 
1.8.3.4


From 9721c802a88d20b2f724909e6cce07295002bedd Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Thu, 17 Oct 2013 19:35:25 +0200
Subject: CPack: add Haiku hpkg support


diff --git a/Modules/CPackHpkg.cmake b/Modules/CPackHpkg.cmake
new file mode 100644
index 0000000..3308889
--- /dev/null
+++ b/Modules/CPackHpkg.cmake
@@ -0,0 +1,297 @@
+##section Variables specific to CPack Haiku (HPKG) generator
+##end
+##module
+# - The builtin (binary) CPack Haiku generator (Haiku only)
+# CPackHaiku may be used to create Haiku packages using CPack.
+# CPackHaiku is a CPack generator thus it uses the CPACK_XXX variables
+# used by CPack : http://www.cmake.org/Wiki/CMake:CPackConfiguration.
+# CPackHaiku will work only on haiku as it uss the 'package' tool available
+# there. With the custom archive format and compression algorithm, there is
+# currently no better way.
+#
+# CPackHaiku has specific features which are controlled by
+# the specifics CPACK_HAIKU_XXX variables.You'll find a detailed usage on
+# the wiki:
+#  http://www.cmake.org/Wiki/CMake:CPackPackageGenerators#HAIKU_.28HAIKU_only.29
+# However as a handy reminder here comes the list of specific variables:
+##end
+#
+##variable
+# CPACK_HAIKU_PACKAGE_NAME
+#     Mandatory : YES
+#     Default   : CPACK_PACKAGE_NAME (lower case)
+#     The haiku package name
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_VERSION
+#     Mandatory : YES
+#     Default   : CPACK_PACKAGE_VERSION
+#     The haiku package version
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_REVISION
+#     Mandatory : YES
+#     Default   : 1
+#     The haiku package version
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_ARCHITECTURE
+#     Mandatory : YES
+#     Default   : $ENV{BE_SYSTEM_CPU}, or x86_gcc2 if using gcc2.
+#     The haiku package architecture
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_PACKAGER
+#     Mandatory : YES
+#     Default   : CPACK_PACKAGE_CONTACT
+#     The haiku package maintainer e-mail address
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_VENDOR
+#     Mandatory : YES
+#     Default   : CPACK_PACKAGE_VENDOR
+#     The haiku package vendor
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_DESCRIPTION
+#     Mandatory : YES
+#     Default   : CPACK_PACKAGE_DESCRIPTION
+#     The haiku package description
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_DESCRIPTION_SUMMARY
+#     Mandatory : YES
+#     Default   : CPACK_PACKAGE_DESCRIPTION_SUMMARY
+#     The haiku package one-line description
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_COPYRIGHT
+#     Mandatory : YES
+#     Default   : -
+#     The haiku package copyright holders
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_LICENSES
+#     Mandatory : YES
+#     Default   : -
+#     The haiku package licenses. This must be available in /system/data/licenses,
+#     either provided by the package or one of the system-provided licenses.
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_URL
+#     Mandatory : NO
+#     Default   : -
+#     The URL of the web site for this package, preferably (when applicable) the
+#     site from which the original source can be obtained and any additional
+#     upstream documentation or information may be found.
+#     The content of this field is a simple URL without any surrounding
+#     characters such as <>.
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_DEBUG
+#     Mandatory : NO
+#     Default   : -
+#     May be set when invoking cpack in order to trace debug information
+#     during CPackHpkg run.
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_PREREQUIRES
+#     Mandatory : NO
+#     Default   : -
+#     This is similar to REQUIRES, but the package will not be rebuilt. This
+#     makes it possible to have circular dependencies between prerequired
+#     packages
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_SUPPLEMENTS
+#     Mandatory : NO
+#     Default   : -
+#     This field allow adding functionality to an existing package. This will
+#     be made visible to the original package in its private directory.
+#     It is used to declare that a package can enhance the functionality of another package.
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_CONFLICTS
+#     Mandatory : NO
+#     Default   : -
+#     When one binary package declares a conflict with another using a Conflicts field,
+#     Haiku will refuse to allow them to be installed on the system at the same time.
+##end
+##variable
+# CPACK_HAIKU_PACKAGE_CONTROL_EXTRA
+#     Mandatory : NO
+#     Default   : -
+#     This variable allow advanced user to add other entries to the .PackageInfo file
+##end
+##variable
+# CPACK_HAIKU_<COMPONENT_>PACKAGE_PROVIDES
+#     Mandatory : YES
+#     Default   : -
+#     List of provided entries for the package, with version constraints.
+#     There should be an entry for each binary, application, library and add-on
+#     provided by the package. The packages always provides itself, there is no
+#     need for explicitly mentionning it in this variable.
+##end
+##variable
+# CPACK_HAIKU_<COMPONENT_>PACKAGE_REQUIRES
+#     Mandatory : NO
+#     Default   : -
+#     May be used to set package dependencies.
+##end
+
+
+#=============================================================================
+# Copyright 2007-2013 Kitware, Inc.
+# Copyright 2007-2009 Mathieu Malaterre <mathieu.malaterre@gmail.com>
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+# (To distribute this file outside of CMake, substitute the full
+#  License text for the above reference.)
+
+# CPack script for creating Haiku packages
+# Author: Adrien Destugues
+#
+# http://wiki.debian.org/HowToPackageForDebian
+
+if(CMAKE_BINARY_DIR)
+	message(FATAL_ERROR "CPackHpkg.cmake may only be used by CPack internally.")
+endif()
+
+if(NOT HAIKU)
+	message(FATAL_ERROR "CPackHpkg.cmake may only be used under Haiku.")
+endif()
+
+find_program(FAKEROOT_EXECUTABLE fakeroot)
+if(FAKEROOT_EXECUTABLE)
+  set(CPACK_DEBIAN_FAKEROOT_EXECUTABLE ${FAKEROOT_EXECUTABLE})
+endif()
+
+
+# Let's define the .PackageInfo file found in haiku package:
+
+# Package: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_NAME)
+	string(TOLOWER "${CPACK_PACKAGE_NAME}" CPACK_HAIKU_PACKAGE_NAME)
+	string(REPLACE "_unspecified" "" CPACK_HAIKU_PACKAGE_NAME
+		"${CPACK_HAIKU_PACKAGE_NAME}")
+endif()
+
+# Version: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_VERSION)
+  if(NOT CPACK_PACKAGE_VERSION)
+	  message(FATAL_ERROR "CPackHpkg: Haiku package requires a package version")
+  endif()
+  set(CPACK_HAIKU_PACKAGE_VERSION ${CPACK_PACKAGE_VERSION})
+endif()
+
+# Revision: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_REVISION)
+	set(CPACK_HAIKU_PACKAGE_REVISION 1)
+endif()
+
+# Architecture: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_ARCHITECTURE)
+  if(CMAKE_C_COMPILER_VERSION VERSION_LESS 3.0)
+    set(CPACK_HAIKU_PACKAGE_ARCHITECTURE "x86_gcc2")
+  else()
+	  set(CPACK_HAIKU_PACKAGE_ARCHITECTURE $ENV{BE_HOST_CPU})
+  endif()
+endif()
+
+# have a look at get_property(result GLOBAL PROPERTY ENABLED_FEATURES),
+# this returns the successful find_package() calls, maybe this can help
+# Depends:
+# You should set: DEBIAN_PACKAGE_DEPENDS
+# TODO: automate 'objdump -p | grep NEEDED'
+if(NOT CPACK_HAIKU_PACKAGE_DEPENDS)
+	message(STATUS "CPACK_HAIKU_PACKAGE_DEPENDS not set, the package will have no dependencies.")
+endif()
+
+# Maintainer: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_PACKAGER)
+  if(NOT CPACK_PACKAGE_CONTACT)
+	  message(FATAL_ERROR "CPackHpkg: Haiku package requires a maintainer, set CPACK_PACKAGE_CONTACT or CPACK_HAIKU_PACKAGE_PACKAGER")
+  endif()
+  set(CPACK_HAIKU_PACKAGE_MAINTAINER ${CPACK_PACKAGE_PACKAGER})
+endif()
+
+# Vendor: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_VENDOR)
+	if(NOT CPACK_PACKAGE_VENDOR)
+		message(FATAL_ERROR "CPackHpkg: Haiku package requires a vendor, set CPACK_PACKAGE_VENDOR or CPACK_HAIKU_PACKAGE_VENDOR")
+  endif()
+  set(CPACK_HAIKU_PACKAGE_VENDOR ${CPACK_PACKAGE_VENDOR})
+endif()
+
+# Copyright: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_COPYRIGHT)
+	message(FATAL_ERROR "CPackHaiku: Haiku package requires a copyright for a package, set CPACK_HAIKU_PACKAGE_COPYRIGHT")
+endif()
+
+# License: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_LICENSES)
+	message(FATAL_ERROR "CPackHaiku: Haiku package requires a copyright for a package, set CPACK_HAIKU_PACKAGE_LICENSES")
+endif()
+
+# Description: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_DESCRIPTION)
+  if(NOT CPACK_PACKAGE_DESCRIPTION)
+	  message(FATAL_ERROR "CPackHaiku: Haiku package requires a description for a package, set CPACK_PACKAGE_DESCRIPTION or CPACK_HAIKU_PACKAGE_DESCRIPTION")
+  endif()
+  set(CPACK_HAIKU_PACKAGE_DESCRIPTION ${CPACK_PACKAGE_DESCRIPTION})
+endif()
+
+# Summary: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_DESCRIPTION_SUMMARY)
+	if(NOT CPACK_PACKAGE_DESCRIPTION_SUMMARY)
+		message(FATAL_ERROR "CPackHaiku: Haiku package requires a summary for a package, set CPACK_PACKAGE_DESCRIPTION_SUMMARY or CPACK_HAIKU_PACKAGE_DESCRIPTION_SUMMARY")
+  endif()
+  set(CPACK_HAIKU_PACKAGE_DESCRIPTION_SUMMARY ${CPACK_PACKAGE_DESCRIPTION_SUMMARY})
+endif()
+
+# Provides: (mandatory)
+if(NOT CPACK_HAIKU_PACKAGE_PROVIDES)
+	set(CPACK_HAIKU_PACKAGE_PROVIDES ${CPACK_HAIKU_PACKAGE_NAME})
+else()
+	set(CPACK_HAIKU_PACKAGE_PROVIDES ${CPACK_HAIKU_PACKAGE_NAME} ${CPACK_HAIKU_PACKAGE_PROVIDES})
+endif()
+
+# CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA
+# This variable allow advanced user to add custom script to the control.tar.gz (inside the .deb archive)
+# Typical examples are:
+# - conffiles
+# - postinst
+# - postrm
+# - prerm"
+# Usage:
+# set(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA
+#    "${CMAKE_CURRENT_SOURCE_DIR/prerm;${CMAKE_CURRENT_SOURCE_DIR}/postrm")
+
+# Are we packaging components ?
+if(CPACK_HAIKU_PACKAGE_COMPONENT)
+	set(CPACK_HAIKU_PACKAGE_COMPONENT_PART_NAME "_${CPACK_HAIKU_PACKAGE_COMPONENT}")
+	string(TOLOWER "${CPACK_PACKAGE_NAME}${CPACK_HAIKU_PACKAGE_COMPONENT_PART_NAME}" CPACK_HAIKU_PACKAGE_NAME)
+else()
+	set(CPACK_HAIKU_PACKAGE_COMPONENT_PART_NAME "")
+endif()
+
+set(WDIR "${CPACK_TOPLEVEL_DIRECTORY}/${CPACK_PACKAGE_FILE_NAME}${CPACK_HAIKU_PACKAGE_COMPONENT_PART_PATH}")
+
+# Print out some debug information if we were asked for that
+if(CPACK_HAIKU_PACKAGE_DEBUG)
+   message("CPackHpkg:Debug: CPACK_TOPLEVEL_DIRECTORY          = ${CPACK_TOPLEVEL_DIRECTORY}")
+   message("CPackHpkg:Debug: CPACK_TOPLEVEL_TAG                = ${CPACK_TOPLEVEL_TAG}")
+   message("CPackHpkg:Debug: CPACK_TEMPORARY_DIRECTORY         = ${CPACK_TEMPORARY_DIRECTORY}")
+   message("CPackHpkg:Debug: CPACK_OUTPUT_FILE_NAME            = ${CPACK_OUTPUT_FILE_NAME}")
+   message("CPackHpkg:Debug: CPACK_OUTPUT_FILE_PATH            = ${CPACK_OUTPUT_FILE_PATH}")
+   message("CPackHpkg:Debug: CPACK_PACKAGE_FILE_NAME           = ${CPACK_PACKAGE_FILE_NAME}")
+   message("CPackHpkg:Debug: CPACK_PACKAGE_INSTALL_DIRECTORY   = ${CPACK_PACKAGE_INSTALL_DIRECTORY}")
+   message("CPackHpkg:Debug: CPACK_TEMPORARY_PACKAGE_FILE_NAME = ${CPACK_TEMPORARY_PACKAGE_FILE_NAME}")
+endif()
+
diff --git a/Source/CPack/cmCPackGeneratorFactory.cxx b/Source/CPack/cmCPackGeneratorFactory.cxx
index b36c2a2..7d8f8a5 100644
--- a/Source/CPack/cmCPackGeneratorFactory.cxx
+++ b/Source/CPack/cmCPackGeneratorFactory.cxx
@@ -42,6 +42,10 @@
 #  include "WiX/cmCPackWIXGenerator.h"
 #endif
 
+#ifdef __HAIKU__
+#  include "cmCPackHpkgGenerator.h"
+#endif
+
 #include "cmCPackLog.h"
 
 #if defined(__BORLANDC__)
@@ -138,6 +142,13 @@ cmCPackGeneratorFactory::cmCPackGeneratorFactory()
       cmCPackRPMGenerator::CreateGenerator);
     }
 #endif
+#if defined(__HAIKU__)
+  if (cmCPackHpkgGenerator::CanGenerate())
+    {
+    this->RegisterGenerator("HPKG", "Haiku packages",
+      cmCPackHpkgGenerator::CreateGenerator);
+    }
+#endif
 }
 
 //----------------------------------------------------------------------
diff --git a/Source/CPack/cmCPackHpkgGenerator.cxx b/Source/CPack/cmCPackHpkgGenerator.cxx
new file mode 100644
index 0000000..f4933cf
--- /dev/null
+++ b/Source/CPack/cmCPackHpkgGenerator.cxx
@@ -0,0 +1,509 @@
+/*============================================================================
+  CMake - Cross Platform Makefile Generator
+  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium
+
+  Distributed under the OSI-approved BSD License (the "License");
+  see accompanying file Copyright.txt for details.
+
+  This software is distributed WITHOUT ANY WARRANTY; without even the
+  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+  See the License for more information.
+============================================================================*/
+#include "cmCPackHpkgGenerator.h"
+
+#include "cmSystemTools.h"
+#include "cmMakefile.h"
+#include "cmGeneratedFileStream.h"
+#include "cmCPackLog.h"
+
+#include <cmsys/SystemTools.hxx>
+#include <cmsys/Glob.hxx>
+
+#include <limits.h> // USHRT_MAX
+
+// NOTE:
+// Haiku .hpkg files are package using a custom compression and archive format.
+// The only way of creating them isusing the package tool provided with Haiku.
+
+//----------------------------------------------------------------------
+cmCPackHpkgGenerator::cmCPackHpkgGenerator()
+{
+}
+
+//----------------------------------------------------------------------
+cmCPackHpkgGenerator::~cmCPackHpkgGenerator()
+{
+}
+
+//----------------------------------------------------------------------
+int cmCPackHpkgGenerator::InitializeInternal()
+{
+  // Haiku packages are "rootless": the hierarchy inside them is relative to
+  // the package mount/install point.
+  this->SetOption("CPACK_PACKAGING_INSTALL_PREFIX", NULL);
+  if (cmSystemTools::IsOn(this->GetOption("CPACK_SET_DESTDIR")))
+    {
+    this->SetOption("CPACK_SET_DESTDIR", "I_OFF");
+    }
+  return this->Superclass::InitializeInternal();
+}
+
+//----------------------------------------------------------------------
+int cmCPackHpkgGenerator::PackageOnePack(std::string initialTopLevel,
+                                        std::string packageName)
+  {
+  int retval = 1;
+  // Begin the archive for this pack
+  std::string localToplevel(initialTopLevel);
+  std::string packageFileName(
+      cmSystemTools::GetParentDirectory(toplevel.c_str())
+  );
+  std::string outputFileName(
+      std::string(this->GetOption("CPACK_PACKAGE_FILE_NAME"))
+  +"_"+packageName + this->GetOutputExtension()
+  );
+
+  cmCPackLogger(cmCPackLog::LOG_DEBUG,
+    "Packaging " << outputFileName << std::endl);
+
+  localToplevel += "/"+ packageName;
+  /* replace the TEMP DIRECTORY with the component one */
+  this->SetOption("CPACK_TEMPORARY_DIRECTORY",localToplevel.c_str());
+  packageFileName += "/"+ outputFileName;
+  /* replace proposed CPACK_OUTPUT_FILE_NAME */
+  this->SetOption("CPACK_OUTPUT_FILE_NAME",outputFileName.c_str());
+  /* replace the TEMPORARY package file name */
+  this->SetOption("CPACK_TEMPORARY_PACKAGE_FILE_NAME",
+      packageFileName.c_str());
+  // Tell CPackHpkg.cmake the name of the component GROUP.
+  this->SetOption("CPACK_HAIKU_PACKAGE_COMPONENT",packageName.c_str());
+  // Tell CPackHpkg.cmake the path where the component is.
+  std::string component_path = "/";
+  component_path += packageName;
+  this->SetOption("CPACK_HAIKU_PACKAGE_COMPONENT_PART_PATH",
+                  component_path.c_str());
+  if (!this->ReadListFile("CPackHpkg.cmake"))
+    {
+    cmCPackLogger(cmCPackLog::LOG_ERROR,
+        "Error while execution CPackHpkg.cmake" << std::endl);
+    retval = 0;
+    return retval;
+    }
+
+  cmsys::Glob gl;
+  std::string findExpr(this->GetOption("WDIR"));
+  findExpr += "/*";
+  gl.RecurseOn();
+  if ( !gl.FindFiles(findExpr) )
+    {
+    cmCPackLogger(cmCPackLog::LOG_ERROR,
+        "Cannot find any files in the installed directory" << std::endl);
+    return 0;
+    }
+  packageFiles = gl.GetFiles();
+
+  int res = createHpkg(packageName);
+  if (res != 1)
+    {
+    retval = 0;
+    }
+  // add the generated package to package file names list
+  packageFileNames.push_back(packageFileName);
+  return retval;
+}
+
+//----------------------------------------------------------------------
+int cmCPackHpkgGenerator::PackageComponents(bool ignoreGroup)
+{
+  int retval = 1;
+  /* Reset package file name list it will be populated during the
+   * component packaging run*/
+  packageFileNames.clear();
+  std::string initialTopLevel(this->GetOption("CPACK_TEMPORARY_DIRECTORY"));
+
+  cmCPackLogger(cmCPackLog::LOG_DEBUG,
+    "Packaging in components mode" << std::endl);
+
+  // The default behavior is to have one package by component group
+  // unless CPACK_COMPONENTS_IGNORE_GROUP is specified.
+  if (!ignoreGroup)
+    {
+    std::map<std::string, cmCPackComponentGroup>::iterator compGIt;
+    for (compGIt=this->ComponentGroups.begin();
+        compGIt!=this->ComponentGroups.end(); ++compGIt)
+      {
+      cmCPackLogger(cmCPackLog::LOG_VERBOSE, "Packaging component group: "
+          << compGIt->first
+          << std::endl);
+      // Begin the archive for this group
+      retval &= PackageOnePack(initialTopLevel,compGIt->first);
+      }
+    // Handle Orphan components (components not belonging to any groups)
+    std::map<std::string, cmCPackComponent>::iterator compIt;
+    for (compIt=this->Components.begin();
+        compIt!=this->Components.end(); ++compIt )
+      {
+      // Does the component belong to a group?
+      if (compIt->second.Group==NULL)
+        {
+        cmCPackLogger(cmCPackLog::LOG_VERBOSE,
+            "Component <"
+            << compIt->second.Name
+            << "> does not belong to any group, package it separately."
+            << std::endl);
+        // Begin the archive for this orphan component
+        retval &= PackageOnePack(initialTopLevel,compIt->first);
+        }
+      }
+    }
+  // CPACK_COMPONENTS_IGNORE_GROUPS is set
+  // We build 1 package per component
+  else
+    {
+    cmCPackLogger(cmCPackLog::LOG_DEBUG,
+      "Groups are ignored" << std::endl);
+
+    std::map<std::string, cmCPackComponent>::iterator compIt;
+    for (compIt=this->Components.begin();
+         compIt!=this->Components.end(); ++compIt )
+      {
+      retval &= PackageOnePack(initialTopLevel,compIt->first);
+      }
+    }
+  return retval;
+}
+
+//----------------------------------------------------------------------
+int cmCPackHpkgGenerator::PackageComponentsAllInOne()
+{
+  int retval = 1;
+  std::string compInstDirName;
+  /* Reset package file name list it will be populated during the
+   * component packaging run*/
+  packageFileNames.clear();
+  std::string initialTopLevel(this->GetOption("CPACK_TEMPORARY_DIRECTORY"));
+
+  compInstDirName = "ALL_COMPONENTS_IN_ONE";
+
+  cmCPackLogger(cmCPackLog::LOG_VERBOSE,
+                "Packaging all groups in one package..."
+                "(CPACK_COMPONENTS_ALL_[GROUPS_]IN_ONE_PACKAGE is set)"
+      << std::endl);
+
+  cmCPackLogger(cmCPackLog::LOG_DEBUG,
+    "Packaging in all-in-one mode" << std::endl);
+
+  // The ALL GROUPS in ONE package case
+  std::string localToplevel(initialTopLevel);
+  std::string packageFileName(
+      cmSystemTools::GetParentDirectory(toplevel.c_str())
+                             );
+  std::string outputFileName(
+            std::string(this->GetOption("CPACK_PACKAGE_FILE_NAME"))
+            + this->GetOutputExtension()
+                            );
+  // all GROUP in one vs all COMPONENT in one
+  localToplevel += "/"+compInstDirName;
+
+  /* replace the TEMP DIRECTORY with the component one */
+  this->SetOption("CPACK_TEMPORARY_DIRECTORY",localToplevel.c_str());
+  packageFileName += "/"+ outputFileName;
+  /* replace proposed CPACK_OUTPUT_FILE_NAME */
+  this->SetOption("CPACK_OUTPUT_FILE_NAME",outputFileName.c_str());
+  /* replace the TEMPORARY package file name */
+  this->SetOption("CPACK_TEMPORARY_PACKAGE_FILE_NAME",
+      packageFileName.c_str());
+  // Tell CPackHpkg.cmake the path where the component is.
+  std::string component_path = "/";
+  component_path += compInstDirName;
+  this->SetOption("CPACK_HPKG_PACKAGE_COMPONENT_PART_PATH",
+                  component_path.c_str());
+  if (!this->ReadListFile("CPackHpkg.cmake"))
+    {
+    cmCPackLogger(cmCPackLog::LOG_ERROR,
+        "Error while execution CPackHpkg.cmake" << std::endl);
+    retval = 0;
+    return retval;
+    }
+
+  cmsys::Glob gl;
+  std::string findExpr(this->GetOption("WDIR"));
+  findExpr += "/*";
+  gl.RecurseOn();
+  if ( !gl.FindFiles(findExpr) )
+    {
+    cmCPackLogger(cmCPackLog::LOG_ERROR,
+    "Cannot find any files in the installed directory" << std::endl);
+    return 0;
+    }
+  packageFiles = gl.GetFiles();
+
+  int res = createHpkg();
+  if (res != 1)
+    {
+    retval = 0;
+    }
+  // add the generated package to package file names list
+  packageFileNames.push_back(packageFileName);
+  return retval;
+}
+
+//----------------------------------------------------------------------
+int cmCPackHpkgGenerator::PackageFiles()
+{
+  int retval = -1;
+
+  /* Are we in the component packaging case */
+  if (WantsComponentInstallation()) {
+    // CASE 1 : COMPONENT ALL-IN-ONE package
+    // If ALL GROUPS or ALL COMPONENTS in ONE package has been requested
+    // then the package file is unique and should be open here.
+    if (componentPackageMethod == ONE_PACKAGE)
+      {
+      return PackageComponentsAllInOne();
+      }
+    // CASE 2 : COMPONENT CLASSICAL package(s) (i.e. not all-in-one)
+    // There will be 1 package for each component group
+    // however one may require to ignore component group and
+    // in this case you'll get 1 package for each component.
+    else
+      {
+      return PackageComponents(componentPackageMethod ==
+                               ONE_PACKAGE_PER_COMPONENT);
+      }
+  }
+  // CASE 3 : NON COMPONENT package.
+  else
+    {
+    if (!this->ReadListFile("CPackHpkg.cmake"))
+      {
+      cmCPackLogger(cmCPackLog::LOG_ERROR,
+                    "Error while execution CPackHpkg.cmake" << std::endl);
+      retval = 0;
+      }
+    else
+      {
+      packageFiles = files;
+      return createHpkg();
+      }
+    }
+  return retval;
+}
+
+int cmCPackHpkgGenerator::createHpkg(std::string packageName)
+{
+  // .PackageInfo file
+  std::string infofilename;
+    infofilename = this->GetOption("WDIR");
+  infofilename += "/.PackageInfo";
+
+  std::string haiku_pkg_id = this->GetOption("CPACK_HAIKU_PACKAGE_NAME");
+  if(packageName == "Unspecified") {
+	  // Remove package specifier for the "unspecified" package
+	  haiku_pkg_id.erase(haiku_pkg_id.length() - packageName.length() - 1); 
+	  packageName = "";
+  } else if(packageName.length() > 0) {
+	  packageName += "_";
+  }
+  // haiku policy enforce lower case for package name
+  std::string haiku_pkg_name = cmsys::SystemTools::LowerCase(haiku_pkg_id);
+
+  // mandatory entries:
+  const char* haiku_pkg_version =
+                               this->GetOption("CPACK_HAIKU_PACKAGE_VERSION");
+  const char* haiku_pkg_revision =
+                               this->GetOption("CPACK_HAIKU_PACKAGE_REVISION");
+  const char* haiku_pkg_arch =
+                          this->GetOption("CPACK_HAIKU_PACKAGE_ARCHITECTURE");
+  const char* maintainer =  this->GetOption("CPACK_HAIKU_PACKAGE_PACKAGER");
+  const char* vendor =  this->GetOption("CPACK_HAIKU_PACKAGE_VENDOR");
+  const char* summary = this->GetOption("CPACK_HAIKU_PACKAGE_DESCRIPTION_SUMMARY");
+  const char* desc =       this->GetOption("CPACK_HAIKU_PACKAGE_DESCRIPTION");
+  const char* copyrights = this->GetOption("CPACK_HAIKU_PACKAGE_COPYRIGHT");
+  const char* haiku_pkg_licenses =
+                    this->GetOption("CPACK_HAIKU_PACKAGE_LICENSES");
+
+  // component-specific entries
+  std::string pkg_requires_option = "CPACK_HAIKU_" + packageName 
+    + "PACKAGE_REQUIRES";
+  const char* haiku_pkg_dep = this->GetOption(pkg_requires_option.c_str());
+  std::string pkg_provides_option = "CPACK_HAIKU_" + packageName
+    + "PACKAGE_PROVIDES";
+  const char* haiku_pkg_provides = this->GetOption(pkg_provides_option.c_str());
+
+  // optional entries
+  const char* haiku_pkg_url = this->GetOption("CPACK_HAIKU_PACKAGE_HOMEPAGE");
+  const char* haiku_pkg_enhances =
+                    this->GetOption("CPACK_HAIKU_PACKAGE_ENHANCES");
+  const char* haiku_pkg_conflicts =
+                    this->GetOption("CPACK_HAIKU_PACKAGE_CONFLICTS");
+  const char* haiku_pkg_replaces =
+                    this->GetOption("CPACK_HAIKU_PACKAGE_REPLACES");
+
+    { // the scope is needed for cmGeneratedFileStream
+    cmGeneratedFileStream out(infofilename.c_str());
+    out << "name " << haiku_pkg_name << "\n";
+    out << "version " << haiku_pkg_version << "-" << haiku_pkg_revision << "\n";
+    out << "architecture " << haiku_pkg_arch << "\n";
+    if(haiku_pkg_dep && *haiku_pkg_dep)
+      {
+      out << "requires {";
+      std::vector<std::string> requiresList;
+      cmSystemTools::ExpandListArgument(haiku_pkg_dep, requiresList);
+      for(std::vector<std::string>::iterator i =
+            requiresList.begin(); i != requiresList.end(); ++i)
+        {
+        out << *i << "\n";
+        }
+
+    out << "}\n";
+      }
+    if(haiku_pkg_url && *haiku_pkg_url)
+      {
+      out << "urls " << haiku_pkg_url << "\n";
+      }
+    if (haiku_pkg_enhances && *haiku_pkg_enhances)
+      {
+      out << "freshens " << haiku_pkg_enhances << "\n";
+      }
+    if (haiku_pkg_conflicts && *haiku_pkg_conflicts)
+      {
+      out << "conflicts " << haiku_pkg_conflicts << "\n";
+      }
+    if (haiku_pkg_replaces && *haiku_pkg_replaces)
+      {
+      out << "replaces " << haiku_pkg_replaces << "\n";
+      }
+
+    out << "provides {";
+    std::vector<std::string> providesList;
+    cmSystemTools::ExpandListArgument(haiku_pkg_provides, providesList);
+    for(std::vector<std::string>::iterator i =
+          providesList.begin(); i != providesList.end(); ++i)
+      {
+      out << *i << "\n";
+      }
+
+    out << "}\n";
+
+    out << "licenses {";
+    std::vector<std::string> licensesList;
+    cmSystemTools::ExpandListArgument(haiku_pkg_licenses, licensesList);
+    for(std::vector<std::string>::iterator i =
+          licensesList.begin(); i != licensesList.end(); ++i)
+      {
+      out << "\"" << *i << "\"\n";
+      }
+
+    out << "}\n";
+
+    out << "copyrights {\"" << copyrights << "\"}\n";
+    out << "packager " << maintainer << "\n";
+    out << "vendor \"" << vendor << "\"\n";
+    out << "summary \"" << summary << "\"\n";
+    out << "description \"" << desc << "\"\n";
+    out << std::endl;
+    }
+
+  std::string cmd;
+  if (NULL != this->GetOption("CPACK_HAIKU_FAKEROOT_EXECUTABLE")) {
+      cmd += this->GetOption("CPACK_HAIKU_FAKEROOT_EXECUTABLE");
+  }
+  cmd += "package create ";
+  cmd += this->GetOption("CPACK_TEMPORARY_PACKAGE_FILE_NAME");
+
+  std::string output;
+    int retval = -1;
+  int res = cmSystemTools::RunSingleCommand(cmd.c_str(), &output,
+      &retval, this->GetOption("WDIR"), this->GeneratorVerbose, 0);
+
+    if ( !res || retval )
+    {
+    std::string tmpFile = this->GetOption("CPACK_TOPLEVEL_DIRECTORY");
+    tmpFile += "/Hpkg.log";
+    cmGeneratedFileStream ofs(tmpFile.c_str());
+    ofs << "# Run command: " << cmd.c_str() << std::endl
+      << "# Working directory: " << toplevel << std::endl
+      << "# Output:" << std::endl
+      << output.c_str() << std::endl;
+    cmCPackLogger(cmCPackLog::LOG_ERROR, "Problem running package command: "
+      << cmd.c_str() << std::endl
+      << "Please check " << tmpFile.c_str() << " for errors" << std::endl);
+    return 0;
+    }
+
+    const char* infoExtra =
+      this->GetOption("CPACK_HAIKU_PACKAGE_INFO_EXTRA");
+  if( infoExtra )
+    {
+    std::vector<std::string> controlExtraList;
+    cmSystemTools::ExpandListArgument(infoExtra, controlExtraList);
+    for(std::vector<std::string>::iterator i =
+          controlExtraList.begin(); i != controlExtraList.end(); ++i)
+      {
+      std::string filenamename =
+        cmsys::SystemTools::GetFilenameName(i->c_str());
+      std::string localcopy = this->GetOption("WDIR");
+      localcopy += "/";
+      localcopy += filenamename;
+      // if we can copy the file, it means it does exist, let's add it:
+      if( cmsys::SystemTools::CopyFileIfDifferent(
+            i->c_str(), localcopy.c_str()) )
+        {
+        // haiku is picky and need relative to ./ path in the tar.gz
+        cmd += " ./";
+        cmd += filenamename;
+        }
+      }
+    }
+  res = cmSystemTools::RunSingleCommand(cmd.c_str(), &output,
+      &retval, this->GetOption("WDIR"), this->GeneratorVerbose, 0);
+
+    if ( !res || retval )
+    {
+    std::string tmpFile = this->GetOption("CPACK_TOPLEVEL_DIRECTORY");
+    tmpFile += "/Hpkg.log";
+    cmGeneratedFileStream ofs(tmpFile.c_str());
+    ofs << "# Run command: " << cmd.c_str() << std::endl
+      << "# Working directory: " << toplevel << std::endl
+      << "# Output:" << std::endl
+      << output.c_str() << std::endl;
+    cmCPackLogger(cmCPackLog::LOG_ERROR, "Problem running tar command: "
+      << cmd.c_str() << std::endl
+      << "Please check " << tmpFile.c_str() << " for errors" << std::endl);
+    return 0;
+    }
+
+  return 1;
+}
+
+bool cmCPackHpkgGenerator::SupportsComponentInstallation() const
+  {
+  return true;
+  }
+
+std::string cmCPackHpkgGenerator::GetComponentInstallDirNameSuffix(
+    const std::string& componentName)
+  {
+  if (componentPackageMethod == ONE_PACKAGE_PER_COMPONENT) {
+    return componentName;
+  }
+
+  if (componentPackageMethod == ONE_PACKAGE) {
+    return std::string("ALL_COMPONENTS_IN_ONE");
+  }
+  // We have to find the name of the COMPONENT GROUP
+  // the current COMPONENT belongs to.
+  std::string groupVar = "CPACK_COMPONENT_" +
+        cmSystemTools::UpperCase(componentName) + "_GROUP";
+    if (NULL != GetOption(groupVar.c_str()))
+      {
+      return std::string(GetOption(groupVar.c_str()));
+      }
+    else
+      {
+      return componentName;
+      }
+  }
+
+
diff --git a/Source/CPack/cmCPackHpkgGenerator.h b/Source/CPack/cmCPackHpkgGenerator.h
new file mode 100644
index 0000000..ffa803d
--- /dev/null
+++ b/Source/CPack/cmCPackHpkgGenerator.h
@@ -0,0 +1,82 @@
+/*============================================================================
+  CMake - Cross Platform Makefile Generator
+  Copyright 2000-2013 Kitware, Inc.
+
+  Distributed under the OSI-approved BSD License (the "License");
+  see accompanying file Copyright.txt for details.
+
+  This software is distributed WITHOUT ANY WARRANTY; without even the
+  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+  See the License for more information.
+============================================================================*/
+
+#ifndef cmCPackHpkgGenerator_h
+#define cmCPackHpkgGenerator_h
+
+
+#include "cmCPackGenerator.h"
+
+/** \class cmCPackHpkgGenerator
+ * \brief A generator for Haiku packages
+ *
+ */
+class cmCPackHpkgGenerator : public cmCPackGenerator
+{
+public:
+  cmCPackTypeMacro(cmCPackHpkgGenerator, cmCPackGenerator);
+
+  /**
+   * Construct generator
+   */
+  cmCPackHpkgGenerator();
+  virtual ~cmCPackHpkgGenerator();
+
+  static bool CanGenerate()
+    {
+#ifdef __HAIKU__
+    return true;
+#else
+    // Sorry! Need the "package" tool from Haiku!
+    return false;
+#endif
+    }
+
+protected:
+  virtual int InitializeInternal();
+  /**
+   * This method factors out the work done in component packaging case.
+   */
+  int PackageOnePack(std::string initialToplevel, std::string packageName);
+  /**
+   * The method used to package files when component
+   * install is used. This will create one
+   * archive for each component group.
+   */
+  int PackageComponents(bool ignoreGroup);
+  /**
+   * Special case of component install where all
+   * components will be put in a single installer.
+   */
+  int PackageComponentsAllInOne();
+  virtual int PackageFiles();
+  virtual const char* GetOutputExtension() { return ".hpkg"; }
+  virtual enum CPackSetDestdirSupport SupportsSetDestdir() const
+    {
+    return SETDESTDIR_UNSUPPORTED;
+    }
+
+  virtual bool SupportsAbsoluteDestination() const
+    {
+    return false;
+    }
+  virtual bool SupportsComponentInstallation() const;
+  virtual std::string GetComponentInstallDirNameSuffix(
+      const std::string& componentName);
+
+private:
+  int createHpkg(std::string packageName = "");
+  std::vector<std::string> packageFiles;
+
+};
+
+#endif
-- 
1.8.3.4


From 4c66402a7b630969a74878a90af03c72edce3844 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Tue, 12 Nov 2013 15:15:33 +0100
Subject: Remove remaining references to "common" directory.


diff --git a/Modules/Platform/Haiku.cmake b/Modules/Platform/Haiku.cmake
index 825f851..a3ebe24 100644
--- a/Modules/Platform/Haiku.cmake
+++ b/Modules/Platform/Haiku.cmake
@@ -53,14 +53,12 @@ else()
 endif()
 
 list(APPEND CMAKE_SYSTEM_PREFIX_PATH
-  /boot/common/non-packaged
-  /boot/common
+  /boot/system/non-packaged
   /boot/system
   )
 
 LIST(APPEND CMAKE_HAIKU_COMMON_INCLUDE_DIRECTORIES
-  /boot/common/non-packaged/develop/headers${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
-  /boot/common/develop/headers${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  /boot/system/non-packaged/develop/headers${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
   /boot/system/develop/headers/os
   /boot/system/develop/headers/os/app
   /boot/system/develop/headers/os/device
@@ -108,8 +106,7 @@ LIST(APPEND CMAKE_HAIKU_CXX_INCLUDE_DIRECTORIES
 LIST(APPEND CMAKE_SYSTEM_INCLUDE_PATH ${CMAKE_HAIKU_C_INCLUDE_DIRECTORIES})
 
 LIST(APPEND CMAKE_HAIKU_DEVELOP_LIB_DIRECTORIES
-  /boot/common/non-packaged/develop/lib${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
-  /boot/common/develop/lib${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
+  /boot/system/non-packaged/develop/lib${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
   /boot/system/develop/lib${CMAKE_HAIKU_SECONDARY_ARCH_SUBDIR}
   )
 
@@ -120,6 +117,6 @@ LIST(APPEND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES
 LIST(APPEND CMAKE_SYSTEM_LIBRARY_PATH ${CMAKE_HAIKU_DEVELOP_LIB_DIRECTORIES})
 
 if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
-  set(CMAKE_INSTALL_PREFIX "/boot/common" CACHE PATH
+  set(CMAKE_INSTALL_PREFIX "/boot/system" CACHE PATH
     "Install path prefix, prepended onto install directories." FORCE)
 endif()
-- 
1.8.3.4


From 95e14820c12369366cffae5050efabebf5b51c0d Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Tue, 12 Nov 2013 15:48:13 +0100
Subject: Fix compiler detection when distcc is involved

cmake will set CMAKE_CXX_COMPILER to "distcc" and put the actual compiler
into another variable, with other arguments. Append CMAKE_CXX_COMPILER_ARG1
to our compiler invocation to take this into account.

diff --git a/Modules/Platform/Haiku.cmake b/Modules/Platform/Haiku.cmake
index a3ebe24..dd4c55e 100644
--- a/Modules/Platform/Haiku.cmake
+++ b/Modules/Platform/Haiku.cmake
@@ -21,18 +21,25 @@ set(CMAKE_EXE_EXPORTS_C_FLAG "-Wl,--export-dynamic")
 # "/boot/system/develop/lib/<subdir>/", which we assume to be the secondary
 # architecture specific subdirectory and extract the name of the architecture
 # accordingly.
-set(__HAIKU_COMPILER ${CMAKE_C_COMPILER})
 
-if(NOT __HAIKU_COMPILER)
-  set(__HAIKU_COMPILER ${CMAKE_CXX_COMPILER})
+# First of all, find a C or C++ compiler we can run. The "arg1" is necessary
+# here for compilers such as "distcc gcc-x86" or "ccache gcc-x86"
+# TODO See CMakeDetermineCompilerId.cmake for some more things we may want to do.
+if(CMAKE_C_COMPILER)
+	set(__HAIKU_COMPILER ${CMAKE_C_COMPILER})
+	string (STRIP "${CMAKE_C_COMPILER_ARG1}" __HAIKU_COMPILER_FLAGS)
+else()
+	set(__HAIKU_COMPILER ${CMAKE_CXX_COMPILER})
+	string (STRIP "${CMAKE_CXX_COMPILER_ARG1}" __HAIKU_COMPILER_FLAGS)
 endif()
 
 execute_process(
-  COMMAND ${__HAIKU_COMPILER} -print-search-dirs
+	COMMAND ${__HAIKU_COMPILER} ${__HAIKU_COMPILER_FLAGS} -print-search-dirs
   OUTPUT_VARIABLE _HAIKU_SEARCH_DIRS
+  RESULT_VARIABLE _HAIKU_SEARCH_DIRS_FOUND
   OUTPUT_STRIP_TRAILING_WHITESPACE)
 
-string(REGEX MATCH ".*\nlibraries: =?([^\n]*:)?/boot/system/develop/lib/([^/]*)/(:[^\n]*)?\n.*" _dummy "\n${_HAIKU_SEARCH_DIRS}\n")
+string(REGEX MATCH "libraries: =?([^\n]*:)?/boot/system/develop/lib/([^/]*)/(:[^\n]*)?" _dummy "${_HAIKU_SEARCH_DIRS}")
 set(CMAKE_HAIKU_SECONDARY_ARCH "${CMAKE_MATCH_2}")
 
 if(NOT CMAKE_HAIKU_SECONDARY_ARCH)
-- 
1.8.3.4


From 748a5f0f1db2efaf411655206b74a85f9417a9c9 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Fri, 22 Nov 2013 17:49:55 +0100
Subject: CPack: fix architecture detection and packager check

CPack can't access CMake compiler settings directly, as it is run in a
different context. Try getting data we export ourselves from the
platform script, and when that doesn't work, fail with a message.

diff --git a/Modules/CPackHpkg.cmake b/Modules/CPackHpkg.cmake
index 3308889..9b6917f 100644
--- a/Modules/CPackHpkg.cmake
+++ b/Modules/CPackHpkg.cmake
@@ -197,11 +197,11 @@ endif()
 
 # Architecture: (mandatory)
 if(NOT CPACK_HAIKU_PACKAGE_ARCHITECTURE)
-  if(CMAKE_C_COMPILER_VERSION VERSION_LESS 3.0)
-    set(CPACK_HAIKU_PACKAGE_ARCHITECTURE "x86_gcc2")
-  else()
-	  set(CPACK_HAIKU_PACKAGE_ARCHITECTURE $ENV{BE_HOST_CPU})
+  if(NOT CMAKE_HAIKU_ARCHITECTURE)
+	message(FATAL_ERROR "CPackHpkg: Please set CPACK_HAIKU_PACKAGE_ARCHITECTURE or CMAKE_HAIKU_ARCHITECTURE")
   endif()
+
+  set(CPACK_HAIKU_PACKAGE_ARCHITECTURE "${CMAKE_HAIKU_ARCHITECTURE}")
 endif()
 
 # have a look at get_property(result GLOBAL PROPERTY ENABLED_FEATURES),
@@ -216,9 +216,9 @@ endif()
 # Maintainer: (mandatory)
 if(NOT CPACK_HAIKU_PACKAGE_PACKAGER)
   if(NOT CPACK_PACKAGE_CONTACT)
-	  message(FATAL_ERROR "CPackHpkg: Haiku package requires a maintainer, set CPACK_PACKAGE_CONTACT or CPACK_HAIKU_PACKAGE_PACKAGER")
+	  message(FATAL_ERROR "CPackHpkg: Haiku package requires a packager, set CPACK_PACKAGE_CONTACT or CPACK_HAIKU_PACKAGE_PACKAGER")
   endif()
-  set(CPACK_HAIKU_PACKAGE_MAINTAINER ${CPACK_PACKAGE_PACKAGER})
+  set(CPACK_HAIKU_PACKAGE_PACKAGER ${CPACK_PACKAGE_CONTACT})
 endif()
 
 # Vendor: (mandatory)
diff --git a/Modules/Platform/Haiku.cmake b/Modules/Platform/Haiku.cmake
index dd4c55e..36576d1 100644
--- a/Modules/Platform/Haiku.cmake
+++ b/Modules/Platform/Haiku.cmake
@@ -39,7 +39,7 @@ execute_process(
   RESULT_VARIABLE _HAIKU_SEARCH_DIRS_FOUND
   OUTPUT_STRIP_TRAILING_WHITESPACE)
 
-string(REGEX MATCH "libraries: =?([^\n]*:)?/boot/system/develop/lib/([^/]*)/(:[^\n]*)?" _dummy "${_HAIKU_SEARCH_DIRS}")
+string(REGEX MATCH "libraries: =?([^\n]*:)?/boot/system/develop/lib/([^/]*)/[:^\n]" _dummy "${_HAIKU_SEARCH_DIRS}")
 set(CMAKE_HAIKU_SECONDARY_ARCH "${CMAKE_MATCH_2}")
 
 if(NOT CMAKE_HAIKU_SECONDARY_ARCH)
@@ -59,6 +59,14 @@ else()
   set(CMAKE_CXX_LIBRARY_ARCHITECTURE ${CMAKE_HAIKU_SECONDARY_ARCH})
 endif()
 
+if(CMAKE_C_COMPILER_VERSION)
+  if(CMAKE_C_COMPILER_VERSION VERSION_LESS 3.0)
+	set(CMAKE_HAIKU_ARCHITECTURE "x86_gcc2")
+  else()
+	set(CMAKE_HAIKU_ARCHITECTURE "$ENV{BE_HOST_CPU}")
+  endif()
+endif()
+
 list(APPEND CMAKE_SYSTEM_PREFIX_PATH
   /boot/system/non-packaged
   /boot/system
-- 
1.8.3.4

