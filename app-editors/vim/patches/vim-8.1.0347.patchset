From: Ken Mays <kmays2000@gmail.com>
Date: Tue Sep  4 20:43:27 GMT 2018
Subject: Patchset for vim 8.1

Previous vim 8.0.x patches from:
Zoltar Mizsei <zmizsei@extrowerk.com>

diff --git a/runtime/doc/eval.txt b/runtime/doc/eval.txt
index 6408165..8b82c2b 100644
--- a/runtime/doc/eval.txt
+++ b/runtime/doc/eval.txt
@@ -9384,12 +9384,14 @@ gui_gnome		Compiled with Gnome support (gui_gtk is also defined).
 gui_gtk			Compiled with GTK+ GUI (any version).
 gui_gtk2		Compiled with GTK+ 2 GUI (gui_gtk is also defined).
 gui_gtk3		Compiled with GTK+ 3 GUI (gui_gtk is also defined).
+gui_haiku		Compiled with Haiku GUI.
 gui_mac			Compiled with Macintosh GUI.
 gui_motif		Compiled with Motif GUI.
 gui_photon		Compiled with Photon GUI.
 gui_running		Vim is running in the GUI, or it will start soon.
 gui_win32		Compiled with MS Windows Win32 GUI.
 gui_win32s		idem, and Win32s system being used (Windows 3.1)
+haiku			Haiku version of Vim.
 hangul_input		Compiled with Hangul input support. |hangul|
 iconv			Can use iconv() for conversion.
 insert_expand		Compiled with support for CTRL-X expansion commands in
diff --git a/b/runtime/doc/eval.txt.orig b/runtime/doc/eval.txt.orig
new file mode 100644
index 0000000..6408165
--- /dev/null
+++ b/runtime/doc/eval.txt.orig
@@ -0,0 +1,11717 @@
+*eval.txt*	For Vim version 8.1.  Last change: 2018 May 17
+
+
+		  VIM REFERENCE MANUAL	  by Bram Moolenaar
+
+
+Expression evaluation			*expression* *expr* *E15* *eval*
+
+Using expressions is introduced in chapter 41 of the user manual |usr_41.txt|.
+
+Note: Expression evaluation can be disabled at compile time.  If this has been
+done, the features in this document are not available.  See |+eval| and
+|no-eval-feature|.
+
+1.  Variables			|variables|
+    1.1 Variable types
+    1.2 Function references		|Funcref|
+    1.3 Lists				|Lists|
+    1.4 Dictionaries			|Dictionaries|
+    1.5 More about variables		|more-variables|
+2.  Expression syntax		|expression-syntax|
+3.  Internal variable		|internal-variables|
+4.  Builtin Functions		|functions|
+5.  Defining functions		|user-functions|
+6.  Curly braces names		|curly-braces-names|
+7.  Commands			|expression-commands|
+8.  Exception handling		|exception-handling|
+9.  Examples			|eval-examples|
+10. No +eval feature		|no-eval-feature|
+11. The sandbox			|eval-sandbox|
+12. Textlock			|textlock|
+13. Testing			|testing|
+
+{Vi does not have any of these commands}
+
+==============================================================================
+1. Variables						*variables*
+
+1.1 Variable types ~
+							*E712*
+There are nine types of variables:
+
+Number		A 32 or 64 bit signed number.  |expr-number| *Number*
+		64-bit Numbers are available only when compiled with the
+		|+num64| feature.
+		Examples:  -123  0x10  0177  0b1011
+
+Float		A floating point number. |floating-point-format| *Float*
+		{only when compiled with the |+float| feature}
+		Examples: 123.456  1.15e-6  -1.1e3
+
+							*E928*
+String		A NUL terminated string of 8-bit unsigned characters (bytes).
+		|expr-string| Examples: "ab\txx\"--"  'x-z''a,c'
+
+List		An ordered sequence of items |List|.
+		Example: [1, 2, ['a', 'b']]
+
+Dictionary	An associative, unordered array: Each entry has a key and a
+		value. |Dictionary|
+		Example: {'blue': "#0000ff", 'red': "#ff0000"}
+
+Funcref		A reference to a function |Funcref|.
+		Example: function("strlen")
+		It can be bound to a dictionary and arguments, it then works
+		like a Partial.
+		Example: function("Callback", [arg], myDict)
+
+Special		|v:false|, |v:true|, |v:none| and |v:null|.  *Special*
+
+Job		Used for a job, see |job_start()|. *Job* *Jobs*
+
+Channel		Used for a channel, see |ch_open()|. *Channel* *Channels*
+
+The Number and String types are converted automatically, depending on how they
+are used.
+
+Conversion from a Number to a String is by making the ASCII representation of
+the Number.  Examples:
+	Number 123	-->	String "123" ~
+	Number 0	-->	String "0" ~
+	Number -1	-->	String "-1" ~
+							*octal*
+Conversion from a String to a Number is done by converting the first digits to
+a number.  Hexadecimal "0xf9", Octal "017", and Binary "0b10" numbers are
+recognized.  If the String doesn't start with digits, the result is zero.
+Examples:
+	String "456"	-->	Number 456 ~
+	String "6bar"	-->	Number 6 ~
+	String "foo"	-->	Number 0 ~
+	String "0xf1"	-->	Number 241 ~
+	String "0100"	-->	Number 64 ~
+	String "0b101"	-->	Number 5 ~
+	String "-8"	-->	Number -8 ~
+	String "+8"	-->	Number 0 ~
+
+To force conversion from String to Number, add zero to it: >
+	:echo "0100" + 0
+<	64 ~
+
+To avoid a leading zero to cause octal conversion, or for using a different
+base, use |str2nr()|.
+
+							*TRUE* *FALSE*
+For boolean operators Numbers are used.  Zero is FALSE, non-zero is TRUE.
+You can also use |v:false| and |v:true|.  When TRUE is returned from a
+function it is the Number one, FALSE is the number zero.
+
+Note that in the command: >
+	:if "foo"
+	:" NOT executed
+"foo" is converted to 0, which means FALSE.  If the string starts with a
+non-zero number it means TRUE: >
+	:if "8foo"
+	:" executed
+To test for a non-empty string, use empty(): >
+	:if !empty("foo")
+<
+							*non-zero-arg*
+Function arguments often behave slightly different from |TRUE|: If the
+argument is present and it evaluates to a non-zero Number, |v:true| or a
+non-empty String, then the value is considered to be TRUE.
+Note that " " and "0" are also non-empty strings, thus considered to be TRUE.
+A List, Dictionary or Float is not a Number or String, thus evaluate to FALSE.
+
+		*E745* *E728* *E703* *E729* *E730* *E731* *E908* *E910* *E913*
+List, Dictionary, Funcref, Job and Channel types are not automatically
+converted.
+
+							*E805* *E806* *E808*
+When mixing Number and Float the Number is converted to Float.  Otherwise
+there is no automatic conversion of Float.  You can use str2float() for String
+to Float, printf() for Float to String and float2nr() for Float to Number.
+
+			*E891* *E892* *E893* *E894* *E907* *E911* *E914*
+When expecting a Float a Number can also be used, but nothing else.
+
+						*no-type-checking*
+You will not get an error if you try to change the type of a variable.
+
+
+1.2 Function references ~
+					*Funcref* *E695* *E718*
+A Funcref variable is obtained with the |function()| function, the |funcref()|
+function or created with the lambda expression |expr-lambda|.  It can be used
+in an expression in the place of a function name, before the parenthesis
+around the arguments, to invoke the function it refers to.  Example: >
+
+	:let Fn = function("MyFunc")
+	:echo Fn()
+<							*E704* *E705* *E707*
+A Funcref variable must start with a capital, "s:", "w:", "t:" or "b:".  You
+can use "g:" but the following name must still start with a capital.  You
+cannot have both a Funcref variable and a function with the same name.
+
+A special case is defining a function and directly assigning its Funcref to a
+Dictionary entry.  Example: >
+	:function dict.init() dict
+	:   let self.val = 0
+	:endfunction
+
+The key of the Dictionary can start with a lower case letter.  The actual
+function name is not used here.  Also see |numbered-function|.
+
+A Funcref can also be used with the |:call| command: >
+	:call Fn()
+	:call dict.init()
+
+The name of the referenced function can be obtained with |string()|. >
+	:let func = string(Fn)
+
+You can use |call()| to invoke a Funcref and use a list variable for the
+arguments: >
+	:let r = call(Fn, mylist)
+<
+								*Partial*
+A Funcref optionally binds a Dictionary and/or arguments.  This is also called
+a Partial.  This is created by passing the Dictionary and/or arguments to
+function() or funcref().  When calling the function the Dictionary and/or
+arguments will be passed to the function.  Example: >
+
+	let Cb = function('Callback', ['foo'], myDict)
+	call Cb()
+
+This will invoke the function as if using: >
+	call myDict.Callback('foo')
+
+This is very useful when passing a function around, e.g. in the arguments of
+|ch_open()|.
+
+Note that binding a function to a Dictionary also happens when the function is
+a member of the Dictionary: >
+
+	let myDict.myFunction = MyFunction
+	call myDict.myFunction()
+
+Here MyFunction() will get myDict passed as "self".  This happens when the
+"myFunction" member is accessed.  When making assigning "myFunction" to
+otherDict and calling it, it will be bound to otherDict: >
+
+	let otherDict.myFunction = myDict.myFunction
+	call otherDict.myFunction()
+
+Now "self" will be "otherDict".  But when the dictionary was bound explicitly
+this won't happen: >
+
+	let myDict.myFunction = function(MyFunction, myDict)
+	let otherDict.myFunction = myDict.myFunction
+	call otherDict.myFunction()
+
+Here "self" will be "myDict", because it was bound explicitly.
+
+
+1.3 Lists ~
+						*list* *List* *Lists* *E686*
+A List is an ordered sequence of items.  An item can be of any type.  Items
+can be accessed by their index number.  Items can be added and removed at any
+position in the sequence.
+
+
+List creation ~
+							*E696* *E697*
+A List is created with a comma separated list of items in square brackets.
+Examples: >
+	:let mylist = [1, two, 3, "four"]
+	:let emptylist = []
+
+An item can be any expression.  Using a List for an item creates a
+List of Lists: >
+	:let nestlist = [[11, 12], [21, 22], [31, 32]]
+
+An extra comma after the last item is ignored.
+
+
+List index ~
+							*list-index* *E684*
+An item in the List can be accessed by putting the index in square brackets
+after the List.  Indexes are zero-based, thus the first item has index zero. >
+	:let item = mylist[0]		" get the first item: 1
+	:let item = mylist[2]		" get the third item: 3
+
+When the resulting item is a list this can be repeated: >
+	:let item = nestlist[0][1]	" get the first list, second item: 12
+<
+A negative index is counted from the end.  Index -1 refers to the last item in
+the List, -2 to the last but one item, etc. >
+	:let last = mylist[-1]		" get the last item: "four"
+
+To avoid an error for an invalid index use the |get()| function.  When an item
+is not available it returns zero or the default value you specify: >
+	:echo get(mylist, idx)
+	:echo get(mylist, idx, "NONE")
+
+
+List concatenation ~
+
+Two lists can be concatenated with the "+" operator: >
+	:let longlist = mylist + [5, 6]
+	:let mylist += [7, 8]
+
+To prepend or append an item turn the item into a list by putting [] around
+it.  To change a list in-place see |list-modification| below.
+
+
+Sublist ~
+							*sublist*
+A part of the List can be obtained by specifying the first and last index,
+separated by a colon in square brackets: >
+	:let shortlist = mylist[2:-1]	" get List [3, "four"]
+
+Omitting the first index is similar to zero.  Omitting the last index is
+similar to -1. >
+	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]
+	:let shortlist = mylist[2:2]	" List with one item: [3]
+	:let otherlist = mylist[:]	" make a copy of the List
+
+If the first index is beyond the last item of the List or the second item is
+before the first item, the result is an empty list.  There is no error
+message.
+
+If the second index is equal to or greater than the length of the list the
+length minus one is used: >
+	:let mylist = [0, 1, 2, 3]
+	:echo mylist[2:8]		" result: [2, 3]
+
+NOTE: mylist[s:e] means using the variable "s:e" as index.  Watch out for
+using a single letter variable before the ":".  Insert a space when needed:
+mylist[s : e].
+
+
+List identity ~
+							*list-identity*
+When variable "aa" is a list and you assign it to another variable "bb", both
+variables refer to the same list.  Thus changing the list "aa" will also
+change "bb": >
+	:let aa = [1, 2, 3]
+	:let bb = aa
+	:call add(aa, 4)
+	:echo bb
+<	[1, 2, 3, 4]
+
+Making a copy of a list is done with the |copy()| function.  Using [:] also
+works, as explained above.  This creates a shallow copy of the list: Changing
+a list item in the list will also change the item in the copied list: >
+	:let aa = [[1, 'a'], 2, 3]
+	:let bb = copy(aa)
+	:call add(aa, 4)
+	:let aa[0][1] = 'aaa'
+	:echo aa
+<	[[1, aaa], 2, 3, 4] >
+	:echo bb
+<	[[1, aaa], 2, 3]
+
+To make a completely independent list use |deepcopy()|.  This also makes a
+copy of the values in the list, recursively.  Up to a hundred levels deep.
+
+The operator "is" can be used to check if two variables refer to the same
+List.  "isnot" does the opposite.  In contrast "==" compares if two lists have
+the same value. >
+	:let alist = [1, 2, 3]
+	:let blist = [1, 2, 3]
+	:echo alist is blist
+<	0 >
+	:echo alist == blist
+<	1
+
+Note about comparing lists: Two lists are considered equal if they have the
+same length and all items compare equal, as with using "==".  There is one
+exception: When comparing a number with a string they are considered
+different.  There is no automatic type conversion, as with using "==" on
+variables.  Example: >
+	echo 4 == "4"
+<	1 >
+	echo [4] == ["4"]
+<	0
+
+Thus comparing Lists is more strict than comparing numbers and strings.  You
+can compare simple values this way too by putting them in a list: >
+
+	:let a = 5
+	:let b = "5"
+	:echo a == b
+<	1 >
+	:echo [a] == [b]
+<	0
+
+
+List unpack ~
+
+To unpack the items in a list to individual variables, put the variables in
+square brackets, like list items: >
+	:let [var1, var2] = mylist
+
+When the number of variables does not match the number of items in the list
+this produces an error.  To handle any extra items from the list append ";"
+and a variable name: >
+	:let [var1, var2; rest] = mylist
+
+This works like: >
+	:let var1 = mylist[0]
+	:let var2 = mylist[1]
+	:let rest = mylist[2:]
+
+Except that there is no error if there are only two items.  "rest" will be an
+empty list then.
+
+
+List modification ~
+							*list-modification*
+To change a specific item of a list use |:let| this way: >
+	:let list[4] = "four"
+	:let listlist[0][3] = item
+
+To change part of a list you can specify the first and last item to be
+modified.  The value must at least have the number of items in the range: >
+	:let list[3:5] = [3, 4, 5]
+
+Adding and removing items from a list is done with functions.  Here are a few
+examples: >
+	:call insert(list, 'a')		" prepend item 'a'
+	:call insert(list, 'a', 3)	" insert item 'a' before list[3]
+	:call add(list, "new")		" append String item
+	:call add(list, [1, 2])		" append a List as one new item
+	:call extend(list, [1, 2])	" extend the list with two more items
+	:let i = remove(list, 3)	" remove item 3
+	:unlet list[3]			" idem
+	:let l = remove(list, 3, -1)	" remove items 3 to last item
+	:unlet list[3 : ]		" idem
+	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'
+
+Changing the order of items in a list: >
+	:call sort(list)		" sort a list alphabetically
+	:call reverse(list)		" reverse the order of items
+	:call uniq(sort(list))		" sort and remove duplicates
+
+
+For loop ~
+
+The |:for| loop executes commands for each item in a list.  A variable is set
+to each item in the list in sequence.  Example: >
+	:for item in mylist
+	:   call Doit(item)
+	:endfor
+
+This works like: >
+	:let index = 0
+	:while index < len(mylist)
+	:   let item = mylist[index]
+	:   :call Doit(item)
+	:   let index = index + 1
+	:endwhile
+
+If all you want to do is modify each item in the list then the |map()|
+function will be a simpler method than a for loop.
+
+Just like the |:let| command, |:for| also accepts a list of variables.  This
+requires the argument to be a list of lists. >
+	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]
+	:   call Doit(lnum, col)
+	:endfor
+
+This works like a |:let| command is done for each list item.  Again, the types
+must remain the same to avoid an error.
+
+It is also possible to put remaining items in a List variable: >
+	:for [i, j; rest] in listlist
+	:   call Doit(i, j)
+	:   if !empty(rest)
+	:      echo "remainder: " . string(rest)
+	:   endif
+	:endfor
+
+
+List functions ~
+						*E714*
+Functions that are useful with a List: >
+	:let r = call(funcname, list)	" call a function with an argument list
+	:if empty(list)			" check if list is empty
+	:let l = len(list)		" number of items in list
+	:let big = max(list)		" maximum value in list
+	:let small = min(list)		" minimum value in list
+	:let xs = count(list, 'x')	" count nr of times 'x' appears in list
+	:let i = index(list, 'x')	" index of first 'x' in list
+	:let lines = getline(1, 10)	" get ten text lines from buffer
+	:call append('$', lines)	" append text lines in buffer
+	:let list = split("a b c")	" create list from items in a string
+	:let string = join(list, ', ')	" create string from list items
+	:let s = string(list)		" String representation of list
+	:call map(list, '">> " . v:val')  " prepend ">> " to each item
+
+Don't forget that a combination of features can make things simple.  For
+example, to add up all the numbers in a list: >
+	:exe 'let sum = ' . join(nrlist, '+')
+
+
+1.4 Dictionaries ~
+					*dict* *Dictionaries* *Dictionary*
+A Dictionary is an associative array: Each entry has a key and a value.  The
+entry can be located with the key.  The entries are stored without a specific
+ordering.
+
+
+Dictionary creation ~
+						*E720* *E721* *E722* *E723*
+A Dictionary is created with a comma separated list of entries in curly
+braces.  Each entry has a key and a value, separated by a colon.  Each key can
+only appear once.  Examples: >
+	:let mydict = {1: 'one', 2: 'two', 3: 'three'}
+	:let emptydict = {}
+<							*E713* *E716* *E717*
+A key is always a String.  You can use a Number, it will be converted to a
+String automatically.  Thus the String '4' and the number 4 will find the same
+entry.  Note that the String '04' and the Number 04 are different, since the
+Number will be converted to the String '4'.  The empty string can be used as a
+key.
+
+A value can be any expression.  Using a Dictionary for a value creates a
+nested Dictionary: >
+	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}
+
+An extra comma after the last entry is ignored.
+
+
+Accessing entries ~
+
+The normal way to access an entry is by putting the key in square brackets: >
+	:let val = mydict["one"]
+	:let mydict["four"] = 4
+
+You can add new entries to an existing Dictionary this way, unlike Lists.
+
+For keys that consist entirely of letters, digits and underscore the following
+form can be used |expr-entry|: >
+	:let val = mydict.one
+	:let mydict.four = 4
+
+Since an entry can be any type, also a List and a Dictionary, the indexing and
+key lookup can be repeated: >
+	:echo dict.key[idx].key
+
+
+Dictionary to List conversion ~
+
+You may want to loop over the entries in a dictionary.  For this you need to
+turn the Dictionary into a List and pass it to |:for|.
+
+Most often you want to loop over the keys, using the |keys()| function: >
+	:for key in keys(mydict)
+	:   echo key . ': ' . mydict[key]
+	:endfor
+
+The List of keys is unsorted.  You may want to sort them first: >
+	:for key in sort(keys(mydict))
+
+To loop over the values use the |values()| function:  >
+	:for v in values(mydict)
+	:   echo "value: " . v
+	:endfor
+
+If you want both the key and the value use the |items()| function.  It returns
+a List in which each item is a	List with two items, the key and the value: >
+	:for [key, value] in items(mydict)
+	:   echo key . ': ' . value
+	:endfor
+
+
+Dictionary identity ~
+							*dict-identity*
+Just like Lists you need to use |copy()| and |deepcopy()| to make a copy of a
+Dictionary.  Otherwise, assignment results in referring to the same
+Dictionary: >
+	:let onedict = {'a': 1, 'b': 2}
+	:let adict = onedict
+	:let adict['a'] = 11
+	:echo onedict['a']
+	11
+
+Two Dictionaries compare equal if all the key-value pairs compare equal.  For
+more info see |list-identity|.
+
+
+Dictionary modification ~
+							*dict-modification*
+To change an already existing entry of a Dictionary, or to add a new entry,
+use |:let| this way: >
+	:let dict[4] = "four"
+	:let dict['one'] = item
+
+Removing an entry from a Dictionary is done with |remove()| or |:unlet|.
+Three ways to remove the entry with key "aaa" from dict: >
+	:let i = remove(dict, 'aaa')
+	:unlet dict.aaa
+	:unlet dict['aaa']
+
+Merging a Dictionary with another is done with |extend()|: >
+	:call extend(adict, bdict)
+This extends adict with all entries from bdict.  Duplicate keys cause entries
+in adict to be overwritten.  An optional third argument can change this.
+Note that the order of entries in a Dictionary is irrelevant, thus don't
+expect ":echo adict" to show the items from bdict after the older entries in
+adict.
+
+Weeding out entries from a Dictionary can be done with |filter()|: >
+	:call filter(dict, 'v:val =~ "x"')
+This removes all entries from "dict" with a value not matching 'x'.
+
+
+Dictionary function ~
+				*Dictionary-function* *self* *E725* *E862*
+When a function is defined with the "dict" attribute it can be used in a
+special way with a dictionary.  Example: >
+	:function Mylen() dict
+	:   return len(self.data)
+	:endfunction
+	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}
+	:echo mydict.len()
+
+This is like a method in object oriented programming.  The entry in the
+Dictionary is a |Funcref|.  The local variable "self" refers to the dictionary
+the function was invoked from.
+
+It is also possible to add a function without the "dict" attribute as a
+Funcref to a Dictionary, but the "self" variable is not available then.
+
+				*numbered-function* *anonymous-function*
+To avoid the extra name for the function it can be defined and directly
+assigned to a Dictionary in this way: >
+	:let mydict = {'data': [0, 1, 2, 3]}
+	:function mydict.len()
+	:   return len(self.data)
+	:endfunction
+	:echo mydict.len()
+
+The function will then get a number and the value of dict.len is a |Funcref|
+that references this function.  The function can only be used through a
+|Funcref|.  It will automatically be deleted when there is no |Funcref|
+remaining that refers to it.
+
+It is not necessary to use the "dict" attribute for a numbered function.
+
+If you get an error for a numbered function, you can find out what it is with
+a trick.  Assuming the function is 42, the command is: >
+	:function {42}
+
+
+Functions for Dictionaries ~
+							*E715*
+Functions that can be used with a Dictionary: >
+	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"
+	:if empty(dict)			" TRUE if dict is empty
+	:let l = len(dict)		" number of items in dict
+	:let big = max(dict)		" maximum value in dict
+	:let small = min(dict)		" minimum value in dict
+	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict
+	:let s = string(dict)		" String representation of dict
+	:call map(dict, '">> " . v:val')  " prepend ">> " to each item
+
+
+1.5 More about variables ~
+							*more-variables*
+If you need to know the type of a variable or expression, use the |type()|
+function.
+
+When the '!' flag is included in the 'viminfo' option, global variables that
+start with an uppercase letter, and don't contain a lowercase letter, are
+stored in the viminfo file |viminfo-file|.
+
+When the 'sessionoptions' option contains "global", global variables that
+start with an uppercase letter and contain at least one lowercase letter are
+stored in the session file |session-file|.
+
+variable name		can be stored where ~
+my_var_6		not
+My_Var_6		session file
+MY_VAR_6		viminfo file
+
+
+It's possible to form a variable name with curly braces, see
+|curly-braces-names|.
+
+==============================================================================
+2. Expression syntax					*expression-syntax*
+
+Expression syntax summary, from least to most significant:
+
+|expr1|	expr2
+	expr2 ? expr1 : expr1	if-then-else
+
+|expr2|	expr3
+	expr3 || expr3 ..	logical OR
+
+|expr3|	expr4
+	expr4 && expr4 ..	logical AND
+
+|expr4|	expr5
+	expr5 == expr5		equal
+	expr5 != expr5		not equal
+	expr5 >	 expr5		greater than
+	expr5 >= expr5		greater than or equal
+	expr5 <	 expr5		smaller than
+	expr5 <= expr5		smaller than or equal
+	expr5 =~ expr5		regexp matches
+	expr5 !~ expr5		regexp doesn't match
+
+	expr5 ==? expr5		equal, ignoring case
+	expr5 ==# expr5		equal, match case
+	etc.			As above, append ? for ignoring case, # for
+				matching case
+
+	expr5 is expr5		same |List| instance
+	expr5 isnot expr5	different |List| instance
+
+|expr5|	expr6
+	expr6 +	 expr6 ..	number addition or list concatenation
+	expr6 -	 expr6 ..	number subtraction
+	expr6 .	 expr6 ..	string concatenation
+
+|expr6|	expr7
+	expr7 *	 expr7 ..	number multiplication
+	expr7 /	 expr7 ..	number division
+	expr7 %	 expr7 ..	number modulo
+
+|expr7|	expr8
+	! expr7			logical NOT
+	- expr7			unary minus
+	+ expr7			unary plus
+
+|expr8|	expr9
+	expr8[expr1]		byte of a String or item of a |List|
+	expr8[expr1 : expr1]	substring of a String or sublist of a |List|
+	expr8.name		entry in a |Dictionary|
+	expr8(expr1, ...)	function call with |Funcref| variable
+
+|expr9|	number			number constant
+	"string"		string constant, backslash is special
+	'string'		string constant, ' is doubled
+	[expr1, ...]		|List|
+	{expr1: expr1, ...}	|Dictionary|
+	&option			option value
+	(expr1)			nested expression
+	variable		internal variable
+	va{ria}ble		internal variable with curly braces
+	$VAR			environment variable
+	@r			contents of register 'r'
+	function(expr1, ...)	function call
+	func{ti}on(expr1, ...)	function call with curly braces
+	{args -> expr1}		lambda expression
+
+
+".." indicates that the operations in this level can be concatenated.
+Example: >
+	&nu || &list && &shell == "csh"
+
+All expressions within one level are parsed from left to right.
+
+
+expr1							*expr1* *E109*
+-----
+
+expr2 ? expr1 : expr1
+
+The expression before the '?' is evaluated to a number.  If it evaluates to
+|TRUE|, the result is the value of the expression between the '?' and ':',
+otherwise the result is the value of the expression after the ':'.
+Example: >
+	:echo lnum == 1 ? "top" : lnum
+
+Since the first expression is an "expr2", it cannot contain another ?:.  The
+other two expressions can, thus allow for recursive use of ?:.
+Example: >
+	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum
+
+To keep this readable, using |line-continuation| is suggested: >
+	:echo lnum == 1
+	:\	? "top"
+	:\	: lnum == 1000
+	:\		? "last"
+	:\		: lnum
+
+You should always put a space before the ':', otherwise it can be mistaken for
+use in a variable such as "a:1".
+
+
+expr2 and expr3						*expr2* *expr3*
+---------------
+
+expr3 || expr3 ..	logical OR		*expr-barbar*
+expr4 && expr4 ..	logical AND		*expr-&&*
+
+The "||" and "&&" operators take one argument on each side.  The arguments
+are (converted to) Numbers.  The result is:
+
+    input			 output ~
+n1	n2		n1 || n2	n1 && n2 ~
+|FALSE|	|FALSE|		|FALSE|		|FALSE|
+|FALSE|	|TRUE|		|TRUE|		|FALSE|
+|TRUE|	|FALSE|		|TRUE|		|FALSE|
+|TRUE|	|TRUE|		|TRUE|		|TRUE|
+
+The operators can be concatenated, for example: >
+
+	&nu || &list && &shell == "csh"
+
+Note that "&&" takes precedence over "||", so this has the meaning of: >
+
+	&nu || (&list && &shell == "csh")
+
+Once the result is known, the expression "short-circuits", that is, further
+arguments are not evaluated.  This is like what happens in C.  For example: >
+
+	let a = 1
+	echo a || b
+
+This is valid even if there is no variable called "b" because "a" is |TRUE|,
+so the result must be |TRUE|.  Similarly below: >
+
+	echo exists("b") && b == "yes"
+
+This is valid whether "b" has been defined or not.  The second clause will
+only be evaluated if "b" has been defined.
+
+
+expr4							*expr4*
+-----
+
+expr5 {cmp} expr5
+
+Compare two expr5 expressions, resulting in a 0 if it evaluates to false, or 1
+if it evaluates to true.
+
+			*expr-==*  *expr-!=*  *expr->*	 *expr->=*
+			*expr-<*   *expr-<=*  *expr-=~*  *expr-!~*
+			*expr-==#* *expr-!=#* *expr->#*  *expr->=#*
+			*expr-<#*  *expr-<=#* *expr-=~#* *expr-!~#*
+			*expr-==?* *expr-!=?* *expr->?*  *expr->=?*
+			*expr-<?*  *expr-<=?* *expr-=~?* *expr-!~?*
+			*expr-is* *expr-isnot* *expr-is#* *expr-isnot#*
+			*expr-is?* *expr-isnot?*
+		use 'ignorecase'    match case	   ignore case ~
+equal			==		==#		==?
+not equal		!=		!=#		!=?
+greater than		>		>#		>?
+greater than or equal	>=		>=#		>=?
+smaller than		<		<#		<?
+smaller than or equal	<=		<=#		<=?
+regexp matches		=~		=~#		=~?
+regexp doesn't match	!~		!~#		!~?
+same instance		is		is#		is?
+different instance	isnot		isnot#		isnot?
+
+Examples:
+"abc" ==# "Abc"	  evaluates to 0
+"abc" ==? "Abc"	  evaluates to 1
+"abc" == "Abc"	  evaluates to 1 if 'ignorecase' is set, 0 otherwise
+
+							*E691* *E692*
+A |List| can only be compared with a |List| and only "equal", "not equal",
+"is" and "isnot" can be used.  This compares the values of the list,
+recursively.  Ignoring case means case is ignored when comparing item values.
+
+							*E735* *E736*
+A |Dictionary| can only be compared with a |Dictionary| and only "equal", "not
+equal", "is" and "isnot" can be used.  This compares the key/values of the
+|Dictionary| recursively.  Ignoring case means case is ignored when comparing
+item values.
+
+							*E694*
+A |Funcref| can only be compared with a |Funcref| and only "equal", "not
+equal", "is" and "isnot" can be used.  Case is never ignored.  Whether
+arguments or a Dictionary are bound (with a partial) matters.  The
+Dictionaries must also be equal (or the same, in case of "is") and the
+arguments must be equal (or the same).
+
+To compare Funcrefs to see if they refer to the same function, ignoring bound
+Dictionary and arguments, use |get()| to get the function name: >
+	if get(Part1, 'name') == get(Part2, 'name')
+	   " Part1 and Part2 refer to the same function
+
+When using "is" or "isnot" with a |List| or a |Dictionary| this checks if the
+expressions are referring to the same |List| or |Dictionary| instance.  A copy
+of a |List| is different from the original |List|.  When using "is" without
+a |List| or a |Dictionary| it is equivalent to using "equal", using "isnot"
+equivalent to using "not equal".  Except that a different type means the
+values are different: >
+	echo 4 == '4'
+	1
+	echo 4 is '4'
+	0
+	echo 0 is []
+	0
+"is#"/"isnot#" and "is?"/"isnot?" can be used to match and ignore case.
+
+When comparing a String with a Number, the String is converted to a Number,
+and the comparison is done on Numbers.  This means that: >
+	echo 0 == 'x'
+	1
+because 'x' converted to a Number is zero.  However: >
+	echo [0] == ['x']
+	0
+Inside a List or Dictionary this conversion is not used.
+
+When comparing two Strings, this is done with strcmp() or stricmp().  This
+results in the mathematical difference (comparing byte values), not
+necessarily the alphabetical difference in the local language.
+
+When using the operators with a trailing '#', or the short version and
+'ignorecase' is off, the comparing is done with strcmp(): case matters.
+
+When using the operators with a trailing '?', or the short version and
+'ignorecase' is set, the comparing is done with stricmp(): case is ignored.
+
+'smartcase' is not used.
+
+The "=~" and "!~" operators match the lefthand argument with the righthand
+argument, which is used as a pattern.  See |pattern| for what a pattern is.
+This matching is always done like 'magic' was set and 'cpoptions' is empty, no
+matter what the actual value of 'magic' or 'cpoptions' is.  This makes scripts
+portable.  To avoid backslashes in the regexp pattern to be doubled, use a
+single-quote string, see |literal-string|.
+Since a string is considered to be a single line, a multi-line pattern
+(containing \n, backslash-n) will not match.  However, a literal NL character
+can be matched like an ordinary character.  Examples:
+	"foo\nbar" =~ "\n"	evaluates to 1
+	"foo\nbar" =~ "\\n"	evaluates to 0
+
+
+expr5 and expr6						*expr5* *expr6*
+---------------
+expr6 +	 expr6 ..	Number addition or |List| concatenation	*expr-+*
+expr6 -	 expr6 ..	Number subtraction			*expr--*
+expr6 .	 expr6 ..	String concatenation			*expr-.*
+
+For |Lists| only "+" is possible and then both expr6 must be a list.  The
+result is a new list with the two lists Concatenated.
+
+expr7 *	 expr7 ..	Number multiplication			*expr-star*
+expr7 /	 expr7 ..	Number division				*expr-/*
+expr7 %	 expr7 ..	Number modulo				*expr-%*
+
+For all, except ".", Strings are converted to Numbers.
+For bitwise operators see |and()|, |or()| and |xor()|.
+
+Note the difference between "+" and ".":
+	"123" + "456" = 579
+	"123" . "456" = "123456"
+
+Since '.' has the same precedence as '+' and '-', you need to read: >
+	1 . 90 + 90.0
+As: >
+	(1 . 90) + 90.0
+That works, since the String "190" is automatically converted to the Number
+190, which can be added to the Float 90.0.  However: >
+	1 . 90 * 90.0
+Should be read as: >
+	1 . (90 * 90.0)
+Since '.' has lower precedence than '*'.  This does NOT work, since this
+attempts to concatenate a Float and a String.
+
+When dividing a Number by zero the result depends on the value:
+	  0 / 0  = -0x80000000	(like NaN for Float)
+	 >0 / 0  =  0x7fffffff	(like positive infinity)
+	 <0 / 0  = -0x7fffffff	(like negative infinity)
+	(before Vim 7.2 it was always 0x7fffffff)
+
+When 64-bit Number support is enabled:
+	  0 / 0  = -0x8000000000000000	(like NaN for Float)
+	 >0 / 0  =  0x7fffffffffffffff	(like positive infinity)
+	 <0 / 0  = -0x7fffffffffffffff	(like negative infinity)
+
+When the righthand side of '%' is zero, the result is 0.
+
+None of these work for |Funcref|s.
+
+. and % do not work for Float. *E804*
+
+
+expr7							*expr7*
+-----
+! expr7			logical NOT		*expr-!*
+- expr7			unary minus		*expr-unary--*
++ expr7			unary plus		*expr-unary-+*
+
+For '!' |TRUE| becomes |FALSE|, |FALSE| becomes |TRUE| (one).
+For '-' the sign of the number is changed.
+For '+' the number is unchanged.
+
+A String will be converted to a Number first.
+
+These three can be repeated and mixed.  Examples:
+	!-1	    == 0
+	!!8	    == 1
+	--9	    == 9
+
+
+expr8							*expr8*
+-----
+This expression is either |expr9| or a sequence of the alternatives below,
+in any order.  E.g., these are all possible:
+	expr9[expr1].name
+	expr9.name[expr1]
+	expr9(expr1, ...)[expr1].name
+
+
+expr8[expr1]		item of String or |List|	*expr-[]* *E111*
+							*E909* *subscript*
+If expr8 is a Number or String this results in a String that contains the
+expr1'th single byte from expr8.  expr8 is used as a String, expr1 as a
+Number.  This doesn't recognize multi-byte encodings, see `byteidx()` for
+an alternative, or use `split()` to turn the string into a list of characters.
+
+Index zero gives the first byte.  This is like it works in C.  Careful:
+text column numbers start with one!  Example, to get the byte under the
+cursor: >
+	:let c = getline(".")[col(".") - 1]
+
+If the length of the String is less than the index, the result is an empty
+String.  A negative index always results in an empty string (reason: backward
+compatibility).  Use [-1:] to get the last byte.
+
+If expr8 is a |List| then it results the item at index expr1.  See |list-index|
+for possible index values.  If the index is out of range this results in an
+error.  Example: >
+	:let item = mylist[-1]		" get last item
+
+Generally, if a |List| index is equal to or higher than the length of the
+|List|, or more negative than the length of the |List|, this results in an
+error.
+
+
+expr8[expr1a : expr1b]	substring or sublist		*expr-[:]*
+
+If expr8 is a Number or String this results in the substring with the bytes
+from expr1a to and including expr1b.  expr8 is used as a String, expr1a and
+expr1b are used as a Number.  This doesn't recognize multi-byte encodings, see
+|byteidx()| for computing the indexes.
+
+If expr1a is omitted zero is used.  If expr1b is omitted the length of the
+string minus one is used.
+
+A negative number can be used to measure from the end of the string.  -1 is
+the last character, -2 the last but one, etc.
+
+If an index goes out of range for the string characters are omitted.  If
+expr1b is smaller than expr1a the result is an empty string.
+
+Examples: >
+	:let c = name[-1:]		" last byte of a string
+	:let c = name[-2:-2]		" last but one byte of a string
+	:let s = line(".")[4:]		" from the fifth byte to the end
+	:let s = s[:-3]			" remove last two bytes
+<
+							*slice*
+If expr8 is a |List| this results in a new |List| with the items indicated by
+the indexes expr1a and expr1b.  This works like with a String, as explained
+just above. Also see |sublist| below.  Examples: >
+	:let l = mylist[:3]		" first four items
+	:let l = mylist[4:4]		" List with one item
+	:let l = mylist[:]		" shallow copy of a List
+
+Using expr8[expr1] or expr8[expr1a : expr1b] on a |Funcref| results in an
+error.
+
+Watch out for confusion between a namespace and a variable followed by a colon
+for a sublist: >
+	mylist[n:]     " uses variable n
+	mylist[s:]     " uses namespace s:, error!
+
+
+expr8.name		entry in a |Dictionary|		*expr-entry*
+
+If expr8 is a |Dictionary| and it is followed by a dot, then the following
+name will be used as a key in the |Dictionary|.  This is just like:
+expr8[name].
+
+The name must consist of alphanumeric characters, just like a variable name,
+but it may start with a number.  Curly braces cannot be used.
+
+There must not be white space before or after the dot.
+
+Examples: >
+	:let dict = {"one": 1, 2: "two"}
+	:echo dict.one
+	:echo dict .2
+
+Note that the dot is also used for String concatenation.  To avoid confusion
+always put spaces around the dot for String concatenation.
+
+
+expr8(expr1, ...)	|Funcref| function call
+
+When expr8 is a |Funcref| type variable, invoke the function it refers to.
+
+
+
+							*expr9*
+number
+------
+number			number constant			*expr-number*
+				*hex-number* *octal-number* *binary-number*
+
+Decimal, Hexadecimal (starting with 0x or 0X), Binary (starting with 0b or 0B)
+and Octal (starting with 0).
+
+						*floating-point-format*
+Floating point numbers can be written in two forms:
+
+	[-+]{N}.{M}
+	[-+]{N}.{M}[eE][-+]{exp}
+
+{N} and {M} are numbers.  Both {N} and {M} must be present and can only
+contain digits.
+[-+] means there is an optional plus or minus sign.
+{exp} is the exponent, power of 10.
+Only a decimal point is accepted, not a comma.  No matter what the current
+locale is.
+{only when compiled with the |+float| feature}
+
+Examples:
+	123.456
+	+0.0001
+	55.0
+	-0.123
+	1.234e03
+	1.0E-6
+	-3.1416e+88
+
+These are INVALID:
+	3.		empty {M}
+	1e40		missing .{M}
+
+							*float-pi* *float-e*
+A few useful values to copy&paste: >
+	:let pi = 3.14159265359
+	:let e  = 2.71828182846
+
+Rationale:
+Before floating point was introduced, the text "123.456" was interpreted as
+the two numbers "123" and "456", both converted to a string and concatenated,
+resulting in the string "123456".  Since this was considered pointless, and we
+could not find it intentionally being used in Vim scripts, this backwards
+incompatibility was accepted in favor of being able to use the normal notation
+for floating point numbers.
+
+						*floating-point-precision*
+The precision and range of floating points numbers depends on what "double"
+means in the library Vim was compiled with.  There is no way to change this at
+runtime.
+
+The default for displaying a |Float| is to use 6 decimal places, like using
+printf("%g", f).  You can select something else when using the |printf()|
+function.  Example: >
+	:echo printf('%.15e', atan(1))
+<	7.853981633974483e-01
+
+
+
+string					*string* *String* *expr-string* *E114*
+------
+"string"		string constant		*expr-quote*
+
+Note that double quotes are used.
+
+A string constant accepts these special characters:
+\...	three-digit octal number (e.g., "\316")
+\..	two-digit octal number (must be followed by non-digit)
+\.	one-digit octal number (must be followed by non-digit)
+\x..	byte specified with two hex numbers (e.g., "\x1f")
+\x.	byte specified with one hex number (must be followed by non-hex char)
+\X..	same as \x..
+\X.	same as \x.
+\u....	character specified with up to 4 hex numbers, stored according to the
+	current value of 'encoding' (e.g., "\u02a4")
+\U....	same as \u but allows up to 8 hex numbers.
+\b	backspace <BS>
+\e	escape <Esc>
+\f	formfeed <FF>
+\n	newline <NL>
+\r	return <CR>
+\t	tab <Tab>
+\\	backslash
+\"	double quote
+\<xxx>	Special key named "xxx".  e.g. "\<C-W>" for CTRL-W.  This is for use
+	in mappings, the 0x80 byte is escaped.
+	To use the double quote character it must be escaped: "<M-\">".
+	Don't use <Char-xxxx> to get a utf-8 character, use \uxxxx as
+	mentioned above.
+
+Note that "\xff" is stored as the byte 255, which may be invalid in some
+encodings.  Use "\u00ff" to store character 255 according to the current value
+of 'encoding'.
+
+Note that "\000" and "\x00" force the end of the string.
+
+
+literal-string						*literal-string* *E115*
+---------------
+'string'		string constant			*expr-'*
+
+Note that single quotes are used.
+
+This string is taken as it is.  No backslashes are removed or have a special
+meaning.  The only exception is that two quotes stand for one quote.
+
+Single quoted strings are useful for patterns, so that backslashes do not need
+to be doubled.  These two commands are equivalent: >
+	if a =~ "\\s*"
+	if a =~ '\s*'
+
+
+option						*expr-option* *E112* *E113*
+------
+&option			option value, local value if possible
+&g:option		global option value
+&l:option		local option value
+
+Examples: >
+	echo "tabstop is " . &tabstop
+	if &insertmode
+
+Any option name can be used here.  See |options|.  When using the local value
+and there is no buffer-local or window-local value, the global value is used
+anyway.
+
+
+register						*expr-register* *@r*
+--------
+@r			contents of register 'r'
+
+The result is the contents of the named register, as a single string.
+Newlines are inserted where required.  To get the contents of the unnamed
+register use @" or @@.  See |registers| for an explanation of the available
+registers.
+
+When using the '=' register you get the expression itself, not what it
+evaluates to.  Use |eval()| to evaluate it.
+
+
+nesting							*expr-nesting* *E110*
+-------
+(expr1)			nested expression
+
+
+environment variable					*expr-env*
+--------------------
+$VAR			environment variable
+
+The String value of any environment variable.  When it is not defined, the
+result is an empty string.
+						*expr-env-expand*
+Note that there is a difference between using $VAR directly and using
+expand("$VAR").  Using it directly will only expand environment variables that
+are known inside the current Vim session.  Using expand() will first try using
+the environment variables known inside the current Vim session.  If that
+fails, a shell will be used to expand the variable.  This can be slow, but it
+does expand all variables that the shell knows about.  Example: >
+	:echo $shell
+	:echo expand("$shell")
+The first one probably doesn't echo anything, the second echoes the $shell
+variable (if your shell supports it).
+
+
+internal variable					*expr-variable*
+-----------------
+variable		internal variable
+See below |internal-variables|.
+
+
+function call		*expr-function* *E116* *E118* *E119* *E120*
+-------------
+function(expr1, ...)	function call
+See below |functions|.
+
+
+lambda expression				*expr-lambda* *lambda*
+-----------------
+{args -> expr1}		lambda expression
+
+A lambda expression creates a new unnamed function which returns the result of
+evaluating |expr1|.  Lambda expressions differ from |user-functions| in
+the following ways:
+
+1. The body of the lambda expression is an |expr1| and not a sequence of |Ex|
+   commands.
+2. The prefix "a:" should not be used for arguments.  E.g.: >
+	:let F = {arg1, arg2 -> arg1 - arg2}
+	:echo F(5, 2)
+<	3
+
+The arguments are optional.  Example: >
+	:let F = {-> 'error function'}
+	:echo F()
+<	error function
+							*closure*
+Lambda expressions can access outer scope variables and arguments.  This is
+often called a closure.  Example where "i" and "a:arg" are used in a lambda
+while they already exist in the function scope.  They remain valid even after
+the function returns: >
+	:function Foo(arg)
+	:  let i = 3
+	:  return {x -> x + i - a:arg}
+	:endfunction
+	:let Bar = Foo(4)
+	:echo Bar(6)
+<	5
+
+Note that the variables must exist in the outer scope before the lamba is
+defined for this to work.  See also |:func-closure|.
+
+Lambda and closure support can be checked with: >
+	if has('lambda')
+
+Examples for using a lambda expression with |sort()|, |map()| and |filter()|: >
+	:echo map([1, 2, 3], {idx, val -> val + 1})
+<	[2, 3, 4] >
+	:echo sort([3,7,2,1,4], {a, b -> a - b})
+<	[1, 2, 3, 4, 7]
+
+The lambda expression is also useful for Channel, Job and timer: >
+	:let timer = timer_start(500,
+			\ {-> execute("echo 'Handler called'", "")},
+			\ {'repeat': 3})
+<	Handler called
+	Handler called
+	Handler called
+
+Note how execute() is used to execute an Ex command.  That's ugly though.
+
+
+Lambda expressions have internal names like '<lambda>42'.  If you get an error
+for a lambda expression, you can find what it is with the following command: >
+	:function {'<lambda>42'}
+See also: |numbered-function|
+
+==============================================================================
+3. Internal variable				*internal-variables* *E461*
+
+An internal variable name can be made up of letters, digits and '_'.  But it
+cannot start with a digit.  It's also possible to use curly braces, see
+|curly-braces-names|.
+
+An internal variable is created with the ":let" command |:let|.
+An internal variable is explicitly destroyed with the ":unlet" command
+|:unlet|.
+Using a name that is not an internal variable or refers to a variable that has
+been destroyed results in an error.
+
+There are several name spaces for variables.  Which one is to be used is
+specified by what is prepended:
+
+		(nothing) In a function: local to a function; otherwise: global
+|buffer-variable|    b:	  Local to the current buffer.
+|window-variable|    w:	  Local to the current window.
+|tabpage-variable|   t:	  Local to the current tab page.
+|global-variable|    g:	  Global.
+|local-variable|     l:	  Local to a function.
+|script-variable|    s:	  Local to a |:source|'ed Vim script.
+|function-argument|  a:	  Function argument (only inside a function).
+|vim-variable|       v:	  Global, predefined by Vim.
+
+The scope name by itself can be used as a |Dictionary|.  For example, to
+delete all script-local variables: >
+	:for k in keys(s:)
+	:    unlet s:[k]
+	:endfor
+<
+						*buffer-variable* *b:var* *b:*
+A variable name that is preceded with "b:" is local to the current buffer.
+Thus you can have several "b:foo" variables, one for each buffer.
+This kind of variable is deleted when the buffer is wiped out or deleted with
+|:bdelete|.
+
+One local buffer variable is predefined:
+					*b:changedtick* *changetick*
+b:changedtick	The total number of changes to the current buffer.  It is
+		incremented for each change.  An undo command is also a change
+		in this case.  This can be used to perform an action only when
+		the buffer has changed.  Example: >
+		    :if my_changedtick != b:changedtick
+		    :	let my_changedtick = b:changedtick
+		    :	call My_Update()
+		    :endif
+<		You cannot change or delete the b:changedtick variable.
+
+						*window-variable* *w:var* *w:*
+A variable name that is preceded with "w:" is local to the current window.  It
+is deleted when the window is closed.
+
+						*tabpage-variable* *t:var* *t:*
+A variable name that is preceded with "t:" is local to the current tab page,
+It is deleted when the tab page is closed. {not available when compiled
+without the |+windows| feature}
+
+						*global-variable* *g:var* *g:*
+Inside functions global variables are accessed with "g:".  Omitting this will
+access a variable local to a function.  But "g:" can also be used in any other
+place if you like.
+
+						*local-variable* *l:var* *l:*
+Inside functions local variables are accessed without prepending anything.
+But you can also prepend "l:" if you like.  However, without prepending "l:"
+you may run into reserved variable names.  For example "count".  By itself it
+refers to "v:count".  Using "l:count" you can have a local variable with the
+same name.
+
+						*script-variable* *s:var*
+In a Vim script variables starting with "s:" can be used.  They cannot be
+accessed from outside of the scripts, thus are local to the script.
+
+They can be used in:
+- commands executed while the script is sourced
+- functions defined in the script
+- autocommands defined in the script
+- functions and autocommands defined in functions and autocommands which were
+  defined in the script (recursively)
+- user defined commands defined in the script
+Thus not in:
+- other scripts sourced from this one
+- mappings
+- menus
+- etc.
+
+Script variables can be used to avoid conflicts with global variable names.
+Take this example: >
+
+	let s:counter = 0
+	function MyCounter()
+	  let s:counter = s:counter + 1
+	  echo s:counter
+	endfunction
+	command Tick call MyCounter()
+
+You can now invoke "Tick" from any script, and the "s:counter" variable in
+that script will not be changed, only the "s:counter" in the script where
+"Tick" was defined is used.
+
+Another example that does the same: >
+
+	let s:counter = 0
+	command Tick let s:counter = s:counter + 1 | echo s:counter
+
+When calling a function and invoking a user-defined command, the context for
+script variables is set to the script where the function or command was
+defined.
+
+The script variables are also available when a function is defined inside a
+function that is defined in a script.  Example: >
+
+	let s:counter = 0
+	function StartCounting(incr)
+	  if a:incr
+	    function MyCounter()
+	      let s:counter = s:counter + 1
+	    endfunction
+	  else
+	    function MyCounter()
+	      let s:counter = s:counter - 1
+	    endfunction
+	  endif
+	endfunction
+
+This defines the MyCounter() function either for counting up or counting down
+when calling StartCounting().  It doesn't matter from where StartCounting() is
+called, the s:counter variable will be accessible in MyCounter().
+
+When the same script is sourced again it will use the same script variables.
+They will remain valid as long as Vim is running.  This can be used to
+maintain a counter: >
+
+	if !exists("s:counter")
+	  let s:counter = 1
+	  echo "script executed for the first time"
+	else
+	  let s:counter = s:counter + 1
+	  echo "script executed " . s:counter . " times now"
+	endif
+
+Note that this means that filetype plugins don't get a different set of script
+variables for each buffer.  Use local buffer variables instead |b:var|.
+
+
+Predefined Vim variables:			*vim-variable* *v:var* *v:*
+
+					*v:beval_col* *beval_col-variable*
+v:beval_col	The number of the column, over which the mouse pointer is.
+		This is the byte index in the |v:beval_lnum| line.
+		Only valid while evaluating the 'balloonexpr' option.
+
+					*v:beval_bufnr* *beval_bufnr-variable*
+v:beval_bufnr	The number of the buffer, over which the mouse pointer is. Only
+		valid while evaluating the 'balloonexpr' option.
+
+					*v:beval_lnum* *beval_lnum-variable*
+v:beval_lnum	The number of the line, over which the mouse pointer is. Only
+		valid while evaluating the 'balloonexpr' option.
+
+					*v:beval_text* *beval_text-variable*
+v:beval_text	The text under or after the mouse pointer.  Usually a word as
+		it is useful for debugging a C program.  'iskeyword' applies,
+		but a dot and "->" before the position is included.  When on a
+		']' the text before it is used, including the matching '[' and
+		word before it.  When on a Visual area within one line the
+		highlighted text is used.  Also see |<cexpr>|.
+		Only valid while evaluating the 'balloonexpr' option.
+
+					*v:beval_winnr* *beval_winnr-variable*
+v:beval_winnr	The number of the window, over which the mouse pointer is. Only
+		valid while evaluating the 'balloonexpr' option.  The first
+		window has number zero (unlike most other places where a
+		window gets a number).
+
+					*v:beval_winid* *beval_winid-variable*
+v:beval_winid	The |window-ID| of the window, over which the mouse pointer
+		is.  Otherwise like v:beval_winnr.
+
+					*v:char* *char-variable*
+v:char		Argument for evaluating 'formatexpr' and used for the typed
+		character when using <expr> in an abbreviation |:map-<expr>|.
+		It is also used by the |InsertCharPre| and |InsertEnter| events.
+
+			*v:charconvert_from* *charconvert_from-variable*
+v:charconvert_from
+		The name of the character encoding of a file to be converted.
+		Only valid while evaluating the 'charconvert' option.
+
+			*v:charconvert_to* *charconvert_to-variable*
+v:charconvert_to
+		The name of the character encoding of a file after conversion.
+		Only valid while evaluating the 'charconvert' option.
+
+					*v:cmdarg* *cmdarg-variable*
+v:cmdarg	This variable is used for two purposes:
+		1. The extra arguments given to a file read/write command.
+		   Currently these are "++enc=" and "++ff=".  This variable is
+		   set before an autocommand event for a file read/write
+		   command is triggered.  There is a leading space to make it
+		   possible to append this variable directly after the
+		   read/write command.  Note: The "+cmd" argument isn't
+		   included here, because it will be executed anyway.
+		2. When printing a PostScript file with ":hardcopy" this is
+		   the argument for the ":hardcopy" command.  This can be used
+		   in 'printexpr'.
+
+					*v:cmdbang* *cmdbang-variable*
+v:cmdbang	Set like v:cmdarg for a file read/write command.  When a "!"
+		was used the value is 1, otherwise it is 0.  Note that this
+		can only be used in autocommands.  For user commands |<bang>|
+		can be used.
+
+				*v:completed_item* *completed_item-variable*
+v:completed_item
+		|Dictionary| containing the |complete-items| for the most
+		recently completed word after |CompleteDone|.  The
+		|Dictionary| is empty if the completion failed.
+
+					*v:count* *count-variable*
+v:count		The count given for the last Normal mode command.  Can be used
+		to get the count before a mapping.  Read-only.  Example: >
+	:map _x :<C-U>echo "the count is " . v:count<CR>
+<		Note: The <C-U> is required to remove the line range that you
+		get when typing ':' after a count.
+		When there are two counts, as in "3d2w", they are multiplied,
+		just like what happens in the command, "d6w" for the example.
+		Also used for evaluating the 'formatexpr' option.
+		"count" also works, for backwards compatibility.
+
+					*v:count1* *count1-variable*
+v:count1	Just like "v:count", but defaults to one when no count is
+		used.
+
+						*v:ctype* *ctype-variable*
+v:ctype		The current locale setting for characters of the runtime
+		environment.  This allows Vim scripts to be aware of the
+		current locale encoding.  Technical: it's the value of
+		LC_CTYPE.  When not using a locale the value is "C".
+		This variable can not be set directly, use the |:language|
+		command.
+		See |multi-lang|.
+
+					*v:dying* *dying-variable*
+v:dying		Normally zero.  When a deadly signal is caught it's set to
+		one.  When multiple signals are caught the number increases.
+		Can be used in an autocommand to check if Vim didn't
+		terminate normally. {only works on Unix}
+		Example: >
+	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
+<		Note: if another deadly signal is caught when v:dying is one,
+		VimLeave autocommands will not be executed.
+
+					*v:errmsg* *errmsg-variable*
+v:errmsg	Last given error message.  It's allowed to set this variable.
+		Example: >
+	:let v:errmsg = ""
+	:silent! next
+	:if v:errmsg != ""
+	:  ... handle error
+<		"errmsg" also works, for backwards compatibility.
+
+				*v:errors* *errors-variable* *assert-return*
+v:errors	Errors found by assert functions, such as |assert_true()|.
+		This is a list of strings.
+		The assert functions append an item when an assert fails.
+		The return value indicates this: a one is returned if an item
+		was added to v:errors, otherwise zero is returned.
+		To remove old results make it empty: >
+	:let v:errors = []
+<		If v:errors is set to anything but a list it is made an empty
+		list by the assert function.
+
+					*v:event* *event-variable*
+v:event		Dictionary containing information about the current
+		|autocommand|.  The dictionary is emptied when the |autocommand|
+		finishes, please refer to |dict-identity| for how to get an
+		independent copy of it.
+
+					*v:exception* *exception-variable*
+v:exception	The value of the exception most recently caught and not
+		finished.  See also |v:throwpoint| and |throw-variables|.
+		Example: >
+	:try
+	:  throw "oops"
+	:catch /.*/
+	:  echo "caught" v:exception
+	:endtry
+<		Output: "caught oops".
+
+					*v:false* *false-variable*
+v:false		A Number with value zero. Used to put "false" in JSON.  See
+		|json_encode()|.
+		When used as a string this evaluates to "v:false". >
+			echo v:false
+<			v:false ~
+		That is so that eval() can parse the string back to the same
+		value.  Read-only.
+
+					*v:fcs_reason* *fcs_reason-variable*
+v:fcs_reason	The reason why the |FileChangedShell| event was triggered.
+		Can be used in an autocommand to decide what to do and/or what
+		to set v:fcs_choice to.  Possible values:
+			deleted		file no longer exists
+			conflict	file contents, mode or timestamp was
+					changed and buffer is modified
+			changed		file contents has changed
+			mode		mode of file changed
+			time		only file timestamp changed
+
+					*v:fcs_choice* *fcs_choice-variable*
+v:fcs_choice	What should happen after a |FileChangedShell| event was
+		triggered.  Can be used in an autocommand to tell Vim what to
+		do with the affected buffer:
+			reload		Reload the buffer (does not work if
+					the file was deleted).
+			ask		Ask the user what to do, as if there
+					was no autocommand.  Except that when
+					only the timestamp changed nothing
+					will happen.
+			<empty>		Nothing, the autocommand should do
+					everything that needs to be done.
+		The default is empty.  If another (invalid) value is used then
+		Vim behaves like it is empty, there is no warning message.
+
+					*v:fname_in* *fname_in-variable*
+v:fname_in	The name of the input file.  Valid while evaluating:
+			option		used for ~
+			'charconvert'	file to be converted
+			'diffexpr'	original file
+			'patchexpr'	original file
+			'printexpr'	file to be printed
+		And set to the swap file name for |SwapExists|.
+
+					*v:fname_out* *fname_out-variable*
+v:fname_out	The name of the output file.  Only valid while
+		evaluating:
+			option		used for ~
+			'charconvert'	resulting converted file (*)
+			'diffexpr'	output of diff
+			'patchexpr'	resulting patched file
+		(*) When doing conversion for a write command (e.g., ":w
+		file") it will be equal to v:fname_in.  When doing conversion
+		for a read command (e.g., ":e file") it will be a temporary
+		file and different from v:fname_in.
+
+					*v:fname_new* *fname_new-variable*
+v:fname_new	The name of the new version of the file.  Only valid while
+		evaluating 'diffexpr'.
+
+					*v:fname_diff* *fname_diff-variable*
+v:fname_diff	The name of the diff (patch) file.  Only valid while
+		evaluating 'patchexpr'.
+
+					*v:folddashes* *folddashes-variable*
+v:folddashes	Used for 'foldtext': dashes representing foldlevel of a closed
+		fold.
+		Read-only in the |sandbox|. |fold-foldtext|
+
+					*v:foldlevel* *foldlevel-variable*
+v:foldlevel	Used for 'foldtext': foldlevel of closed fold.
+		Read-only in the |sandbox|. |fold-foldtext|
+
+					*v:foldend* *foldend-variable*
+v:foldend	Used for 'foldtext': last line of closed fold.
+		Read-only in the |sandbox|. |fold-foldtext|
+
+					*v:foldstart* *foldstart-variable*
+v:foldstart	Used for 'foldtext': first line of closed fold.
+		Read-only in the |sandbox|. |fold-foldtext|
+
+					*v:hlsearch* *hlsearch-variable*
+v:hlsearch	Variable that indicates whether search highlighting is on.
+		Setting it makes sense only if 'hlsearch' is enabled which
+		requires |+extra_search|. Setting this variable to zero acts
+		like the |:nohlsearch| command, setting it to one acts like >
+			let &hlsearch = &hlsearch
+<		Note that the value is restored when returning from a
+		function. |function-search-undo|.
+
+					*v:insertmode* *insertmode-variable*
+v:insertmode	Used for the |InsertEnter| and |InsertChange| autocommand
+		events.  Values:
+			i	Insert mode
+			r	Replace mode
+			v	Virtual Replace mode
+
+						*v:key* *key-variable*
+v:key		Key of the current item of a |Dictionary|.  Only valid while
+		evaluating the expression used with |map()| and |filter()|.
+		Read-only.
+
+						*v:lang* *lang-variable*
+v:lang		The current locale setting for messages of the runtime
+		environment.  This allows Vim scripts to be aware of the
+		current language.  Technical: it's the value of LC_MESSAGES.
+		The value is system dependent.
+		This variable can not be set directly, use the |:language|
+		command.
+		It can be different from |v:ctype| when messages are desired
+		in a different language than what is used for character
+		encoding.  See |multi-lang|.
+
+						*v:lc_time* *lc_time-variable*
+v:lc_time	The current locale setting for time messages of the runtime
+		environment.  This allows Vim scripts to be aware of the
+		current language.  Technical: it's the value of LC_TIME.
+		This variable can not be set directly, use the |:language|
+		command.  See |multi-lang|.
+
+						*v:lnum* *lnum-variable*
+v:lnum		Line number for the 'foldexpr' |fold-expr|, 'formatexpr' and
+		'indentexpr' expressions, tab page number for 'guitablabel'
+		and 'guitabtooltip'.  Only valid while one of these
+		expressions is being evaluated.  Read-only when in the
+		|sandbox|.
+
+					*v:mouse_win* *mouse_win-variable*
+v:mouse_win	Window number for a mouse click obtained with |getchar()|.
+		First window has number 1, like with |winnr()|.  The value is
+		zero when there was no mouse button click.
+
+					*v:mouse_winid* *mouse_winid-variable*
+v:mouse_winid	Window ID for a mouse click obtained with |getchar()|.
+		The value is zero when there was no mouse button click.
+
+					*v:mouse_lnum* *mouse_lnum-variable*
+v:mouse_lnum	Line number for a mouse click obtained with |getchar()|.
+		This is the text line number, not the screen line number.  The
+		value is zero when there was no mouse button click.
+
+					*v:mouse_col* *mouse_col-variable*
+v:mouse_col	Column number for a mouse click obtained with |getchar()|.
+		This is the screen column number, like with |virtcol()|.  The
+		value is zero when there was no mouse button click.
+
+					*v:none* *none-variable*
+v:none		An empty String. Used to put an empty item in JSON.  See
+		|json_encode()|.
+		When used as a number this evaluates to zero.
+		When used as a string this evaluates to "v:none". >
+			echo v:none
+<			v:none ~
+		That is so that eval() can parse the string back to the same
+		value.  Read-only.
+
+					*v:null* *null-variable*
+v:null		An empty String. Used to put "null" in JSON.  See
+		|json_encode()|.
+		When used as a number this evaluates to zero.
+		When used as a string this evaluates to "v:null". >
+			echo v:null
+<			v:null ~
+		That is so that eval() can parse the string back to the same
+		value.  Read-only.
+
+					*v:oldfiles* *oldfiles-variable*
+v:oldfiles	List of file names that is loaded from the |viminfo| file on
+		startup.  These are the files that Vim remembers marks for.
+		The length of the List is limited by the ' argument of the
+		'viminfo' option (default is 100).
+		When the |viminfo| file is not used the List is empty.
+		Also see |:oldfiles| and |c_#<|.
+		The List can be modified, but this has no effect on what is
+		stored in the |viminfo| file later.  If you use values other
+		than String this will cause trouble.
+		{only when compiled with the |+viminfo| feature}
+
+						    *v:option_new*
+v:option_new    New value of the option. Valid while executing an |OptionSet|
+		autocommand.
+						    *v:option_old*
+v:option_old    Old value of the option. Valid while executing an |OptionSet|
+		autocommand.
+						    *v:option_type*
+v:option_type   Scope of the set command. Valid while executing an
+		|OptionSet| autocommand. Can be either "global" or "local"
+					*v:operator* *operator-variable*
+v:operator	The last operator given in Normal mode.  This is a single
+		character except for commands starting with <g> or <z>,
+		in which case it is two characters.  Best used alongside
+		|v:prevcount| and |v:register|.  Useful if you want to cancel
+		Operator-pending mode and then use the operator, e.g.: >
+			:omap O <Esc>:call MyMotion(v:operator)<CR>
+<		The value remains set until another operator is entered, thus
+		don't expect it to be empty.
+		v:operator is not set for |:delete|, |:yank| or other Ex
+		commands.
+		Read-only.
+
+					*v:prevcount* *prevcount-variable*
+v:prevcount	The count given for the last but one Normal mode command.
+		This is the v:count value of the previous command.  Useful if
+		you want to cancel Visual or Operator-pending mode and then
+		use the count, e.g.: >
+			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
+<		Read-only.
+
+					*v:profiling* *profiling-variable*
+v:profiling	Normally zero.  Set to one after using ":profile start".
+		See |profiling|.
+
+					*v:progname* *progname-variable*
+v:progname	Contains the name (with path removed) with which Vim was
+		invoked.  Allows you to do special initialisations for |view|,
+		|evim| etc., or any other name you might symlink to Vim.
+		Read-only.
+
+					*v:progpath* *progpath-variable*
+v:progpath	Contains the command with which Vim was invoked, including the
+		path.  Useful if you want to message a Vim server using a
+		|--remote-expr|.
+		To get the full path use: >
+			echo exepath(v:progpath)
+<		If the path is relative it will be expanded to the full path,
+		so that it still works after `:cd`. Thus starting "./vim"
+		results in "/home/user/path/to/vim/src/vim".
+		On MS-Windows the executable may be called "vim.exe", but the
+		".exe" is not added to v:progpath.
+		Read-only.
+
+					*v:register* *register-variable*
+v:register	The name of the register in effect for the current normal mode
+		command (regardless of whether that command actually used a
+		register).  Or for the currently executing normal mode mapping
+		(use this in custom commands that take a register).
+		If none is supplied it is the default register '"', unless
+		'clipboard' contains "unnamed" or "unnamedplus", then it is
+		'*' or '+'.
+		Also see |getreg()| and |setreg()|
+
+					*v:scrollstart* *scrollstart-variable*
+v:scrollstart	String describing the script or function that caused the
+		screen to scroll up.  It's only set when it is empty, thus the
+		first reason is remembered.  It is set to "Unknown" for a
+		typed command.
+		This can be used to find out why your script causes the
+		hit-enter prompt.
+
+					*v:servername* *servername-variable*
+v:servername	The resulting registered |client-server-name| if any.
+		Read-only.
+
+
+v:searchforward			*v:searchforward* *searchforward-variable*
+		Search direction:  1 after a forward search, 0 after a
+		backward search.  It is reset to forward when directly setting
+		the last search pattern, see |quote/|.
+		Note that the value is restored when returning from a
+		function. |function-search-undo|.
+		Read-write.
+
+					*v:shell_error* *shell_error-variable*
+v:shell_error	Result of the last shell command.  When non-zero, the last
+		shell command had an error.  When zero, there was no problem.
+		This only works when the shell returns the error code to Vim.
+		The value -1 is often used when the command could not be
+		executed.  Read-only.
+		Example: >
+	:!mv foo bar
+	:if v:shell_error
+	:  echo 'could not rename "foo" to "bar"!'
+	:endif
+<		"shell_error" also works, for backwards compatibility.
+
+					*v:statusmsg* *statusmsg-variable*
+v:statusmsg	Last given status message.  It's allowed to set this variable.
+
+					*v:swapname* *swapname-variable*
+v:swapname	Only valid when executing |SwapExists| autocommands: Name of
+		the swap file found.  Read-only.
+
+					*v:swapchoice* *swapchoice-variable*
+v:swapchoice	|SwapExists| autocommands can set this to the selected choice
+		for handling an existing swap file:
+			'o'	Open read-only
+			'e'	Edit anyway
+			'r'	Recover
+			'd'	Delete swapfile
+			'q'	Quit
+			'a'	Abort
+		The value should be a single-character string.  An empty value
+		results in the user being asked, as would happen when there is
+		no SwapExists autocommand.  The default is empty.
+
+					*v:swapcommand* *swapcommand-variable*
+v:swapcommand	Normal mode command to be executed after a file has been
+		opened.  Can be used for a |SwapExists| autocommand to have
+		another Vim open the file and jump to the right place.  For
+		example, when jumping to a tag the value is ":tag tagname\r".
+		For ":edit +cmd file" the value is ":cmd\r".
+
+				*v:t_TYPE* *v:t_bool* *t_bool-variable*
+v:t_bool	Value of Boolean type.  Read-only.  See: |type()|
+					*v:t_channel* *t_channel-variable*
+v:t_channel	Value of Channel type.  Read-only.  See: |type()|
+					*v:t_dict* *t_dict-variable*
+v:t_dict	Value of Dictionary type.  Read-only.  See: |type()|
+					*v:t_float* *t_float-variable*
+v:t_float	Value of Float type.  Read-only.  See: |type()|
+					*v:t_func* *t_func-variable*
+v:t_func	Value of Funcref type.  Read-only.  See: |type()|
+					*v:t_job* *t_job-variable*
+v:t_job		Value of Job type.  Read-only.  See: |type()|
+					*v:t_list* *t_list-variable*
+v:t_list	Value of List type.  Read-only.  See: |type()|
+					*v:t_none* *t_none-variable*
+v:t_none	Value of None type.  Read-only.  See: |type()|
+					*v:t_number* *t_number-variable*
+v:t_number	Value of Number type.  Read-only.  See: |type()|
+					*v:t_string* *t_string-variable*
+v:t_string	Value of String type.  Read-only.  See: |type()|
+
+				*v:termresponse* *termresponse-variable*
+v:termresponse	The escape sequence returned by the terminal for the |t_RV|
+		termcap entry.  It is set when Vim receives an escape sequence
+		that starts with ESC [ or CSI and ends in a 'c', with only
+		digits, ';' and '.' in between.
+		When this option is set, the TermResponse autocommand event is
+		fired, so that you can react to the response from the
+		terminal.
+		The response from a new xterm is: "<Esc>[ Pp ; Pv ; Pc c".  Pp
+		is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the
+		patch level (since this was introduced in patch 95, it's
+		always 95 or bigger).  Pc is always zero.
+		{only when compiled with |+termresponse| feature}
+
+						*v:termblinkresp*
+v:termblinkresp	The escape sequence returned by the terminal for the |t_RC|
+		termcap entry.  This is used to find out whether the terminal
+		cursor is blinking. This is used by |term_getcursor()|.
+
+						*v:termstyleresp*
+v:termstyleresp	The escape sequence returned by the terminal for the |t_RS|
+		termcap entry.  This is used to find out what the shape of the
+		cursor is.  This is used by |term_getcursor()|.
+
+						*v:termrbgresp*
+v:termrbgresp	The escape sequence returned by the terminal for the |t_RB|
+		termcap entry.  This is used to find out what the terminal
+		background color is, see 'background'.
+
+						*v:termrfgresp*
+v:termrfgresp	The escape sequence returned by the terminal for the |t_RF|
+		termcap entry.  This is used to find out what the terminal
+		foreground color is.
+
+						*v:termu7resp*
+v:termu7resp	The escape sequence returned by the terminal for the |t_u7|
+		termcap entry.  This is used to find out what the terminal
+		does with ambiguous width characters, see 'ambiwidth'.
+
+					*v:testing* *testing-variable*
+v:testing	Must be set before using `test_garbagecollect_now()`.
+		Also, when set certain error messages won't be shown for 2
+		seconds. (e.g. "'dictionary' option is empty")
+
+				*v:this_session* *this_session-variable*
+v:this_session	Full filename of the last loaded or saved session file.  See
+		|:mksession|.  It is allowed to set this variable.  When no
+		session file has been saved, this variable is empty.
+		"this_session" also works, for backwards compatibility.
+
+					*v:throwpoint* *throwpoint-variable*
+v:throwpoint	The point where the exception most recently caught and not
+		finished was thrown.  Not set when commands are typed.  See
+		also |v:exception| and |throw-variables|.
+		Example: >
+	:try
+	:  throw "oops"
+	:catch /.*/
+	:  echo "Exception from" v:throwpoint
+	:endtry
+<		Output: "Exception from test.vim, line 2"
+
+						*v:true* *true-variable*
+v:true		A Number with value one. Used to put "true" in JSON.  See
+		|json_encode()|.
+		When used as a string this evaluates to "v:true". >
+			echo v:true
+<			v:true ~
+		That is so that eval() can parse the string back to the same
+		value.  Read-only.
+						*v:val* *val-variable*
+v:val		Value of the current item of a |List| or |Dictionary|.  Only
+		valid while evaluating the expression used with |map()| and
+		|filter()|.  Read-only.
+
+					*v:version* *version-variable*
+v:version	Version number of Vim: Major version number times 100 plus
+		minor version number.  Version 5.0 is 500.  Version 5.1 (5.01)
+		is 501.  Read-only.  "version" also works, for backwards
+		compatibility.
+		Use |has()| to check if a certain patch was included, e.g.: >
+			if has("patch-7.4.123")
+<		Note that patch numbers are specific to the version, thus both
+		version 5.0 and 5.1 may have a patch 123, but these are
+		completely different.
+
+				*v:vim_did_enter* *vim_did_enter-variable*
+v:vim_did_enter	Zero until most of startup is done.  It is set to one just
+		before |VimEnter| autocommands are triggered.
+
+					*v:warningmsg* *warningmsg-variable*
+v:warningmsg	Last given warning message.  It's allowed to set this variable.
+
+					*v:windowid* *windowid-variable*
+v:windowid	When any X11 based GUI is running or when running in a
+		terminal and Vim connects to the X server (|-X|) this will be
+		set to the window ID.
+		When an MS-Windows GUI is running this will be set to the
+		window handle.
+		Otherwise the value is zero.
+		Note: for windows inside Vim use |winnr()| or |win_getid()|,
+		see |window-ID|.
+
+==============================================================================
+4. Builtin Functions					*functions*
+
+See |function-list| for a list grouped by what the function is used for.
+
+(Use CTRL-] on the function name to jump to the full explanation.)
+
+USAGE				RESULT	DESCRIPTION	~
+
+abs({expr})			Float or Number  absolute value of {expr}
+acos({expr})			Float	arc cosine of {expr}
+add({list}, {item})		List	append {item} to |List| {list}
+and({expr}, {expr})		Number	bitwise AND
+append({lnum}, {string})	Number	append {string} below line {lnum}
+append({lnum}, {list})		Number	append lines {list} below line {lnum}
+argc()				Number	number of files in the argument list
+argidx()			Number	current index in the argument list
+arglistid([{winnr} [, {tabnr}]]) Number	argument list id
+argv({nr})			String	{nr} entry of the argument list
+argv()				List	the argument list
+assert_beeps({cmd})		Number	assert {cmd} causes a beep
+assert_equal({exp}, {act} [, {msg}])
+				Number	assert {exp} is equal to {act}
+assert_equalfile({fname-one}, {fname-two})
+				Number	assert file contents is equal
+assert_exception({error} [, {msg}])
+				Number	assert {error} is in v:exception
+assert_fails({cmd} [, {error}])	Number	assert {cmd} fails
+assert_false({actual} [, {msg}])
+				Number	assert {actual} is false
+assert_inrange({lower}, {upper}, {actual} [, {msg}])
+				Number	assert {actual} is inside the range
+assert_match({pat}, {text} [, {msg}])
+				Number	assert {pat} matches {text}
+assert_notequal({exp}, {act} [, {msg}])
+				Number	assert {exp} is not equal {act}
+assert_notmatch({pat}, {text} [, {msg}])
+				Number	assert {pat} not matches {text}
+assert_report({msg})		Number	report a test failure
+assert_true({actual} [, {msg}])	Number	assert {actual} is true
+asin({expr})			Float	arc sine of {expr}
+atan({expr})			Float	arc tangent of {expr}
+atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
+balloon_show({expr})		none	show {expr} inside the balloon
+balloon_split({msg})		List	split {msg} as used for a balloon
+browse({save}, {title}, {initdir}, {default})
+				String	put up a file requester
+browsedir({title}, {initdir})	String	put up a directory requester
+bufexists({expr})		Number	|TRUE| if buffer {expr} exists
+buflisted({expr})		Number	|TRUE| if buffer {expr} is listed
+bufloaded({expr})		Number	|TRUE| if buffer {expr} is loaded
+bufname({expr})			String	Name of the buffer {expr}
+bufnr({expr} [, {create}])	Number	Number of the buffer {expr}
+bufwinid({expr})		Number	window ID of buffer {expr}
+bufwinnr({expr})		Number	window number of buffer {expr}
+byte2line({byte})		Number	line number at byte count {byte}
+byteidx({expr}, {nr})		Number	byte index of {nr}'th char in {expr}
+byteidxcomp({expr}, {nr})	Number	byte index of {nr}'th char in {expr}
+call({func}, {arglist} [, {dict}])
+				any	call {func} with arguments {arglist}
+ceil({expr})			Float	round {expr} up
+ch_canread({handle})		Number	check if there is something to read
+ch_close({handle})		none	close {handle}
+ch_close_in({handle})		none	close in part of {handle}
+ch_evalexpr({handle}, {expr} [, {options}])
+				any	evaluate {expr} on JSON {handle}
+ch_evalraw({handle}, {string} [, {options}])
+				any	evaluate {string} on raw {handle}
+ch_getbufnr({handle}, {what})	Number	get buffer number for {handle}/{what}
+ch_getjob({channel})		Job	get the Job of {channel}
+ch_info({handle})		String	info about channel {handle}
+ch_log({msg} [, {handle}])	none	write {msg} in the channel log file
+ch_logfile({fname} [, {mode}])	none	start logging channel activity
+ch_open({address} [, {options}])
+				Channel	open a channel to {address}
+ch_read({handle} [, {options}]) String	read from {handle}
+ch_readraw({handle} [, {options}])
+				String	read raw from {handle}
+ch_sendexpr({handle}, {expr} [, {options}])
+				any	send {expr} over JSON {handle}
+ch_sendraw({handle}, {string} [, {options}])
+				any	send {string} over raw {handle}
+ch_setoptions({handle}, {options})
+				none	set options for {handle}
+ch_status({handle} [, {options}])
+				String	status of channel {handle}
+changenr()			Number	current change number
+char2nr({expr} [, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
+cindent({lnum})			Number	C indent for line {lnum}
+clearmatches()			none	clear all matches
+col({expr})			Number	column nr of cursor or mark
+complete({startcol}, {matches}) none	set Insert mode completion
+complete_add({expr})		Number	add completion match
+complete_check()		Number	check for key typed during completion
+confirm({msg} [, {choices} [, {default} [, {type}]]])
+				Number	number of choice picked by user
+copy({expr})			any	make a shallow copy of {expr}
+cos({expr})			Float	cosine of {expr}
+cosh({expr})			Float	hyperbolic cosine of {expr}
+count({list}, {expr} [, {ic} [, {start}]])
+				Number	count how many {expr} are in {list}
+cscope_connection([{num}, {dbpath} [, {prepend}]])
+				Number	checks existence of cscope connection
+cursor({lnum}, {col} [, {off}])
+				Number	move cursor to {lnum}, {col}, {off}
+cursor({list})			Number	move cursor to position in {list}
+debugbreak({pid})		Number  interrupt process being debugged
+deepcopy({expr} [, {noref}])	any	make a full copy of {expr}
+delete({fname} [, {flags}])	Number	delete the file or directory {fname}
+deletebufline({expr}, {first} [, {last}])
+				Number	delete lines from buffer {expr}
+did_filetype()			Number	|TRUE| if FileType autocmd event used
+diff_filler({lnum})		Number	diff filler lines about {lnum}
+diff_hlID({lnum}, {col})	Number	diff highlighting at {lnum}/{col}
+empty({expr})			Number	|TRUE| if {expr} is empty
+escape({string}, {chars})	String	escape {chars} in {string} with '\'
+eval({string})			any	evaluate {string} into its value
+eventhandler()			Number	|TRUE| if inside an event handler
+executable({expr})		Number	1 if executable {expr} exists
+execute({command})		String	execute {command} and get the output
+exepath({expr})			String	full path of the command {expr}
+exists({expr})			Number	|TRUE| if {expr} exists
+extend({expr1}, {expr2} [, {expr3}])
+				List/Dict insert items of {expr2} into {expr1}
+exp({expr})			Float	exponential of {expr}
+expand({expr} [, {nosuf} [, {list}]])
+				any	expand special keywords in {expr}
+feedkeys({string} [, {mode}])	Number	add key sequence to typeahead buffer
+filereadable({file})		Number	|TRUE| if {file} is a readable file
+filewritable({file})		Number	|TRUE| if {file} is a writable file
+filter({expr1}, {expr2})	List/Dict  remove items from {expr1} where
+					{expr2} is 0
+finddir({name} [, {path} [, {count}]])
+				String	find directory {name} in {path}
+findfile({name} [, {path} [, {count}]])
+				String	find file {name} in {path}
+float2nr({expr})		Number	convert Float {expr} to a Number
+floor({expr})			Float	round {expr} down
+fmod({expr1}, {expr2})		Float	remainder of {expr1} / {expr2}
+fnameescape({fname})		String	escape special characters in {fname}
+fnamemodify({fname}, {mods})	String	modify file name
+foldclosed({lnum})		Number	first line of fold at {lnum} if closed
+foldclosedend({lnum})		Number	last line of fold at {lnum} if closed
+foldlevel({lnum})		Number	fold level at {lnum}
+foldtext()			String	line displayed for closed fold
+foldtextresult({lnum})		String	text for closed fold at {lnum}
+foreground()			Number	bring the Vim window to the foreground
+funcref({name} [, {arglist}] [, {dict}])
+				Funcref	reference to function {name}
+function({name} [, {arglist}] [, {dict}])
+				Funcref	named reference to function {name}
+garbagecollect([{atexit}])	none	free memory, breaking cyclic references
+get({list}, {idx} [, {def}])	any	get item {idx} from {list} or {def}
+get({dict}, {key} [, {def}])	any	get item {key} from {dict} or {def}
+get({func}, {what})		any	get property of funcref/partial {func}
+getbufinfo([{expr}])		List	information about buffers
+getbufline({expr}, {lnum} [, {end}])
+				List	lines {lnum} to {end} of buffer {expr}
+getbufvar({expr}, {varname} [, {def}])
+				any	variable {varname} in buffer {expr}
+getchangelist({expr})		List	list of change list items
+getchar([expr])			Number	get one character from the user
+getcharmod()			Number	modifiers for the last typed character
+getcharsearch()			Dict	last character search
+getcmdline()			String	return the current command-line
+getcmdpos()			Number	return cursor position in command-line
+getcmdtype()			String	return current command-line type
+getcmdwintype()			String	return current command-line window type
+getcompletion({pat}, {type} [, {filtered}])
+				List	list of cmdline completion matches
+getcurpos()			List	position of the cursor
+getcwd([{winnr} [, {tabnr}]])	String	get the current working directory
+getfontname([{name}])		String	name of font being used
+getfperm({fname})		String	file permissions of file {fname}
+getfsize({fname})		Number	size in bytes of file {fname}
+getftime({fname})		Number	last modification time of file
+getftype({fname})		String	description of type of file {fname}
+getjumplist([{winnr} [, {tabnr}]])
+				List	list of jump list items
+getline({lnum})			String	line {lnum} of current buffer
+getline({lnum}, {end})		List	lines {lnum} to {end} of current buffer
+getloclist({nr} [, {what}])	List	list of location list items
+getmatches()			List	list of current matches
+getpid()			Number	process ID of Vim
+getpos({expr})			List	position of cursor, mark, etc.
+getqflist([{what}])		List	list of quickfix items
+getreg([{regname} [, 1 [, {list}]]])
+				String or List   contents of register
+getregtype([{regname}])		String	type of register
+gettabinfo([{expr}])		List	list of tab pages
+gettabvar({nr}, {varname} [, {def}])
+				any	variable {varname} in tab {nr} or {def}
+gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
+				any	{name} in {winnr} in tab page {tabnr}
+getwininfo([{winid}])		List	list of info about each window
+getwinpos([{timeout}])		List	X and Y coord in pixels of the Vim window
+getwinposx()			Number	X coord in pixels of the Vim window
+getwinposy()			Number	Y coord in pixels of the Vim window
+getwinvar({nr}, {varname} [, {def}])
+				any	variable {varname} in window {nr}
+glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
+				any	expand file wildcards in {expr}
+glob2regpat({expr})		String	convert a glob pat into a search pat
+globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
+				String	do glob({expr}) for all dirs in {path}
+has({feature})			Number	|TRUE| if feature {feature} supported
+has_key({dict}, {key})		Number	|TRUE| if {dict} has entry {key}
+haslocaldir([{winnr} [, {tabnr}]])
+				Number	|TRUE| if the window executed |:lcd|
+hasmapto({what} [, {mode} [, {abbr}]])
+				Number	|TRUE| if mapping to {what} exists
+histadd({history}, {item})	String	add an item to a history
+histdel({history} [, {item}])	String	remove an item from a history
+histget({history} [, {index}])	String	get the item {index} from a history
+histnr({history})		Number	highest index of a history
+hlexists({name})		Number	|TRUE| if highlight group {name} exists
+hlID({name})			Number	syntax ID of highlight group {name}
+hostname()			String	name of the machine Vim is running on
+iconv({expr}, {from}, {to})	String	convert encoding of {expr}
+indent({lnum})			Number	indent of line {lnum}
+index({list}, {expr} [, {start} [, {ic}]])
+				Number	index in {list} where {expr} appears
+input({prompt} [, {text} [, {completion}]])
+				String	get input from the user
+inputdialog({prompt} [, {text} [, {completion}]])
+				String	like input() but in a GUI dialog
+inputlist({textlist})		Number	let the user pick from a choice list
+inputrestore()			Number	restore typeahead
+inputsave()			Number	save and clear typeahead
+inputsecret({prompt} [, {text}]) String	like input() but hiding the text
+insert({list}, {item} [, {idx}]) List	insert {item} in {list} [before {idx}]
+invert({expr})			Number	bitwise invert
+isdirectory({directory})	Number	|TRUE| if {directory} is a directory
+islocked({expr})		Number	|TRUE| if {expr} is locked
+isnan({expr})			Number	|TRUE| if {expr} is NaN
+items({dict})			List	key-value pairs in {dict}
+job_getchannel({job})		Channel	get the channel handle for {job}
+job_info([{job}])		Dict	get information about {job}
+job_setoptions({job}, {options}) none	set options for {job}
+job_start({command} [, {options}])
+				Job	start a job
+job_status({job})		String	get the status of {job}
+job_stop({job} [, {how}])	Number	stop {job}
+join({list} [, {sep}])		String	join {list} items into one String
+js_decode({string})		any	decode JS style JSON
+js_encode({expr})		String	encode JS style JSON
+json_decode({string})		any	decode JSON
+json_encode({expr})		String	encode JSON
+keys({dict})			List	keys in {dict}
+len({expr})			Number	the length of {expr}
+libcall({lib}, {func}, {arg})	String	call {func} in library {lib} with {arg}
+libcallnr({lib}, {func}, {arg})	Number	idem, but return a Number
+line({expr})			Number	line nr of cursor, last line or mark
+line2byte({lnum})		Number	byte count of line {lnum}
+lispindent({lnum})		Number	Lisp indent for line {lnum}
+localtime()			Number	current time
+log({expr})			Float	natural logarithm (base e) of {expr}
+log10({expr})			Float	logarithm of Float {expr} to base 10
+luaeval({expr} [, {expr}])	any	evaluate |Lua| expression
+map({expr1}, {expr2})		List/Dict  change each item in {expr1} to {expr}
+maparg({name} [, {mode} [, {abbr} [, {dict}]]])
+				String or Dict
+					rhs of mapping {name} in mode {mode}
+mapcheck({name} [, {mode} [, {abbr}]])
+				String	check for mappings matching {name}
+match({expr}, {pat} [, {start} [, {count}]])
+				Number	position where {pat} matches in {expr}
+matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
+				Number	highlight {pattern} with {group}
+matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
+				Number	highlight positions with {group}
+matcharg({nr})			List	arguments of |:match|
+matchdelete({id})		Number	delete match identified by {id}
+matchend({expr}, {pat} [, {start} [, {count}]])
+				Number	position where {pat} ends in {expr}
+matchlist({expr}, {pat} [, {start} [, {count}]])
+				List	match and submatches of {pat} in {expr}
+matchstr({expr}, {pat} [, {start} [, {count}]])
+				String	{count}'th match of {pat} in {expr}
+matchstrpos({expr}, {pat} [, {start} [, {count}]])
+				List	{count}'th match of {pat} in {expr}
+max({expr})			Number	maximum value of items in {expr}
+min({expr})			Number	minimum value of items in {expr}
+mkdir({name} [, {path} [, {prot}]])
+				Number	create directory {name}
+mode([expr])			String	current editing mode
+mzeval({expr})			any	evaluate |MzScheme| expression
+nextnonblank({lnum})		Number	line nr of non-blank line >= {lnum}
+nr2char({expr} [, {utf8}])	String	single char with ASCII/UTF8 value {expr}
+or({expr}, {expr})		Number	bitwise OR
+pathshorten({expr})		String	shorten directory names in a path
+perleval({expr})		any	evaluate |Perl| expression
+pow({x}, {y})			Float	{x} to the power of {y}
+prevnonblank({lnum})		Number	line nr of non-blank line <= {lnum}
+printf({fmt}, {expr1}...)	String	format text
+prompt_addtext({buf}, {expr})	none	add text to a prompt buffer
+prompt_setcallback({buf}, {expr}) none	set prompt callback function
+prompt_setinterrupt({buf}, {text}) none	set prompt interrupt function
+prompt_setprompt({buf}, {text}) none	set prompt text
+pumvisible()			Number	whether popup menu is visible
+pyeval({expr})			any	evaluate |Python| expression
+py3eval({expr})			any	evaluate |python3| expression
+pyxeval({expr})			any	evaluate |python_x| expression
+range({expr} [, {max} [, {stride}]])
+				List	items from {expr} to {max}
+readfile({fname} [, {binary} [, {max}]])
+				List	get list of lines from file {fname}
+reg_executing()			String	get the executing register name
+reg_recording()			String	get the recording register name
+reltime([{start} [, {end}]])	List	get time value
+reltimefloat({time})		Float	turn the time value into a Float
+reltimestr({time})		String	turn time value into a String
+remote_expr({server}, {string} [, {idvar} [, {timeout}]])
+				String	send expression
+remote_foreground({server})	Number	bring Vim server to the foreground
+remote_peek({serverid} [, {retvar}])
+				Number	check for reply string
+remote_read({serverid} [, {timeout}])
+				String	read reply string
+remote_send({server}, {string} [, {idvar}])
+				String	send key sequence
+remote_startserver({name})	none	become server {name}
+				String	send key sequence
+remove({list}, {idx} [, {end}])	any	remove items {idx}-{end} from {list}
+remove({dict}, {key})		any	remove entry {key} from {dict}
+rename({from}, {to})		Number	rename (move) file from {from} to {to}
+repeat({expr}, {count})		String	repeat {expr} {count} times
+resolve({filename})		String	get filename a shortcut points to
+reverse({list})			List	reverse {list} in-place
+round({expr})			Float	round off {expr}
+screenattr({row}, {col})	Number	attribute at screen position
+screenchar({row}, {col})	Number	character at screen position
+screencol()			Number	current cursor column
+screenrow()			Number	current cursor row
+search({pattern} [, {flags} [, {stopline} [, {timeout}]]])
+				Number	search for {pattern}
+searchdecl({name} [, {global} [, {thisblock}]])
+				Number	search for variable declaration
+searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
+				Number	search for other end of start/end pair
+searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
+				List	search for other end of start/end pair
+searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])
+				List	search for {pattern}
+server2client({clientid}, {string})
+				Number	send reply string
+serverlist()			String	get a list of available servers
+setbufline({expr}, {lnum}, {line})
+				Number	set line {lnum} to {line} in buffer
+					{expr}
+setbufvar({expr}, {varname}, {val})
+				none	set {varname} in buffer {expr} to {val}
+setcharsearch({dict})		Dict	set character search from {dict}
+setcmdpos({pos})		Number	set cursor position in command-line
+setfperm({fname}, {mode})	Number	set {fname} file permissions to {mode}
+setline({lnum}, {line})		Number	set line {lnum} to {line}
+setloclist({nr}, {list} [, {action} [, {what}]])
+				Number	modify location list using {list}
+setmatches({list})		Number	restore a list of matches
+setpos({expr}, {list})		Number	set the {expr} position to {list}
+setqflist({list} [, {action} [, {what}]])
+				Number	modify quickfix list using {list}
+setreg({n}, {v} [, {opt}])	Number	set register to value and type
+settabvar({nr}, {varname}, {val}) none	set {varname} in tab page {nr} to {val}
+settabwinvar({tabnr}, {winnr}, {varname}, {val})
+				none	set {varname} in window {winnr} in tab
+					page {tabnr} to {val}
+setwinvar({nr}, {varname}, {val}) none	set {varname} in window {nr} to {val}
+sha256({string})		String	SHA256 checksum of {string}
+shellescape({string} [, {special}])
+				String	escape {string} for use as shell
+					command argument
+shiftwidth()			Number	effective value of 'shiftwidth'
+simplify({filename})		String	simplify filename as much as possible
+sin({expr})			Float	sine of {expr}
+sinh({expr})			Float	hyperbolic sine of {expr}
+sort({list} [, {func} [, {dict}]])
+				List	sort {list}, using {func} to compare
+soundfold({word})		String	sound-fold {word}
+spellbadword()			String	badly spelled word at cursor
+spellsuggest({word} [, {max} [, {capital}]])
+				List	spelling suggestions
+split({expr} [, {pat} [, {keepempty}]])
+				List	make |List| from {pat} separated {expr}
+sqrt({expr})			Float	square root of {expr}
+str2float({expr})		Float	convert String to Float
+str2nr({expr} [, {base}])	Number	convert String to Number
+strchars({expr} [, {skipcc}])	Number	character length of the String {expr}
+strcharpart({str}, {start} [, {len}])
+				String	{len} characters of {str} at {start}
+strdisplaywidth({expr} [, {col}]) Number display length of the String {expr}
+strftime({format} [, {time}])	String	time in specified format
+strgetchar({str}, {index})	Number	get char {index} from {str}
+stridx({haystack}, {needle} [, {start}])
+				Number	index of {needle} in {haystack}
+string({expr})			String	String representation of {expr} value
+strlen({expr})			Number	length of the String {expr}
+strpart({str}, {start} [, {len}])
+				String	{len} characters of {str} at {start}
+strridx({haystack}, {needle} [, {start}])
+				Number	last index of {needle} in {haystack}
+strtrans({expr})		String	translate string to make it printable
+strwidth({expr})		Number	display cell length of the String {expr}
+submatch({nr} [, {list}])	String or List
+					specific match in ":s" or substitute()
+substitute({expr}, {pat}, {sub}, {flags})
+				String	all {pat} in {expr} replaced with {sub}
+swapinfo({fname})		Dict	information about swap file {fname}
+synID({lnum}, {col}, {trans})	Number	syntax ID at {lnum} and {col}
+synIDattr({synID}, {what} [, {mode}])
+				String	attribute {what} of syntax ID {synID}
+synIDtrans({synID})		Number	translated syntax ID of {synID}
+synconcealed({lnum}, {col})	List	info about concealing
+synstack({lnum}, {col})		List	stack of syntax IDs at {lnum} and {col}
+system({expr} [, {input}])	String	output of shell command/filter {expr}
+systemlist({expr} [, {input}])	List	output of shell command/filter {expr}
+tabpagebuflist([{arg}])		List	list of buffer numbers in tab page
+tabpagenr([{arg}])		Number	number of current or last tab page
+tabpagewinnr({tabarg} [, {arg}]) Number	number of current window in tab page
+taglist({expr} [, {filename}])	List	list of tags matching {expr}
+tagfiles()			List	tags files used
+tan({expr})			Float	tangent of {expr}
+tanh({expr})			Float	hyperbolic tangent of {expr}
+tempname()			String	name for a temporary file
+term_dumpdiff({filename}, {filename} [, {options}])
+				Number  display difference between two dumps
+term_dumpload({filename} [, {options}])
+				Number	displaying a screen dump
+term_dumpwrite({buf}, {filename} [, {options}])
+				none	dump terminal window contents
+term_getaltscreen({buf})	Number	get the alternate screen flag
+term_getansicolors({buf})	List	get ANSI palette in GUI color mode
+term_getattr({attr}, {what})	Number	get the value of attribute {what}
+term_getcursor({buf})		List	get the cursor position of a terminal
+term_getjob({buf})		Job	get the job associated with a terminal
+term_getline({buf}, {row})	String	get a line of text from a terminal
+term_getscrolled({buf})		Number	get the scroll count of a terminal
+term_getsize({buf})		List	get the size of a terminal
+term_getstatus({buf})		String	get the status of a terminal
+term_gettitle({buf})		String	get the title of a terminal
+term_gettty({buf}, [{input}])	String	get the tty name of a terminal
+term_list()			List	get the list of terminal buffers
+term_scrape({buf}, {row})	List	get row of a terminal screen
+term_sendkeys({buf}, {keys})	none	send keystrokes to a terminal
+term_setansicolors({buf}, {colors})
+				none	set ANSI palette in GUI color mode
+term_setkill({buf}, {how})	none	set signal to stop job in terminal
+term_setrestore({buf}, {command}) none	set command to restore terminal
+term_setsize({buf}, {rows}, {cols})
+				none	set the size of a terminal
+term_start({cmd}, {options})	Job	open a terminal window and run a job
+term_wait({buf} [, {time}])	Number  wait for screen to be updated
+test_alloc_fail({id}, {countdown}, {repeat})
+				none	make memory allocation fail
+test_autochdir()		none	enable 'autochdir' during startup
+test_feedinput()		none	add key sequence to input buffer
+test_garbagecollect_now()	none	free memory right now for testing
+test_ignore_error({expr})	none	ignore a specific error
+test_null_channel()		Channel	null value for testing
+test_null_dict()		Dict	null value for testing
+test_null_job()			Job	null value for testing
+test_null_list()		List	null value for testing
+test_null_partial()		Funcref	null value for testing
+test_null_string()		String	null value for testing
+test_override({expr}, {val})    none	test with Vim internal overrides
+test_settime({expr})		none	set current time for testing
+timer_info([{id}])		List	information about timers
+timer_pause({id}, {pause})	none	pause or unpause a timer
+timer_start({time}, {callback} [, {options}])
+				Number	create a timer
+timer_stop({timer})		none	stop a timer
+timer_stopall()			none	stop all timers
+tolower({expr})			String	the String {expr} switched to lowercase
+toupper({expr})			String	the String {expr} switched to uppercase
+tr({src}, {fromstr}, {tostr})	String	translate chars of {src} in {fromstr}
+					to chars in {tostr}
+trim({text} [, {mask}])		String	trim characters in {mask} from {text}
+trunc({expr})			Float	truncate Float {expr}
+type({name})			Number	type of variable {name}
+undofile({name})		String	undo file name for {name}
+undotree()			List	undo file tree
+uniq({list} [, {func} [, {dict}]])
+				List	remove adjacent duplicates from a list
+values({dict})			List	values in {dict}
+virtcol({expr})			Number	screen column of cursor or mark
+visualmode([expr])		String	last visual mode used
+wildmenumode()			Number	whether 'wildmenu' mode is active
+win_findbuf({bufnr})		List	find windows containing {bufnr}
+win_getid([{win} [, {tab}]])	Number	get window ID for {win} in {tab}
+win_gotoid({expr})		Number	go to window with ID {expr}
+win_id2tabwin({expr})		List	get tab and window nr from window ID
+win_id2win({expr})		Number	get window nr from window ID
+win_screenpos({nr})		List	get screen position of window {nr}
+winbufnr({nr})			Number	buffer number of window {nr}
+wincol()			Number	window column of the cursor
+winheight({nr})			Number	height of window {nr}
+winlayout([{tabnr}])		List	layout of windows in tab {tabnr}
+winline()			Number	window line of the cursor
+winnr([{expr}])			Number	number of current window
+winrestcmd()			String	returns command to restore window sizes
+winrestview({dict})		none	restore view of current window
+winsaveview()			Dict	save view of current window
+winwidth({nr})			Number	width of window {nr}
+wordcount()			Dict	get byte/char/word statistics
+writefile({list}, {fname} [, {flags}])
+				Number	write list of lines to file {fname}
+xor({expr}, {expr})		Number	bitwise XOR
+
+
+abs({expr})							*abs()*
+		Return the absolute value of {expr}.  When {expr} evaluates to
+		a |Float| abs() returns a |Float|.  When {expr} can be
+		converted to a |Number| abs() returns a |Number|.  Otherwise
+		abs() gives an error message and returns -1.
+		Examples: >
+			echo abs(1.456)
+<			1.456  >
+			echo abs(-5.456)
+<			5.456  >
+			echo abs(-4)
+<			4
+		{only available when compiled with the |+float| feature}
+
+
+acos({expr})							*acos()*
+		Return the arc cosine of {expr} measured in radians, as a
+		|Float| in the range of [0, pi].
+		{expr} must evaluate to a |Float| or a |Number| in the range
+		[-1, 1].
+		Examples: >
+			:echo acos(0)
+<			1.570796 >
+			:echo acos(-0.5)
+<			2.094395
+		{only available when compiled with the |+float| feature}
+
+
+add({list}, {expr})					*add()*
+		Append the item {expr} to |List| {list}.  Returns the
+		resulting |List|.  Examples: >
+			:let alist = add([1, 2, 3], item)
+			:call add(mylist, "woodstock")
+<		Note that when {expr} is a |List| it is appended as a single
+		item.  Use |extend()| to concatenate |Lists|.
+		Use |insert()| to add an item at another position.
+
+
+and({expr}, {expr})					*and()*
+		Bitwise AND on the two arguments.  The arguments are converted
+		to a number.  A List, Dict or Float argument causes an error.
+		Example: >
+			:let flag = and(bits, 0x80)
+
+
+append({lnum}, {expr})					*append()*
+		When {expr} is a |List|: Append each item of the |List| as a
+		text line below line {lnum} in the current buffer.
+		Otherwise append {expr} as one text line below line {lnum} in
+		the current buffer.
+		{lnum} can be zero to insert a line before the first one.
+		Returns 1 for failure ({lnum} out of range or out of memory),
+		0 for success.  Example: >
+			:let failed = append(line('$'), "# THE END")
+			:let failed = append(0, ["Chapter 1", "the beginning"])
+
+appendbufline({expr}, {lnum}, {text})			*appendbufline()*
+		Like |append()| but append the text in buffer {expr}.
+
+		For the use of {expr}, see |bufname()|.
+
+		{lnum} is used like with |append()|.  Note that using |line()|
+		would use the current buffer, not the one appending to.
+		Use "$" to append at the end of the buffer.
+
+		On success 0 is returned, on failure 1 is returned.
+
+		If {expr} is not a valid buffer or {lnum} is not valid, an
+		error message is given. Example: >
+			:let failed = appendbufline(13, 0, "# THE START")
+<
+							*argc()*
+argc()		The result is the number of files in the argument list of the
+		current window.  See |arglist|.
+
+							*argidx()*
+argidx()	The result is the current index in the argument list.  0 is
+		the first file.  argc() - 1 is the last one.  See |arglist|.
+
+							*arglistid()*
+arglistid([{winnr} [, {tabnr}]])
+		Return the argument list ID.  This is a number which
+		identifies the argument list being used.  Zero is used for the
+		global argument list.  See |arglist|.
+		Return -1 if the arguments are invalid.
+
+		Without arguments use the current window.
+		With {winnr} only use this window in the current tab page.
+		With {winnr} and {tabnr} use the window in the specified tab
+		page.
+		{winnr} can be the window number or the |window-ID|.
+
+							*argv()*
+argv([{nr}])	The result is the {nr}th file in the argument list of the
+		current window.  See |arglist|.  "argv(0)" is the first one.
+		Example: >
+	:let i = 0
+	:while i < argc()
+	:  let f = escape(fnameescape(argv(i)), '.')
+	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
+	:  let i = i + 1
+	:endwhile
+<		Without the {nr} argument a |List| with the whole |arglist| is
+		returned.
+
+assert_beeps({cmd})					*assert_beeps()*
+		Run {cmd} and add an error message to |v:errors| if it does
+		NOT produce a beep or visual bell.
+		Also see |assert_fails()| and |assert-return|.
+
+							*assert_equal()*
+assert_equal({expected}, {actual} [, {msg}])
+		When {expected} and {actual} are not equal an error message is
+		added to |v:errors| and 1 is returned.  Otherwise zero is
+		returned |assert-return|.
+		There is no automatic conversion, the String "4" is different
+		from the Number 4.  And the number 4 is different from the
+		Float 4.0.  The value of 'ignorecase' is not used here, case
+		always matters.
+		When {msg} is omitted an error in the form "Expected
+		{expected} but got {actual}" is produced.
+		Example: >
+	assert_equal('foo', 'bar')
+<		Will result in a string to be added to |v:errors|:
+	test.vim line 12: Expected 'foo' but got 'bar' ~
+
+							*assert_equalfile()*
+assert_equalfile({fname-one}, {fname-two})
+		When the files {fname-one} and {fname-two} do not contain
+		exactly the same text an error message is added to |v:errors|.
+		Also see |assert-return|.
+		When {fname-one} or {fname-two} does not exist the error will
+		mention that.
+		Mainly useful with |terminal-diff|.
+
+assert_exception({error} [, {msg}])			*assert_exception()*
+		When v:exception does not contain the string {error} an error
+		message is added to |v:errors|.  Also see |assert-return|.
+		This can be used to assert that a command throws an exception.
+		Using the error number, followed by a colon, avoids problems
+		with translations: >
+			try
+			  commandthatfails
+			  call assert_false(1, 'command should have failed')
+			catch
+			  call assert_exception('E492:')
+			endtry
+
+assert_fails({cmd} [, {error}])					*assert_fails()*
+		Run {cmd} and add an error message to |v:errors| if it does
+		NOT produce an error.  Also see |assert-return|.
+		When {error} is given it must match in |v:errmsg|.
+		Note that beeping is not considered an error, and some failing
+		commands only beep.  Use |assert_beeps()| for those.
+
+assert_false({actual} [, {msg}])				*assert_false()*
+		When {actual} is not false an error message is added to
+		|v:errors|, like with |assert_equal()|. 
+		Also see |assert-return|.
+		A value is false when it is zero. When {actual} is not a
+		number the assert fails.
+		When {msg} is omitted an error in the form
+		"Expected False but got {actual}" is produced.
+
+assert_inrange({lower}, {upper}, {actual} [, {msg}])	 *assert_inrange()*
+		This asserts number values.  When {actual}  is lower than
+		{lower} or higher than {upper} an error message is added to
+		|v:errors|.  Also see |assert-return|.
+		When {msg} is omitted an error in the form
+		"Expected range {lower} - {upper}, but got {actual}" is
+		produced.
+
+								*assert_match()*
+assert_match({pattern}, {actual} [, {msg}])
+		When {pattern} does not match {actual} an error message is
+		added to |v:errors|.  Also see |assert-return|.
+
+		{pattern} is used as with |=~|: The matching is always done
+		like 'magic' was set and 'cpoptions' is empty, no matter what
+		the actual value of 'magic' or 'cpoptions' is.
+
+		{actual} is used as a string, automatic conversion applies.
+		Use "^" and "$" to match with the start and end of the text.
+		Use both to match the whole text.
+
+		When {msg} is omitted an error in the form
+		"Pattern {pattern} does not match {actual}" is produced.
+		Example: >
+	assert_match('^f.*o$', 'foobar')
+<		Will result in a string to be added to |v:errors|:
+	test.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~
+
+							*assert_notequal()*
+assert_notequal({expected}, {actual} [, {msg}])
+		The opposite of `assert_equal()`: add an error message to
+		|v:errors| when {expected} and {actual} are equal.
+		Also see |assert-return|.
+
+							*assert_notmatch()*
+assert_notmatch({pattern}, {actual} [, {msg}])
+		The opposite of `assert_match()`: add an error message to
+		|v:errors| when {pattern} matches {actual}.
+		Also see |assert-return|.
+
+assert_report({msg})					*assert_report()*
+		Report a test failure directly, using {msg}.
+		Always returns one.
+
+assert_true({actual} [, {msg}])				*assert_true()*
+		When {actual} is not true an error message is added to
+		|v:errors|, like with |assert_equal()|.
+		Also see |assert-return|.
+		A value is TRUE when it is a non-zero number.  When {actual}
+		is not a number the assert fails.
+		When {msg} is omitted an error in the form "Expected True but
+		got {actual}" is produced.
+
+asin({expr})						*asin()*
+		Return the arc sine of {expr} measured in radians, as a |Float|
+		in the range of [-pi/2, pi/2].
+		{expr} must evaluate to a |Float| or a |Number| in the range
+		[-1, 1].
+		Examples: >
+			:echo asin(0.8)
+<			0.927295 >
+			:echo asin(-0.5)
+<			-0.523599
+		{only available when compiled with the |+float| feature}
+
+
+atan({expr})						*atan()*
+		Return the principal value of the arc tangent of {expr}, in
+		the range [-pi/2, +pi/2] radians, as a |Float|.
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo atan(100)
+<			1.560797 >
+			:echo atan(-4.01)
+<			-1.326405
+		{only available when compiled with the |+float| feature}
+
+
+atan2({expr1}, {expr2})					*atan2()*
+		Return the arc tangent of {expr1} / {expr2}, measured in
+		radians, as a |Float| in the range [-pi, pi].
+		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo atan2(-1, 1)
+<			-0.785398 >
+			:echo atan2(1, -1)
+<			2.356194
+		{only available when compiled with the |+float| feature}
+
+balloon_show({expr})					*balloon_show()*
+		Show {expr} inside the balloon.  For the GUI {expr} is used as
+		a string.  For a terminal {expr} can be a list, which contains
+		the lines of the balloon.  If {expr} is not a list it will be
+		split with |balloon_split()|.
+
+		Example: >
+			func GetBalloonContent()
+			   " initiate getting the content
+			   return ''
+			endfunc
+			set balloonexpr=GetBalloonContent()
+
+			func BalloonCallback(result)
+			  call balloon_show(a:result)
+			endfunc
+<
+		The intended use is that fetching the content of the balloon
+		is initiated from 'balloonexpr'.  It will invoke an
+		asynchronous method, in which a callback invokes
+		balloon_show().  The 'balloonexpr' itself can return an
+		empty string or a placeholder.
+
+		When showing a balloon is not possible nothing happens, no
+		error message.
+		{only available when compiled with the +balloon_eval or
+		+balloon_eval_term feature}
+
+balloon_split({msg})					*balloon_split()*
+		Split {msg} into lines to be displayed in a balloon.  The
+		splits are made for the current window size and optimize to
+		show debugger output.
+		Returns a |List| with the split lines.
+		{only available when compiled with the +balloon_eval_term
+		feature}
+
+							*browse()*
+browse({save}, {title}, {initdir}, {default})
+		Put up a file requester.  This only works when "has("browse")"
+		returns |TRUE| (only in some GUI versions).
+		The input fields are:
+		    {save}	when |TRUE|, select file to write
+		    {title}	title for the requester
+		    {initdir}	directory to start browsing in
+		    {default}	default file name
+		When the "Cancel" button is hit, something went wrong, or
+		browsing is not possible, an empty string is returned.
+
+							*browsedir()*
+browsedir({title}, {initdir})
+		Put up a directory requester.  This only works when
+		"has("browse")" returns |TRUE| (only in some GUI versions).
+		On systems where a directory browser is not supported a file
+		browser is used.  In that case: select a file in the directory
+		to be used.
+		The input fields are:
+		    {title}	title for the requester
+		    {initdir}	directory to start browsing in
+		When the "Cancel" button is hit, something went wrong, or
+		browsing is not possible, an empty string is returned.
+
+bufexists({expr})					*bufexists()*
+		The result is a Number, which is |TRUE| if a buffer called
+		{expr} exists.
+		If the {expr} argument is a number, buffer numbers are used.
+		Number zero is the alternate buffer for the current window.
+
+		If the {expr} argument is a string it must match a buffer name
+		exactly.  The name can be:
+		- Relative to the current directory.
+		- A full path.
+		- The name of a buffer with 'buftype' set to "nofile".
+		- A URL name.
+		Unlisted buffers will be found.
+		Note that help files are listed by their short name in the
+		output of |:buffers|, but bufexists() requires using their
+		long name to be able to find them.
+		bufexists() may report a buffer exists, but to use the name
+		with a |:buffer| command you may need to use |expand()|.  Esp
+		for MS-Windows 8.3 names in the form "c:\DOCUME~1"
+		Use "bufexists(0)" to test for the existence of an alternate
+		file name.
+							*buffer_exists()*
+		Obsolete name: buffer_exists().
+
+buflisted({expr})					*buflisted()*
+		The result is a Number, which is |TRUE| if a buffer called
+		{expr} exists and is listed (has the 'buflisted' option set).
+		The {expr} argument is used like with |bufexists()|.
+
+bufloaded({expr})					*bufloaded()*
+		The result is a Number, which is |TRUE| if a buffer called
+		{expr} exists and is loaded (shown in a window or hidden).
+		The {expr} argument is used like with |bufexists()|.
+
+bufname({expr})						*bufname()*
+		The result is the name of a buffer, as it is displayed by the
+		":ls" command.
+		If {expr} is a Number, that buffer number's name is given.
+		Number zero is the alternate buffer for the current window.
+		If {expr} is a String, it is used as a |file-pattern| to match
+		with the buffer names.  This is always done like 'magic' is
+		set and 'cpoptions' is empty.  When there is more than one
+		match an empty string is returned.
+		"" or "%" can be used for the current buffer, "#" for the
+		alternate buffer.
+		A full match is preferred, otherwise a match at the start, end
+		or middle of the buffer name is accepted.  If you only want a
+		full match then put "^" at the start and "$" at the end of the
+		pattern.
+		Listed buffers are found first.  If there is a single match
+		with a listed buffer, that one is returned.  Next unlisted
+		buffers are searched for.
+		If the {expr} is a String, but you want to use it as a buffer
+		number, force it to be a Number by adding zero to it: >
+			:echo bufname("3" + 0)
+<		If the buffer doesn't exist, or doesn't have a name, an empty
+		string is returned. >
+	bufname("#")		alternate buffer name
+	bufname(3)		name of buffer 3
+	bufname("%")		name of current buffer
+	bufname("file2")	name of buffer where "file2" matches.
+<							*buffer_name()*
+		Obsolete name: buffer_name().
+
+							*bufnr()*
+bufnr({expr} [, {create}])
+		The result is the number of a buffer, as it is displayed by
+		the ":ls" command.  For the use of {expr}, see |bufname()|
+		above.
+		If the buffer doesn't exist, -1 is returned.  Or, if the
+		{create} argument is present and not zero, a new, unlisted,
+		buffer is created and its number is returned.
+		bufnr("$") is the last buffer: >
+	:let last_buffer = bufnr("$")
+<		The result is a Number, which is the highest buffer number
+		of existing buffers.  Note that not all buffers with a smaller
+		number necessarily exist, because ":bwipeout" may have removed
+		them.  Use bufexists() to test for the existence of a buffer.
+							*buffer_number()*
+		Obsolete name: buffer_number().
+							*last_buffer_nr()*
+		Obsolete name for bufnr("$"): last_buffer_nr().
+
+bufwinid({expr})					*bufwinid()*
+		The result is a Number, which is the |window-ID| of the first
+		window associated with buffer {expr}.  For the use of {expr},
+		see |bufname()| above.  If buffer {expr} doesn't exist or
+		there is no such window, -1 is returned.  Example: >
+
+	echo "A window containing buffer 1 is " . (bufwinid(1))
+<
+		Only deals with the current tab page.
+
+bufwinnr({expr})					*bufwinnr()*
+		The result is a Number, which is the number of the first
+		window associated with buffer {expr}.  For the use of {expr},
+		see |bufname()| above.  If buffer {expr} doesn't exist or
+		there is no such window, -1 is returned.  Example: >
+
+	echo "A window containing buffer 1 is " . (bufwinnr(1))
+
+<		The number can be used with |CTRL-W_w| and ":wincmd w"
+		|:wincmd|.
+		Only deals with the current tab page.
+
+byte2line({byte})					*byte2line()*
+		Return the line number that contains the character at byte
+		count {byte} in the current buffer.  This includes the
+		end-of-line character, depending on the 'fileformat' option
+		for the current buffer.  The first character has byte count
+		one.
+		Also see |line2byte()|, |go| and |:goto|.
+		{not available when compiled without the |+byte_offset|
+		feature}
+
+byteidx({expr}, {nr})					*byteidx()*
+		Return byte index of the {nr}'th character in the string
+		{expr}.  Use zero for the first character, it returns zero.
+		This function is only useful when there are multibyte
+		characters, otherwise the returned value is equal to {nr}.
+		Composing characters are not counted separately, their byte
+		length is added to the preceding base character.  See
+		|byteidxcomp()| below for counting composing characters
+		separately.
+		Example : >
+			echo matchstr(str, ".", byteidx(str, 3))
+<		will display the fourth character.  Another way to do the
+		same: >
+			let s = strpart(str, byteidx(str, 3))
+			echo strpart(s, 0, byteidx(s, 1))
+<		Also see |strgetchar()| and |strcharpart()|.
+
+		If there are less than {nr} characters -1 is returned.
+		If there are exactly {nr} characters the length of the string
+		in bytes is returned.
+
+byteidxcomp({expr}, {nr})					*byteidxcomp()*
+		Like byteidx(), except that a composing character is counted
+		as a separate character.  Example: >
+			let s = 'e' . nr2char(0x301)
+			echo byteidx(s, 1)
+			echo byteidxcomp(s, 1)
+			echo byteidxcomp(s, 2)
+<		The first and third echo result in 3 ('e' plus composing
+		character is 3 bytes), the second echo results in 1 ('e' is
+		one byte).
+		Only works different from byteidx() when 'encoding' is set to
+		a Unicode encoding.
+
+call({func}, {arglist} [, {dict}])			*call()* *E699*
+		Call function {func} with the items in |List| {arglist} as
+		arguments.
+		{func} can either be a |Funcref| or the name of a function.
+		a:firstline and a:lastline are set to the cursor line.
+		Returns the return value of the called function.
+		{dict} is for functions with the "dict" attribute.  It will be
+		used to set the local variable "self". |Dictionary-function|
+
+ceil({expr})							*ceil()*
+		Return the smallest integral value greater than or equal to
+		{expr} as a |Float| (round up).
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			echo ceil(1.456)
+<			2.0  >
+			echo ceil(-5.456)
+<			-5.0  >
+			echo ceil(4.0)
+<			4.0
+		{only available when compiled with the |+float| feature}
+
+ch_canread({handle})						*ch_canread()*
+		Return non-zero when there is something to read from {handle}.
+		{handle} can be a Channel or a Job that has a Channel.
+
+		This is useful to read from a channel at a convenient time,
+		e.g. from a timer.
+
+		Note that messages are dropped when the channel does not have
+		a callback.  Add a close callback to avoid that.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_close({handle})						*ch_close()*
+		Close {handle}.  See |channel-close|.
+		{handle} can be a Channel or a Job that has a Channel.
+		A close callback is not invoked.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_close_in({handle})						*ch_close_in()*
+		Close the "in" part of {handle}.  See |channel-close-in|.
+		{handle} can be a Channel or a Job that has a Channel.
+		A close callback is not invoked.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_evalexpr({handle}, {expr} [, {options}])			*ch_evalexpr()*
+		Send {expr} over {handle}.  The {expr} is encoded
+		according to the type of channel.  The function cannot be used
+		with a raw channel.  See |channel-use|.
+		{handle} can be a Channel or a Job that has a Channel.
+								*E917*
+		{options} must be a Dictionary.  It must not have a "callback"
+		entry.  It can have a "timeout" entry to specify the timeout
+		for this specific request.
+
+		ch_evalexpr() waits for a response and returns the decoded
+		expression.  When there is an error or timeout it returns an
+		empty string.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_evalraw({handle}, {string} [, {options}])		*ch_evalraw()*
+		Send {string} over {handle}.
+		{handle} can be a Channel or a Job that has a Channel.
+
+		Works like |ch_evalexpr()|, but does not encode the request or
+		decode the response.  The caller is responsible for the
+		correct contents.  Also does not add a newline for a channel
+		in NL mode, the caller must do that.  The NL in the response
+		is removed.
+		Note that Vim does not know when the text received on a raw
+		channel is complete, it may only return the first part and you
+		need to use ch_readraw() to fetch the rest.
+		See |channel-use|.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_getbufnr({handle}, {what})				 *ch_getbufnr()*
+		Get the buffer number that {handle} is using for {what}.
+		{handle} can be a Channel or a Job that has a Channel.
+		{what} can be "err" for stderr, "out" for stdout or empty for
+		socket output.
+		Returns -1 when there is no buffer.
+		{only available when compiled with the |+channel| feature}
+
+ch_getjob({channel})						*ch_getjob()*
+		Get the Job associated with {channel}.
+		If there is no job calling |job_status()| on the returned Job
+		will result in "fail".
+
+		{only available when compiled with the |+channel| and
+		|+job| features}
+
+ch_info({handle})						*ch_info()*
+		Returns a Dictionary with information about {handle}.  The
+		items are:
+		   "id"		  number of the channel
+		   "status"	  "open", "buffered" or "closed", like
+				  ch_status()
+		When opened with ch_open():
+		   "hostname"	  the hostname of the address
+		   "port"	  the port of the address
+		   "sock_status"  "open" or "closed"
+		   "sock_mode"	  "NL", "RAW", "JSON" or "JS"
+		   "sock_io"	  "socket"
+		   "sock_timeout" timeout in msec
+		When opened with job_start():
+		   "out_status"	  "open", "buffered" or "closed"
+		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
+		   "out_io"	  "null", "pipe", "file" or "buffer"
+		   "out_timeout"  timeout in msec
+		   "err_status"	  "open", "buffered" or "closed"
+		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
+		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
+		   "err_timeout"  timeout in msec
+		   "in_status"	  "open" or "closed"
+		   "in_mode"	  "NL", "RAW", "JSON" or "JS"
+		   "in_io"	  "null", "pipe", "file" or "buffer"
+		   "in_timeout"	  timeout in msec
+
+ch_log({msg} [, {handle}])					*ch_log()*
+		Write {msg} in the channel log file, if it was opened with
+		|ch_logfile()|.
+		When {handle} is passed the channel number is used for the
+		message.
+		{handle} can be a Channel or a Job that has a Channel.  The
+		Channel must be open for the channel number to be used.
+
+ch_logfile({fname} [, {mode}])					*ch_logfile()*
+		Start logging channel activity to {fname}.
+		When {fname} is an empty string: stop logging.
+
+		When {mode} is omitted or "a" append to the file.
+		When {mode} is "w" start with an empty file.
+
+		The file is flushed after every message, on Unix you can use
+		"tail -f" to see what is going on in real time.
+
+		This function is not available in the |sandbox|.
+		NOTE: the channel communication is stored in the file, be
+		aware that this may contain confidential and privacy sensitive
+		information, e.g. a password you type in a terminal window.
+
+
+ch_open({address} [, {options}])				*ch_open()*
+		Open a channel to {address}.  See |channel|.
+		Returns a Channel.  Use |ch_status()| to check for failure.
+
+		{address} has the form "hostname:port", e.g.,
+		"localhost:8765".
+
+		If {options} is given it must be a |Dictionary|.
+		See |channel-open-options|.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_read({handle} [, {options}])					*ch_read()*
+		Read from {handle} and return the received message.
+		{handle} can be a Channel or a Job that has a Channel.
+		For a NL channel this waits for a NL to arrive, except when
+		there is nothing more to read (channel was closed).
+		See |channel-more|.
+		{only available when compiled with the |+channel| feature}
+
+ch_readraw({handle} [, {options}])			*ch_readraw()*
+		Like ch_read() but for a JS and JSON channel does not decode
+		the message.  For a NL channel it does not block waiting for
+		the NL to arrive, but otherwise works like ch_read().
+		See |channel-more|.
+		{only available when compiled with the |+channel| feature}
+
+ch_sendexpr({handle}, {expr} [, {options}])			*ch_sendexpr()*
+		Send {expr} over {handle}.  The {expr} is encoded
+		according to the type of channel.  The function cannot be used
+		with a raw channel.
+		See |channel-use|.				*E912*
+		{handle} can be a Channel or a Job that has a Channel.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_sendraw({handle}, {string} [, {options}])		*ch_sendraw()*
+		Send {string} over {handle}.
+		Works like |ch_sendexpr()|, but does not encode the request or
+		decode the response.  The caller is responsible for the
+		correct contents.  Also does not add a newline for a channel
+		in NL mode, the caller must do that.  The NL in the response
+		is removed.
+		See |channel-use|.
+
+		{only available when compiled with the |+channel| feature}
+
+ch_setoptions({handle}, {options})			*ch_setoptions()*
+		Set options on {handle}:
+			"callback"	the channel callback
+			"timeout"	default read timeout in msec
+			"mode"		mode for the whole channel
+		See |ch_open()| for more explanation.
+		{handle} can be a Channel or a Job that has a Channel.
+
+		Note that changing the mode may cause queued messages to be
+		lost.
+
+		These options cannot be changed:
+			"waittime"	only applies to |ch_open()|
+
+ch_status({handle} [, {options}])				*ch_status()*
+		Return the status of {handle}:
+			"fail"		failed to open the channel
+			"open"		channel can be used
+			"buffered"	channel can be read, not written to
+			"closed"	channel can not be used
+		{handle} can be a Channel or a Job that has a Channel.
+		"buffered" is used when the channel was closed but there is
+		still data that can be obtained with |ch_read()|.
+
+		If {options} is given it can contain a "part" entry to specify
+		the part of the channel to return the status for: "out" or
+		"err".  For example, to get the error status: >
+			ch_status(job, {"part": "err"})
+<
+changenr()						*changenr()*
+		Return the number of the most recent change.  This is the same
+		number as what is displayed with |:undolist| and can be used
+		with the |:undo| command.
+		When a change was made it is the number of that change.  After
+		redo it is the number of the redone change.  After undo it is
+		one less than the number of the undone change.
+
+char2nr({expr} [, {utf8}])					*char2nr()*
+		Return number value of the first char in {expr}.  Examples: >
+			char2nr(" ")		returns 32
+			char2nr("ABC")		returns 65
+<		When {utf8} is omitted or zero, the current 'encoding' is used.
+		Example for "utf-8": >
+			char2nr("")		returns 225
+			char2nr(""[0])		returns 195
+<		With {utf8} set to 1, always treat as utf-8 characters.
+		A combining character is a separate character.
+		|nr2char()| does the opposite.
+
+cindent({lnum})						*cindent()*
+		Get the amount of indent for line {lnum} according the C
+		indenting rules, as with 'cindent'.
+		The indent is counted in spaces, the value of 'tabstop' is
+		relevant.  {lnum} is used just like in |getline()|.
+		When {lnum} is invalid or Vim was not compiled the |+cindent|
+		feature, -1 is returned.
+		See |C-indenting|.
+
+clearmatches()						*clearmatches()*
+		Clears all matches previously defined by |matchadd()| and the
+		|:match| commands.
+
+							*col()*
+col({expr})	The result is a Number, which is the byte index of the column
+		position given with {expr}.  The accepted positions are:
+		    .	    the cursor position
+		    $	    the end of the cursor line (the result is the
+			    number of bytes in the cursor line plus one)
+		    'x	    position of mark x (if the mark is not set, 0 is
+			    returned)
+		    v       In Visual mode: the start of the Visual area (the
+			    cursor is the end).  When not in Visual mode
+			    returns the cursor position.  Differs from |'<| in
+			    that it's updated right away.
+		Additionally {expr} can be [lnum, col]: a |List| with the line
+		and column number. Most useful when the column is "$", to get
+		the last column of a specific line.  When "lnum" or "col" is
+		out of range then col() returns zero.
+		To get the line number use |line()|.  To get both use
+		|getpos()|.
+		For the screen column position use |virtcol()|.
+		Note that only marks in the current file can be used.
+		Examples: >
+			col(".")		column of cursor
+			col("$")		length of cursor line plus one
+			col("'t")		column of mark t
+			col("'" . markname)	column of mark markname
+<		The first column is 1.  0 is returned for an error.
+		For an uppercase mark the column may actually be in another
+		buffer.
+		For the cursor position, when 'virtualedit' is active, the
+		column is one higher if the cursor is after the end of the
+		line.  This can be used to obtain the column in Insert mode: >
+			:imap <F2> <C-O>:let save_ve = &ve<CR>
+				\<C-O>:set ve=all<CR>
+				\<C-O>:echo col(".") . "\n" <Bar>
+				\let &ve = save_ve<CR>
+<
+
+complete({startcol}, {matches})			*complete()* *E785*
+		Set the matches for Insert mode completion.
+		Can only be used in Insert mode.  You need to use a mapping
+		with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O
+		or with an expression mapping.
+		{startcol} is the byte offset in the line where the completed
+		text start.  The text up to the cursor is the original text
+		that will be replaced by the matches.  Use col('.') for an
+		empty string.  "col('.') - 1" will replace one character by a
+		match.
+		{matches} must be a |List|.  Each |List| item is one match.
+		See |complete-items| for the kind of items that are possible.
+		Note that the after calling this function you need to avoid
+		inserting anything that would cause completion to stop.
+		The match can be selected with CTRL-N and CTRL-P as usual with
+		Insert mode completion.  The popup menu will appear if
+		specified, see |ins-completion-menu|.
+		Example: >
+	inoremap <F5> <C-R>=ListMonths()<CR>
+
+	func! ListMonths()
+	  call complete(col('.'), ['January', 'February', 'March',
+		\ 'April', 'May', 'June', 'July', 'August', 'September',
+		\ 'October', 'November', 'December'])
+	  return ''
+	endfunc
+<		This isn't very useful, but it shows how it works.  Note that
+		an empty string is returned to avoid a zero being inserted.
+
+complete_add({expr})				*complete_add()*
+		Add {expr} to the list of matches.  Only to be used by the
+		function specified with the 'completefunc' option.
+		Returns 0 for failure (empty string or out of memory),
+		1 when the match was added, 2 when the match was already in
+		the list.
+		See |complete-functions| for an explanation of {expr}.  It is
+		the same as one item in the list that 'omnifunc' would return.
+
+complete_check()				*complete_check()*
+		Check for a key typed while looking for completion matches.
+		This is to be used when looking for matches takes some time.
+		Returns |TRUE| when searching for matches is to be aborted,
+		zero otherwise.
+		Only to be used by the function specified with the
+		'completefunc' option.
+
+						*confirm()*
+confirm({msg} [, {choices} [, {default} [, {type}]]])
+		Confirm() offers the user a dialog, from which a choice can be
+		made.  It returns the number of the choice.  For the first
+		choice this is 1.
+		Note: confirm() is only supported when compiled with dialog
+		support, see |+dialog_con| and |+dialog_gui|.
+
+		{msg} is displayed in a |dialog| with {choices} as the
+		alternatives.  When {choices} is missing or empty, "&OK" is
+		used (and translated).
+		{msg} is a String, use '\n' to include a newline.  Only on
+		some systems the string is wrapped when it doesn't fit.
+
+		{choices} is a String, with the individual choices separated
+		by '\n', e.g. >
+			confirm("Save changes?", "&Yes\n&No\n&Cancel")
+<		The letter after the '&' is the shortcut key for that choice.
+		Thus you can type 'c' to select "Cancel".  The shortcut does
+		not need to be the first letter: >
+			confirm("file has been modified", "&Save\nSave &All")
+<		For the console, the first letter of each choice is used as
+		the default shortcut key.
+
+		The optional {default} argument is the number of the choice
+		that is made if the user hits <CR>.  Use 1 to make the first
+		choice the default one.  Use 0 to not set a default.  If
+		{default} is omitted, 1 is used.
+
+		The optional {type} argument gives the type of dialog.  This
+		is only used for the icon of the GTK, Mac, Motif and Win32
+		GUI.  It can be one of these values: "Error", "Question",
+		"Info", "Warning" or "Generic".  Only the first character is
+		relevant.  When {type} is omitted, "Generic" is used.
+
+		If the user aborts the dialog by pressing <Esc>, CTRL-C,
+		or another valid interrupt key, confirm() returns 0.
+
+		An example: >
+   :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
+   :if choice == 0
+   :	echo "make up your mind!"
+   :elseif choice == 3
+   :	echo "tasteful"
+   :else
+   :	echo "I prefer bananas myself."
+   :endif
+<		In a GUI dialog, buttons are used.  The layout of the buttons
+		depends on the 'v' flag in 'guioptions'.  If it is included,
+		the buttons are always put vertically.  Otherwise,  confirm()
+		tries to put the buttons in one horizontal line.  If they
+		don't fit, a vertical layout is used anyway.  For some systems
+		the horizontal layout is always used.
+
+							*copy()*
+copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
+		different from using {expr} directly.
+		When {expr} is a |List| a shallow copy is created.  This means
+		that the original |List| can be changed without changing the
+		copy, and vice versa.  But the items are identical, thus
+		changing an item changes the contents of both |Lists|.
+		A |Dictionary| is copied in a similar way as a |List|.
+		Also see |deepcopy()|.
+
+cos({expr})						*cos()*
+		Return the cosine of {expr}, measured in radians, as a |Float|.
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo cos(100)
+<			0.862319 >
+			:echo cos(-4.01)
+<			-0.646043
+		{only available when compiled with the |+float| feature}
+
+
+cosh({expr})						*cosh()*
+		Return the hyperbolic cosine of {expr} as a |Float| in the range
+		[1, inf].
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo cosh(0.5)
+<			1.127626 >
+			:echo cosh(-0.5)
+<			-1.127626
+		{only available when compiled with the |+float| feature}
+
+
+count({comp}, {expr} [, {ic} [, {start}]])			*count()*
+		Return the number of times an item with value {expr} appears
+		in |String|, |List| or |Dictionary| {comp}.
+
+		If {start} is given then start with the item with this index.
+		{start} can only be used with a |List|.
+
+		When {ic} is given and it's |TRUE| then case is ignored.
+
+		When {comp} is a string then the number of not overlapping
+		occurrences of {expr} is returned. Zero is returned when
+		{expr} is an empty string.
+
+							*cscope_connection()*
+cscope_connection([{num} , {dbpath} [, {prepend}]])
+		Checks for the existence of a |cscope| connection.  If no
+		parameters are specified, then the function returns:
+			0, if cscope was not available (not compiled in), or
+			   if there are no cscope connections;
+			1, if there is at least one cscope connection.
+
+		If parameters are specified, then the value of {num}
+		determines how existence of a cscope connection is checked:
+
+		{num}	Description of existence check
+		-----	------------------------------
+		0	Same as no parameters (e.g., "cscope_connection()").
+		1	Ignore {prepend}, and use partial string matches for
+			{dbpath}.
+		2	Ignore {prepend}, and use exact string matches for
+			{dbpath}.
+		3	Use {prepend}, use partial string matches for both
+			{dbpath} and {prepend}.
+		4	Use {prepend}, use exact string matches for both
+			{dbpath} and {prepend}.
+
+		Note: All string comparisons are case sensitive!
+
+		Examples.  Suppose we had the following (from ":cs show"): >
+
+  # pid    database name			prepend path
+  0 27664  cscope.out				/usr/local
+<
+		Invocation					Return Val ~
+		----------					---------- >
+		cscope_connection()					1
+		cscope_connection(1, "out")				1
+		cscope_connection(2, "out")				0
+		cscope_connection(3, "out")				0
+		cscope_connection(3, "out", "local")			1
+		cscope_connection(4, "out")				0
+		cscope_connection(4, "out", "local")			0
+		cscope_connection(4, "cscope.out", "/usr/local")	1
+<
+cursor({lnum}, {col} [, {off}])				*cursor()*
+cursor({list})
+		Positions the cursor at the column (byte count) {col} in the
+		line {lnum}.  The first column is one.
+
+		When there is one argument {list} this is used as a |List|
+		with two, three or four item:
+			[{lnum}, {col}]
+			[{lnum}, {col}, {off}]
+			[{lnum}, {col}, {off}, {curswant}]
+		This is like the return value of |getpos()| or |getcurpos()|,
+		but without the first item.
+
+		Does not change the jumplist.
+		If {lnum} is greater than the number of lines in the buffer,
+		the cursor will be positioned at the last line in the buffer.
+		If {lnum} is zero, the cursor will stay in the current line.
+		If {col} is greater than the number of bytes in the line,
+		the cursor will be positioned at the last character in the
+		line.
+		If {col} is zero, the cursor will stay in the current column.
+		If {curswant} is given it is used to set the preferred column
+		for vertical movement.  Otherwise {col} is used.
+
+		When 'virtualedit' is used {off} specifies the offset in
+		screen columns from the start of the character.  E.g., a
+		position within a <Tab> or after the last character.
+		Returns 0 when the position could be set, -1 otherwise.
+
+debugbreak({pid})					*debugbreak()*
+		Specifically used to interrupt a program being debugged.  It
+		will cause process {pid} to get a SIGTRAP.  Behavior for other
+		processes is undefined. See |terminal-debugger|.
+		{only available on MS-Windows}
+
+deepcopy({expr} [, {noref}])				*deepcopy()* *E698*
+		Make a copy of {expr}.  For Numbers and Strings this isn't
+		different from using {expr} directly.
+		When {expr} is a |List| a full copy is created.  This means
+		that the original |List| can be changed without changing the
+		copy, and vice versa.  When an item is a |List| or
+		|Dictionary|, a copy for it is made, recursively.  Thus
+		changing an item in the copy does not change the contents of
+		the original |List|.
+		A |Dictionary| is copied in a similar way as a |List|.
+		When {noref} is omitted or zero a contained |List| or
+		|Dictionary| is only copied once.  All references point to
+		this single copy.  With {noref} set to 1 every occurrence of a
+		|List| or |Dictionary| results in a new copy.  This also means
+		that a cyclic reference causes deepcopy() to fail.
+								*E724*
+		Nesting is possible up to 100 levels.  When there is an item
+		that refers back to a higher level making a deep copy with
+		{noref} set to 1 will fail.
+		Also see |copy()|.
+
+delete({fname} [, {flags}])					*delete()*
+		Without {flags} or with {flags} empty: Deletes the file by the
+		name {fname}.  This also works when {fname} is a symbolic link.
+
+		When {flags} is "d": Deletes the directory by the name
+		{fname}.  This fails when directory {fname} is not empty.
+
+		When {flags} is "rf": Deletes the directory by the name
+		{fname} and everything in it, recursively.  BE CAREFUL!
+		Note: on MS-Windows it is not possible to delete a directory
+		that is being used.
+
+		A symbolic link itself is deleted, not what it points to.
+
+		The result is a Number, which is 0 if the delete operation was
+		successful and -1 when the deletion failed or partly failed.
+
+		Use |remove()| to delete an item from a |List|.
+		To delete a line from the buffer use |:delete| or
+		|deletebufline()|.
+
+deletebufline({expr}, {first} [, {last}])		*deletebufline()*
+		Delete lines {first} to {last} (inclusive) from buffer {expr}.
+		If {last} is omitted then delete line {first} only.
+		On success 0 is returned, on failure 1 is returned.
+
+		For the use of {expr}, see |bufname()| above.
+
+		{first} and {last} are used like with |setline()|. Note that
+		when using |line()| this refers to the current buffer. Use "$"
+		to refer to the last line in buffer {expr}.
+
+							*did_filetype()*
+did_filetype()	Returns |TRUE| when autocommands are being executed and the
+		FileType event has been triggered at least once.  Can be used
+		to avoid triggering the FileType event again in the scripts
+		that detect the file type. |FileType|
+		Returns |FALSE| when `:setf FALLBACK` was used.
+		When editing another file, the counter is reset, thus this
+		really checks if the FileType event has been triggered for the
+		current buffer.  This allows an autocommand that starts
+		editing another buffer to set 'filetype' and load a syntax
+		file.
+
+diff_filler({lnum})					*diff_filler()*
+		Returns the number of filler lines above line {lnum}.
+		These are the lines that were inserted at this point in
+		another diff'ed window.  These filler lines are shown in the
+		display but don't exist in the buffer.
+		{lnum} is used like with |getline()|.  Thus "." is the current
+		line, "'m" mark m, etc.
+		Returns 0 if the current window is not in diff mode.
+
+diff_hlID({lnum}, {col})				*diff_hlID()*
+		Returns the highlight ID for diff mode at line {lnum} column
+		{col} (byte index).  When the current line does not have a
+		diff change zero is returned.
+		{lnum} is used like with |getline()|.  Thus "." is the current
+		line, "'m" mark m, etc.
+		{col} is 1 for the leftmost column, {lnum} is 1 for the first
+		line.
+		The highlight ID can be used with |synIDattr()| to obtain
+		syntax information about the highlighting.
+
+empty({expr})						*empty()*
+		Return the Number 1 if {expr} is empty, zero otherwise.
+		- A |List| or |Dictionary| is empty when it does not have any
+		  items.
+		- A String is empty when its length is zero.
+		- A Number and Float is empty when its value is zero.
+		- |v:false|, |v:none| and |v:null| are empty, |v:true| is not.
+		- A Job is empty when it failed to start.
+		- A Channel is empty when it is closed.
+
+		For a long |List| this is much faster than comparing the
+		length with zero.
+
+escape({string}, {chars})				*escape()*
+		Escape the characters in {chars} that occur in {string} with a
+		backslash.  Example: >
+			:echo escape('c:\program files\vim', ' \')
+<		results in: >
+			c:\\program\ files\\vim
+<		Also see |shellescape()| and |fnameescape()|.
+
+							*eval()*
+eval({string})	Evaluate {string} and return the result.  Especially useful to
+		turn the result of |string()| back into the original value.
+		This works for Numbers, Floats, Strings and composites of
+		them.  Also works for |Funcref|s that refer to existing
+		functions.
+
+eventhandler()						*eventhandler()*
+		Returns 1 when inside an event handler.  That is that Vim got
+		interrupted while waiting for the user to type a character,
+		e.g., when dropping a file on Vim.  This means interactive
+		commands cannot be used.  Otherwise zero is returned.
+
+executable({expr})					*executable()*
+		This function checks if an executable with the name {expr}
+		exists.  {expr} must be the name of the program without any
+		arguments.
+		executable() uses the value of $PATH and/or the normal
+		searchpath for programs.		*PATHEXT*
+		On MS-DOS and MS-Windows the ".exe", ".bat", etc. can
+		optionally be included.  Then the extensions in $PATHEXT are
+		tried.  Thus if "foo.exe" does not exist, "foo.exe.bat" can be
+		found.  If $PATHEXT is not set then ".exe;.com;.bat;.cmd" is
+		used.  A dot by itself can be used in $PATHEXT to try using
+		the name without an extension.  When 'shell' looks like a
+		Unix shell, then the name is also tried without adding an
+		extension.
+		On MS-DOS and MS-Windows it only checks if the file exists and
+		is not a directory, not if it's really executable.
+		On MS-Windows an executable in the same directory as Vim is
+		always found.  Since this directory is added to $PATH it
+		should also work to execute it |win32-PATH|.
+		The result is a Number:
+			1	exists
+			0	does not exist
+			-1	not implemented on this system
+		|exepath()| can be used to get the full path of an executable.
+
+execute({command} [, {silent}])					*execute()*
+		Execute an Ex command or commands and return the output as a
+		string.
+		{command} can be a string or a List.  In case of a List the
+		lines are executed one by one.
+		This is equivalent to: >
+			redir => var
+			{command}
+			redir END
+<
+		The optional {silent} argument can have these values:
+			""		no `:silent` used
+			"silent"	`:silent` used
+			"silent!"	`:silent!` used
+		The default is "silent".  Note that with "silent!", unlike
+		`:redir`, error messages are dropped.  When using an external
+		command the screen may be messed up, use `system()` instead.
+							*E930*
+		It is not possible to use `:redir` anywhere in {command}.
+
+		To get a list of lines use |split()| on the result: >
+			split(execute('args'), "\n")
+
+<		When used recursively the output of the recursive call is not
+		included in the output of the higher level call.
+
+exepath({expr})						*exepath()*
+		If {expr} is an executable and is either an absolute path, a
+		relative path or found in $PATH, return the full path.
+		Note that the current directory is used when {expr} starts
+		with "./", which may be a problem for Vim: >
+			echo exepath(v:progpath)
+<		If {expr} cannot be found in $PATH or is not executable then
+		an empty string is returned.
+
+							*exists()*
+exists({expr})	The result is a Number, which is |TRUE| if {expr} is defined,
+		zero otherwise.
+
+		For checking for a supported feature use |has()|.
+		For checking if a file exists use |filereadable()|.
+
+		The {expr} argument is a string, which contains one of these:
+			&option-name	Vim option (only checks if it exists,
+					not if it really works)
+			+option-name	Vim option that works.
+			$ENVNAME	environment variable (could also be
+					done by comparing with an empty
+					string)
+			*funcname	built-in function (see |functions|)
+					or user defined function (see
+					|user-functions|). Also works for a
+					variable that is a Funcref.
+			varname		internal variable (see
+					|internal-variables|).  Also works
+					for |curly-braces-names|, |Dictionary|
+					entries, |List| items, etc.  Beware
+					that evaluating an index may cause an
+					error message for an invalid
+					expression.  E.g.: >
+					   :let l = [1, 2, 3]
+					   :echo exists("l[5]")
+<					   0 >
+					   :echo exists("l[xx]")
+<					   E121: Undefined variable: xx
+					   0
+			:cmdname	Ex command: built-in command, user
+					command or command modifier |:command|.
+					Returns:
+					1  for match with start of a command
+					2  full match with a command
+					3  matches several user commands
+					To check for a supported command
+					always check the return value to be 2.
+			:2match		The |:2match| command.
+			:3match		The |:3match| command.
+			#event		autocommand defined for this event
+			#event#pattern	autocommand defined for this event and
+					pattern (the pattern is taken
+					literally and compared to the
+					autocommand patterns character by
+					character)
+			#group		autocommand group exists
+			#group#event	autocommand defined for this group and
+					event.
+			#group#event#pattern
+					autocommand defined for this group,
+					event and pattern.
+			##event		autocommand for this event is
+					supported.
+
+		Examples: >
+			exists("&shortname")
+			exists("$HOSTNAME")
+			exists("*strftime")
+			exists("*s:MyFunc")
+			exists("bufcount")
+			exists(":Make")
+			exists("#CursorHold")
+			exists("#BufReadPre#*.gz")
+			exists("#filetypeindent")
+			exists("#filetypeindent#FileType")
+			exists("#filetypeindent#FileType#*")
+			exists("##ColorScheme")
+<		There must be no space between the symbol (&/$/*/#) and the
+		name.
+		There must be no extra characters after the name, although in
+		a few cases this is ignored.  That may become more strict in
+		the future, thus don't count on it!
+		Working example: >
+			exists(":make")
+<		NOT working example: >
+			exists(":make install")
+
+<		Note that the argument must be a string, not the name of the
+		variable itself.  For example: >
+			exists(bufcount)
+<		This doesn't check for existence of the "bufcount" variable,
+		but gets the value of "bufcount", and checks if that exists.
+
+exp({expr})						*exp()*
+		Return the exponential of {expr} as a |Float| in the range
+		[0, inf].
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo exp(2)
+<			7.389056 >
+			:echo exp(-1)
+<			0.367879
+		{only available when compiled with the |+float| feature}
+
+
+expand({expr} [, {nosuf} [, {list}]])				*expand()*
+		Expand wildcards and the following special keywords in {expr}.
+		'wildignorecase' applies.
+
+		If {list} is given and it is |TRUE|, a List will be returned.
+		Otherwise the result is a String and when there are several
+		matches, they are separated by <NL> characters.  [Note: in
+		version 5.0 a space was used, which caused problems when a
+		file name contains a space]
+
+		If the expansion fails, the result is an empty string.  A name
+		for a non-existing file is not included, unless {expr} does
+		not start with '%', '#' or '<', see below.
+
+		When {expr} starts with '%', '#' or '<', the expansion is done
+		like for the |cmdline-special| variables with their associated
+		modifiers.  Here is a short overview:
+
+			%		current file name
+			#		alternate file name
+			#n		alternate file name n
+			<cfile>		file name under the cursor
+			<afile>		autocmd file name
+			<abuf>		autocmd buffer number (as a String!)
+			<amatch>	autocmd matched name
+			<sfile>		sourced script file or function name
+			<slnum>		sourced script file line number
+			<cword>		word under the cursor
+			<cWORD>		WORD under the cursor
+			<client>	the {clientid} of the last received
+					message |server2client()|
+		Modifiers:
+			:p		expand to full path
+			:h		head (last path component removed)
+			:t		tail (last path component only)
+			:r		root (one extension removed)
+			:e		extension only
+
+		Example: >
+			:let &tags = expand("%:p:h") . "/tags"
+<		Note that when expanding a string that starts with '%', '#' or
+		'<', any following text is ignored.  This does NOT work: >
+			:let doesntwork = expand("%:h.bak")
+<		Use this: >
+			:let doeswork = expand("%:h") . ".bak"
+<		Also note that expanding "<cfile>" and others only returns the
+		referenced file name without further expansion.  If "<cfile>"
+		is "~/.cshrc", you need to do another expand() to have the
+		"~/" expanded into the path of the home directory: >
+			:echo expand(expand("<cfile>"))
+<
+		There cannot be white space between the variables and the
+		following modifier.  The |fnamemodify()| function can be used
+		to modify normal file names.
+
+		When using '%' or '#', and the current or alternate file name
+		is not defined, an empty string is used.  Using "%:p" in a
+		buffer with no name, results in the current directory, with a
+		'/' added.
+
+		When {expr} does not start with '%', '#' or '<', it is
+		expanded like a file name is expanded on the command line.
+		'suffixes' and 'wildignore' are used, unless the optional
+		{nosuf} argument is given and it is |TRUE|.
+		Names for non-existing files are included.  The "**" item can
+		be used to search in a directory tree.  For example, to find
+		all "README" files in the current directory and below: >
+			:echo expand("**/README")
+<
+		Expand() can also be used to expand variables and environment
+		variables that are only known in a shell.  But this can be
+		slow, because a shell may be used to do the expansion.  See
+		|expr-env-expand|.
+		The expanded variable is still handled like a list of file
+		names.  When an environment variable cannot be expanded, it is
+		left unchanged.  Thus ":echo expand('$FOOBAR')" results in
+		"$FOOBAR".
+
+		See |glob()| for finding existing files.  See |system()| for
+		getting the raw output of an external command.
+
+extend({expr1}, {expr2} [, {expr3}])			*extend()*
+		{expr1} and {expr2} must be both |Lists| or both
+		|Dictionaries|.
+
+		If they are |Lists|: Append {expr2} to {expr1}.
+		If {expr3} is given insert the items of {expr2} before item
+		{expr3} in {expr1}.  When {expr3} is zero insert before the
+		first item.  When {expr3} is equal to len({expr1}) then
+		{expr2} is appended.
+		Examples: >
+			:echo sort(extend(mylist, [7, 5]))
+			:call extend(mylist, [2, 3], 1)
+<		When {expr1} is the same List as {expr2} then the number of
+		items copied is equal to the original length of the List.
+		E.g., when {expr3} is 1 you get N new copies of the first item
+		(where N is the original length of the List).
+		Use |add()| to concatenate one item to a list.  To concatenate
+		two lists into a new list use the + operator: >
+			:let newlist = [1, 2, 3] + [4, 5]
+<
+		If they are |Dictionaries|:
+		Add all entries from {expr2} to {expr1}.
+		If a key exists in both {expr1} and {expr2} then {expr3} is
+		used to decide what to do:
+		{expr3} = "keep": keep the value of {expr1}
+		{expr3} = "force": use the value of {expr2}
+		{expr3} = "error": give an error message		*E737*
+		When {expr3} is omitted then "force" is assumed.
+
+		{expr1} is changed when {expr2} is not empty.  If necessary
+		make a copy of {expr1} first.
+		{expr2} remains unchanged.
+		When {expr1} is locked and {expr2} is not empty the operation
+		fails.
+		Returns {expr1}.
+
+
+feedkeys({string} [, {mode}])				*feedkeys()*
+		Characters in {string} are queued for processing as if they
+		come from a mapping or were typed by the user.
+		By default the string is added to the end of the typeahead
+		buffer, thus if a mapping is still being executed the
+		characters come after them.  Use the 'i' flag to insert before
+		other characters, they will be executed next, before any
+		characters from a mapping.
+		The function does not wait for processing of keys contained in
+		{string}.
+		To include special keys into {string}, use double-quotes
+		and "\..." notation |expr-quote|. For example,
+		feedkeys("\<CR>") simulates pressing of the <Enter> key. But
+		feedkeys('\<CR>') pushes 5 characters.
+		If {mode} is absent, keys are remapped.
+		{mode} is a String, which can contain these character flags:
+		'm'	Remap keys. This is default.
+		'n'	Do not remap keys.
+		't'	Handle keys as if typed; otherwise they are handled as
+			if coming from a mapping.  This matters for undo,
+			opening folds, etc.
+		'i'	Insert the string instead of appending (see above).
+		'x'	Execute commands until typeahead is empty.  This is
+			similar to using ":normal!".  You can call feedkeys()
+			several times without 'x' and then one time with 'x'
+			(possibly with an empty {string}) to execute all the
+			typeahead.  Note that when Vim ends in Insert mode it
+			will behave as if <Esc> is typed, to avoid getting
+			stuck, waiting for a character to be typed before the
+			script continues.
+		'!'	When used with 'x' will not end Insert mode. Can be
+			used in a test when a timer is set to exit Insert mode
+			a little later.  Useful for testing CursorHoldI.
+
+		Return value is always 0.
+
+filereadable({file})					*filereadable()*
+		The result is a Number, which is |TRUE| when a file with the
+		name {file} exists, and can be read.  If {file} doesn't exist,
+		or is a directory, the result is |FALSE|.  {file} is any
+		expression, which is used as a String.
+		If you don't care about the file being readable you can use
+		|glob()|.
+							*file_readable()*
+		Obsolete name: file_readable().
+
+
+filewritable({file})					*filewritable()*
+		The result is a Number, which is 1 when a file with the
+		name {file} exists, and can be written.  If {file} doesn't
+		exist, or is not writable, the result is 0.  If {file} is a
+		directory, and we can write to it, the result is 2.
+
+
+filter({expr1}, {expr2})				*filter()*
+		{expr1} must be a |List| or a |Dictionary|.
+		For each item in {expr1} evaluate {expr2} and when the result
+		is zero remove the item from the |List| or |Dictionary|.
+		{expr2} must be a |string| or |Funcref|.
+
+		If {expr2} is a |string|, inside {expr2} |v:val| has the value
+		of the current item.  For a |Dictionary| |v:key| has the key
+		of the current item and for a |List| |v:key| has the index of
+		the current item.
+		Examples: >
+			call filter(mylist, 'v:val !~ "OLD"')
+<		Removes the items where "OLD" appears. >
+			call filter(mydict, 'v:key >= 8')
+<		Removes the items with a key below 8. >
+			call filter(var, 0)
+<		Removes all the items, thus clears the |List| or |Dictionary|.
+
+		Note that {expr2} is the result of expression and is then
+		used as an expression again.  Often it is good to use a
+		|literal-string| to avoid having to double backslashes.
+
+		If {expr2} is a |Funcref| it must take two arguments:
+			1. the key or the index of the current item.
+			2. the value of the current item.
+		The function must return |TRUE| if the item should be kept.
+		Example that keeps the odd items of a list: >
+			func Odd(idx, val)
+			  return a:idx % 2 == 1
+			endfunc
+			call filter(mylist, function('Odd'))
+<		It is shorter when using a |lambda|: >
+			call filter(myList, {idx, val -> idx * val <= 42})
+<		If you do not use "val" you can leave it out: >
+			call filter(myList, {idx -> idx % 2 == 1})
+<
+		The operation is done in-place.  If you want a |List| or
+		|Dictionary| to remain unmodified make a copy first: >
+			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')
+
+<		Returns {expr1}, the |List| or |Dictionary| that was filtered.
+		When an error is encountered while evaluating {expr2} no
+		further items in {expr1} are processed.  When {expr2} is a
+		Funcref errors inside a function are ignored, unless it was
+		defined with the "abort" flag.
+
+
+finddir({name} [, {path} [, {count}]])				*finddir()*
+		Find directory {name} in {path}.  Supports both downwards and
+		upwards recursive directory searches.  See |file-searching|
+		for the syntax of {path}.
+		Returns the path of the first found match.  When the found
+		directory is below the current directory a relative path is
+		returned.  Otherwise a full path is returned.
+		If {path} is omitted or empty then 'path' is used.
+		If the optional {count} is given, find {count}'s occurrence of
+		{name} in {path} instead of the first one.
+		When {count} is negative return all the matches in a |List|.
+		This is quite similar to the ex-command |:find|.
+		{only available when compiled with the |+file_in_path|
+		feature}
+
+findfile({name} [, {path} [, {count}]])				*findfile()*
+		Just like |finddir()|, but find a file instead of a directory.
+		Uses 'suffixesadd'.
+		Example: >
+			:echo findfile("tags.vim", ".;")
+<		Searches from the directory of the current file upwards until
+		it finds the file "tags.vim".
+
+float2nr({expr})					*float2nr()*
+		Convert {expr} to a Number by omitting the part after the
+		decimal point.
+		{expr} must evaluate to a |Float| or a Number.
+		When the value of {expr} is out of range for a |Number| the
+		result is truncated to 0x7fffffff or -0x7fffffff (or when
+		64-bit Number support is enabled, 0x7fffffffffffffff or
+		-0x7fffffffffffffff).  NaN results in -0x80000000 (or when
+		64-bit Number support is enabled, -0x8000000000000000).
+		Examples: >
+			echo float2nr(3.95)
+<			3  >
+			echo float2nr(-23.45)
+<			-23  >
+			echo float2nr(1.0e100)
+<			2147483647  (or 9223372036854775807) >
+			echo float2nr(-1.0e150)
+<			-2147483647 (or -9223372036854775807) >
+			echo float2nr(1.0e-100)
+<			0
+		{only available when compiled with the |+float| feature}
+
+
+floor({expr})							*floor()*
+		Return the largest integral value less than or equal to
+		{expr} as a |Float| (round down).
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			echo floor(1.856)
+<			1.0  >
+			echo floor(-5.456)
+<			-6.0  >
+			echo floor(4.0)
+<			4.0
+		{only available when compiled with the |+float| feature}
+
+
+fmod({expr1}, {expr2})					*fmod()*
+		Return the remainder of {expr1} / {expr2}, even if the
+		division is not representable.  Returns {expr1} - i * {expr2}
+		for some integer i such that if {expr2} is non-zero, the
+		result has the same sign as {expr1} and magnitude less than
+		the magnitude of {expr2}.  If {expr2} is zero, the value
+		returned is zero.  The value returned is a |Float|.
+		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo fmod(12.33, 1.22)
+<			0.13 >
+			:echo fmod(-12.33, 1.22)
+<			-0.13
+		{only available when compiled with |+float| feature}
+
+
+fnameescape({string})					*fnameescape()*
+		Escape {string} for use as file name command argument.  All
+		characters that have a special meaning, such as '%' and '|'
+		are escaped with a backslash.
+		For most systems the characters escaped are
+		" \t\n*?[{`$\\%#'\"|!<".  For systems where a backslash
+		appears in a filename, it depends on the value of 'isfname'.
+		A leading '+' and '>' is also escaped (special after |:edit|
+		and |:write|).  And a "-" by itself (special after |:cd|).
+		Example: >
+			:let fname = '+some str%nge|name'
+			:exe "edit " . fnameescape(fname)
+<		results in executing: >
+			edit \+some\ str\%nge\|name
+
+fnamemodify({fname}, {mods})				*fnamemodify()*
+		Modify file name {fname} according to {mods}.  {mods} is a
+		string of characters like it is used for file names on the
+		command line.  See |filename-modifiers|.
+		Example: >
+			:echo fnamemodify("main.c", ":p:h")
+<		results in: >
+			/home/mool/vim/vim/src
+<		Note: Environment variables don't work in {fname}, use
+		|expand()| first then.
+
+foldclosed({lnum})					*foldclosed()*
+		The result is a Number.  If the line {lnum} is in a closed
+		fold, the result is the number of the first line in that fold.
+		If the line {lnum} is not in a closed fold, -1 is returned.
+
+foldclosedend({lnum})					*foldclosedend()*
+		The result is a Number.  If the line {lnum} is in a closed
+		fold, the result is the number of the last line in that fold.
+		If the line {lnum} is not in a closed fold, -1 is returned.
+
+foldlevel({lnum})					*foldlevel()*
+		The result is a Number, which is the foldlevel of line {lnum}
+		in the current buffer.  For nested folds the deepest level is
+		returned.  If there is no fold at line {lnum}, zero is
+		returned.  It doesn't matter if the folds are open or closed.
+		When used while updating folds (from 'foldexpr') -1 is
+		returned for lines where folds are still to be updated and the
+		foldlevel is unknown.  As a special case the level of the
+		previous line is usually available.
+
+							*foldtext()*
+foldtext()	Returns a String, to be displayed for a closed fold.  This is
+		the default function used for the 'foldtext' option and should
+		only be called from evaluating 'foldtext'.  It uses the
+		|v:foldstart|, |v:foldend| and |v:folddashes| variables.
+		The returned string looks like this: >
+			+-- 45 lines: abcdef
+<		The number of leading dashes depends on the foldlevel.  The
+		"45" is the number of lines in the fold.  "abcdef" is the text
+		in the first non-blank line of the fold.  Leading white space,
+		"//" or "/*" and the text from the 'foldmarker' and
+		'commentstring' options is removed.
+		When used to draw the actual foldtext, the rest of the line
+		will be filled with the fold char from the 'fillchars'
+		setting.
+		{not available when compiled without the |+folding| feature}
+
+foldtextresult({lnum})					*foldtextresult()*
+		Returns the text that is displayed for the closed fold at line
+		{lnum}.  Evaluates 'foldtext' in the appropriate context.
+		When there is no closed fold at {lnum} an empty string is
+		returned.
+		{lnum} is used like with |getline()|.  Thus "." is the current
+		line, "'m" mark m, etc.
+		Useful when exporting folded text, e.g., to HTML.
+		{not available when compiled without the |+folding| feature}
+
+							*foreground()*
+foreground()	Move the Vim window to the foreground.  Useful when sent from
+		a client to a Vim server. |remote_send()|
+		On Win32 systems this might not work, the OS does not always
+		allow a window to bring itself to the foreground.  Use
+		|remote_foreground()| instead.
+		{only in the Win32, Athena, Motif and GTK GUI versions and the
+		Win32 console version}
+
+						*funcref()*
+funcref({name} [, {arglist}] [, {dict}])
+		Just like |function()|, but the returned Funcref will lookup
+		the function by reference, not by name.  This matters when the
+		function {name} is redefined later.
+
+		Unlike |function()|, {name} must be an existing user function.
+		Also for autoloaded functions. {name} cannot be a builtin
+		function.
+
+					*function()* *E700* *E922* *E923*
+function({name} [, {arglist}] [, {dict}])
+		Return a |Funcref| variable that refers to function {name}.
+		{name} can be the name of a user defined function or an
+		internal function.
+
+		{name} can also be a Funcref or a partial.  When it is a
+		partial the dict stored in it will be used and the {dict}
+		argument is not allowed. E.g.: >
+			let FuncWithArg = function(dict.Func, [arg])
+			let Broken = function(dict.Func, [arg], dict)
+<
+		When using the Funcref the function will be found by {name},
+		also when it was redefined later.  Use |funcref()| to keep the
+		same function.
+
+		When {arglist} or {dict} is present this creates a partial.
+		That means the argument list and/or the dictionary is stored in
+		the Funcref and will be used when the Funcref is called.
+
+		The arguments are passed to the function in front of other
+		arguments.  Example: >
+			func Callback(arg1, arg2, name)
+			...
+			let Func = function('Callback', ['one', 'two'])
+			...
+			call Func('name')
+<		Invokes the function as with: >
+			call Callback('one', 'two', 'name')
+
+<		The function() call can be nested to add more arguments to the
+		Funcref.  The extra arguments are appended to the list of
+		arguments.  Example: >
+			func Callback(arg1, arg2, name)
+			...
+			let Func = function('Callback', ['one'])
+			let Func2 = function(Func, ['two'])
+			...
+			call Func2('name')
+<		Invokes the function as with: >
+			call Callback('one', 'two', 'name')
+
+<		The Dictionary is only useful when calling a "dict" function.
+		In that case the {dict} is passed in as "self". Example: >
+			function Callback() dict
+			   echo "called for " . self.name
+			endfunction
+			...
+			let context = {"name": "example"}
+			let Func = function('Callback', context)
+			...
+			call Func()	" will echo: called for example
+<		The use of function() is not needed when there are no extra
+		arguments, these two are equivalent: >
+			let Func = function('Callback', context)
+			let Func = context.Callback
+
+<		The argument list and the Dictionary can be combined: >
+			function Callback(arg1, count) dict
+			...
+			let context = {"name": "example"}
+			let Func = function('Callback', ['one'], context)
+			...
+			call Func(500)
+<		Invokes the function as with: >
+			call context.Callback('one', 500)
+
+
+garbagecollect([{atexit}])				*garbagecollect()*
+		Cleanup unused |Lists|, |Dictionaries|, |Channels| and |Jobs|
+		that have circular references.
+
+		There is hardly ever a need to invoke this function, as it is
+		automatically done when Vim runs out of memory or is waiting
+		for the user to press a key after 'updatetime'.  Items without
+		circular references are always freed when they become unused.
+		This is useful if you have deleted a very big |List| and/or
+		|Dictionary| with circular references in a script that runs
+		for a long time.
+
+		When the optional {atexit} argument is one, garbage
+		collection will also be done when exiting Vim, if it wasn't
+		done before.  This is useful when checking for memory leaks.
+
+		The garbage collection is not done immediately but only when
+		it's safe to perform.  This is when waiting for the user to
+		type a character.  To force garbage collection immediately use
+		|test_garbagecollect_now()|.
+
+get({list}, {idx} [, {default}])			*get()*
+		Get item {idx} from |List| {list}.  When this item is not
+		available return {default}.  Return zero when {default} is
+		omitted.
+get({dict}, {key} [, {default}])
+		Get item with key {key} from |Dictionary| {dict}.  When this
+		item is not available return {default}.  Return zero when
+		{default} is omitted.
+get({func}, {what})
+		Get an item with from Funcref {func}.  Possible values for
+		{what} are:
+			"name"	The function name
+			"func"	The function
+			"dict"	The dictionary
+			"args"	The list with arguments
+
+							*getbufinfo()*
+getbufinfo([{expr}])
+getbufinfo([{dict}])
+		Get information about buffers as a List of Dictionaries.
+
+		Without an argument information about all the buffers is
+		returned.
+
+		When the argument is a Dictionary only the buffers matching
+		the specified criteria are returned.  The following keys can
+		be specified in {dict}:
+			buflisted	include only listed buffers.
+			bufloaded	include only loaded buffers.
+			bufmodified	include only modified buffers.
+
+		Otherwise, {expr} specifies a particular buffer to return
+		information for.  For the use of {expr}, see |bufname()|
+		above.  If the buffer is found the returned List has one item.
+		Otherwise the result is an empty list.
+
+		Each returned List item is a dictionary with the following
+		entries:
+			bufnr		buffer number.
+			changed		TRUE if the buffer is modified.
+			changedtick	number of changes made to the buffer.
+			hidden		TRUE if the buffer is hidden.
+			listed		TRUE if the buffer is listed.
+			lnum		current line number in buffer.
+			loaded		TRUE if the buffer is loaded.
+			name		full path to the file in the buffer.
+			signs		list of signs placed in the buffer.
+					Each list item is a dictionary with
+					the following fields:
+					    id	  sign identifier
+					    lnum  line number
+					    name  sign name
+			variables	a reference to the dictionary with
+					buffer-local variables.
+			windows		list of |window-ID|s that display this
+					buffer
+
+		Examples: >
+			for buf in getbufinfo()
+			    echo buf.name
+			endfor
+			for buf in getbufinfo({'buflisted':1})
+			    if buf.changed
+				....
+			    endif
+			endfor
+<
+		To get buffer-local options use: >
+			getbufvar({bufnr}, '&option_name')
+
+<
+							*getbufline()*
+getbufline({expr}, {lnum} [, {end}])
+		Return a |List| with the lines starting from {lnum} to {end}
+		(inclusive) in the buffer {expr}.  If {end} is omitted, a
+		|List| with only the line {lnum} is returned.
+
+		For the use of {expr}, see |bufname()| above.
+
+		For {lnum} and {end} "$" can be used for the last line of the
+		buffer.  Otherwise a number must be used.
+
+		When {lnum} is smaller than 1 or bigger than the number of
+		lines in the buffer, an empty |List| is returned.
+
+		When {end} is greater than the number of lines in the buffer,
+		it is treated as {end} is set to the number of lines in the
+		buffer.  When {end} is before {lnum} an empty |List| is
+		returned.
+
+		This function works only for loaded buffers.  For unloaded and
+		non-existing buffers, an empty |List| is returned.
+
+		Example: >
+			:let lines = getbufline(bufnr("myfile"), 1, "$")
+
+getbufvar({expr}, {varname} [, {def}])				*getbufvar()*
+		The result is the value of option or local buffer variable
+		{varname} in buffer {expr}.  Note that the name without "b:"
+		must be used.
+		When {varname} is empty returns a dictionary with all the
+		buffer-local variables.
+		When {varname} is equal to "&" returns a dictionary with all
+		the buffer-local options.
+		Otherwise, when {varname} starts with "&" returns the value of
+		a buffer-local option.
+		This also works for a global or buffer-local option, but it
+		doesn't work for a global variable, window-local variable or
+		window-local option.
+		For the use of {expr}, see |bufname()| above.
+		When the buffer or variable doesn't exist {def} or an empty
+		string is returned, there is no error message.
+		Examples: >
+			:let bufmodified = getbufvar(1, "&mod")
+			:echo "todo myvar = " . getbufvar("todo", "myvar")
+<
+getchangelist({expr})					*getchangelist()*
+		Returns the |changelist| for the buffer {expr}. For the use
+		of {expr}, see |bufname()| above. If buffer {expr} doesn't
+		exist, an empty list is returned.
+
+		The returned list contains two entries: a list with the change
+		locations and the current position in the list.  Each
+		entry in the change list is a dictionary with the following
+		entries:
+			col		column number
+			coladd		column offset for 'virtualedit'
+			lnum		line number
+		If buffer {expr} is the current buffer, then the current
+		position refers to the position in the list. For other
+		buffers, it is set to the length of the list.
+
+getchar([expr])						*getchar()*
+		Get a single character from the user or input stream.
+		If [expr] is omitted, wait until a character is available.
+		If [expr] is 0, only get a character when one is available.
+			Return zero otherwise.
+		If [expr] is 1, only check if a character is available, it is
+			not consumed.  Return zero if no character available.
+
+		Without [expr] and when [expr] is 0 a whole character or
+		special key is returned.  If it is a single character, the
+		result is a number.  Use nr2char() to convert it to a String.
+		Otherwise a String is returned with the encoded character.
+		For a special key it's a String with a sequence of bytes
+		starting with 0x80 (decimal: 128).  This is the same value as
+		the String "\<Key>", e.g., "\<Left>".  The returned value is
+		also a String when a modifier (shift, control, alt) was used
+		that is not included in the character.
+
+		When [expr] is 0 and Esc is typed, there will be a short delay
+		while Vim waits to see if this is the start of an escape
+		sequence.
+
+		When [expr] is 1 only the first byte is returned.  For a
+		one-byte character it is the character itself as a number.
+		Use nr2char() to convert it to a String.
+
+		Use getcharmod() to obtain any additional modifiers.
+
+		When the user clicks a mouse button, the mouse event will be
+		returned.  The position can then be found in |v:mouse_col|,
+		|v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.  This
+		example positions the mouse as it would normally happen: >
+			let c = getchar()
+			if c == "\<LeftMouse>" && v:mouse_win > 0
+			  exe v:mouse_win . "wincmd w"
+			  exe v:mouse_lnum
+			  exe "normal " . v:mouse_col . "|"
+			endif
+<
+		When using bracketed paste only the first character is
+		returned, the rest of the pasted text is dropped.
+		|xterm-bracketed-paste|.
+
+		There is no prompt, you will somehow have to make clear to the
+		user that a character has to be typed.
+		There is no mapping for the character.
+		Key codes are replaced, thus when the user presses the <Del>
+		key you get the code for the <Del> key, not the raw character
+		sequence.  Examples: >
+			getchar() == "\<Del>"
+			getchar() == "\<S-Left>"
+<		This example redefines "f" to ignore case: >
+			:nmap f :call FindChar()<CR>
+			:function FindChar()
+			:  let c = nr2char(getchar())
+			:  while col('.') < col('$') - 1
+			:    normal l
+			:    if getline('.')[col('.') - 1] ==? c
+			:      break
+			:    endif
+			:  endwhile
+			:endfunction
+<
+		You may also receive synthetic characters, such as
+		|<CursorHold>|. Often you will want to ignore this and get
+		another character: >
+			:function GetKey()
+			:  let c = getchar()
+			:  while c == "\<CursorHold>"
+			:    let c = getchar()
+			:  endwhile
+			:  return c
+			:endfunction
+
+getcharmod()						*getcharmod()*
+		The result is a Number which is the state of the modifiers for
+		the last obtained character with getchar() or in another way.
+		These values are added together:
+			2	shift
+			4	control
+			8	alt (meta)
+			16	meta (when it's different from ALT)
+			32	mouse double click
+			64	mouse triple click
+			96	mouse quadruple click (== 32 + 64)
+			128	command (Macintosh only)
+		Only the modifiers that have not been included in the
+		character itself are obtained.  Thus Shift-a results in "A"
+		without a modifier.
+
+getcharsearch()						*getcharsearch()*
+		Return the current character search information as a {dict}
+		with the following entries:
+
+		    char	character previously used for a character
+				search (|t|, |f|, |T|, or |F|); empty string
+				if no character search has been performed
+		    forward	direction of character search; 1 for forward,
+				0 for backward
+		    until	type of character search; 1 for a |t| or |T|
+				character search, 0 for an |f| or |F|
+				character search
+
+		This can be useful to always have |;| and |,| search
+		forward/backward regardless of the direction of the previous
+		character search: >
+			:nnoremap <expr> ; getcharsearch().forward ? ';' : ','
+			:nnoremap <expr> , getcharsearch().forward ? ',' : ';'
+<		Also see |setcharsearch()|.
+
+getcmdline()						*getcmdline()*
+		Return the current command-line.  Only works when the command
+		line is being edited, thus requires use of |c_CTRL-\_e| or
+		|c_CTRL-R_=|.
+		Example: >
+			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
+<		Also see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.
+
+getcmdpos()						*getcmdpos()*
+		Return the position of the cursor in the command line as a
+		byte count.  The first column is 1.
+		Only works when editing the command line, thus requires use of
+		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
+		Returns 0 otherwise.
+		Also see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.
+
+getcmdtype()						*getcmdtype()*
+		Return the current command-line type. Possible return values
+		are:
+		    :	normal Ex command
+		    >	debug mode command |debug-mode|
+		    /	forward search command
+		    ?	backward search command
+		    @	|input()| command
+		    -	|:insert| or |:append| command
+		    =	|i_CTRL-R_=|
+		Only works when editing the command line, thus requires use of
+		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
+		Returns an empty string otherwise.
+		Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.
+
+getcmdwintype()						*getcmdwintype()*
+		Return the current |command-line-window| type. Possible return
+		values are the same as |getcmdtype()|. Returns an empty string
+		when not in the command-line window.
+
+getcompletion({pat}, {type} [, {filtered}])		*getcompletion()*
+		Return a list of command-line completion matches. {type}
+		specifies what for.  The following completion types are
+		supported:
+
+		arglist		file names in argument list
+		augroup		autocmd groups
+		buffer		buffer names
+		behave		:behave suboptions
+		color		color schemes
+		command		Ex command (and arguments)
+		compiler	compilers
+		cscope		|:cscope| suboptions
+		dir		directory names
+		environment	environment variable names
+		event		autocommand events
+		expression	Vim expression
+		file		file and directory names
+		file_in_path	file and directory names in |'path'|
+		filetype	filetype names |'filetype'|
+		function	function name
+		help		help subjects
+		highlight	highlight groups
+		history		:history suboptions
+		locale		locale names (as output of locale -a)
+		mapclear        buffer argument
+		mapping		mapping name
+		menu		menus
+		messages	|:messages| suboptions
+		option		options
+		packadd		optional package |pack-add| names
+		shellcmd	Shell command
+		sign		|:sign| suboptions
+		syntax		syntax file names |'syntax'|
+		syntime		|:syntime| suboptions
+		tag		tags
+		tag_listfiles	tags, file names
+		user		user names
+		var		user variables
+
+		If {pat} is an empty string, then all the matches are returned.
+		Otherwise only items matching {pat} are returned. See
+		|wildcards| for the use of special characters in {pat}.
+
+		If the optional {filtered} flag is set to 1, then 'wildignore'
+		is applied to filter the results.  Otherwise all the matches
+		are returned. The 'wildignorecase' option always applies.
+
+		If there are no matches, an empty list is returned.  An
+		invalid value for {type} produces an error.
+
+							*getcurpos()*
+getcurpos()	Get the position of the cursor.  This is like getpos('.'), but
+		includes an extra item in the list:
+		    [bufnum, lnum, col, off, curswant] ~
+		The "curswant" number is the preferred column when moving the
+		cursor vertically.  Also see |getpos()|.
+
+		This can be used to save and restore the cursor position: >
+			let save_cursor = getcurpos()
+			MoveTheCursorAround
+			call setpos('.', save_cursor)
+<		Note that this only works within the window.  See
+		|winrestview()| for restoring more state.
+							*getcwd()*
+getcwd([{winnr} [, {tabnr}]])
+		The result is a String, which is the name of the current
+		working directory.
+		Without arguments, for the current window.
+
+		With {winnr} return the local current directory of this window
+		in the current tab page.  {winnr} can be the window number or
+		the |window-ID|.
+		If {winnr} is -1 return the name of the global working
+		directory.  See also |haslocaldir()|.
+
+		With {winnr} and {tabnr} return the local current directory of
+		the window in the specified tab page.
+		Return an empty string if the arguments are invalid.
+
+getfsize({fname})					*getfsize()*
+		The result is a Number, which is the size in bytes of the
+		given file {fname}.
+		If {fname} is a directory, 0 is returned.
+		If the file {fname} can't be found, -1 is returned.
+		If the size of {fname} is too big to fit in a Number then -2
+		is returned.
+
+getfontname([{name}])					*getfontname()*
+		Without an argument returns the name of the normal font being
+		used.  Like what is used for the Normal highlight group
+		|hl-Normal|.
+		With an argument a check is done whether {name} is a valid
+		font name.  If not then an empty string is returned.
+		Otherwise the actual font name is returned, or {name} if the
+		GUI does not support obtaining the real name.
+		Only works when the GUI is running, thus not in your vimrc or
+		gvimrc file.  Use the |GUIEnter| autocommand to use this
+		function just after the GUI has started.
+		Note that the GTK GUI accepts any font name, thus checking for
+		a valid name does not work.
+
+getfperm({fname})					*getfperm()*
+		The result is a String, which is the read, write, and execute
+		permissions of the given file {fname}.
+		If {fname} does not exist or its directory cannot be read, an
+		empty string is returned.
+		The result is of the form "rwxrwxrwx", where each group of
+		"rwx" flags represent, in turn, the permissions of the owner
+		of the file, the group the file belongs to, and other users.
+		If a user does not have a given permission the flag for this
+		is replaced with the string "-".  Examples: >
+			:echo getfperm("/etc/passwd")
+			:echo getfperm(expand("~/.vimrc"))
+<		This will hopefully (from a security point of view) display
+		the string "rw-r--r--" or even "rw-------".
+
+		For setting permissions use |setfperm()|.
+
+getftime({fname})					*getftime()*
+		The result is a Number, which is the last modification time of
+		the given file {fname}.  The value is measured as seconds
+		since 1st Jan 1970, and may be passed to strftime().  See also
+		|localtime()| and |strftime()|.
+		If the file {fname} can't be found -1 is returned.
+
+getftype({fname})					*getftype()*
+		The result is a String, which is a description of the kind of
+		file of the given file {fname}.
+		If {fname} does not exist an empty string is returned.
+		Here is a table over different kinds of files and their
+		results:
+			Normal file		"file"
+			Directory		"dir"
+			Symbolic link		"link"
+			Block device		"bdev"
+			Character device	"cdev"
+			Socket			"socket"
+			FIFO			"fifo"
+			All other		"other"
+		Example: >
+			getftype("/home")
+<		Note that a type such as "link" will only be returned on
+		systems that support it.  On some systems only "dir" and
+		"file" are returned.  On MS-Windows a symbolic link to a
+		directory returns "dir" instead of "link".
+
+getjumplist([{winnr} [, {tabnr}]])			*getjumplist()*
+		Returns the |jumplist| for the specified window.
+
+		Without arguments use the current window.
+		With {winnr} only use this window in the current tab page.
+		{winnr} can also be a |window-ID|.
+		With {winnr} and {tabnr} use the window in the specified tab
+		page.
+
+		The returned list contains two entries: a list with the jump
+		locations and the last used jump position number in the list.
+		Each entry in the jump location list is a dictionary with
+		the following entries:
+			bufnr		buffer number
+			col		column number
+			coladd		column offset for 'virtualedit'
+			filename	filename if available
+			lnum		line number
+
+							*getline()*
+getline({lnum} [, {end}])
+		Without {end} the result is a String, which is line {lnum}
+		from the current buffer.  Example: >
+			getline(1)
+<		When {lnum} is a String that doesn't start with a
+		digit, |line()| is called to translate the String into a Number.
+		To get the line under the cursor: >
+			getline(".")
+<		When {lnum} is smaller than 1 or bigger than the number of
+		lines in the buffer, an empty string is returned.
+
+		When {end} is given the result is a |List| where each item is
+		a line from the current buffer in the range {lnum} to {end},
+		including line {end}.
+		{end} is used in the same way as {lnum}.
+		Non-existing lines are silently omitted.
+		When {end} is before {lnum} an empty |List| is returned.
+		Example: >
+			:let start = line('.')
+			:let end = search("^$") - 1
+			:let lines = getline(start, end)
+
+<		To get lines from another buffer see |getbufline()|
+
+getloclist({nr} [, {what}])				*getloclist()*
+		Returns a list with all the entries in the location list for
+		window {nr}.  {nr} can be the window number or the |window-ID|.
+		When {nr} is zero the current window is used.
+
+		For a location list window, the displayed location list is
+		returned.  For an invalid window number {nr}, an empty list is
+		returned. Otherwise, same as |getqflist()|.
+
+		If the optional {what} dictionary argument is supplied, then
+		returns the items listed in {what} as a dictionary. Refer to
+		|getqflist()| for the supported items in {what}.
+		If {what} contains 'filewinid', then returns the id of the
+		window used to display files from the location list. This
+		field is applicable only when called from a location list
+		window.
+
+getmatches()						*getmatches()*
+		Returns a |List| with all matches previously defined by
+		|matchadd()| and the |:match| commands.  |getmatches()| is
+		useful in combination with |setmatches()|, as |setmatches()|
+		can restore a list of matches saved by |getmatches()|.
+		Example: >
+			:echo getmatches()
+<			[{'group': 'MyGroup1', 'pattern': 'TODO',
+			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
+			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
+			:let m = getmatches()
+			:call clearmatches()
+			:echo getmatches()
+<			[] >
+			:call setmatches(m)
+			:echo getmatches()
+<			[{'group': 'MyGroup1', 'pattern': 'TODO',
+			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
+			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
+			:unlet m
+<
+							*getpid()*
+getpid()	Return a Number which is the process ID of the Vim process.
+		On Unix and MS-Windows this is a unique number, until Vim
+		exits.  On MS-DOS it's always zero.
+
+							*getpos()*
+getpos({expr})	Get the position for {expr}.  For possible values of {expr}
+		see |line()|.  For getting the cursor position see
+		|getcurpos()|.
+		The result is a |List| with four numbers:
+		    [bufnum, lnum, col, off]
+		"bufnum" is zero, unless a mark like '0 or 'A is used, then it
+		is the buffer number of the mark.
+		"lnum" and "col" are the position in the buffer.  The first
+		column is 1.
+		The "off" number is zero, unless 'virtualedit' is used.  Then
+		it is the offset in screen columns from the start of the
+		character.  E.g., a position within a <Tab> or after the last
+		character.
+		Note that for '< and '> Visual mode matters: when it is "V"
+		(visual line mode) the column of '< is zero and the column of
+		'> is a large number.
+		This can be used to save and restore the position of a mark: >
+			let save_a_mark = getpos("'a")
+			...
+			call setpos("'a", save_a_mark)
+<		Also see |getcurpos()| and |setpos()|.
+
+
+getqflist([{what}])					*getqflist()*
+		Returns a list with all the current quickfix errors.  Each
+		list item is a dictionary with these entries:
+			bufnr	number of buffer that has the file name, use
+				bufname() to get the name
+			module	module name
+			lnum	line number in the buffer (first line is 1)
+			col	column number (first column is 1)
+			vcol	|TRUE|: "col" is visual column
+				|FALSE|: "col" is byte index
+			nr	error number
+			pattern	search pattern used to locate the error
+			text	description of the error
+			type	type of the error, 'E', '1', etc.
+			valid	|TRUE|: recognized error message
+
+		When there is no error list or it's empty, an empty list is
+		returned. Quickfix list entries with non-existing buffer
+		number are returned with "bufnr" set to zero.
+
+		Useful application: Find pattern matches in multiple files and
+		do something with them: >
+			:vimgrep /theword/jg *.c
+			:for d in getqflist()
+			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
+			:endfor
+<
+		If the optional {what} dictionary argument is supplied, then
+		returns only the items listed in {what} as a dictionary. The
+		following string items are supported in {what}:
+			changedtick	get the total number of changes made
+					to the list |quickfix-changedtick|
+			context	get the |quickfix-context|
+			efm	errorformat to use when parsing "lines". If
+				not present, then the 'errorformat' option
+				value is used.
+			id	get information for the quickfix list with
+				|quickfix-ID|; zero means the id for the
+				current list or the list specified by "nr"
+			idx	index of the current entry in the list
+			items	quickfix list entries
+			lines	parse a list of lines using 'efm' and return
+				the resulting entries.  Only a |List| type is
+				accepted.  The current quickfix list is not
+				modified. See |quickfix-parse|.
+			nr	get information for this quickfix list; zero
+				means the current quickfix list and "$" means
+				the last quickfix list
+			size	number of entries in the quickfix list
+			title	get the list title |quickfix-title|
+			winid	get the quickfix |window-ID|
+			all	all of the above quickfix properties
+		Non-string items in {what} are ignored. To get the value of a
+		particular item, set it to zero.
+		If "nr" is not present then the current quickfix list is used.
+		If both "nr" and a non-zero "id" are specified, then the list
+		specified by "id" is used.
+		To get the number of lists in the quickfix stack, set "nr" to
+		"$" in {what}. The "nr" value in the returned dictionary
+		contains the quickfix stack size.
+		When "lines" is specified, all the other items except "efm"
+		are ignored.  The returned dictionary contains the entry
+		"items" with the list of entries.
+
+		The returned dictionary contains the following entries:
+			changedtick	total number of changes made to the
+					list |quickfix-changedtick|
+			context	quickfix list context. See |quickfix-context|
+				If not present, set to "".
+			id	quickfix list ID |quickfix-ID|. If not
+				present, set to 0.
+			idx	index of the current entry in the list. If not
+				present, set to 0.
+			items	quickfix list entries. If not present, set to
+				an empty list.
+			nr	quickfix list number. If not present, set to 0
+			size	number of entries in the quickfix list. If not
+				present, set to 0.
+			title	quickfix list title text. If not present, set
+				to "".
+			winid	quickfix |window-ID|. If not present, set to 0
+
+		Examples (See also |getqflist-examples|): >
+			:echo getqflist({'all': 1})
+			:echo getqflist({'nr': 2, 'title': 1})
+			:echo getqflist({'lines' : ["F1:10:L10"]})
+<
+getreg([{regname} [, 1 [, {list}]]])			*getreg()*
+		The result is a String, which is the contents of register
+		{regname}.  Example: >
+			:let cliptext = getreg('*')
+<		When {regname} was not set the result is an empty string.
+
+		getreg('=') returns the last evaluated value of the expression
+		register.  (For use in maps.)
+		getreg('=', 1) returns the expression itself, so that it can
+		be restored with |setreg()|.  For other registers the extra
+		argument is ignored, thus you can always give it.
+
+		If {list} is present and |TRUE|, the result type is changed
+		to |List|. Each list item is one text line. Use it if you care
+		about zero bytes possibly present inside register: without
+		third argument both NLs and zero bytes are represented as NLs
+		(see |NL-used-for-Nul|).
+		When the register was not set an empty list is returned.
+
+		If {regname} is not specified, |v:register| is used.
+
+
+getregtype([{regname}])					*getregtype()*
+		The result is a String, which is type of register {regname}.
+		The value will be one of:
+		    "v"			for |characterwise| text
+		    "V"			for |linewise| text
+		    "<CTRL-V>{width}"	for |blockwise-visual| text
+		    ""			for an empty or unknown register
+		<CTRL-V> is one character with value 0x16.
+		If {regname} is not specified, |v:register| is used.
+
+gettabinfo([{arg}])					*gettabinfo()*
+		If {arg} is not specified, then information about all the tab
+		pages is returned as a List. Each List item is a Dictionary.
+		Otherwise, {arg} specifies the tab page number and information
+		about that one is returned.  If the tab page does not exist an
+		empty List is returned.
+
+		Each List item is a Dictionary with the following entries:
+			tabnr		tab page number.
+			variables	a reference to the dictionary with
+					tabpage-local variables
+			windows		List of |window-ID|s in the tag page.
+
+gettabvar({tabnr}, {varname} [, {def}])				*gettabvar()*
+		Get the value of a tab-local variable {varname} in tab page
+		{tabnr}. |t:var|
+		Tabs are numbered starting with one.
+		When {varname} is empty a dictionary with all tab-local
+		variables is returned.
+		Note that the name without "t:" must be used.
+		When the tab or variable doesn't exist {def} or an empty
+		string is returned, there is no error message.
+
+gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*gettabwinvar()*
+		Get the value of window-local variable {varname} in window
+		{winnr} in tab page {tabnr}.
+		When {varname} is empty a dictionary with all window-local
+		variables is returned.
+		When {varname} is equal to "&" get the values of all
+		window-local options in a Dictionary.
+		Otherwise, when {varname} starts with "&" get the value of a
+		window-local option.
+		Note that {varname} must be the name without "w:".
+		Tabs are numbered starting with one.  For the current tabpage
+		use |getwinvar()|.
+		{winnr} can be the window number or the |window-ID|.
+		When {winnr} is zero the current window is used.
+		This also works for a global option, buffer-local option and
+		window-local option, but it doesn't work for a global variable
+		or buffer-local variable.
+		When the tab, window or variable doesn't exist {def} or an
+		empty string is returned, there is no error message.
+		Examples: >
+			:let list_is_on = gettabwinvar(1, 2, '&list')
+			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
+<
+		To obtain all window-local variables use: >
+			gettabwinvar({tabnr}, {winnr}, '&')
+
+getwininfo([{winid}])					*getwininfo()*
+		Returns information about windows as a List with Dictionaries.
+
+		If {winid} is given Information about the window with that ID
+		is returned.  If the window does not exist the result is an
+		empty list.
+
+		Without {winid} information about all the windows in all the
+		tab pages is returned.
+
+		Each List item is a Dictionary with the following entries:
+			bufnr		number of buffer in the window
+			height		window height (excluding winbar)
+			loclist		1 if showing a location list
+					{only with the +quickfix feature}
+			quickfix	1 if quickfix or location list window
+					{only with the +quickfix feature}
+			terminal	1 if a terminal window
+					{only with the +terminal feature}
+			tabnr		tab page number
+			variables	a reference to the dictionary with
+					window-local variables
+			width		window width
+			winbar		1 if the window has a toolbar, 0
+					otherwise
+			wincol		leftmost screen column of the window,
+					col from |win_screenpos()|
+			winid		|window-ID|
+			winnr		window number
+			winrow		topmost screen column of the window,
+					row from |win_screenpos()|
+
+getwinpos([{timeout}])					*getwinpos()*
+		The result is a list with two numbers, the result of
+		getwinposx() and getwinposy() combined: 
+			[x-pos, y-pos]
+		{timeout} can be used to specify how long to wait in msec for
+		a response from the terminal.  When omitted 100 msec is used.
+		Use a longer time for a remote terminal.
+		When using a value less than 10 and no response is received
+		within that time, a previously reported position is returned,
+		if available.  This can be used to poll for the position and
+		do some work in the mean time: >
+			while 1
+			  let res = getwinpos(1)
+			  if res[0] >= 0
+			    break
+			  endif
+			  " Do some work here
+			endwhile
+<
+							*getwinposx()*
+getwinposx()	The result is a Number, which is the X coordinate in pixels of
+		the left hand side of the GUI Vim window. Also works for an
+		xterm (uses a timeout of 100 msec).
+		The result will be -1 if the information is not available.
+		The value can be used with `:winpos`.
+
+							*getwinposy()*
+getwinposy()	The result is a Number, which is the Y coordinate in pixels of
+		the top of the GUI Vim window.  Also works for an xterm (uses
+		a timeout of 100 msec).
+		The result will be -1 if the information is not available.
+		The value can be used with `:winpos`.
+
+getwinvar({winnr}, {varname} [, {def}])				*getwinvar()*
+		Like |gettabwinvar()| for the current tabpage.
+		Examples: >
+			:let list_is_on = getwinvar(2, '&list')
+			:echo "myvar = " . getwinvar(1, 'myvar')
+<
+glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])		*glob()*
+		Expand the file wildcards in {expr}.  See |wildcards| for the
+		use of special characters.
+
+		Unless the optional {nosuf} argument is given and is |TRUE|,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
+		'wildignorecase' always applies.
+
+		When {list} is present and it is |TRUE| the result is a List
+		with all matching files. The advantage of using a List is,
+		you also get filenames containing newlines correctly.
+		Otherwise the result is a String and when there are several
+		matches, they are separated by <NL> characters.
+
+		If the expansion fails, the result is an empty String or List.
+
+		A name for a non-existing file is not included.  A symbolic
+		link is only included if it points to an existing file.
+		However, when the {alllinks} argument is present and it is
+		|TRUE| then all symbolic links are included.
+
+		For most systems backticks can be used to get files names from
+		any external command.  Example: >
+			:let tagfiles = glob("`find . -name tags -print`")
+			:let &tags = substitute(tagfiles, "\n", ",", "g")
+<		The result of the program inside the backticks should be one
+		item per line.  Spaces inside an item are allowed.
+
+		See |expand()| for expanding special Vim variables.  See
+		|system()| for getting the raw output of an external command.
+
+glob2regpat({expr})					 *glob2regpat()*
+		Convert a file pattern, as used by glob(), into a search
+		pattern.  The result can be used to match with a string that
+		is a file name.  E.g. >
+			if filename =~ glob2regpat('Make*.mak')
+<		This is equivalent to: >
+			if filename =~ '^Make.*\.mak$'
+<		When {expr} is an empty string the result is "^$", match an
+		empty string.
+		Note that the result depends on the system.  On MS-Windows
+		a backslash usually means a path separator.
+
+								*globpath()*
+globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
+		Perform glob() on all directories in {path} and concatenate
+		the results.  Example: >
+			:echo globpath(&rtp, "syntax/c.vim")
+<
+		{path} is a comma-separated list of directory names.  Each
+		directory name is prepended to {expr} and expanded like with
+		|glob()|.  A path separator is inserted when needed.
+		To add a comma inside a directory name escape it with a
+		backslash.  Note that on MS-Windows a directory may have a
+		trailing backslash, remove it if you put a comma after it.
+		If the expansion fails for one of the directories, there is no
+		error message.
+
+		Unless the optional {nosuf} argument is given and is |TRUE|,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
+
+		When {list} is present and it is |TRUE| the result is a List
+		with all matching files. The advantage of using a List is, you
+		also get filenames containing newlines correctly. Otherwise
+		the result is a String and when there are several matches,
+		they are separated by <NL> characters.  Example: >
+			:echo globpath(&rtp, "syntax/c.vim", 0, 1)
+<
+		{alllinks} is used as with |glob()|.
+
+		The "**" item can be used to search in a directory tree.
+		For example, to find all "README.txt" files in the directories
+		in 'runtimepath' and below: >
+			:echo globpath(&rtp, "**/README.txt")
+<		Upwards search and limiting the depth of "**" is not
+		supported, thus using 'path' will not always work properly.
+
+							*has()*
+has({feature})	The result is a Number, which is 1 if the feature {feature} is
+		supported, zero otherwise.  The {feature} argument is a
+		string.  See |feature-list| below.
+		Also see |exists()|.
+
+
+has_key({dict}, {key})					*has_key()*
+		The result is a Number, which is 1 if |Dictionary| {dict} has
+		an entry with key {key}.  Zero otherwise.
+
+haslocaldir([{winnr} [, {tabnr}]])			*haslocaldir()*
+		The result is a Number, which is 1 when the window has set a
+		local path via |:lcd|, and 0 otherwise.
+
+		Without arguments use the current window.
+		With {winnr} use this window in the current tab page.
+		With {winnr} and {tabnr} use the window in the specified tab
+		page.
+		{winnr} can be the window number or the |window-ID|.
+		Return 0 if the arguments are invalid.
+
+hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
+		The result is a Number, which is 1 if there is a mapping that
+		contains {what} in somewhere in the rhs (what it is mapped to)
+		and this mapping exists in one of the modes indicated by
+		{mode}.
+		When {abbr} is there and it is |TRUE| use abbreviations
+		instead of mappings.  Don't forget to specify Insert and/or
+		Command-line mode.
+		Both the global mappings and the mappings local to the current
+		buffer are checked for a match.
+		If no matching mapping is found 0 is returned.
+		The following characters are recognized in {mode}:
+			n	Normal mode
+			v	Visual mode
+			o	Operator-pending mode
+			i	Insert mode
+			l	Language-Argument ("r", "f", "t", etc.)
+			c	Command-line mode
+		When {mode} is omitted, "nvo" is used.
+
+		This function is useful to check if a mapping already exists
+		to a function in a Vim script.  Example: >
+			:if !hasmapto('\ABCdoit')
+			:   map <Leader>d \ABCdoit
+			:endif
+<		This installs the mapping to "\ABCdoit" only if there isn't
+		already a mapping to "\ABCdoit".
+
+histadd({history}, {item})				*histadd()*
+		Add the String {item} to the history {history} which can be
+		one of:					*hist-names*
+			"cmd"	 or ":"	  command line history
+			"search" or "/"   search pattern history
+			"expr"	 or "="   typed expression history
+			"input"  or "@"	  input line history
+			"debug"  or ">"   debug command history
+			empty		  the current or last used history
+		The {history} string does not need to be the whole name, one
+		character is sufficient.
+		If {item} does already exist in the history, it will be
+		shifted to become the newest entry.
+		The result is a Number: 1 if the operation was successful,
+		otherwise 0 is returned.
+
+		Example: >
+			:call histadd("input", strftime("%Y %b %d"))
+			:let date=input("Enter date: ")
+<		This function is not available in the |sandbox|.
+
+histdel({history} [, {item}])				*histdel()*
+		Clear {history}, i.e. delete all its entries.  See |hist-names|
+		for the possible values of {history}.
+
+		If the parameter {item} evaluates to a String, it is used as a
+		regular expression.  All entries matching that expression will
+		be removed from the history (if there are any).
+		Upper/lowercase must match, unless "\c" is used |/\c|.
+		If {item} evaluates to a Number, it will be interpreted as
+		an index, see |:history-indexing|.  The respective entry will
+		be removed if it exists.
+
+		The result is a Number: 1 for a successful operation,
+		otherwise 0 is returned.
+
+		Examples:
+		Clear expression register history: >
+			:call histdel("expr")
+<
+		Remove all entries starting with "*" from the search history: >
+			:call histdel("/", '^\*')
+<
+		The following three are equivalent: >
+			:call histdel("search", histnr("search"))
+			:call histdel("search", -1)
+			:call histdel("search", '^'.histget("search", -1).'$')
+<
+		To delete the last search pattern and use the last-but-one for
+		the "n" command and 'hlsearch': >
+			:call histdel("search", -1)
+			:let @/ = histget("search", -1)
+
+histget({history} [, {index}])				*histget()*
+		The result is a String, the entry with Number {index} from
+		{history}.  See |hist-names| for the possible values of
+		{history}, and |:history-indexing| for {index}.  If there is
+		no such entry, an empty String is returned.  When {index} is
+		omitted, the most recent item from the history is used.
+
+		Examples:
+		Redo the second last search from history. >
+			:execute '/' . histget("search", -2)
+
+<		Define an Ex command ":H {num}" that supports re-execution of
+		the {num}th entry from the output of |:history|. >
+			:command -nargs=1 H execute histget("cmd", 0+<args>)
+<
+histnr({history})					*histnr()*
+		The result is the Number of the current entry in {history}.
+		See |hist-names| for the possible values of {history}.
+		If an error occurred, -1 is returned.
+
+		Example: >
+			:let inp_index = histnr("expr")
+<
+hlexists({name})					*hlexists()*
+		The result is a Number, which is non-zero if a highlight group
+		called {name} exists.  This is when the group has been
+		defined in some way.  Not necessarily when highlighting has
+		been defined for it, it may also have been used for a syntax
+		item.
+							*highlight_exists()*
+		Obsolete name: highlight_exists().
+
+							*hlID()*
+hlID({name})	The result is a Number, which is the ID of the highlight group
+		with name {name}.  When the highlight group doesn't exist,
+		zero is returned.
+		This can be used to retrieve information about the highlight
+		group.  For example, to get the background color of the
+		"Comment" group: >
+	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
+<							*highlightID()*
+		Obsolete name: highlightID().
+
+hostname()						*hostname()*
+		The result is a String, which is the name of the machine on
+		which Vim is currently running.  Machine names greater than
+		256 characters long are truncated.
+
+iconv({expr}, {from}, {to})				*iconv()*
+		The result is a String, which is the text {expr} converted
+		from encoding {from} to encoding {to}.
+		When the conversion completely fails an empty string is
+		returned.  When some characters could not be converted they
+		are replaced with "?".
+		The encoding names are whatever the iconv() library function
+		can accept, see ":!man 3 iconv".
+		Most conversions require Vim to be compiled with the |+iconv|
+		feature.  Otherwise only UTF-8 to latin1 conversion and back
+		can be done.
+		This can be used to display messages with special characters,
+		no matter what 'encoding' is set to.  Write the message in
+		UTF-8 and use: >
+			echo iconv(utf8_str, "utf-8", &enc)
+<		Note that Vim uses UTF-8 for all Unicode encodings, conversion
+		from/to UCS-2 is automatically changed to use UTF-8.  You
+		cannot use UCS-2 in a string anyway, because of the NUL bytes.
+		{only available when compiled with the |+multi_byte| feature}
+
+							*indent()*
+indent({lnum})	The result is a Number, which is indent of line {lnum} in the
+		current buffer.  The indent is counted in spaces, the value
+		of 'tabstop' is relevant.  {lnum} is used just like in
+		|getline()|.
+		When {lnum} is invalid -1 is returned.
+
+
+index({list}, {expr} [, {start} [, {ic}]])			*index()*
+		Return the lowest index in |List| {list} where the item has a
+		value equal to {expr}.  There is no automatic conversion, so
+		the String "4" is different from the Number 4.  And the number
+		4 is different from the Float 4.0.  The value of 'ignorecase'
+		is not used here, case always matters.
+		If {start} is given then start looking at the item with index
+		{start} (may be negative for an item relative to the end).
+		When {ic} is given and it is |TRUE|, ignore case.  Otherwise
+		case must match.
+		-1 is returned when {expr} is not found in {list}.
+		Example: >
+			:let idx = index(words, "the")
+			:if index(numbers, 123) >= 0
+
+
+input({prompt} [, {text} [, {completion}]])		*input()*
+		The result is a String, which is whatever the user typed on
+		the command-line.  The {prompt} argument is either a prompt
+		string, or a blank string (for no prompt).  A '\n' can be used
+		in the prompt to start a new line.
+		The highlighting set with |:echohl| is used for the prompt.
+		The input is entered just like a command-line, with the same
+		editing commands and mappings.  There is a separate history
+		for lines typed for input().
+		Example: >
+			:if input("Coffee or beer? ") == "beer"
+			:  echo "Cheers!"
+			:endif
+<
+		If the optional {text} argument is present and not empty, this
+		is used for the default reply, as if the user typed this.
+		Example: >
+			:let color = input("Color? ", "white")
+
+<		The optional {completion} argument specifies the type of
+		completion supported for the input.  Without it completion is
+		not performed.  The supported completion types are the same as
+		that can be supplied to a user-defined command using the
+		"-complete=" argument.  Refer to |:command-completion| for
+		more information.  Example: >
+			let fname = input("File: ", "", "file")
+<
+		NOTE: This function must not be used in a startup file, for
+		the versions that only run in GUI mode (e.g., the Win32 GUI).
+		Note: When input() is called from within a mapping it will
+		consume remaining characters from that mapping, because a
+		mapping is handled like the characters were typed.
+		Use |inputsave()| before input() and |inputrestore()|
+		after input() to avoid that.  Another solution is to avoid
+		that further characters follow in the mapping, e.g., by using
+		|:execute| or |:normal|.
+
+		Example with a mapping: >
+			:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
+			:function GetFoo()
+			:  call inputsave()
+			:  let g:Foo = input("enter search pattern: ")
+			:  call inputrestore()
+			:endfunction
+
+inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
+		Like |input()|, but when the GUI is running and text dialogs
+		are supported, a dialog window pops up to input the text.
+		Example: >
+		   :let n = inputdialog("value for shiftwidth", shiftwidth())
+		   :if n != ""
+		   :  let &sw = n
+		   :endif
+<		When the dialog is cancelled {cancelreturn} is returned.  When
+		omitted an empty string is returned.
+		Hitting <Enter> works like pressing the OK button.  Hitting
+		<Esc> works like pressing the Cancel button.
+		NOTE: Command-line completion is not supported.
+
+inputlist({textlist})					*inputlist()*
+		{textlist} must be a |List| of strings.  This |List| is
+		displayed, one string per line.  The user will be prompted to
+		enter a number, which is returned.
+		The user can also select an item by clicking on it with the
+		mouse.  For the first string 0 is returned.  When clicking
+		above the first item a negative number is returned.  When
+		clicking on the prompt one more than the length of {textlist}
+		is returned.
+		Make sure {textlist} has less than 'lines' entries, otherwise
+		it won't work.  It's a good idea to put the entry number at
+		the start of the string.  And put a prompt in the first item.
+		Example: >
+			let color = inputlist(['Select color:', '1. red',
+				\ '2. green', '3. blue'])
+
+inputrestore()						*inputrestore()*
+		Restore typeahead that was saved with a previous |inputsave()|.
+		Should be called the same number of times inputsave() is
+		called.  Calling it more often is harmless though.
+		Returns 1 when there is nothing to restore, 0 otherwise.
+
+inputsave()						*inputsave()*
+		Preserve typeahead (also from mappings) and clear it, so that
+		a following prompt gets input from the user.  Should be
+		followed by a matching inputrestore() after the prompt.  Can
+		be used several times, in which case there must be just as
+		many inputrestore() calls.
+		Returns 1 when out of memory, 0 otherwise.
+
+inputsecret({prompt} [, {text}])			*inputsecret()*
+		This function acts much like the |input()| function with but
+		two exceptions:
+		a) the user's response will be displayed as a sequence of
+		asterisks ("*") thereby keeping the entry secret, and
+		b) the user's response will not be recorded on the input
+		|history| stack.
+		The result is a String, which is whatever the user actually
+		typed on the command-line in response to the issued prompt.
+		NOTE: Command-line completion is not supported.
+
+insert({list}, {item} [, {idx}])			*insert()*
+		Insert {item} at the start of |List| {list}.
+		If {idx} is specified insert {item} before the item with index
+		{idx}.  If {idx} is zero it goes before the first item, just
+		like omitting {idx}.  A negative {idx} is also possible, see
+		|list-index|.  -1 inserts just before the last item.
+		Returns the resulting |List|.  Examples: >
+			:let mylist = insert([2, 3, 5], 1)
+			:call insert(mylist, 4, -1)
+			:call insert(mylist, 6, len(mylist))
+<		The last example can be done simpler with |add()|.
+		Note that when {item} is a |List| it is inserted as a single
+		item.  Use |extend()| to concatenate |Lists|.
+
+invert({expr})						*invert()*
+		Bitwise invert.  The argument is converted to a number.  A
+		List, Dict or Float argument causes an error.  Example: >
+			:let bits = invert(bits)
+
+isdirectory({directory})				*isdirectory()*
+		The result is a Number, which is |TRUE| when a directory
+		with the name {directory} exists.  If {directory} doesn't
+		exist, or isn't a directory, the result is |FALSE|.  {directory}
+		is any expression, which is used as a String.
+
+islocked({expr})					*islocked()* *E786*
+		The result is a Number, which is |TRUE| when {expr} is the
+		name of a locked variable.
+		{expr} must be the name of a variable, |List| item or
+		|Dictionary| entry, not the variable itself!  Example: >
+			:let alist = [0, ['a', 'b'], 2, 3]
+			:lockvar 1 alist
+			:echo islocked('alist')		" 1
+			:echo islocked('alist[1]')	" 0
+
+<		When {expr} is a variable that does not exist you get an error
+		message.  Use |exists()| to check for existence.
+
+isnan({expr})						*isnan()*
+		Return |TRUE| if {expr} is a float with value NaN. >
+			echo isnan(0.0 / 0.0)
+<			1 ~
+
+		{only available when compiled with the |+float| feature}
+
+items({dict})						*items()*
+		Return a |List| with all the key-value pairs of {dict}.  Each
+		|List| item is a list with two items: the key of a {dict}
+		entry and the value of this entry.  The |List| is in arbitrary
+		order.
+
+job_getchannel({job})					 *job_getchannel()*
+		Get the channel handle that {job} is using.
+		To check if the job has no channel: >
+			if string(job_getchannel()) == 'channel fail'
+<
+		{only available when compiled with the |+job| feature}
+
+job_info([{job}])					*job_info()*
+		Returns a Dictionary with information about {job}:
+		   "status"	what |job_status()| returns
+		   "channel"	what |job_getchannel()| returns
+		   "cmd"	List of command arguments used to start the job
+		   "process"	process ID
+		   "tty_in"	terminal input name, empty when none
+		   "tty_out"	terminal output name, empty when none
+		   "exitval"	only valid when "status" is "dead"
+		   "exit_cb"	function to be called on exit
+		   "stoponexit"	|job-stoponexit|
+
+		Without any arguments, returns a List with all Job objects.
+
+job_setoptions({job}, {options})			*job_setoptions()*
+		Change options for {job}.  Supported are:
+		   "stoponexit"	|job-stoponexit|
+		   "exit_cb"	|job-exit_cb|
+
+job_start({command} [, {options}])			*job_start()*
+		Start a job and return a Job object.  Unlike |system()| and
+		|:!cmd| this does not wait for the job to finish.
+		To start a job in a terminal window see |term_start()|.
+
+		{command} can be a String.  This works best on MS-Windows.  On
+		Unix it is split up in white-separated parts to be passed to
+		execvp().  Arguments in double quotes can contain white space.
+
+		{command} can be a List, where the first item is the executable
+		and further items are the arguments.  All items are converted
+		to String.  This works best on Unix.
+
+		On MS-Windows, job_start() makes a GUI application hidden. If
+		want to show it, Use |:!start| instead.
+
+		The command is executed directly, not through a shell, the
+		'shell' option is not used.  To use the shell: >
+	let job = job_start(["/bin/sh", "-c", "echo hello"])
+<		Or: >
+	let job = job_start('/bin/sh -c "echo hello"')
+<		Note that this will start two processes, the shell and the
+		command it executes.  If you don't want this use the "exec"
+		shell command.
+
+		On Unix $PATH is used to search for the executable only when
+		the command does not contain a slash.
+
+		The job will use the same terminal as Vim.  If it reads from
+		stdin the job and Vim will be fighting over input, that
+		doesn't work.  Redirect stdin and stdout to avoid problems: >
+	let job = job_start(['sh', '-c', "myserver </dev/null >/dev/null"])
+<
+		The returned Job object can be used to get the status with
+		|job_status()| and stop the job with |job_stop()|.
+
+		Note that the job object will be deleted if there are no
+		references to it.  This closes the stdin and stderr, which may
+		cause the job to fail with an error.  To avoid this keep a
+		reference to the job.  Thus instead of: >
+	call job_start('my-command')
+<		use: >
+	let myjob = job_start('my-command')
+<		and unlet "myjob" once the job is not needed or is past the
+		point where it would fail (e.g. when it prints a message on
+		startup).  Keep in mind that variables local to a function
+		will cease to exist if the function returns.  Use a
+		script-local variable if needed: >
+	let s:myjob = job_start('my-command')
+<
+		{options} must be a Dictionary.  It can contain many optional
+		items, see |job-options|.
+
+		{only available when compiled with the |+job| feature}
+
+job_status({job})					*job_status()* *E916*
+		Returns a String with the status of {job}:
+			"run"	job is running
+			"fail"	job failed to start
+			"dead"	job died or was stopped after running
+
+		On Unix a non-existing command results in "dead" instead of
+		"fail", because a fork happens before the failure can be
+		detected.
+
+		If an exit callback was set with the "exit_cb" option and the
+		job is now detected to be "dead" the callback will be invoked.
+
+		For more information see |job_info()|.
+
+		{only available when compiled with the |+job| feature}
+
+job_stop({job} [, {how}])					*job_stop()*
+		Stop the {job}.  This can also be used to signal the job.
+
+		When {how} is omitted or is "term" the job will be terminated.
+		For Unix SIGTERM is sent.  On MS-Windows the job will be
+		terminated forcedly (there is no "gentle" way).
+		This goes to the process group, thus children may also be
+		affected.
+
+		Effect for Unix:
+			"term"	 SIGTERM (default)
+			"hup"	 SIGHUP
+			"quit"	 SIGQUIT
+			"int"	 SIGINT
+			"kill"	 SIGKILL (strongest way to stop)
+			number	 signal with that number
+
+		Effect for MS-Windows:
+			"term"	 terminate process forcedly (default)
+			"hup"	 CTRL_BREAK
+			"quit"	 CTRL_BREAK
+			"int"	 CTRL_C
+			"kill"	 terminate process forcedly
+			Others	 CTRL_BREAK
+
+		On Unix the signal is sent to the process group.  This means
+		that when the job is "sh -c command" it affects both the shell
+		and the command.
+
+		The result is a Number: 1 if the operation could be executed,
+		0 if "how" is not supported on the system.
+		Note that even when the operation was executed, whether the
+		job was actually stopped needs to be checked with
+		|job_status()|.
+
+		If the status of the job is "dead", the signal will not be
+		sent.  This is to avoid to stop the wrong job (esp. on Unix,
+		where process numbers are recycled).
+
+		When using "kill" Vim will assume the job will die and close
+		the channel.
+
+		{only available when compiled with the |+job| feature}
+
+join({list} [, {sep}])					*join()*
+		Join the items in {list} together into one String.
+		When {sep} is specified it is put in between the items.  If
+		{sep} is omitted a single space is used.
+		Note that {sep} is not added at the end.  You might want to
+		add it there too: >
+			let lines = join(mylist, "\n") . "\n"
+<		String items are used as-is.  |Lists| and |Dictionaries| are
+		converted into a string like with |string()|.
+		The opposite function is |split()|.
+
+js_decode({string})					*js_decode()*
+		This is similar to |json_decode()| with these differences:
+		- Object key names do not have to be in quotes.
+		- Strings can be in single quotes.
+		- Empty items in an array (between two commas) are allowed and
+		  result in v:none items.
+
+js_encode({expr})					*js_encode()*
+		This is similar to |json_encode()| with these differences:
+		- Object key names are not in quotes.
+		- v:none items in an array result in an empty item between
+		  commas.
+		For example, the Vim object:
+			[1,v:none,{"one":1},v:none] ~
+		Will be encoded as:
+			[1,,{one:1},,] ~
+		While json_encode() would produce:
+			[1,null,{"one":1},null] ~
+		This encoding is valid for JavaScript. It is more efficient
+		than JSON, especially when using an array with optional items.
+
+
+json_decode({string})					*json_decode()*
+		This parses a JSON formatted string and returns the equivalent
+		in Vim values.  See |json_encode()| for the relation between
+		JSON and Vim values.
+		The decoding is permissive:
+		- A trailing comma in an array and object is ignored, e.g.
+		  "[1, 2, ]" is the same as "[1, 2]".
+		- More floating point numbers are recognized, e.g. "1." for
+		  "1.0", or "001.2" for "1.2". Special floating point values
+		  "Infinity" and "NaN" (capitalization ignored) are accepted.
+		- Leading zeroes in integer numbers are ignored, e.g. "012"
+		  for "12" or "-012" for "-12".
+		- Capitalization is ignored in literal names null, true or
+		  false, e.g. "NULL" for "null", "True" for "true".
+		- Control characters U+0000 through U+001F which are not
+		  escaped in strings are accepted, e.g. "	" (tab
+		  character in string) for "\t".
+		- Backslash in an invalid 2-character sequence escape is
+		  ignored, e.g. "\a" is decoded as "a".
+		- A correct surrogate pair in JSON strings should normally be
+		  a 12 character sequence such as "\uD834\uDD1E", but
+		  json_decode() silently accepts truncated surrogate pairs
+		  such as "\uD834" or "\uD834\u"
+								*E938*
+		A duplicate key in an object, valid in rfc7159, is not
+		accepted by json_decode() as the result must be a valid Vim
+		type, e.g. this fails: {"a":"b", "a":"c"}
+
+
+json_encode({expr})					*json_encode()*
+		Encode {expr} as JSON and return this as a string.
+		The encoding is specified in:
+		https://tools.ietf.org/html/rfc7159.html
+		Vim values are converted as follows:
+		   Number		decimal number
+		   Float		floating point number
+		   Float nan		"NaN"
+		   Float inf		"Infinity"
+		   String		in double quotes (possibly null)
+		   Funcref		not possible, error
+		   List			as an array (possibly null); when
+					used recursively: []
+		   Dict			as an object (possibly null); when
+					used recursively: {}
+		   v:false		"false"
+		   v:true		"true"
+		   v:none		"null"
+		   v:null		"null"
+		Note that NaN and Infinity are passed on as values.  This is
+		missing in the JSON standard, but several implementations do
+		allow it.  If not then you will get an error.
+
+keys({dict})						*keys()*
+		Return a |List| with all the keys of {dict}.  The |List| is in
+		arbitrary order.
+
+							*len()* *E701*
+len({expr})	The result is a Number, which is the length of the argument.
+		When {expr} is a String or a Number the length in bytes is
+		used, as with |strlen()|.
+		When {expr} is a |List| the number of items in the |List| is
+		returned.
+		When {expr} is a |Dictionary| the number of entries in the
+		|Dictionary| is returned.
+		Otherwise an error is given.
+
+						*libcall()* *E364* *E368*
+libcall({libname}, {funcname}, {argument})
+		Call function {funcname} in the run-time library {libname}
+		with single argument {argument}.
+		This is useful to call functions in a library that you
+		especially made to be used with Vim.  Since only one argument
+		is possible, calling standard library functions is rather
+		limited.
+		The result is the String returned by the function.  If the
+		function returns NULL, this will appear as an empty string ""
+		to Vim.
+		If the function returns a number, use libcallnr()!
+		If {argument} is a number, it is passed to the function as an
+		int; if {argument} is a string, it is passed as a
+		null-terminated string.
+		This function will fail in |restricted-mode|.
+
+		libcall() allows you to write your own 'plug-in' extensions to
+		Vim without having to recompile the program.  It is NOT a
+		means to call system functions!  If you try to do so Vim will
+		very probably crash.
+
+		For Win32, the functions you write must be placed in a DLL
+		and use the normal C calling convention (NOT Pascal which is
+		used in Windows System DLLs).  The function must take exactly
+		one parameter, either a character pointer or a long integer,
+		and must return a character pointer or NULL.  The character
+		pointer returned must point to memory that will remain valid
+		after the function has returned (e.g. in static data in the
+		DLL).  If it points to allocated memory, that memory will
+		leak away.  Using a static buffer in the function should work,
+		it's then freed when the DLL is unloaded.
+
+		WARNING: If the function returns a non-valid pointer, Vim may
+		crash!	This also happens if the function returns a number,
+		because Vim thinks it's a pointer.
+		For Win32 systems, {libname} should be the filename of the DLL
+		without the ".DLL" suffix.  A full path is only required if
+		the DLL is not in the usual places.
+		For Unix: When compiling your own plugins, remember that the
+		object code must be compiled as position-independent ('PIC').
+		{only in Win32 and some Unix versions, when the |+libcall|
+		feature is present}
+		Examples: >
+			:echo libcall("libc.so", "getenv", "HOME")
+<
+							*libcallnr()*
+libcallnr({libname}, {funcname}, {argument})
+		Just like |libcall()|, but used for a function that returns an
+		int instead of a string.
+		{only in Win32 on some Unix versions, when the |+libcall|
+		feature is present}
+		Examples: >
+			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
+			:call libcallnr("libc.so", "printf", "Hello World!\n")
+			:call libcallnr("libc.so", "sleep", 10)
+<
+							*line()*
+line({expr})	The result is a Number, which is the line number of the file
+		position given with {expr}.  The accepted positions are:
+		    .	    the cursor position
+		    $	    the last line in the current buffer
+		    'x	    position of mark x (if the mark is not set, 0 is
+			    returned)
+		    w0	    first line visible in current window (one if the
+			    display isn't updated, e.g. in silent Ex mode)
+		    w$	    last line visible in current window (this is one
+			    less than "w0" if no lines are visible)
+		    v	    In Visual mode: the start of the Visual area (the
+			    cursor is the end).  When not in Visual mode
+			    returns the cursor position.  Differs from |'<| in
+			    that it's updated right away.
+		Note that a mark in another file can be used.  The line number
+		then applies to another buffer.
+		To get the column number use |col()|.  To get both use
+		|getpos()|.
+		Examples: >
+			line(".")		line number of the cursor
+			line("'t")		line number of mark t
+			line("'" . marker)	line number of mark marker
+<							*last-position-jump*
+		This autocommand jumps to the last known position in a file
+		just after opening it, if the '" mark is set: >
+     :au BufReadPost *
+	 \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
+	 \ |   exe "normal! g`\""
+	 \ | endif
+
+line2byte({lnum})					*line2byte()*
+		Return the byte count from the start of the buffer for line
+		{lnum}.  This includes the end-of-line character, depending on
+		the 'fileformat' option for the current buffer.  The first
+		line returns 1. 'encoding' matters, 'fileencoding' is ignored.
+		This can also be used to get the byte count for the line just
+		below the last line: >
+			line2byte(line("$") + 1)
+<		This is the buffer size plus one.  If 'fileencoding' is empty
+		it is the file size plus one.
+		When {lnum} is invalid, or the |+byte_offset| feature has been
+		disabled at compile time, -1 is returned.
+		Also see |byte2line()|, |go| and |:goto|.
+
+lispindent({lnum})					*lispindent()*
+		Get the amount of indent for line {lnum} according the lisp
+		indenting rules, as with 'lisp'.
+		The indent is counted in spaces, the value of 'tabstop' is
+		relevant.  {lnum} is used just like in |getline()|.
+		When {lnum} is invalid or Vim was not compiled the
+		|+lispindent| feature, -1 is returned.
+
+localtime()						*localtime()*
+		Return the current time, measured as seconds since 1st Jan
+		1970.  See also |strftime()| and |getftime()|.
+
+
+log({expr})						*log()*
+		Return the natural logarithm (base e) of {expr} as a |Float|.
+		{expr} must evaluate to a |Float| or a |Number| in the range
+		(0, inf].
+		Examples: >
+			:echo log(10)
+<			2.302585 >
+			:echo log(exp(5))
+<			5.0
+		{only available when compiled with the |+float| feature}
+
+
+log10({expr})						*log10()*
+		Return the logarithm of Float {expr} to base 10 as a |Float|.
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo log10(1000)
+<			3.0 >
+			:echo log10(0.01)
+<			-2.0
+		{only available when compiled with the |+float| feature}
+
+luaeval({expr} [, {expr}])					*luaeval()*
+		Evaluate Lua expression {expr} and return its result converted
+		to Vim data structures. Second {expr} may hold additional
+		argument accessible as _A inside first {expr}.
+		Strings are returned as they are.
+		Boolean objects are converted to numbers.
+		Numbers are converted to |Float| values if vim was compiled
+		with |+float| and to numbers otherwise.
+		Dictionaries and lists obtained by vim.eval() are returned
+		as-is.
+		Other objects are returned as zero without any errors.
+		See |lua-luaeval| for more details.
+		{only available when compiled with the |+lua| feature}
+
+map({expr1}, {expr2})					*map()*
+		{expr1} must be a |List| or a |Dictionary|.
+		Replace each item in {expr1} with the result of evaluating
+		{expr2}.  {expr2} must be a |string| or |Funcref|.
+
+		If {expr2} is a |string|, inside {expr2} |v:val| has the value
+		of the current item.  For a |Dictionary| |v:key| has the key
+		of the current item and for a |List| |v:key| has the index of
+		the current item.
+		Example: >
+			:call map(mylist, '"> " . v:val . " <"')
+<		This puts "> " before and " <" after each item in "mylist".
+
+		Note that {expr2} is the result of an expression and is then
+		used as an expression again.  Often it is good to use a
+		|literal-string| to avoid having to double backslashes.  You
+		still have to double ' quotes
+
+		If {expr2} is a |Funcref| it is called with two arguments:
+			1. The key or the index of the current item.
+			2. the value of the current item.
+		The function must return the new value of the item. Example
+		that changes each value by "key-value": >
+			func KeyValue(key, val)
+			  return a:key . '-' . a:val
+			endfunc
+			call map(myDict, function('KeyValue'))
+<		It is shorter when using a |lambda|: >
+			call map(myDict, {key, val -> key . '-' . val})
+<		If you do not use "val" you can leave it out: >
+			call map(myDict, {key -> 'item: ' . key})
+<
+		The operation is done in-place.  If you want a |List| or
+		|Dictionary| to remain unmodified make a copy first: >
+			:let tlist = map(copy(mylist), ' v:val . "\t"')
+
+<		Returns {expr1}, the |List| or |Dictionary| that was filtered.
+		When an error is encountered while evaluating {expr2} no
+		further items in {expr1} are processed.  When {expr2} is a
+		Funcref errors inside a function are ignored, unless it was
+		defined with the "abort" flag.
+
+
+maparg({name} [, {mode} [, {abbr} [, {dict}]]])			*maparg()*
+		When {dict} is omitted or zero: Return the rhs of mapping
+		{name} in mode {mode}.  The returned String has special
+		characters translated like in the output of the ":map" command
+		listing.
+
+		When there is no mapping for {name}, an empty String is
+		returned.  When the mapping for {name} is empty, then "<Nop>"
+		is returned.
+
+		The {name} can have special key names, like in the ":map"
+		command.
+
+		{mode} can be one of these strings:
+			"n"	Normal
+			"v"	Visual (including Select)
+			"o"	Operator-pending
+			"i"	Insert
+			"c"	Cmd-line
+			"s"	Select
+			"x"	Visual
+			"l"	langmap |language-mapping|
+			"t"	Terminal-Job
+			""	Normal, Visual and Operator-pending
+		When {mode} is omitted, the modes for "" are used.
+
+		When {abbr} is there and it is |TRUE| use abbreviations
+		instead of mappings.
+
+		When {dict} is there and it is |TRUE| return a dictionary
+		containing all the information of the mapping with the
+		following items:
+		  "lhs"	     The {lhs} of the mapping.
+		  "rhs"	     The {rhs} of the mapping as typed.
+		  "silent"   1 for a |:map-silent| mapping, else 0.
+		  "noremap"  1 if the {rhs} of the mapping is not remappable.
+		  "expr"     1 for an expression mapping (|:map-<expr>|).
+		  "buffer"   1 for a buffer local mapping (|:map-local|).
+		  "mode"     Modes for which the mapping is defined. In
+			     addition to the modes mentioned above, these
+			     characters will be used:
+			     " "     Normal, Visual and Operator-pending
+			     "!"     Insert and Commandline mode
+				     (|mapmode-ic|)
+		  "sid"	     The script local ID, used for <sid> mappings
+			     (|<SID>|).
+		  "nowait"   Do not wait for other, longer mappings.
+			     (|:map-<nowait>|).
+
+		The mappings local to the current buffer are checked first,
+		then the global mappings.
+		This function can be used to map a key even when it's already
+		mapped, and have it do the original mapping too.  Sketch: >
+			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')
+
+
+mapcheck({name} [, {mode} [, {abbr}]])			*mapcheck()*
+		Check if there is a mapping that matches with {name} in mode
+		{mode}.  See |maparg()| for {mode} and special names in
+		{name}.
+		When {abbr} is there and it is |TRUE| use abbreviations
+		instead of mappings.
+		A match happens with a mapping that starts with {name} and
+		with a mapping which is equal to the start of {name}.
+
+			matches mapping "a"	"ab"	"abc" ~
+		   mapcheck("a")	yes	yes	 yes
+		   mapcheck("abc")	yes	yes	 yes
+		   mapcheck("ax")	yes	no	 no
+		   mapcheck("b")	no	no	 no
+
+		The difference with maparg() is that mapcheck() finds a
+		mapping that matches with {name}, while maparg() only finds a
+		mapping for {name} exactly.
+		When there is no mapping that starts with {name}, an empty
+		String is returned.  If there is one, the RHS of that mapping
+		is returned.  If there are several mappings that start with
+		{name}, the RHS of one of them is returned.  This will be
+		"<Nop>" if the RHS is empty.
+		The mappings local to the current buffer are checked first,
+		then the global mappings.
+		This function can be used to check if a mapping can be added
+		without being ambiguous.  Example: >
+	:if mapcheck("_vv") == ""
+	:   map _vv :set guifont=7x13<CR>
+	:endif
+<		This avoids adding the "_vv" mapping when there already is a
+		mapping for "_v" or for "_vvv".
+
+match({expr}, {pat} [, {start} [, {count}]])			*match()*
+		When {expr} is a |List| then this returns the index of the
+		first item where {pat} matches.  Each item is used as a
+		String, |Lists| and |Dictionaries| are used as echoed.
+		Otherwise, {expr} is used as a String.  The result is a
+		Number, which gives the index (byte offset) in {expr} where
+		{pat} matches.
+		A match at the first character or |List| item returns zero.
+		If there is no match -1 is returned.
+		For getting submatches see |matchlist()|.
+		Example: >
+			:echo match("testing", "ing")	" results in 4
+			:echo match([1, 'x'], '\a')	" results in 1
+<		See |string-match| for how {pat} is used.
+								*strpbrk()*
+		Vim doesn't have a strpbrk() function.  But you can do: >
+			:let sepidx = match(line, '[.,;: \t]')
+<								*strcasestr()*
+		Vim doesn't have a strcasestr() function.  But you can add
+		"\c" to the pattern to ignore case: >
+			:let idx = match(haystack, '\cneedle')
+<
+		If {start} is given, the search starts from byte index
+		{start} in a String or item {start} in a |List|.
+		The result, however, is still the index counted from the
+		first character/item.  Example: >
+			:echo match("testing", "ing", 2)
+<		result is again "4". >
+			:echo match("testing", "ing", 4)
+<		result is again "4". >
+			:echo match("testing", "t", 2)
+<		result is "3".
+		For a String, if {start} > 0 then it is like the string starts
+		{start} bytes later, thus "^" will match at {start}.  Except
+		when {count} is given, then it's like matches before the
+		{start} byte are ignored (this is a bit complicated to keep it
+		backwards compatible).
+		For a String, if {start} < 0, it will be set to 0.  For a list
+		the index is counted from the end.
+		If {start} is out of range ({start} > strlen({expr}) for a
+		String or {start} > len({expr}) for a |List|) -1 is returned.
+
+		When {count} is given use the {count}'th match.  When a match
+		is found in a String the search for the next one starts one
+		character further.  Thus this example results in 1: >
+			echo match("testing", "..", 0, 2)
+<		In a |List| the search continues in the next item.
+		Note that when {count} is added the way {start} works changes,
+		see above.
+
+		See |pattern| for the patterns that are accepted.
+		The 'ignorecase' option is used to set the ignore-caseness of
+		the pattern.  'smartcase' is NOT used.  The matching is always
+		done like 'magic' is set and 'cpoptions' is empty.
+
+				*matchadd()* *E798* *E799* *E801* *E957*
+matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
+		Defines a pattern to be highlighted in the current window (a
+		"match").  It will be highlighted with {group}.  Returns an
+		identification number (ID), which can be used to delete the
+		match using |matchdelete()|.
+		Matching is case sensitive and magic, unless case sensitivity
+		or magicness are explicitly overridden in {pattern}.  The
+		'magic', 'smartcase' and 'ignorecase' options are not used.
+		The "Conceal" value is special, it causes the match to be
+		concealed.
+
+		The optional {priority} argument assigns a priority to the
+		match.  A match with a high priority will have its
+		highlighting overrule that of a match with a lower priority.
+		A priority is specified as an integer (negative numbers are no
+		exception).  If the {priority} argument is not specified, the
+		default priority is 10.  The priority of 'hlsearch' is zero,
+		hence all matches with a priority greater than zero will
+		overrule it.  Syntax highlighting (see 'syntax') is a separate
+		mechanism, and regardless of the chosen priority a match will
+		always overrule syntax highlighting.
+
+		The optional {id} argument allows the request for a specific
+		match ID.  If a specified ID is already taken, an error
+		message will appear and the match will not be added.  An ID
+		is specified as a positive integer (zero excluded).  IDs 1, 2
+		and 3 are reserved for |:match|, |:2match| and |:3match|,
+		respectively.  If the {id} argument is not specified or -1,
+		|matchadd()| automatically chooses a free ID.
+
+		The optional {dict} argument allows for further custom
+		values. Currently this is used to specify a match specific
+		conceal character that will be shown for |hl-Conceal|
+		highlighted matches. The dict can have the following members:
+
+			conceal	    Special character to show instead of the
+				    match (only for |hl-Conceal| highlighted
+				    matches, see |:syn-cchar|)
+			window	    Instead of the current window use the
+				    window with this number or window ID.
+
+		The number of matches is not limited, as it is the case with
+		the |:match| commands.
+
+		Example: >
+			:highlight MyGroup ctermbg=green guibg=green
+			:let m = matchadd("MyGroup", "TODO")
+<		Deletion of the pattern: >
+			:call matchdelete(m)
+
+<		A list of matches defined by |matchadd()| and |:match| are
+		available from |getmatches()|.  All matches can be deleted in
+		one operation by |clearmatches()|.
+
+							*matchaddpos()*
+matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
+		Same as |matchadd()|, but requires a list of positions {pos}
+		instead of a pattern. This command is faster than |matchadd()|
+		because it does not require to handle regular expressions and
+		sets buffer line boundaries to redraw screen. It is supposed
+		to be used when fast match additions and deletions are
+		required, for example to highlight matching parentheses.
+
+		The list {pos} can contain one of these items:
+		- A number.  This whole line will be highlighted.  The first
+		  line has number 1.
+		- A list with one number, e.g., [23]. The whole line with this
+		  number will be highlighted.
+		- A list with two numbers, e.g., [23, 11]. The first number is
+		  the line number, the second one is the column number (first
+		  column is 1, the value must correspond to the byte index as
+		  |col()| would return).  The character at this position will
+		  be highlighted.
+		- A list with three numbers, e.g., [23, 11, 3]. As above, but
+		  the third number gives the length of the highlight in bytes.
+
+		The maximum number of positions is 8.
+
+		Example: >
+			:highlight MyGroup ctermbg=green guibg=green
+			:let m = matchaddpos("MyGroup", [[23, 24], 34])
+<		Deletion of the pattern: >
+			:call matchdelete(m)
+
+<		Matches added by |matchaddpos()| are returned by
+		|getmatches()| with an entry "pos1", "pos2", etc., with the
+		value a list like the {pos} item.
+
+matcharg({nr})							*matcharg()*
+		Selects the {nr} match item, as set with a |:match|,
+		|:2match| or |:3match| command.
+		Return a |List| with two elements:
+			The name of the highlight group used
+			The pattern used.
+		When {nr} is not 1, 2 or 3 returns an empty |List|.
+		When there is no match item set returns ['', ''].
+		This is useful to save and restore a |:match|.
+		Highlighting matches using the |:match| commands are limited
+		to three matches. |matchadd()| does not have this limitation.
+
+matchdelete({id})			       *matchdelete()* *E802* *E803*
+		Deletes a match with ID {id} previously defined by |matchadd()|
+		or one of the |:match| commands.  Returns 0 if successful,
+		otherwise -1.  See example for |matchadd()|.  All matches can
+		be deleted in one operation by |clearmatches()|.
+
+matchend({expr}, {pat} [, {start} [, {count}]])			*matchend()*
+		Same as |match()|, but return the index of first character
+		after the match.  Example: >
+			:echo matchend("testing", "ing")
+<		results in "7".
+							*strspn()* *strcspn()*
+		Vim doesn't have a strspn() or strcspn() function, but you can
+		do it with matchend(): >
+			:let span = matchend(line, '[a-zA-Z]')
+			:let span = matchend(line, '[^a-zA-Z]')
+<		Except that -1 is returned when there are no matches.
+
+		The {start}, if given, has the same meaning as for |match()|. >
+			:echo matchend("testing", "ing", 2)
+<		results in "7". >
+			:echo matchend("testing", "ing", 5)
+<		result is "-1".
+		When {expr} is a |List| the result is equal to |match()|.
+
+matchlist({expr}, {pat} [, {start} [, {count}]])		*matchlist()*
+		Same as |match()|, but return a |List|.  The first item in the
+		list is the matched string, same as what matchstr() would
+		return.  Following items are submatches, like "\1", "\2", etc.
+		in |:substitute|.  When an optional submatch didn't match an
+		empty string is used.  Example: >
+			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
+<		Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
+		When there is no match an empty list is returned.
+
+matchstr({expr}, {pat} [, {start} [, {count}]])			*matchstr()*
+		Same as |match()|, but return the matched string.  Example: >
+			:echo matchstr("testing", "ing")
+<		results in "ing".
+		When there is no match "" is returned.
+		The {start}, if given, has the same meaning as for |match()|. >
+			:echo matchstr("testing", "ing", 2)
+<		results in "ing". >
+			:echo matchstr("testing", "ing", 5)
+<		result is "".
+		When {expr} is a |List| then the matching item is returned.
+		The type isn't changed, it's not necessarily a String.
+
+matchstrpos({expr}, {pat} [, {start} [, {count}]])		*matchstrpos()*
+		Same as |matchstr()|, but return the matched string, the start
+		position and the end position of the match.  Example: >
+			:echo matchstrpos("testing", "ing")
+<		results in ["ing", 4, 7].
+		When there is no match ["", -1, -1] is returned.
+		The {start}, if given, has the same meaning as for |match()|. >
+			:echo matchstrpos("testing", "ing", 2)
+<		results in ["ing", 4, 7]. >
+			:echo matchstrpos("testing", "ing", 5)
+<		result is ["", -1, -1].
+		When {expr} is a |List| then the matching item, the index
+		of first item where {pat} matches, the start position and the
+		end position of the match are returned. >
+			:echo matchstrpos([1, '__x'], '\a')
+<		result is ["x", 1, 2, 3].
+		The type isn't changed, it's not necessarily a String.
+
+							*max()*
+max({expr})	Return the maximum value of all items in {expr}.
+		{expr} can be a list or a dictionary.  For a dictionary,
+		it returns the maximum of all values in the dictionary.
+		If {expr} is neither a list nor a dictionary, or one of the
+		items in {expr} cannot be used as a Number this results in
+		an error.  An empty |List| or |Dictionary| results in zero.
+
+							*min()*
+min({expr})	Return the minimum value of all items in {expr}.
+		{expr} can be a list or a dictionary.  For a dictionary,
+		it returns the minimum of all values in the dictionary.
+		If {expr} is neither a list nor a dictionary, or one of the
+		items in {expr} cannot be used as a Number this results in
+		an error.  An empty |List| or |Dictionary| results in zero.
+
+							*mkdir()* *E739*
+mkdir({name} [, {path} [, {prot}]])
+		Create directory {name}.
+		If {path} is "p" then intermediate directories are created as
+		necessary.  Otherwise it must be "".
+		If {prot} is given it is used to set the protection bits of
+		the new directory.  The default is 0755 (rwxr-xr-x: r/w for
+		the user readable for others).  Use 0700 to make it unreadable
+		for others.  This is only used for the last part of {name}.
+		Thus if you create /tmp/foo/bar then /tmp/foo will be created
+		with 0755.
+		Example: >
+			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
+<		This function is not available in the |sandbox|.
+		There is no error if the directory already exists and the "p"
+		flag is passed (since patch 8.0.1708).
+		Not available on all systems.  To check use: >
+			:if exists("*mkdir")
+<
+							*mode()*
+mode([expr])	Return a string that indicates the current mode.
+		If [expr] is supplied and it evaluates to a non-zero Number or
+		a non-empty String (|non-zero-arg|), then the full mode is
+		returned, otherwise only the first letter is returned.
+
+		   n	    Normal, Terminal-Normal
+		   no	    Operator-pending
+		   niI	    Normal using |i_CTRL-O| in |Insert-mode|
+		   niR	    Normal using |i_CTRL-O| in |Replace-mode|
+		   niV	    Normal using |i_CTRL-O| in |Virtual-Replace-mode|
+		   v	    Visual by character
+		   V	    Visual by line
+		   CTRL-V   Visual blockwise
+		   s	    Select by character
+		   S	    Select by line
+		   CTRL-S   Select blockwise
+		   i	    Insert
+		   ic	    Insert mode completion |compl-generic|
+		   ix	    Insert mode |i_CTRL-X| completion
+		   R	    Replace |R|
+		   Rc	    Replace mode completion |compl-generic|
+		   Rv	    Virtual Replace |gR|
+		   Rx	    Replace mode |i_CTRL-X| completion
+		   c	    Command-line editing
+		   cv	    Vim Ex mode |gQ|
+		   ce	    Normal Ex mode |Q|
+		   r	    Hit-enter prompt
+		   rm	    The -- more -- prompt
+		   r?	    A |:confirm| query of some sort
+		   !	    Shell or external command is executing
+		   t	    Terminal-Job mode: keys go to the job
+		This is useful in the 'statusline' option or when used
+		with |remote_expr()| In most other places it always returns
+		"c" or "n".
+		Note that in the future more modes and more specific modes may
+		be added. It's better not to compare the whole string but only
+		the leading character(s).
+		Also see |visualmode()|.
+
+mzeval({expr})							*mzeval()*
+		Evaluate MzScheme expression {expr} and return its result
+		converted to Vim data structures.
+		Numbers and strings are returned as they are.
+		Pairs (including lists and improper lists) and vectors are
+		returned as Vim |Lists|.
+		Hash tables are represented as Vim |Dictionary| type with keys
+		converted to strings.
+		All other types are converted to string with display function.
+		Examples: >
+		    :mz (define l (list 1 2 3))
+		    :mz (define h (make-hash)) (hash-set! h "list" l)
+		    :echo mzeval("l")
+		    :echo mzeval("h")
+<
+		{only available when compiled with the |+mzscheme| feature}
+
+nextnonblank({lnum})					*nextnonblank()*
+		Return the line number of the first line at or below {lnum}
+		that is not blank.  Example: >
+			if getline(nextnonblank(1)) =~ "Java"
+<		When {lnum} is invalid or there is no non-blank line at or
+		below it, zero is returned.
+		See also |prevnonblank()|.
+
+nr2char({expr} [, {utf8}])				*nr2char()*
+		Return a string with a single character, which has the number
+		value {expr}.  Examples: >
+			nr2char(64)		returns "@"
+			nr2char(32)		returns " "
+<		When {utf8} is omitted or zero, the current 'encoding' is used.
+		Example for "utf-8": >
+			nr2char(300)		returns I with bow character
+<		With {utf8} set to 1, always return utf-8 characters.
+		Note that a NUL character in the file is specified with
+		nr2char(10), because NULs are represented with newline
+		characters.  nr2char(0) is a real NUL and terminates the
+		string, thus results in an empty string.
+
+or({expr}, {expr})					*or()*
+		Bitwise OR on the two arguments.  The arguments are converted
+		to a number.  A List, Dict or Float argument causes an error.
+		Example: >
+			:let bits = or(bits, 0x80)
+
+
+pathshorten({expr})					*pathshorten()*
+		Shorten directory names in the path {expr} and return the
+		result.  The tail, the file name, is kept as-is.  The other
+		components in the path are reduced to single letters.  Leading
+		'~' and '.' characters are kept.  Example: >
+			:echo pathshorten('~/.vim/autoload/myfile.vim')
+<			~/.v/a/myfile.vim ~
+		It doesn't matter if the path exists or not.
+
+perleval({expr})					*perleval()*
+		Evaluate Perl expression {expr} in scalar context and return
+		its result converted to Vim data structures. If value can't be
+		converted, it is returned as a string Perl representation.
+		Note: If you want an array or hash, {expr} must return a
+		reference to it.
+		Example: >
+			:echo perleval('[1 .. 4]')
+<			[1, 2, 3, 4]
+		{only available when compiled with the |+perl| feature}
+
+pow({x}, {y})						*pow()*
+		Return the power of {x} to the exponent {y} as a |Float|.
+		{x} and {y} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo pow(3, 3)
+<			27.0 >
+			:echo pow(2, 16)
+<			65536.0 >
+			:echo pow(32, 0.20)
+<			2.0
+		{only available when compiled with the |+float| feature}
+
+prevnonblank({lnum})					*prevnonblank()*
+		Return the line number of the first line at or above {lnum}
+		that is not blank.  Example: >
+			let ind = indent(prevnonblank(v:lnum - 1))
+<		When {lnum} is invalid or there is no non-blank line at or
+		above it, zero is returned.
+		Also see |nextnonblank()|.
+
+
+printf({fmt}, {expr1} ...)				*printf()*
+		Return a String with {fmt}, where "%" items are replaced by
+		the formatted form of their respective arguments.  Example: >
+			printf("%4d: E%d %.30s", lnum, errno, msg)
+<		May result in:
+			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~
+
+		Often used items are:
+		  %s	string
+		  %6S	string right-aligned in 6 display cells
+		  %6s	string right-aligned in 6 bytes
+		  %.9s	string truncated to 9 bytes
+		  %c	single byte
+		  %d	decimal number
+		  %5d	decimal number padded with spaces to 5 characters
+		  %x	hex number
+		  %04x	hex number padded with zeros to at least 4 characters
+		  %X	hex number using upper case letters
+		  %o	octal number
+		  %08b	binary number padded with zeros to at least 8 chars
+		  %f	floating point number as 12.23, inf, -inf or nan
+		  %F	floating point number as 12.23, INF, -INF or NAN
+		  %e	floating point number as 1.23e3, inf, -inf or nan
+		  %E	floating point number as 1.23E3, INF, -INF or NAN
+		  %g	floating point number, as %f or %e depending on value
+		  %G	floating point number, as %F or %E depending on value
+		  %%	the % character itself
+
+		Conversion specifications start with '%' and end with the
+		conversion type.  All other characters are copied unchanged to
+		the result.
+
+		The "%" starts a conversion specification.  The following
+		arguments appear in sequence:
+
+			%  [flags]  [field-width]  [.precision]  type
+
+		flags
+			Zero or more of the following flags:
+
+		    #	      The value should be converted to an "alternate
+			      form".  For c, d, and s conversions, this option
+			      has no effect.  For o conversions, the precision
+			      of the number is increased to force the first
+			      character of the output string to a zero (except
+			      if a zero value is printed with an explicit
+			      precision of zero).
+			      For b and B conversions, a non-zero result has
+			      the string "0b" (or "0B" for B conversions)
+			      prepended to it.
+			      For x and X conversions, a non-zero result has
+			      the string "0x" (or "0X" for X conversions)
+			      prepended to it.
+
+		    0 (zero)  Zero padding.  For all conversions the converted
+			      value is padded on the left with zeros rather
+			      than blanks.  If a precision is given with a
+			      numeric conversion (d, b, B, o, x, and X), the 0
+			      flag is ignored.
+
+		    -	      A negative field width flag; the converted value
+			      is to be left adjusted on the field boundary.
+			      The converted value is padded on the right with
+			      blanks, rather than on the left with blanks or
+			      zeros.  A - overrides a 0 if both are given.
+
+		    ' ' (space)  A blank should be left before a positive
+			      number produced by a signed conversion (d).
+
+		    +	      A sign must always be placed before a number
+			      produced by a signed conversion.  A + overrides
+			      a space if both are used.
+
+		field-width
+			An optional decimal digit string specifying a minimum
+			field width.  If the converted value has fewer bytes
+			than the field width, it will be padded with spaces on
+			the left (or right, if the left-adjustment flag has
+			been given) to fill out the field width.
+
+		.precision
+			An optional precision, in the form of a period '.'
+			followed by an optional digit string.  If the digit
+			string is omitted, the precision is taken as zero.
+			This gives the minimum number of digits to appear for
+			d, o, x, and X conversions, or the maximum number of
+			bytes to be printed from a string for s conversions.
+			For floating point it is the number of digits after
+			the decimal point.
+
+		type
+			A character that specifies the type of conversion to
+			be applied, see below.
+
+		A field width or precision, or both, may be indicated by an
+		asterisk '*' instead of a digit string.  In this case, a
+		Number argument supplies the field width or precision.  A
+		negative field width is treated as a left adjustment flag
+		followed by a positive field width; a negative precision is
+		treated as though it were missing.  Example: >
+			:echo printf("%d: %.*s", nr, width, line)
+<		This limits the length of the text used from "line" to
+		"width" bytes.
+
+		The conversion specifiers and their meanings are:
+
+				*printf-d* *printf-b* *printf-B* *printf-o*
+				*printf-x* *printf-X*
+		dbBoxX	The Number argument is converted to signed decimal
+			(d), unsigned binary (b and B), unsigned octal (o), or
+			unsigned hexadecimal (x and X) notation.  The letters
+			"abcdef" are used for x conversions; the letters
+			"ABCDEF" are used for X conversions.
+			The precision, if any, gives the minimum number of
+			digits that must appear; if the converted value
+			requires fewer digits, it is padded on the left with
+			zeros.
+			In no case does a non-existent or small field width
+			cause truncation of a numeric field; if the result of
+			a conversion is wider than the field width, the field
+			is expanded to contain the conversion result.
+			The 'h' modifier indicates the argument is 16 bits.
+			The 'l' modifier indicates the argument is 32 bits.
+			The 'L' modifier indicates the argument is 64 bits.
+			Generally, these modifiers are not useful. They are
+			ignored when type is known from the argument.
+
+		i	alias for d
+		D	alias for ld
+		U	alias for lu
+		O	alias for lo
+
+							*printf-c*
+		c	The Number argument is converted to a byte, and the
+			resulting character is written.
+
+							*printf-s*
+		s	The text of the String argument is used.  If a
+			precision is specified, no more bytes than the number
+			specified are used.
+			If the argument is not a String type, it is
+			automatically converted to text with the same format
+			as ":echo".
+							*printf-S*
+		S	The text of the String argument is used.  If a
+			precision is specified, no more display cells than the
+			number specified are used.  Without the |+multi_byte|
+			feature works just like 's'.
+
+							*printf-f* *E807*
+		f F	The Float argument is converted into a string of the
+			form 123.456.  The precision specifies the number of
+			digits after the decimal point.  When the precision is
+			zero the decimal point is omitted.  When the precision
+			is not specified 6 is used.  A really big number
+			(out of range or dividing by zero) results in "inf"
+			or "-inf" with %f (INF or -INF with %F).
+			"0.0 / 0.0" results in "nan" with %f (NAN with %F).
+			Example: >
+				echo printf("%.2f", 12.115)
+<				12.12
+			Note that roundoff depends on the system libraries.
+			Use |round()| when in doubt.
+
+							*printf-e* *printf-E*
+		e E	The Float argument is converted into a string of the
+			form 1.234e+03 or 1.234E+03 when using 'E'.  The
+			precision specifies the number of digits after the
+			decimal point, like with 'f'.
+
+							*printf-g* *printf-G*
+		g G	The Float argument is converted like with 'f' if the
+			value is between 0.001 (inclusive) and 10000000.0
+			(exclusive).  Otherwise 'e' is used for 'g' and 'E'
+			for 'G'.  When no precision is specified superfluous
+			zeroes and '+' signs are removed, except for the zero
+			immediately after the decimal point.  Thus 10000000.0
+			results in 1.0e7.
+
+							*printf-%*
+		%	A '%' is written.  No argument is converted.  The
+			complete conversion specification is "%%".
+
+		When a Number argument is expected a String argument is also
+		accepted and automatically converted.
+		When a Float or String argument is expected a Number argument
+		is also accepted and automatically converted.
+		Any other argument type results in an error message.
+
+							*E766* *E767*
+		The number of {exprN} arguments must exactly match the number
+		of "%" items.  If there are not sufficient or too many
+		arguments an error is given.  Up to 18 arguments can be used.
+
+
+prompt_setcallback({buf}, {expr})			*prompt_setcallback()*
+		Set prompt callback for buffer {buf} to {expr}.  When {expr}
+		is an empty string the callback is removed.  This has only
+		effect if {buf} has 'buftype' set to "prompt".
+
+		The callback is invoked when pressing Enter.  The current
+		buffer will always be the prompt buffer.  A new line for a
+		prompt is added before invoking the callback, thus the prompt
+		for which the callback was invoked will be in the last but one
+		line.
+		If the callback wants to add text to the buffer, it must
+		insert it above the last line, since that is where the current
+		prompt is.  This can also be done asynchronously.
+		The callback is invoked with one argument, which is the text
+		that was entered at the prompt.  This can be an empty string
+		if the user only typed Enter.
+		Example: >
+		   call prompt_setcallback(bufnr(''), function('s:TextEntered'))
+		   func s:TextEntered(text)
+		     if a:text == 'exit' || a:text == 'quit'
+		       stopinsert
+		       close
+		     else
+		       call append(line('$') - 1, 'Entered: "' . a:text . '"')
+		       " Reset 'modified' to allow the buffer to be closed.
+		       set nomodified
+		     endif
+		   endfunc
+
+prompt_setinterrupt({buf}, {expr})			*prompt_setinterrupt()*
+		Set a callback for buffer {buf} to {expr}.  When {expr} is an
+		empty string the callback is removed.  This has only effect if
+		{buf} has 'buftype' set to "prompt".
+
+		This callback will be invoked when pressing CTRL-C in Insert
+		mode.  Without setting a callback Vim will exit Insert mode,
+		as in any buffer.
+
+prompt_setprompt({buf}, {text})				*prompt_setprompt()*
+		Set prompt for buffer {buf} to {text}.  You most likely want
+		{text} to end in a space.
+		The result is only visible if {buf} has 'buftype' set to
+		"prompt".  Example: >
+			call prompt_setprompt(bufnr(''), 'command: ')
+
+
+pumvisible()						*pumvisible()*
+		Returns non-zero when the popup menu is visible, zero
+		otherwise.  See |ins-completion-menu|.
+		This can be used to avoid some things that would remove the
+		popup menu.
+
+py3eval({expr})						*py3eval()*
+		Evaluate Python expression {expr} and return its result
+		converted to Vim data structures.
+		Numbers and strings are returned as they are (strings are
+		copied though, Unicode strings are additionally converted to
+		'encoding').
+		Lists are represented as Vim |List| type.
+		Dictionaries are represented as Vim |Dictionary| type with
+		keys converted to strings.
+		{only available when compiled with the |+python3| feature}
+
+							*E858* *E859*
+pyeval({expr})						*pyeval()*
+		Evaluate Python expression {expr} and return its result
+		converted to Vim data structures.
+		Numbers and strings are returned as they are (strings are
+		copied though).
+		Lists are represented as Vim |List| type.
+		Dictionaries are represented as Vim |Dictionary| type,
+		non-string keys result in error.
+		{only available when compiled with the |+python| feature}
+
+pyxeval({expr})						*pyxeval()*
+		Evaluate Python expression {expr} and return its result
+		converted to Vim data structures.
+		Uses Python 2 or 3, see |python_x| and 'pyxversion'.
+		See also: |pyeval()|, |py3eval()|
+		{only available when compiled with the |+python| or the
+		|+python3| feature}
+
+							*E726* *E727*
+range({expr} [, {max} [, {stride}]])				*range()*
+		Returns a |List| with Numbers:
+		- If only {expr} is specified: [0, 1, ..., {expr} - 1]
+		- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
+		- If {stride} is specified: [{expr}, {expr} + {stride}, ...,
+		  {max}] (increasing {expr} with {stride} each time, not
+		  producing a value past {max}).
+		When the maximum is one before the start the result is an
+		empty list.  When the maximum is more than one before the
+		start this is an error.
+		Examples: >
+			range(4)		" [0, 1, 2, 3]
+			range(2, 4)		" [2, 3, 4]
+			range(2, 9, 3)		" [2, 5, 8]
+			range(2, -2, -1)	" [2, 1, 0, -1, -2]
+			range(0)		" []
+			range(2, 0)		" error!
+<
+							*readfile()*
+readfile({fname} [, {binary} [, {max}]])
+		Read file {fname} and return a |List|, each line of the file
+		as an item.  Lines are broken at NL characters.  Macintosh
+		files separated with CR will result in a single long line
+		(unless a NL appears somewhere).
+		All NUL characters are replaced with a NL character.
+		When {binary} contains "b" binary mode is used:
+		- When the last line ends in a NL an extra empty list item is
+		  added.
+		- No CR characters are removed.
+		Otherwise:
+		- CR characters that appear before a NL are removed.
+		- Whether the last line ends in a NL or not does not matter.
+		- When 'encoding' is Unicode any UTF-8 byte order mark is
+		  removed from the text.
+		When {max} is given this specifies the maximum number of lines
+		to be read.  Useful if you only want to check the first ten
+		lines of a file: >
+			:for line in readfile(fname, '', 10)
+			:  if line =~ 'Date' | echo line | endif
+			:endfor
+<		When {max} is negative -{max} lines from the end of the file
+		are returned, or as many as there are.
+		When {max} is zero the result is an empty list.
+		Note that without {max} the whole file is read into memory.
+		Also note that there is no recognition of encoding.  Read a
+		file into a buffer if you need to.
+		When the file can't be opened an error message is given and
+		the result is an empty list.
+		Also see |writefile()|.
+
+reg_executing()						*reg_executing()*
+		Returns the single letter name of the register being executed.
+		Returns an empty string when no register is being executed.
+		See |@|.
+
+reg_recording()						*reg_recording()*
+		Returns the single letter name of the register being recorded.
+		Returns an empty string string when not recording.  See |q|.
+
+reltime([{start} [, {end}]])				*reltime()*
+		Return an item that represents a time value.  The format of
+		the item depends on the system.  It can be passed to
+		|reltimestr()| to convert it to a string  or |reltimefloat()|
+		to convert to a Float.
+		Without an argument it returns the current time.
+		With one argument is returns the time passed since the time
+		specified in the argument.
+		With two arguments it returns the time passed between {start}
+		and {end}.
+		The {start} and {end} arguments must be values returned by
+		reltime().
+		{only available when compiled with the |+reltime| feature}
+
+reltimefloat({time})				*reltimefloat()*
+		Return a Float that represents the time value of {time}.
+		Example: >
+			let start = reltime()
+			call MyFunction()
+			let seconds = reltimefloat(reltime(start))
+<		See the note of reltimestr() about overhead.
+		Also see |profiling|.
+		{only available when compiled with the |+reltime| feature}
+
+reltimestr({time})				*reltimestr()*
+		Return a String that represents the time value of {time}.
+		This is the number of seconds, a dot and the number of
+		microseconds.  Example: >
+			let start = reltime()
+			call MyFunction()
+			echo reltimestr(reltime(start))
+<		Note that overhead for the commands will be added to the time.
+		The accuracy depends on the system.
+		Leading spaces are used to make the string align nicely.  You
+		can use split() to remove it. >
+			echo split(reltimestr(reltime(start)))[0]
+<		Also see |profiling|.
+		{only available when compiled with the |+reltime| feature}
+
+							*remote_expr()* *E449*
+remote_expr({server}, {string} [, {idvar} [, {timeout}]])
+		Send the {string} to {server}.  The string is sent as an
+		expression and the result is returned after evaluation.
+		The result must be a String or a |List|.  A |List| is turned
+		into a String by joining the items with a line break in
+		between (not at the end), like with join(expr, "\n").
+		If {idvar} is present and not empty, it is taken as the name
+		of a variable and a {serverid} for later use with
+		|remote_read()| is stored there.
+		If {timeout} is given the read times out after this many
+		seconds.  Otherwise a timeout of 600 seconds is used.
+		See also |clientserver| |RemoteReply|.
+		This function is not available in the |sandbox|.
+		{only available when compiled with the |+clientserver| feature}
+		Note: Any errors will cause a local error message to be issued
+		and the result will be the empty string.
+
+		Variables will be evaluated in the global namespace,
+		independent of a function currently being active.  Except
+		when in debug mode, then local function variables and
+		arguments can be evaluated.
+
+		Examples: >
+			:echo remote_expr("gvim", "2+2")
+			:echo remote_expr("gvim1", "b:current_syntax")
+<
+
+remote_foreground({server})				*remote_foreground()*
+		Move the Vim server with the name {server} to the foreground.
+		This works like: >
+			remote_expr({server}, "foreground()")
+<		Except that on Win32 systems the client does the work, to work
+		around the problem that the OS doesn't always allow the server
+		to bring itself to the foreground.
+		Note: This does not restore the window if it was minimized,
+		like foreground() does.
+		This function is not available in the |sandbox|.
+		{only in the Win32, Athena, Motif and GTK GUI versions and the
+		Win32 console version}
+
+
+remote_peek({serverid} [, {retvar}])		*remote_peek()*
+		Returns a positive number if there are available strings
+		from {serverid}.  Copies any reply string into the variable
+		{retvar} if specified.  {retvar} must be a string with the
+		name of a variable.
+		Returns zero if none are available.
+		Returns -1 if something is wrong.
+		See also |clientserver|.
+		This function is not available in the |sandbox|.
+		{only available when compiled with the |+clientserver| feature}
+		Examples: >
+			:let repl = ""
+			:echo "PEEK: ".remote_peek(id, "repl").": ".repl
+
+remote_read({serverid}, [{timeout}])			*remote_read()*
+		Return the oldest available reply from {serverid} and consume
+		it.  Unless a {timeout} in seconds is given, it blocks until a
+		reply is available.
+		See also |clientserver|.
+		This function is not available in the |sandbox|.
+		{only available when compiled with the |+clientserver| feature}
+		Example: >
+			:echo remote_read(id)
+<
+							*remote_send()* *E241*
+remote_send({server}, {string} [, {idvar}])
+		Send the {string} to {server}.  The string is sent as input
+		keys and the function returns immediately.  At the Vim server
+		the keys are not mapped |:map|.
+		If {idvar} is present, it is taken as the name of a variable
+		and a {serverid} for later use with remote_read() is stored
+		there.
+		See also |clientserver| |RemoteReply|.
+		This function is not available in the |sandbox|.
+		{only available when compiled with the |+clientserver| feature}
+
+		Note: Any errors will be reported in the server and may mess
+		up the display.
+		Examples: >
+		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
+		 \ remote_read(serverid)
+
+		:autocmd NONE RemoteReply *
+		 \ echo remote_read(expand("<amatch>"))
+		:echo remote_send("gvim", ":sleep 10 | echo ".
+		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
+<
+					*remote_startserver()* *E941* *E942*
+remote_startserver({name})
+		Become the server {name}.  This fails if already running as a
+		server, when |v:servername| is not empty.
+		{only available when compiled with the |+clientserver| feature}
+
+remove({list}, {idx} [, {end}])				*remove()*
+		Without {end}: Remove the item at {idx} from |List| {list} and
+		return the item.
+		With {end}: Remove items from {idx} to {end} (inclusive) and
+		return a List with these items.  When {idx} points to the same
+		item as {end} a list with one item is returned.  When {end}
+		points to an item before {idx} this is an error.
+		See |list-index| for possible values of {idx} and {end}.
+		Example: >
+			:echo "last item: " . remove(mylist, -1)
+			:call remove(mylist, 0, 9)
+remove({dict}, {key})
+		Remove the entry from {dict} with key {key}.  Example: >
+			:echo "removed " . remove(dict, "one")
+<		If there is no {key} in {dict} this is an error.
+
+		Use |delete()| to remove a file.
+
+rename({from}, {to})					*rename()*
+		Rename the file by the name {from} to the name {to}.  This
+		should also work to move files across file systems.  The
+		result is a Number, which is 0 if the file was renamed
+		successfully, and non-zero when the renaming failed.
+		NOTE: If {to} exists it is overwritten without warning.
+		This function is not available in the |sandbox|.
+
+repeat({expr}, {count})					*repeat()*
+		Repeat {expr} {count} times and return the concatenated
+		result.  Example: >
+			:let separator = repeat('-', 80)
+<		When {count} is zero or negative the result is empty.
+		When {expr} is a |List| the result is {expr} concatenated
+		{count} times.  Example: >
+			:let longlist = repeat(['a', 'b'], 3)
+<		Results in ['a', 'b', 'a', 'b', 'a', 'b'].
+
+
+resolve({filename})					*resolve()* *E655*
+		On MS-Windows, when {filename} is a shortcut (a .lnk file),
+		returns the path the shortcut points to in a simplified form.
+		On Unix, repeat resolving symbolic links in all path
+		components of {filename} and return the simplified result.
+		To cope with link cycles, resolving of symbolic links is
+		stopped after 100 iterations.
+		On other systems, return the simplified {filename}.
+		The simplification step is done as by |simplify()|.
+		resolve() keeps a leading path component specifying the
+		current directory (provided the result is still a relative
+		path name) and also keeps a trailing path separator.
+
+							*reverse()*
+reverse({list})	Reverse the order of items in {list} in-place.  Returns
+		{list}.
+		If you want a list to remain unmodified make a copy first: >
+			:let revlist = reverse(copy(mylist))
+
+round({expr})							*round()*
+		Round off {expr} to the nearest integral value and return it
+		as a |Float|.  If {expr} lies halfway between two integral
+		values, then use the larger one (away from zero).
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			echo round(0.456)
+<			0.0  >
+			echo round(4.5)
+<			5.0 >
+			echo round(-4.5)
+<			-5.0
+		{only available when compiled with the |+float| feature}
+
+screenattr({row}, {col})					*screenattr()*
+		Like |screenchar()|, but return the attribute.  This is a rather
+		arbitrary number that can only be used to compare to the
+		attribute at other positions.
+
+screenchar({row}, {col})					*screenchar()*
+		The result is a Number, which is the character at position
+		[row, col] on the screen.  This works for every possible
+		screen position, also status lines, window separators and the
+		command line.  The top left position is row one, column one
+		The character excludes composing characters.  For double-byte
+		encodings it may only be the first byte.
+		This is mainly to be used for testing.
+		Returns -1 when row or col is out of range.
+
+screencol()							*screencol()*
+		The result is a Number, which is the current screen column of
+		the cursor. The leftmost column has number 1.
+		This function is mainly used for testing.
+
+		Note: Always returns the current screen column, thus if used
+		in a command (e.g. ":echo screencol()") it will return the
+		column inside the command line, which is 1 when the command is
+		executed. To get the cursor position in the file use one of
+		the following mappings: >
+			nnoremap <expr> GG ":echom ".screencol()."\n"
+			nnoremap <silent> GG :echom screencol()<CR>
+<
+screenrow()							*screenrow()*
+		The result is a Number, which is the current screen row of the
+		cursor.  The top line has number one.
+		This function is mainly used for testing.
+		Alternatively you can use |winline()|.
+
+		Note: Same restrictions as with |screencol()|.
+
+search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
+		Search for regexp pattern {pattern}.  The search starts at the
+		cursor position (you can use |cursor()| to set it).
+
+		When a match has been found its line number is returned.
+		If there is no match a 0 is returned and the cursor doesn't
+		move.  No error message is given.
+
+		{flags} is a String, which can contain these character flags:
+		'b'	search Backward instead of forward
+		'c'	accept a match at the Cursor position
+		'e'	move to the End of the match
+		'n'	do Not move the cursor
+		'p'	return number of matching sub-Pattern (see below)
+		's'	Set the ' mark at the previous location of the cursor
+		'w'	Wrap around the end of the file
+		'W'	don't Wrap around the end of the file
+		'z'	start searching at the cursor column instead of zero
+		If neither 'w' or 'W' is given, the 'wrapscan' option applies.
+
+		If the 's' flag is supplied, the ' mark is set, only if the
+		cursor is moved. The 's' flag cannot be combined with the 'n'
+		flag.
+
+		'ignorecase', 'smartcase' and 'magic' are used.
+
+		When the 'z' flag is not given, searching always starts in
+		column zero and then matches before the cursor are skipped.
+		When the 'c' flag is present in 'cpo' the next search starts
+		after the match.  Without the 'c' flag the next search starts
+		one column further.
+
+		When the {stopline} argument is given then the search stops
+		after searching this line.  This is useful to restrict the
+		search to a range of lines.  Examples: >
+			let match = search('(', 'b', line("w0"))
+			let end = search('END', '', line("w$"))
+<		When {stopline} is used and it is not zero this also implies
+		that the search does not wrap around the end of the file.
+		A zero value is equal to not giving the argument.
+
+		When the {timeout} argument is given the search stops when
+		more than this many milliseconds have passed.  Thus when
+		{timeout} is 500 the search stops after half a second.
+		The value must not be negative.  A zero value is like not
+		giving the argument.
+		{only available when compiled with the |+reltime| feature}
+
+							*search()-sub-match*
+		With the 'p' flag the returned value is one more than the
+		first sub-match in \(\).  One if none of them matched but the
+		whole pattern did match.
+		To get the column number too use |searchpos()|.
+
+		The cursor will be positioned at the match, unless the 'n'
+		flag is used.
+
+		Example (goes over all files in the argument list): >
+		    :let n = 1
+		    :while n <= argc()	    " loop over all files in arglist
+		    :  exe "argument " . n
+		    :  " start at the last char in the file and wrap for the
+		    :  " first search to find match at start of file
+		    :  normal G$
+		    :  let flags = "w"
+		    :  while search("foo", flags) > 0
+		    :	 s/foo/bar/g
+		    :	 let flags = "W"
+		    :  endwhile
+		    :  update		    " write the file if modified
+		    :  let n = n + 1
+		    :endwhile
+<
+		Example for using some flags: >
+		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
+<		This will search for the keywords "if", "else", and "endif"
+		under or after the cursor.  Because of the 'p' flag, it
+		returns 1, 2, or 3 depending on which keyword is found, or 0
+		if the search fails.  With the cursor on the first word of the
+		line:
+		    if (foo == 0) | let foo = foo + 1 | endif ~
+		the function returns 1.  Without the 'c' flag, the function
+		finds the "endif" and returns 3.  The same thing happens
+		without the 'e' flag if the cursor is on the "f" of "if".
+		The 'n' flag tells the function not to move the cursor.
+
+
+searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
+		Search for the declaration of {name}.
+
+		With a non-zero {global} argument it works like |gD|, find
+		first match in the file.  Otherwise it works like |gd|, find
+		first match in the function.
+
+		With a non-zero {thisblock} argument matches in a {} block
+		that ends before the cursor position are ignored.  Avoids
+		finding variable declarations only valid in another scope.
+
+		Moves the cursor to the found match.
+		Returns zero for success, non-zero for failure.
+		Example: >
+			if searchdecl('myvar') == 0
+			   echo getline('.')
+			endif
+<
+							*searchpair()*
+searchpair({start}, {middle}, {end} [, {flags} [, {skip}
+				[, {stopline} [, {timeout}]]]])
+		Search for the match of a nested start-end pair.  This can be
+		used to find the "endif" that matches an "if", while other
+		if/endif pairs in between are ignored.
+		The search starts at the cursor.  The default is to search
+		forward, include 'b' in {flags} to search backward.
+		If a match is found, the cursor is positioned at it and the
+		line number is returned.  If no match is found 0 or -1 is
+		returned and the cursor doesn't move.  No error message is
+		given.
+
+		{start}, {middle} and {end} are patterns, see |pattern|.  They
+		must not contain \( \) pairs.  Use of \%( \) is allowed.  When
+		{middle} is not empty, it is found when searching from either
+		direction, but only when not in a nested start-end pair.  A
+		typical use is: >
+			searchpair('\<if\>', '\<else\>', '\<endif\>')
+<		By leaving {middle} empty the "else" is skipped.
+
+		{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
+		|search()|.  Additionally:
+		'r'	Repeat until no more matches found; will find the
+			outer pair.  Implies the 'W' flag.
+		'm'	Return number of matches instead of line number with
+			the match; will be > 1 when 'r' is used.
+		Note: it's nearly always a good idea to use the 'W' flag, to
+		avoid wrapping around the end of the file.
+
+		When a match for {start}, {middle} or {end} is found, the
+		{skip} expression is evaluated with the cursor positioned on
+		the start of the match.  It should return non-zero if this
+		match is to be skipped.  E.g., because it is inside a comment
+		or a string.
+		When {skip} is omitted or empty, every match is accepted.
+		When evaluating {skip} causes an error the search is aborted
+		and -1 returned.
+		{skip} can be a string, a lambda, a funcref or a partial.
+		Anything else makes the function fail.
+
+		For {stopline} and {timeout} see |search()|.
+
+		The value of 'ignorecase' is used.  'magic' is ignored, the
+		patterns are used like it's on.
+
+		The search starts exactly at the cursor.  A match with
+		{start}, {middle} or {end} at the next character, in the
+		direction of searching, is the first one found.  Example: >
+			if 1
+			  if 2
+			  endif 2
+			endif 1
+<		When starting at the "if 2", with the cursor on the "i", and
+		searching forwards, the "endif 2" is found.  When starting on
+		the character just before the "if 2", the "endif 1" will be
+		found.  That's because the "if 2" will be found first, and
+		then this is considered to be a nested if/endif from "if 2" to
+		"endif 2".
+		When searching backwards and {end} is more than one character,
+		it may be useful to put "\zs" at the end of the pattern, so
+		that when the cursor is inside a match with the end it finds
+		the matching start.
+
+		Example, to find the "endif" command in a Vim script: >
+
+	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
+			\ 'getline(".") =~ "^\\s*\""')
+
+<		The cursor must be at or after the "if" for which a match is
+		to be found.  Note that single-quote strings are used to avoid
+		having to double the backslashes.  The skip expression only
+		catches comments at the start of a line, not after a command.
+		Also, a word "en" or "if" halfway a line is considered a
+		match.
+		Another example, to search for the matching "{" of a "}": >
+
+	:echo searchpair('{', '', '}', 'bW')
+
+<		This works when the cursor is at or before the "}" for which a
+		match is to be found.  To reject matches that syntax
+		highlighting recognized as strings: >
+
+	:echo searchpair('{', '', '}', 'bW',
+	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
+<
+							*searchpairpos()*
+searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
+				[, {stopline} [, {timeout}]]]])
+		Same as |searchpair()|, but returns a |List| with the line and
+		column position of the match. The first element of the |List|
+		is the line number and the second element is the byte index of
+		the column position of the match.  If no match is found,
+		returns [0, 0]. >
+
+			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
+<
+		See |match-parens| for a bigger and more useful example.
+
+searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
+		Same as |search()|, but returns a |List| with the line and
+		column position of the match. The first element of the |List|
+		is the line number and the second element is the byte index of
+		the column position of the match. If no match is found,
+		returns [0, 0].
+		Example: >
+	:let [lnum, col] = searchpos('mypattern', 'n')
+
+<		When the 'p' flag is given then there is an extra item with
+		the sub-pattern match number |search()-sub-match|.  Example: >
+	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
+<		In this example "submatch" is 2 when a lowercase letter is
+		found |/\l|, 3 when an uppercase letter is found |/\u|.
+
+server2client({clientid}, {string})			*server2client()*
+		Send a reply string to {clientid}.  The most recent {clientid}
+		that sent a string can be retrieved with expand("<client>").
+		{only available when compiled with the |+clientserver| feature}
+		Note:
+		This id has to be stored before the next command can be
+		received.  I.e. before returning from the received command and
+		before calling any commands that waits for input.
+		See also |clientserver|.
+		Example: >
+			:echo server2client(expand("<client>"), "HELLO")
+<
+serverlist()					*serverlist()*
+		Return a list of available server names, one per line.
+		When there are no servers or the information is not available
+		an empty string is returned.  See also |clientserver|.
+		{only available when compiled with the |+clientserver| feature}
+		Example: >
+			:echo serverlist()
+<
+setbufline({expr}, {lnum}, {text})			*setbufline()*
+		Set line {lnum} to {text} in buffer {expr}.  To insert
+		lines use |append()|.
+
+		For the use of {expr}, see |bufname()| above.
+
+		{lnum} is used like with |setline()|.
+		This works like |setline()| for the specified buffer.
+		On success 0 is returned, on failure 1 is returned.
+
+		If {expr} is not a valid buffer or {lnum} is not valid, an
+		error message is given.
+
+setbufvar({expr}, {varname}, {val})			*setbufvar()*
+		Set option or local variable {varname} in buffer {expr} to
+		{val}.
+		This also works for a global or local window option, but it
+		doesn't work for a global or local window variable.
+		For a local window option the global value is unchanged.
+		For the use of {expr}, see |bufname()| above.
+		Note that the variable name without "b:" must be used.
+		Examples: >
+			:call setbufvar(1, "&mod", 1)
+			:call setbufvar("todo", "myvar", "foobar")
+<		This function is not available in the |sandbox|.
+
+setcharsearch({dict})					*setcharsearch()*
+		Set the current character search information to {dict},
+		which contains one or more of the following entries:
+
+		    char	character which will be used for a subsequent
+				|,| or |;| command; an empty string clears the
+				character search
+		    forward	direction of character search; 1 for forward,
+				0 for backward
+		    until	type of character search; 1 for a |t| or |T|
+				character search, 0 for an |f| or |F|
+				character search
+
+		This can be useful to save/restore a user's character search
+		from a script: >
+			:let prevsearch = getcharsearch()
+			:" Perform a command which clobbers user's search
+			:call setcharsearch(prevsearch)
+<		Also see |getcharsearch()|.
+
+setcmdpos({pos})					*setcmdpos()*
+		Set the cursor position in the command line to byte position
+		{pos}.  The first position is 1.
+		Use |getcmdpos()| to obtain the current position.
+		Only works while editing the command line, thus you must use
+		|c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
+		|c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
+		set after the command line is set to the expression.  For
+		|c_CTRL-R_=| it is set after evaluating the expression but
+		before inserting the resulting text.
+		When the number is too big the cursor is put at the end of the
+		line.  A number smaller than one has undefined results.
+		Returns 0 when successful, 1 when not editing the command
+		line.
+
+setfperm({fname}, {mode})				*setfperm()* *chmod*
+		Set the file permissions for {fname} to {mode}.
+		{mode} must be a string with 9 characters.  It is of the form
+		"rwxrwxrwx", where each group of "rwx" flags represent, in
+		turn, the permissions of the owner of the file, the group the
+		file belongs to, and other users.  A '-' character means the
+		permission is off, any other character means on.  Multi-byte
+		characters are not supported.
+
+		For example "rw-r-----" means read-write for the user,
+		readable by the group, not accessible by others.  "xx-x-----"
+		would do the same thing.
+
+		Returns non-zero for success, zero for failure.
+
+		To read permissions see |getfperm()|.
+
+
+setline({lnum}, {text})					*setline()*
+		Set line {lnum} of the current buffer to {text}.  To insert
+		lines use |append()|. To set lines in another buffer use
+		|setbufline()|.
+
+		{lnum} is used like with |getline()|.
+		When {lnum} is just below the last line the {text} will be
+		added as a new line.
+
+		If this succeeds, 0 is returned.  If this fails (most likely
+		because {lnum} is invalid) 1 is returned.
+
+		Example: >
+			:call setline(5, strftime("%c"))
+
+<		When {text} is a |List| then line {lnum} and following lines
+		will be set to the items in the list.  Example: >
+			:call setline(5, ['aaa', 'bbb', 'ccc'])
+<		This is equivalent to: >
+			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
+			:  call setline(n, l)
+			:endfor
+
+<		Note: The '[ and '] marks are not set.
+
+setloclist({nr}, {list} [, {action} [, {what}]])		*setloclist()*
+		Create or replace or add to the location list for window {nr}.
+		{nr} can be the window number or the |window-ID|.
+		When {nr} is zero the current window is used.
+
+		For a location list window, the displayed location list is
+		modified.  For an invalid window number {nr}, -1 is returned.
+		Otherwise, same as |setqflist()|.
+		Also see |location-list|.
+
+		If the optional {what} dictionary argument is supplied, then
+		only the items listed in {what} are set. Refer to |setqflist()|
+		for the list of supported keys in {what}.
+
+setmatches({list})					*setmatches()*
+		Restores a list of matches saved by |getmatches()|.  Returns 0
+		if successful, otherwise -1.  All current matches are cleared
+		before the list is restored.  See example for |getmatches()|.
+
+							*setpos()*
+setpos({expr}, {list})
+		Set the position for {expr}.  Possible values:
+			.	the cursor
+			'x	mark x
+
+		{list} must be a |List| with four or five numbers:
+		    [bufnum, lnum, col, off]
+		    [bufnum, lnum, col, off, curswant]
+
+		"bufnum" is the buffer number.  Zero can be used for the
+		current buffer.  When setting an uppercase mark "bufnum" is
+		used for the mark position.  For other marks it specifies the
+		buffer to set the mark in.  You can use the |bufnr()| function
+		to turn a file name into a buffer number.
+		For setting the cursor and the ' mark "bufnum" is ignored,
+		since these are associated with a window, not a buffer.
+		Does not change the jumplist.
+
+		"lnum" and "col" are the position in the buffer.  The first
+		column is 1.  Use a zero "lnum" to delete a mark.  If "col" is
+		smaller than 1 then 1 is used.
+
+		The "off" number is only used when 'virtualedit' is set. Then
+		it is the offset in screen columns from the start of the
+		character.  E.g., a position within a <Tab> or after the last
+		character.
+
+		The "curswant" number is only used when setting the cursor
+		position.  It sets the preferred column for when moving the
+		cursor vertically.  When the "curswant" number is missing the
+		preferred column is not set.  When it is present and setting a
+		mark position it is not used.
+
+		Note that for '< and '> changing the line number may result in
+		the marks to be effectively be swapped, so that '< is always
+		before '>.
+
+		Returns 0 when the position could be set, -1 otherwise.
+		An error message is given if {expr} is invalid.
+
+		Also see |getpos()| and |getcurpos()|.
+
+		This does not restore the preferred column for moving
+		vertically; if you set the cursor position with this, |j| and
+		|k| motions will jump to previous columns!  Use |cursor()| to
+		also set the preferred column.  Also see the "curswant" key in
+		|winrestview()|.
+
+setqflist({list} [, {action} [, {what}]])		*setqflist()*
+		Create or replace or add to the quickfix list.
+
+		When {what} is not present, use the items in {list}.  Each
+		item must be a dictionary.  Non-dictionary items in {list} are
+		ignored.  Each dictionary item can contain the following
+		entries:
+
+		    bufnr	buffer number; must be the number of a valid
+				buffer
+		    filename	name of a file; only used when "bufnr" is not
+				present or it is invalid.
+		    module	name of a module; if given it will be used in
+				quickfix error window instead of the filename.
+		    lnum	line number in the file
+		    pattern	search pattern used to locate the error
+		    col		column number
+		    vcol	when non-zero: "col" is visual column
+				when zero: "col" is byte index
+		    nr		error number
+		    text	description of the error
+		    type	single-character error type, 'E', 'W', etc.
+		    valid	recognized error message
+
+		The "col", "vcol", "nr", "type" and "text" entries are
+		optional.  Either "lnum" or "pattern" entry can be used to
+		locate a matching error line.
+		If the "filename" and "bufnr" entries are not present or
+		neither the "lnum" or "pattern" entries are present, then the
+		item will not be handled as an error line.
+		If both "pattern" and "lnum" are present then "pattern" will
+		be used.
+		If the "valid" entry is not supplied, then the valid flag is
+		set when "bufnr" is a valid buffer or "filename" exists.
+		If you supply an empty {list}, the quickfix list will be
+		cleared.
+		Note that the list is not exactly the same as what
+		|getqflist()| returns.
+
+		{action} values:				*E927*
+		'a'	The items from {list} are added to the existing
+			quickfix list. If there is no existing list, then a
+			new list is created.
+
+		'r'	The items from the current quickfix list are replaced
+			with the items from {list}.  This can also be used to
+			clear the list: >
+				:call setqflist([], 'r')
+<
+		'f'	All the quickfix lists in the quickfix stack are
+			freed.
+
+		If {action} is not present or is set to ' ', then a new list
+		is created. The new quickfix list is added after the current
+		quickfix list in the stack and all the following lists are
+		freed. To add a new quickfix list at the end of the stack,
+		set "nr" in {what} to "$".
+
+		If the optional {what} dictionary argument is supplied, then
+		only the items listed in {what} are set. The first {list}
+		argument is ignored.  The following items can be specified in
+		{what}:
+		    context	quickfix list context. See |quickfix-context|
+		    efm		errorformat to use when parsing text from
+				"lines". If this is not present, then the
+				'errorformat' option value is used.
+		    id		quickfix list identifier |quickfix-ID|
+		    items	list of quickfix entries. Same as the {list}
+				argument.
+		    lines	use 'errorformat' to parse a list of lines and
+				add the resulting entries to the quickfix list
+				{nr} or {id}.  Only a |List| value is supported.
+		    nr		list number in the quickfix stack; zero
+				means the current quickfix list and "$" means
+				the last quickfix list
+		    title	quickfix list title text
+		Unsupported keys in {what} are ignored.
+		If the "nr" item is not present, then the current quickfix list
+		is modified. When creating a new quickfix list, "nr" can be
+		set to a value one greater than the quickfix stack size.
+		When modifying a quickfix list, to guarantee that the correct
+		list is modified, "id" should be used instead of "nr" to
+		specify the list.
+
+		Examples (See also |setqflist-examples|): >
+		   :call setqflist([], 'r', {'title': 'My search'})
+		   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
+		   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})
+<
+		Returns zero for success, -1 for failure.
+
+		This function can be used to create a quickfix list
+		independent of the 'errorformat' setting.  Use a command like
+		`:cc 1` to jump to the first position.
+
+
+							*setreg()*
+setreg({regname}, {value} [, {options}])
+		Set the register {regname} to {value}.
+		{value} may be any value returned by |getreg()|, including
+		a |List|.
+		If {options} contains "a" or {regname} is upper case,
+		then the value is appended.
+		{options} can also contain a register type specification:
+		    "c" or "v"	      |characterwise| mode
+		    "l" or "V"	      |linewise| mode
+		    "b" or "<CTRL-V>" |blockwise-visual| mode
+		If a number immediately follows "b" or "<CTRL-V>" then this is
+		used as the width of the selection - if it is not specified
+		then the width of the block is set to the number of characters
+		in the longest line (counting a <Tab> as 1 character).
+
+		If {options} contains no register settings, then the default
+		is to use character mode unless {value} ends in a <NL> for
+		string {value} and linewise mode for list {value}. Blockwise
+		mode is never selected automatically.
+		Returns zero for success, non-zero for failure.
+
+							*E883*
+		Note: you may not use |List| containing more than one item to
+		      set search and expression registers. Lists containing no
+		      items act like empty strings.
+
+		Examples: >
+			:call setreg(v:register, @*)
+			:call setreg('*', @%, 'ac')
+			:call setreg('a', "1\n2\n3", 'b5')
+
+<		This example shows using the functions to save and restore a
+		register: >
+			:let var_a = getreg('a', 1, 1)
+			:let var_amode = getregtype('a')
+			    ....
+			:call setreg('a', var_a, var_amode)
+<		Note: you may not reliably restore register value
+		without using the third argument to |getreg()| as without it
+		newlines are represented as newlines AND Nul bytes are
+		represented as newlines as well, see |NL-used-for-Nul|.
+
+		You can also change the type of a register by appending
+		nothing: >
+			:call setreg('a', '', 'al')
+
+settabvar({tabnr}, {varname}, {val})			*settabvar()*
+		Set tab-local variable {varname} to {val} in tab page {tabnr}.
+		|t:var|
+		Note that the variable name without "t:" must be used.
+		Tabs are numbered starting with one.
+		This function is not available in the |sandbox|.
+
+settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
+		Set option or local variable {varname} in window {winnr} to
+		{val}.
+		Tabs are numbered starting with one.  For the current tabpage
+		use |setwinvar()|.
+		{winnr} can be the window number or the |window-ID|.
+		When {winnr} is zero the current window is used.
+		This also works for a global or local buffer option, but it
+		doesn't work for a global or local buffer variable.
+		For a local buffer option the global value is unchanged.
+		Note that the variable name without "w:" must be used.
+		Examples: >
+			:call settabwinvar(1, 1, "&list", 0)
+			:call settabwinvar(3, 2, "myvar", "foobar")
+<		This function is not available in the |sandbox|.
+
+setwinvar({nr}, {varname}, {val})			*setwinvar()*
+		Like |settabwinvar()| for the current tab page.
+		Examples: >
+			:call setwinvar(1, "&list", 0)
+			:call setwinvar(2, "myvar", "foobar")
+
+sha256({string})						*sha256()*
+		Returns a String with 64 hex characters, which is the SHA256
+		checksum of {string}.
+		{only available when compiled with the |+cryptv| feature}
+
+shellescape({string} [, {special}])			*shellescape()*
+		Escape {string} for use as a shell command argument.
+		On MS-Windows and MS-DOS, when 'shellslash' is not set, it
+		will enclose {string} in double quotes and double all double
+		quotes within {string}.
+		Otherwise it will enclose {string} in single quotes and
+		replace all "'" with "'\''".
+
+		When the {special} argument is present and it's a non-zero
+		Number or a non-empty String (|non-zero-arg|), then special
+		items such as "!", "%", "#" and "<cword>" will be preceded by
+		a backslash.  This backslash will be removed again by the |:!|
+		command.
+
+		The "!" character will be escaped (again with a |non-zero-arg|
+		{special}) when 'shell' contains "csh" in the tail.  That is
+		because for csh and tcsh "!" is used for history replacement
+		even when inside single quotes.
+
+		With a |non-zero-arg| {special} the <NL> character is also
+		escaped.  When 'shell' containing "csh" in the tail it's
+		escaped a second time.
+
+		Example of use with a |:!| command: >
+		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
+<		This results in a directory listing for the file under the
+		cursor.  Example of use with |system()|: >
+		    :call system("chmod +w -- " . shellescape(expand("%")))
+<		See also |::S|.
+
+
+shiftwidth()						*shiftwidth()*
+		Returns the effective value of 'shiftwidth'. This is the
+		'shiftwidth' value unless it is zero, in which case it is the
+		'tabstop' value.  This function was introduced with patch
+		7.3.694 in 2012, everybody should have it by now.
+
+
+simplify({filename})					*simplify()*
+		Simplify the file name as much as possible without changing
+		the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
+		Unix) are not resolved.  If the first path component in
+		{filename} designates the current directory, this will be
+		valid for the result as well.  A trailing path separator is
+		not removed either.
+		Example: >
+			simplify("./dir/.././/file/") == "./file/"
+<		Note: The combination "dir/.." is only removed if "dir" is
+		a searchable directory or does not exist.  On Unix, it is also
+		removed when "dir" is a symbolic link within the same
+		directory.  In order to resolve all the involved symbolic
+		links before simplifying the path name, use |resolve()|.
+
+
+sin({expr})						*sin()*
+		Return the sine of {expr}, measured in radians, as a |Float|.
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo sin(100)
+<			-0.506366 >
+			:echo sin(-4.01)
+<			0.763301
+		{only available when compiled with the |+float| feature}
+
+
+sinh({expr})						*sinh()*
+		Return the hyperbolic sine of {expr} as a |Float| in the range
+		[-inf, inf].
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo sinh(0.5)
+<			0.521095 >
+			:echo sinh(-0.9)
+<			-1.026517
+		{only available when compiled with the |+float| feature}
+
+
+sort({list} [, {func} [, {dict}]])			*sort()* *E702*
+		Sort the items in {list} in-place.  Returns {list}.
+
+		If you want a list to remain unmodified make a copy first: >
+			:let sortedlist = sort(copy(mylist))
+
+<		When {func} is omitted, is empty or zero, then sort() uses the
+		string representation of each item to sort on.  Numbers sort
+		after Strings, |Lists| after Numbers.  For sorting text in the
+		current buffer use |:sort|.
+
+		When {func} is given and it is '1' or 'i' then case is
+		ignored.
+
+		When {func} is given and it is 'n' then all items will be
+		sorted numerical (Implementation detail: This uses the
+		strtod() function to parse numbers, Strings, Lists, Dicts and
+		Funcrefs will be considered as being 0).
+
+		When {func} is given and it is 'N' then all items will be
+		sorted numerical. This is like 'n' but a string containing
+		digits will be used as the number they represent.
+
+		When {func} is given and it is 'f' then all items will be
+		sorted numerical. All values must be a Number or a Float.
+
+		When {func} is a |Funcref| or a function name, this function
+		is called to compare items.  The function is invoked with two
+		items as argument and must return zero if they are equal, 1 or
+		bigger if the first one sorts after the second one, -1 or
+		smaller if the first one sorts before the second one.
+
+		{dict} is for functions with the "dict" attribute.  It will be
+		used to set the local variable "self". |Dictionary-function|
+
+		The sort is stable, items which compare equal (as number or as
+		string) will keep their relative position. E.g., when sorting
+		on numbers, text strings will sort next to each other, in the
+		same order as they were originally.
+
+		Also see |uniq()|.
+
+		Example: >
+			func MyCompare(i1, i2)
+			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
+			endfunc
+			let sortedlist = sort(mylist, "MyCompare")
+<		A shorter compare version for this specific simple case, which
+		ignores overflow: >
+			func MyCompare(i1, i2)
+			   return a:i1 - a:i2
+			endfunc
+<
+							*soundfold()*
+soundfold({word})
+		Return the sound-folded equivalent of {word}.  Uses the first
+		language in 'spelllang' for the current window that supports
+		soundfolding.  'spell' must be set.  When no sound folding is
+		possible the {word} is returned unmodified.
+		This can be used for making spelling suggestions.  Note that
+		the method can be quite slow.
+
+							*spellbadword()*
+spellbadword([{sentence}])
+		Without argument: The result is the badly spelled word under
+		or after the cursor.  The cursor is moved to the start of the
+		bad word.  When no bad word is found in the cursor line the
+		result is an empty string and the cursor doesn't move.
+
+		With argument: The result is the first word in {sentence} that
+		is badly spelled.  If there are no spelling mistakes the
+		result is an empty string.
+
+		The return value is a list with two items:
+		- The badly spelled word or an empty string.
+		- The type of the spelling error:
+			"bad"		spelling mistake
+			"rare"		rare word
+			"local"		word only valid in another region
+			"caps"		word should start with Capital
+		Example: >
+			echo spellbadword("the quik brown fox")
+<			['quik', 'bad'] ~
+
+		The spelling information for the current window is used.  The
+		'spell' option must be set and the value of 'spelllang' is
+		used.
+
+							*spellsuggest()*
+spellsuggest({word} [, {max} [, {capital}]])
+		Return a |List| with spelling suggestions to replace {word}.
+		When {max} is given up to this number of suggestions are
+		returned.  Otherwise up to 25 suggestions are returned.
+
+		When the {capital} argument is given and it's non-zero only
+		suggestions with a leading capital will be given.  Use this
+		after a match with 'spellcapcheck'.
+
+		{word} can be a badly spelled word followed by other text.
+		This allows for joining two words that were split.  The
+		suggestions also include the following text, thus you can
+		replace a line.
+
+		{word} may also be a good word.  Similar words will then be
+		returned.  {word} itself is not included in the suggestions,
+		although it may appear capitalized.
+
+		The spelling information for the current window is used.  The
+		'spell' option must be set and the values of 'spelllang' and
+		'spellsuggest' are used.
+
+
+split({expr} [, {pattern} [, {keepempty}]])			*split()*
+		Make a |List| out of {expr}.  When {pattern} is omitted or
+		empty each white-separated sequence of characters becomes an
+		item.
+		Otherwise the string is split where {pattern} matches,
+		removing the matched characters. 'ignorecase' is not used
+		here, add \c to ignore case. |/\c|
+		When the first or last item is empty it is omitted, unless the
+		{keepempty} argument is given and it's non-zero.
+		Other empty items are kept when {pattern} matches at least one
+		character or when {keepempty} is non-zero.
+		Example: >
+			:let words = split(getline('.'), '\W\+')
+<		To split a string in individual characters: >
+			:for c in split(mystring, '\zs')
+<		If you want to keep the separator you can also use '\zs' at
+		the end of the pattern: >
+			:echo split('abc:def:ghi', ':\zs')
+<			['abc:', 'def:', 'ghi'] ~
+		Splitting a table where the first element can be empty: >
+			:let items = split(line, ':', 1)
+<		The opposite function is |join()|.
+
+
+sqrt({expr})						*sqrt()*
+		Return the non-negative square root of Float {expr} as a
+		|Float|.
+		{expr} must evaluate to a |Float| or a |Number|.  When {expr}
+		is negative the result is NaN (Not a Number).
+		Examples: >
+			:echo sqrt(100)
+<			10.0 >
+			:echo sqrt(-4.01)
+<			nan
+		"nan" may be different, it depends on system libraries.
+		{only available when compiled with the |+float| feature}
+
+
+str2float({expr})					*str2float()*
+		Convert String {expr} to a Float.  This mostly works the same
+		as when using a floating point number in an expression, see
+		|floating-point-format|.  But it's a bit more permissive.
+		E.g., "1e40" is accepted, while in an expression you need to
+		write "1.0e40".
+		Text after the number is silently ignored.
+		The decimal point is always '.', no matter what the locale is
+		set to.  A comma ends the number: "12,345.67" is converted to
+		12.0.  You can strip out thousands separators with
+		|substitute()|: >
+			let f = str2float(substitute(text, ',', '', 'g'))
+<		{only available when compiled with the |+float| feature}
+
+
+str2nr({expr} [, {base}])				*str2nr()*
+		Convert string {expr} to a number.
+		{base} is the conversion base, it can be 2, 8, 10 or 16.
+		When {base} is omitted base 10 is used.  This also means that
+		a leading zero doesn't cause octal conversion to be used, as
+		with the default String to Number conversion.
+		When {base} is 16 a leading "0x" or "0X" is ignored.  With a
+		different base the result will be zero.  Similarly, when
+		{base} is 8 a leading "0" is ignored, and when {base} is 2 a
+		leading "0b" or "0B" is ignored.
+		Text after the number is silently ignored.
+
+
+strchars({expr} [, {skipcc}])					*strchars()*
+		The result is a Number, which is the number of characters
+		in String {expr}.
+		When {skipcc} is omitted or zero, composing characters are
+		counted separately.
+		When {skipcc} set to 1, Composing characters are ignored.
+		Also see |strlen()|, |strdisplaywidth()| and |strwidth()|.
+
+		{skipcc} is only available after 7.4.755.  For backward
+		compatibility, you can define a wrapper function: >
+		    if has("patch-7.4.755")
+		      function s:strchars(str, skipcc)
+			return strchars(a:str, a:skipcc)
+		      endfunction
+		    else
+		      function s:strchars(str, skipcc)
+			if a:skipcc
+			  return strlen(substitute(a:str, ".", "x", "g"))
+			else
+			  return strchars(a:str)
+			endif
+		      endfunction
+		    endif
+<
+strcharpart({src}, {start} [, {len}])			*strcharpart()*
+		Like |strpart()| but using character index and length instead
+		of byte index and length.
+		When a character index is used where a character does not
+		exist it is assumed to be one character.  For example: >
+			strcharpart('abc', -1, 2)
+<		results in 'a'.
+
+strdisplaywidth({expr} [, {col}])			*strdisplaywidth()*
+		The result is a Number, which is the number of display cells
+		String {expr} occupies on the screen when it starts at {col}.
+		When {col} is omitted zero is used.  Otherwise it is the
+		screen column where to start.  This matters for Tab
+		characters.
+		The option settings of the current window are used.  This
+		matters for anything that's displayed differently, such as
+		'tabstop' and 'display'.
+		When {expr} contains characters with East Asian Width Class
+		Ambiguous, this function's return value depends on 'ambiwidth'.
+		Also see |strlen()|, |strwidth()| and |strchars()|.
+
+strftime({format} [, {time}])				*strftime()*
+		The result is a String, which is a formatted date and time, as
+		specified by the {format} string.  The given {time} is used,
+		or the current time if no time is given.  The accepted
+		{format} depends on your system, thus this is not portable!
+		See the manual page of the C function strftime() for the
+		format.  The maximum length of the result is 80 characters.
+		See also |localtime()| and |getftime()|.
+		The language can be changed with the |:language| command.
+		Examples: >
+		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
+		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
+		  :echo strftime("%y%m%d %T")	   970427 11:53:55
+		  :echo strftime("%H:%M")	   11:55
+		  :echo strftime("%c", getftime("file.c"))
+						   Show mod time of file.c.
+<		Not available on all systems.  To check use: >
+			:if exists("*strftime")
+
+strgetchar({str}, {index})				*strgetchar()*
+		Get character {index} from {str}.  This uses a character
+		index, not a byte index.  Composing characters are considered
+		separate characters here.
+		Also see |strcharpart()| and |strchars()|.
+
+stridx({haystack}, {needle} [, {start}])		*stridx()*
+		The result is a Number, which gives the byte index in
+		{haystack} of the first occurrence of the String {needle}.
+		If {start} is specified, the search starts at index {start}.
+		This can be used to find a second match: >
+			:let colon1 = stridx(line, ":")
+			:let colon2 = stridx(line, ":", colon1 + 1)
+<		The search is done case-sensitive.
+		For pattern searches use |match()|.
+		-1 is returned if the {needle} does not occur in {haystack}.
+		See also |strridx()|.
+		Examples: >
+		  :echo stridx("An Example", "Example")	     3
+		  :echo stridx("Starting point", "Start")    0
+		  :echo stridx("Starting point", "start")   -1
+<						*strstr()* *strchr()*
+		stridx() works similar to the C function strstr().  When used
+		with a single character it works similar to strchr().
+
+							*string()*
+string({expr})	Return {expr} converted to a String.  If {expr} is a Number,
+		Float, String or a composition of them, then the result can be
+		parsed back with |eval()|.
+			{expr} type	result ~
+			String		'string' (single quotes are doubled)
+			Number		123
+			Float		123.123456 or 1.123456e8
+			Funcref		function('name')
+			List		[item, item]
+			Dictionary	{key: value, key: value}
+
+		When a List or Dictionary has a recursive reference it is
+		replaced by "[...]" or "{...}".  Using eval() on the result
+		will then fail.
+
+		Also see |strtrans()|.
+
+							*strlen()*
+strlen({expr})	The result is a Number, which is the length of the String
+		{expr} in bytes.
+		If the argument is a Number it is first converted to a String.
+		For other types an error is given.
+		If you want to count the number of multi-byte characters use
+		|strchars()|.
+		Also see |len()|, |strdisplaywidth()| and |strwidth()|.
+
+strpart({src}, {start} [, {len}])			*strpart()*
+		The result is a String, which is part of {src}, starting from
+		byte {start}, with the byte length {len}.
+		To count characters instead of bytes use |strcharpart()|.
+
+		When bytes are selected which do not exist, this doesn't
+		result in an error, the bytes are simply omitted.
+		If {len} is missing, the copy continues from {start} till the
+		end of the {src}. >
+			strpart("abcdefg", 3, 2)    == "de"
+			strpart("abcdefg", -2, 4)   == "ab"
+			strpart("abcdefg", 5, 4)    == "fg"
+			strpart("abcdefg", 3)	    == "defg"
+
+<		Note: To get the first character, {start} must be 0.  For
+		example, to get three bytes under and after the cursor: >
+			strpart(getline("."), col(".") - 1, 3)
+<
+strridx({haystack}, {needle} [, {start}])			*strridx()*
+		The result is a Number, which gives the byte index in
+		{haystack} of the last occurrence of the String {needle}.
+		When {start} is specified, matches beyond this index are
+		ignored.  This can be used to find a match before a previous
+		match: >
+			:let lastcomma = strridx(line, ",")
+			:let comma2 = strridx(line, ",", lastcomma - 1)
+<		The search is done case-sensitive.
+		For pattern searches use |match()|.
+		-1 is returned if the {needle} does not occur in {haystack}.
+		If the {needle} is empty the length of {haystack} is returned.
+		See also |stridx()|.  Examples: >
+		  :echo strridx("an angry armadillo", "an")	     3
+<							*strrchr()*
+		When used with a single character it works similar to the C
+		function strrchr().
+
+strtrans({expr})					*strtrans()*
+		The result is a String, which is {expr} with all unprintable
+		characters translated into printable characters |'isprint'|.
+		Like they are shown in a window.  Example: >
+			echo strtrans(@a)
+<		This displays a newline in register a as "^@" instead of
+		starting a new line.
+
+strwidth({expr})					*strwidth()*
+		The result is a Number, which is the number of display cells
+		String {expr} occupies.  A Tab character is counted as one
+		cell, alternatively use |strdisplaywidth()|.
+		When {expr} contains characters with East Asian Width Class
+		Ambiguous, this function's return value depends on 'ambiwidth'.
+		Also see |strlen()|, |strdisplaywidth()| and |strchars()|.
+
+submatch({nr} [, {list}])			*submatch()* *E935*
+		Only for an expression in a |:substitute| command or
+		substitute() function.
+		Returns the {nr}'th submatch of the matched text.  When {nr}
+		is 0 the whole matched text is returned.
+		Note that a NL in the string can stand for a line break of a
+		multi-line match or a NUL character in the text.
+		Also see |sub-replace-expression|.
+
+		If {list} is present and non-zero then submatch() returns
+		a list of strings, similar to |getline()| with two arguments.
+		NL characters in the text represent NUL characters in the
+		text.
+		Only returns more than one item for |:substitute|, inside
+		|substitute()| this list will always contain one or zero
+		items, since there are no real line breaks.
+
+		When substitute() is used recursively only the submatches in
+		the current (deepest) call can be obtained.
+
+		Examples: >
+			:s/\d\+/\=submatch(0) + 1/
+			:echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
+<		This finds the first number in the line and adds one to it.
+		A line break is included as a newline character.
+
+substitute({expr}, {pat}, {sub}, {flags})		*substitute()*
+		The result is a String, which is a copy of {expr}, in which
+		the first match of {pat} is replaced with {sub}.
+		When {flags} is "g", all matches of {pat} in {expr} are
+		replaced.  Otherwise {flags} should be "".
+
+		This works like the ":substitute" command (without any flags).
+		But the matching with {pat} is always done like the 'magic'
+		option is set and 'cpoptions' is empty (to make scripts
+		portable).  'ignorecase' is still relevant, use |/\c| or |/\C|
+		if you want to ignore or match case and ignore 'ignorecase'.
+		'smartcase' is not used.  See |string-match| for how {pat} is
+		used.
+
+		A "~" in {sub} is not replaced with the previous {sub}.
+		Note that some codes in {sub} have a special meaning
+		|sub-replace-special|.  For example, to replace something with
+		"\n" (two characters), use "\\\\n" or '\\n'.
+
+		When {pat} does not match in {expr}, {expr} is returned
+		unmodified.
+
+		Example: >
+		   :let &path = substitute(&path, ",\\=[^,]*$", "", "")
+<		This removes the last component of the 'path' option. >
+		   :echo substitute("testing", ".*", "\\U\\0", "")
+<		results in "TESTING".
+
+		When {sub} starts with "\=", the remainder is interpreted as
+		an expression. See |sub-replace-expression|.  Example: >
+		   :echo substitute(s, '%\(\x\x\)',
+			   \ '\=nr2char("0x" . submatch(1))', 'g')
+
+<		When {sub} is a Funcref that function is called, with one
+		optional argument.  Example: >
+		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')
+<		The optional argument is a list which contains the whole
+		matched string and up to nine submatches, like what
+		|submatch()| returns.  Example: >
+		   :echo substitute(s, '%\(\x\x\)', {m -> '0x' . m[1]}, 'g')
+
+swapinfo({fname})					*swapinfo()*
+		The result is a dictionary, which holds information about the
+		swapfile {fname}. The available fields are:
+			version VIM version
+			user	user name
+			host	host name
+			fname	original file name
+			pid	PID of the VIM process that created the swap
+				file
+			mtime	last modification time in seconds
+			inode	Optional: INODE number of the file
+			dirty	1 if file was modified, 0 if not
+		Note that "user" and "host" are truncated to at most 39 bytes.
+		In case of failure an "error" item is added with the reason:
+			Cannot open file: file not found or in accessible
+			Cannot read file: cannot read first block
+			Not a swap file: does not contain correct block ID
+			Magic number mismatch: Info in first block is invalid
+
+synID({lnum}, {col}, {trans})				*synID()*
+		The result is a Number, which is the syntax ID at the position
+		{lnum} and {col} in the current window.
+		The syntax ID can be used with |synIDattr()| and
+		|synIDtrans()| to obtain syntax information about text.
+
+		{col} is 1 for the leftmost column, {lnum} is 1 for the first
+		line.  'synmaxcol' applies, in a longer line zero is returned.
+		Note that when the position is after the last character,
+		that's where the cursor can be in Insert mode, synID() returns
+		zero.
+
+		When {trans} is |TRUE|, transparent items are reduced to the
+		item that they reveal.  This is useful when wanting to know
+		the effective color.  When {trans} is |FALSE|, the transparent
+		item is returned.  This is useful when wanting to know which
+		syntax item is effective (e.g. inside parens).
+		Warning: This function can be very slow.  Best speed is
+		obtained by going through the file in forward direction.
+
+		Example (echoes the name of the syntax item under the cursor): >
+			:echo synIDattr(synID(line("."), col("."), 1), "name")
+<
+
+synIDattr({synID}, {what} [, {mode}])			*synIDattr()*
+		The result is a String, which is the {what} attribute of
+		syntax ID {synID}.  This can be used to obtain information
+		about a syntax item.
+		{mode} can be "gui", "cterm" or "term", to get the attributes
+		for that mode.  When {mode} is omitted, or an invalid value is
+		used, the attributes for the currently active highlighting are
+		used (GUI, cterm or term).
+		Use synIDtrans() to follow linked highlight groups.
+		{what}		result
+		"name"		the name of the syntax item
+		"fg"		foreground color (GUI: color name used to set
+				the color, cterm: color number as a string,
+				term: empty string)
+		"bg"		background color (as with "fg")
+		"font"		font name (only available in the GUI)
+				|highlight-font|
+		"sp"		special color (as with "fg") |highlight-guisp|
+		"fg#"		like "fg", but for the GUI and the GUI is
+				running the name in "#RRGGBB" form
+		"bg#"		like "fg#" for "bg"
+		"sp#"		like "fg#" for "sp"
+		"bold"		"1" if bold
+		"italic"	"1" if italic
+		"reverse"	"1" if reverse
+		"inverse"	"1" if inverse (= reverse)
+		"standout"	"1" if standout
+		"underline"	"1" if underlined
+		"undercurl"	"1" if undercurled
+		"strike"	"1" if strikethrough
+
+		Example (echoes the color of the syntax item under the
+		cursor): >
+	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
+<
+synIDtrans({synID})					*synIDtrans()*
+		The result is a Number, which is the translated syntax ID of
+		{synID}.  This is the syntax group ID of what is being used to
+		highlight the character.  Highlight links given with
+		":highlight link" are followed.
+
+synconcealed({lnum}, {col})				*synconcealed()*
+		The result is a List with currently three items:
+		1. The first item in the list is 0 if the character at the
+		   position {lnum} and {col} is not part of a concealable
+		   region, 1 if it is.
+		2. The second item in the list is a string. If the first item
+		   is 1, the second item contains the text which will be
+		   displayed in place of the concealed text, depending on the
+		   current setting of 'conceallevel' and 'listchars'.
+		3. The third and final item in the list is a number
+		   representing the specific syntax region matched in the
+		   line. When the character is not concealed the value is
+		   zero. This allows detection of the beginning of a new
+		   concealable region if there are two consecutive regions
+		   with the same replacement character.  For an example, if
+		   the text is "123456" and both "23" and "45" are concealed
+		   and replace by the character "X", then:
+			call			returns ~
+			synconcealed(lnum, 1)   [0, '', 0]
+			synconcealed(lnum, 2)   [1, 'X', 1]
+			synconcealed(lnum, 3)   [1, 'X', 1]
+			synconcealed(lnum, 4)   [1, 'X', 2]
+			synconcealed(lnum, 5)   [1, 'X', 2]
+			synconcealed(lnum, 6)   [0, '', 0]
+
+
+synstack({lnum}, {col})					*synstack()*
+		Return a |List|, which is the stack of syntax items at the
+		position {lnum} and {col} in the current window.  Each item in
+		the List is an ID like what |synID()| returns.
+		The first item in the List is the outer region, following are
+		items contained in that one.  The last one is what |synID()|
+		returns, unless not the whole item is highlighted or it is a
+		transparent item.
+		This function is useful for debugging a syntax file.
+		Example that shows the syntax stack under the cursor: >
+			for id in synstack(line("."), col("."))
+			   echo synIDattr(id, "name")
+			endfor
+<		When the position specified with {lnum} and {col} is invalid
+		nothing is returned.  The position just after the last
+		character in a line and the first column in an empty line are
+		valid positions.
+
+system({expr} [, {input}])				*system()* *E677*
+		Get the output of the shell command {expr} as a string.  See
+		|systemlist()| to get the output as a List.
+
+		When {input} is given and is a string this string is written
+		to a file and passed as stdin to the command.  The string is
+		written as-is, you need to take care of using the correct line
+		separators yourself.
+		If {input} is given and is a |List| it is written to the file
+		in a way |writefile()| does with {binary} set to "b" (i.e.
+		with a newline between each list item with newlines inside
+		list items converted to NULs).
+		When {input} is given and is a number that is a valid id for
+		an existing buffer then the content of the buffer is written
+		to the file line by line, each line terminated by a NL and
+		NULs characters where the text has a NL.
+
+		Pipes are not used, the 'shelltemp' option is not used.
+
+		When prepended by |:silent| the terminal will not be set to
+		cooked mode.  This is meant to be used for commands that do
+		not need the user to type.  It avoids stray characters showing
+		up on the screen which require |CTRL-L| to remove. >
+			:silent let f = system('ls *.vim')
+<
+		Note: Use |shellescape()| or |::S| with |expand()| or
+		|fnamemodify()| to escape special characters in a command
+		argument.  Newlines in {expr} may cause the command to fail.
+		The characters in 'shellquote' and 'shellxquote' may also
+		cause trouble.
+		This is not to be used for interactive commands.
+
+		The result is a String.  Example: >
+		    :let files = system("ls " .  shellescape(expand('%:h')))
+		    :let files = system('ls ' . expand('%:h:S'))
+
+<		To make the result more system-independent, the shell output
+		is filtered to replace <CR> with <NL> for Macintosh, and
+		<CR><NL> with <NL> for DOS-like systems.
+		To avoid the string being truncated at a NUL, all NUL
+		characters are replaced with SOH (0x01).
+
+		The command executed is constructed using several options:
+	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
+		({tmp} is an automatically generated file name).
+		For Unix and OS/2 braces are put around {expr} to allow for
+		concatenated commands.
+
+		The command will be executed in "cooked" mode, so that a
+		CTRL-C will interrupt the command (on Unix at least).
+
+		The resulting error code can be found in |v:shell_error|.
+		This function will fail in |restricted-mode|.
+
+		Note that any wrong value in the options mentioned above may
+		make the function fail.  It has also been reported to fail
+		when using a security agent application.
+		Unlike ":!cmd" there is no automatic check for changed files.
+		Use |:checktime| to force a check.
+
+
+systemlist({expr} [, {input}])				*systemlist()*
+		Same as |system()|, but returns a |List| with lines (parts of
+		output separated by NL) with NULs transformed into NLs. Output
+		is the same as |readfile()| will output with {binary} argument
+		set to "b".  Note that on MS-Windows you may get trailing CR
+		characters.
+
+		Returns an empty string on error.
+
+
+tabpagebuflist([{arg}])					*tabpagebuflist()*
+		The result is a |List|, where each item is the number of the
+		buffer associated with each window in the current tab page.
+		{arg} specifies the number of the tab page to be used. When
+		omitted the current tab page is used.
+		When {arg} is invalid the number zero is returned.
+		To get a list of all buffers in all tabs use this: >
+			let buflist = []
+			for i in range(tabpagenr('$'))
+			   call extend(buflist, tabpagebuflist(i + 1))
+			endfor
+<		Note that a buffer may appear in more than one window.
+
+
+tabpagenr([{arg}])					*tabpagenr()*
+		The result is a Number, which is the number of the current
+		tab page.  The first tab page has number 1.
+		When the optional argument is "$", the number of the last tab
+		page is returned (the tab page count).
+		The number can be used with the |:tab| command.
+
+
+tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
+		Like |winnr()| but for tab page {tabarg}.
+		{tabarg} specifies the number of tab page to be used.
+		{arg} is used like with |winnr()|:
+		- When omitted the current window number is returned.  This is
+		  the window which will be used when going to this tab page.
+		- When "$" the number of windows is returned.
+		- When "#" the previous window nr is returned.
+		Useful examples: >
+		    tabpagewinnr(1)	    " current window of tab page 1
+		    tabpagewinnr(4, '$')    " number of windows in tab page 4
+<		When {tabarg} is invalid zero is returned.
+
+							*tagfiles()*
+tagfiles()	Returns a |List| with the file names used to search for tags
+		for the current buffer.  This is the 'tags' option expanded.
+
+
+taglist({expr} [, {filename}])				*taglist()*
+		Returns a list of tags matching the regular expression {expr}.
+
+		If {filename} is passed it is used to prioritize the results
+		in the same way that |:tselect| does. See |tag-priority|.
+		{filename} should be the full path of the file.
+
+		Each list item is a dictionary with at least the following
+		entries:
+			name		Name of the tag.
+			filename	Name of the file where the tag is
+					defined.  It is either relative to the
+					current directory or a full path.
+			cmd		Ex command used to locate the tag in
+					the file.
+			kind		Type of the tag.  The value for this
+					entry depends on the language specific
+					kind values.  Only available when
+					using a tags file generated by
+					Exuberant ctags or hdrtag.
+			static		A file specific tag.  Refer to
+					|static-tag| for more information.
+		More entries may be present, depending on the content of the
+		tags file: access, implementation, inherits and signature.
+		Refer to the ctags documentation for information about these
+		fields.  For C code the fields "struct", "class" and "enum"
+		may appear, they give the name of the entity the tag is
+		contained in.
+
+		The ex-command "cmd" can be either an ex search pattern, a
+		line number or a line number followed by a byte number.
+
+		If there are no matching tags, then an empty list is returned.
+
+		To get an exact tag match, the anchors '^' and '$' should be
+		used in {expr}.  This also make the function work faster.
+		Refer to |tag-regexp| for more information about the tag
+		search regular expression pattern.
+
+		Refer to |'tags'| for information about how the tags file is
+		located by Vim. Refer to |tags-file-format| for the format of
+		the tags file generated by the different ctags tools.
+
+tan({expr})						*tan()*
+		Return the tangent of {expr}, measured in radians, as a |Float|
+		in the range [-inf, inf].
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo tan(10)
+<			0.648361 >
+			:echo tan(-4.01)
+<			-1.181502
+		{only available when compiled with the |+float| feature}
+
+
+tanh({expr})						*tanh()*
+		Return the hyperbolic tangent of {expr} as a |Float| in the
+		range [-1, 1].
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			:echo tanh(0.5)
+<			0.462117 >
+			:echo tanh(-1)
+<			-0.761594
+		{only available when compiled with the |+float| feature}
+
+
+tempname()					*tempname()* *temp-file-name*
+		The result is a String, which is the name of a file that
+		doesn't exist.  It can be used for a temporary file.  The name
+		is different for at least 26 consecutive calls.  Example: >
+			:let tmpfile = tempname()
+			:exe "redir > " . tmpfile
+<		For Unix, the file will be in a private directory |tempfile|.
+		For MS-Windows forward slashes are used when the 'shellslash'
+		option is set or when 'shellcmdflag' starts with '-'.
+
+							*term_dumpdiff()*
+term_dumpdiff({filename}, {filename} [, {options}])
+		Open a new window displaying the difference between the two
+		files.  The files must have been created with
+		|term_dumpwrite()|.
+		Returns the buffer number or zero when the diff fails.
+		Also see |terminal-diff|.
+		NOTE: this does not work with double-width characters yet.
+
+		The top part of the buffer contains the contents of the first
+		file, the bottom part of the buffer contains the contents of
+		the second file.  The middle part shows the differences.
+		The parts are separated by a line of dashes.
+
+		If the {options} argument is present, it must be a Dict with
+		these possible members:
+		   "term_name"	     name to use for the buffer name, instead
+				     of the first file name.
+		   "term_rows"	     vertical size to use for the terminal,
+				     instead of using 'termwinsize'
+		   "term_cols"	     horizontal size to use for the terminal,
+				     instead of using 'termwinsize'
+		   "vertical"	     split the window vertically
+		   "curwin"	     use the current window, do not split the
+				     window; fails if the current buffer
+				     cannot be |abandon|ed
+		   "norestore"	     do not add the terminal window to a
+				     session file
+
+		Each character in the middle part indicates a difference. If
+		there are multiple differences only the first in this list is
+		used:
+			X	different character
+			w	different width
+			f	different foreground color
+			b	different background color
+			a	different attribute
+			+	missing position in first file
+			-	missing position in second file
+
+		Using the "s" key the top and bottom parts are swapped.  This
+		makes it easy to spot a difference.
+
+							*term_dumpload()*
+term_dumpload({filename} [, {options}])
+		Open a new window displaying the contents of {filename}
+		The file must have been created with |term_dumpwrite()|.
+		Returns the buffer number or zero when it fails.
+		Also see |terminal-diff|.
+
+		For {options} see |term_dumpdiff()|.
+
+							*term_dumpwrite()*
+term_dumpwrite({buf}, {filename} [, {options}])
+		Dump the contents of the terminal screen of {buf} in the file
+		{filename}.  This uses a format that can be used with
+		|term_dumpload()| and |term_dumpdiff()|.
+		If {filename} already exists an error is given.	*E953*
+		Also see |terminal-diff|.
+
+		{options} is a dictionary with these optional entries:
+			"rows"		maximum number of rows to dump
+			"columns"	maximum number of columns to dump
+
+term_getaltscreen({buf})				*term_getaltscreen()*
+		Returns 1 if the terminal of {buf} is using the alternate
+		screen.
+		{buf} is used as with |term_getsize()|.
+		{only available when compiled with the |+terminal| feature}
+
+term_getansicolors({buf})				*term_getansicolors()*
+		Get the ANSI color palette in use by terminal {buf}.
+		Returns a List of length 16 where each element is a String
+		representing a color in hexadecimal "#rrggbb" format.
+		Also see |term_setansicolors()| and |g:terminal_ansi_colors|.
+		If neither was used returns the default colors.
+
+		{buf} is used as with |term_getsize()|.  If the buffer does not
+		exist or is not a terminal window, an empty list is returned.
+		{only available when compiled with the |+terminal| feature and
+		with GUI enabled and/or the |+termguicolors| feature}
+
+term_getattr({attr}, {what})				*term_getattr()*
+		Given {attr}, a value returned by term_scrape() in the "attr"
+		item, return whether {what} is on.  {what} can be one of:
+			bold
+			italic
+			underline
+			strike
+			reverse
+		{only available when compiled with the |+terminal| feature}
+
+term_getcursor({buf})					*term_getcursor()*
+		Get the cursor position of terminal {buf}. Returns a list with
+		two numbers and a dictionary: [row, col, dict].
+
+		"row" and "col" are one based, the first screen cell is row
+		1, column 1.  This is the cursor position of the terminal
+		itself, not of the Vim window.
+
+		"dict" can have these members:
+		   "visible"	one when the cursor is visible, zero when it
+				is hidden.
+		   "blink"	one when the cursor is visible, zero when it
+				is hidden.
+		   "shape"	1 for a block cursor, 2 for underline and 3
+				for a vertical bar.
+
+		{buf} must be the buffer number of a terminal window. If the
+		buffer does not exist or is not a terminal window, an empty
+		list is returned.
+		{only available when compiled with the |+terminal| feature}
+
+term_getjob({buf})					*term_getjob()*
+		Get the Job associated with terminal window {buf}.
+		{buf} is used as with |term_getsize()|.
+		Returns |v:null| when there is no job.
+		{only available when compiled with the |+terminal| feature}
+
+term_getline({buf}, {row})				*term_getline()*
+		Get a line of text from the terminal window of {buf}.
+		{buf} is used as with |term_getsize()|.
+
+		The first line has {row} one.  When {row} is "." the cursor
+		line is used.  When {row} is invalid an empty string is
+		returned.
+
+		To get attributes of each character use |term_scrape()|.
+		{only available when compiled with the |+terminal| feature}
+
+term_getscrolled({buf})					*term_getscrolled()*
+		Return the number of lines that scrolled to above the top of
+		terminal {buf}.  This is the offset between the row number
+		used for |term_getline()| and |getline()|, so that: >
+			term_getline(buf, N)
+<		is equal to: >
+			`getline(N + term_getscrolled(buf))
+<		(if that line exists).
+
+		{buf} is used as with |term_getsize()|.
+		{only available when compiled with the |+terminal| feature}
+
+term_getsize({buf})					*term_getsize()*
+		Get the size of terminal {buf}. Returns a list with two
+		numbers: [rows, cols].  This is the size of the terminal, not
+		the window containing the terminal.
+
+		{buf} must be the buffer number of a terminal window.  Use an
+		empty string for the current buffer.  If the buffer does not
+		exist or is not a terminal window, an empty list is returned.
+		{only available when compiled with the |+terminal| feature}
+
+term_getstatus({buf})					*term_getstatus()*
+		Get the status of terminal {buf}. This returns a comma
+		separated list of these items:
+			running		job is running
+			finished	job has finished
+			normal		in Terminal-Normal mode
+		One of "running" or "finished" is always present.
+
+		{buf} must be the buffer number of a terminal window. If the
+		buffer does not exist or is not a terminal window, an empty
+		string is returned.
+		{only available when compiled with the |+terminal| feature}
+
+term_gettitle({buf})					*term_gettitle()*
+		Get the title of terminal {buf}. This is the title that the
+		job in the terminal has set.
+
+		{buf} must be the buffer number of a terminal window. If the
+		buffer does not exist or is not a terminal window, an empty
+		string is returned.
+		{only available when compiled with the |+terminal| feature}
+
+term_gettty({buf} [, {input}])				*term_gettty()*
+		Get the name of the controlling terminal associated with
+		terminal window {buf}.  {buf} is used as with |term_getsize()|.
+
+		When {input} is omitted or 0, return the name for writing
+		(stdout). When {input} is 1 return the name for reading
+		(stdin). On UNIX, both return same name.
+		{only available when compiled with the |+terminal| feature}
+
+term_list()						*term_list()*
+		Return a list with the buffer numbers of all buffers for
+		terminal windows.
+		{only available when compiled with the |+terminal| feature}
+
+term_scrape({buf}, {row})				*term_scrape()*
+		Get the contents of {row} of terminal screen of {buf}.
+		For {buf} see |term_getsize()|.
+
+		The first line has {row} one.  When {row} is "." the cursor
+		line is used.  When {row} is invalid an empty string is
+		returned.
+
+		Return a List containing a Dict for each screen cell:
+		    "chars"	character(s) at the cell
+		    "fg"	foreground color as #rrggbb
+		    "bg"	background color as #rrggbb
+		    "attr"	attributes of the cell, use |term_getattr()|
+				to get the individual flags
+		    "width"	cell width: 1 or 2
+		{only available when compiled with the |+terminal| feature}
+
+term_sendkeys({buf}, {keys})				*term_sendkeys()*
+		Send keystrokes {keys} to terminal {buf}.
+		{buf} is used as with |term_getsize()|.
+
+		{keys} are translated as key sequences. For example, "\<c-x>"
+		means the character CTRL-X.
+		{only available when compiled with the |+terminal| feature}
+
+term_setansicolors({buf}, {colors})			*term_setansicolors()*
+		Set the ANSI color palette used by terminal {buf}.
+		{colors} must be a List of 16 valid color names or hexadecimal
+		color codes, like those accepted by |highlight-guifg|.
+		Also see |term_getansicolors()| and |g:terminal_ansi_colors|.
+
+		The colors normally are:
+			0    black
+			1    dark red
+			2    dark green
+			3    brown
+			4    dark blue
+			5    dark magenta
+			6    dark cyan
+			7    light grey
+			8    dark grey
+			9    red
+			10   green
+			11   yellow
+			12   blue
+			13   magenta
+			14   cyan
+			15   white
+
+		These colors are used in the GUI and in the terminal when
+		'termguicolors' is set.  When not using GUI colors (GUI mode
+		or 'termguicolors'), the terminal window always uses the 16
+		ANSI colors of the underlying terminal.
+		{only available when compiled with the |+terminal| feature and
+		with GUI enabled and/or the |+termguicolors| feature}
+
+term_setkill({buf}, {how})				*term_setkill()*
+		When exiting Vim or trying to close the terminal window in
+		another way, {how} defines whether the job in the terminal can
+		be stopped.
+		When {how} is empty (the default), the job will not be
+		stopped, trying to exit will result in |E947|.
+		Otherwise, {how} specifies what signal to send to the job.
+		See |job_stop()| for the values.
+
+		After sending the signal Vim will wait for up to a second to
+		check that the job actually stopped.
+
+term_setrestore({buf}, {command})			*term_setrestore()*
+		Set the command to write in a session file to restore the job
+		in this terminal.  The line written in the session file is: >
+			terminal ++curwin ++cols=%d ++rows=%d {command}
+<		Make sure to escape the command properly.
+
+		Use an empty {command} to run 'shell'.
+		Use "NONE" to not restore this window.
+		{only available when compiled with the |+terminal| feature}
+
+term_setsize({buf}, {rows}, {cols})		*term_setsize()* *E955*
+		Set the size of terminal {buf}. The size of the window
+		containing the terminal will also be adjusted, if possible.
+		If {rows} or {cols} is zero or negative, that dimension is not
+		changed.
+
+		{buf} must be the buffer number of a terminal window.  Use an
+		empty string for the current buffer.  If the buffer does not
+		exist or is not a terminal window, an error is given.
+		{only available when compiled with the |+terminal| feature}
+
+term_start({cmd}, {options})				*term_start()*
+		Open a terminal window and run {cmd} in it.
+
+		{cmd} can be a string or a List, like with |job_start()|. The
+		string "NONE" can be used to open a terminal window without
+		starting a job, the pty of the terminal can be used by a
+		command like gdb.
+
+		Returns the buffer number of the terminal window.  If {cmd}
+		cannot be executed the window does open and shows an error
+		message.
+		If opening the window fails zero is returned.
+
+		{options} are similar to what is used for |job_start()|, see
+		|job-options|.  However, not all options can be used.  These
+		are supported:
+		   all timeout options
+		   "stoponexit", "cwd", "env"
+		   "callback", "out_cb", "err_cb", "exit_cb", "close_cb"
+		   "in_io", "in_top", "in_bot", "in_name", "in_buf"
+		   "out_io", "out_name", "out_buf", "out_modifiable", "out_msg"
+		   "err_io", "err_name", "err_buf", "err_modifiable", "err_msg"
+		However, at least one of stdin, stdout or stderr must be
+		connected to the terminal.  When I/O is connected to the
+		terminal then the callback function for that part is not used.
+
+		There are extra options:
+		   "term_name"	     name to use for the buffer name, instead
+				     of the command name.
+		   "term_rows"	     vertical size to use for the terminal,
+				     instead of using 'termwinsize'
+		   "term_cols"	     horizontal size to use for the terminal,
+				     instead of using 'termwinsize'
+		   "vertical"	     split the window vertically; note that
+				     other window position can be defined with
+				     command modifiers, such as |:belowright|.
+		   "curwin"	     use the current window, do not split the
+				     window; fails if the current buffer
+				     cannot be |abandon|ed
+		   "hidden"	     do not open a window
+		   "norestore"	     do not add the terminal window to a
+				     session file
+		   "term_kill"	     what to do when trying to close the
+				     terminal window, see |term_setkill()|
+		   "term_finish"     What to do when the job is finished:
+					"close": close any windows
+					"open": open window if needed
+				     Note that "open" can be interruptive.
+				     See |term++close| and |term++open|.
+		   "term_opencmd"    command to use for opening the window when
+				     "open" is used for "term_finish"; must
+				     have "%d" where the buffer number goes,
+				     e.g. "10split|buffer %d"; when not
+				     specified "botright sbuf %d" is used
+		   "eof_chars"	     Text to send after all buffer lines were
+				     written to the terminal.  When not set
+				     CTRL-D is used on MS-Windows. For Python
+				     use CTRL-Z or "exit()". For a shell use
+				     "exit".  A CR is always added.
+		   "ansi_colors"     A list of 16 color names or hex codes
+				     defining the ANSI palette used in GUI
+				     color modes.  See |g:terminal_ansi_colors|.
+
+		{only available when compiled with the |+terminal| feature}
+
+term_wait({buf} [, {time}])					*term_wait()*
+		Wait for pending updates of {buf} to be handled.
+		{buf} is used as with |term_getsize()|.
+		{time} is how long to wait for updates to arrive in msec.  If
+		not set then 10 msec will be used.
+		{only available when compiled with the |+terminal| feature}
+
+test_alloc_fail({id}, {countdown}, {repeat})		*test_alloc_fail()*
+		This is for testing: If the memory allocation with {id} is
+		called, then decrement {countdown}, and when it reaches zero
+		let memory allocation fail {repeat} times.  When {repeat} is
+		smaller than one it fails one time.
+
+test_autochdir()					*test_autochdir()*
+		Set a flag to enable the effect of 'autochdir' before Vim
+		startup has finished.
+
+test_feedinput({string})				*test_feedinput()*
+		Characters in {string} are queued for processing as if they
+		were typed by the user. This uses a low level input buffer.
+		This function works only when with |+unix| or GUI is running.
+
+test_garbagecollect_now()			 *test_garbagecollect_now()*
+		Like garbagecollect(), but executed right away.  This must
+		only be called directly to avoid any structure to exist
+		internally, and |v:testing| must have been set before calling
+		any function.
+
+test_ignore_error({expr})			 *test_ignore_error()*
+		Ignore any error containing {expr}.  A normal message is given
+		instead.
+		This is only meant to be used in tests, where catching the
+		error with try/catch cannot be used (because it skips over
+		following code).
+		{expr} is used literally, not as a pattern.
+		There is currently no way to revert this.
+
+test_null_channel()					*test_null_channel()*
+		Return a Channel that is null. Only useful for testing.
+		{only available when compiled with the +channel feature}
+
+test_null_dict()					*test_null_dict()*
+		Return a Dict that is null. Only useful for testing.
+
+test_null_job()						*test_null_job()*
+		Return a Job that is null. Only useful for testing.
+		{only available when compiled with the +job feature}
+
+test_null_list()					*test_null_list()*
+		Return a List that is null. Only useful for testing.
+
+test_null_partial()					*test_null_partial()*
+		Return a Partial that is null. Only useful for testing.
+
+test_null_string()					*test_null_string()*
+		Return a String that is null. Only useful for testing.
+
+test_override({name}, {val})				*test_override()*
+		Overrides certain parts of Vims internal processing to be able
+		to run tests. Only to be used for testing Vim!
+		The override is enabled when {val} is non-zero and removed
+		when {val} is zero.
+		Current supported values for name are:
+
+		name	     effect when {val} is non-zero ~
+		redraw       disable the redrawing() function
+		char_avail   disable the char_avail() function
+		starting     reset the "starting" variable, see below
+		nfa_fail     makes the NFA regexp engine fail to force a
+			     fallback to the old engine
+		ALL	     clear all overrides ({val} is not used)
+
+		"starting" is to be used when a test should behave like
+		startup was done.  Since the tests are run by sourcing a
+		script the "starting" variable is non-zero. This is usually a
+		good thing (tests run faster), but sometimes changes behavior
+		in a way that the test doesn't work properly.
+		When using: >
+			call test_override('starting', 1)
+<		The value of "starting" is saved.  It is restored by: >
+			call test_override('starting', 0)
+
+test_settime({expr})					*test_settime()*
+		Set the time Vim uses internally.  Currently only used for
+		timestamps in the history, as they are used in viminfo, and
+		for undo.
+		Using a value of 1 makes Vim not sleep after a warning or
+		error message.
+		{expr} must evaluate to a number.  When the value is zero the
+		normal behavior is restored.
+
+							*timer_info()*
+timer_info([{id}])
+		Return a list with information about timers.
+		When {id} is given only information about this timer is
+		returned.  When timer {id} does not exist an empty list is
+		returned.
+		When {id} is omitted information about all timers is returned.
+
+		For each timer the information is stored in a Dictionary with
+		these items:
+		    "id"	    the timer ID
+		    "time"	    time the timer was started with
+		    "remaining"	    time until the timer fires
+		    "repeat"	    number of times the timer will still fire;
+				    -1 means forever
+		    "callback"	    the callback
+		    "paused"	    1 if the timer is paused, 0 otherwise
+
+		{only available when compiled with the |+timers| feature}
+
+timer_pause({timer}, {paused})				*timer_pause()*
+		Pause or unpause a timer.  A paused timer does not invoke its
+		callback when its time expires.  Unpausing a timer may cause
+		the callback to be invoked almost immediately if enough time
+		has passed.
+
+		Pausing a timer is useful to avoid the callback to be called
+		for a short time.
+
+		If {paused} evaluates to a non-zero Number or a non-empty
+		String, then the timer is paused, otherwise it is unpaused.
+		See |non-zero-arg|.
+
+		{only available when compiled with the |+timers| feature}
+
+						*timer_start()* *timer* *timers*
+timer_start({time}, {callback} [, {options}])
+		Create a timer and return the timer ID.
+
+		{time} is the waiting time in milliseconds. This is the
+		minimum time before invoking the callback.  When the system is
+		busy or Vim is not waiting for input the time will be longer.
+
+		{callback} is the function to call.  It can be the name of a
+		function or a |Funcref|.  It is called with one argument, which
+		is the timer ID.  The callback is only invoked when Vim is
+		waiting for input.
+
+		{options} is a dictionary.  Supported entries:
+		   "repeat"	Number of times to repeat calling the
+				callback.  -1 means forever.  When not present
+				the callback will be called once.
+				If the timer causes an error three times in a
+				row the repeat is cancelled.  This avoids that
+				Vim becomes unusable because of all the error
+				messages.
+
+		Example: >
+			func MyHandler(timer)
+			  echo 'Handler called'
+			endfunc
+			let timer = timer_start(500, 'MyHandler',
+				\ {'repeat': 3})
+<		This will invoke MyHandler() three times at 500 msec
+		intervals.
+
+		{only available when compiled with the |+timers| feature}
+
+timer_stop({timer})					*timer_stop()*
+		Stop a timer.  The timer callback will no longer be invoked.
+		{timer} is an ID returned by timer_start(), thus it must be a
+		Number.  If {timer} does not exist there is no error.
+
+		{only available when compiled with the |+timers| feature}
+
+timer_stopall()						*timer_stopall()*
+		Stop all timers.  The timer callbacks will no longer be
+		invoked.  Useful if some timers is misbehaving.  If there are
+		no timers there is no error.
+
+		{only available when compiled with the |+timers| feature}
+
+tolower({expr})						*tolower()*
+		The result is a copy of the String given, with all uppercase
+		characters turned into lowercase (just like applying |gu| to
+		the string).
+
+toupper({expr})						*toupper()*
+		The result is a copy of the String given, with all lowercase
+		characters turned into uppercase (just like applying |gU| to
+		the string).
+
+tr({src}, {fromstr}, {tostr})				*tr()*
+		The result is a copy of the {src} string with all characters
+		which appear in {fromstr} replaced by the character in that
+		position in the {tostr} string.  Thus the first character in
+		{fromstr} is translated into the first character in {tostr}
+		and so on.  Exactly like the unix "tr" command.
+		This code also deals with multibyte characters properly.
+
+		Examples: >
+			echo tr("hello there", "ht", "HT")
+<		returns "Hello THere" >
+			echo tr("<blob>", "<>", "{}")
+<		returns "{blob}"
+
+trim({text} [, {mask}])						*trim()*
+		Return {text} as a String where any character in {mask} is
+		removed from the beginning and  end of {text}.
+		If {mask} is not given, {mask} is all characters up to 0x20,
+		which includes Tab, space, NL and CR, plus the non-breaking
+		space character 0xa0.
+		This code deals with multibyte characters properly.
+
+		Examples: >
+			echo trim("   some text ")
+<		returns "some text" >
+			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") . "_TAIL"
+<		returns "RESERVE_TAIL" >
+			echo trim("rm<Xrm<>X>rrm", "rm<>")
+<		returns "Xrm<>X" (characters in the middle are not removed)
+
+trunc({expr})							*trunc()*
+		Return the largest integral value with magnitude less than or
+		equal to {expr} as a |Float| (truncate towards zero).
+		{expr} must evaluate to a |Float| or a |Number|.
+		Examples: >
+			echo trunc(1.456)
+<			1.0  >
+			echo trunc(-5.456)
+<			-5.0  >
+			echo trunc(4.0)
+<			4.0
+		{only available when compiled with the |+float| feature}
+
+							*type()*
+type({expr})	The result is a Number representing the type of {expr}.
+		Instead of using the number directly, it is better to use the
+		v:t_ variable that has the value:
+			Number:	    0  |v:t_number|
+			String:	    1  |v:t_string|
+			Funcref:    2  |v:t_func|
+			List:	    3  |v:t_list|
+			Dictionary: 4  |v:t_dict|
+			Float:	    5  |v:t_float|
+			Boolean:    6  |v:t_bool| (v:false and v:true)
+			None	    7  |v:t_none| (v:null and v:none)
+			Job	    8  |v:t_job|
+			Channel	    9  |v:t_channel|
+		For backward compatibility, this method can be used: >
+			:if type(myvar) == type(0)
+			:if type(myvar) == type("")
+			:if type(myvar) == type(function("tr"))
+			:if type(myvar) == type([])
+			:if type(myvar) == type({})
+			:if type(myvar) == type(0.0)
+			:if type(myvar) == type(v:false)
+			:if type(myvar) == type(v:none)
+<		To check if the v:t_ variables exist use this: >
+			:if exists('v:t_number')
+
+undofile({name})					*undofile()*
+		Return the name of the undo file that would be used for a file
+		with name {name} when writing.  This uses the 'undodir'
+		option, finding directories that exist.  It does not check if
+		the undo file exists.
+		{name} is always expanded to the full path, since that is what
+		is used internally.
+		If {name} is empty undofile() returns an empty string, since a
+		buffer without a file name will not write an undo file.
+		Useful in combination with |:wundo| and |:rundo|.
+		When compiled without the +persistent_undo option this always
+		returns an empty string.
+
+undotree()						*undotree()*
+		Return the current state of the undo tree in a dictionary with
+		the following items:
+		  "seq_last"	The highest undo sequence number used.
+		  "seq_cur"	The sequence number of the current position in
+				the undo tree.  This differs from "seq_last"
+				when some changes were undone.
+		  "time_cur"	Time last used for |:earlier| and related
+				commands.  Use |strftime()| to convert to
+				something readable.
+		  "save_last"	Number of the last file write.  Zero when no
+				write yet.
+		  "save_cur"	Number of the current position in the undo
+				tree.
+		  "synced"	Non-zero when the last undo block was synced.
+				This happens when waiting from input from the
+				user.  See |undo-blocks|.
+		  "entries"	A list of dictionaries with information about
+				undo blocks.
+
+		The first item in the "entries" list is the oldest undo item.
+		Each List item is a Dictionary with these items:
+		  "seq"		Undo sequence number.  Same as what appears in
+				|:undolist|.
+		  "time"	Timestamp when the change happened.  Use
+				|strftime()| to convert to something readable.
+		  "newhead"	Only appears in the item that is the last one
+				that was added.  This marks the last change
+				and where further changes will be added.
+		  "curhead"	Only appears in the item that is the last one
+				that was undone.  This marks the current
+				position in the undo tree, the block that will
+				be used by a redo command.  When nothing was
+				undone after the last change this item will
+				not appear anywhere.
+		  "save"	Only appears on the last block before a file
+				write.  The number is the write count.  The
+				first write has number 1, the last one the
+				"save_last" mentioned above.
+		  "alt"		Alternate entry.  This is again a List of undo
+				blocks.  Each item may again have an "alt"
+				item.
+
+uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
+		Remove second and succeeding copies of repeated adjacent
+		{list} items in-place.  Returns {list}.  If you want a list
+		to remain unmodified make a copy first: >
+			:let newlist = uniq(copy(mylist))
+<		The default compare function uses the string representation of
+		each item.  For the use of {func} and {dict} see |sort()|.
+
+values({dict})						*values()*
+		Return a |List| with all the values of {dict}.  The |List| is
+		in arbitrary order.
+
+
+virtcol({expr})						*virtcol()*
+		The result is a Number, which is the screen column of the file
+		position given with {expr}.  That is, the last screen position
+		occupied by the character at that position, when the screen
+		would be of unlimited width.  When there is a <Tab> at the
+		position, the returned Number will be the column at the end of
+		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
+		set to 8, it returns 8. |conceal| is ignored.
+		For the byte position use |col()|.
+		For the use of {expr} see |col()|.
+		When 'virtualedit' is used {expr} can be [lnum, col, off], where
+		"off" is the offset in screen columns from the start of the
+		character.  E.g., a position within a <Tab> or after the last
+		character.  When "off" is omitted zero is used.
+		When Virtual editing is active in the current mode, a position
+		beyond the end of the line can be returned. |'virtualedit'|
+		The accepted positions are:
+		    .	    the cursor position
+		    $	    the end of the cursor line (the result is the
+			    number of displayed characters in the cursor line
+			    plus one)
+		    'x	    position of mark x (if the mark is not set, 0 is
+			    returned)
+		    v       In Visual mode: the start of the Visual area (the
+			    cursor is the end).  When not in Visual mode
+			    returns the cursor position.  Differs from |'<| in
+			    that it's updated right away.
+		Note that only marks in the current file can be used.
+		Examples: >
+  virtcol(".")	   with text "foo^Lbar", with cursor on the "^L", returns 5
+  virtcol("$")	   with text "foo^Lbar", returns 9
+  virtcol("'t")    with text "	  there", with 't at 'h', returns 6
+<		The first column is 1.  0 is returned for an error.
+		A more advanced example that echoes the maximum length of
+		all lines: >
+		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))
+
+
+visualmode([expr])						*visualmode()*
+		The result is a String, which describes the last Visual mode
+		used in the current buffer.  Initially it returns an empty
+		string, but once Visual mode has been used, it returns "v",
+		"V", or "<CTRL-V>" (a single CTRL-V character) for
+		character-wise, line-wise, or block-wise Visual mode
+		respectively.
+		Example: >
+			:exe "normal " . visualmode()
+<		This enters the same Visual mode as before.  It is also useful
+		in scripts if you wish to act differently depending on the
+		Visual mode that was used.
+		If Visual mode is active, use |mode()| to get the Visual mode
+		(e.g., in a |:vmap|).
+		If [expr] is supplied and it evaluates to a non-zero Number or
+		a non-empty String, then the Visual mode will be cleared and
+		the old value is returned.  See |non-zero-arg|.
+
+wildmenumode()					*wildmenumode()*
+		Returns |TRUE| when the wildmenu is active and |FALSE|
+		otherwise.  See 'wildmenu' and 'wildmode'.
+		This can be used in mappings to handle the 'wildcharm' option
+		gracefully. (Makes only sense with |mapmode-c| mappings).
+
+		For example to make <c-j> work like <down> in wildmode, use: >
+    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
+<
+		(Note, this needs the 'wildcharm' option set appropriately).
+
+
+win_findbuf({bufnr})					*win_findbuf()*
+		Returns a list with |window-ID|s for windows that contain
+		buffer {bufnr}.  When there is none the list is empty.
+
+win_getid([{win} [, {tab}]])				*win_getid()*
+		Get the |window-ID| for the specified window.
+		When {win} is missing use the current window.
+		With {win} this is the window number.  The top window has
+		number 1.  Use `win_getid(winnr())` for the current window.
+		Without {tab} use the current tab, otherwise the tab with
+		number {tab}.  The first tab has number one.
+		Return zero if the window cannot be found.
+
+win_gotoid({expr})					*win_gotoid()*
+		Go to window with ID {expr}.  This may also change the current
+		tabpage.
+		Return 1 if successful, 0 if the window cannot be found.
+
+win_id2tabwin({expr})					*win_id2tabwin()*
+		Return a list with the tab number and window number of window
+		with ID {expr}: [tabnr, winnr].
+		Return [0, 0] if the window cannot be found.
+
+win_id2win({expr})					*win_id2win()*
+		Return the window number of window with ID {expr}.
+		Return 0 if the window cannot be found in the current tabpage.
+
+win_screenpos({nr})					*win_screenpos()*
+		Return the screen position of window {nr} as a list with two
+		numbers: [row, col].  The first window always has position
+		[1, 1], unless there is a tabline, then it is [2, 1].
+		{nr} can be the window number or the |window-ID|.
+		Return [0, 0] if the window cannot be found in the current
+		tabpage.
+
+							*winbufnr()*
+winbufnr({nr})	The result is a Number, which is the number of the buffer
+		associated with window {nr}.  {nr} can be the window number or
+		the |window-ID|.
+		When {nr} is zero, the number of the buffer in the current
+		window is returned.
+		When window {nr} doesn't exist, -1 is returned.
+		Example: >
+  :echo "The file in the current window is " . bufname(winbufnr(0))
+<
+							*wincol()*
+wincol()	The result is a Number, which is the virtual column of the
+		cursor in the window.  This is counting screen cells from the
+		left side of the window.  The leftmost column is one.
+
+winheight({nr})						*winheight()*
+		The result is a Number, which is the height of window {nr}.
+		{nr} can be the window number or the |window-ID|.
+		When {nr} is zero, the height of the current window is
+		returned.  When window {nr} doesn't exist, -1 is returned.
+		An existing window always has a height of zero or more.
+		This excludes any window toolbar line.
+		Examples: >
+  :echo "The current window has " . winheight(0) . " lines."
+<
+winlayout([{tabnr}])					*winlayout()*
+		The result is a nested List containing the layout of windows
+		in a tabpage.
+
+		Without {tabnr} use the current tabpage, otherwise the tabpage
+		with number {tabnr}. If the tabpage {tabnr} is not found,
+		returns an empty list.
+
+		For a leaf window, it returns:
+			['leaf', {winid}]
+		For horizontally split windows, which form a column, it
+		returns:
+			['col', [{nested list of windows}]]
+		For vertically split windows, which form a row, it returns:
+			['row', [{nested list of windows}]]
+
+		Example: >
+			" Only one window in the tab page
+			:echo winlayout()
+			['leaf', 1000]
+			" Two horizontally split windows
+			:echo winlayout()
+			['col', [['leaf', 1000], ['leaf', 1001]]]
+			" Three horizontally split windows, with two
+			" vertically split windows in the middle window
+			:echo winlayout(2)
+			['col', [['leaf', 1002], ['row', ['leaf', 1003],
+					     ['leaf', 1001]]], ['leaf', 1000]]
+<
+							*winline()*
+winline()	The result is a Number, which is the screen line of the cursor
+		in the window.  This is counting screen lines from the top of
+		the window.  The first line is one.
+		If the cursor was moved the view on the file will be updated
+		first, this may cause a scroll.
+
+							*winnr()*
+winnr([{arg}])	The result is a Number, which is the number of the current
+		window.  The top window has number 1.
+		When the optional argument is "$", the number of the
+		last window is returned (the window count). >
+			let window_count = winnr('$')
+<		When the optional argument is "#", the number of the last
+		accessed window is returned (where |CTRL-W_p| goes to).
+		If there is no previous window or it is in another tab page 0
+		is returned.
+		The number can be used with |CTRL-W_w| and ":wincmd w"
+		|:wincmd|.
+		Also see |tabpagewinnr()| and |win_getid()|.
+
+							*winrestcmd()*
+winrestcmd()	Returns a sequence of |:resize| commands that should restore
+		the current window sizes.  Only works properly when no windows
+		are opened or closed and the current window and tab page is
+		unchanged.
+		Example: >
+			:let cmd = winrestcmd()
+			:call MessWithWindowSizes()
+			:exe cmd
+<
+							*winrestview()*
+winrestview({dict})
+		Uses the |Dictionary| returned by |winsaveview()| to restore
+		the view of the current window.
+		Note: The {dict} does not have to contain all values, that are
+		returned by |winsaveview()|. If values are missing, those
+		settings won't be restored. So you can use: >
+		    :call winrestview({'curswant': 4})
+<
+		This will only set the curswant value (the column the cursor
+		wants to move on vertical movements) of the cursor to column 5
+		(yes, that is 5), while all other settings will remain the
+		same. This is useful, if you set the cursor position manually.
+
+		If you have changed the values the result is unpredictable.
+		If the window size changed the result won't be the same.
+
+							*winsaveview()*
+winsaveview()	Returns a |Dictionary| that contains information to restore
+		the view of the current window.  Use |winrestview()| to
+		restore the view.
+		This is useful if you have a mapping that jumps around in the
+		buffer and you want to go back to the original view.
+		This does not save fold information.  Use the 'foldenable'
+		option to temporarily switch off folding, so that folds are
+		not opened when moving around. This may have side effects.
+		The return value includes:
+			lnum		cursor line number
+			col		cursor column (Note: the first column
+					zero, as opposed to what getpos()
+					returns)
+			coladd		cursor column offset for 'virtualedit'
+			curswant	column for vertical movement
+			topline		first line in the window
+			topfill		filler lines, only in diff mode
+			leftcol		first column displayed
+			skipcol		columns skipped
+		Note that no option values are saved.
+
+
+winwidth({nr})						*winwidth()*
+		The result is a Number, which is the width of window {nr}.
+		{nr} can be the window number or the |window-ID|.
+		When {nr} is zero, the width of the current window is
+		returned.  When window {nr} doesn't exist, -1 is returned.
+		An existing window always has a width of zero or more.
+		Examples: >
+  :echo "The current window has " . winwidth(0) . " columns."
+  :if winwidth(0) <= 50
+  :  50 wincmd |
+  :endif
+<		For getting the terminal or screen size, see the 'columns'
+		option.
+
+
+wordcount()						*wordcount()*
+		The result is a dictionary of byte/chars/word statistics for
+		the current buffer.  This is the same info as provided by
+		|g_CTRL-G|
+		The return value includes:
+			bytes		Number of bytes in the buffer
+			chars		Number of chars in the buffer
+			words		Number of words in the buffer
+			cursor_bytes    Number of bytes before cursor position
+					(not in Visual mode)
+			cursor_chars    Number of chars before cursor position
+					(not in Visual mode)
+			cursor_words    Number of words before cursor position
+					(not in Visual mode)
+			visual_bytes    Number of bytes visually selected
+					(only in Visual mode)
+			visual_chars    Number of chars visually selected
+					(only in Visual mode)
+			visual_words    Number of words visually selected
+					(only in Visual mode)
+
+
+							*writefile()*
+writefile({list}, {fname} [, {flags}])
+		Write |List| {list} to file {fname}.  Each list item is
+		separated with a NL.  Each list item must be a String or
+		Number.
+		When {flags} contains "b" then binary mode is used: There will
+		not be a NL after the last list item.  An empty item at the
+		end does cause the last line in the file to end in a NL.
+
+		When {flags} contains "a" then append mode is used, lines are
+		appended to the file: >
+			:call writefile(["foo"], "event.log", "a")
+			:call writefile(["bar"], "event.log", "a")
+<
+		When {flags} contains "s" then fsync() is called after writing
+		the file.  This flushes the file to disk, if possible.  This
+		takes more time but avoids losing the file if the system
+		crashes.
+		When {flags} does not contain "S" or "s" then fsync() is
+		called if the 'fsync' option is set.
+		When {flags} contains "S" then fsync() is not called, even
+		when 'fsync' is set.
+
+		All NL characters are replaced with a NUL character.
+		Inserting CR characters needs to be done before passing {list}
+		to writefile().
+		An existing file is overwritten, if possible.
+		When the write fails -1 is returned, otherwise 0.  There is an
+		error message if the file can't be created or when writing
+		fails.
+		Also see |readfile()|.
+		To copy a file byte for byte: >
+			:let fl = readfile("foo", "b")
+			:call writefile(fl, "foocopy", "b")
+
+
+xor({expr}, {expr})					*xor()*
+		Bitwise XOR on the two arguments.  The arguments are converted
+		to a number.  A List, Dict or Float argument causes an error.
+		Example: >
+			:let bits = xor(bits, 0x80)
+<
+
+
+							*feature-list*
+There are four types of features:
+1.  Features that are only supported when they have been enabled when Vim
+    was compiled |+feature-list|.  Example: >
+	:if has("cindent")
+2.  Features that are only supported when certain conditions have been met.
+    Example: >
+	:if has("gui_running")
+<							*has-patch*
+3.  Beyond a certain version or at a certain version and including a specific
+    patch.  The "patch-7.4.248" feature means that the Vim version is 7.5 or
+    later, or it is version 7.4 and patch 248 was included.  Example: >
+	:if has("patch-7.4.248")
+<    Note that it's possible for patch 248 to be omitted even though 249 is
+    included.  Only happens when cherry-picking patches.
+    Note that this form only works for patch 7.4.237 and later, before that
+    you need to check for the patch and the  v:version.  Example (checking
+    version 6.2.148 or later): >
+	:if v:version > 602 || (v:version == 602 && has("patch148"))
+
+Hint: To find out if Vim supports backslashes in a file name (MS-Windows),
+use: `if exists('+shellslash')`
+
+
+acl			Compiled with |ACL| support.
+all_builtin_terms	Compiled with all builtin terminals enabled.
+amiga			Amiga version of Vim.
+arabic			Compiled with Arabic support |Arabic|.
+arp			Compiled with ARP support (Amiga).
+autocmd			Compiled with autocommand support. |autocommand|
+autochdir		Compiled with support for 'autochdir'
+autoservername		Automatically enable |clientserver|
+balloon_eval		Compiled with |balloon-eval| support.
+balloon_multiline	GUI supports multiline balloons.
+beos			BeOS version of Vim.
+browse			Compiled with |:browse| support, and browse() will
+			work.
+browsefilter		Compiled with support for |browsefilter|.
+builtin_terms		Compiled with some builtin terminals.
+byte_offset		Compiled with support for 'o' in 'statusline'
+cindent			Compiled with 'cindent' support.
+clientserver		Compiled with remote invocation support |clientserver|.
+clipboard		Compiled with 'clipboard' support.
+cmdline_compl		Compiled with |cmdline-completion| support.
+cmdline_hist		Compiled with |cmdline-history| support.
+cmdline_info		Compiled with 'showcmd' and 'ruler' support.
+comments		Compiled with |'comments'| support.
+compatible		Compiled to be very Vi compatible.
+cryptv			Compiled with encryption support |encryption|.
+cscope			Compiled with |cscope| support.
+debug			Compiled with "DEBUG" defined.
+dialog_con		Compiled with console dialog support.
+dialog_gui		Compiled with GUI dialog support.
+diff			Compiled with |vimdiff| and 'diff' support.
+digraphs		Compiled with support for digraphs.
+directx			Compiled with support for DirectX and 'renderoptions'.
+dnd			Compiled with support for the "~ register |quote_~|.
+ebcdic			Compiled on a machine with ebcdic character set.
+emacs_tags		Compiled with support for Emacs tags.
+eval			Compiled with expression evaluation support.  Always
+			true, of course!
+ex_extra		|+ex_extra|, always true now
+extra_search		Compiled with support for |'incsearch'| and
+			|'hlsearch'|
+farsi			Compiled with Farsi support |farsi|.
+file_in_path		Compiled with support for |gf| and |<cfile>|
+filterpipe		When 'shelltemp' is off pipes are used for shell
+			read/write/filter commands
+find_in_path		Compiled with support for include file searches
+			|+find_in_path|.
+float			Compiled with support for |Float|.
+fname_case		Case in file names matters (for Amiga, MS-DOS, and
+			Windows this is not present).
+folding			Compiled with |folding| support.
+footer			Compiled with GUI footer support. |gui-footer|
+fork			Compiled to use fork()/exec() instead of system().
+gettext			Compiled with message translation |multi-lang|
+gui			Compiled with GUI enabled.
+gui_athena		Compiled with Athena GUI.
+gui_gnome		Compiled with Gnome support (gui_gtk is also defined).
+gui_gtk			Compiled with GTK+ GUI (any version).
+gui_gtk2		Compiled with GTK+ 2 GUI (gui_gtk is also defined).
+gui_gtk3		Compiled with GTK+ 3 GUI (gui_gtk is also defined).
+gui_mac			Compiled with Macintosh GUI.
+gui_motif		Compiled with Motif GUI.
+gui_photon		Compiled with Photon GUI.
+gui_running		Vim is running in the GUI, or it will start soon.
+gui_win32		Compiled with MS Windows Win32 GUI.
+gui_win32s		idem, and Win32s system being used (Windows 3.1)
+hangul_input		Compiled with Hangul input support. |hangul|
+iconv			Can use iconv() for conversion.
+insert_expand		Compiled with support for CTRL-X expansion commands in
+			Insert mode.
+jumplist		Compiled with |jumplist| support.
+keymap			Compiled with 'keymap' support.
+lambda			Compiled with |lambda| support.
+langmap			Compiled with 'langmap' support.
+libcall			Compiled with |libcall()| support.
+linebreak		Compiled with 'linebreak', 'breakat', 'showbreak' and
+			'breakindent' support.
+lispindent		Compiled with support for lisp indenting.
+listcmds		Compiled with commands for the buffer list |:files|
+			and the argument list |arglist|.
+localmap		Compiled with local mappings and abbr. |:map-local|
+lua			Compiled with Lua interface |Lua|.
+mac			Any Macintosh version of Vim  cf. osx
+macunix			Synonym for osxdarwin
+menu			Compiled with support for |:menu|.
+mksession		Compiled with support for |:mksession|.
+modify_fname		Compiled with file name modifiers. |filename-modifiers|
+mouse			Compiled with support mouse.
+mouse_dec		Compiled with support for Dec terminal mouse.
+mouse_gpm		Compiled with support for gpm (Linux console mouse)
+mouse_netterm		Compiled with support for netterm mouse.
+mouse_pterm		Compiled with support for qnx pterm mouse.
+mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
+mouse_sgr		Compiled with support for sgr mouse.
+mouse_urxvt		Compiled with support for urxvt mouse.
+mouse_xterm		Compiled with support for xterm mouse.
+mouseshape		Compiled with support for 'mouseshape'.
+multi_byte		Compiled with support for 'encoding'
+multi_byte_encoding	'encoding' is set to a multi-byte encoding.
+multi_byte_ime		Compiled with support for IME input method.
+multi_lang		Compiled with support for multiple languages.
+mzscheme		Compiled with MzScheme interface |mzscheme|.
+netbeans_enabled	Compiled with support for |netbeans| and connected.
+netbeans_intg		Compiled with support for |netbeans|.
+num64			Compiled with 64-bit |Number| support.
+ole			Compiled with OLE automation support for Win32.
+osx			Compiled for macOS  cf. mac
+osxdarwin		Compiled for macOS, with |mac-darwin-feature|
+packages		Compiled with |packages| support.
+path_extra		Compiled with up/downwards search in 'path' and 'tags'
+perl			Compiled with Perl interface.
+persistent_undo		Compiled with support for persistent undo history.
+postscript		Compiled with PostScript file printing.
+printer			Compiled with |:hardcopy| support.
+profile			Compiled with |:profile| support.
+python			Python 2.x interface available. |has-python|
+python_compiled		Compiled with Python 2.x interface. |has-python|
+python_dynamic		Python 2.x interface is dynamically loaded. |has-python|
+python3			Python 3.x interface available. |has-python|
+python3_compiled	Compiled with Python 3.x interface. |has-python|
+python3_dynamic		Python 3.x interface is dynamically loaded. |has-python|
+pythonx			Compiled with |python_x| interface. |has-pythonx|
+qnx			QNX version of Vim.
+quickfix		Compiled with |quickfix| support.
+reltime			Compiled with |reltime()| support.
+rightleft		Compiled with 'rightleft' support.
+ruby			Compiled with Ruby interface |ruby|.
+scrollbind		Compiled with 'scrollbind' support.
+showcmd			Compiled with 'showcmd' support.
+signs			Compiled with |:sign| support.
+smartindent		Compiled with 'smartindent' support.
+spell			Compiled with spell checking support |spell|.
+startuptime		Compiled with |--startuptime| support.
+statusline		Compiled with support for 'statusline', 'rulerformat'
+			and special formats of 'titlestring' and 'iconstring'.
+sun_workshop		Compiled with support for Sun |workshop|.
+syntax			Compiled with syntax highlighting support |syntax|.
+syntax_items		There are active syntax highlighting items for the
+			current buffer.
+system			Compiled to use system() instead of fork()/exec().
+tag_binary		Compiled with binary searching in tags files
+			|tag-binary-search|.
+tag_old_static		Compiled with support for old static tags
+			|tag-old-static|.
+tag_any_white		Compiled with support for any white characters in tags
+			files |tag-any-white|.
+tcl			Compiled with Tcl interface.
+termguicolors		Compiled with true color in terminal support.
+terminal		Compiled with |terminal| support.
+terminfo		Compiled with terminfo instead of termcap.
+termresponse		Compiled with support for |t_RV| and |v:termresponse|.
+textobjects		Compiled with support for |text-objects|.
+tgetent			Compiled with tgetent support, able to use a termcap
+			or terminfo file.
+timers			Compiled with |timer_start()| support.
+title			Compiled with window title support |'title'|.
+toolbar			Compiled with support for |gui-toolbar|.
+ttyin			input is a terminal (tty)
+ttyout			output is a terminal (tty)
+unix			Unix version of Vim. *+unix*
+unnamedplus		Compiled with support for "unnamedplus" in 'clipboard'
+user_commands		User-defined commands.
+vcon			Win32: Virtual console support is working, can use
+			'termguicolors'. Also see |+vtp|.
+vertsplit		Compiled with vertically split windows |:vsplit|.
+vim_starting		True while initial source'ing takes place. |startup|
+			*vim_starting*
+viminfo			Compiled with viminfo support.
+virtualedit		Compiled with 'virtualedit' option.
+visual			Compiled with Visual mode.
+visualextra		Compiled with extra Visual mode commands.
+			|blockwise-operators|.
+vms			VMS version of Vim.
+vreplace		Compiled with |gR| and |gr| commands.
+vtp			Compiled for vcon support |+vtp| (check vcon to find
+			out if it works in the current console).
+wildignore		Compiled with 'wildignore' option.
+wildmenu		Compiled with 'wildmenu' option.
+win16			old version for MS-Windows 3.1 (always False)
+win32			Win32 version of Vim (MS-Windows 95 and later, 32 or
+			64 bits)
+win32unix		Win32 version of Vim, using Unix files (Cygwin)
+win64			Win64 version of Vim (MS-Windows 64 bit).
+win95			Win32 version for MS-Windows 95/98/ME (always False)
+winaltkeys		Compiled with 'winaltkeys' option.
+windows			Compiled with support for more than one window.
+writebackup		Compiled with 'writebackup' default on.
+xfontset		Compiled with X fontset support |xfontset|.
+xim			Compiled with X input method support |xim|.
+xpm			Compiled with pixmap support.
+xpm_w32			Compiled with pixmap support for Win32. (Only for
+			backward compatibility. Use "xpm" instead.)
+xsmp			Compiled with X session management support.
+xsmp_interact		Compiled with interactive X session management support.
+xterm_clipboard		Compiled with support for xterm clipboard.
+xterm_save		Compiled with support for saving and restoring the
+			xterm screen.
+x11			Compiled with X11 support.
+
+							*string-match*
+Matching a pattern in a String
+
+A regexp pattern as explained at |pattern| is normally used to find a match in
+the buffer lines.  When a pattern is used to find a match in a String, almost
+everything works in the same way.  The difference is that a String is handled
+like it is one line.  When it contains a "\n" character, this is not seen as a
+line break for the pattern.  It can be matched with a "\n" in the pattern, or
+with ".".  Example: >
+	:let a = "aaaa\nxxxx"
+	:echo matchstr(a, "..\n..")
+	aa
+	xx
+	:echo matchstr(a, "a.x")
+	a
+	x
+
+Don't forget that "^" will only match at the first character of the String and
+"$" at the last character of the string.  They don't match after or before a
+"\n".
+
+==============================================================================
+5. Defining functions					*user-functions*
+
+New functions can be defined.  These can be called just like builtin
+functions.  The function executes a sequence of Ex commands.  Normal mode
+commands can be executed with the |:normal| command.
+
+The function name must start with an uppercase letter, to avoid confusion with
+builtin functions.  To prevent from using the same name in different scripts
+avoid obvious, short names.  A good habit is to start the function name with
+the name of the script, e.g., "HTMLcolor()".
+
+It's also possible to use curly braces, see |curly-braces-names|.  And the
+|autoload| facility is useful to define a function only when it's called.
+
+							*local-function*
+A function local to a script must start with "s:".  A local script function
+can only be called from within the script and from functions, user commands
+and autocommands defined in the script.  It is also possible to call the
+function from a mapping defined in the script, but then |<SID>| must be used
+instead of "s:" when the mapping is expanded outside of the script.
+There are only script-local functions, no buffer-local or window-local
+functions.
+
+					*:fu* *:function* *E128* *E129* *E123*
+:fu[nction]		List all functions and their arguments.
+
+:fu[nction] {name}	List function {name}.
+			{name} can also be a |Dictionary| entry that is a
+			|Funcref|: >
+				:function dict.init
+
+:fu[nction] /{pattern}	List functions with a name matching {pattern}.
+			Example that lists all functions ending with "File": >
+				:function /File$
+<
+							*:function-verbose*
+When 'verbose' is non-zero, listing a function will also display where it was
+last defined. Example: >
+
+    :verbose function SetFileTypeSH
+	function SetFileTypeSH(name)
+	    Last set from /usr/share/vim/vim-7.0/filetype.vim
+<
+See |:verbose-cmd| for more information.
+
+						*E124* *E125* *E853* *E884*
+:fu[nction][!] {name}([arguments]) [range] [abort] [dict] [closure]
+			Define a new function by the name {name}.  The body of
+			the function follows in the next lines, until the
+			matching |:endfunction|.
+
+			The name must be made of alphanumeric characters and
+			'_', and must start with a capital or "s:" (see
+			above).  Note that using "b:" or "g:" is not allowed.
+			(since patch 7.4.260 E884 is given if the function
+			name has a colon in the name, e.g. for "foo:bar()".
+			Before that patch no error was given).
+
+			{name} can also be a |Dictionary| entry that is a
+			|Funcref|: >
+				:function dict.init(arg)
+<			"dict" must be an existing dictionary.  The entry
+			"init" is added if it didn't exist yet.  Otherwise [!]
+			is required to overwrite an existing function.  The
+			result is a |Funcref| to a numbered function.  The
+			function can only be used with a |Funcref| and will be
+			deleted if there are no more references to it.
+								*E127* *E122*
+			When a function by this name already exists and [!] is
+			not used an error message is given.  When [!] is used,
+			an existing function is silently replaced.  Unless it
+			is currently being executed, that is an error.
+			NOTE: Use ! wisely.  If used without care it can cause
+			an existing function to be replaced unexpectedly,
+			which is hard to debug.
+
+			For the {arguments} see |function-argument|.
+
+					*:func-range* *a:firstline* *a:lastline*
+			When the [range] argument is added, the function is
+			expected to take care of a range itself.  The range is
+			passed as "a:firstline" and "a:lastline".  If [range]
+			is excluded, ":{range}call" will call the function for
+			each line in the range, with the cursor on the start
+			of each line.  See |function-range-example|.
+			The cursor is still moved to the first line of the
+			range, as is the case with all Ex commands.
+								*:func-abort*
+			When the [abort] argument is added, the function will
+			abort as soon as an error is detected.
+								*:func-dict*
+			When the [dict] argument is added, the function must
+			be invoked through an entry in a |Dictionary|.  The
+			local variable "self" will then be set to the
+			dictionary.  See |Dictionary-function|.
+						*:func-closure* *E932*
+			When the [closure] argument is added, the function
+			can access variables and arguments from the outer
+			scope.  This is usually called a closure.  In this
+			example Bar() uses "x" from the scope of Foo().  It
+			remains referenced even after Foo() returns: >
+				:function! Foo()
+				:  let x = 0
+				:  function! Bar() closure
+				:    let x += 1
+				:    return x
+				:  endfunction
+				:  return funcref('Bar')
+				:endfunction
+
+				:let F = Foo()
+				:echo F()
+<				1 >
+				:echo F()
+<				2 >
+				:echo F()
+<				3
+
+						*function-search-undo*
+			The last used search pattern and the redo command "."
+			will not be changed by the function.  This also
+			implies that the effect of |:nohlsearch| is undone
+			when the function returns.
+
+				*:endf* *:endfunction* *E126* *E193* *W22*
+:endf[unction] [argument]
+			The end of a function definition.  Best is to put it
+			on a line by its own, without [argument].
+
+			[argument] can be:
+				| command	command to execute next
+				\n command	command to execute next
+				" comment	always ignored
+				anything else	ignored, warning given when
+						'verbose' is non-zero
+			The support for a following command was added in Vim
+			8.0.0654, before that any argument was silently
+			ignored.
+
+			To be able to define a function inside an `:execute`
+			command, use line breaks instead of |:bar|: >
+				:exe "func Foo()\necho 'foo'\nendfunc"
+<
+				*:delf* *:delfunction* *E130* *E131* *E933*
+:delf[unction][!] {name}
+			Delete function {name}.
+			{name} can also be a |Dictionary| entry that is a
+			|Funcref|: >
+				:delfunc dict.init
+<			This will remove the "init" entry from "dict".  The
+			function is deleted if there are no more references to
+			it.
+			With the ! there is no error if the function does not
+			exist.
+							*:retu* *:return* *E133*
+:retu[rn] [expr]	Return from a function.  When "[expr]" is given, it is
+			evaluated and returned as the result of the function.
+			If "[expr]" is not given, the number 0 is returned.
+			When a function ends without an explicit ":return",
+			the number 0 is returned.
+			Note that there is no check for unreachable lines,
+			thus there is no warning if commands follow ":return".
+
+			If the ":return" is used after a |:try| but before the
+			matching |:finally| (if present), the commands
+			following the ":finally" up to the matching |:endtry|
+			are executed first.  This process applies to all
+			nested ":try"s inside the function.  The function
+			returns at the outermost ":endtry".
+
+						*function-argument* *a:var*
+An argument can be defined by giving its name.  In the function this can then
+be used as "a:name" ("a:" for argument).
+					*a:0* *a:1* *a:000* *E740* *...*
+Up to 20 arguments can be given, separated by commas.  After the named
+arguments an argument "..." can be specified, which means that more arguments
+may optionally be following.  In the function the extra arguments can be used
+as "a:1", "a:2", etc.  "a:0" is set to the number of extra arguments (which
+can be 0).  "a:000" is set to a |List| that contains these arguments.  Note
+that "a:1" is the same as "a:000[0]".
+								*E742*
+The a: scope and the variables in it cannot be changed, they are fixed.
+However, if a composite type is used, such as |List| or |Dictionary| , you can
+change their contents.  Thus you can pass a |List| to a function and have the
+function add an item to it.  If you want to make sure the function cannot
+change a |List| or |Dictionary| use |:lockvar|.
+
+When not using "...", the number of arguments in a function call must be equal
+to the number of named arguments.  When using "...", the number of arguments
+may be larger.
+
+It is also possible to define a function without any arguments.  You must
+still supply the () then.
+
+It is allowed to define another function inside a function body.
+
+							*local-variables*
+Inside a function local variables can be used.  These will disappear when the
+function returns.  Global variables need to be accessed with "g:".
+
+Example: >
+  :function Table(title, ...)
+  :  echohl Title
+  :  echo a:title
+  :  echohl None
+  :  echo a:0 . " items:"
+  :  for s in a:000
+  :    echon ' ' . s
+  :  endfor
+  :endfunction
+
+This function can then be called with: >
+  call Table("Table", "line1", "line2")
+  call Table("Empty Table")
+
+To return more than one value, return a |List|: >
+  :function Compute(n1, n2)
+  :  if a:n2 == 0
+  :    return ["fail", 0]
+  :  endif
+  :  return ["ok", a:n1 / a:n2]
+  :endfunction
+
+This function can then be called with: >
+  :let [success, div] = Compute(102, 6)
+  :if success == "ok"
+  :  echo div
+  :endif
+<
+						*:cal* *:call* *E107* *E117*
+:[range]cal[l] {name}([arguments])
+		Call a function.  The name of the function and its arguments
+		are as specified with |:function|.  Up to 20 arguments can be
+		used.  The returned value is discarded.
+		Without a range and for functions that accept a range, the
+		function is called once.  When a range is given the cursor is
+		positioned at the start of the first line before executing the
+		function.
+		When a range is given and the function doesn't handle it
+		itself, the function is executed for each line in the range,
+		with the cursor in the first column of that line.  The cursor
+		is left at the last line (possibly moved by the last function
+		call).  The arguments are re-evaluated for each line.  Thus
+		this works:
+						*function-range-example*  >
+	:function Mynumber(arg)
+	:  echo line(".") . " " . a:arg
+	:endfunction
+	:1,5call Mynumber(getline("."))
+<
+		The "a:firstline" and "a:lastline" are defined anyway, they
+		can be used to do something different at the start or end of
+		the range.
+
+		Example of a function that handles the range itself: >
+
+	:function Cont() range
+	:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '
+	:endfunction
+	:4,8call Cont()
+<
+		This function inserts the continuation character "\" in front
+		of all the lines in the range, except the first one.
+
+		When the function returns a composite value it can be further
+		dereferenced, but the range will not be used then.  Example: >
+	:4,8call GetDict().method()
+<		Here GetDict() gets the range but method() does not.
+
+								*E132*
+The recursiveness of user functions is restricted with the |'maxfuncdepth'|
+option.
+
+
+AUTOMATICALLY LOADING FUNCTIONS ~
+							*autoload-functions*
+When using many or large functions, it's possible to automatically define them
+only when they are used.  There are two methods: with an autocommand and with
+the "autoload" directory in 'runtimepath'.
+
+
+Using an autocommand ~
+
+This is introduced in the user manual, section |41.14|.
+
+The autocommand is useful if you have a plugin that is a long Vim script file.
+You can define the autocommand and quickly quit the script with |:finish|.
+That makes Vim startup faster.  The autocommand should then load the same file
+again, setting a variable to skip the |:finish| command.
+
+Use the FuncUndefined autocommand event with a pattern that matches the
+function(s) to be defined.  Example: >
+
+	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim
+
+The file "~/vim/bufnetfuncs.vim" should then define functions that start with
+"BufNet".  Also see |FuncUndefined|.
+
+
+Using an autoload script ~
+							*autoload* *E746*
+This is introduced in the user manual, section |41.15|.
+
+Using a script in the "autoload" directory is simpler, but requires using
+exactly the right file name.  A function that can be autoloaded has a name
+like this: >
+
+	:call filename#funcname()
+
+When such a function is called, and it is not defined yet, Vim will search the
+"autoload" directories in 'runtimepath' for a script file called
+"filename.vim".  For example "~/.vim/autoload/filename.vim".  That file should
+then define the function like this: >
+
+	function filename#funcname()
+	   echo "Done!"
+	endfunction
+
+The file name and the name used before the # in the function must match
+exactly, and the defined function must have the name exactly as it will be
+called.
+
+It is possible to use subdirectories.  Every # in the function name works like
+a path separator.  Thus when calling a function: >
+
+	:call foo#bar#func()
+
+Vim will look for the file "autoload/foo/bar.vim" in 'runtimepath'.
+
+This also works when reading a variable that has not been set yet: >
+
+	:let l = foo#bar#lvar
+
+However, when the autoload script was already loaded it won't be loaded again
+for an unknown variable.
+
+When assigning a value to such a variable nothing special happens.  This can
+be used to pass settings to the autoload script before it's loaded: >
+
+	:let foo#bar#toggle = 1
+	:call foo#bar#func()
+
+Note that when you make a mistake and call a function that is supposed to be
+defined in an autoload script, but the script doesn't actually define the
+function, the script will be sourced every time you try to call the function.
+And you will get an error message every time.
+
+Also note that if you have two script files, and one calls a function in the
+other and vice versa, before the used function is defined, it won't work.
+Avoid using the autoload functionality at the toplevel.
+
+Hint: If you distribute a bunch of scripts you can pack them together with the
+|vimball| utility.  Also read the user manual |distribute-script|.
+
+==============================================================================
+6. Curly braces names					*curly-braces-names*
+
+In most places where you can use a variable, you can use a "curly braces name"
+variable.  This is a regular variable name with one or more expressions
+wrapped in braces {} like this: >
+	my_{adjective}_variable
+
+When Vim encounters this, it evaluates the expression inside the braces, puts
+that in place of the expression, and re-interprets the whole as a variable
+name.  So in the above example, if the variable "adjective" was set to
+"noisy", then the reference would be to "my_noisy_variable", whereas if
+"adjective" was set to "quiet", then it would be to "my_quiet_variable".
+
+One application for this is to create a set of variables governed by an option
+value.  For example, the statement >
+	echo my_{&background}_message
+
+would output the contents of "my_dark_message" or "my_light_message" depending
+on the current value of 'background'.
+
+You can use multiple brace pairs: >
+	echo my_{adverb}_{adjective}_message
+..or even nest them: >
+	echo my_{ad{end_of_word}}_message
+where "end_of_word" is either "verb" or "jective".
+
+However, the expression inside the braces must evaluate to a valid single
+variable name, e.g. this is invalid: >
+	:let foo='a + b'
+	:echo c{foo}d
+.. since the result of expansion is "ca + bd", which is not a variable name.
+
+						*curly-braces-function-names*
+You can call and define functions by an evaluated name in a similar way.
+Example: >
+	:let func_end='whizz'
+	:call my_func_{func_end}(parameter)
+
+This would call the function "my_func_whizz(parameter)".
+
+This does NOT work: >
+  :let i = 3
+  :let @{i} = ''  " error
+  :echo @{i}      " error
+
+==============================================================================
+7. Commands						*expression-commands*
+
+:let {var-name} = {expr1}				*:let* *E18*
+			Set internal variable {var-name} to the result of the
+			expression {expr1}.  The variable will get the type
+			from the {expr}.  If {var-name} didn't exist yet, it
+			is created.
+
+:let {var-name}[{idx}] = {expr1}			*E689*
+			Set a list item to the result of the expression
+			{expr1}.  {var-name} must refer to a list and {idx}
+			must be a valid index in that list.  For nested list
+			the index can be repeated.
+			This cannot be used to add an item to a |List|.
+			This cannot be used to set a byte in a String.  You
+			can do that like this: >
+				:let var = var[0:2] . 'X' . var[4:]
+<
+							*E711* *E719*
+:let {var-name}[{idx1}:{idx2}] = {expr1}		*E708* *E709* *E710*
+			Set a sequence of items in a |List| to the result of
+			the expression {expr1}, which must be a list with the
+			correct number of items.
+			{idx1} can be omitted, zero is used instead.
+			{idx2} can be omitted, meaning the end of the list.
+			When the selected range of items is partly past the
+			end of the list, items will be added.
+
+					*:let+=* *:let-=* *:let.=* *E734*
+:let {var} += {expr1}	Like ":let {var} = {var} + {expr1}".
+:let {var} -= {expr1}	Like ":let {var} = {var} - {expr1}".
+:let {var} .= {expr1}	Like ":let {var} = {var} . {expr1}".
+			These fail if {var} was not set yet and when the type
+			of {var} and {expr1} don't fit the operator.
+
+
+:let ${env-name} = {expr1}			*:let-environment* *:let-$*
+			Set environment variable {env-name} to the result of
+			the expression {expr1}.  The type is always String.
+:let ${env-name} .= {expr1}
+			Append {expr1} to the environment variable {env-name}.
+			If the environment variable didn't exist yet this
+			works like "=".
+
+:let @{reg-name} = {expr1}			*:let-register* *:let-@*
+			Write the result of the expression {expr1} in register
+			{reg-name}.  {reg-name} must be a single letter, and
+			must be the name of a writable register (see
+			|registers|).  "@@" can be used for the unnamed
+			register, "@/" for the search pattern.
+			If the result of {expr1} ends in a <CR> or <NL>, the
+			register will be linewise, otherwise it will be set to
+			characterwise.
+			This can be used to clear the last search pattern: >
+				:let @/ = ""
+<			This is different from searching for an empty string,
+			that would match everywhere.
+
+:let @{reg-name} .= {expr1}
+			Append {expr1} to register {reg-name}.  If the
+			register was empty it's like setting it to {expr1}.
+
+:let &{option-name} = {expr1}			*:let-option* *:let-&*
+			Set option {option-name} to the result of the
+			expression {expr1}.  A String or Number value is
+			always converted to the type of the option.
+			For an option local to a window or buffer the effect
+			is just like using the |:set| command: both the local
+			value and the global value are changed.
+			Example: >
+				:let &path = &path . ',/usr/local/include'
+<			This also works for terminal codes in the form t_xx.
+			But only for alphanumerical names.  Example: >
+				:let &t_k1 = "\<Esc>[234;"
+<			When the code does not exist yet it will be created as
+			a terminal key code, there is no error.
+
+:let &{option-name} .= {expr1}
+			For a string option: Append {expr1} to the value.
+			Does not insert a comma like |:set+=|.
+
+:let &{option-name} += {expr1}
+:let &{option-name} -= {expr1}
+			For a number or boolean option: Add or subtract
+			{expr1}.
+
+:let &l:{option-name} = {expr1}
+:let &l:{option-name} .= {expr1}
+:let &l:{option-name} += {expr1}
+:let &l:{option-name} -= {expr1}
+			Like above, but only set the local value of an option
+			(if there is one).  Works like |:setlocal|.
+
+:let &g:{option-name} = {expr1}
+:let &g:{option-name} .= {expr1}
+:let &g:{option-name} += {expr1}
+:let &g:{option-name} -= {expr1}
+			Like above, but only set the global value of an option
+			(if there is one).  Works like |:setglobal|.
+
+:let [{name1}, {name2}, ...] = {expr1}		*:let-unpack* *E687* *E688*
+			{expr1} must evaluate to a |List|.  The first item in
+			the list is assigned to {name1}, the second item to
+			{name2}, etc.
+			The number of names must match the number of items in
+			the |List|.
+			Each name can be one of the items of the ":let"
+			command as mentioned above.
+			Example: >
+				:let [s, item] = GetItem(s)
+<			Detail: {expr1} is evaluated first, then the
+			assignments are done in sequence.  This matters if
+			{name2} depends on {name1}.  Example: >
+				:let x = [0, 1]
+				:let i = 0
+				:let [i, x[i]] = [1, 2]
+				:echo x
+<			The result is [0, 2].
+
+:let [{name1}, {name2}, ...] .= {expr1}
+:let [{name1}, {name2}, ...] += {expr1}
+:let [{name1}, {name2}, ...] -= {expr1}
+			Like above, but append/add/subtract the value for each
+			|List| item.
+
+:let [{name}, ..., ; {lastname}] = {expr1}
+			Like |:let-unpack| above, but the |List| may have more
+			items than there are names.  A list of the remaining
+			items is assigned to {lastname}.  If there are no
+			remaining items {lastname} is set to an empty list.
+			Example: >
+				:let [a, b; rest] = ["aval", "bval", 3, 4]
+<
+:let [{name}, ..., ; {lastname}] .= {expr1}
+:let [{name}, ..., ; {lastname}] += {expr1}
+:let [{name}, ..., ; {lastname}] -= {expr1}
+			Like above, but append/add/subtract the value for each
+			|List| item.
+
+								*E121*
+:let {var-name}	..	List the value of variable {var-name}.  Multiple
+			variable names may be given.  Special names recognized
+			here:				*E738*
+			  g:	global variables
+			  b:	local buffer variables
+			  w:	local window variables
+			  t:	local tab page variables
+			  s:	script-local variables
+			  l:	local function variables
+			  v:	Vim variables.
+
+:let			List the values of all variables.  The type of the
+			variable is indicated before the value:
+			    <nothing>	String
+				#	Number
+				*	Funcref
+
+
+:unl[et][!] {name} ...				*:unlet* *:unl* *E108* *E795*
+			Remove the internal variable {name}.  Several variable
+			names can be given, they are all removed.  The name
+			may also be a |List| or |Dictionary| item.
+			With [!] no error message is given for non-existing
+			variables.
+			One or more items from a |List| can be removed: >
+				:unlet list[3]	  " remove fourth item
+				:unlet list[3:]   " remove fourth item to last
+<			One item from a |Dictionary| can be removed at a time: >
+				:unlet dict['two']
+				:unlet dict.two
+<			This is especially useful to clean up used global
+			variables and script-local variables (these are not
+			deleted when the script ends).  Function-local
+			variables are automatically deleted when the function
+			ends.
+
+:unl[et] ${env-name} ...			*:unlet-environment* *:unlet-$*
+			Remove environment variable {env-name}.
+			Can mix {name} and ${env-name} in one :unlet command.
+			No error message is given for a non-existing
+			variable, also without !.
+			If the system does not support deleting an environment
+			variable, it is made emtpy.
+
+:lockv[ar][!] [depth] {name} ...			*:lockvar* *:lockv*
+			Lock the internal variable {name}.  Locking means that
+			it can no longer be changed (until it is unlocked).
+			A locked variable can be deleted: >
+				:lockvar v
+				:let v = 'asdf'		" fails!
+				:unlet v
+<							*E741* *E940*
+			If you try to change a locked variable you get an
+			error message: "E741: Value is locked: {name}".
+			If you try to lock or unlock a built-in variable you
+			get an error message: "E940: Cannot lock or unlock
+			variable {name}".
+
+			[depth] is relevant when locking a |List| or
+			|Dictionary|.  It specifies how deep the locking goes:
+				1	Lock the |List| or |Dictionary| itself,
+					cannot add or remove items, but can
+					still change their values.
+				2	Also lock the values, cannot change
+					the items.  If an item is a |List| or
+					|Dictionary|, cannot add or remove
+					items, but can still change the
+					values.
+				3	Like 2 but for the |List| /
+					|Dictionary| in the |List| /
+					|Dictionary|, one level deeper.
+			The default [depth] is 2, thus when {name} is a |List|
+			or |Dictionary| the values cannot be changed.
+								*E743*
+			For unlimited depth use [!] and omit [depth].
+			However, there is a maximum depth of 100 to catch
+			loops.
+
+			Note that when two variables refer to the same |List|
+			and you lock one of them, the |List| will also be
+			locked when used through the other variable.
+			Example: >
+				:let l = [0, 1, 2, 3]
+				:let cl = l
+				:lockvar l
+				:let cl[1] = 99		" won't work!
+<			You may want to make a copy of a list to avoid this.
+			See |deepcopy()|.
+
+
+:unlo[ckvar][!] [depth] {name} ...			*:unlockvar* *:unlo*
+			Unlock the internal variable {name}.  Does the
+			opposite of |:lockvar|.
+
+
+:if {expr1}			*:if* *:endif* *:en* *E171* *E579* *E580*
+:en[dif]		Execute the commands until the next matching ":else"
+			or ":endif" if {expr1} evaluates to non-zero.
+
+			From Vim version 4.5 until 5.0, every Ex command in
+			between the ":if" and ":endif" is ignored.  These two
+			commands were just to allow for future expansions in a
+			backward compatible way.  Nesting was allowed.  Note
+			that any ":else" or ":elseif" was ignored, the "else"
+			part was not executed either.
+
+			You can use this to remain compatible with older
+			versions: >
+				:if version >= 500
+				:  version-5-specific-commands
+				:endif
+<			The commands still need to be parsed to find the
+			"endif".  Sometimes an older Vim has a problem with a
+			new command.  For example, ":silent" is recognized as
+			a ":substitute" command.  In that case ":execute" can
+			avoid problems: >
+				:if version >= 600
+				:  execute "silent 1,$delete"
+				:endif
+<
+			NOTE: The ":append" and ":insert" commands don't work
+			properly in between ":if" and ":endif".
+
+						*:else* *:el* *E581* *E583*
+:el[se]			Execute the commands until the next matching ":else"
+			or ":endif" if they previously were not being
+			executed.
+
+					*:elseif* *:elsei* *E582* *E584*
+:elsei[f] {expr1}	Short for ":else" ":if", with the addition that there
+			is no extra ":endif".
+
+:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
+						*E170* *E585* *E588* *E733*
+:endw[hile]		Repeat the commands between ":while" and ":endwhile",
+			as long as {expr1} evaluates to non-zero.
+			When an error is detected from a command inside the
+			loop, execution continues after the "endwhile".
+			Example: >
+				:let lnum = 1
+				:while lnum <= line("$")
+				   :call FixLine(lnum)
+				   :let lnum = lnum + 1
+				:endwhile
+<
+			NOTE: The ":append" and ":insert" commands don't work
+			properly inside a ":while" and ":for" loop.
+
+:for {var} in {list}					*:for* *E690* *E732*
+:endfo[r]						*:endfo* *:endfor*
+			Repeat the commands between ":for" and ":endfor" for
+			each item in {list}.  Variable {var} is set to the
+			value of each item.
+			When an error is detected for a command inside the
+			loop, execution continues after the "endfor".
+			Changing {list} inside the loop affects what items are
+			used.  Make a copy if this is unwanted: >
+				:for item in copy(mylist)
+<			When not making a copy, Vim stores a reference to the
+			next item in the list, before executing the commands
+			with the current item.  Thus the current item can be
+			removed without effect.  Removing any later item means
+			it will not be found.  Thus the following example
+			works (an inefficient way to make a list empty): >
+				for item in mylist
+				   call remove(mylist, 0)
+				endfor
+<			Note that reordering the list (e.g., with sort() or
+			reverse()) may have unexpected effects.
+
+:for [{var1}, {var2}, ...] in {listlist}
+:endfo[r]
+			Like ":for" above, but each item in {listlist} must be
+			a list, of which each item is assigned to {var1},
+			{var2}, etc.  Example: >
+				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]
+				   :echo getline(lnum)[col]
+				:endfor
+<
+						*:continue* *:con* *E586*
+:con[tinue]		When used inside a ":while" or ":for" loop, jumps back
+			to the start of the loop.
+			If it is used after a |:try| inside the loop but
+			before the matching |:finally| (if present), the
+			commands following the ":finally" up to the matching
+			|:endtry| are executed first.  This process applies to
+			all nested ":try"s inside the loop.  The outermost
+			":endtry" then jumps back to the start of the loop.
+
+						*:break* *:brea* *E587*
+:brea[k]		When used inside a ":while" or ":for" loop, skips to
+			the command after the matching ":endwhile" or
+			":endfor".
+			If it is used after a |:try| inside the loop but
+			before the matching |:finally| (if present), the
+			commands following the ":finally" up to the matching
+			|:endtry| are executed first.  This process applies to
+			all nested ":try"s inside the loop.  The outermost
+			":endtry" then jumps to the command after the loop.
+
+:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
+:endt[ry]		Change the error handling for the commands between
+			":try" and ":endtry" including everything being
+			executed across ":source" commands, function calls,
+			or autocommand invocations.
+
+			When an error or interrupt is detected and there is
+			a |:finally| command following, execution continues
+			after the ":finally".  Otherwise, or when the
+			":endtry" is reached thereafter, the next
+			(dynamically) surrounding ":try" is checked for
+			a corresponding ":finally" etc.  Then the script
+			processing is terminated.  (Whether a function
+			definition has an "abort" argument does not matter.)
+			Example: >
+		:try | edit too much | finally | echo "cleanup" | endtry
+		:echo "impossible"	" not reached, script terminated above
+<
+			Moreover, an error or interrupt (dynamically) inside
+			":try" and ":endtry" is converted to an exception.  It
+			can be caught as if it were thrown by a |:throw|
+			command (see |:catch|).  In this case, the script
+			processing is not terminated.
+
+			The value "Vim:Interrupt" is used for an interrupt
+			exception.  An error in a Vim command is converted
+			to a value of the form "Vim({command}):{errmsg}",
+			other errors are converted to a value of the form
+			"Vim:{errmsg}".  {command} is the full command name,
+			and {errmsg} is the message that is displayed if the
+			error exception is not caught, always beginning with
+			the error number.
+			Examples: >
+		:try | sleep 100 | catch /^Vim:Interrupt$/ | endtry
+		:try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry
+<
+					*:cat* *:catch* *E603* *E604* *E605*
+:cat[ch] /{pattern}/	The following commands until the next |:catch|,
+			|:finally|, or |:endtry| that belongs to the same
+			|:try| as the ":catch" are executed when an exception
+			matching {pattern} is being thrown and has not yet
+			been caught by a previous ":catch".  Otherwise, these
+			commands are skipped.
+			When {pattern} is omitted all errors are caught.
+			Examples: >
+		:catch /^Vim:Interrupt$/	" catch interrupts (CTRL-C)
+		:catch /^Vim\%((\a\+)\)\=:E/	" catch all Vim errors
+		:catch /^Vim\%((\a\+)\)\=:/	" catch errors and interrupts
+		:catch /^Vim(write):/		" catch all errors in :write
+		:catch /^Vim\%((\a\+)\)\=:E123/	" catch error E123
+		:catch /my-exception/		" catch user exception
+		:catch /.*/			" catch everything
+		:catch				" same as /.*/
+<
+			Another character can be used instead of / around the
+			{pattern}, so long as it does not have a special
+			meaning (e.g., '|' or '"') and doesn't occur inside
+			{pattern}.
+			Information about the exception is available in
+			|v:exception|.  Also see |throw-variables|.
+			NOTE: It is not reliable to ":catch" the TEXT of
+			an error message because it may vary in different
+			locales.
+
+					*:fina* *:finally* *E606* *E607*
+:fina[lly]		The following commands until the matching |:endtry|
+			are executed whenever the part between the matching
+			|:try| and the ":finally" is left:  either by falling
+			through to the ":finally" or by a |:continue|,
+			|:break|, |:finish|, or |:return|, or by an error or
+			interrupt or exception (see |:throw|).
+
+							*:th* *:throw* *E608*
+:th[row] {expr1}	The {expr1} is evaluated and thrown as an exception.
+			If the ":throw" is used after a |:try| but before the
+			first corresponding |:catch|, commands are skipped
+			until the first ":catch" matching {expr1} is reached.
+			If there is no such ":catch" or if the ":throw" is
+			used after a ":catch" but before the |:finally|, the
+			commands following the ":finally" (if present) up to
+			the matching |:endtry| are executed.  If the ":throw"
+			is after the ":finally", commands up to the ":endtry"
+			are skipped.  At the ":endtry", this process applies
+			again for the next dynamically surrounding ":try"
+			(which may be found in a calling function or sourcing
+			script), until a matching ":catch" has been found.
+			If the exception is not caught, the command processing
+			is terminated.
+			Example: >
+		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry
+<			Note that "catch" may need to be on a separate line
+			for when an error causes the parsing to skip the whole
+			line and not see the "|" that separates the commands.
+
+							*:ec* *:echo*
+:ec[ho] {expr1} ..	Echoes each {expr1}, with a space in between.  The
+			first {expr1} starts on a new line.
+			Also see |:comment|.
+			Use "\n" to start a new line.  Use "\r" to move the
+			cursor to the first column.
+			Uses the highlighting set by the |:echohl| command.
+			Cannot be followed by a comment.
+			Example: >
+		:echo "the value of 'shell' is" &shell
+<							*:echo-redraw*
+			A later redraw may make the message disappear again.
+			And since Vim mostly postpones redrawing until it's
+			finished with a sequence of commands this happens
+			quite often.  To avoid that a command from before the
+			":echo" causes a redraw afterwards (redraws are often
+			postponed until you type something), force a redraw
+			with the |:redraw| command.  Example: >
+		:new | redraw | echo "there is a new window"
+<
+							*:echon*
+:echon {expr1} ..	Echoes each {expr1}, without anything added.  Also see
+			|:comment|.
+			Uses the highlighting set by the |:echohl| command.
+			Cannot be followed by a comment.
+			Example: >
+				:echon "the value of 'shell' is " &shell
+<
+			Note the difference between using ":echo", which is a
+			Vim command, and ":!echo", which is an external shell
+			command: >
+		:!echo %		--> filename
+<			The arguments of ":!" are expanded, see |:_%|. >
+		:!echo "%"		--> filename or "filename"
+<			Like the previous example.  Whether you see the double
+			quotes or not depends on your 'shell'. >
+		:echo %			--> nothing
+<			The '%' is an illegal character in an expression. >
+		:echo "%"		--> %
+<			This just echoes the '%' character. >
+		:echo expand("%")	--> filename
+<			This calls the expand() function to expand the '%'.
+
+							*:echoh* *:echohl*
+:echoh[l] {name}	Use the highlight group {name} for the following
+			|:echo|, |:echon| and |:echomsg| commands.  Also used
+			for the |input()| prompt.  Example: >
+		:echohl WarningMsg | echo "Don't panic!" | echohl None
+<			Don't forget to set the group back to "None",
+			otherwise all following echo's will be highlighted.
+
+							*:echom* *:echomsg*
+:echom[sg] {expr1} ..	Echo the expression(s) as a true message, saving the
+			message in the |message-history|.
+			Spaces are placed between the arguments as with the
+			|:echo| command.  But unprintable characters are
+			displayed, not interpreted.
+			The parsing works slightly different from |:echo|,
+			more like |:execute|.  All the expressions are first
+			evaluated and concatenated before echoing anything.
+			The expressions must evaluate to a Number or String, a
+			Dictionary or List causes an error.
+			Uses the highlighting set by the |:echohl| command.
+			Example: >
+		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."
+<			See |:echo-redraw| to avoid the message disappearing
+			when the screen is redrawn.
+							*:echoe* *:echoerr*
+:echoe[rr] {expr1} ..	Echo the expression(s) as an error message, saving the
+			message in the |message-history|.  When used in a
+			script or function the line number will be added.
+			Spaces are placed between the arguments as with the
+			:echo command.  When used inside a try conditional,
+			the message is raised as an error exception instead
+			(see |try-echoerr|).
+			Example: >
+		:echoerr "This script just failed!"
+<			If you just want a highlighted message use |:echohl|.
+			And to get a beep: >
+		:exe "normal \<Esc>"
+<
+							*:exe* *:execute*
+:exe[cute] {expr1} ..	Executes the string that results from the evaluation
+			of {expr1} as an Ex command.
+			Multiple arguments are concatenated, with a space in
+			between.  To avoid the extra space use the "."
+			operator to concatenate strings into one argument.
+			{expr1} is used as the processed command, command line
+			editing keys are not recognized.
+			Cannot be followed by a comment.
+			Examples: >
+		:execute "buffer" nextbuf
+		:execute "normal" count . "w"
+<
+			":execute" can be used to append a command to commands
+			that don't accept a '|'.  Example: >
+		:execute '!ls' | echo "theend"
+
+<			":execute" is also a nice way to avoid having to type
+			control characters in a Vim script for a ":normal"
+			command: >
+		:execute "normal ixxx\<Esc>"
+<			This has an <Esc> character, see |expr-string|.
+
+			Be careful to correctly escape special characters in
+			file names.  The |fnameescape()| function can be used
+			for Vim commands, |shellescape()| for |:!| commands.
+			Examples: >
+		:execute "e " . fnameescape(filename)
+		:execute "!ls " . shellescape(filename, 1)
+<
+			Note: The executed string may be any command-line, but
+			starting or ending "if", "while" and "for" does not
+			always work, because when commands are skipped the
+			":execute" is not evaluated and Vim loses track of
+			where blocks start and end.  Also "break" and
+			"continue" should not be inside ":execute".
+			This example does not work, because the ":execute" is
+			not evaluated and Vim does not see the "while", and
+			gives an error for finding an ":endwhile": >
+		:if 0
+		: execute 'while i > 5'
+		:  echo "test"
+		: endwhile
+		:endif
+<
+			It is allowed to have a "while" or "if" command
+			completely in the executed string: >
+		:execute 'while i < 5 | echo i | let i = i + 1 | endwhile'
+<
+
+							*:exe-comment*
+			":execute", ":echo" and ":echon" cannot be followed by
+			a comment directly, because they see the '"' as the
+			start of a string.  But, you can use '|' followed by a
+			comment.  Example: >
+		:echo "foo" | "this is a comment
+
+==============================================================================
+8. Exception handling					*exception-handling*
+
+The Vim script language comprises an exception handling feature.  This section
+explains how it can be used in a Vim script.
+
+Exceptions may be raised by Vim on an error or on interrupt, see
+|catch-errors| and |catch-interrupt|.  You can also explicitly throw an
+exception by using the ":throw" command, see |throw-catch|.
+
+
+TRY CONDITIONALS					*try-conditionals*
+
+Exceptions can be caught or can cause cleanup code to be executed.  You can
+use a try conditional to specify catch clauses (that catch exceptions) and/or
+a finally clause (to be executed for cleanup).
+   A try conditional begins with a |:try| command and ends at the matching
+|:endtry| command.  In between, you can use a |:catch| command to start
+a catch clause, or a |:finally| command to start a finally clause.  There may
+be none or multiple catch clauses, but there is at most one finally clause,
+which must not be followed by any catch clauses.  The lines before the catch
+clauses and the finally clause is called a try block. >
+
+     :try
+     :	...
+     :	...				TRY BLOCK
+     :	...
+     :catch /{pattern}/
+     :	...
+     :	...				CATCH CLAUSE
+     :	...
+     :catch /{pattern}/
+     :	...
+     :	...				CATCH CLAUSE
+     :	...
+     :finally
+     :	...
+     :	...				FINALLY CLAUSE
+     :	...
+     :endtry
+
+The try conditional allows to watch code for exceptions and to take the
+appropriate actions.  Exceptions from the try block may be caught.  Exceptions
+from the try block and also the catch clauses may cause cleanup actions.
+   When no exception is thrown during execution of the try block, the control
+is transferred to the finally clause, if present.  After its execution, the
+script continues with the line following the ":endtry".
+   When an exception occurs during execution of the try block, the remaining
+lines in the try block are skipped.  The exception is matched against the
+patterns specified as arguments to the ":catch" commands.  The catch clause
+after the first matching ":catch" is taken, other catch clauses are not
+executed.  The catch clause ends when the next ":catch", ":finally", or
+":endtry" command is reached - whatever is first.  Then, the finally clause
+(if present) is executed.  When the ":endtry" is reached, the script execution
+continues in the following line as usual.
+   When an exception that does not match any of the patterns specified by the
+":catch" commands is thrown in the try block, the exception is not caught by
+that try conditional and none of the catch clauses is executed.  Only the
+finally clause, if present, is taken.  The exception pends during execution of
+the finally clause.  It is resumed at the ":endtry", so that commands after
+the ":endtry" are not executed and the exception might be caught elsewhere,
+see |try-nesting|.
+   When during execution of a catch clause another exception is thrown, the
+remaining lines in that catch clause are not executed.  The new exception is
+not matched against the patterns in any of the ":catch" commands of the same
+try conditional and none of its catch clauses is taken.  If there is, however,
+a finally clause, it is executed, and the exception pends during its
+execution.  The commands following the ":endtry" are not executed.  The new
+exception might, however, be caught elsewhere, see |try-nesting|.
+   When during execution of the finally clause (if present) an exception is
+thrown, the remaining lines in the finally clause are skipped.  If the finally
+clause has been taken because of an exception from the try block or one of the
+catch clauses, the original (pending) exception is discarded.  The commands
+following the ":endtry" are not executed, and the exception from the finally
+clause is propagated and can be caught elsewhere, see |try-nesting|.
+
+The finally clause is also executed, when a ":break" or ":continue" for
+a ":while" loop enclosing the complete try conditional is executed from the
+try block or a catch clause.  Or when a ":return" or ":finish" is executed
+from the try block or a catch clause of a try conditional in a function or
+sourced script, respectively.  The ":break", ":continue", ":return", or
+":finish" pends during execution of the finally clause and is resumed when the
+":endtry" is reached.  It is, however, discarded when an exception is thrown
+from the finally clause.
+   When a ":break" or ":continue" for a ":while" loop enclosing the complete
+try conditional or when a ":return" or ":finish" is encountered in the finally
+clause, the rest of the finally clause is skipped, and the ":break",
+":continue", ":return" or ":finish" is executed as usual.  If the finally
+clause has been taken because of an exception or an earlier ":break",
+":continue", ":return", or ":finish" from the try block or a catch clause,
+this pending exception or command is discarded.
+
+For examples see |throw-catch| and |try-finally|.
+
+
+NESTING	OF TRY CONDITIONALS				*try-nesting*
+
+Try conditionals can be nested arbitrarily.  That is, a complete try
+conditional can be put into the try block, a catch clause, or the finally
+clause of another try conditional.  If the inner try conditional does not
+catch an exception thrown in its try block or throws a new exception from one
+of its catch clauses or its finally clause, the outer try conditional is
+checked according to the rules above.  If the inner try conditional is in the
+try block of the outer try conditional, its catch clauses are checked, but
+otherwise only the finally clause is executed.  It does not matter for
+nesting, whether the inner try conditional is directly contained in the outer
+one, or whether the outer one sources a script or calls a function containing
+the inner try conditional.
+
+When none of the active try conditionals catches an exception, just their
+finally clauses are executed.  Thereafter, the script processing terminates.
+An error message is displayed in case of an uncaught exception explicitly
+thrown by a ":throw" command.  For uncaught error and interrupt exceptions
+implicitly raised by Vim, the error message(s) or interrupt message are shown
+as usual.
+
+For examples see |throw-catch|.
+
+
+EXAMINING EXCEPTION HANDLING CODE			*except-examine*
+
+Exception handling code can get tricky.  If you are in doubt what happens, set
+'verbose' to 13 or use the ":13verbose" command modifier when sourcing your
+script file.  Then you see when an exception is thrown, discarded, caught, or
+finished.  When using a verbosity level of at least 14, things pending in
+a finally clause are also shown.  This information is also given in debug mode
+(see |debug-scripts|).
+
+
+THROWING AND CATCHING EXCEPTIONS			*throw-catch*
+
+You can throw any number or string as an exception.  Use the |:throw| command
+and pass the value to be thrown as argument: >
+	:throw 4711
+	:throw "string"
+<							*throw-expression*
+You can also specify an expression argument.  The expression is then evaluated
+first, and the result is thrown: >
+	:throw 4705 + strlen("string")
+	:throw strpart("strings", 0, 6)
+
+An exception might be thrown during evaluation of the argument of the ":throw"
+command.  Unless it is caught there, the expression evaluation is abandoned.
+The ":throw" command then does not throw a new exception.
+   Example: >
+
+	:function! Foo(arg)
+	:  try
+	:    throw a:arg
+	:  catch /foo/
+	:  endtry
+	:  return 1
+	:endfunction
+	:
+	:function! Bar()
+	:  echo "in Bar"
+	:  return 4710
+	:endfunction
+	:
+	:throw Foo("arrgh") + Bar()
+
+This throws "arrgh", and "in Bar" is not displayed since Bar() is not
+executed. >
+	:throw Foo("foo") + Bar()
+however displays "in Bar" and throws 4711.
+
+Any other command that takes an expression as argument might also be
+abandoned by an (uncaught) exception during the expression evaluation.  The
+exception is then propagated to the caller of the command.
+   Example: >
+
+	:if Foo("arrgh")
+	:  echo "then"
+	:else
+	:  echo "else"
+	:endif
+
+Here neither of "then" or "else" is displayed.
+
+							*catch-order*
+Exceptions can be caught by a try conditional with one or more |:catch|
+commands, see |try-conditionals|.   The values to be caught by each ":catch"
+command can be specified as a pattern argument.  The subsequent catch clause
+gets executed when a matching exception is caught.
+   Example: >
+
+	:function! Foo(value)
+	:  try
+	:    throw a:value
+	:  catch /^\d\+$/
+	:    echo "Number thrown"
+	:  catch /.*/
+	:    echo "String thrown"
+	:  endtry
+	:endfunction
+	:
+	:call Foo(0x1267)
+	:call Foo('string')
+
+The first call to Foo() displays "Number thrown", the second "String thrown".
+An exception is matched against the ":catch" commands in the order they are
+specified.  Only the first match counts.  So you should place the more
+specific ":catch" first.  The following order does not make sense: >
+
+	:  catch /.*/
+	:    echo "String thrown"
+	:  catch /^\d\+$/
+	:    echo "Number thrown"
+
+The first ":catch" here matches always, so that the second catch clause is
+never taken.
+
+							*throw-variables*
+If you catch an exception by a general pattern, you may access the exact value
+in the variable |v:exception|: >
+
+	:  catch /^\d\+$/
+	:    echo "Number thrown.  Value is" v:exception
+
+You may also be interested where an exception was thrown.  This is stored in
+|v:throwpoint|.  Note that "v:exception" and "v:throwpoint" are valid for the
+exception most recently caught as long it is not finished.
+   Example: >
+
+	:function! Caught()
+	:  if v:exception != ""
+	:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint
+	:  else
+	:    echo 'Nothing caught'
+	:  endif
+	:endfunction
+	:
+	:function! Foo()
+	:  try
+	:    try
+	:      try
+	:	 throw 4711
+	:      finally
+	:	 call Caught()
+	:      endtry
+	:    catch /.*/
+	:      call Caught()
+	:      throw "oops"
+	:    endtry
+	:  catch /.*/
+	:    call Caught()
+	:  finally
+	:    call Caught()
+	:  endtry
+	:endfunction
+	:
+	:call Foo()
+
+This displays >
+
+	Nothing caught
+	Caught "4711" in function Foo, line 4
+	Caught "oops" in function Foo, line 10
+	Nothing caught
+
+A practical example:  The following command ":LineNumber" displays the line
+number in the script or function where it has been used: >
+
+	:function! LineNumber()
+	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")
+	:endfunction
+	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry
+<
+							*try-nested*
+An exception that is not caught by a try conditional can be caught by
+a surrounding try conditional: >
+
+	:try
+	:  try
+	:    throw "foo"
+	:  catch /foobar/
+	:    echo "foobar"
+	:  finally
+	:    echo "inner finally"
+	:  endtry
+	:catch /foo/
+	:  echo "foo"
+	:endtry
+
+The inner try conditional does not catch the exception, just its finally
+clause is executed.  The exception is then caught by the outer try
+conditional.  The example displays "inner finally" and then "foo".
+
+							*throw-from-catch*
+You can catch an exception and throw a new one to be caught elsewhere from the
+catch clause: >
+
+	:function! Foo()
+	:  throw "foo"
+	:endfunction
+	:
+	:function! Bar()
+	:  try
+	:    call Foo()
+	:  catch /foo/
+	:    echo "Caught foo, throw bar"
+	:    throw "bar"
+	:  endtry
+	:endfunction
+	:
+	:try
+	:  call Bar()
+	:catch /.*/
+	:  echo "Caught" v:exception
+	:endtry
+
+This displays "Caught foo, throw bar" and then "Caught bar".
+
+							*rethrow*
+There is no real rethrow in the Vim script language, but you may throw
+"v:exception" instead: >
+
+	:function! Bar()
+	:  try
+	:    call Foo()
+	:  catch /.*/
+	:    echo "Rethrow" v:exception
+	:    throw v:exception
+	:  endtry
+	:endfunction
+<							*try-echoerr*
+Note that this method cannot be used to "rethrow" Vim error or interrupt
+exceptions, because it is not possible to fake Vim internal exceptions.
+Trying so causes an error exception.  You should throw your own exception
+denoting the situation.  If you want to cause a Vim error exception containing
+the original error exception value, you can use the |:echoerr| command: >
+
+	:try
+	:  try
+	:    asdf
+	:  catch /.*/
+	:    echoerr v:exception
+	:  endtry
+	:catch /.*/
+	:  echo v:exception
+	:endtry
+
+This code displays
+
+	Vim(echoerr):Vim:E492: Not an editor command:	asdf ~
+
+
+CLEANUP CODE						*try-finally*
+
+Scripts often change global settings and restore them at their end.  If the
+user however interrupts the script by pressing CTRL-C, the settings remain in
+an inconsistent state.  The same may happen to you in the development phase of
+a script when an error occurs or you explicitly throw an exception without
+catching it.  You can solve these problems by using a try conditional with
+a finally clause for restoring the settings.  Its execution is guaranteed on
+normal control flow, on error, on an explicit ":throw", and on interrupt.
+(Note that errors and interrupts from inside the try conditional are converted
+to exceptions.  When not caught, they terminate the script after the finally
+clause has been executed.)
+Example: >
+
+	:try
+	:  let s:saved_ts = &ts
+	:  set ts=17
+	:
+	:  " Do the hard work here.
+	:
+	:finally
+	:  let &ts = s:saved_ts
+	:  unlet s:saved_ts
+	:endtry
+
+This method should be used locally whenever a function or part of a script
+changes global settings which need to be restored on failure or normal exit of
+that function or script part.
+
+							*break-finally*
+Cleanup code works also when the try block or a catch clause is left by
+a ":continue", ":break", ":return", or ":finish".
+   Example: >
+
+	:let first = 1
+	:while 1
+	:  try
+	:    if first
+	:      echo "first"
+	:      let first = 0
+	:      continue
+	:    else
+	:      throw "second"
+	:    endif
+	:  catch /.*/
+	:    echo v:exception
+	:    break
+	:  finally
+	:    echo "cleanup"
+	:  endtry
+	:  echo "still in while"
+	:endwhile
+	:echo "end"
+
+This displays "first", "cleanup", "second", "cleanup", and "end". >
+
+	:function! Foo()
+	:  try
+	:    return 4711
+	:  finally
+	:    echo "cleanup\n"
+	:  endtry
+	:  echo "Foo still active"
+	:endfunction
+	:
+	:echo Foo() "returned by Foo"
+
+This displays "cleanup" and "4711 returned by Foo".  You don't need to add an
+extra ":return" in the finally clause.  (Above all, this would override the
+return value.)
+
+							*except-from-finally*
+Using either of ":continue", ":break", ":return", ":finish", or ":throw" in
+a finally clause is possible, but not recommended since it abandons the
+cleanup actions for the try conditional.  But, of course, interrupt and error
+exceptions might get raised from a finally clause.
+   Example where an error in the finally clause stops an interrupt from
+working correctly: >
+
+	:try
+	:  try
+	:    echo "Press CTRL-C for interrupt"
+	:    while 1
+	:    endwhile
+	:  finally
+	:    unlet novar
+	:  endtry
+	:catch /novar/
+	:endtry
+	:echo "Script still running"
+	:sleep 1
+
+If you need to put commands that could fail into a finally clause, you should
+think about catching or ignoring the errors in these commands, see
+|catch-errors| and |ignore-errors|.
+
+
+CATCHING ERRORS						*catch-errors*
+
+If you want to catch specific errors, you just have to put the code to be
+watched in a try block and add a catch clause for the error message.  The
+presence of the try conditional causes all errors to be converted to an
+exception.  No message is displayed and |v:errmsg| is not set then.  To find
+the right pattern for the ":catch" command, you have to know how the format of
+the error exception is.
+   Error exceptions have the following format: >
+
+	Vim({cmdname}):{errmsg}
+or >
+	Vim:{errmsg}
+
+{cmdname} is the name of the command that failed; the second form is used when
+the command name is not known.  {errmsg} is the error message usually produced
+when the error occurs outside try conditionals.  It always begins with
+a capital "E", followed by a two or three-digit error number, a colon, and
+a space.
+
+Examples:
+
+The command >
+	:unlet novar
+normally produces the error message >
+	E108: No such variable: "novar"
+which is converted inside try conditionals to an exception >
+	Vim(unlet):E108: No such variable: "novar"
+
+The command >
+	:dwim
+normally produces the error message >
+	E492: Not an editor command: dwim
+which is converted inside try conditionals to an exception >
+	Vim:E492: Not an editor command: dwim
+
+You can catch all ":unlet" errors by a >
+	:catch /^Vim(unlet):/
+or all errors for misspelled command names by a >
+	:catch /^Vim:E492:/
+
+Some error messages may be produced by different commands: >
+	:function nofunc
+and >
+	:delfunction nofunc
+both produce the error message >
+	E128: Function name must start with a capital: nofunc
+which is converted inside try conditionals to an exception >
+	Vim(function):E128: Function name must start with a capital: nofunc
+or >
+	Vim(delfunction):E128: Function name must start with a capital: nofunc
+respectively.  You can catch the error by its number independently on the
+command that caused it if you use the following pattern: >
+	:catch /^Vim(\a\+):E128:/
+
+Some commands like >
+	:let x = novar
+produce multiple error messages, here: >
+	E121: Undefined variable: novar
+	E15: Invalid expression:  novar
+Only the first is used for the exception value, since it is the most specific
+one (see |except-several-errors|).  So you can catch it by >
+	:catch /^Vim(\a\+):E121:/
+
+You can catch all errors related to the name "nofunc" by >
+	:catch /\<nofunc\>/
+
+You can catch all Vim errors in the ":write" and ":read" commands by >
+	:catch /^Vim(\(write\|read\)):E\d\+:/
+
+You can catch all Vim errors by the pattern >
+	:catch /^Vim\((\a\+)\)\=:E\d\+:/
+<
+							*catch-text*
+NOTE: You should never catch the error message text itself: >
+	:catch /No such variable/
+only works in the English locale, but not when the user has selected
+a different language by the |:language| command.  It is however helpful to
+cite the message text in a comment: >
+	:catch /^Vim(\a\+):E108:/   " No such variable
+
+
+IGNORING ERRORS						*ignore-errors*
+
+You can ignore errors in a specific Vim command by catching them locally: >
+
+	:try
+	:  write
+	:catch
+	:endtry
+
+But you are strongly recommended NOT to use this simple form, since it could
+catch more than you want.  With the ":write" command, some autocommands could
+be executed and cause errors not related to writing, for instance: >
+
+	:au BufWritePre * unlet novar
+
+There could even be such errors you are not responsible for as a script
+writer: a user of your script might have defined such autocommands.  You would
+then hide the error from the user.
+   It is much better to use >
+
+	:try
+	:  write
+	:catch /^Vim(write):/
+	:endtry
+
+which only catches real write errors.  So catch only what you'd like to ignore
+intentionally.
+
+For a single command that does not cause execution of autocommands, you could
+even suppress the conversion of errors to exceptions by the ":silent!"
+command: >
+	:silent! nunmap k
+This works also when a try conditional is active.
+
+
+CATCHING INTERRUPTS					*catch-interrupt*
+
+When there are active try conditionals, an interrupt (CTRL-C) is converted to
+the exception "Vim:Interrupt".  You can catch it like every exception.  The
+script is not terminated, then.
+   Example: >
+
+	:function! TASK1()
+	:  sleep 10
+	:endfunction
+
+	:function! TASK2()
+	:  sleep 20
+	:endfunction
+
+	:while 1
+	:  let command = input("Type a command: ")
+	:  try
+	:    if command == ""
+	:      continue
+	:    elseif command == "END"
+	:      break
+	:    elseif command == "TASK1"
+	:      call TASK1()
+	:    elseif command == "TASK2"
+	:      call TASK2()
+	:    else
+	:      echo "\nIllegal command:" command
+	:      continue
+	:    endif
+	:  catch /^Vim:Interrupt$/
+	:    echo "\nCommand interrupted"
+	:    " Caught the interrupt.  Continue with next prompt.
+	:  endtry
+	:endwhile
+
+You can interrupt a task here by pressing CTRL-C; the script then asks for
+a new command.  If you press CTRL-C at the prompt, the script is terminated.
+
+For testing what happens when CTRL-C would be pressed on a specific line in
+your script, use the debug mode and execute the |>quit| or |>interrupt|
+command on that line.  See |debug-scripts|.
+
+
+CATCHING ALL						*catch-all*
+
+The commands >
+
+	:catch /.*/
+	:catch //
+	:catch
+
+catch everything, error exceptions, interrupt exceptions and exceptions
+explicitly thrown by the |:throw| command.  This is useful at the top level of
+a script in order to catch unexpected things.
+   Example: >
+
+	:try
+	:
+	:  " do the hard work here
+	:
+	:catch /MyException/
+	:
+	:  " handle known problem
+	:
+	:catch /^Vim:Interrupt$/
+	:    echo "Script interrupted"
+	:catch /.*/
+	:  echo "Internal error (" . v:exception . ")"
+	:  echo " - occurred at " . v:throwpoint
+	:endtry
+	:" end of script
+
+Note: Catching all might catch more things than you want.  Thus, you are
+strongly encouraged to catch only for problems that you can really handle by
+specifying a pattern argument to the ":catch".
+   Example: Catching all could make it nearly impossible to interrupt a script
+by pressing CTRL-C: >
+
+	:while 1
+	:  try
+	:    sleep 1
+	:  catch
+	:  endtry
+	:endwhile
+
+
+EXCEPTIONS AND AUTOCOMMANDS				*except-autocmd*
+
+Exceptions may be used during execution of autocommands.  Example: >
+
+	:autocmd User x try
+	:autocmd User x   throw "Oops!"
+	:autocmd User x catch
+	:autocmd User x   echo v:exception
+	:autocmd User x endtry
+	:autocmd User x throw "Arrgh!"
+	:autocmd User x echo "Should not be displayed"
+	:
+	:try
+	:  doautocmd User x
+	:catch
+	:  echo v:exception
+	:endtry
+
+This displays "Oops!" and "Arrgh!".
+
+							*except-autocmd-Pre*
+For some commands, autocommands get executed before the main action of the
+command takes place.  If an exception is thrown and not caught in the sequence
+of autocommands, the sequence and the command that caused its execution are
+abandoned and the exception is propagated to the caller of the command.
+   Example: >
+
+	:autocmd BufWritePre * throw "FAIL"
+	:autocmd BufWritePre * echo "Should not be displayed"
+	:
+	:try
+	:  write
+	:catch
+	:  echo "Caught:" v:exception "from" v:throwpoint
+	:endtry
+
+Here, the ":write" command does not write the file currently being edited (as
+you can see by checking 'modified'), since the exception from the BufWritePre
+autocommand abandons the ":write".  The exception is then caught and the
+script displays: >
+
+	Caught: FAIL from BufWrite Auto commands for "*"
+<
+							*except-autocmd-Post*
+For some commands, autocommands get executed after the main action of the
+command has taken place.  If this main action fails and the command is inside
+an active try conditional, the autocommands are skipped and an error exception
+is thrown that can be caught by the caller of the command.
+   Example: >
+
+	:autocmd BufWritePost * echo "File successfully written!"
+	:
+	:try
+	:  write /i/m/p/o/s/s/i/b/l/e
+	:catch
+	:  echo v:exception
+	:endtry
+
+This just displays: >
+
+	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)
+
+If you really need to execute the autocommands even when the main action
+fails, trigger the event from the catch clause.
+   Example: >
+
+	:autocmd BufWritePre  * set noreadonly
+	:autocmd BufWritePost * set readonly
+	:
+	:try
+	:  write /i/m/p/o/s/s/i/b/l/e
+	:catch
+	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e
+	:endtry
+<
+You can also use ":silent!": >
+
+	:let x = "ok"
+	:let v:errmsg = ""
+	:autocmd BufWritePost * if v:errmsg != ""
+	:autocmd BufWritePost *   let x = "after fail"
+	:autocmd BufWritePost * endif
+	:try
+	:  silent! write /i/m/p/o/s/s/i/b/l/e
+	:catch
+	:endtry
+	:echo x
+
+This displays "after fail".
+
+If the main action of the command does not fail, exceptions from the
+autocommands will be catchable by the caller of the command:  >
+
+	:autocmd BufWritePost * throw ":-("
+	:autocmd BufWritePost * echo "Should not be displayed"
+	:
+	:try
+	:  write
+	:catch
+	:  echo v:exception
+	:endtry
+<
+							*except-autocmd-Cmd*
+For some commands, the normal action can be replaced by a sequence of
+autocommands.  Exceptions from that sequence will be catchable by the caller
+of the command.
+   Example:  For the ":write" command, the caller cannot know whether the file
+had actually been written when the exception occurred.  You need to tell it in
+some way. >
+
+	:if !exists("cnt")
+	:  let cnt = 0
+	:
+	:  autocmd BufWriteCmd * if &modified
+	:  autocmd BufWriteCmd *   let cnt = cnt + 1
+	:  autocmd BufWriteCmd *   if cnt % 3 == 2
+	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
+	:  autocmd BufWriteCmd *   endif
+	:  autocmd BufWriteCmd *   write | set nomodified
+	:  autocmd BufWriteCmd *   if cnt % 3 == 0
+	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
+	:  autocmd BufWriteCmd *   endif
+	:  autocmd BufWriteCmd *   echo "File successfully written!"
+	:  autocmd BufWriteCmd * endif
+	:endif
+	:
+	:try
+	:	write
+	:catch /^BufWriteCmdError$/
+	:  if &modified
+	:    echo "Error on writing (file contents not changed)"
+	:  else
+	:    echo "Error after writing"
+	:  endif
+	:catch /^Vim(write):/
+	:    echo "Error on writing"
+	:endtry
+
+When this script is sourced several times after making changes, it displays
+first >
+	File successfully written!
+then >
+	Error on writing (file contents not changed)
+then >
+	Error after writing
+etc.
+
+							*except-autocmd-ill*
+You cannot spread a try conditional over autocommands for different events.
+The following code is ill-formed: >
+
+	:autocmd BufWritePre  * try
+	:
+	:autocmd BufWritePost * catch
+	:autocmd BufWritePost *   echo v:exception
+	:autocmd BufWritePost * endtry
+	:
+	:write
+
+
+EXCEPTION HIERARCHIES AND PARAMETERIZED EXCEPTIONS	*except-hier-param*
+
+Some programming languages allow to use hierarchies of exception classes or to
+pass additional information with the object of an exception class.  You can do
+similar things in Vim.
+   In order to throw an exception from a hierarchy, just throw the complete
+class name with the components separated by a colon, for instance throw the
+string "EXCEPT:MATHERR:OVERFLOW" for an overflow in a mathematical library.
+   When you want to pass additional information with your exception class, add
+it in parentheses, for instance throw the string "EXCEPT:IO:WRITEERR(myfile)"
+for an error when writing "myfile".
+   With the appropriate patterns in the ":catch" command, you can catch for
+base classes or derived classes of your hierarchy.  Additional information in
+parentheses can be cut out from |v:exception| with the ":substitute" command.
+   Example: >
+
+	:function! CheckRange(a, func)
+	:  if a:a < 0
+	:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"
+	:  endif
+	:endfunction
+	:
+	:function! Add(a, b)
+	:  call CheckRange(a:a, "Add")
+	:  call CheckRange(a:b, "Add")
+	:  let c = a:a + a:b
+	:  if c < 0
+	:    throw "EXCEPT:MATHERR:OVERFLOW"
+	:  endif
+	:  return c
+	:endfunction
+	:
+	:function! Div(a, b)
+	:  call CheckRange(a:a, "Div")
+	:  call CheckRange(a:b, "Div")
+	:  if (a:b == 0)
+	:    throw "EXCEPT:MATHERR:ZERODIV"
+	:  endif
+	:  return a:a / a:b
+	:endfunction
+	:
+	:function! Write(file)
+	:  try
+	:    execute "write" fnameescape(a:file)
+	:  catch /^Vim(write):/
+	:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"
+	:  endtry
+	:endfunction
+	:
+	:try
+	:
+	:  " something with arithmetics and I/O
+	:
+	:catch /^EXCEPT:MATHERR:RANGE/
+	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")
+	:  echo "Range error in" function
+	:
+	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV
+	:  echo "Math error"
+	:
+	:catch /^EXCEPT:IO/
+	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")
+	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")
+	:  if file !~ '^/'
+	:    let file = dir . "/" . file
+	:  endif
+	:  echo 'I/O error for "' . file . '"'
+	:
+	:catch /^EXCEPT/
+	:  echo "Unspecified error"
+	:
+	:endtry
+
+The exceptions raised by Vim itself (on error or when pressing CTRL-C) use
+a flat hierarchy:  they are all in the "Vim" class.  You cannot throw yourself
+exceptions with the "Vim" prefix; they are reserved for Vim.
+   Vim error exceptions are parameterized with the name of the command that
+failed, if known.  See |catch-errors|.
+
+
+PECULIARITIES
+							*except-compat*
+The exception handling concept requires that the command sequence causing the
+exception is aborted immediately and control is transferred to finally clauses
+and/or a catch clause.
+
+In the Vim script language there are cases where scripts and functions
+continue after an error: in functions without the "abort" flag or in a command
+after ":silent!", control flow goes to the following line, and outside
+functions, control flow goes to the line following the outermost ":endwhile"
+or ":endif".  On the other hand, errors should be catchable as exceptions
+(thus, requiring the immediate abortion).
+
+This problem has been solved by converting errors to exceptions and using
+immediate abortion (if not suppressed by ":silent!") only when a try
+conditional is active.  This is no restriction since an (error) exception can
+be caught only from an active try conditional.  If you want an immediate
+termination without catching the error, just use a try conditional without
+catch clause.  (You can cause cleanup code being executed before termination
+by specifying a finally clause.)
+
+When no try conditional is active, the usual abortion and continuation
+behavior is used instead of immediate abortion.  This ensures compatibility of
+scripts written for Vim 6.1 and earlier.
+
+However, when sourcing an existing script that does not use exception handling
+commands (or when calling one of its functions) from inside an active try
+conditional of a new script, you might change the control flow of the existing
+script on error.  You get the immediate abortion on error and can catch the
+error in the new script.  If however the sourced script suppresses error
+messages by using the ":silent!" command (checking for errors by testing
+|v:errmsg| if appropriate), its execution path is not changed.  The error is
+not converted to an exception.  (See |:silent|.)  So the only remaining cause
+where this happens is for scripts that don't care about errors and produce
+error messages.  You probably won't want to use such code from your new
+scripts.
+
+							*except-syntax-err*
+Syntax errors in the exception handling commands are never caught by any of
+the ":catch" commands of the try conditional they belong to.  Its finally
+clauses, however, is executed.
+   Example: >
+
+	:try
+	:  try
+	:    throw 4711
+	:  catch /\(/
+	:    echo "in catch with syntax error"
+	:  catch
+	:    echo "inner catch-all"
+	:  finally
+	:    echo "inner finally"
+	:  endtry
+	:catch
+	:  echo 'outer catch-all caught "' . v:exception . '"'
+	:  finally
+	:    echo "outer finally"
+	:endtry
+
+This displays: >
+    inner finally
+    outer catch-all caught "Vim(catch):E54: Unmatched \("
+    outer finally
+The original exception is discarded and an error exception is raised, instead.
+
+							*except-single-line*
+The ":try", ":catch", ":finally", and ":endtry" commands can be put on
+a single line, but then syntax errors may make it difficult to recognize the
+"catch" line, thus you better avoid this.
+   Example: >
+	:try | unlet! foo # | catch | endtry
+raises an error exception for the trailing characters after the ":unlet!"
+argument, but does not see the ":catch" and ":endtry" commands, so that the
+error exception is discarded and the "E488: Trailing characters" message gets
+displayed.
+
+							*except-several-errors*
+When several errors appear in a single command, the first error message is
+usually the most specific one and therefor converted to the error exception.
+   Example: >
+	echo novar
+causes >
+	E121: Undefined variable: novar
+	E15: Invalid expression: novar
+The value of the error exception inside try conditionals is: >
+	Vim(echo):E121: Undefined variable: novar
+<							*except-syntax-error*
+But when a syntax error is detected after a normal error in the same command,
+the syntax error is used for the exception being thrown.
+   Example: >
+	unlet novar #
+causes >
+	E108: No such variable: "novar"
+	E488: Trailing characters
+The value of the error exception inside try conditionals is: >
+	Vim(unlet):E488: Trailing characters
+This is done because the syntax error might change the execution path in a way
+not intended by the user.  Example: >
+	try
+	    try | unlet novar # | catch | echo v:exception | endtry
+	catch /.*/
+	    echo "outer catch:" v:exception
+	endtry
+This displays "outer catch: Vim(unlet):E488: Trailing characters", and then
+a "E600: Missing :endtry" error message is given, see |except-single-line|.
+
+==============================================================================
+9. Examples						*eval-examples*
+
+Printing in Binary ~
+>
+  :" The function Nr2Bin() returns the binary string representation of a number.
+  :func Nr2Bin(nr)
+  :  let n = a:nr
+  :  let r = ""
+  :  while n
+  :    let r = '01'[n % 2] . r
+  :    let n = n / 2
+  :  endwhile
+  :  return r
+  :endfunc
+
+  :" The function String2Bin() converts each character in a string to a
+  :" binary string, separated with dashes.
+  :func String2Bin(str)
+  :  let out = ''
+  :  for ix in range(strlen(a:str))
+  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))
+  :  endfor
+  :  return out[1:]
+  :endfunc
+
+Example of its use: >
+  :echo Nr2Bin(32)
+result: "100000" >
+  :echo String2Bin("32")
+result: "110011-110010"
+
+
+Sorting lines ~
+
+This example sorts lines with a specific compare function. >
+
+  :func SortBuffer()
+  :  let lines = getline(1, '$')
+  :  call sort(lines, function("Strcmp"))
+  :  call setline(1, lines)
+  :endfunction
+
+As a one-liner: >
+  :call setline(1, sort(getline(1, '$'), function("Strcmp")))
+
+
+scanf() replacement ~
+							*sscanf*
+There is no sscanf() function in Vim.  If you need to extract parts from a
+line, you can use matchstr() and substitute() to do it.  This example shows
+how to get the file name, line number and column number out of a line like
+"foobar.txt, 123, 45". >
+   :" Set up the match bit
+   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'
+   :"get the part matching the whole expression
+   :let l = matchstr(line, mx)
+   :"get each item out of the match
+   :let file = substitute(l, mx, '\1', '')
+   :let lnum = substitute(l, mx, '\2', '')
+   :let col = substitute(l, mx, '\3', '')
+
+The input is in the variable "line", the results in the variables "file",
+"lnum" and "col". (idea from Michael Geddes)
+
+
+getting the scriptnames in a Dictionary ~
+						*scriptnames-dictionary*
+The |:scriptnames| command can be used to get a list of all script files that
+have been sourced.  There is no equivalent function or variable for this
+(because it's rarely needed).  In case you need to manipulate the list this
+code can be used: >
+    " Get the output of ":scriptnames" in the scriptnames_output variable.
+    let scriptnames_output = ''
+    redir => scriptnames_output
+    silent scriptnames
+    redir END
+
+    " Split the output into lines and parse each line.	Add an entry to the
+    " "scripts" dictionary.
+    let scripts = {}
+    for line in split(scriptnames_output, "\n")
+      " Only do non-blank lines.
+      if line =~ '\S'
+	" Get the first number in the line.
+	let nr = matchstr(line, '\d\+')
+	" Get the file name, remove the script number " 123: ".
+	let name = substitute(line, '.\+:\s*', '', '')
+	" Add an item to the Dictionary
+	let scripts[nr] = name
+      endif
+    endfor
+    unlet scriptnames_output
+
+==============================================================================
+10. No +eval feature				*no-eval-feature*
+
+When the |+eval| feature was disabled at compile time, none of the expression
+evaluation commands are available.  To prevent this from causing Vim scripts
+to generate all kinds of errors, the ":if" and ":endif" commands are still
+recognized, though the argument of the ":if" and everything between the ":if"
+and the matching ":endif" is ignored.  Nesting of ":if" blocks is allowed, but
+only if the commands are at the start of the line.  The ":else" command is not
+recognized.
+
+Example of how to avoid executing commands when the |+eval| feature is
+missing: >
+
+	:if 1
+	:  echo "Expression evaluation is compiled in"
+	:else
+	:  echo "You will _never_ see this message"
+	:endif
+
+To execute a command only when the |+eval| feature is disabled requires a trick,
+as this example shows: >
+
+	silent! while 0
+	  set history=111
+	silent! endwhile
+
+When the |+eval| feature is available the command is skipped because of the
+"while 0".  Without the |+eval| feature the "while 0" is an error, which is
+silently ignored, and the command is executed.
+
+==============================================================================
+11. The sandbox					*eval-sandbox* *sandbox* *E48*
+
+The 'foldexpr', 'formatexpr', 'includeexpr', 'indentexpr', 'statusline' and
+'foldtext' options may be evaluated in a sandbox.  This means that you are
+protected from these expressions having nasty side effects.  This gives some
+safety for when these options are set from a modeline.  It is also used when
+the command from a tags file is executed and for CTRL-R = in the command line.
+The sandbox is also used for the |:sandbox| command.
+
+These items are not allowed in the sandbox:
+	- changing the buffer text
+	- defining or changing mapping, autocommands, user commands
+	- setting certain options (see |option-summary|)
+	- setting certain v: variables (see |v:var|)  *E794*
+	- executing a shell command
+	- reading or writing a file
+	- jumping to another buffer or editing a file
+	- executing Python, Perl, etc. commands
+This is not guaranteed 100% secure, but it should block most attacks.
+
+							*:san* *:sandbox*
+:san[dbox] {cmd}	Execute {cmd} in the sandbox.  Useful to evaluate an
+			option that may have been set from a modeline, e.g.
+			'foldexpr'.
+
+							*sandbox-option*
+A few options contain an expression.  When this expression is evaluated it may
+have to be done in the sandbox to avoid a security risk.  But the sandbox is
+restrictive, thus this only happens when the option was set from an insecure
+location.  Insecure in this context are:
+- sourcing a .vimrc or .exrc in the current directory
+- while executing in the sandbox
+- value coming from a modeline
+- executing a function that was defined in the sandbox
+
+Note that when in the sandbox and saving an option value and restoring it, the
+option will still be marked as it was set in the sandbox.
+
+==============================================================================
+12. Textlock							*textlock*
+
+In a few situations it is not allowed to change the text in the buffer, jump
+to another window and some other things that might confuse or break what Vim
+is currently doing.  This mostly applies to things that happen when Vim is
+actually doing something else.  For example, evaluating the 'balloonexpr' may
+happen any moment the mouse cursor is resting at some position.
+
+This is not allowed when the textlock is active:
+	- changing the buffer text
+	- jumping to another buffer or window
+	- editing another file
+	- closing a window or quitting Vim
+	- etc.
+
+==============================================================================
+13. Testing							*testing*
+
+Vim can be tested after building it, usually with "make test".
+The tests are located in the directory "src/testdir".
+
+There are several types of tests added over time:
+	test33.in		oldest, don't add any more
+	test_something.in	old style tests
+	test_something.vim	new style tests
+
+						*new-style-testing*
+New tests should be added as new style tests.  These use functions such as
+|assert_equal()| to keep the test commands and the expected result in one
+place.
+						*old-style-testing*
+In some cases an old style test needs to be used.  E.g. when testing Vim
+without the |+eval| feature.
+
+Find more information in the file src/testdir/README.txt.
+
+
+ vim:tw=78:ts=8:noet:ft=help:norl:
diff --git a/runtime/doc/options.txt b/runtime/doc/options.txt
index b5e9626..e16e0ee 100644
--- a/runtime/doc/options.txt
+++ b/runtime/doc/options.txt
@@ -3911,7 +3911,7 @@ A jump table for the options with a short description can be found at |Q_op|.
 		'guitablabel' can be used to change the text in the labels.
 		When 'e' is missing a non-GUI tab pages line may be used.
 		The GUI tabs are only supported on some systems, currently
-		GTK, Motif, Mac OS/X and MS-Windows.
+		GTK, Motif, Mac OS/X, Haiku and MS-Windows.
 								*'go-f'*
 	  'f'	Foreground: Don't use fork() to detach the GUI from the shell
 		where it was started.  Use this for programs that wait for the
@@ -6427,7 +6427,12 @@ A jump table for the options with a short description can be found at |Q_op|.
 						$VIM/vimfiles,
 						$VIMRUNTIME,
 						$VIM/vimfiles/after,
-						sys$login:vimfiles/after")
+						sys$login:vimfiles/after"
+					Haiku: "$BE_USER_SETTINGS/vim,
+						$VIM/vimfiles,
+						$VIMRUNTIME,
+						$VIM/vimfiles/after,
+						$BE_USER_SETTINGS/vim/after")
 			global
 			{not in Vi}
 	This is a list of directories which will be searched for runtime
@@ -7902,6 +7907,7 @@ A jump table for the options with a short description can be found at |Q_op|.
 					 on MiNT: "vt52"
 				       on MS-DOS: "pcterm"
 					 on OS/2: "os2ansi"
+					on Haiku: "xterm"
 					 on Unix: "ansi"
 					  on VMS: "ansi"
 				       on Win 32: "win32")
diff --git a/b/runtime/doc/options.txt.orig b/runtime/doc/options.txt.orig
new file mode 100644
index 0000000..b5e9626
--- /dev/null
+++ b/runtime/doc/options.txt.orig
@@ -0,0 +1,9231 @@
+*options.txt*	For Vim version 8.1.  Last change: 2018 May 15
+
+
+		  VIM REFERENCE MANUAL	  by Bram Moolenaar
+
+
+Options							*options*
+
+1. Setting options			|set-option|
+2. Automatically setting options	|auto-setting|
+3. Options summary			|option-summary|
+
+For an overview of options see quickref.txt |option-list|.
+
+Vim has a number of internal variables and switches which can be set to
+achieve special effects.  These options come in three forms:
+	boolean		can only be on or off		*boolean* *toggle*
+	number		has a numeric value
+	string		has a string value
+
+==============================================================================
+1. Setting options					*set-option* *E764*
+
+							*:se* *:set*
+:se[t]			Show all options that differ from their default value.
+
+:se[t] all		Show all but terminal options.
+
+:se[t] termcap		Show all terminal options.  Note that in the GUI the
+			key codes are not shown, because they are generated
+			internally and can't be changed.  Changing the terminal
+			codes in the GUI is not useful either...
+
+								*E518* *E519*
+:se[t] {option}?	Show value of {option}.
+
+:se[t] {option}		Toggle option: set, switch it on.
+			Number option: show value.
+			String option: show value.
+
+:se[t] no{option}	Toggle option: Reset, switch it off.
+
+							   *:set-!* *:set-inv*
+:se[t] {option}!   or
+:se[t] inv{option}	Toggle option: Invert value. {not in Vi}
+
+				*:set-default* *:set-&* *:set-&vi* *:set-&vim*
+:se[t] {option}&	Reset option to its default value.  May depend on the
+			current value of 'compatible'. {not in Vi}
+:se[t] {option}&vi	Reset option to its Vi default value. {not in Vi}
+:se[t] {option}&vim	Reset option to its Vim default value. {not in Vi}
+
+:se[t] all&		Set all options to their default value.  The values of
+			these options are not changed:
+			  all terminal options, starting with t_
+			  'columns'
+			  'cryptmethod'
+			  'encoding'
+			  'key'
+			  'lines'
+			  'term'
+			  'ttymouse'
+			  'ttytype'
+			Warning: This may have a lot of side effects.
+			{not in Vi}
+
+						*:set-args* *E487* *E521*
+:se[t] {option}={value}		or
+:se[t] {option}:{value}
+			Set string or number option to {value}.
+			For numeric options the value can be given in decimal,
+			hex (preceded with 0x) or octal (preceded with '0').
+			The old value can be inserted by typing 'wildchar' (by
+			default this is a <Tab> or CTRL-E if 'compatible' is
+			set).  See |cmdline-completion|.
+			White space between {option} and '=' is allowed and
+			will be ignored.  White space between '=' and {value}
+			is not allowed.
+			See |option-backslash| for using white space and
+			backslashes in {value}.
+
+:se[t] {option}+={value}				*:set+=*
+			Add the {value} to a number option, or append the
+			{value} to a string option.  When the option is a
+			comma separated list, a comma is added, unless the
+			value was empty.
+			If the option is a list of flags, superfluous flags
+			are removed.  When adding a flag that was already
+			present the option value doesn't change.
+			Also see |:set-args| above.
+			{not in Vi}
+
+:se[t] {option}^={value}				*:set^=*
+			Multiply the {value} to a number option, or prepend
+			the {value} to a string option.  When the option is a
+			comma separated list, a comma is added, unless the
+			value was empty.
+			Also see |:set-args| above.
+			{not in Vi}
+
+:se[t] {option}-={value}				*:set-=*
+			Subtract the {value} from a number option, or remove
+			the {value} from a string option, if it is there.
+			If the {value} is not found in a string option, there
+			is no error or warning.  When the option is a comma
+			separated list, a comma is deleted, unless the option
+			becomes empty.
+			When the option is a list of flags, {value} must be
+			exactly as they appear in the option.  Remove flags
+			one by one to avoid problems.
+			Also see |:set-args| above.
+			{not in Vi}
+
+The {option} arguments to ":set" may be repeated.  For example: >
+	:set ai nosi sw=3 ts=3
+If you make an error in one of the arguments, an error message will be given
+and the following arguments will be ignored.
+
+							*:set-verbose*
+When 'verbose' is non-zero, displaying an option value will also tell where it
+was last set.  Example: >
+	:verbose set shiftwidth cindent?
+<	  shiftwidth=4 ~
+		  Last set from modeline ~
+	  cindent ~
+		  Last set from /usr/local/share/vim/vim60/ftplugin/c.vim ~
+This is only done when specific option values are requested, not for ":verbose
+set all" or ":verbose set" without an argument.
+When the option was set by hand there is no "Last set" message.
+When the option was set while executing a function, user command or
+autocommand, the script in which it was defined is reported.
+Note that an option may also have been set as a side effect of setting
+'compatible'.
+A few special texts:
+	Last set from modeline ~
+		Option was set in a |modeline|.
+	Last set from --cmd argument ~
+		Option was set with command line argument |--cmd| or +.
+	Last set from -c argument ~
+		Option was set with command line argument |-c|, +, |-S| or
+		|-q|.
+	Last set from environment variable ~
+		Option was set from an environment variable, $VIMINIT,
+		$GVIMINIT or $EXINIT.
+	Last set from error handler ~
+		Option was cleared when evaluating it resulted in an error.
+
+{not available when compiled without the |+eval| feature}
+
+							*:set-termcap* *E522*
+For {option} the form "t_xx" may be used to set a terminal option.  This will
+override the value from the termcap.  You can then use it in a mapping.  If
+the "xx" part contains special characters, use the <t_xx> form: >
+	:set <t_#4>=^[Ot
+This can also be used to translate a special code for a normal key.  For
+example, if Alt-b produces <Esc>b, use this: >
+	:set <M-b>=^[b
+(the ^[ is a real <Esc> here, use CTRL-V <Esc> to enter it)
+The advantage over a mapping is that it works in all situations.
+
+You can define any key codes, e.g.: >
+	:set t_xy=^[foo;
+There is no warning for using a name that isn't recognized.  You can map these
+codes as you like: >
+	:map <t_xy> something
+<								*E846*
+When a key code is not set, it's like it does not exist.  Trying to get its
+value will result in an error: >
+	:set t_kb=
+	:set t_kb
+	E846: Key code not set: t_kb
+
+The t_xx options cannot be set from a |modeline| or in the |sandbox|, for
+security reasons.
+
+The listing from ":set" looks different from Vi.  Long string options are put
+at the end of the list.  The number of options is quite large.  The output of
+"set all" probably does not fit on the screen, causing Vim to give the
+|more-prompt|.
+
+							*option-backslash*
+To include white space in a string option value it has to be preceded with a
+backslash.  To include a backslash you have to use two.  Effectively this
+means that the number of backslashes in an option value is halved (rounded
+down).
+A few examples: >
+   :set tags=tags\ /usr/tags	    results in "tags /usr/tags"
+   :set tags=tags\\,file	    results in "tags\,file"
+   :set tags=tags\\\ file	    results in "tags\ file"
+
+The "|" character separates a ":set" command from a following command.  To
+include the "|" in the option value, use "\|" instead.  This example sets the
+'titlestring' option to "hi|there": >
+   :set titlestring=hi\|there
+This sets the 'titlestring' option to "hi" and 'iconstring' to "there": >
+   :set titlestring=hi|set iconstring=there
+
+Similarly, the double quote character starts a comment.  To include the '"' in
+the option value, use '\"' instead.  This example sets the 'titlestring'
+option to 'hi "there"': >
+   :set titlestring=hi\ \"there\"
+
+For MS-DOS and WIN32 backslashes in file names are mostly not removed.  More
+precise: For options that expect a file name (those where environment
+variables are expanded) a backslash before a normal file name character is not
+removed.  But a backslash before a special character (space, backslash, comma,
+etc.) is used like explained above.
+There is one special situation, when the value starts with "\\": >
+   :set dir=\\machine\path	    results in "\\machine\path"
+   :set dir=\\\\machine\\path	    results in "\\machine\path"
+   :set dir=\\path\\file	    results in "\\path\file" (wrong!)
+For the first one the start is kept, but for the second one the backslashes
+are halved.  This makes sure it works both when you expect backslashes to be
+halved and when you expect the backslashes to be kept.  The third gives a
+result which is probably not what you want.  Avoid it.
+
+				*add-option-flags* *remove-option-flags*
+				*E539* *E550* *E551* *E552*
+Some options are a list of flags.  When you want to add a flag to such an
+option, without changing the existing ones, you can do it like this: >
+   :set guioptions+=a
+Remove a flag from an option like this: >
+   :set guioptions-=a
+This removes the 'a' flag from 'guioptions'.
+Note that you should add or remove one flag at a time.  If 'guioptions' has
+the value "ab", using "set guioptions-=ba" won't work, because the string "ba"
+doesn't appear.
+
+			   *:set_env* *expand-env* *expand-environment-var*
+Environment variables in specific string options will be expanded.  If the
+environment variable exists the '$' and the following environment variable
+name is replaced with its value.  If it does not exist the '$' and the name
+are not modified.  Any non-id character (not a letter, digit or '_') may
+follow the environment variable name.  That character and what follows is
+appended to the value of the environment variable.  Examples: >
+   :set term=$TERM.new
+   :set path=/usr/$INCLUDE,$HOME/include,.
+When adding or removing a string from an option with ":set opt-=val" or ":set
+opt+=val" the expansion is done before the adding or removing.
+
+
+Handling of local options			*local-options*
+
+Some of the options only apply to a window or buffer.  Each window or buffer
+has its own copy of this option, thus each can have its own value.  This
+allows you to set 'list' in one window but not in another.  And set
+'shiftwidth' to 3 in one buffer and 4 in another.
+
+The following explains what happens to these local options in specific
+situations.  You don't really need to know all of this, since Vim mostly uses
+the option values you would expect.  Unfortunately, doing what the user
+expects is a bit complicated...
+
+When splitting a window, the local options are copied to the new window.  Thus
+right after the split the contents of the two windows look the same.
+
+When editing a new buffer, its local option values must be initialized.  Since
+the local options of the current buffer might be specifically for that buffer,
+these are not used.  Instead, for each buffer-local option there also is a
+global value, which is used for new buffers.  With ":set" both the local and
+global value is changed.  With "setlocal" only the local value is changed,
+thus this value is not used when editing a new buffer.
+
+When editing a buffer that has been edited before, the options from the window
+that was last closed are used again.  If this buffer has been edited in this
+window, the values from back then are used.  Otherwise the values from the
+last closed window where the buffer was edited last are used.
+
+It's possible to set a local window option specifically for a type of buffer.
+When you edit another buffer in the same window, you don't want to keep
+using these local window options.  Therefore Vim keeps a global value of the
+local window options, which is used when editing another buffer.  Each window
+has its own copy of these values.  Thus these are local to the window, but
+global to all buffers in the window.  With this you can do: >
+	:e one
+	:set list
+	:e two
+Now the 'list' option will also be set in "two", since with the ":set list"
+command you have also set the global value. >
+	:set nolist
+	:e one
+	:setlocal list
+	:e two
+Now the 'list' option is not set, because ":set nolist" resets the global
+value, ":setlocal list" only changes the local value and ":e two" gets the
+global value.  Note that if you do this next: >
+	:e one
+You will get back the 'list' value as it was the last time you edited "one".
+The options local to a window are remembered for each buffer.  This also
+happens when the buffer is not loaded, but they are lost when the buffer is
+wiped out |:bwipe|.
+
+							*:setl* *:setlocal*
+:setl[ocal] ...		Like ":set" but set only the value local to the
+			current buffer or window.  Not all options have a
+			local value.  If the option does not have a local
+			value the global value is set.
+			With the "all" argument: display local values for all
+			local options.
+			Without argument: Display local values for all local
+			options which are different from the default.
+			When displaying a specific local option, show the
+			local value.  For a global/local boolean option, when
+			the global value is being used, "--" is displayed
+			before the option name.
+			For a global option the global value is
+			shown (but that might change in the future).
+			{not in Vi}
+
+:setl[ocal] {option}<	Set the local value of {option} to its global value by
+			copying the value.
+			{not in Vi}
+
+:se[t] {option}<	For |global-local| options: Remove the local value of
+			{option}, so that the global value will be used.
+			{not in Vi}
+
+							*:setg* *:setglobal*
+:setg[lobal] ...	Like ":set" but set only the global value for a local
+			option without changing the local value.
+			When displaying an option, the global value is shown.
+			With the "all" argument: display global values for all
+			local options.
+			Without argument: display global values for all local
+			options which are different from the default.
+			{not in Vi}
+
+For buffer-local and window-local options:
+	Command		 global value	    local value ~
+      :set option=value	     set		set
+ :setlocal option=value	      -			set
+:setglobal option=value	     set		 -
+      :set option?	      -		       display
+ :setlocal option?	      -		       display
+:setglobal option?	    display		 -
+
+
+Global options with a local value			*global-local*
+
+Options are global when you mostly use one value for all buffers and windows.
+For some global options it's useful to sometimes have a different local value.
+You can set the local value with ":setlocal".  That buffer or window will then
+use the local value, while other buffers and windows continue using the global
+value.
+
+For example, you have two windows, both on C source code.  They use the global
+'makeprg' option.  If you do this in one of the two windows: >
+	:set makeprg=gmake
+then the other window will switch to the same value.  There is no need to set
+the 'makeprg' option in the other C source window too.
+However, if you start editing a Perl file in a new window, you want to use
+another 'makeprg' for it, without changing the value used for the C source
+files.  You use this command: >
+	:setlocal makeprg=perlmake
+You can switch back to using the global value by making the local value empty: >
+	:setlocal makeprg=
+This only works for a string option.  For a boolean option you need to use the
+"<" flag, like this: >
+	:setlocal autoread<
+Note that for non-boolean options using "<" copies the global value to the
+local value, it doesn't switch back to using the global value (that matters
+when the global value changes later).  You can also use: >
+	:set path<
+This will make the local value of 'path' empty, so that the global value is
+used.  Thus it does the same as: >
+	:setlocal path=
+Note: In the future more global options can be made global-local.  Using
+":setlocal" on a global option might work differently then.
+
+
+Setting the filetype
+
+:setf[iletype] [FALLBACK] {filetype}			*:setf* *:setfiletype*
+			Set the 'filetype' option to {filetype}, but only if
+			not done yet in a sequence of (nested) autocommands.
+			This is short for: >
+				:if !did_filetype()
+				:  setlocal filetype={filetype}
+				:endif
+<			This command is used in a filetype.vim file to avoid
+			setting the 'filetype' option twice, causing different
+			settings and syntax files to be loaded.
+
+			When the optional FALLBACK argument is present, a
+			later :setfiletype command will override the
+			'filetype'.  This is to used for filetype detections
+			that are just a guess.  |did_filetype()| will return
+			false after this command.
+
+			{not in Vi}
+
+				*option-window* *optwin*
+:bro[wse] se[t]			*:set-browse* *:browse-set* *:opt* *:options*
+:opt[ions]		Open a window for viewing and setting all options.
+			Options are grouped by function.
+			Offers short help for each option.  Hit <CR> on the
+			short help to open a help window with more help for
+			the option.
+			Modify the value of the option and hit <CR> on the
+			"set" line to set the new value.  For window and
+			buffer specific options, the last accessed window is
+			used to set the option value in, unless this is a help
+			window, in which case the window below help window is
+			used (skipping the option-window).
+			{not available when compiled without the |+eval|
+			feature}
+
+								*$HOME*
+Using "~" is like using "$HOME", but it is only recognized at the start of an
+option and after a space or comma.
+
+On Unix systems "~user" can be used too.  It is replaced by the home directory
+of user "user".  Example: >
+    :set path=~mool/include,/usr/include,.
+
+On Unix systems the form "${HOME}" can be used too.  The name between {} can
+contain non-id characters then.  Note that if you want to use this for the
+"gf" command, you need to add the '{' and '}' characters to 'isfname'.
+
+NOTE: expanding environment variables and "~/" is only done with the ":set"
+command, not when assigning a value to an option with ":let".
+
+							*$HOME-windows*
+On MS-Windows, if $HOME is not defined as an environment variable, then
+at runtime Vim will set it to the expansion of $HOMEDRIVE$HOMEPATH.
+If $HOMEDRIVE is not set then $USERPROFILE is used.
+
+This expanded value is not exported to the environment, this matters when
+running an external command: >
+	:echo system('set | findstr ^HOME=')
+and >
+	:echo luaeval('os.getenv("HOME")')
+should echo nothing (an empty string) despite exists('$HOME') being true.
+When setting $HOME to a non-empty string it will be exported to the
+subprocesses.
+
+
+Note the maximum length of an expanded option is limited.  How much depends on
+the system, mostly it is something like 256 or 1024 characters.
+
+							*:fix* *:fixdel*
+:fix[del]		Set the value of 't_kD':
+				't_kb' is     't_kD' becomes	~
+				  CTRL-?	CTRL-H
+				not CTRL-?	CTRL-?
+
+			(CTRL-? is 0177 octal, 0x7f hex) {not in Vi}
+
+			If your delete key terminal code is wrong, but the
+			code for backspace is alright, you can put this in
+			your .vimrc: >
+				:fixdel
+<			This works no matter what the actual code for
+			backspace is.
+
+			If the backspace key terminal code is wrong you can
+			use this: >
+				:if &term == "termname"
+				:  set t_kb=^V<BS>
+				:  fixdel
+				:endif
+<			Where "^V" is CTRL-V and "<BS>" is the backspace key
+			(don't type four characters!).  Replace "termname"
+			with your terminal name.
+
+			If your <Delete> key sends a strange key sequence (not
+			CTRL-? or CTRL-H) you cannot use ":fixdel".  Then use: >
+				:if &term == "termname"
+				:  set t_kD=^V<Delete>
+				:endif
+<			Where "^V" is CTRL-V and "<Delete>" is the delete key
+			(don't type eight characters!).  Replace "termname"
+			with your terminal name.
+
+							*Linux-backspace*
+			Note about Linux: By default the backspace key
+			produces CTRL-?, which is wrong.  You can fix it by
+			putting this line in your rc.local: >
+				echo "keycode 14 = BackSpace" | loadkeys
+<
+							*NetBSD-backspace*
+			Note about NetBSD: If your backspace doesn't produce
+			the right code, try this: >
+				xmodmap -e "keycode 22 = BackSpace"
+<			If this works, add this in your .Xmodmap file: >
+				keysym 22 = BackSpace
+<			You need to restart for this to take effect.
+
+==============================================================================
+2. Automatically setting options			*auto-setting*
+
+Besides changing options with the ":set" command, there are three alternatives
+to set options automatically for one or more files:
+
+1. When starting Vim initializations are read from various places.  See
+   |initialization|.  Most of them are performed for all editing sessions,
+   and some of them depend on the directory where Vim is started.
+   You can create an initialization file with |:mkvimrc|, |:mkview| and
+   |:mksession|.
+2. If you start editing a new file, the automatic commands are executed.
+   This can be used to set options for files matching a particular pattern and
+   many other things.  See |autocommand|.
+3. If you start editing a new file, and the 'modeline' option is on, a
+   number of lines at the beginning and end of the file are checked for
+   modelines.  This is explained here.
+
+					*modeline* *vim:* *vi:* *ex:* *E520*
+There are two forms of modelines.  The first form:
+	[text]{white}{vi:|vim:|ex:}[white]{options}
+
+[text]			any text or empty
+{white}			at least one blank character (<Space> or <Tab>)
+{vi:|vim:|ex:}		the string "vi:", "vim:" or "ex:"
+[white]			optional white space
+{options}		a list of option settings, separated with white space
+			or ':', where each part between ':' is the argument
+			for a ":set" command (can be empty)
+
+Examples:
+   vi:noai:sw=3 ts=6 ~
+   vim: tw=77 ~
+
+The second form (this is compatible with some versions of Vi):
+
+	[text]{white}{vi:|vim:|Vim:|ex:}[white]se[t] {options}:[text]
+
+[text]			any text or empty
+{white}			at least one blank character (<Space> or <Tab>)
+{vi:|vim:|Vim:|ex:}	the string "vi:", "vim:", "Vim:" or "ex:"
+[white]			optional white space
+se[t]			the string "set " or "se " (note the space); When
+			"Vim" is used it must be "set".
+{options}		a list of options, separated with white space, which
+			is the argument for a ":set" command
+:			a colon
+[text]			any text or empty
+
+Examples:
+   /* vim: set ai tw=75: */ ~
+   /* Vim: set ai tw=75: */ ~
+
+The white space before {vi:|vim:|Vim:|ex:} is required.  This minimizes the
+chance that a normal word like "lex:" is caught.  There is one exception:
+"vi:" and "vim:" can also be at the start of the line (for compatibility with
+version 3.0).  Using "ex:" at the start of the line will be ignored (this
+could be short for "example:").
+
+							*modeline-local*
+The options are set like with ":setlocal": The new value only applies to the
+buffer and window that contain the file.  Although it's possible to set global
+options from a modeline, this is unusual.  If you have two windows open and
+the files in it set the same global option to a different value, the result
+depends on which one was opened last.
+
+When editing a file that was already loaded, only the window-local options
+from the modeline are used.  Thus if you manually changed a buffer-local
+option after opening the file, it won't be changed if you edit the same buffer
+in another window.  But window-local options will be set.
+
+							*modeline-version*
+If the modeline is only to be used for some versions of Vim, the version
+number can be specified where "vim:" or "Vim:" is used:
+	vim{vers}:	version {vers} or later
+	vim<{vers}:	version before {vers}
+	vim={vers}:	version {vers}
+	vim>{vers}:	version after {vers}
+{vers} is 700 for Vim 7.0 (hundred times the major version plus minor).
+For example, to use a modeline only for Vim 7.0:
+	/* vim700: set foldmethod=marker */ ~
+To use a modeline for Vim after version 7.2:
+	/* vim>702: set cole=2: */ ~
+There can be no blanks between "vim" and the ":".
+
+
+The number of lines that are checked can be set with the 'modelines' option.
+If 'modeline' is off or 'modelines' is 0 no lines are checked.
+
+Note that for the first form all of the rest of the line is used, thus a line
+like:
+   /* vi:ts=4: */ ~
+will give an error message for the trailing "*/".  This line is OK:
+   /* vi:set ts=4: */ ~
+
+If an error is detected the rest of the line is skipped.
+
+If you want to include a ':' in a set command precede it with a '\'.  The
+backslash in front of the ':' will be removed.  Example:
+   /* vi:set dir=c\:\tmp: */ ~
+This sets the 'dir' option to "c:\tmp".  Only a single backslash before the
+':' is removed.  Thus to include "\:" you have to specify "\\:".
+
+No other commands than "set" are supported, for security reasons (somebody
+might create a Trojan horse text file with modelines).  And not all options
+can be set.  For some options a flag is set, so that when it's used the
+|sandbox| is effective.  Still, there is always a small risk that a modeline
+causes trouble.  E.g., when some joker sets 'textwidth' to 5 all your lines
+are wrapped unexpectedly.  So disable modelines before editing untrusted text.
+The mail ftplugin does this, for example.
+
+Hint: If you would like to do something else than setting an option, you could
+define an autocommand that checks the file for a specific string.  For
+example: >
+	au BufReadPost * if getline(1) =~ "VAR" | call SetVar() | endif
+And define a function SetVar() that does something with the line containing
+"VAR".
+
+==============================================================================
+3. Options summary					*option-summary*
+
+In the list below all the options are mentioned with their full name and with
+an abbreviation if there is one.  Both forms may be used.
+
+In this document when a boolean option is "set" that means that ":set option"
+is entered.  When an option is "reset", ":set nooption" is used.
+
+For some options there are two default values: The "Vim default", which is
+used when 'compatible' is not set, and the "Vi default", which is used when
+'compatible' is set.
+
+Most options are the same in all windows and buffers.  There are a few that
+are specific to how the text is presented in a window.  These can be set to a
+different value in each window.  For example the 'list' option can be set in
+one window and reset in another for the same text, giving both types of view
+at the same time.  There are a few options that are specific to a certain
+file.  These can have a different value for each file or buffer.  For example
+the 'textwidth' option can be 78 for a normal text file and 0 for a C
+program.
+
+	global			one option for all buffers and windows
+	local to window		each window has its own copy of this option
+	local to buffer		each buffer has its own copy of this option
+
+When creating a new window the option values from the currently active window
+are used as a default value for the window-specific options.  For the
+buffer-specific options this depends on the 's' and 'S' flags in the
+'cpoptions' option.  If 's' is included (which is the default) the values for
+buffer options are copied from the currently active buffer when a buffer is
+first entered.  If 'S' is present the options are copied each time the buffer
+is entered, this is almost like having global options.  If 's' and 'S' are not
+present, the options are copied from the currently active buffer when the
+buffer is created.
+
+Hidden options						*hidden-options*
+
+Not all options are supported in all versions.  This depends on the supported
+features and sometimes on the system.  A remark about this is in curly braces
+below.  When an option is not supported it may still be set without getting an
+error, this is called a hidden option.  You can't get the value of a hidden
+option though, it is not stored.
+
+To test if option "foo" can be used with ":set" use something like this: >
+	if exists('&foo')
+This also returns true for a hidden option.  To test if option "foo" is really
+supported use something like this: >
+	if exists('+foo')
+<
+							*E355*
+A jump table for the options with a short description can be found at |Q_op|.
+
+					*'aleph'* *'al'* *aleph* *Aleph*
+'aleph' 'al'		number	(default 128 for MS-DOS, 224 otherwise)
+			global
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	The ASCII code for the first letter of the Hebrew alphabet.  The
+	routine that maps the keyboard in Hebrew mode, both in Insert mode
+	(when hkmap is set) and on the command-line (when hitting CTRL-_)
+	outputs the Hebrew characters in the range [aleph..aleph+26].
+	aleph=128 applies to PC code, and aleph=224 applies to ISO 8859-8.
+	See |rileft.txt|.
+
+			*'allowrevins'* *'ari'* *'noallowrevins'* *'noari'*
+'allowrevins' 'ari'	boolean	(default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	Allow CTRL-_ in Insert and Command-line mode.  This is default off, to
+	avoid that users that accidentally type CTRL-_ instead of SHIFT-_ get
+	into reverse Insert mode, and don't know how to get out.  See
+	'revins'.
+	NOTE: This option is reset when 'compatible' is set.
+
+			 *'altkeymap'* *'akm'* *'noaltkeymap'* *'noakm'*
+'altkeymap' 'akm'	boolean (default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+farsi|
+			feature}
+	When on, the second language is Farsi.  In editing mode CTRL-_ toggles
+	the keyboard map between Farsi and English, when 'allowrevins' set.
+
+	When off, the keyboard map toggles between Hebrew and English.  This
+	is useful to start the Vim in native mode i.e. English (left-to-right
+	mode) and have default second language Farsi or Hebrew (right-to-left
+	mode).  See |farsi.txt|.
+
+						*'ambiwidth'* *'ambw'*
+'ambiwidth' 'ambw'	string (default: "single")
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	Only effective when 'encoding' is "utf-8" or another Unicode encoding.
+	Tells Vim what to do with characters with East Asian Width Class
+	Ambiguous (such as Euro, Registered Sign, Copyright Sign, Greek
+	letters, Cyrillic letters).
+
+	There are currently two possible values:
+	"single":	Use the same width as characters in US-ASCII.  This is
+			expected by most users.
+	"double":	Use twice the width of ASCII characters.
+							*E834* *E835*
+	The value "double" cannot be used if 'listchars' or 'fillchars'
+	contains a character that would be double width.
+
+	There are a number of CJK fonts for which the width of glyphs for
+	those characters are solely based on how many octets they take in
+	legacy/traditional CJK encodings.  In those encodings, Euro,
+	Registered sign, Greek/Cyrillic letters are represented by two octets,
+	therefore those fonts have "wide" glyphs for them.  This is also
+	true of some line drawing characters used to make tables in text
+	file.  Therefore, when a CJK font is used for GUI Vim or
+	Vim is running inside a terminal (emulators) that uses a CJK font
+	(or Vim is run inside an xterm invoked with "-cjkwidth" option.),
+	this option should be set to "double" to match the width perceived
+	by Vim with the width of glyphs in the font.  Perhaps it also has
+	to be set to "double" under CJK Windows 9x/ME or Windows 2k/XP
+	when the system locale is set to one of CJK locales.  See Unicode
+	Standard Annex #11 (http://www.unicode.org/reports/tr11).
+
+	Vim may set this option automatically at startup time when Vim is
+	compiled with the |+termresponse| feature and if |t_u7| is set to the
+	escape sequence to request cursor position report.  The response can
+	be found in |v:termu7resp|.
+
+			*'antialias'* *'anti'* *'noantialias'* *'noanti'*
+'antialias' 'anti'	boolean (default: off)
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled
+			on Mac OS X}
+	This option only has an effect in the GUI version of Vim on Mac OS X
+	v10.2 or later.  When on, Vim will use smooth ("antialiased") fonts,
+	which can be easier to read at certain sizes on certain displays.
+	Setting this option can sometimes cause problems if 'guifont' is set
+	to its default (empty string).
+	NOTE: This option is reset when 'compatible' is set.
+
+			*'autochdir'* *'acd'* *'noautochdir'* *'noacd'*
+'autochdir' 'acd'	boolean (default off)
+			global
+			{not in Vi}
+			{only available when compiled with it, use
+			exists("+autochdir") to check}
+	When on, Vim will change the current working directory whenever you
+	open a file, switch buffers, delete a buffer or open/close a window.
+	It will change to the directory containing the file which was opened
+	or selected.
+	Note: When this option is on some plugins may not work.
+
+				*'arabic'* *'arab'* *'noarabic'* *'noarab'*
+'arabic' 'arab'		boolean (default off)
+			local to window
+			{not in Vi}
+			{only available when compiled with the |+arabic|
+			feature}
+	This option can be set to start editing Arabic text.
+	Setting this option will:
+	- Set the 'rightleft' option, unless 'termbidi' is set.
+	- Set the 'arabicshape' option, unless 'termbidi' is set.
+	- Set the 'keymap' option to "arabic"; in Insert mode CTRL-^ toggles
+	  between typing English and Arabic key mapping.
+	- Set the 'delcombine' option
+	Note that 'encoding' must be "utf-8" for working with Arabic text.
+
+	Resetting this option will:
+	- Reset the 'rightleft' option.
+	- Disable the use of 'keymap' (without changing its value).
+	Note that 'arabicshape' and 'delcombine' are not reset (it is a global
+	option).
+	NOTE: This option is reset when 'compatible' is set.
+	Also see |arabic.txt|.
+
+					*'arabicshape'* *'arshape'*
+					*'noarabicshape'* *'noarshape'*
+'arabicshape' 'arshape'	boolean (default on)
+			global
+			{not in Vi}
+			{only available when compiled with the |+arabic|
+			feature}
+	When on and 'termbidi' is off, the required visual character
+	corrections that need to take place for displaying the Arabic language
+	take effect.  Shaping, in essence, gets enabled; the term is a broad
+	one which encompasses:
+	  a) the changing/morphing of characters based on their location
+	     within a word (initial, medial, final and stand-alone).
+	  b) the enabling of the ability to compose characters
+	  c) the enabling of the required combining of some characters
+	When disabled the display shows each character's true stand-alone
+	form.
+	Arabic is a complex language which requires other settings, for
+	further details see |arabic.txt|.
+	NOTE: This option is set when 'compatible' is set.
+
+			*'autoindent'* *'ai'* *'noautoindent'* *'noai'*
+'autoindent' 'ai'	boolean	(default off)
+			local to buffer
+	Copy indent from current line when starting a new line (typing <CR>
+	in Insert mode or when using the "o" or "O" command).  If you do not
+	type anything on the new line except <BS> or CTRL-D and then type
+	<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor
+	to another line has the same effect, unless the 'I' flag is included
+	in 'cpoptions'.
+	When autoindent is on, formatting (with the "gq" command or when you
+	reach 'textwidth' in Insert mode) uses the indentation of the first
+	line.
+	When 'smartindent' or 'cindent' is on the indent is changed in
+	a different way.
+	The 'autoindent' option is reset when the 'paste' option is set and
+	restored when 'paste' is reset.
+	{small difference from Vi: After the indent is deleted when typing
+	<Esc> or <CR>, the cursor position when moving up or down is after the
+	deleted indent; Vi puts the cursor somewhere in the deleted indent}.
+
+				 *'autoread'* *'ar'* *'noautoread'* *'noar'*
+'autoread' 'ar'		boolean	(default off)
+			global or local to buffer |global-local|
+			{not in Vi}
+	When a file has been detected to have been changed outside of Vim and
+	it has not been changed inside of Vim, automatically read it again.
+	When the file has been deleted this is not done, so you have the text
+	from before it was deleted.  When it appears again then it is read.
+	|timestamp|
+	If this option has a local value, use this command to switch back to
+	using the global value: >
+		:set autoread<
+<
+				 *'autowrite'* *'aw'* *'noautowrite'* *'noaw'*
+'autowrite' 'aw'	boolean	(default off)
+			global
+	Write the contents of the file, if it has been modified, on each
+	:next, :rewind, :last, :first, :previous, :stop, :suspend, :tag, :!,
+	:make, CTRL-] and CTRL-^ command; and when a :buffer, CTRL-O, CTRL-I,
+	'{A-Z0-9}, or `{A-Z0-9} command takes one to another file.
+	Note that for some commands the 'autowrite' option is not used, see
+	'autowriteall' for that.
+	Some buffers will not be written, specifically when 'buttype' is
+	"nowrite", "nofile", "terminal" or "prompt".
+
+			 *'autowriteall'* *'awa'* *'noautowriteall'* *'noawa'*
+'autowriteall' 'awa'	boolean	(default off)
+			global
+			{not in Vi}
+	Like 'autowrite', but also used for commands ":edit", ":enew", ":quit",
+	":qall", ":exit", ":xit", ":recover" and closing the Vim window.
+	Setting this option also implies that Vim behaves like 'autowrite' has
+	been set.
+
+							*'background'* *'bg'*
+'background' 'bg'	string	(default "dark" or "light", see below)
+			global
+			{not in Vi}
+	When set to "dark", Vim will try to use colors that look good on a
+	dark background.  When set to "light", Vim will try to use colors that
+	look good on a light background.  Any other value is illegal.
+	Vim tries to set the default value according to the terminal used.
+	This will not always be correct.
+	Setting this option does not change the background color, it tells Vim
+	what the background color looks like.  For changing the background
+	color, see |:hi-normal|.
+
+	When 'background' is set Vim will adjust the default color groups for
+	the new value.  But the colors used for syntax highlighting will not
+	change.					*g:colors_name*
+	When a color scheme is loaded (the "g:colors_name" variable is set)
+	setting 'background' will cause the color scheme to be reloaded.  If
+	the color scheme adjusts to the value of 'background' this will work.
+	However, if the color scheme sets 'background' itself the effect may
+	be undone.  First delete the "g:colors_name" variable when needed.
+
+	When setting 'background' to the default value with: >
+		:set background&
+<	Vim will guess the value.  In the GUI this should work correctly,
+	in other cases Vim might not be able to guess the right value.
+
+	When the |t_RB| option is set, Vim will use it to request the background
+	color from the terminal.  If the returned RGB value is dark/light and
+	'background' is not dark/light, 'background' will be set and the
+	screen is redrawn.  This may have side effects, make t_BG empty in
+	your .vimrc if you suspect this problem.  The response to |t_RB| can
+	be found in |v:termrbgresp|.
+
+	When starting the GUI, the default value for 'background' will be
+	"light".  When the value is not set in the .gvimrc, and Vim detects
+	that the background is actually quite dark, 'background' is set to
+	"dark".  But this happens only AFTER the .gvimrc file has been read
+	(because the window needs to be opened to find the actual background
+	color).  To get around this, force the GUI window to be opened by
+	putting a ":gui" command in the .gvimrc file, before where the value
+	of 'background' is used (e.g., before ":syntax on").
+
+	For MS-DOS, Windows and OS/2 the default is "dark".
+	For other systems "dark" is used when 'term' is "linux",
+	"screen.linux", "cygwin" or "putty", or $COLORFGBG suggests a dark
+	background.  Otherwise the default is "light".
+
+	The |:terminal| command and the |term_start()| function use the
+	'background' value to decide whether the terminal window will start
+	with a white or black background.
+
+	Normally this option would be set in the .vimrc file.  Possibly
+	depending on the terminal name.  Example: >
+		:if &term == "pcterm"
+		:  set background=dark
+		:endif
+<	When this option is set, the default settings for the highlight groups
+	will change.  To use other settings, place ":highlight" commands AFTER
+	the setting of the 'background' option.
+	This option is also used in the "$VIMRUNTIME/syntax/syntax.vim" file
+	to select the colors for syntax highlighting.  After changing this
+	option, you must load syntax.vim again to see the result.  This can be
+	done with ":syntax on".
+
+							*'backspace'* *'bs'*
+'backspace' 'bs'	string	(default "", set to "indent,eol,start"
+							    in |defaults.vim|)
+			global
+			{not in Vi}
+	Influences the working of <BS>, <Del>, CTRL-W and CTRL-U in Insert
+	mode.  This is a list of items, separated by commas.  Each item allows
+	a way to backspace over something:
+	value	effect	~
+	indent	allow backspacing over autoindent
+	eol	allow backspacing over line breaks (join lines)
+	start	allow backspacing over the start of insert; CTRL-W and CTRL-U
+		stop once at the start of insert.
+
+	When the value is empty, Vi compatible backspacing is used.
+
+	For backwards compatibility with version 5.4 and earlier:
+	value	effect	~
+	  0	same as ":set backspace=" (Vi compatible)
+	  1	same as ":set backspace=indent,eol"
+	  2	same as ":set backspace=indent,eol,start"
+
+	See |:fixdel| if your <BS> or <Del> key does not do what you want.
+	NOTE: This option is set to "" when 'compatible' is set.
+
+				*'backup'* *'bk'* *'nobackup'* *'nobk'*
+'backup' 'bk'		boolean	(default off)
+			global
+			{not in Vi}
+	Make a backup before overwriting a file.  Leave it around after the
+	file has been successfully written.  If you do not want to keep the
+	backup file, but you do want a backup while the file is being
+	written, reset this option and set the 'writebackup' option (this is
+	the default).  If you do not want a backup file at all reset both
+	options (use this if your file system is almost full).  See the
+	|backup-table| for more explanations.
+	When the 'backupskip' pattern matches, a backup is not made anyway.
+	When 'patchmode' is set, the backup may be renamed to become the
+	oldest version of a file.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'backupcopy'* *'bkc'*
+'backupcopy' 'bkc'	string	(Vi default for Unix: "yes", otherwise: "auto")
+			global or local to buffer |global-local|
+			{not in Vi}
+	When writing a file and a backup is made, this option tells how it's
+	done.  This is a comma separated list of words.
+
+	The main values are:
+	"yes"	make a copy of the file and overwrite the original one
+	"no"	rename the file and write a new one
+	"auto"	one of the previous, what works best
+
+	Extra values that can be combined with the ones above are:
+	"breaksymlink"	always break symlinks when writing
+	"breakhardlink"	always break hardlinks when writing
+
+	Making a copy and overwriting the original file:
+	- Takes extra time to copy the file.
+	+ When the file has special attributes, is a (hard/symbolic) link or
+	  has a resource fork, all this is preserved.
+	- When the file is a link the backup will have the name of the link,
+	  not of the real file.
+
+	Renaming the file and writing a new one:
+	+ It's fast.
+	- Sometimes not all attributes of the file can be copied to the new
+	  file.
+	- When the file is a link the new file will not be a link.
+
+	The "auto" value is the middle way: When Vim sees that renaming file
+	is possible without side effects (the attributes can be passed on and
+	the file is not a link) that is used.  When problems are expected, a
+	copy will be made.
+
+	The "breaksymlink" and "breakhardlink" values can be used in
+	combination with any of "yes", "no" and "auto".  When included, they
+	force Vim to always break either symbolic or hard links by doing
+	exactly what the "no" option does, renaming the original file to
+	become the backup and writing a new file in its place.  This can be
+	useful for example in source trees where all the files are symbolic or
+	hard links and any changes should stay in the local source tree, not
+	be propagated back to the original source.
+							*crontab*
+	One situation where "no" and "auto" will cause problems: A program
+	that opens a file, invokes Vim to edit that file, and then tests if
+	the open file was changed (through the file descriptor) will check the
+	backup file instead of the newly created file.  "crontab -e" is an
+	example.
+
+	When a copy is made, the original file is truncated and then filled
+	with the new text.  This means that protection bits, owner and
+	symbolic links of the original file are unmodified.  The backup file
+	however, is a new file, owned by the user who edited the file.  The
+	group of the backup is set to the group of the original file.  If this
+	fails, the protection bits for the group are made the same as for
+	others.
+
+	When the file is renamed this is the other way around: The backup has
+	the same attributes of the original file, and the newly written file
+	is owned by the current user.  When the file was a (hard/symbolic)
+	link, the new file will not!  That's why the "auto" value doesn't
+	rename when the file is a link.  The owner and group of the newly
+	written file will be set to the same ones as the original file, but
+	the system may refuse to do this.  In that case the "auto" value will
+	again not rename the file.
+
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'backupdir'* *'bdir'*
+'backupdir' 'bdir'	string	(default for Amiga: ".,t:",
+				 for MS-DOS and Win32: ".,$TEMP,c:/tmp,c:/temp"
+				 for Unix: ".,~/tmp,~/")
+			global
+			{not in Vi}
+	List of directories for the backup file, separated with commas.
+	- The backup file will be created in the first directory in the list
+	  where this is possible.  The directory must exist, Vim will not
+	  create it for you.
+	- Empty means that no backup file will be created ('patchmode' is
+	  impossible!).  Writing may fail because of this.
+	- A directory "." means to put the backup file in the same directory
+	  as the edited file.
+	- A directory starting with "./" (or ".\" for MS-DOS et al.) means to
+	  put the backup file relative to where the edited file is.  The
+	  leading "." is replaced with the path name of the edited file.
+	  ("." inside a directory name has no special meaning).
+	- Spaces after the comma are ignored, other spaces are considered part
+	  of the directory name.  To have a space at the start of a directory
+	  name, precede it with a backslash.
+	- To include a comma in a directory name precede it with a backslash.
+	- A directory name may end in an '/'.
+	- For Unix and Win32, if a directory ends in two path separators "//",
+	  the swap file name will be built from the complete path to the file
+	  with all path separators changed to percent '%' signs. This will
+	  ensure file name uniqueness in the backup directory.
+	  On Win32, it is also possible to end with "\\".  However, When a
+	  separating comma is following, you must use "//", since "\\" will
+	  include the comma in the file name. Therefore it is recommended to
+	  use '//', instead of '\\'.
+	- Environment variables are expanded |:set_env|.
+	- Careful with '\' characters, type one before a space, type two to
+	  get one in the option (see |option-backslash|), for example: >
+	    :set bdir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
+<	- For backwards compatibility with Vim version 3.0 a '>' at the start
+	  of the option is removed.
+	See also 'backup' and 'writebackup' options.
+	If you want to hide your backup files on Unix, consider this value: >
+		:set backupdir=./.backup,~/.backup,.,/tmp
+<	You must create a ".backup" directory in each directory and in your
+	home directory for this to work properly.
+	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	directories from the list.  This avoids problems when a future version
+	uses another default.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'backupext'* *'bex'* *E589*
+'backupext' 'bex'	string	(default "~", for VMS: "_")
+			global
+			{not in Vi}
+	String which is appended to a file name to make the name of the
+	backup file.  The default is quite unusual, because this avoids
+	accidentally overwriting existing files with a backup file.  You might
+	prefer using ".bak", but make sure that you don't have files with
+	".bak" that you want to keep.
+	Only normal file name characters can be used, "/\*?[|<>" are illegal.
+
+	If you like to keep a lot of backups, you could use a BufWritePre
+	autocommand to change 'backupext' just before writing the file to
+	include a timestamp. >
+		:au BufWritePre * let &bex = '-' . strftime("%Y%b%d%X") . '~'
+<	Use 'backupdir' to put the backup in a different directory.
+
+						*'backupskip'* *'bsk'*
+'backupskip' 'bsk'	string	(default: "$TMPDIR/*,$TMP/*,$TEMP/*"
+				 Unix: "/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*"
+				 Mac: "/private/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*")
+			global
+			{not in Vi}
+			{not available when compiled without the |+wildignore|
+			feature}
+	A list of file patterns.  When one of the patterns matches with the
+	name of the file which is written, no backup file is created.  Both
+	the specified file name and the full path name of the file are used.
+	The pattern is used like with |:autocmd|, see |autocmd-patterns|.
+	Watch out for special characters, see |option-backslash|.
+	When $TMPDIR, $TMP or $TEMP is not defined, it is not used for the
+	default value.  "/tmp/*" is only used for Unix.
+
+	WARNING: Not having a backup file means that when Vim fails to write
+	your buffer correctly and then, for whatever reason, Vim exits, you
+	lose both the original file and what you were writing.  Only disable
+	backups if you don't care about losing the file.
+
+	Note that environment variables are not expanded.  If you want to use
+	$HOME you must expand it explicitly, e.g.: >
+		:let &backupskip = escape(expand('$HOME'), '\') . '/tmp/*'
+
+<	Note that the default also makes sure that "crontab -e" works (when a
+	backup would be made by renaming the original file crontab won't see
+	the newly created file).  Also see 'backupcopy' and |crontab|.
+
+						*'balloondelay'* *'bdlay'*
+'balloondelay' 'bdlay'	number	(default: 600)
+			global
+			{not in Vi}
+			{only available when compiled with the |+balloon_eval|
+			feature}
+	Delay in milliseconds before a balloon may pop up.  See |balloon-eval|.
+
+		       *'ballooneval'* *'beval'* *'noballooneval'* *'nobeval'*
+'ballooneval' 'beval'	boolean	(default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+balloon_eval|
+			feature}
+	Switch on the |balloon-eval| functionality for the GUI.
+
+		       *'balloonevalterm'* *'bevalterm'* *'noballoonevalterm'*
+		       *'nobevalterm'*
+'balloonevalterm' 'bevalterm'	boolean	(default off)
+			global
+			{not in Vi}
+			{only available when compiled with the
+			|+balloon_eval_term| feature}
+	Switch on the |balloon-eval| functionality for the terminal.
+
+						     *'balloonexpr'* *'bexpr'*
+'balloonexpr' 'bexpr'	string	(default "")
+			global or local to buffer |global-local|
+			{not in Vi}
+			{only available when compiled with the |+balloon_eval|
+			feature}
+	Expression for text to show in evaluation balloon.  It is only used
+	when 'ballooneval' is on.  These variables can be used:
+
+	v:beval_bufnr	number of the buffer in which balloon is going to show
+	v:beval_winnr	number of the window
+	v:beval_winid	ID of the window
+	v:beval_lnum	line number
+	v:beval_col	column number (byte index)
+	v:beval_text	word under or after the mouse pointer
+
+	The evaluation of the expression must not have side effects!
+	Example: >
+    function! MyBalloonExpr()
+	return 'Cursor is at line ' . v:beval_lnum .
+		\', column ' . v:beval_col .
+		\ ' of file ' .  bufname(v:beval_bufnr) .
+		\ ' on word "' . v:beval_text . '"'
+    endfunction
+    set bexpr=MyBalloonExpr()
+    set ballooneval
+<
+	Also see |balloon_show()|, can be used if the content of the balloon
+	is to be fetched asynchronously.
+
+	NOTE: The balloon is displayed only if the cursor is on a text
+	character.  If the result of evaluating 'balloonexpr' is not empty,
+	Vim does not try to send a message to an external debugger (Netbeans
+	or Sun Workshop).
+
+	The expression will be evaluated in the |sandbox| when set from a
+	modeline, see |sandbox-option|.
+
+	It is not allowed to change text or jump to another window while
+	evaluating 'balloonexpr' |textlock|.
+
+	To check whether line breaks in the balloon text work use this check: >
+		if has("balloon_multiline")
+<	When they are supported "\n" characters will start a new line.  If the
+	expression evaluates to a |List| this is equal to using each List item
+	as a string and putting "\n" in between them.
+	NOTE: This option is set to "" when 'compatible' is set.
+
+						*'belloff'* *'bo'*
+'belloff' 'bo'		string	(default "")
+			global
+			{not in Vi}
+	Specifies for which events the bell will not be rung. It is a comma
+	separated list of items. For each item that is present, the bell
+	will be silenced. This is most useful to specify specific events in
+	insert mode to be silenced.
+
+	item	    meaning when present	~
+	all	    All events.
+	backspace   When hitting <BS> or <Del> and deleting results in an
+		    error.
+	cursor	    Fail to move around using the cursor keys or
+		    <PageUp>/<PageDown> in |Insert-mode|.
+	complete    Error occurred when using |i_CTRL-X_CTRL-K| or
+		    |i_CTRL-X_CTRL-T|.
+	copy	    Cannot copy char from insert mode using |i_CTRL-Y| or
+		    |i_CTRL-E|.
+	ctrlg	    Unknown Char after <C-G> in Insert mode.
+	error	    Other Error occurred (e.g. try to join last line)
+		    (mostly used in |Normal-mode| or |Cmdline-mode|).
+	esc	    hitting <Esc> in |Normal-mode|.
+	ex	    In |Visual-mode|, hitting |Q| results in an error.
+	hangul	    Error occurred when using hangul input.
+	insertmode  Pressing <Esc> in 'insertmode'.
+	lang	    Calling the beep module for Lua/Mzscheme/TCL.
+	mess	    No output available for |g<|.
+	showmatch   Error occurred for 'showmatch' function.
+	operator    Empty region error |cpo-E|.
+	register    Unknown register after <C-R> in |Insert-mode|.
+	shell	    Bell from shell output |:!|.
+	spell	    Error happened on spell suggest.
+	wildmode    More matches in |cmdline-completion| available
+		    (depends on the 'wildmode' setting).
+
+	This is most useful to fine tune when in Insert mode the bell should
+	be rung. For Normal mode and Ex commands, the bell is often rung to
+	indicate that an error occurred. It can be silenced by adding the
+	"error" keyword.
+
+				     *'binary'* *'bin'* *'nobinary'* *'nobin'*
+'binary' 'bin'		boolean	(default off)
+			local to buffer
+			{not in Vi}
+	This option should be set before editing a binary file.  You can also
+	use the |-b| Vim argument.  When this option is switched on a few
+	options will be changed (also when it already was on):
+		'textwidth'  will be set to 0
+		'wrapmargin' will be set to 0
+		'modeline'   will be off
+		'expandtab'  will be off
+	Also, 'fileformat' and 'fileformats' options will not be used, the
+	file is read and written like 'fileformat' was "unix" (a single <NL>
+	separates lines).
+	The 'fileencoding' and 'fileencodings' options will not be used, the
+	file is read without conversion.
+	NOTE: When you start editing a(nother) file while the 'bin' option is
+	on, settings from autocommands may change the settings again (e.g.,
+	'textwidth'), causing trouble when editing.  You might want to set
+	'bin' again when the file has been loaded.
+	The previous values of these options are remembered and restored when
+	'bin' is switched from on to off.  Each buffer has its own set of
+	saved option values.
+	To edit a file with 'binary' set you can use the |++bin| argument.
+	This avoids you have to do ":set bin", which would have effect for all
+	files you edit.
+	When writing a file the <EOL> for the last line is only written if
+	there was one in the original file (normally Vim appends an <EOL> to
+	the last line if there is none; this would make the file longer).  See
+	the 'endofline' option.
+
+			*'bioskey'* *'biosk'* *'nobioskey'* *'nobiosk'*
+'bioskey' 'biosk'	boolean	(default on)
+			global
+			{not in Vi}  {only for MS-DOS}
+	This was for MS-DOS and is no longer supported.
+
+							*'bomb'* *'nobomb'*
+'bomb'			boolean	(default off)
+			local to buffer
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	When writing a file and the following conditions are met, a BOM (Byte
+	Order Mark) is prepended to the file:
+	- this option is on
+	- the 'binary' option is off
+	- 'fileencoding' is "utf-8", "ucs-2", "ucs-4" or one of the little/big
+	  endian variants.
+	Some applications use the BOM to recognize the encoding of the file.
+	Often used for UCS-2 files on MS-Windows.  For other applications it
+	causes trouble, for example: "cat file1 file2" makes the BOM of file2
+	appear halfway the resulting file.  Gcc doesn't accept a BOM.
+	When Vim reads a file and 'fileencodings' starts with "ucs-bom", a
+	check for the presence of the BOM is done and 'bomb' set accordingly.
+	Unless 'binary' is set, it is removed from the first line, so that you
+	don't see it when editing.  When you don't change the options, the BOM
+	will be restored when writing the file.
+
+						*'breakat'* *'brk'*
+'breakat' 'brk'		string	(default " ^I!@*-+;:,./?")
+			global
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	This option lets you choose which characters might cause a line
+	break if 'linebreak' is on.  Only works for ASCII and also for 8-bit
+	characters when 'encoding' is an 8-bit encoding.
+
+			*'breakindent'* *'bri'* *'nobreakindent'* *'nobri'*
+'breakindent' 'bri'	boolean (default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	Every wrapped line will continue visually indented (same amount of
+	space as the beginning of that line), thus preserving horizontal blocks
+	of text.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'breakindentopt'* *'briopt'*
+'breakindentopt' 'briopt' string (default empty)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	Settings for 'breakindent'. It can consist of the following optional
+	items and must be separated by a comma:
+		min:{n}	    Minimum text width that will be kept after
+			    applying 'breakindent', even if the resulting
+			    text should normally be narrower. This prevents
+			    text indented almost to the right window border
+			    occupying lot of vertical space when broken.
+		shift:{n}   After applying 'breakindent', the wrapped line's
+			    beginning will be shifted by the given number of
+			    characters.  It permits dynamic French paragraph
+			    indentation (negative) or emphasizing the line
+			    continuation (positive).
+		sbr	    Display the 'showbreak' value before applying the
+			    additional indent.
+	The default value for min is 20 and shift is 0.
+
+						*'browsedir'* *'bsdir'*
+'browsedir' 'bsdir'	string	(default: "last")
+			global
+			{not in Vi} {only for Motif, Athena, GTK, Mac and
+			Win32 GUI}
+	Which directory to use for the file browser:
+	   last		Use same directory as with last file browser, where a
+			file was opened or saved.
+	   buffer	Use the directory of the related buffer.
+	   current	Use the current directory.
+	   {path}	Use the specified directory
+
+						*'bufhidden'* *'bh'*
+'bufhidden' 'bh'	string (default: "")
+			local to buffer
+			{not in Vi}
+	This option specifies what happens when a buffer is no longer
+	displayed in a window:
+	  <empty>	follow the global 'hidden' option
+	  hide		hide the buffer (don't unload it), also when 'hidden'
+			is not set
+	  unload	unload the buffer, also when 'hidden' is set or using
+			|:hide|
+	  delete	delete the buffer from the buffer list, also when
+			'hidden' is set or using |:hide|, like using
+			|:bdelete|
+	  wipe		wipe out the buffer from the buffer list, also when
+			'hidden' is set or using |:hide|, like using
+			|:bwipeout|
+
+	CAREFUL: when "unload", "delete" or "wipe" is used changes in a buffer
+	are lost without a warning.  Also, these values may break autocommands
+	that switch between buffers temporarily.
+	This option is used together with 'buftype' and 'swapfile' to specify
+	special kinds of buffers.   See |special-buffers|.
+
+			*'buflisted'* *'bl'* *'nobuflisted'* *'nobl'* *E85*
+'buflisted' 'bl'	boolean (default: on)
+			local to buffer
+			{not in Vi}
+	When this option is set, the buffer shows up in the buffer list.  If
+	it is reset it is not used for ":bnext", "ls", the Buffers menu, etc.
+	This option is reset by Vim for buffers that are only used to remember
+	a file name or marks.  Vim sets it when starting to edit a buffer.
+	But not when moving to a buffer with ":buffer".
+
+						*'buftype'* *'bt'* *E382*
+'buftype' 'bt'		string (default: "")
+			local to buffer
+			{not in Vi}
+	The value of this option specifies the type of a buffer:
+	  <empty>	normal buffer
+	  nofile	buffer which is not related to a file and will not be
+			written
+	  nowrite	buffer which will not be written
+	  acwrite	buffer which will always be written with BufWriteCmd
+			autocommands.
+	  quickfix	quickfix buffer, contains list of errors |:cwindow|
+			or list of locations |:lwindow|
+	  help		help buffer (you are not supposed to set this
+			manually)
+	  terminal	buffer for a |terminal| (you are not supposed to set
+			this manually)
+	  prompt	buffer where only the last line can be edited, meant
+			to be used by a plugin, see |prompt-buffer|
+			{only when compiled with the |+channel| feature}
+
+	This option is used together with 'bufhidden' and 'swapfile' to
+	specify special kinds of buffers.   See |special-buffers|.
+
+	Be careful with changing this option, it can have many side effects!
+
+	A "quickfix" buffer is only used for the error list and the location
+	list.  This value is set by the |:cwindow| and |:lwindow| commands and
+	you are not supposed to change it.
+
+	"nofile" and "nowrite" buffers are similar:
+	both:		The buffer is not to be written to disk, ":w" doesn't
+			work (":w filename" does work though).
+	both:		The buffer is never considered to be |'modified'|.
+			There is no warning when the changes will be lost, for
+			example when you quit Vim.
+	both:		A swap file is only created when using too much memory
+			(when 'swapfile' has been reset there is never a swap
+			file).
+	nofile only:	The buffer name is fixed, it is not handled like a
+			file name.  It is not modified in response to a |:cd|
+			command.
+	both:		When using ":e bufname" and already editing "bufname"
+			the buffer is made empty and autocommands are
+			triggered as usual for |:edit|.
+							*E676*
+	"acwrite" implies that the buffer name is not related to a file, like
+	"nofile", but it will be written.  Thus, in contrast to "nofile" and
+	"nowrite", ":w" does work and a modified buffer can't be abandoned
+	without saving.  For writing there must be matching |BufWriteCmd|,
+	|FileWriteCmd| or |FileAppendCmd| autocommands.
+
+						*'casemap'* *'cmp'*
+'casemap' 'cmp'		string	(default: "internal,keepascii")
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	Specifies details about changing the case of letters.  It may contain
+	these words, separated by a comma:
+	internal	Use internal case mapping functions, the current
+			locale does not change the case mapping.  This only
+			matters when 'encoding' is a Unicode encoding,
+			"latin1" or "iso-8859-15".  When "internal" is
+			omitted, the towupper() and towlower() system library
+			functions are used when available.
+	keepascii	For the ASCII characters (0x00 to 0x7f) use the US
+			case mapping, the current locale is not effective.
+			This probably only matters for Turkish.
+
+						*'cdpath'* *'cd'* *E344* *E346*
+'cdpath' 'cd'		string	(default: equivalent to $CDPATH or ",,")
+			global
+			{not in Vi}
+			{not available when compiled without the
+			|+file_in_path| feature}
+	This is a list of directories which will be searched when using the
+	|:cd| and |:lcd| commands, provided that the directory being searched
+	for has a relative path, not an absolute part starting with "/", "./"
+	or "../", the 'cdpath' option is not used then.
+	The 'cdpath' option's value has the same form and semantics as
+	|'path'|.  Also see |file-searching|.
+	The default value is taken from $CDPATH, with a "," prepended to look
+	in the current directory first.
+	If the default value taken from $CDPATH is not what you want, include
+	a modified version of the following command in your vimrc file to
+	override it: >
+	  :let &cdpath = ',' . substitute(substitute($CDPATH, '[, ]', '\\\0', 'g'), ':', ',', 'g')
+<	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+	(parts of 'cdpath' can be passed to the shell to expand file names).
+
+						*'cedit'*
+'cedit'			string	(Vi default: "", Vim default: CTRL-F)
+			global
+			{not in Vi}
+			{not available when compiled without the |+vertsplit|
+			feature}
+	The key used in Command-line Mode to open the command-line window.
+	The default is CTRL-F when 'compatible' is off.
+	Only non-printable keys are allowed.
+	The key can be specified as a single character, but it is difficult to
+	type.  The preferred way is to use the <> notation.  Examples: >
+		:exe "set cedit=\<C-Y>"
+		:exe "set cedit=\<Esc>"
+<	|Nvi| also has this option, but it only uses the first character.
+	See |cmdwin|.
+	NOTE: This option is set to the Vim default value when 'compatible'
+	is reset.
+
+				*'charconvert'* *'ccv'* *E202* *E214* *E513*
+'charconvert' 'ccv'	string (default "")
+			global
+			{only available when compiled with the |+multi_byte|
+			and |+eval| features}
+			{not in Vi}
+	An expression that is used for character encoding conversion.  It is
+	evaluated when a file that is to be read or has been written has a
+	different encoding from what is desired.
+	'charconvert' is not used when the internal iconv() function is
+	supported and is able to do the conversion.  Using iconv() is
+	preferred, because it is much faster.
+	'charconvert' is not used when reading stdin |--|, because there is no
+	file to convert from.  You will have to save the text in a file first.
+	The expression must return zero or an empty string for success,
+	non-zero for failure.
+	The possible encoding names encountered are in 'encoding'.
+	Additionally, names given in 'fileencodings' and 'fileencoding' are
+	used.
+	Conversion between "latin1", "unicode", "ucs-2", "ucs-4" and "utf-8"
+	is done internally by Vim, 'charconvert' is not used for this.
+	'charconvert' is also used to convert the viminfo file, if the 'c'
+	flag is present in 'viminfo'.  Also used for Unicode conversion.
+	Example: >
+		set charconvert=CharConvert()
+		fun CharConvert()
+		  system("recode "
+			\ . v:charconvert_from . ".." . v:charconvert_to
+			\ . " <" . v:fname_in . " >" v:fname_out)
+		  return v:shell_error
+		endfun
+<	The related Vim variables are:
+		v:charconvert_from	name of the current encoding
+		v:charconvert_to	name of the desired encoding
+		v:fname_in		name of the input file
+		v:fname_out		name of the output file
+	Note that v:fname_in and v:fname_out will never be the same.
+	Note that v:charconvert_from and v:charconvert_to may be different
+	from 'encoding'.  Vim internally uses UTF-8 instead of UCS-2 or UCS-4.
+	Encryption is not done by Vim when using 'charconvert'.  If you want
+	to encrypt the file after conversion, 'charconvert' should take care
+	of this.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+				   *'cindent'* *'cin'* *'nocindent'* *'nocin'*
+'cindent' 'cin'		boolean	(default off)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+cindent|
+			feature}
+	Enables automatic C program indenting.  See 'cinkeys' to set the keys
+	that trigger reindenting in insert mode and 'cinoptions' to set your
+	preferred indent style.
+	If 'indentexpr' is not empty, it overrules 'cindent'.
+	If 'lisp' is not on and both 'indentexpr' and 'equalprg' are empty,
+	the "=" operator indents using this algorithm rather than calling an
+	external program.
+	See |C-indenting|.
+	When you don't like the way 'cindent' works, try the 'smartindent'
+	option or 'indentexpr'.
+	This option is not used when 'paste' is set.
+	NOTE: This option is reset when 'compatible' is set.
+
+							*'cinkeys'* *'cink'*
+'cinkeys' 'cink'	string	(default "0{,0},0),:,0#,!^F,o,O,e")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+cindent|
+			feature}
+	A list of keys that, when typed in Insert mode, cause reindenting of
+	the current line.  Only used if 'cindent' is on and 'indentexpr' is
+	empty.
+	For the format of this option see |cinkeys-format|.
+	See |C-indenting|.
+
+						*'cinoptions'* *'cino'*
+'cinoptions' 'cino'	string	(default "")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+cindent|
+			feature}
+	The 'cinoptions' affect the way 'cindent' reindents lines in a C
+	program.  See |cinoptions-values| for the values of this option, and
+	|C-indenting| for info on C indenting in general.
+
+
+						*'cinwords'* *'cinw'*
+'cinwords' 'cinw'	string	(default "if,else,while,do,for,switch")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without both the
+			|+cindent| and the |+smartindent| features}
+	These keywords start an extra indent in the next line when
+	'smartindent' or 'cindent' is set.  For 'cindent' this is only done at
+	an appropriate place (inside {}).
+	Note that 'ignorecase' isn't used for 'cinwords'.  If case doesn't
+	matter, include the keyword both the uppercase and lowercase:
+	"if,If,IF".
+
+						*'clipboard'* *'cb'*
+'clipboard' 'cb'	string	(default "autoselect,exclude:cons\|linux"
+						  for X-windows, "" otherwise)
+			global
+			{not in Vi}
+			{only in GUI versions or when the |+xterm_clipboard|
+			feature is included}
+	This option is a list of comma separated names.
+	These names are recognized:
+
+						*clipboard-unnamed*
+	unnamed		When included, Vim will use the clipboard register '*'
+			for all yank, delete, change and put operations which
+			would normally go to the unnamed register.  When a
+			register is explicitly specified, it will always be
+			used regardless of whether "unnamed" is in 'clipboard'
+			or not.  The clipboard register can always be
+			explicitly accessed using the "* notation.  Also see
+			|gui-clipboard|.
+
+						*clipboard-unnamedplus*
+	unnamedplus	A variant of the "unnamed" flag which uses the
+			clipboard register '+' (|quoteplus|) instead of
+			register '*' for all yank, delete, change and put
+			operations which would normally go to the unnamed
+			register.  When "unnamed" is also included to the
+			option, yank operations (but not delete, change or
+			put) will additionally copy the text into register
+			'*'.
+			Only available with the |+X11| feature.
+			Availability can be checked with: >
+				if has('unnamedplus')
+<
+						*clipboard-autoselect*
+	autoselect	Works like the 'a' flag in 'guioptions': If present,
+			then whenever Visual mode is started, or the Visual
+			area extended, Vim tries to become the owner of the
+			windowing system's global selection or put the
+			selected text on the clipboard used by the selection
+			register "*.  See |guioptions_a| and |quotestar| for
+			details.  When the GUI is active, the 'a' flag in
+			'guioptions' is used, when the GUI is not active, this
+			"autoselect" flag is used.
+			Also applies to the modeless selection.
+
+						*clipboard-autoselectplus*
+	autoselectplus  Like "autoselect" but using the + register instead of
+			the * register.  Compare to the 'P' flag in
+			'guioptions'.
+
+						*clipboard-autoselectml*
+	autoselectml	Like "autoselect", but for the modeless selection
+			only.  Compare to the 'A' flag in 'guioptions'.
+
+						*clipboard-html*
+	html		When the clipboard contains HTML, use this when
+			pasting.  When putting text on the clipboard, mark it
+			as HTML.  This works to copy rendered HTML from
+			Firefox, paste it as raw HTML in Vim, select the HTML
+			in Vim and paste it in a rich edit box in Firefox.
+			You probably want to add this only temporarily,
+			possibly use BufEnter autocommands.
+			Only supported for GTK version 2 and later.
+			Only available with the |+multi_byte| feature.
+
+						*clipboard-exclude*
+	exclude:{pattern}
+			Defines a pattern that is matched against the name of
+			the terminal 'term'.  If there is a match, no
+			connection will be made to the X server.  This is
+			useful in this situation:
+			- Running Vim in a console.
+			- $DISPLAY is set to start applications on another
+			  display.
+			- You do not want to connect to the X server in the
+			  console, but do want this in a terminal emulator.
+			To never connect to the X server use: >
+				exclude:.*
+<			This has the same effect as using the |-X| argument.
+			Note that when there is no connection to the X server
+			the window title won't be restored and the clipboard
+			cannot be accessed.
+			The value of 'magic' is ignored, {pattern} is
+			interpreted as if 'magic' was on.
+			The rest of the option value will be used for
+			{pattern}, this must be the last entry.
+
+						*'cmdheight'* *'ch'*
+'cmdheight' 'ch'	number	(default 1)
+			global
+			{not in Vi}
+	Number of screen lines to use for the command-line.  Helps avoiding
+	|hit-enter| prompts.
+	The value of this option is stored with the tab page, so that each tab
+	page can have a different value.
+
+						*'cmdwinheight'* *'cwh'*
+'cmdwinheight' 'cwh'	number	(default 7)
+			global
+			{not in Vi}
+			{not available when compiled without the |+vertsplit|
+			feature}
+	Number of screen lines to use for the command-line window. |cmdwin|
+
+						*'colorcolumn'* *'cc'*
+'colorcolumn' 'cc'	string	(default "")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	'colorcolumn' is a comma separated list of screen columns that are
+	highlighted with ColorColumn |hl-ColorColumn|.  Useful to align
+	text.  Will make screen redrawing slower.
+	The screen column can be an absolute number, or a number preceded with
+	'+' or '-', which is added to or subtracted from 'textwidth'. >
+
+		:set cc=+1  " highlight column after 'textwidth'
+		:set cc=+1,+2,+3  " highlight three columns after 'textwidth'
+		:hi ColorColumn ctermbg=lightgrey guibg=lightgrey
+<
+	When 'textwidth' is zero then the items with '-' and '+' are not used.
+	A maximum of 256 columns are highlighted.
+
+						*'columns'* *'co'* *E594*
+'columns' 'co'		number	(default 80 or terminal width)
+			global
+			{not in Vi}
+	Number of columns of the screen.  Normally this is set by the terminal
+	initialization and does not have to be set by hand.  Also see
+	|posix-screen-size|.
+	When Vim is running in the GUI or in a resizable window, setting this
+	option will cause the window size to be changed.  When you only want
+	to use the size for the GUI, put the command in your |gvimrc| file.
+	When you set this option and Vim is unable to change the physical
+	number of columns of the display, the display may be messed up.  For
+	the GUI it is always possible and Vim limits the number of columns to
+	what fits on the screen.  You can use this command to get the widest
+	window possible: >
+		:set columns=9999
+<	Minimum value is 12, maximum value is 10000.
+
+					*'comments'* *'com'* *E524* *E525*
+'comments' 'com'	string	(default
+				"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+comments|
+			feature}
+	A comma separated list of strings that can start a comment line.  See
+	|format-comments|.  See |option-backslash| about using backslashes to
+	insert a space.
+
+					*'commentstring'* *'cms'* *E537*
+'commentstring' 'cms'	string	(default "/*%s*/")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	A template for a comment.  The "%s" in the value is replaced with the
+	comment text.  Currently only used to add markers for folding, see
+	|fold-marker|.
+
+			*'compatible'* *'cp'* *'nocompatible'* *'nocp'*
+'compatible' 'cp'	boolean	(default on, off when a |vimrc| or |gvimrc|
+					file is found, reset in |defaults.vim|)
+			global
+			{not in Vi}
+	This option has the effect of making Vim either more Vi-compatible, or
+	make Vim behave in a more useful way.
+
+	This is a special kind of option, because when it's set or reset,
+	other options are also changed as a side effect.
+	NOTE: Setting or resetting this option can have a lot of unexpected
+	effects: Mappings are interpreted in another way, undo behaves
+	differently, etc.  If you set this option in your vimrc file, you
+	should probably put it at the very start.
+
+	By default this option is on and the Vi defaults are used for the
+	options.  This default was chosen for those people who want to use Vim
+	just like Vi, and don't even (want to) know about the 'compatible'
+	option.
+	When a |vimrc| or |gvimrc| file is found while Vim is starting up,
+	this option is switched off, and all options that have not been
+	modified will be set to the Vim defaults.  Effectively, this means
+	that when a |vimrc| or |gvimrc| file exists, Vim will use the Vim
+	defaults, otherwise it will use the Vi defaults.  (Note: This doesn't
+	happen for the system-wide vimrc or gvimrc file, nor for a file given
+	with the |-u| argument).  Also see |compatible-default| and
+	|posix-compliance|.
+	You can also set this option with the "-C" argument, and reset it with
+	"-N".  See |-C| and |-N|.
+	See 'cpoptions' for more fine tuning of Vi compatibility.
+
+	When this option is set, numerous other options are set to make Vim as
+	Vi-compatible as possible.  When this option is unset, various options
+	are set to make Vim more useful.  The table below lists all the
+	options affected.
+	The {?} column indicates when the options are affected:
+	+  Means that the option is set to the value given in {set value} when
+	   'compatible' is set.
+	&  Means that the option is set to the value given in {set value} when
+	   'compatible' is set AND is set to its Vim default value when
+	   'compatible' is unset.
+	-  Means the option is NOT changed when setting 'compatible' but IS
+	   set to its Vim default when 'compatible' is unset.
+	The {effect} column summarises the change when 'compatible' is set.
+
+	option		? set value	effect ~
+
+	'allowrevins'	+ off		no CTRL-_ command
+	'antialias'	+ off		don't use antialiased fonts
+	'arabic'	+ off	 	reset arabic-related options
+	'arabicshape'	+ on		correct character shapes
+	'backspace'	+ ""		normal backspace
+	'backup'	+ off		no backup file
+	'backupcopy'	& Unix: "yes"	backup file is a copy
+			  else: "auto"	copy or rename backup file
+	'balloonexpr'	+ ""		text to show in evaluation balloon
+	'breakindent'	+ off		don't indent when wrapping lines
+	'cedit'		- {unchanged}	{set vim default only on resetting 'cp'}
+	'cindent'	+ off		no C code indentation
+	'compatible'	- {unchanged}	{set vim default only on resetting 'cp'}
+	'copyindent'	+ off		don't copy indent structure
+	'cpoptions'	& (all flags)	Vi-compatible flags
+	'cscopepathcomp'+ 0		don't show directories in tags list
+	'cscoperelative'+ off		don't use basename of path as prefix
+	'cscopetag'	+ off		don't use cscope for ":tag"
+	'cscopetagorder'+ 0		see |cscopetagorder|
+	'cscopeverbose'	+ off		see |cscopeverbose|
+	'delcombine'	+ off		unicode: delete whole char combination
+	'digraph'	+ off		no digraphs
+	'esckeys'	& off		no <Esc>-keys in Insert mode
+	'expandtab'	+ off		tabs not expanded to spaces
+	'fileformats'	& ""		no automatic file format detection,
+			  "dos,unix"	except for DOS, Windows and OS/2
+	'formatexpr'	+ ""		use 'formatprg' for auto-formatting
+	'formatoptions'	& "vt"		Vi compatible formatting
+	'gdefault'	+ off		no default 'g' flag for ":s"
+	'history'	& 0		no commandline history
+	'hkmap'		+ off		no Hebrew keyboard mapping
+	'hkmapp'	+ off		no phonetic Hebrew keyboard mapping
+	'hlsearch'	+ off		no highlighting of search matches
+	'incsearch'	+ off		no incremental searching
+	'indentexpr'	+ ""		no indenting by expression
+	'insertmode'	+ off		do not start in Insert mode
+	'iskeyword'	& "@,48-57,_"	keywords contain alphanumeric
+						characters and '_'
+	'joinspaces'	+ on		insert 2 spaces after period
+	'modeline'	& off		no modelines
+	'more'		& off		no pauses in listings
+	'mzquantum'	- {unchanged}	{set vim default only on resetting 'cp'}
+	'numberwidth'	& 8		min number of columns for line number
+	'preserveindent'+ off		don't preserve current indent structure
+						when changing it
+	'revins'	+ off		no reverse insert
+	'ruler'		+ off		no ruler
+	'scrolljump'	+ 1		no jump scroll
+	'scrolloff'	+ 0		no scroll offset
+	'shelltemp'	- {unchanged}	{set vim default only on resetting 'cp'}
+	'shiftround'	+ off		indent not rounded to shiftwidth
+	'shortmess'	& ""		no shortening of messages
+	'showcmd'	& off		command characters not shown
+	'showmode'	& off		current mode not shown
+	'sidescrolloff'	+ 0		cursor moves to edge of screen in scroll
+	'smartcase'	+ off		no automatic ignore case switch
+	'smartindent'	+ off		no smart indentation
+	'smarttab'	+ off		no smart tab size
+	'softtabstop'	+ 0		tabs are always 'tabstop' positions
+	'startofline'	+ on		goto startofline with some commands
+	'tagcase'	& "followic"	'ignorecase' when searching tags file
+	'tagrelative'	& off		tag file names are not relative
+	'termguicolors'	+ off		don't use highlight-(guifg|guibg)
+	'textauto'	& off		no automatic textmode detection
+	'textwidth'	+ 0		no automatic line wrap
+	'tildeop'	+ off		tilde is not an operator
+	'ttimeout'	+ off		no terminal timeout
+	'undofile'	+ off		don't use an undo file
+	'viminfo'       - {unchanged}	{set Vim default only on resetting 'cp'}
+	'virtualedit'	+ ""		cursor can only be placed on characters
+	'whichwrap'	& ""		left-right movements don't wrap
+	'wildchar'	& CTRL-E	only when the current value is <Tab>
+					use CTRL-E for cmdline completion
+	'writebackup'	+ on or off	depends on the |+writebackup| feature
+
+						*'complete'* *'cpt'* *E535*
+'complete' 'cpt'	string	(default: ".,w,b,u,t,i")
+			local to buffer
+			{not in Vi}
+	This option specifies how keyword completion |ins-completion| works
+	when CTRL-P or CTRL-N are used.  It is also used for whole-line
+	completion |i_CTRL-X_CTRL-L|.  It indicates the type of completion
+	and the places to scan.  It is a comma separated list of flags:
+	.	scan the current buffer ('wrapscan' is ignored)
+	w	scan buffers from other windows
+	b	scan other loaded buffers that are in the buffer list
+	u	scan the unloaded buffers that are in the buffer list
+	U	scan the buffers that are not in the buffer list
+	k	scan the files given with the 'dictionary' option
+	kspell  use the currently active spell checking |spell|
+	k{dict}	scan the file {dict}.  Several "k" flags can be given,
+		patterns are valid too.  For example: >
+			:set cpt=k/usr/dict/*,k~/spanish
+<	s	scan the files given with the 'thesaurus' option
+	s{tsr}	scan the file {tsr}.  Several "s" flags can be given, patterns
+		are valid too.
+	i	scan current and included files
+	d	scan current and included files for defined name or macro
+		|i_CTRL-X_CTRL-D|
+	]	tag completion
+	t	same as "]"
+
+	Unloaded buffers are not loaded, thus their autocmds |:autocmd| are
+	not executed, this may lead to unexpected completions from some files
+	(gzipped files for example).  Unloaded buffers are not scanned for
+	whole-line completion.
+
+	The default is ".,w,b,u,t,i", which means to scan:
+	   1. the current buffer
+	   2. buffers in other windows
+	   3. other loaded buffers
+	   4. unloaded buffers
+	   5. tags
+	   6. included files
+
+	As you can see, CTRL-N and CTRL-P can be used to do any 'iskeyword'-
+	based expansion (e.g., dictionary |i_CTRL-X_CTRL-K|, included patterns
+	|i_CTRL-X_CTRL-I|, tags |i_CTRL-X_CTRL-]| and normal expansions).
+
+						*'completefunc'* *'cfu'*
+'completefunc' 'cfu'	string	(default: empty)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+eval|
+			or |+insert_expand| features}
+	This option specifies a function to be used for Insert mode completion
+	with CTRL-X CTRL-U. |i_CTRL-X_CTRL-U|
+	See |complete-functions| for an explanation of how the function is
+	invoked and what it should return.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'completeopt'* *'cot'*
+'completeopt' 'cot'	string	(default: "menu,preview")
+			global
+			{not available when compiled without the
+			|+insert_expand| feature}
+			{not in Vi}
+	A comma separated list of options for Insert mode completion
+	|ins-completion|.  The supported values are:
+
+	   menu	    Use a popup menu to show the possible completions.  The
+		    menu is only shown when there is more than one match and
+		    sufficient colors are available.  |ins-completion-menu|
+
+	   menuone  Use the popup menu also when there is only one match.
+		    Useful when there is additional information about the
+		    match, e.g., what file it comes from.
+
+	   longest  Only insert the longest common text of the matches.  If
+		    the menu is displayed you can use CTRL-L to add more
+		    characters.  Whether case is ignored depends on the kind
+		    of completion.  For buffer text the 'ignorecase' option is
+		    used.
+
+	   preview  Show extra information about the currently selected
+		    completion in the preview window.  Only works in
+		    combination with "menu" or "menuone".
+
+	   noinsert Do not insert any text for a match until the user selects
+		    a match from the menu. Only works in combination with
+		    "menu" or "menuone". No effect if "longest" is present.
+
+	   noselect Do not select a match in the menu, force the user to
+		    select one from the menu. Only works in combination with
+		    "menu" or "menuone".
+
+
+						*'concealcursor'* *'cocu'*
+'concealcursor' 'cocu'	string (default: "")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+conceal|
+			feature}
+	Sets the modes in which text in the cursor line can also be concealed.
+	When the current mode is listed then concealing happens just like in
+	other lines.
+	  n		Normal mode
+	  v		Visual mode
+	  i		Insert mode
+	  c		Command line editing, for 'incsearch'
+
+	'v' applies to all lines in the Visual area, not only the cursor.
+	A useful value is "nc".  This is used in help files.  So long as you
+	are moving around text is concealed, but when starting to insert text
+	or selecting a Visual area the concealed text is displayed, so that
+	you can see what you are doing.
+	Keep in mind that the cursor position is not always where it's
+	displayed.  E.g., when moving vertically it may change column.
+
+
+'conceallevel' 'cole'		*'conceallevel'* *'cole'*
+			number (default 0)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+conceal|
+			feature}
+	Determine how text with the "conceal" syntax attribute |:syn-conceal|
+	is shown:
+
+	Value		Effect ~
+	0		Text is shown normally
+	1		Each block of concealed text is replaced with one
+			character.  If the syntax item does not have a custom
+			replacement character defined (see |:syn-cchar|) the
+			character defined in 'listchars' is used (default is a
+			space).
+			It is highlighted with the "Conceal" highlight group.
+	2		Concealed text is completely hidden unless it has a
+			custom replacement character defined (see
+			|:syn-cchar|).
+	3		Concealed text is completely hidden.
+
+	Note: in the cursor line concealed text is not hidden, so that you can
+	edit and copy the text.  This can be changed with the 'concealcursor'
+	option.
+
+				*'confirm'* *'cf'* *'noconfirm'* *'nocf'*
+'confirm' 'cf'		boolean (default off)
+			global
+			{not in Vi}
+	When 'confirm' is on, certain operations that would normally
+	fail because of unsaved changes to a buffer, e.g. ":q" and ":e",
+	instead raise a |dialog| asking if you wish to save the current
+	file(s).  You can still use a ! to unconditionally |abandon| a buffer.
+	If 'confirm' is off you can still activate confirmation for one
+	command only (this is most useful in mappings) with the |:confirm|
+	command.
+	Also see the |confirm()| function and the 'v' flag in 'guioptions'.
+
+			*'conskey'* *'consk'* *'noconskey'* *'noconsk'*
+'conskey' 'consk'	boolean	(default off)
+			global
+			{not in Vi}  {only for MS-DOS}
+	This was for MS-DOS and is no longer supported.
+
+			*'copyindent'* *'ci'* *'nocopyindent'* *'noci'*
+'copyindent' 'ci'	boolean	(default off)
+			local to buffer
+			{not in Vi}
+	Copy the structure of the existing lines indent when autoindenting a
+	new line.  Normally the new indent is reconstructed by a series of
+	tabs followed by spaces as required (unless |'expandtab'| is enabled,
+	in which case only spaces are used).  Enabling this option makes the
+	new line copy whatever characters were used for indenting on the
+	existing line.  'expandtab' has no effect on these characters, a Tab
+	remains a Tab.  If the new indent is greater than on the existing
+	line, the remaining space is filled in the normal manner.
+	NOTE: This option is reset when 'compatible' is set.
+	Also see 'preserveindent'.
+
+						*'cpoptions'* *'cpo'* *cpo*
+'cpoptions' 'cpo'	string	(Vim default: "aABceFs",
+				 Vi default:  all flags)
+			global
+			{not in Vi}
+	A sequence of single character flags.  When a character is present
+	this indicates Vi-compatible behavior.  This is used for things where
+	not being Vi-compatible is mostly or sometimes preferred.
+	'cpoptions' stands for "compatible-options".
+	Commas can be added for readability.
+	To avoid problems with flags that are added in the future, use the
+	"+=" and "-=" feature of ":set" |add-option-flags|.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+	NOTE: This option is set to the POSIX default value at startup when
+	the Vi default value would be used and the $VIM_POSIX environment
+	variable exists |posix|.  This means Vim tries to behave like the
+	POSIX specification.
+
+	    contains	behavior	~
+								*cpo-a*
+		a	When included, a ":read" command with a file name
+			argument will set the alternate file name for the
+			current window.
+								*cpo-A*
+		A	When included, a ":write" command with a file name
+			argument will set the alternate file name for the
+			current window.
+								*cpo-b*
+		b	"\|" in a ":map" command is recognized as the end of
+			the map command.  The '\' is included in the mapping,
+			the text after the '|' is interpreted as the next
+			command.  Use a CTRL-V instead of a backslash to
+			include the '|' in the mapping.  Applies to all
+			mapping, abbreviation, menu and autocmd commands.
+			See also |map_bar|.
+								*cpo-B*
+		B	A backslash has no special meaning in mappings,
+			abbreviations, user commands and the "to" part of the
+			menu commands.  Remove this flag to be able to use a
+			backslash like a CTRL-V.  For example, the command
+			":map X \<Esc>" results in X being mapped to:
+				'B' included:	"\^["	 (^[ is a real <Esc>)
+				'B' excluded:	"<Esc>"  (5 characters)
+				('<' excluded in both cases)
+								*cpo-c*
+		c	Searching continues at the end of any match at the
+			cursor position, but not further than the start of the
+			next line.  When not present searching continues
+			one character from the cursor position.  With 'c'
+			"abababababab" only gets three matches when repeating
+			"/abab", without 'c' there are five matches.
+								*cpo-C*
+		C	Do not concatenate sourced lines that start with a
+			backslash.  See |line-continuation|.
+								*cpo-d*
+		d	Using "./" in the 'tags' option doesn't mean to use
+			the tags file relative to the current file, but the
+			tags file in the current directory.
+								*cpo-D*
+		D	Can't use CTRL-K to enter a digraph after Normal mode
+			commands with a character argument, like |r|, |f| and
+			|t|.
+								*cpo-e*
+		e	When executing a register with ":@r", always add a
+			<CR> to the last line, also when the register is not
+			linewise.  If this flag is not present, the register
+			is not linewise and the last line does not end in a
+			<CR>, then the last line is put on the command-line
+			and can be edited before hitting <CR>.
+								*cpo-E*
+		E	It is an error when using "y", "d", "c", "g~", "gu" or
+			"gU" on an Empty region.  The operators only work when
+			at least one character is to be operated on.  Example:
+			This makes "y0" fail in the first column.
+								*cpo-f*
+		f	When included, a ":read" command with a file name
+			argument will set the file name for the current buffer,
+			if the current buffer doesn't have a file name yet.
+								*cpo-F*
+		F	When included, a ":write" command with a file name
+			argument will set the file name for the current
+			buffer, if the current buffer doesn't have a file name
+			yet.  Also see |cpo-P|.
+								*cpo-g*
+		g	Goto line 1 when using ":edit" without argument.
+								*cpo-H*
+		H	When using "I" on a line with only blanks, insert
+			before the last blank.  Without this flag insert after
+			the last blank.
+								*cpo-i*
+		i	When included, interrupting the reading of a file will
+			leave it modified.
+								*cpo-I*
+		I	When moving the cursor up or down just after inserting
+			indent for 'autoindent', do not delete the indent.
+								*cpo-j*
+		j	When joining lines, only add two spaces after a '.',
+			not after '!' or '?'.  Also see 'joinspaces'.
+								*cpo-J*
+		J	A |sentence| has to be followed by two spaces after
+			the '.', '!' or '?'.  A <Tab> is not recognized as
+			white space.
+								*cpo-k*
+		k	Disable the recognition of raw key codes in
+			mappings, abbreviations, and the "to" part of menu
+			commands.  For example, if <Key> sends ^[OA (where ^[
+			is <Esc>), the command ":map X ^[OA" results in X
+			being mapped to:
+				'k' included:	"^[OA"	 (3 characters)
+				'k' excluded:	"<Key>"  (one key code)
+			Also see the '<' flag below.
+								*cpo-K*
+		K	Don't wait for a key code to complete when it is
+			halfway a mapping.  This breaks mapping <F1><F1> when
+			only part of the second <F1> has been read.  It
+			enables cancelling the mapping by typing <F1><Esc>.
+								*cpo-l*
+		l	Backslash in a [] range in a search pattern is taken
+			literally, only "\]", "\^", "\-" and "\\" are special.
+			See |/[]|
+			   'l' included: "/[ \t]"  finds <Space>, '\' and 't'
+			   'l' excluded: "/[ \t]"  finds <Space> and <Tab>
+			Also see |cpo-\|.
+								*cpo-L*
+		L	When the 'list' option is set, 'wrapmargin',
+			'textwidth', 'softtabstop' and Virtual Replace mode
+			(see |gR|) count a <Tab> as two characters, instead of
+			the normal behavior of a <Tab>.
+								*cpo-m*
+		m	When included, a showmatch will always wait half a
+			second.  When not included, a showmatch will wait half
+			a second or until a character is typed.  |'showmatch'|
+								*cpo-M*
+		M	When excluded, "%" matching will take backslashes into
+			account.  Thus in "( \( )" and "\( ( \)" the outer
+			parenthesis match.  When included "%" ignores
+			backslashes, which is Vi compatible.
+								*cpo-n*
+		n	When included, the column used for 'number' and
+			'relativenumber' will also be used for text of wrapped
+			lines.
+								*cpo-o*
+		o	Line offset to search command is not remembered for
+			next search.
+								*cpo-O*
+		O	Don't complain if a file is being overwritten, even
+			when it didn't exist when editing it.  This is a
+			protection against a file unexpectedly created by
+			someone else.  Vi didn't complain about this.
+								*cpo-p*
+		p	Vi compatible Lisp indenting.  When not present, a
+			slightly better algorithm is used.
+								*cpo-P*
+		P	When included, a ":write" command that appends to a
+			file will set the file name for the current buffer, if
+			the current buffer doesn't have a file name yet and
+			the 'F' flag is also included |cpo-F|.
+								*cpo-q*
+		q	When joining multiple lines leave the cursor at the
+			position where it would be when joining two lines.
+								*cpo-r*
+		r	Redo ("." command) uses "/" to repeat a search
+			command, instead of the actually used search string.
+								*cpo-R*
+		R	Remove marks from filtered lines.  Without this flag
+			marks are kept like |:keepmarks| was used.
+								*cpo-s*
+		s	Set buffer options when entering the buffer for the
+			first time.  This is like it is in Vim version 3.0.
+			And it is the default.  If not present the options are
+			set when the buffer is created.
+								*cpo-S*
+		S	Set buffer options always when entering a buffer
+			(except 'readonly', 'fileformat', 'filetype' and
+			'syntax').  This is the (most) Vi compatible setting.
+			The options are set to the values in the current
+			buffer.  When you change an option and go to another
+			buffer, the value is copied.  Effectively makes the
+			buffer options global to all buffers.
+
+			's'    'S'     copy buffer options
+			no     no      when buffer created
+			yes    no      when buffer first entered (default)
+			 X     yes     each time when buffer entered (vi comp.)
+								*cpo-t*
+		t	Search pattern for the tag command is remembered for
+			"n" command.  Otherwise Vim only puts the pattern in
+			the history for search pattern, but doesn't change the
+			last used search pattern.
+								*cpo-u*
+		u	Undo is Vi compatible.  See |undo-two-ways|.
+								*cpo-v*
+		v	Backspaced characters remain visible on the screen in
+			Insert mode.  Without this flag the characters are
+			erased from the screen right away.  With this flag the
+			screen newly typed text overwrites backspaced
+			characters.
+								*cpo-w*
+		w	When using "cw" on a blank character, only change one
+			character and not all blanks until the start of the
+			next word.
+								*cpo-W*
+		W	Don't overwrite a readonly file.  When omitted, ":w!"
+			overwrites a readonly file, if possible.
+								*cpo-x*
+		x	<Esc> on the command-line executes the command-line.
+			The default in Vim is to abandon the command-line,
+			because <Esc> normally aborts a command.  |c_<Esc>|
+								*cpo-X*
+		X	When using a count with "R" the replaced text is
+			deleted only once.  Also when repeating "R" with "."
+			and a count.
+								*cpo-y*
+		y	A yank command can be redone with ".".
+								*cpo-Z*
+		Z	When using "w!" while the 'readonly' option is set,
+			don't reset 'readonly'.
+								*cpo-!*
+		!	When redoing a filter command, use the last used
+			external command, whatever it was.  Otherwise the last
+			used -filter- command is used.
+								*cpo-$*
+		$	When making a change to one line, don't redisplay the
+			line, but put a '$' at the end of the changed text.
+			The changed text will be overwritten when you type the
+			new text.  The line is redisplayed if you type any
+			command that moves the cursor from the insertion
+			point.
+								*cpo-%*
+		%	Vi-compatible matching is done for the "%" command.
+			Does not recognize "#if", "#endif", etc.
+			Does not recognize "/*" and "*/".
+			Parens inside single and double quotes are also
+			counted, causing a string that contains a paren to
+			disturb the matching.  For example, in a line like
+			"if (strcmp("foo(", s))" the first paren does not
+			match the last one.  When this flag is not included,
+			parens inside single and double quotes are treated
+			specially.  When matching a paren outside of quotes,
+			everything inside quotes is ignored.  When matching a
+			paren inside quotes, it will find the matching one (if
+			there is one).  This works very well for C programs.
+			This flag is also used for other features, such as
+			C-indenting.
+								*cpo--*
+		-	When included, a vertical movement command fails when
+			it would go above the first line or below the last
+			line.  Without it the cursor moves to the first or
+			last line, unless it already was in that line.
+			Applies to the commands "-", "k", CTRL-P, "+", "j",
+			CTRL-N, CTRL-J and ":1234".
+								*cpo-+*
+		+	When included, a ":write file" command will reset the
+			'modified' flag of the buffer, even though the buffer
+			itself may still be different from its file.
+								*cpo-star*
+		*	Use ":*" in the same way as ":@".  When not included,
+			":*" is an alias for ":'<,'>", select the Visual area.
+								*cpo-<*
+		<	Disable the recognition of special key codes in |<>|
+			form in mappings, abbreviations, and the "to" part of
+			menu commands.  For example, the command
+			":map X <Tab>" results in X being mapped to:
+				'<' included:	"<Tab>"  (5 characters)
+				'<' excluded:	"^I"	 (^I is a real <Tab>)
+			Also see the 'k' flag above.
+								*cpo->*
+		>	When appending to a register, put a line break before
+			the appended text.
+								*cpo-;*
+		;	When using |,| or |;| to repeat the last |t| search
+			and the cursor is right in front of the searched
+			character, the cursor won't move. When not included,
+			the cursor would skip over it and jump to the
+			following occurrence.
+
+	POSIX flags.  These are not included in the Vi default value, except
+	when $VIM_POSIX was set on startup. |posix|
+
+	    contains	behavior	~
+								*cpo-#*
+		#	A count before "D", "o" and "O" has no effect.
+								*cpo-&*
+		&	When ":preserve" was used keep the swap file when
+			exiting normally while this buffer is still loaded.
+			This flag is tested when exiting.
+								*cpo-\*
+		\	Backslash in a [] range in a search pattern is taken
+			literally, only "\]" is special  See |/[]|
+			   '\' included: "/[ \-]"  finds <Space>, '\' and '-'
+			   '\' excluded: "/[ \-]"  finds <Space> and '-'
+			Also see |cpo-l|.
+								*cpo-/*
+		/	When "%" is used as the replacement string in a |:s|
+			command, use the previous replacement string. |:s%|
+								*cpo-{*
+		{	The |{| and |}| commands also stop at a "{" character
+			at the start of a line.
+								*cpo-.*
+		.	The ":chdir" and ":cd" commands fail if the current
+			buffer is modified, unless ! is used.  Vim doesn't
+			need this, since it remembers the full path of an
+			opened file.
+								*cpo-bar*
+		|	The value of the $LINES and $COLUMNS environment
+			variables overrule the terminal size values obtained
+			with system specific functions.
+
+
+						*'cryptmethod'* *'cm'*
+'cryptmethod' 'cm'	string	(default "zip")
+			global or local to buffer |global-local|
+			{not in Vi}
+	Method used for encryption when the buffer is written to a file:
+							*pkzip*
+	   zip		PkZip compatible method.  A weak kind of encryption.
+			Backwards compatible with Vim 7.2 and older.
+							*blowfish*
+	   blowfish	Blowfish method.  Medium strong encryption but it has
+			an implementation flaw.  Requires Vim 7.3 or later,
+			files can NOT be read by Vim 7.2 and older.  This adds
+			a "seed" to the file, every time you write the file
+			the encrypted bytes will be different.
+							*blowfish2*
+	   blowfish2	Blowfish method.  Medium strong encryption.  Requires
+			Vim 7.4.401 or later, files can NOT be read by Vim 7.3
+			and older.  This adds a "seed" to the file, every time
+			you write the file the encrypted bytes will be
+			different.  The whole undo file is encrypted, not just
+			the pieces of text.
+
+	You should use "blowfish2", also to re-encrypt older files.
+
+	When reading an encrypted file 'cryptmethod' will be set automatically
+	to the detected method of the file being read.  Thus if you write it
+	without changing 'cryptmethod' the same method will be used.
+	Changing 'cryptmethod' does not mark the file as modified, you have to
+	explicitly write it, you don't get a warning unless there are other
+	modifications.  Also see |:X|.
+
+	When setting the global value to an empty string, it will end up with
+	the value "zip".  When setting the local value to an empty string the
+	buffer will use the global value.
+
+	When a new encryption method is added in a later version of Vim, and
+	the current version does not recognize it, you will get	*E821* .
+	You need to edit this file with the later version of Vim.
+
+
+						*'cscopepathcomp'* *'cspc'*
+'cscopepathcomp' 'cspc'	number	(default 0)
+			global
+			{not available when compiled without the |+cscope|
+			feature}
+			{not in Vi}
+	Determines how many components of the path to show in a list of tags.
+	See |cscopepathcomp|.
+	NOTE: This option is set to 0 when 'compatible' is set.
+
+						*'cscopeprg'* *'csprg'*
+'cscopeprg' 'csprg'	string	(default "cscope")
+			global
+			{not available when compiled without the |+cscope|
+			feature}
+			{not in Vi}
+	Specifies the command to execute cscope.  See |cscopeprg|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'cscopequickfix'* *'csqf'*
+'cscopequickfix' 'csqf' string	(default "")
+			global
+			{not available when compiled without the |+cscope|
+			or |+quickfix| features}
+			{not in Vi}
+	Specifies whether to use quickfix window to show cscope results.
+	See |cscopequickfix|.
+
+		*'cscoperelative'* *'csre'* *'nocscoperelative'* *'nocsre'*
+'cscoperelative' 'csre' boolean (default off)
+			global
+			{not available when compiled without the |+cscope|
+			feature}
+			{not in Vi}
+	In the absence of a prefix (-P) for cscope. setting this option enables
+	to use the basename of cscope.out path as the prefix.
+	See |cscoperelative|.
+	NOTE: This option is reset when 'compatible' is set.
+
+				*'cscopetag'* *'cst'* *'nocscopetag'* *'nocst'*
+'cscopetag' 'cst'	boolean (default off)
+			global
+			{not available when compiled without the |+cscope|
+			feature}
+			{not in Vi}
+	Use cscope for tag commands.  See |cscope-options|.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'cscopetagorder'* *'csto'*
+'cscopetagorder' 'csto'	number	(default 0)
+			global
+			{not available when compiled without the |+cscope|
+			feature}
+			{not in Vi}
+	Determines the order in which ":cstag" performs a search.  See
+	|cscopetagorder|.
+	NOTE: This option is set to 0 when 'compatible' is set.
+
+					*'cscopeverbose'* *'csverb'*
+					*'nocscopeverbose'* *'nocsverb'*
+'cscopeverbose' 'csverb' boolean (default off)
+			global
+			{not available when compiled without the |+cscope|
+			feature}
+			{not in Vi}
+	Give messages when adding a cscope database.  See |cscopeverbose|.
+	NOTE: This option is reset when 'compatible' is set.
+
+			*'cursorbind'* *'crb'* *'nocursorbind'* *'nocrb'*
+'cursorbind' 'crb'	boolean  (default off)
+			local to window
+			{not in Vi}
+	When this option is set, as the cursor in the current
+	window moves other cursorbound windows (windows that also have
+	this option set) move their cursors to the corresponding line and
+	column.  This option is useful for viewing the
+	differences between two versions of a file (see 'diff'); in diff mode,
+	inserted and deleted lines (though not characters within a line) are
+	taken into account.
+
+
+			*'cursorcolumn'* *'cuc'* *'nocursorcolumn'* *'nocuc'*
+'cursorcolumn' 'cuc'	boolean	(default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	Highlight the screen column of the cursor with CursorColumn
+	|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing
+	slower.
+	If you only want the highlighting in the current window you can use
+	these autocommands: >
+		au WinLeave * set nocursorline nocursorcolumn
+		au WinEnter * set cursorline cursorcolumn
+<
+
+			*'cursorline'* *'cul'* *'nocursorline'* *'nocul'*
+'cursorline' 'cul'	boolean	(default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	Highlight the screen line of the cursor with CursorLine
+	|hl-CursorLine|.  Useful to easily spot the cursor.  Will make screen
+	redrawing slower.
+	When Visual mode is active the highlighting isn't used to make it
+	easier to see the selected text.
+
+
+						*'debug'*
+'debug'			string	(default "")
+			global
+			{not in Vi}
+	These values can be used:
+	msg	Error messages that would otherwise be omitted will be given
+		anyway.
+	throw	Error messages that would otherwise be omitted will be given
+		anyway and also throw an exception and set |v:errmsg|.
+	beep	A message will be given when otherwise only a beep would be
+		produced.
+	The values can be combined, separated by a comma.
+	"msg" and "throw" are useful for debugging 'foldexpr', 'formatexpr' or
+	'indentexpr'.
+
+						*'define'* *'def'*
+'define' 'def'		string	(default "^\s*#\s*define")
+			global or local to buffer |global-local|
+			{not in Vi}
+	Pattern to be used to find a macro definition.  It is a search
+	pattern, just like for the "/" command.  This option is used for the
+	commands like "[i" and "[d" |include-search|.  The 'isident' option is
+	used to recognize the defined name after the match:
+		{match with 'define'}{non-ID chars}{defined name}{non-ID char}
+	See |option-backslash| about inserting backslashes to include a space
+	or backslash.
+	The default value is for C programs.  For C++ this value would be
+	useful, to include const type declarations: >
+		^\(#\s*define\|[a-z]*\s*const\s*[a-z]*\)
+<	When using the ":set" command, you need to double the backslashes!
+
+			*'delcombine'* *'deco'* *'nodelcombine'* *'nodeco'*
+'delcombine' 'deco'	boolean (default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	If editing Unicode and this option is set, backspace and Normal mode
+	"x" delete each combining character on its own.  When it is off (the
+	default) the character along with its combining characters are
+	deleted.
+	Note: When 'delcombine' is set "xx" may work different from "2x"!
+
+	This is useful for Arabic, Hebrew and many other languages where one
+	may have combining characters overtop of base characters, and want
+	to remove only the combining ones.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'dictionary'* *'dict'*
+'dictionary' 'dict'	string	(default "")
+			global or local to buffer |global-local|
+			{not in Vi}
+	List of file names, separated by commas, that are used to lookup words
+	for keyword completion commands |i_CTRL-X_CTRL-K|.  Each file should
+	contain a list of words.  This can be one word per line, or several
+	words per line, separated by non-keyword characters (white space is
+	preferred).  Maximum line length is 510 bytes.
+
+	When this option is empty or an entry "spell" is present, and spell
+	checking is enabled, words in the word lists for the currently active
+	'spelllang' are used. See |spell|.
+
+	To include a comma in a file name precede it with a backslash.  Spaces
+	after a comma are ignored, otherwise spaces are included in the file
+	name.  See |option-backslash| about using backslashes.
+	This has nothing to do with the |Dictionary| variable type.
+	Where to find a list of words?
+	- On FreeBSD, there is the file "/usr/share/dict/words".
+	- In the Simtel archive, look in the "msdos/linguist" directory.
+	- In "miscfiles" of the GNU collection.
+	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	directories from the list.  This avoids problems when a future version
+	uses another default.
+	Backticks cannot be used in this option for security reasons.
+
+							*'diff'* *'nodiff'*
+'diff'			boolean	(default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+diff|
+			feature}
+	Join the current window in the group of windows that shows differences
+	between files.  See |vimdiff|.
+
+						*'dex'* *'diffexpr'*
+'diffexpr' 'dex'	string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+diff|
+			feature}
+	Expression which is evaluated to obtain an ed-style diff file from two
+	versions of a file.  See |diff-diffexpr|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'dip'* *'diffopt'*
+'diffopt' 'dip'		string	(default "filler")
+			global
+			{not in Vi}
+			{not available when compiled without the |+diff|
+			feature}
+	Option settings for diff mode.  It can consist of the following items.
+	All are optional.  Items must be separated by a comma.
+
+		filler		Show filler lines, to keep the text
+				synchronized with a window that has inserted
+				lines at the same position.  Mostly useful
+				when windows are side-by-side and 'scrollbind'
+				is set.
+
+		context:{n}	Use a context of {n} lines between a change
+				and a fold that contains unchanged lines.
+				When omitted a context of six lines is used.
+				See |fold-diff|.
+
+		icase		Ignore changes in case of text.  "a" and "A"
+				are considered the same.  Adds the "-i" flag
+				to the "diff" command if 'diffexpr' is empty.
+
+		iwhite		Ignore changes in amount of white space.  Adds
+				the "-b" flag to the "diff" command if
+				'diffexpr' is empty.  Check the documentation
+				of the "diff" command for what this does
+				exactly.  It should ignore adding trailing
+				white space, but not leading white space.
+
+		horizontal	Start diff mode with horizontal splits (unless
+				explicitly specified otherwise).
+
+		vertical	Start diff mode with vertical splits (unless
+				explicitly specified otherwise).
+
+		hiddenoff	Do not use diff mode for a buffer when it
+				becomes hidden.
+
+		foldcolumn:{n}	Set the 'foldcolumn' option to {n} when
+				starting diff mode.  Without this 2 is used.
+
+	Examples: >
+
+		:set diffopt=filler,context:4
+		:set diffopt=
+		:set diffopt=filler,foldcolumn:3
+<
+				     *'digraph'* *'dg'* *'nodigraph'* *'nodg'*
+'digraph' 'dg'		boolean	(default off)
+			global
+			{not in Vi}
+			{not available when compiled without the |+digraphs|
+			feature}
+	Enable the entering of digraphs in Insert mode with {char1} <BS>
+	{char2}.  See |digraphs|.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'directory'* *'dir'*
+'directory' 'dir'	string	(default for Amiga: ".,t:",
+				 for MS-DOS and Win32: ".,$TEMP,c:\tmp,c:\temp"
+				 for Unix: ".,~/tmp,/var/tmp,/tmp")
+			global
+	List of directory names for the swap file, separated with commas.
+	- The swap file will be created in the first directory where this is
+	  possible.
+	- Empty means that no swap file will be used (recovery is
+	  impossible!).
+	- A directory "." means to put the swap file in the same directory as
+	  the edited file.  On Unix, a dot is prepended to the file name, so
+	  it doesn't show in a directory listing.  On MS-Windows the "hidden"
+	  attribute is set and a dot prepended if possible.
+	- A directory starting with "./" (or ".\" for MS-DOS et al.) means to
+	  put the swap file relative to where the edited file is.  The leading
+	  "." is replaced with the path name of the edited file.
+	- For Unix and Win32, if a directory ends in two path separators "//",
+	  the swap file name will be built from the complete path to the file
+	  with all path separators substituted to percent '%' signs. This will
+	  ensure file name uniqueness in the preserve directory.
+	  On Win32, it is also possible to end with "\\".  However, When a
+	  separating comma is following, you must use "//", since "\\" will
+	  include the comma in the file name. Therefore it is recommended to
+	  use '//', instead of '\\'.
+	- Spaces after the comma are ignored, other spaces are considered part
+	  of the directory name.  To have a space at the start of a directory
+	  name, precede it with a backslash.
+	- To include a comma in a directory name precede it with a backslash.
+	- A directory name may end in an ':' or '/'.
+	- Environment variables are expanded |:set_env|.
+	- Careful with '\' characters, type one before a space, type two to
+	  get one in the option (see |option-backslash|), for example: >
+	    :set dir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
+<	- For backwards compatibility with Vim version 3.0 a '>' at the start
+	  of the option is removed.
+	Using "." first in the list is recommended.  This means that editing
+	the same file twice will result in a warning.  Using "/tmp" on Unix is
+	discouraged: When the system crashes you lose the swap file.
+	"/var/tmp" is often not cleared when rebooting, thus is a better
+	choice than "/tmp".  But it can contain a lot of files, your swap
+	files get lost in the crowd.  That is why a "tmp" directory in your
+	home directory is tried first.
+	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	directories from the list.  This avoids problems when a future version
+	uses another default.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+	{Vi: directory to put temp file in, defaults to "/tmp"}
+
+					*'display'* *'dy'*
+'display' 'dy'		string	(default "", set to "truncate" in
+							       |defaults.vim|)
+			global
+			{not in Vi}
+	Change the way text is displayed.  This is comma separated list of
+	flags:
+	lastline	When included, as much as possible of the last line
+			in a window will be displayed.  "@@@" is put in the
+			last columns of the last screen line to indicate the
+			rest of the line is not displayed.
+	truncate	Like "lastline", but "@@@" is displayed in the first
+			column of the last screen line.  Overrules "lastline".
+	uhex		Show unprintable characters hexadecimal as <xx>
+			instead of using ^C and ~C.
+
+	When neither "lastline" nor "truncate" is included, a last line that
+	doesn't fit is replaced with "@" lines.
+
+						*'eadirection'* *'ead'*
+'eadirection' 'ead'	string	(default "both")
+			global
+			{not in Vi}
+			{not available when compiled without the |+vertsplit|
+			feature}
+	Tells when the 'equalalways' option applies:
+		ver	vertically, width of windows is not affected
+		hor	horizontally, height of windows is not affected
+		both	width and height of windows is affected
+
+			   *'ed'* *'edcompatible'* *'noed'* *'noedcompatible'*
+'edcompatible' 'ed'	boolean	(default off)
+			global
+	Makes the 'g' and 'c' flags of the ":substitute" command to be
+	toggled each time the flag is given.  See |complex-change|.  See
+	also 'gdefault' option.
+	Switching this option on may break plugins!
+
+					*'emoji'* *'emo'* *'noemoji'* *'noemo'*
+'emoji' 'emo'	boolean (default: on)
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	When on all Unicode emoji characters are considered to be full width.
+
+
+					*'encoding'* *'enc'* *E543*
+'encoding' 'enc'	string (default: "latin1" or value from $LANG)
+			global
+			{only available when compiled with the |+multi_byte|
+			feature}
+			{not in Vi}
+	Sets the character encoding used inside Vim.  It applies to text in
+	the buffers, registers, Strings in expressions, text stored in the
+	viminfo file, etc.  It sets the kind of characters which Vim can work
+	with.  See |encoding-names| for the possible values.
+
+	NOTE: Changing this option will not change the encoding of the
+	existing text in Vim.  It may cause non-ASCII text to become invalid.
+	It should normally be kept at its default value, or set when Vim
+	starts up.  See |multibyte|.  To reload the menus see |:menutrans|.
+
+	This option cannot be set from a |modeline|.  It would most likely
+	corrupt the text.
+
+	NOTE: For GTK+ 2 or later, it is highly recommended to set 'encoding'
+	to "utf-8".  Although care has been taken to allow different values of
+	'encoding', "utf-8" is the natural choice for the environment and
+	avoids unnecessary conversion overhead.  "utf-8" has not been made
+	the default to prevent different behavior of the GUI and terminal
+	versions, and to avoid changing the encoding of newly created files
+	without your knowledge (in case 'fileencodings' is empty).
+
+	The character encoding of files can be different from 'encoding'.
+	This is specified with 'fileencoding'.  The conversion is done with
+	iconv() or as specified with 'charconvert'.
+
+	If you need to know whether 'encoding' is a multi-byte encoding, you
+	can use: >
+		if has("multi_byte_encoding")
+<
+	Normally 'encoding' will be equal to your current locale.  This will
+	be the default if Vim recognizes your environment settings.  If
+	'encoding' is not set to the current locale, 'termencoding' must be
+	set to convert typed and displayed text.  See |encoding-table|.
+
+	When you set this option, it fires the |EncodingChanged| autocommand
+	event so that you can set up fonts if necessary.
+
+	When the option is set, the value is converted to lowercase.  Thus
+	you can set it with uppercase values too.  Underscores are translated
+	to '-' signs.
+	When the encoding is recognized, it is changed to the standard name.
+	For example "Latin-1" becomes "latin1", "ISO_88592" becomes
+	"iso-8859-2" and "utf8" becomes "utf-8".
+
+	Note: "latin1" is also used when the encoding could not be detected.
+	This only works when editing files in the same encoding!  When the
+	actual character set is not latin1, make sure 'fileencoding' and
+	'fileencodings' are empty.  When conversion is needed, switch to using
+	utf-8.
+
+	When "unicode", "ucs-2" or "ucs-4" is used, Vim internally uses utf-8.
+	You don't notice this while editing, but it does matter for the
+	|viminfo-file|.  And Vim expects the terminal to use utf-8 too.  Thus
+	setting 'encoding' to one of these values instead of utf-8 only has
+	effect for encoding used for files when 'fileencoding' is empty.
+
+	When 'encoding' is set to a Unicode encoding, and 'fileencodings' was
+	not set yet, the default for 'fileencodings' is changed.
+
+			*'endofline'* *'eol'* *'noendofline'* *'noeol'*
+'endofline' 'eol'	boolean	(default on)
+			local to buffer
+			{not in Vi}
+	When writing a file and this option is off and the 'binary' option
+	is on, or 'fixeol' option is off, no <EOL> will be written for the
+	last line in the file.  This option is automatically set or reset when
+	starting to edit a new file, depending on whether file has an <EOL>
+	for the last line in the file.  Normally you don't have to set or
+	reset this option.
+	When 'binary' is off and 'fixeol' is on the value is not used when
+	writing the file.  When 'binary' is on or 'fixeol' is off it is used
+	to remember the presence of a <EOL> for the last line in the file, so
+	that when you write the file the situation from the original file can
+	be kept.  But you can change it if you want to.
+
+			     *'equalalways'* *'ea'* *'noequalalways'* *'noea'*
+'equalalways' 'ea'	boolean	(default on)
+			global
+			{not in Vi}
+	When on, all the windows are automatically made the same size after
+	splitting or closing a window.  This also happens the moment the
+	option is switched on.  When off, splitting a window will reduce the
+	size of the current window and leave the other windows the same.  When
+	closing a window the extra lines are given to the window next to it
+	(depending on 'splitbelow' and 'splitright').
+	When mixing vertically and horizontally split windows, a minimal size
+	is computed and some windows may be larger if there is room.  The
+	'eadirection' option tells in which direction the size is affected.
+	Changing the height and width of a window can be avoided by setting
+	'winfixheight' and 'winfixwidth', respectively.
+	If a window size is specified when creating a new window sizes are
+	currently not equalized (it's complicated, but may be implemented in
+	the future).
+
+						*'equalprg'* *'ep'*
+'equalprg' 'ep'		string	(default "")
+			global or local to buffer |global-local|
+			{not in Vi}
+	External program to use for "=" command.  When this option is empty
+	the internal formatting functions are used; either 'lisp', 'cindent'
+	or 'indentexpr'.  When Vim was compiled without internal formatting,
+	the "indent" program is used.
+	Environment variables are expanded |:set_env|.  See |option-backslash|
+	about including spaces and backslashes.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+			*'errorbells'* *'eb'* *'noerrorbells'* *'noeb'*
+'errorbells' 'eb'	boolean	(default off)
+			global
+	Ring the bell (beep or screen flash) for error messages.  This only
+	makes a difference for error messages, the bell will be used always
+	for a lot of errors without a message (e.g., hitting <Esc> in Normal
+	mode).  See 'visualbell' on how to make the bell behave like a beep,
+	screen flash or do nothing. See 'belloff' to finetune when to ring the
+	bell.
+
+						*'errorfile'* *'ef'*
+'errorfile' 'ef'	string	(Amiga default: "AztecC.Err",
+					others: "errors.err")
+			global
+			{not in Vi}
+			{not available when compiled without the |+quickfix|
+			feature}
+	Name of the errorfile for the QuickFix mode (see |:cf|).
+	When the "-q" command-line argument is used, 'errorfile' is set to the
+	following argument.  See |-q|.
+	NOT used for the ":make" command.  See 'makeef' for that.
+	Environment variables are expanded |:set_env|.
+	See |option-backslash| about including spaces and backslashes.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'errorformat'* *'efm'*
+'errorformat' 'efm'	string	(default is very long)
+			global or local to buffer |global-local|
+			{not in Vi}
+			{not available when compiled without the |+quickfix|
+			feature}
+	Scanf-like description of the format for the lines in the error file
+	(see |errorformat|).
+
+				     *'esckeys'* *'ek'* *'noesckeys'* *'noek'*
+'esckeys' 'ek'		boolean	(Vim default: on, Vi default: off)
+			global
+			{not in Vi}
+	Function keys that start with an <Esc> are recognized in Insert
+	mode.  When this option is off, the cursor and function keys cannot be
+	used in Insert mode if they start with an <Esc>.  The advantage of
+	this is that the single <Esc> is recognized immediately, instead of
+	after one second.  Instead of resetting this option, you might want to
+	try changing the values for 'timeoutlen' and 'ttimeoutlen'.  Note that
+	when 'esckeys' is off, you can still map anything, but the cursor keys
+	won't work by default.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'eventignore'* *'ei'*
+'eventignore' 'ei'	string	(default "")
+			global
+			{not in Vi}
+	A list of autocommand event names, which are to be ignored.
+	When set to "all" or when "all" is one of the items, all autocommand
+	events are ignored, autocommands will not be executed.
+	Otherwise this is a comma separated list of event names.  Example: >
+	    :set ei=WinEnter,WinLeave
+<
+				 *'expandtab'* *'et'* *'noexpandtab'* *'noet'*
+'expandtab' 'et'	boolean	(default off)
+			local to buffer
+			{not in Vi}
+	In Insert mode: Use the appropriate number of spaces to insert a
+	<Tab>.  Spaces are used in indents with the '>' and '<' commands and
+	when 'autoindent' is on.  To insert a real tab when 'expandtab' is
+	on, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|.
+	This option is reset when the 'paste' option is set and restored when
+	the 'paste' option is reset.
+	NOTE: This option is reset when 'compatible' is set.
+
+					*'exrc'* *'ex'* *'noexrc'* *'noex'*
+'exrc' 'ex'		boolean (default off)
+			global
+			{not in Vi}
+	Enables the reading of .vimrc, .exrc and .gvimrc in the current
+	directory.
+
+	Setting this option is a potential security leak.  E.g., consider
+	unpacking a package or fetching files from github, a .vimrc in there
+	might be a trojan horse.  BETTER NOT SET THIS OPTION!
+	Instead, define an autocommand in your .vimrc to set options for a
+	matching directory.
+
+	If you do switch this option on you should also consider setting the
+	'secure' option (see |initialization|).
+	Also see |.vimrc| and |gui-init|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+				*'fileencoding'* *'fenc'* *E213*
+'fileencoding' 'fenc'	string (default: "")
+			local to buffer
+			{only available when compiled with the |+multi_byte|
+			feature}
+			{not in Vi}
+	Sets the character encoding for the file of this buffer.
+
+	When 'fileencoding' is different from 'encoding', conversion will be
+	done when writing the file.  For reading see below.
+	When 'fileencoding' is empty, the same value as 'encoding' will be
+	used (no conversion when reading or writing a file).
+	No error will be given when the value is set, only when it is used,
+	only when writing a file.
+	Conversion will also be done when 'encoding' and 'fileencoding' are
+	both a Unicode encoding and 'fileencoding' is not utf-8.  That's
+	because internally Unicode is always stored as utf-8.
+		WARNING: Conversion can cause loss of information!  When
+		'encoding' is "utf-8" or another Unicode encoding, conversion
+		is most likely done in a way that the reverse conversion
+		results in the same text.  When 'encoding' is not "utf-8" some
+		characters may be lost!
+
+	See 'encoding' for the possible values.  Additionally, values may be
+	specified that can be handled by the converter, see
+	|mbyte-conversion|.
+
+	When reading a file 'fileencoding' will be set from 'fileencodings'.
+	To read a file in a certain encoding it won't work by setting
+	'fileencoding', use the |++enc| argument.  One exception: when
+	'fileencodings' is empty the value of 'fileencoding' is used.
+	For a new file the global value of 'fileencoding' is used.
+
+	Prepending "8bit-" and "2byte-" has no meaning here, they are ignored.
+	When the option is set, the value is converted to lowercase.  Thus
+	you can set it with uppercase values too.  '_' characters are
+	replaced with '-'.  If a name is recognized from the list for
+	'encoding', it is replaced by the standard name.  For example
+	"ISO8859-2" becomes "iso-8859-2".
+
+	When this option is set, after starting to edit a file, the 'modified'
+	option is set, because the file would be different when written.
+
+	Keep in mind that changing 'fenc' from a modeline happens
+	AFTER the text has been read, thus it applies to when the file will be
+	written.  If you do set 'fenc' in a modeline, you might want to set
+	'nomodified' to avoid not being able to ":q".
+
+	This option can not be changed when 'modifiable' is off.
+
+							*'fe'*
+	NOTE: Before version 6.0 this option specified the encoding for the
+	whole of Vim, this was a mistake.  Now use 'encoding' instead.  The
+	old short name was 'fe', which is no longer used.
+
+					*'fileencodings'* *'fencs'*
+'fileencodings' 'fencs'	string (default: "ucs-bom",
+				    "ucs-bom,utf-8,default,latin1" when
+				    'encoding' is set to a Unicode value)
+			global
+			{only available when compiled with the |+multi_byte|
+			feature}
+			{not in Vi}
+	This is a list of character encodings considered when starting to edit
+	an existing file.  When a file is read, Vim tries to use the first
+	mentioned character encoding.  If an error is detected, the next one
+	in the list is tried.  When an encoding is found that works,
+	'fileencoding' is set to it.  If all fail, 'fileencoding' is set to
+	an empty string, which means the value of 'encoding' is used.
+		WARNING: Conversion can cause loss of information!  When
+		'encoding' is "utf-8" (or one of the other Unicode variants)
+		conversion is most likely done in a way that the reverse
+		conversion results in the same text.  When 'encoding' is not
+		"utf-8" some non-ASCII characters may be lost!  You can use
+		the |++bad| argument to specify what is done with characters
+		that can't be converted.
+	For an empty file or a file with only ASCII characters most encodings
+	will work and the first entry of 'fileencodings' will be used (except
+	"ucs-bom", which requires the BOM to be present).  If you prefer
+	another encoding use an BufReadPost autocommand event to test if your
+	preferred encoding is to be used.  Example: >
+		au BufReadPost * if search('\S', 'w') == 0 |
+			\ set fenc=iso-2022-jp | endif
+<	This sets 'fileencoding' to "iso-2022-jp" if the file does not contain
+	non-blank characters.
+	When the |++enc| argument is used then the value of 'fileencodings' is
+	not used.
+	Note that 'fileencodings' is not used for a new file, the global value
+	of 'fileencoding' is used instead.  You can set it with: >
+		:setglobal fenc=iso-8859-2
+<	This means that a non-existing file may get a different encoding than
+	an empty file.
+	The special value "ucs-bom" can be used to check for a Unicode BOM
+	(Byte Order Mark) at the start of the file.  It must not be preceded
+	by "utf-8" or another Unicode encoding for this to work properly.
+	An entry for an 8-bit encoding (e.g., "latin1") should be the last,
+	because Vim cannot detect an error, thus the encoding is always
+	accepted.
+	The special value "default" can be used for the encoding from the
+	environment.  This is the default value for 'encoding'.  It is useful
+	when 'encoding' is set to "utf-8" and your environment uses a
+	non-latin1 encoding, such as Russian.
+	When 'encoding' is "utf-8" and a file contains an illegal byte
+	sequence it won't be recognized as UTF-8.  You can use the |8g8|
+	command to find the illegal byte sequence.
+	WRONG VALUES:			WHAT'S WRONG:
+		latin1,utf-8		"latin1" will always be used
+		utf-8,ucs-bom,latin1	BOM won't be recognized in an utf-8
+					file
+		cp1250,latin1		"cp1250" will always be used
+	If 'fileencodings' is empty, 'fileencoding' is not modified.
+	See 'fileencoding' for the possible values.
+	Setting this option does not have an effect until the next time a file
+	is read.
+
+					*'fileformat'* *'ff'*
+'fileformat' 'ff'	string (MS-DOS, MS-Windows, OS/2 default: "dos",
+				Unix default: "unix",
+				Macintosh default: "mac")
+			local to buffer
+			{not in Vi}
+	This gives the <EOL> of the current buffer, which is used for
+	reading/writing the buffer from/to a file:
+	    dos	    <CR> <NL>
+	    unix    <NL>
+	    mac	    <CR>
+	When "dos" is used, CTRL-Z at the end of a file is ignored.
+	See |file-formats| and |file-read|.
+	For the character encoding of the file see 'fileencoding'.
+	When 'binary' is set, the value of 'fileformat' is ignored, file I/O
+	works like it was set to "unix".
+	This option is set automatically when starting to edit a file and
+	'fileformats' is not empty and 'binary' is off.
+	When this option is set, after starting to edit a file, the 'modified'
+	option is set, because the file would be different when written.
+	This option can not be changed when 'modifiable' is off.
+	For backwards compatibility: When this option is set to "dos",
+	'textmode' is set, otherwise 'textmode' is reset.
+
+					*'fileformats'* *'ffs'*
+'fileformats' 'ffs'	string (default:
+				Vim+Vi	MS-DOS, MS-Windows OS/2: "dos,unix",
+				Vim	Unix: "unix,dos",
+				Vim	Mac: "mac,unix,dos",
+				Vi	Cygwin: "unix,dos",
+				Vi	others: "")
+			global
+			{not in Vi}
+	This gives the end-of-line (<EOL>) formats that will be tried when
+	starting to edit a new buffer and when reading a file into an existing
+	buffer:
+	- When empty, the format defined with 'fileformat' will be used
+	  always.  It is not set automatically.
+	- When set to one name, that format will be used whenever a new buffer
+	  is opened.  'fileformat' is set accordingly for that buffer.  The
+	  'fileformats' name will be used when a file is read into an existing
+	  buffer, no matter what 'fileformat' for that buffer is set to.
+	- When more than one name is present, separated by commas, automatic
+	  <EOL> detection will be done when reading a file.  When starting to
+	  edit a file, a check is done for the <EOL>:
+	  1. If all lines end in <CR><NL>, and 'fileformats' includes "dos",
+	     'fileformat' is set to "dos".
+	  2. If a <NL> is found and 'fileformats' includes "unix", 'fileformat'
+	     is set to "unix".  Note that when a <NL> is found without a
+	     preceding <CR>, "unix" is preferred over "dos".
+	  3. If 'fileformat' has not yet been set, and if a <CR> is found, and
+	     if 'fileformats' includes "mac", 'fileformat' is set to "mac".
+	     This means that "mac" is only chosen when:
+	      "unix" is not present or no <NL> is found in the file, and
+	      "dos" is not present or no <CR><NL> is found in the file.
+	     Except: if "unix" was chosen, but there is a <CR> before
+	     the first <NL>, and there appear to be more <CR>s than <NL>s in
+	     the first few lines, "mac" is used.
+	  4. If 'fileformat' is still not set, the first name from
+	     'fileformats' is used.
+	  When reading a file into an existing buffer, the same is done, but
+	  this happens like 'fileformat' has been set appropriately for that
+	  file only, the option is not changed.
+	When 'binary' is set, the value of 'fileformats' is not used.
+
+	When Vim starts up with an empty buffer the first item is used.  You
+	can overrule this by setting 'fileformat' in your .vimrc.
+
+	For systems with a Dos-like <EOL> (<CR><NL>), when reading files that
+	are ":source"ed and for vimrc files, automatic <EOL> detection may be
+	done:
+	- When 'fileformats' is empty, there is no automatic detection.  Dos
+	  format will be used.
+	- When 'fileformats' is set to one or more names, automatic detection
+	  is done.  This is based on the first <NL> in the file: If there is a
+	  <CR> in front of it, Dos format is used, otherwise Unix format is
+	  used.
+	Also see |file-formats|.
+	For backwards compatibility: When this option is set to an empty
+	string or one format (no comma is included), 'textauto' is reset,
+	otherwise 'textauto' is set.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+		*'fileignorecase'* *'fic'* *'nofileignorecase'* *'nofic'*
+'fileignorecase' 'fic'	boolean	(default on for systems where case in file
+				 names is normally ignored)
+			global
+			{not in Vi}
+	When set case is ignored when using file names and directories.
+	See 'wildignorecase' for only ignoring case when doing completion.
+
+					*'filetype'* *'ft'*
+'filetype' 'ft'		string (default: "")
+			local to buffer
+			{not in Vi}
+	When this option is set, the FileType autocommand event is triggered.
+	All autocommands that match with the value of this option will be
+	executed.  Thus the value of 'filetype' is used in place of the file
+	name.
+	Otherwise this option does not always reflect the current file type.
+	This option is normally set when the file type is detected.  To enable
+	this use the ":filetype on" command. |:filetype|
+	Setting this option to a different value is most useful in a modeline,
+	for a file for which the file type is not automatically recognized.
+	Example, for in an IDL file:
+		/* vim: set filetype=idl : */ ~
+	|FileType| |filetypes|
+	When a dot appears in the value then this separates two filetype
+	names.  Example:
+		/* vim: set filetype=c.doxygen : */ ~
+	This will use the "c" filetype first, then the "doxygen" filetype.
+	This works both for filetype plugins and for syntax files.  More than
+	one dot may appear.
+	This option is not copied to another buffer, independent of the 's' or
+	'S' flag in 'cpoptions'.
+	Only normal file name characters can be used, "/\*?[|<>" are illegal.
+
+						*'fillchars'* *'fcs'*
+'fillchars' 'fcs'	string	(default "vert:|,fold:-")
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			and |+folding| features}
+	Characters to fill the statuslines and vertical separators.
+	It is a comma separated list of items:
+
+	  item		default		Used for ~
+	  stl:c		' ' or '^'	statusline of the current window
+	  stlnc:c	' ' or '='	statusline of the non-current windows
+	  vert:c	'|'		vertical separators |:vsplit|
+	  fold:c	'-'		filling 'foldtext'
+	  diff:c	'-'		deleted lines of the 'diff' option
+
+	Any one that is omitted will fall back to the default.  For "stl" and
+	"stlnc" the space will be used when there is highlighting, '^' or '='
+	otherwise.
+
+	Example: >
+	    :set fillchars=stl:^,stlnc:=,vert:\|,fold:-,diff:-
+<	This is similar to the default, except that these characters will also
+	be used when there is highlighting.
+
+	for "stl" and "stlnc" only single-byte values are supported.
+
+	The highlighting used for these items:
+	  item		highlight group ~
+	  stl:c		StatusLine		|hl-StatusLine|
+	  stlnc:c	StatusLineNC		|hl-StatusLineNC|
+	  vert:c	VertSplit		|hl-VertSplit|
+	  fold:c	Folded			|hl-Folded|
+	  diff:c	DiffDelete		|hl-DiffDelete|
+
+		*'fixendofline'* *'fixeol'* *'nofixendofline'* *'nofixeol'*
+'fixendofline' 'fixeol'	boolean	(default on)
+			local to buffer
+			{not in Vi}
+	When writing a file and this option is on, <EOL> at the end of file
+	will be restored if missing. Turn this option off if you want to
+	preserve the situation from the original file.
+	When the 'binary' option is set the value of this option doesn't
+	matter.
+	See the 'endofline' option.
+
+					*'fkmap'* *'fk'* *'nofkmap'* *'nofk'*
+'fkmap' 'fk'		boolean (default off)			*E198*
+			global
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	When on, the keyboard is mapped for the Farsi character set.
+	Normally you would set 'allowrevins' and use CTRL-_ in insert mode to
+	toggle this option |i_CTRL-_|.  See |farsi.txt|.
+
+						*'foldclose'* *'fcl'*
+'foldclose' 'fcl'	string (default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	When set to "all", a fold is closed when the cursor isn't in it and
+	its level is higher than 'foldlevel'.  Useful if you want folds to
+	automatically close when moving out of them.
+
+						*'foldcolumn'* *'fdc'*
+'foldcolumn' 'fdc'	number (default 0)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	When non-zero, a column with the specified width is shown at the side
+	of the window which indicates open and closed folds.  The maximum
+	value is 12.
+	See |folding|.
+
+			*'foldenable'* *'fen'* *'nofoldenable'* *'nofen'*
+'foldenable' 'fen'	boolean (default on)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	When off, all folds are open.  This option can be used to quickly
+	switch between showing all text unfolded and viewing the text with
+	folds (including manually opened or closed folds).  It can be toggled
+	with the |zi| command.  The 'foldcolumn' will remain blank when
+	'foldenable' is off.
+	This option is set by commands that create a new fold or close a fold.
+	See |folding|.
+
+						*'foldexpr'* *'fde'*
+'foldexpr' 'fde'	string (default: "0")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			or |+eval| features}
+	The expression used for when 'foldmethod' is "expr".  It is evaluated
+	for each line to obtain its fold level.  See |fold-expr|.
+
+	The expression will be evaluated in the |sandbox| if set from a
+	modeline, see |sandbox-option|.
+	This option can't be set from a |modeline| when the 'diff' option is
+	on.
+
+	It is not allowed to change text or jump to another window while
+	evaluating 'foldexpr' |textlock|.
+
+						*'foldignore'* *'fdi'*
+'foldignore' 'fdi'	string (default: "#")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	Used only when 'foldmethod' is "indent".  Lines starting with
+	characters in 'foldignore' will get their fold level from surrounding
+	lines.  White space is skipped before checking for this character.
+	The default "#" works well for C programs.  See |fold-indent|.
+
+						*'foldlevel'* *'fdl'*
+'foldlevel' 'fdl'	number (default: 0)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	Sets the fold level: Folds with a higher level will be closed.
+	Setting this option to zero will close all folds.  Higher numbers will
+	close fewer folds.
+	This option is set by commands like |zm|, |zM| and |zR|.
+	See |fold-foldlevel|.
+
+						*'foldlevelstart'* *'fdls'*
+'foldlevelstart' 'fdls'	number (default: -1)
+			global
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	Sets 'foldlevel' when starting to edit another buffer in a window.
+	Useful to always start editing with all folds closed (value zero),
+	some folds closed (one) or no folds closed (99).
+	This is done before reading any modeline, thus a setting in a modeline
+	overrules this option.  Starting to edit a file for |diff-mode| also
+	ignores this option and closes all folds.
+	It is also done before BufReadPre autocommands, to allow an autocmd to
+	overrule the 'foldlevel' value for specific files.
+	When the value is negative, it is not used.
+
+						*'foldmarker'* *'fmr'* *E536*
+'foldmarker' 'fmr'	string (default: "{{{,}}}")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	The start and end marker used when 'foldmethod' is "marker".  There
+	must be one comma, which separates the start and end marker.  The
+	marker is a literal string (a regular expression would be too slow).
+	See |fold-marker|.
+
+						*'foldmethod'* *'fdm'*
+'foldmethod' 'fdm'	string (default: "manual")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	The kind of folding used for the current window.  Possible values:
+	|fold-manual|	manual	    Folds are created manually.
+	|fold-indent|	indent	    Lines with equal indent form a fold.
+	|fold-expr|	expr	    'foldexpr' gives the fold level of a line.
+	|fold-marker|	marker	    Markers are used to specify folds.
+	|fold-syntax|	syntax	    Syntax highlighting items specify folds.
+	|fold-diff|	diff	    Fold text that is not changed.
+
+						*'foldminlines'* *'fml'*
+'foldminlines' 'fml'	number (default: 1)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	Sets the number of screen lines above which a fold can be displayed
+	closed.  Also for manually closed folds.  With the default value of
+	one a fold can only be closed if it takes up two or more screen lines.
+	Set to zero to be able to close folds of just one screen line.
+	Note that this only has an effect on what is displayed.  After using
+	"zc" to close a fold, which is displayed open because it's smaller
+	than 'foldminlines', a following "zc" may close a containing fold.
+
+						*'foldnestmax'* *'fdn'*
+'foldnestmax' 'fdn'	number (default: 20)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	Sets the maximum nesting of folds for the "indent" and "syntax"
+	methods.  This avoids that too many folds will be created.  Using more
+	than 20 doesn't work, because the internal limit is 20.
+
+						*'foldopen'* *'fdo'*
+'foldopen' 'fdo'	string (default: "block,hor,mark,percent,quickfix,
+							     search,tag,undo")
+			global
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	Specifies for which type of commands folds will be opened, if the
+	command moves the cursor into a closed fold.  It is a comma separated
+	list of items.
+	NOTE: When the command is part of a mapping this option is not used.
+	Add the |zv| command to the mapping to get the same effect.
+	(rationale: the mapping may want to control opening folds itself)
+
+		item		commands ~
+		all		any
+		block		"(", "{", "[[", "[{", etc.
+		hor		horizontal movements: "l", "w", "fx", etc.
+		insert		any command in Insert mode
+		jump		far jumps: "G", "gg", etc.
+		mark		jumping to a mark: "'m", CTRL-O, etc.
+		percent		"%"
+		quickfix	":cn", ":crew", ":make", etc.
+		search		search for a pattern: "/", "n", "*", "gd", etc.
+				(not for a search pattern in a ":" command)
+				Also for |[s| and |]s|.
+		tag		jumping to a tag: ":ta", CTRL-T, etc.
+		undo		undo or redo: "u" and CTRL-R
+	When a movement command is used for an operator (e.g., "dl" or "y%")
+	this option is not used.  This means the operator will include the
+	whole closed fold.
+	Note that vertical movements are not here, because it would make it
+	very difficult to move onto a closed fold.
+	In insert mode the folds containing the cursor will always be open
+	when text is inserted.
+	To close folds you can re-apply 'foldlevel' with the |zx| command or
+	set the 'foldclose' option to "all".
+
+						*'foldtext'* *'fdt'*
+'foldtext' 'fdt'	string (default: "foldtext()")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+folding|
+			feature}
+	An expression which is used to specify the text displayed for a closed
+	fold.  See |fold-foldtext|.
+
+	The expression will be evaluated in the |sandbox| if set from a
+	modeline, see |sandbox-option|.
+
+	It is not allowed to change text or jump to another window while
+	evaluating 'foldtext' |textlock|.
+
+						*'formatexpr'* *'fex'*
+'formatexpr' 'fex'	string (default "")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+eval|
+			feature}
+	Expression which is evaluated to format a range of lines for the |gq|
+	operator or automatic formatting (see 'formatoptions').  When this
+	option is empty 'formatprg' is used.
+
+	The |v:lnum|  variable holds the first line to be formatted.
+	The |v:count| variable holds the number of lines to be formatted.
+	The |v:char|  variable holds the character that is going to be
+		      inserted if the expression is being evaluated due to
+		      automatic formatting.  This can be empty.  Don't insert
+		      it yet!
+
+	Example: >
+		:set formatexpr=mylang#Format()
+<	This will invoke the mylang#Format() function in the
+	autoload/mylang.vim file in 'runtimepath'. |autoload|
+
+	The expression is also evaluated when 'textwidth' is set and adding
+	text beyond that limit.  This happens under the same conditions as
+	when internal formatting is used.  Make sure the cursor is kept in the
+	same spot relative to the text then!  The |mode()| function will
+	return "i" or "R" in this situation.
+
+	When the expression evaluates to non-zero Vim will fall back to using
+	the internal format mechanism.
+
+	The expression will be evaluated in the |sandbox| when set from a
+	modeline, see |sandbox-option|.  That stops the option from working,
+	since changing the buffer text is not allowed.
+	NOTE: This option is set to "" when 'compatible' is set.
+
+					*'formatoptions'* *'fo'*
+'formatoptions' 'fo'	string (Vim default: "tcq", Vi default: "vt")
+			local to buffer
+			{not in Vi}
+	This is a sequence of letters which describes how automatic
+	formatting is to be done.  See |fo-table|.  When the 'paste' option is
+	on, no formatting is done (like 'formatoptions' is empty).  Commas can
+	be inserted for readability.
+	To avoid problems with flags that are added in the future, use the
+	"+=" and "-=" feature of ":set" |add-option-flags|.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+					*'formatlistpat'* *'flp'*
+'formatlistpat' 'flp'	string (default: "^\s*\d\+[\]:.)}\t ]\s*")
+			local to buffer
+			{not in Vi}
+	A pattern that is used to recognize a list header.  This is used for
+	the "n" flag in 'formatoptions'.
+	The pattern must match exactly the text that will be the indent for
+	the line below it.  You can use |/\ze| to mark the end of the match
+	while still checking more characters.  There must be a character
+	following the pattern, when it matches the whole line it is handled
+	like there is no match.
+	The default recognizes a number, followed by an optional punctuation
+	character and white space.
+
+						*'formatprg'* *'fp'*
+'formatprg' 'fp'	string (default "")
+			global or local to buffer |global-local|
+			{not in Vi}
+	The name of an external program that will be used to format the lines
+	selected with the |gq| operator.  The program must take the input on
+	stdin and produce the output on stdout.  The Unix program "fmt" is
+	such a program.
+	If the 'formatexpr' option is not empty it will be used instead.
+	Otherwise, if 'formatprg' option is an empty string, the internal
+	format function will be used |C-indenting|.
+	Environment variables are expanded |:set_env|.  See |option-backslash|
+	about including spaces and backslashes.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+					*'fsync'* *'fs'* *'nofsync'* *'nofs'*
+'fsync' 'fs'		boolean	(default on)
+			global
+			{not in Vi}
+	When on, the library function fsync() will be called after writing a
+	file.  This will flush a file to disk, ensuring that it is safely
+	written even on filesystems which do metadata-only journaling.  This
+	will force the harddrive to spin up on Linux systems running in laptop
+	mode, so it may be undesirable in some situations.  Be warned that
+	turning this off increases the chances of data loss after a crash.  On
+	systems without an fsync() implementation, this variable is always
+	off.
+	Also see 'swapsync' for controlling fsync() on swap files.
+	'fsync' also applies to |writefile()|, unless a flag is used to
+	overrule it.
+
+				   *'gdefault'* *'gd'* *'nogdefault'* *'nogd'*
+'gdefault' 'gd'		boolean	(default off)
+			global
+			{not in Vi}
+	When on, the ":substitute" flag 'g' is default on.  This means that
+	all matches in a line are substituted instead of one.  When a 'g' flag
+	is given to a ":substitute" command, this will toggle the substitution
+	of all or one match.  See |complex-change|.
+
+		command		'gdefault' on	'gdefault' off	~
+		:s///		  subst. all	  subst. one
+		:s///g		  subst. one	  subst. all
+		:s///gg		  subst. all	  subst. one
+
+	NOTE: This option is reset when 'compatible' is set.
+	DEPRECATED: Setting this option may break plugins that are not aware
+	of this option.  Also, many users get confused that adding the /g flag
+	has the opposite effect of that it normally does.
+
+						*'grepformat'* *'gfm'*
+'grepformat' 'gfm'	string	(default "%f:%l:%m,%f:%l%m,%f  %l%m")
+			global
+			{not in Vi}
+	Format to recognize for the ":grep" command output.
+	This is a scanf-like string that uses the same format as the
+	'errorformat' option: see |errorformat|.
+
+						*'grepprg'* *'gp'*
+'grepprg' 'gp'		string	(default "grep -n ",
+					Unix: "grep -n $* /dev/null",
+					Win32: "findstr /n" or "grep -n",
+						      VMS: "SEARCH/NUMBERS ")
+			global or local to buffer |global-local|
+			{not in Vi}
+	Program to use for the |:grep| command.  This option may contain '%'
+	and '#' characters, which are expanded like when used in a command-
+	line.  The placeholder "$*" is allowed to specify where the arguments
+	will be included.  Environment variables are expanded |:set_env|.  See
+	|option-backslash| about including spaces and backslashes.
+	When your "grep" accepts the "-H" argument, use this to make ":grep"
+	also work well with a single file: >
+		:set grepprg=grep\ -nH
+<	Special value: When 'grepprg' is set to "internal" the |:grep| command
+	works like |:vimgrep|, |:lgrep| like |:lvimgrep|, |:grepadd| like
+	|:vimgrepadd| and |:lgrepadd| like |:lvimgrepadd|.
+	See also the section |:make_makeprg|, since most of the comments there
+	apply equally to 'grepprg'.
+	For Win32, the default is "findstr /n" if "findstr.exe" can be found,
+	otherwise it's "grep -n".
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+			*'guicursor'* *'gcr'* *E545* *E546* *E548* *E549*
+'guicursor' 'gcr'	string	(default "n-v-c:block-Cursor/lCursor,
+					ve:ver35-Cursor,
+					o:hor50-Cursor,
+					i-ci:ver25-Cursor/lCursor,
+					r-cr:hor20-Cursor/lCursor,
+					sm:block-Cursor
+					-blinkwait175-blinkoff150-blinkon175",
+				for MS-DOS and Win32 console:
+					"n-v-c:block,o:hor50,i-ci:hor15,
+					r-cr:hor30,sm:block")
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled, and
+			for MS-DOS and Win32 console}
+	This option tells Vim what the cursor should look like in different
+	modes.  It fully works in the GUI.  In an MSDOS or Win32 console, only
+	the height of the cursor can be changed.  This can be done by
+	specifying a block cursor, or a percentage for a vertical or
+	horizontal cursor.
+	For a console the 't_SI', 't_SR', and 't_EI' escape sequences are
+	used.
+
+	The option is a comma separated list of parts.  Each part consist of a
+	mode-list and an argument-list:
+		mode-list:argument-list,mode-list:argument-list,..
+	The mode-list is a dash separated list of these modes:
+		n	Normal mode
+		v	Visual mode
+		ve	Visual mode with 'selection' "exclusive" (same as 'v',
+			if not specified)
+		o	Operator-pending mode
+		i	Insert mode
+		r	Replace mode
+		c	Command-line Normal (append) mode
+		ci	Command-line Insert mode
+		cr	Command-line Replace mode
+		sm	showmatch in Insert mode
+		a	all modes
+	The argument-list is a dash separated list of these arguments:
+		hor{N}	horizontal bar, {N} percent of the character height
+		ver{N}	vertical bar, {N} percent of the character width
+		block	block cursor, fills the whole character
+			[only one of the above three should be present]
+		blinkwait{N}				*cursor-blinking*
+		blinkon{N}
+		blinkoff{N}
+			blink times for cursor: blinkwait is the delay before
+			the cursor starts blinking, blinkon is the time that
+			the cursor is shown and blinkoff is the time that the
+			cursor is not shown.  The times are in msec.  When one
+			of the numbers is zero, there is no blinking.  The
+			default is: "blinkwait700-blinkon400-blinkoff250".
+			These numbers are used for a missing entry.  This
+			means that blinking is enabled by default.  To switch
+			blinking off you can use "blinkon0".  The cursor only
+			blinks when Vim is waiting for input, not while
+			executing a command.
+			To make the cursor blink in an xterm, see
+			|xterm-blink|.
+		{group-name}
+			a highlight group name, that sets the color and font
+			for the cursor
+		{group-name}/{group-name}
+			Two highlight group names, the first is used when
+			no language mappings are used, the other when they
+			are. |language-mapping|
+
+	Examples of parts:
+	   n-c-v:block-nCursor	in Normal, Command-line and Visual mode, use a
+				block cursor with colors from the "nCursor"
+				highlight group
+	   i-ci:ver30-iCursor-blinkwait300-blinkon200-blinkoff150
+				In Insert and Command-line Insert mode, use a
+				30% vertical bar cursor with colors from the
+				"iCursor" highlight group.  Blink a bit
+				faster.
+
+	The 'a' mode is different.  It will set the given argument-list for
+	all modes.  It does not reset anything to defaults.  This can be used
+	to do a common setting for all modes.  For example, to switch off
+	blinking: "a:blinkon0"
+
+	Examples of cursor highlighting: >
+	    :highlight Cursor gui=reverse guifg=NONE guibg=NONE
+	    :highlight Cursor gui=NONE guifg=bg guibg=fg
+<
+					*'guifont'* *'gfn'*
+						   *E235* *E596*
+'guifont' 'gfn'		string	(default "")
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled}
+	This is a list of fonts which will be used for the GUI version of Vim.
+	In its simplest form the value is just one font name.  When
+	the font cannot be found you will get an error message.  To try other
+	font names a list can be specified, font names separated with commas.
+	The first valid font is used.
+
+	On systems where 'guifontset' is supported (X11) and 'guifontset' is
+	not empty, then 'guifont' is not used.
+
+	Note: As to the GTK GUIs, no error is given against any invalid names,
+	and the first element of the list is always picked up and made use of.
+	This is because, instead of identifying a given name with a font, the
+	GTK GUIs use it to construct a pattern and try to look up a font which
+	best matches the pattern among available fonts, and this way, the
+	matching never fails.  An invalid name doesn't matter because a number
+	of font properties other than name will do to get the matching done.
+
+	Spaces after a comma are ignored.  To include a comma in a font name
+	precede it with a backslash.  Setting an option requires an extra
+	backslash before a space and a backslash.  See also
+	|option-backslash|.  For example: >
+	    :set guifont=Screen15,\ 7x13,font\\,with\\,commas
+<	will make Vim try to use the font "Screen15" first, and if it fails it
+	will try to use "7x13" and then "font,with,commas" instead.
+
+	If none of the fonts can be loaded, Vim will keep the current setting.
+	If an empty font list is given, Vim will try using other resource
+	settings (for X, it will use the Vim.font resource), and finally it
+	will try some builtin default which should always be there ("7x13" in
+	the case of X).  The font names given should be "normal" fonts.  Vim
+	will try to find the related bold and italic fonts.
+
+	For Win32, GTK, Motif, Mac OS and Photon: >
+	    :set guifont=*
+<	will bring up a font requester, where you can pick the font you want.
+
+	The font name depends on the GUI used.  See |setting-guifont| for a
+	way to set 'guifont' for various systems.
+
+	For the GTK+ 2 and 3 GUIs, the font name looks like this: >
+	    :set guifont=Andale\ Mono\ 11
+<	That's all.  XLFDs are not used.  For Chinese this is reported to work
+	well: >
+	    if has("gui_gtk2")
+	      set guifont=Bitstream\ Vera\ Sans\ Mono\ 12,Fixed\ 12
+	      set guifontwide=Microsoft\ Yahei\ 12,WenQuanYi\ Zen\ Hei\ 12
+	    endif
+<
+        (Replace gui_gtk2 with gui_gtk3 for the GTK+ 3 GUI)
+
+	For Mac OSX you can use something like this: >
+	    :set guifont=Monaco:h10
+<	Also see 'macatsui', it can help fix display problems.
+								*E236*
+	Note that the fonts must be mono-spaced (all characters have the same
+	width).  An exception is GTK: all fonts are accepted, but mono-spaced
+	fonts look best.
+
+	To preview a font on X11, you might be able to use the "xfontsel"
+	program.  The "xlsfonts" program gives a list of all available fonts.
+
+	For the Win32 GUI					*E244* *E245*
+	- takes these options in the font name:
+		hXX - height is XX (points, can be floating-point)
+		wXX - width is XX (points, can be floating-point)
+		b   - bold
+		i   - italic
+		u   - underline
+		s   - strikeout
+		cXX - character set XX.  Valid charsets are: ANSI, ARABIC,
+		      BALTIC, CHINESEBIG5, DEFAULT, EASTEUROPE, GB2312, GREEK,
+		      HANGEUL, HEBREW, JOHAB, MAC, OEM, RUSSIAN, SHIFTJIS,
+		      SYMBOL, THAI, TURKISH, VIETNAMESE ANSI and BALTIC.
+		      Normally you would use "cDEFAULT".
+		qXX - quality XX.  Valid quality names are: PROOF, DRAFT,
+		      ANTIALIASED, NONANTIALIASED, CLEARTYPE, DEFAULT.
+		      Normally you would use "qDEFAULT".
+		      Some quality values are not supported in legacy OSs.
+
+	  Use a ':' to separate the options.
+	- A '_' can be used in the place of a space, so you don't need to use
+	  backslashes to escape the spaces.
+	- Examples: >
+	    :set guifont=courier_new:h12:w5:b:cRUSSIAN
+	    :set guifont=Andale_Mono:h7.5:w4.5
+<	See also |font-sizes|.
+
+					*'guifontset'* *'gfs'*
+					*E250* *E252* *E234* *E597* *E598*
+'guifontset' 'gfs'	string	(default "")
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled and
+			with the |+xfontset| feature}
+			{not available in the GTK+ GUI}
+	When not empty, specifies two (or more) fonts to be used.  The first
+	one for normal English, the second one for your special language.  See
+	|xfontset|.
+	Setting this option also means that all font names will be handled as
+	a fontset name.  Also the ones used for the "font" argument of the
+	|:highlight| command.
+	The fonts must match with the current locale.  If fonts for the
+	character sets that the current locale uses are not included, setting
+	'guifontset' will fail.
+	Note the difference between 'guifont' and 'guifontset': In 'guifont'
+	the comma-separated names are alternative names, one of which will be
+	used.  In 'guifontset' the whole string is one fontset name,
+	including the commas.  It is not possible to specify alternative
+	fontset names.
+	This example works on many X11 systems: >
+		:set guifontset=-*-*-medium-r-normal--16-*-*-*-c-*-*-*
+<
+				*'guifontwide'* *'gfw'* *E231* *E533* *E534*
+'guifontwide' 'gfw'	string	(default "")
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled}
+	When not empty, specifies a comma-separated list of fonts to be used
+	for double-width characters.  The first font that can be loaded is
+	used.
+	Note: The size of these fonts must be exactly twice as wide as the one
+	specified with 'guifont' and the same height.
+
+	All GUI versions but GTK+:
+
+	'guifontwide' is only used when 'encoding' is set to "utf-8" and
+	'guifontset' is empty or invalid.
+	When 'guifont' is set and a valid font is found in it and
+	'guifontwide' is empty Vim will attempt to find a matching
+	double-width font and set 'guifontwide' to it.
+
+	GTK+ GUI only:  		    	*guifontwide_gtk*
+
+	If set and valid, 'guifontwide' is always used for double width
+	characters, even if 'encoding' is not set to "utf-8".
+	Vim does not attempt to find an appropriate value for 'guifontwide'
+	automatically.  If 'guifontwide' is empty Pango/Xft will choose the
+	font for characters not available in 'guifont'.  Thus you do not need
+	to set 'guifontwide' at all unless you want to override the choice
+	made by Pango/Xft.
+
+	Windows +multibyte only:		*guifontwide_win_mbyte*
+
+	If set and valid, 'guifontwide' is used for IME instead of 'guifont'.
+
+						*'guiheadroom'* *'ghr'*
+'guiheadroom' 'ghr'	number	(default 50)
+			global
+			{not in Vi} {only for GTK and X11 GUI}
+	The number of pixels subtracted from the screen height when fitting
+	the GUI window on the screen.  Set this before the GUI is started,
+	e.g., in your |gvimrc| file.  When zero, the whole screen height will
+	be used by the window.  When positive, the specified number of pixel
+	lines will be left for window decorations and other items on the
+	screen.  Set it to a negative value to allow windows taller than the
+	screen.
+
+						*'guioptions'* *'go'*
+'guioptions' 'go'	string	(default "egmrLtT"   (MS-Windows, "t" is
+						   removed in |defaults.vim|),
+					 "aegimrLtT" (GTK, Motif and Athena),
+					 )
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled}
+	This option only has an effect in the GUI version of Vim.  It is a
+	sequence of letters which describes what components and options of the
+	GUI should be used.
+	To avoid problems with flags that are added in the future, use the
+	"+=" and "-=" feature of ":set" |add-option-flags|.
+
+	Valid characters are as follows:
+								*'go-!'*
+	  '!'	External commands are executed in a terminal window.  Without
+		this flag the MS-Windows GUI will open a console window to
+		execute the command.  The Unix GUI will simulate a dumb
+		terminal to list the command output.
+		The terminal window will be positioned at the bottom, and grow
+		upwards as needed.
+							*guioptions_a* *'go-a'*
+	  'a'	Autoselect:  If present, then whenever VISUAL mode is started,
+		or the Visual area extended, Vim tries to become the owner of
+		the windowing system's global selection.  This means that the
+		Visually highlighted text is available for pasting into other
+		applications as well as into Vim itself.  When the Visual mode
+		ends, possibly due to an operation on the text, or when an
+		application wants to paste the selection, the highlighted text
+		is automatically yanked into the "* selection register.
+		Thus the selection is still available for pasting into other
+		applications after the VISUAL mode has ended.
+		    If not present, then Vim won't become the owner of the
+		windowing system's global selection unless explicitly told to
+		by a yank or delete operation for the "* register.
+		The same applies to the modeless selection.
+								*'go-P'*
+	  'P'	Like autoselect but using the "+ register instead of the "*
+		register.
+								*'go-A'*
+	  'A'	Autoselect for the modeless selection.  Like 'a', but only
+		applies to the modeless selection.
+
+		    'guioptions'   autoselect Visual  autoselect modeless ~
+			 ""		 -			 -
+			 "a"		yes			yes
+			 "A"		 -			yes
+			 "aA"		yes			yes
+
+								*'go-c'*
+	  'c'	Use console dialogs instead of popup dialogs for simple
+		choices.
+								*'go-e'*
+	  'e'	Add tab pages when indicated with 'showtabline'.
+		'guitablabel' can be used to change the text in the labels.
+		When 'e' is missing a non-GUI tab pages line may be used.
+		The GUI tabs are only supported on some systems, currently
+		GTK, Motif, Mac OS/X and MS-Windows.
+								*'go-f'*
+	  'f'	Foreground: Don't use fork() to detach the GUI from the shell
+		where it was started.  Use this for programs that wait for the
+		editor to finish (e.g., an e-mail program).  Alternatively you
+		can use "gvim -f" or ":gui -f" to start the GUI in the
+		foreground.  |gui-fork|
+		Note: Set this option in the vimrc file.  The forking may have
+		happened already when the |gvimrc| file is read.
+								*'go-i'*
+	  'i'	Use a Vim icon.  For GTK with KDE it is used in the left-upper
+		corner of the window.  It's black&white on non-GTK, because of
+		limitations of X11.  For a color icon, see |X11-icon|.
+								*'go-m'*
+	  'm'	Menu bar is present.
+								*'go-M'*
+	  'M'	The system menu "$VIMRUNTIME/menu.vim" is not sourced.  Note
+		that this flag must be added in the .vimrc file, before
+		switching on syntax or filetype recognition (when the |gvimrc|
+		file is sourced the system menu has already been loaded; the
+		`:syntax on` and `:filetype on` commands load the menu too).
+								*'go-g'*
+	  'g'	Grey menu items: Make menu items that are not active grey.  If
+		'g' is not included inactive menu items are not shown at all.
+		Exception: Athena will always use grey menu items.
+								*'go-t'*
+	  't'	Include tearoff menu items.  Currently only works for Win32,
+		GTK+, and Motif 1.2 GUI.
+								*'go-T'*
+	  'T'	Include Toolbar.  Currently only in Win32, GTK+, Motif, Photon
+		and Athena GUIs.
+								*'go-r'*
+	  'r'	Right-hand scrollbar is always present.
+								*'go-R'*
+	  'R'	Right-hand scrollbar is present when there is a vertically
+		split window.
+								*'go-l'*
+	  'l'	Left-hand scrollbar is always present.
+								*'go-L'*
+	  'L'	Left-hand scrollbar is present when there is a vertically
+		split window.
+								*'go-b'*
+	  'b'	Bottom (horizontal) scrollbar is present.  Its size depends on
+		the longest visible line, or on the cursor line if the 'h'
+		flag is included. |gui-horiz-scroll|
+								*'go-h'*
+	  'h'	Limit horizontal scrollbar size to the length of the cursor
+		line.  Reduces computations. |gui-horiz-scroll|
+
+	And yes, you may even have scrollbars on the left AND the right if
+	you really want to :-).  See |gui-scrollbars| for more information.
+
+								*'go-v'*
+	  'v'	Use a vertical button layout for dialogs.  When not included,
+		a horizontal layout is preferred, but when it doesn't fit a
+		vertical layout is used anyway.
+								*'go-p'*
+	  'p'	Use Pointer callbacks for X11 GUI.  This is required for some
+		window managers.  If the cursor is not blinking or hollow at
+		the right moment, try adding this flag.  This must be done
+		before starting the GUI.  Set it in your |gvimrc|.  Adding or
+		removing it after the GUI has started has no effect.
+								*'go-F'*
+	  'F'	Add a footer.  Only for Motif.  See |gui-footer|.
+								*'go-k'*
+	  'k'	Keep the GUI window size when adding/removing a scrollbar, or
+		toolbar, tabline, etc.  Instead, the behavior is similar to
+		when the window is maximized and will adjust 'lines' and
+		'columns' to fit to the window.  Without the 'k' flag Vim will
+		try to keep 'lines' and 'columns' the same when adding and
+		removing GUI components.
+
+						*'guipty'* *'noguipty'*
+'guipty'		boolean	(default on)
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled}
+	Only in the GUI: If on, an attempt is made to open a pseudo-tty for
+	I/O to/from shell commands.  See |gui-pty|.
+
+						*'guitablabel'* *'gtl'*
+'guitablabel' 'gtl'	string	(default empty)
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled and
+			with the |+windows| feature}
+	When nonempty describes the text to use in a label of the GUI tab
+	pages line.  When empty and when the result is empty Vim will use a
+	default label.  See |setting-guitablabel| for more info.
+
+	The format of this option is like that of 'statusline'.
+	'guitabtooltip' is used for the tooltip, see below.
+	The expression will be evaluated in the |sandbox| when set from a
+	modeline, see |sandbox-option|.
+
+	Only used when the GUI tab pages line is displayed.  'e' must be
+	present in 'guioptions'.  For the non-GUI tab pages line 'tabline' is
+	used.
+
+						*'guitabtooltip'* *'gtt'*
+'guitabtooltip' 'gtt'	string	(default empty)
+			global
+			{not in Vi}
+			{only available when compiled with GUI enabled and
+			with the |+windows| feature}
+	When nonempty describes the text to use in a tooltip for the GUI tab
+	pages line.  When empty Vim will use a default tooltip.
+	This option is otherwise just like 'guitablabel' above.
+	You can include a line break.  Simplest method is to use |:let|: >
+		:let &guitabtooltip = "line one\nline two"
+<
+
+						*'helpfile'* *'hf'*
+'helpfile' 'hf'		string	(default (MSDOS)  "$VIMRUNTIME\doc\help.txt"
+					 (others) "$VIMRUNTIME/doc/help.txt")
+			global
+			{not in Vi}
+	Name of the main help file.  All distributed help files should be
+	placed together in one directory.  Additionally, all "doc" directories
+	in 'runtimepath' will be used.
+	Environment variables are expanded |:set_env|.  For example:
+	"$VIMRUNTIME/doc/help.txt".  If $VIMRUNTIME is not set, $VIM is also
+	tried.  Also see |$VIMRUNTIME| and |option-backslash| about including
+	spaces and backslashes.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'helpheight'* *'hh'*
+'helpheight' 'hh'	number	(default 20)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	Minimal initial height of the help window when it is opened with the
+	":help" command.  The initial height of the help window is half of the
+	current window, or (when the 'ea' option is on) the same as other
+	windows.  When the height is less than 'helpheight', the height is
+	set to 'helpheight'.  Set to zero to disable.
+
+						*'helplang'* *'hlg'*
+'helplang' 'hlg'	string	(default: messages language or empty)
+			global
+			{only available when compiled with the |+multi_lang|
+			feature}
+			{not in Vi}
+	Comma separated list of languages.  Vim will use the first language
+	for which the desired help can be found.  The English help will always
+	be used as a last resort.  You can add "en" to prefer English over
+	another language, but that will only find tags that exist in that
+	language and not in the English help.
+	Example: >
+		:set helplang=de,it
+<	This will first search German, then Italian and finally English help
+	files.
+	When using |CTRL-]| and ":help!" in a non-English help file Vim will
+	try to find the tag in the current language before using this option.
+	See |help-translated|.
+
+				     *'hidden'* *'hid'* *'nohidden'* *'nohid'*
+'hidden' 'hid'		boolean	(default off)
+			global
+			{not in Vi}
+	When off a buffer is unloaded when it is |abandon|ed.  When on a
+	buffer becomes hidden when it is |abandon|ed.  If the buffer is still
+	displayed in another window, it does not become hidden, of course.
+	The commands that move through the buffer list sometimes make a buffer
+	hidden although the 'hidden' option is off: When the buffer is
+	modified, 'autowrite' is off or writing is not possible, and the '!'
+	flag was used.  See also |windows.txt|.
+	To only make one buffer hidden use the 'bufhidden' option.
+	This option is set for one command with ":hide {command}" |:hide|.
+	WARNING: It's easy to forget that you have changes in hidden buffers.
+	Think twice when using ":q!" or ":qa!".
+
+						*'highlight'* *'hl'*
+'highlight' 'hl'	string	(default (as a single string):
+				     "8:SpecialKey,~:EndOfBuffer,@:NonText,
+				     d:Directory,e:ErrorMsg,i:IncSearch,
+				     l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,
+				     N:CursorLineNr,r:Question,s:StatusLine,
+				     S:StatusLineNC,c:VertSplit,t:Title,
+				     v:Visual,w:WarningMsg,W:WildMenu,f:Folded,
+				     F:FoldColumn,A:DiffAdd,C:DiffChange,
+				     D:DiffDelete,T:DiffText,>:SignColumn,
+				     B:SpellBad,P:SpellCap,R:SpellRare,
+				     L:SpellLocal,-:Conceal,+:Pmenu,=:PmenuSel,
+				     x:PmenuSbar,X:PmenuThumb,*:TabLine,
+				     #:TabLineSel,_:TabLineFill,!:CursorColumn,
+				     .:CursorLine,o:ColorColumn,q:QuickFixLine,
+				     z:StatusLineTerm,Z:StatusLineTermNC")
+			global
+			{not in Vi}
+	This option can be used to set highlighting mode for various
+	occasions.  It is a comma separated list of character pairs.  The
+	first character in a pair gives the occasion, the second the mode to
+	use for that occasion.  The occasions are:
+	|hl-SpecialKey|	 8  Meta and special keys listed with ":map"
+	|hl-EndOfBuffer|   ~  lines after the last line in the buffer
+	|hl-NonText|	 @  '@' at the end of the window and
+			    characters from 'showbreak'
+	|hl-Directory|	 d  directories in CTRL-D listing and other special
+			    things in listings
+	|hl-ErrorMsg|	 e  error messages
+			 h  (obsolete, ignored)
+	|hl-IncSearch|	 i  'incsearch' highlighting
+	|hl-Search|	 l  last search pattern highlighting (see 'hlsearch')
+	|hl-MoreMsg|	 m  |more-prompt|
+	|hl-ModeMsg|	 M  Mode (e.g., "-- INSERT --")
+	|hl-LineNr|	 n  line number for ":number" and ":#" commands, and
+			    when 'number' or 'relativenumber' option is set.
+	|hl-CursorLineNr|  N like n for when 'cursorline' or 'relativenumber' is
+			    set.
+	|hl-Question|	 r  |hit-enter| prompt and yes/no questions
+	|hl-StatusLine|	 s  status line of current window |status-line|
+	|hl-StatusLineNC|  S  status lines of not-current windows
+	|hl-Title|	 t  Titles for output from ":set all", ":autocmd" etc.
+	|hl-VertSplit|	 c  column used to separate vertically split windows
+	|hl-Visual|	 v  Visual mode
+	|hl-VisualNOS|	 V  Visual mode when Vim does is "Not Owning the
+			    Selection" Only X11 Gui's |gui-x11| and
+			    |xterm-clipboard|.
+	|hl-WarningMsg|	 w  warning messages
+	|hl-WildMenu|	 W  wildcard matches displayed for 'wildmenu'
+	|hl-Folded|	 f  line used for closed folds
+	|hl-FoldColumn|	 F  'foldcolumn'
+	|hl-DiffAdd|	 A  added line in diff mode
+	|hl-DiffChange|	 C  changed line in diff mode
+	|hl-DiffDelete|	 D  deleted line in diff mode
+	|hl-DiffText|	 T  inserted text in diff mode
+	|hl-SignColumn|	 >  column used for |signs|
+	|hl-SpellBad|	 B  misspelled word |spell|
+	|hl-SpellCap|	 P  word that should start with capital |spell|
+	|hl-SpellRare|	 R  rare word |spell|
+	|hl-SpellLocal|	 L  word from other region |spell|
+	|hl-Conceal|	 -  the placeholders used for concealed characters
+			    (see 'conceallevel')
+	|hl-Pmenu|       +  popup menu normal line
+	|hl-PmenuSel|    =  popup menu normal line
+	|hl-PmenuSbar|   x  popup menu scrollbar
+	|hl-PmenuThumb|  X  popup menu scrollbar thumb
+
+	The display modes are:
+		r	reverse		(termcap entry "mr" and "me")
+		i	italic		(termcap entry "ZH" and "ZR")
+		b	bold		(termcap entry "md" and "me")
+		s	standout	(termcap entry "so" and "se")
+		u	underline	(termcap entry "us" and "ue")
+		c	undercurl	(termcap entry "Cs" and "Ce")
+		t	strikethrough	(termcap entry "Ts" and "Te")
+		n	no highlighting
+		-	no highlighting
+		:	use a highlight group
+	The default is used for occasions that are not included.
+	If you want to change what the display modes do, see |dos-colors|
+	for an example.
+	When using the ':' display mode, this must be followed by the name of
+	a highlight group.  A highlight group can be used to define any type
+	of highlighting, including using color.  See |:highlight| on how to
+	define one.  The default uses a different group for each occasion.
+	See |highlight-default| for the default highlight groups.
+
+						*'history'* *'hi'*
+'history' 'hi'		number	(Vim default: 50, Vi default: 0,
+						 set to 200 in |defaults.vim|)
+			global
+			{not in Vi}
+	A history of ":" commands, and a history of previous search patterns
+	is remembered.  This option decides how many entries may be stored in
+	each of these histories (see |cmdline-editing|).
+	The maximum value is 10000.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+					 *'hkmap'* *'hk'* *'nohkmap'* *'nohk'*
+'hkmap' 'hk'		boolean (default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	When on, the keyboard is mapped for the Hebrew character set.
+	Normally you would set 'allowrevins' and use CTRL-_ in insert mode to
+	toggle this option.  See |rileft.txt|.
+	NOTE: This option is reset when 'compatible' is set.
+
+				 *'hkmapp'* *'hkp'* *'nohkmapp'* *'nohkp'*
+'hkmapp' 'hkp'		boolean (default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	When on, phonetic keyboard mapping is used.  'hkmap' must also be on.
+	This is useful if you have a non-Hebrew keyboard.
+	See |rileft.txt|.
+	NOTE: This option is reset when 'compatible' is set.
+
+				 *'hlsearch'* *'hls'* *'nohlsearch'* *'nohls'*
+'hlsearch' 'hls'	boolean	(default off)
+			global
+			{not in Vi}
+			{not available when compiled without the
+			|+extra_search| feature}
+	When there is a previous search pattern, highlight all its matches.
+	The type of highlighting used can be set with the 'l' occasion in the
+	'highlight' option.  This uses the "Search" highlight group by
+	default.  Note that only the matching text is highlighted, any offsets
+	are not applied.
+	See also: 'incsearch' and |:match|.
+	When you get bored looking at the highlighted matches, you can turn it
+	off with |:nohlsearch|.  This does not change the option value, as
+	soon as you use a search command, the highlighting comes back.
+	'redrawtime' specifies the maximum time spent on finding matches.
+	When the search pattern can match an end-of-line, Vim will try to
+	highlight all of the matched text.  However, this depends on where the
+	search starts.  This will be the first line in the window or the first
+	line below a closed fold.  A match in a previous line which is not
+	drawn may not continue in a newly drawn line.
+	You can specify whether the highlight status is restored on startup
+	with the 'h' flag in 'viminfo' |viminfo-h|.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'icon'* *'noicon'*
+'icon'			boolean	(default off, on when title can be restored)
+			global
+			{not in Vi}
+			{not available when compiled without the |+title|
+			feature}
+	When on, the icon text of the window will be set to the value of
+	'iconstring' (if it is not empty), or to the name of the file
+	currently being edited.  Only the last part of the name is used.
+	Overridden by the 'iconstring' option.
+	Only works if the terminal supports setting window icons (currently
+	only X11 GUI and terminals with a non-empty 't_IS' option - these are
+	Unix xterm and iris-ansi by default, where 't_IS' is taken from the
+	builtin termcap).
+	When Vim was compiled with HAVE_X11 defined, the original icon will be
+	restored if possible |X11|.  See |X11-icon| for changing the icon on
+	X11.
+	For MS-Windows the icon can be changed, see |windows-icon|.
+
+						*'iconstring'*
+'iconstring'		string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+title|
+			feature}
+	When this option is not empty, it will be used for the icon text of
+	the window.  This happens only when the 'icon' option is on.
+	Only works if the terminal supports setting window icon text
+	(currently only X11 GUI and terminals with a non-empty 't_IS' option).
+	Does not work for MS Windows.
+	When Vim was compiled with HAVE_X11 defined, the original icon will be
+	restored if possible |X11|.
+	When this option contains printf-style '%' items, they will be
+	expanded according to the rules used for 'statusline'.  See
+	'titlestring' for example settings.
+	{not available when compiled without the |+statusline| feature}
+
+			*'ignorecase'* *'ic'* *'noignorecase'* *'noic'*
+'ignorecase' 'ic'	boolean	(default off)
+			global
+	Ignore case in search patterns.  Also used when searching in the tags
+	file.
+	Also see 'smartcase' and 'tagcase'.
+	Can be overruled by using "\c" or "\C" in the pattern, see
+	|/ignorecase|.
+
+						*'imactivatefunc'* *'imaf'*
+'imactivatefunc' 'imaf'	string (default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	This option specifies a function that will be called to
+	activate or deactivate the Input Method.
+	It is not used in the GUI.
+
+	Example: >
+		function ImActivateFunc(active)
+		  if a:active
+		    ... do something
+		  else
+		    ... do something
+		  endif
+		  " return value is not used
+		endfunction
+		set imactivatefunc=ImActivateFunc
+<
+						*'imactivatekey'* *'imak'*
+'imactivatekey' 'imak'	string (default "")
+			global
+			{not in Vi}
+			{only available when compiled with |+xim| and
+			|+GUI_GTK|}				*E599*
+	Specifies the key that your Input Method in X-Windows uses for
+	activation.  When this is specified correctly, vim can fully control
+	IM with 'imcmdline', 'iminsert' and 'imsearch'.
+	You can't use this option to change the activation key, the option
+	tells Vim what the key is.
+	Format:
+		[MODIFIER_FLAG-]KEY_STRING
+
+	These characters can be used for MODIFIER_FLAG (case is ignored):
+		S	    Shift key
+		L	    Lock key
+		C	    Control key
+		1	    Mod1 key
+		2	    Mod2 key
+		3	    Mod3 key
+		4	    Mod4 key
+		5	    Mod5 key
+	Combinations are allowed, for example "S-C-space" or "SC-space" are
+	both shift+ctrl+space.
+	See <X11/keysymdef.h> and XStringToKeysym for KEY_STRING.
+
+	Example: >
+		:set imactivatekey=S-space
+<	"S-space" means shift+space.  This is the activation key for kinput2 +
+	canna (Japanese), and ami (Korean).
+
+				*'imcmdline'* *'imc'* *'noimcmdline'* *'noimc'*
+'imcmdline' 'imc'	boolean (default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	When set the Input Method is always on when starting to edit a command
+	line, unless entering a search pattern (see 'imsearch' for that).
+	Setting this option is useful when your input method allows entering
+	English characters directly, e.g., when it's used to type accented
+	characters with dead keys.
+
+				*'imdisable'* *'imd'* *'noimdisable'* *'noimd'*
+'imdisable' 'imd'	boolean (default off, on for some systems (SGI))
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	When set the Input Method is never used.  This is useful to disable
+	the IM when it doesn't work properly.
+	Currently this option is on by default for SGI/IRIX machines.  This
+	may change in later releases.
+
+						*'iminsert'* *'imi'*
+'iminsert' 'imi'	number (default 0)
+			local to buffer
+			{not in Vi}
+	Specifies whether :lmap or an Input Method (IM) is to be used in
+	Insert mode.  Valid values:
+		0	:lmap is off and IM is off
+		1	:lmap is ON and IM is off
+		2	:lmap is off and IM is ON
+	To always reset the option to zero when leaving Insert mode with <Esc>
+	this can be used: >
+		:inoremap <ESC> <ESC>:set iminsert=0<CR>
+<	This makes :lmap and IM turn off automatically when leaving Insert
+	mode.
+	Note that this option changes when using CTRL-^ in Insert mode
+	|i_CTRL-^|.
+	The value is set to 1 when setting 'keymap' to a valid keymap name.
+	It is also used for the argument of commands like "r" and "f".
+	The value 0 may not work correctly with Athena and Motif with some XIM
+	methods.  Use 'imdisable' to disable XIM then.
+
+	You can set 'imactivatefunc' and 'imstatusfunc' to handle IME/XIM
+	via external command if Vim is not compiled with the |+xim|,
+	|+multi_byte_ime| or |global-ime|.
+
+						*'imsearch'* *'ims'*
+'imsearch' 'ims'	number (default -1)
+			local to buffer
+			{not in Vi}
+	Specifies whether :lmap or an Input Method (IM) is to be used when
+	entering a search pattern.  Valid values:
+		-1	the value of 'iminsert' is used, makes it look like
+			'iminsert' is also used when typing a search pattern
+		0	:lmap is off and IM is off
+		1	:lmap is ON and IM is off
+		2	:lmap is off and IM is ON
+	Note that this option changes when using CTRL-^ in Command-line mode
+	|c_CTRL-^|.
+	The value is set to 1 when it is not -1 and setting the 'keymap'
+	option to a valid keymap name.
+	The value 0 may not work correctly with Athena and Motif with some XIM
+	methods.  Use 'imdisable' to disable XIM then.
+
+						*'imstatusfunc'* *'imsf'*
+'imstatusfunc' 'imsf'	string (default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	This option specifies a function that is called to obtain the status
+	of Input Method.  It must return a positive number when IME is active.
+	It is not used in the GUI.
+
+	Example: >
+		function ImStatusFunc()
+		  let is_active = ...do something
+		  return is_active ? 1 : 0
+		endfunction
+		set imstatusfunc=ImStatusFunc
+<
+	NOTE: This function is invoked very often.  Keep it fast.
+
+						*'imstyle'* *'imst'*
+'imstyle' 'imst'	number (default 1)
+			global
+			{not in Vi}
+			{only available when compiled with |+xim| and
+			|+GUI_GTK|}
+	This option specifies the input style of Input Method:
+	0   use on-the-spot style
+	1   over-the-spot style
+	See: |xim-input-style|
+
+	For a long time on-the-spot style had been used in the GTK version of
+	vim, however, it is known that it causes troubles when using mappings,
+	|single-repeat|, etc.  Therefore over-the-spot style becomes the
+	default now.  This should work fine for most people, however if you
+	have any problem with it, try using on-the-spot style.
+
+						*'include'* *'inc'*
+'include' 'inc'		string	(default "^\s*#\s*include")
+			global or local to buffer |global-local|
+			{not in Vi}
+			{not available when compiled without the
+			|+find_in_path| feature}
+	Pattern to be used to find an include command.  It is a search
+	pattern, just like for the "/" command (See |pattern|).  The default
+	value is for C programs.  This option is used for the commands "[i",
+	"]I", "[d", etc.
+	Normally the 'isfname' option is used to recognize the file name that
+	comes after the matched pattern.  But if "\zs" appears in the pattern
+	then the text matched from "\zs" to the end, or until "\ze" if it
+	appears, is used as the file name.  Use this to include characters
+	that are not in 'isfname', such as a space.  You can then use
+	'includeexpr' to process the matched text.
+	See |option-backslash| about including spaces and backslashes.
+
+						*'includeexpr'* *'inex'*
+'includeexpr' 'inex'	string	(default "")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the
+			|+find_in_path| or |+eval| features}
+	Expression to be used to transform the string found with the 'include'
+	option to a file name.  Mostly useful to change "." to "/" for Java: >
+		:set includeexpr=substitute(v:fname,'\\.','/','g')
+<	The "v:fname" variable will be set to the file name that was detected.
+
+	Also used for the |gf| command if an unmodified file name can't be
+	found.  Allows doing "gf" on the name after an 'include' statement.
+	Also used for |<cfile>|.
+
+	The expression will be evaluated in the |sandbox| when set from a
+	modeline, see |sandbox-option|.
+
+	It is not allowed to change text or jump to another window while
+	evaluating 'includeexpr' |textlock|.
+
+				 *'incsearch'* *'is'* *'noincsearch'* *'nois'*
+'incsearch' 'is'	boolean	(default off, set in |defaults.vim| if the
+						+reltime feature is supported)
+			global
+			{not in Vi}
+			{not available when compiled without the
+			|+extra_search| features}
+	While typing a search command, show where the pattern, as it was typed
+	so far, matches.  The matched string is highlighted.  If the pattern
+	is invalid or not found, nothing is shown.  The screen will be updated
+	often, this is only useful on fast terminals.
+	Also applies to the pattern in commands: >
+		:global
+		:lvimgrep
+		:lvimgrepadd
+		:smagic
+		:snomagic
+		:sort
+		:substitute
+		:vglobal
+		:vimgrep
+		:vimgrepadd
+<	Note that the match will be shown, but the cursor will return to its
+	original position when no match is found and when pressing <Esc>.  You
+	still need to finish the search command with <Enter> to move the
+	cursor to the match.
+	You can use the CTRL-G and CTRL-T keys to move to the next and
+	previous match. |c_CTRL-G| |c_CTRL-T|
+	When compiled with the |+reltime| feature Vim only searches for about
+	half a second.  With a complicated pattern and/or a lot of text the
+	match may not be found.  This is to avoid that Vim hangs while you
+	are typing the pattern.
+	The highlighting can be set with the 'i' flag in 'highlight'.
+	When 'hlsearch' is on, all matched strings are highlighted too while
+	typing a search command. See also: 'hlsearch'.
+	If you don't want to turn 'hlsearch' on, but want to highlight all
+	matches while searching, you can turn on and off 'hlsearch' with
+	autocmd.  Example: >
+		augroup vimrc-incsearch-highlight
+		  autocmd!
+		  autocmd CmdlineEnter /,\? :set hlsearch
+		  autocmd CmdlineLeave /,\? :set nohlsearch
+		augroup END
+<
+	CTRL-L can be used to add one character from after the current match
+	to the command line.  If 'ignorecase' and 'smartcase' are set and the
+	command line has no uppercase characters, the added character is
+	converted to lowercase.
+	CTRL-R CTRL-W can be used to add the word at the end of the current
+	match, excluding the characters that were already typed.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'indentexpr'* *'inde'*
+'indentexpr' 'inde'	string	(default "")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+cindent|
+			or |+eval| features}
+	Expression which is evaluated to obtain the proper indent for a line.
+	It is used when a new line is created, for the |=| operator and
+	in Insert mode as specified with the 'indentkeys' option.
+	When this option is not empty, it overrules the 'cindent' and
+	'smartindent' indenting.  When 'lisp' is set, this option is
+	overridden by the Lisp indentation algorithm.
+	When 'paste' is set this option is not used for indenting.
+	The expression is evaluated with |v:lnum| set to the line number for
+	which the indent is to be computed.  The cursor is also in this line
+	when the expression is evaluated (but it may be moved around).
+	The expression must return the number of spaces worth of indent.  It
+	can return "-1" to keep the current indent (this means 'autoindent' is
+	used for the indent).
+	Functions useful for computing the indent are |indent()|, |cindent()|
+	and |lispindent()|.
+	The evaluation of the expression must not have side effects!  It must
+	not change the text, jump to another window, etc.  Afterwards the
+	cursor position is always restored, thus the cursor may be moved.
+	Normally this option would be set to call a function: >
+		:set indentexpr=GetMyIndent()
+<	Error messages will be suppressed, unless the 'debug' option contains
+	"msg".
+	See |indent-expression|.
+	NOTE: This option is set to "" when 'compatible' is set.
+
+	The expression will be evaluated in the |sandbox| when set from a
+	modeline, see |sandbox-option|.
+
+	It is not allowed to change text or jump to another window while
+	evaluating 'indentexpr' |textlock|.
+
+
+						*'indentkeys'* *'indk'*
+'indentkeys' 'indk'	string	(default "0{,0},:,0#,!^F,o,O,e")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+cindent|
+			feature}
+	A list of keys that, when typed in Insert mode, cause reindenting of
+	the current line.  Only happens if 'indentexpr' isn't empty.
+	The format is identical to 'cinkeys', see |indentkeys-format|.
+	See |C-indenting| and |indent-expression|.
+
+			*'infercase'* *'inf'* *'noinfercase'* *'noinf'*
+'infercase' 'inf'	boolean	(default off)
+			local to buffer
+			{not in Vi}
+	When doing keyword completion in insert mode |ins-completion|, and
+	'ignorecase' is also on, the case of the match is adjusted depending
+	on the typed text.  If the typed text contains a lowercase letter
+	where the match has an upper case letter, the completed part is made
+	lowercase.  If the typed text has no lowercase letters and the match
+	has a lowercase letter where the typed text has an uppercase letter,
+	and there is a letter before it, the completed part is made uppercase.
+	With 'noinfercase' the match is used as-is.
+
+			*'insertmode'* *'im'* *'noinsertmode'* *'noim'*
+'insertmode' 'im'	boolean	(default off)
+			global
+			{not in Vi}
+	Makes Vim work in a way that Insert mode is the default mode.  Useful
+	if you want to use Vim as a modeless editor.  Used for |evim|.
+	These Insert mode commands will be useful:
+	- Use the cursor keys to move around.
+	- Use CTRL-O to execute one Normal mode command |i_CTRL-O|.  When
+	  this is a mapping, it is executed as if 'insertmode' was off.
+	  Normal mode remains active until the mapping is finished.
+	- Use CTRL-L to execute a number of Normal mode commands, then use
+	  <Esc> to get back to Insert mode.  Note that CTRL-L moves the cursor
+	  left, like <Esc> does when 'insertmode' isn't set.  |i_CTRL-L|
+
+	These items change when 'insertmode' is set:
+	- when starting to edit of a file, Vim goes to Insert mode.
+	- <Esc> in Insert mode is a no-op and beeps.
+	- <Esc> in Normal mode makes Vim go to Insert mode.
+	- CTRL-L in Insert mode is a command, it is not inserted.
+	- CTRL-Z in Insert mode suspends Vim, see |CTRL-Z|.	*i_CTRL-Z*
+	However, when <Esc> is used inside a mapping, it behaves like
+	'insertmode' was not set.  This was done to be able to use the same
+	mappings with 'insertmode' set or not set.
+	When executing commands with |:normal| 'insertmode' is not used.
+
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'isfname'* *'isf'*
+'isfname' 'isf'		string	(default for MS-DOS, Win32 and OS/2:
+			     "@,48-57,/,\,.,-,_,+,,,#,$,%,{,},[,],:,@-@,!,~,="
+			    for AMIGA: "@,48-57,/,.,-,_,+,,,$,:"
+			    for VMS: "@,48-57,/,.,-,_,+,,,#,$,%,<,>,[,],:,;,~"
+			    for OS/390: "@,240-249,/,.,-,_,+,,,#,$,%,~,="
+			    otherwise: "@,48-57,/,.,-,_,+,,,#,$,%,~,=")
+			global
+			{not in Vi}
+	The characters specified by this option are included in file names and
+	path names.  Filenames are used for commands like "gf", "[i" and in
+	the tags file.  It is also used for "\f" in a |pattern|.
+	Multi-byte characters 256 and above are always included, only the
+	characters up to 255 are specified with this option.
+	For UTF-8 the characters 0xa0 to 0xff are included as well.
+	Think twice before adding white space to this option.  Although a
+	space may appear inside a file name, the effect will be that Vim
+	doesn't know where a file name starts or ends when doing completion.
+	It most likely works better without a space in 'isfname'.
+
+	Note that on systems using a backslash as path separator, Vim tries to
+	do its best to make it work as you would expect.  That is a bit
+	tricky, since Vi originally used the backslash to escape special
+	characters.  Vim will not remove a backslash in front of a normal file
+	name character on these systems, but it will on Unix and alikes.  The
+	'&' and '^' are not included by default, because these are special for
+	cmd.exe.
+
+	The format of this option is a list of parts, separated with commas.
+	Each part can be a single character number or a range.  A range is two
+	character numbers with '-' in between.  A character number can be a
+	decimal number between 0 and 255 or the ASCII character itself (does
+	not work for digits).  Example:
+		"_,-,128-140,#-43"	(include '_' and '-' and the range
+					128 to 140 and '#' to 43)
+	If a part starts with '^', the following character number or range
+	will be excluded from the option.  The option is interpreted from left
+	to right.  Put the excluded character after the range where it is
+	included.  To include '^' itself use it as the last character of the
+	option or the end of a range.  Example:
+		"^a-z,#,^"	(exclude 'a' to 'z', include '#' and '^')
+	If the character is '@', all characters where isalpha() returns TRUE
+	are included.  Normally these are the characters a to z and A to Z,
+	plus accented characters.  To include '@' itself use "@-@".  Examples:
+		"@,^a-z"	All alphabetic characters, excluding lower
+				case ASCII letters.
+		"a-z,A-Z,@-@"	All letters plus the '@' character.
+	A comma can be included by using it where a character number is
+	expected.  Example:
+		"48-57,,,_"	Digits, comma and underscore.
+	A comma can be excluded by prepending a '^'.  Example:
+		" -~,^,,9"	All characters from space to '~', excluding
+				comma, plus <Tab>.
+	See |option-backslash| about including spaces and backslashes.
+
+						*'isident'* *'isi'*
+'isident' 'isi'		string	(default for MS-DOS, Win32 and OS/2:
+					   "@,48-57,_,128-167,224-235"
+				otherwise: "@,48-57,_,192-255")
+			global
+			{not in Vi}
+	The characters given by this option are included in identifiers.
+	Identifiers are used in recognizing environment variables and after a
+	match of the 'define' option.  It is also used for "\i" in a
+	|pattern|.  See 'isfname' for a description of the format of this
+	option.
+	Careful: If you change this option, it might break expanding
+	environment variables.  E.g., when '/' is included and Vim tries to
+	expand "$HOME/.viminfo".  Maybe you should change 'iskeyword' instead.
+
+						*'iskeyword'* *'isk'*
+'iskeyword' 'isk'	string (Vim default for MS-DOS and Win32:
+					    "@,48-57,_,128-167,224-235"
+				   otherwise:  "@,48-57,_,192-255"
+				Vi default: "@,48-57,_")
+			local to buffer
+			{not in Vi}
+	Keywords are used in searching and recognizing with many commands:
+	"w", "*", "[i", etc.  It is also used for "\k" in a |pattern|.  See
+	'isfname' for a description of the format of this option.  For C
+	programs you could use "a-z,A-Z,48-57,_,.,-,>".
+	For a help file it is set to all non-blank printable characters except
+	'*', '"' and '|' (so that CTRL-] on a command finds the help for that
+	command).
+	When the 'lisp' option is on the '-' character is always included.
+	This option also influences syntax highlighting, unless the syntax
+	uses |:syn-iskeyword|.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'isprint'* *'isp'*
+'isprint' 'isp'	string	(default for MS-DOS, Win32, OS/2 and Macintosh:
+				"@,~-255"; otherwise: "@,161-255")
+			global
+			{not in Vi}
+	The characters given by this option are displayed directly on the
+	screen.  It is also used for "\p" in a |pattern|.  The characters from
+	space (ASCII 32) to '~' (ASCII 126) are always displayed directly,
+	even when they are not included in 'isprint' or excluded.  See
+	'isfname' for a description of the format of this option.
+
+	Non-printable characters are displayed with two characters:
+		  0 -  31	"^@" - "^_"
+		 32 - 126	always single characters
+		   127		"^?"
+		128 - 159	"~@" - "~_"
+		160 - 254	"| " - "|~"
+		   255		"~?"
+	When 'encoding' is a Unicode one, illegal bytes from 128 to 255 are
+	displayed as <xx>, with the hexadecimal value of the byte.
+	When 'display' contains "uhex" all unprintable characters are
+	displayed as <xx>.
+	The SpecialKey highlighting will be used for unprintable characters.
+	|hl-SpecialKey|
+
+	Multi-byte characters 256 and above are always included, only the
+	characters up to 255 are specified with this option.  When a character
+	is printable but it is not available in the current font, a
+	replacement character will be shown.
+	Unprintable and zero-width Unicode characters are displayed as <xxxx>.
+	There is no option to specify these characters.
+
+			*'joinspaces'* *'js'* *'nojoinspaces'* *'nojs'*
+'joinspaces' 'js'	boolean	(default on)
+			global
+			{not in Vi}
+	Insert two spaces after a '.', '?' and '!' with a join command.
+	When 'cpoptions' includes the 'j' flag, only do this after a '.'.
+	Otherwise only one space is inserted.
+	NOTE: This option is set when 'compatible' is set.
+
+							*'key'*
+'key'			string	(default "")
+			local to buffer
+			{not in Vi}
+			{only available when compiled with the |+cryptv|
+			feature}
+	The key that is used for encrypting and decrypting the current buffer.
+	See |encryption| and 'cryptmethod'.
+	Careful: Do not set the key value by hand, someone might see the typed
+	key.  Use the |:X| command.  But you can make 'key' empty: >
+		:set key=
+<	It is not possible to get the value of this option with ":set key" or
+	"echo &key".  This is to avoid showing it to someone who shouldn't
+	know.  It also means you cannot see it yourself once you have set it,
+	be careful not to make a typing error!
+	You can use "&key" in an expression to detect whether encryption is
+	enabled.  When 'key' is set it returns "*****" (five stars).
+
+					*'keymap'* *'kmp'* *E544*
+'keymap' 'kmp'		string	(default "")
+			local to buffer
+			{not in Vi}
+			{only available when compiled with the |+keymap|
+			feature}
+	Name of a keyboard mapping.  See |mbyte-keymap|.
+	Setting this option to a valid keymap name has the side effect of
+	setting 'iminsert' to one, so that the keymap becomes effective.
+	'imsearch' is also set to one, unless it was -1
+	Only normal file name characters can be used, "/\*?[|<>" are illegal.
+
+					*'keymodel'* *'km'*
+'keymodel' 'km'		string	(default "")
+			global
+			{not in Vi}
+	List of comma separated words, which enable special things that keys
+	can do.  These values can be used:
+	   startsel	Using a shifted special key starts selection (either
+			Select mode or Visual mode, depending on "key" being
+			present in 'selectmode').
+	   stopsel	Using a not-shifted special key stops selection.
+	Special keys in this context are the cursor keys, <End>, <Home>,
+	<PageUp> and <PageDown>.
+	The 'keymodel' option is set by the |:behave| command.
+
+					*'keywordprg'* *'kp'*
+'keywordprg' 'kp'	string	(default "man" or "man -s",  DOS: ":help",
+								  VMS: "help")
+			global or local to buffer |global-local|
+			{not in Vi}
+	Program to use for the |K| command.  Environment variables are
+	expanded |:set_env|.  ":help" may be used to access the Vim internal
+	help.  (Note that previously setting the global option to the empty
+	value did this, which is now deprecated.)
+	When the first character is ":", the command is invoked as a Vim
+	Ex command prefixed with [count].
+	When "man", "man -s" or an Ex command is used, Vim will automatically
+	translate a count for the "K" command and pass it as the first
+	argument.  For "man -s" the "-s" is removed when there is no count.
+	See |option-backslash| about including spaces and backslashes.
+	Example: >
+		:set keywordprg=man\ -s
+<	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+					*'langmap'* *'lmap'* *E357* *E358*
+'langmap' 'lmap'	string	(default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+langmap|
+			feature}
+	This option allows switching your keyboard into a special language
+	mode.  When you are typing text in Insert mode the characters are
+	inserted directly.  When in Normal mode the 'langmap' option takes
+	care of translating these special characters to the original meaning
+	of the key.  This means you don't have to change the keyboard mode to
+	be able to execute Normal mode commands.
+	This is the opposite of the 'keymap' option, where characters are
+	mapped in Insert mode.
+	Also consider resetting 'langremap' to avoid 'langmap' applies to
+	characters resulting from a mapping.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+	Example (for Greek, in UTF-8):				*greek*  >
+	    :set langmap=A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,QQ,R,S,T,U,V,WW,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,qq,r,s,t,u,v,w,x,y,z
+<	Example (exchanges meaning of z and y for commands): >
+	    :set langmap=zy,yz,ZY,YZ
+<
+	The 'langmap' option is a list of parts, separated with commas.  Each
+	part can be in one of two forms:
+	1.  A list of pairs.  Each pair is a "from" character immediately
+	    followed by the "to" character.  Examples: "aA", "aAbBcC".
+	2.  A list of "from" characters, a semi-colon and a list of "to"
+	    characters.  Example: "abc;ABC"
+	Example: "aA,fgh;FGH,cCdDeE"
+	Special characters need to be preceded with a backslash.  These are
+	";", ',' and backslash itself.
+
+	This will allow you to activate vim actions without having to switch
+	back and forth between the languages.  Your language characters will
+	be understood as normal vim English characters (according to the
+	langmap mappings) in the following cases:
+	 o Normal/Visual mode (commands, buffer/register names, user mappings)
+	 o Insert/Replace Mode: Register names after CTRL-R
+	 o Insert/Replace Mode: Mappings
+	Characters entered in Command-line mode will NOT be affected by
+	this option.   Note that this option can be changed at any time
+	allowing to switch between mappings for different languages/encodings.
+	Use a mapping to avoid having to type it each time!
+
+					*'langmenu'* *'lm'*
+'langmenu' 'lm'		string	(default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+menu| and
+			|+multi_lang| features}
+	Language to use for menu translation.  Tells which file is loaded
+	from the "lang" directory in 'runtimepath': >
+		"lang/menu_" . &langmenu . ".vim"
+<	(without the spaces).  For example, to always use the Dutch menus, no
+	matter what $LANG is set to: >
+		:set langmenu=nl_NL.ISO_8859-1
+<	When 'langmenu' is empty, |v:lang| is used.
+	Only normal file name characters can be used, "/\*?[|<>" are illegal.
+	If your $LANG is set to a non-English language but you do want to use
+	the English menus: >
+		:set langmenu=none
+<	This option must be set before loading menus, switching on filetype
+	detection or syntax highlighting.  Once the menus are defined setting
+	this option has no effect.  But you could do this: >
+		:source $VIMRUNTIME/delmenu.vim
+		:set langmenu=de_DE.ISO_8859-1
+		:source $VIMRUNTIME/menu.vim
+<	Warning: This deletes all menus that you defined yourself!
+
+			*'langnoremap'* *'lnr'* *'nolangnoremap'* *'nolnr'*
+'langnoremap' 'lnr'	boolean (default off, set in |defaults.vim|)
+			global
+			{not in Vi}
+			{only available when compiled with the |+langmap|
+			feature}
+	This is just like 'langremap' but with the value inverted.  It only
+	exists for backwards compatibility.  When setting 'langremap' then
+	'langnoremap' is set to the inverted value, and the other way around.
+
+			*'langremap'* *'lrm'* *'nolangremap'* *'nolrm'*
+'langremap' 'lrm'	boolean (default on, reset in |defaults.vim|)
+			global
+			{not in Vi}
+			{only available when compiled with the |+langmap|
+			feature}
+	When off, setting 'langmap' does not apply to characters resulting from
+	a mapping.  This basically means, if you noticed that setting
+	'langmap' disables some of your mappings, try resetting this option.
+	This option defaults to on for backwards compatibility.  Set it off if
+	that works for you to avoid mappings to break.
+
+					*'laststatus'* *'ls'*
+'laststatus' 'ls'	number	(default 1)
+			global
+			{not in Vi}
+	The value of this option influences when the last window will have a
+	status line:
+		0: never
+		1: only if there are at least two windows
+		2: always
+	The screen looks nicer with a status line if you have several
+	windows, but it takes another screen line. |status-line|
+
+			*'lazyredraw'* *'lz'* *'nolazyredraw'* *'nolz'*
+'lazyredraw' 'lz'	boolean	(default off)
+			global
+			{not in Vi}
+	When this option is set, the screen will not be redrawn while
+	executing macros, registers and other commands that have not been
+	typed.  Also, updating the window title is postponed.  To force an
+	update use |:redraw|.
+
+			*'linebreak'* *'lbr'* *'nolinebreak'* *'nolbr'*
+'linebreak' 'lbr'	boolean	(default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	If on, Vim will wrap long lines at a character in 'breakat' rather
+	than at the last character that fits on the screen.  Unlike
+	'wrapmargin' and 'textwidth', this does not insert <EOL>s in the file,
+	it only affects the way the file is displayed, not its contents.
+	If 'breakindent' is set, line is visually indented. Then, the value
+	of 'showbreak' is used to put in front of wrapped lines. This option
+	is not used when the 'wrap' option is off.
+	Note that <Tab> characters after an <EOL> are mostly not displayed
+	with the right amount of white space.
+
+						*'lines'* *E593*
+'lines'			number	(default 24 or terminal height)
+			global
+	Number of lines of the Vim window.
+	Normally you don't need to set this.  It is done automatically by the
+	terminal initialization code.  Also see |posix-screen-size|.
+	When Vim is running in the GUI or in a resizable window, setting this
+	option will cause the window size to be changed.  When you only want
+	to use the size for the GUI, put the command in your |gvimrc| file.
+	Vim limits the number of lines to what fits on the screen.  You can
+	use this command to get the tallest window possible: >
+		:set lines=999
+<	Minimum value is 2, maximum value is 1000.
+	If you get fewer lines than expected, check the 'guiheadroom' option.
+	When you set this option and Vim is unable to change the physical
+	number of lines of the display, the display may be messed up.
+
+						*'linespace'* *'lsp'*
+'linespace' 'lsp'	number	(default 0, 1 for Win32 GUI)
+			global
+			{not in Vi}
+			{only in the GUI}
+	Number of pixel lines inserted between characters.  Useful if the font
+	uses the full character cell height, making lines touch each other.
+	When non-zero there is room for underlining.
+	With some fonts there can be too much room between lines (to have
+	space for ascents and descents).  Then it makes sense to set
+	'linespace' to a negative value.  This may cause display problems
+	though!
+
+						*'lisp'* *'nolisp'*
+'lisp'			boolean	(default off)
+			local to buffer
+			{not available when compiled without the |+lispindent|
+			feature}
+	Lisp mode: When <Enter> is typed in insert mode set the indent for
+	the next line to Lisp standards (well, sort of).  Also happens with
+	"cc" or "S".  'autoindent' must also be on for this to work.  The 'p'
+	flag in 'cpoptions' changes the method of indenting: Vi compatible or
+	better.  Also see 'lispwords'.
+	The '-' character is included in keyword characters.  Redefines the
+	"=" operator to use this same indentation algorithm rather than
+	calling an external program if 'equalprg' is empty.
+	This option is not used when 'paste' is set.
+	{Vi: Does it a little bit differently}
+
+						*'lispwords'* *'lw'*
+'lispwords' 'lw'	string	(default is very long)
+			global or local to buffer |global-local|
+			{not in Vi}
+			{not available when compiled without the |+lispindent|
+			feature}
+	Comma separated list of words that influence the Lisp indenting.
+	|'lisp'|
+
+						*'list'* *'nolist'*
+'list'			boolean	(default off)
+			local to window
+	List mode: Show tabs as CTRL-I is displayed, display $ after end of
+	line.  Useful to see the difference between tabs and spaces and for
+	trailing blanks.  Further changed by the 'listchars' option.
+
+	The cursor is displayed at the start of the space a Tab character
+	occupies, not at the end as usual in Normal mode.  To get this cursor
+	position while displaying Tabs with spaces, use: >
+		:set list lcs=tab:\ \ 
+<
+	Note that list mode will also affect formatting (set with 'textwidth'
+	or 'wrapmargin') when 'cpoptions' includes 'L'.  See 'listchars' for
+	changing the way tabs are displayed.
+
+						*'listchars'* *'lcs'*
+'listchars' 'lcs'	string	(default "eol:$")
+			global
+			{not in Vi}
+	Strings to use in 'list' mode and for the |:list| command.  It is a
+	comma separated list of string settings.
+							*lcs-eol*
+	  eol:c		Character to show at the end of each line.  When
+			omitted, there is no extra character at the end of the
+			line.
+							*lcs-tab*
+	  tab:xy	Two characters to be used to show a tab.  The first
+			char is used once.  The second char is repeated to
+			fill the space that the tab normally occupies.
+			"tab:>-" will show a tab that takes four spaces as
+			">---".  When omitted, a tab is show as ^I.
+							*lcs-space*
+	  space:c	Character to show for a space.  When omitted, spaces
+			are left blank.
+							*lcs-trail*
+	  trail:c	Character to show for trailing spaces.  When omitted,
+			trailing spaces are blank.  Overrides the "space"
+			setting for trailing spaces.
+							*lcs-extends*
+	  extends:c	Character to show in the last column, when 'wrap' is
+			off and the line continues beyond the right of the
+			screen.
+							*lcs-precedes*
+	  precedes:c	Character to show in the first column, when 'wrap'
+			is off and there is text preceding the character
+			visible in the first column.
+							*lcs-conceal*
+	  conceal:c	Character to show in place of concealed text, when
+			'conceallevel' is set to 1.
+							*lcs-nbsp*
+	  nbsp:c	Character to show for a non-breakable space character
+			(0xA0 (160 decimal) and U+202F).  Left blank when
+			omitted.
+
+	The characters ':' and ',' should not be used.  UTF-8 characters can
+	be used when 'encoding' is "utf-8", otherwise only printable
+	characters are allowed.  All characters must be single width.
+
+	Examples: >
+	    :set lcs=tab:>-,trail:-
+	    :set lcs=tab:>-,eol:<,nbsp:%
+	    :set lcs=extends:>,precedes:<
+<	The "NonText" highlighting will be used for "eol", "extends" and
+	"precedes".  "SpecialKey" for "nbsp", "space", "tab" and "trail".
+	|hl-NonText| |hl-SpecialKey|
+
+			*'lpl'* *'nolpl'* *'loadplugins'* *'noloadplugins'*
+'loadplugins' 'lpl'	boolean	(default on)
+			global
+			{not in Vi}
+	When on the plugin scripts are loaded when starting up |load-plugins|.
+	This option can be reset in your |vimrc| file to disable the loading
+	of plugins.
+	Note that using the "-u NONE", "-u DEFAULTS" and "--noplugin" command
+	line arguments reset this option.  See |-u| and |--noplugin|.
+
+						*'luadll'*
+'luadll'		string	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+lua/dyn|
+			feature}
+	Specifies the name of the Lua shared library. The default is
+	DYNAMIC_LUA_DLL, which was specified at compile time.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'macatsui'* *'nomacatsui'*
+'macatsui'		boolean	(default on)
+			global
+			{only available in Mac GUI version}
+	This is a workaround for when drawing doesn't work properly.  When set
+	and compiled with multi-byte support ATSUI text drawing is used.  When
+	not set ATSUI text drawing is not used.  Switch this option off when
+	you experience drawing problems.  In a future version the problems may
+	be solved and this option becomes obsolete.  Therefore use this method
+	to unset it: >
+		if exists('&macatsui')
+		   set nomacatsui
+		endif
+<	Another option to check if you have drawing problems is
+	'termencoding'.
+
+						*'magic'* *'nomagic'*
+'magic'			boolean	(default on)
+			global
+	Changes the special characters that can be used in search patterns.
+	See |pattern|.
+	WARNING: Switching this option off most likely breaks plugins!  That
+	is because many patterns assume it's on and will fail when it's off.
+	Only switch it off when working with old Vi scripts.  In any other
+	situation write patterns that work when 'magic' is on.  Include "\M"
+	when you want to |/\M|.
+
+						*'makeef'* *'mef'*
+'makeef' 'mef'		string	(default: "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+quickfix|
+			feature}
+	Name of the errorfile for the |:make| command (see |:make_makeprg|)
+	and the |:grep| command.
+	When it is empty, an internally generated temp file will be used.
+	When "##" is included, it is replaced by a number to make the name
+	unique.  This makes sure that the ":make" command doesn't overwrite an
+	existing file.
+	NOT used for the ":cf" command.  See 'errorfile' for that.
+	Environment variables are expanded |:set_env|.
+	See |option-backslash| about including spaces and backslashes.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+					*'makeencoding'* *'menc'*
+'makeencoding' 'menc'	string	(default "")
+			global or local to buffer |global-local|
+			{only available when compiled with the |+multi_byte|
+			feature}
+			{not in Vi}
+	Encoding used for reading the output of external commands.  When empty,
+	encoding is not converted.
+	This is used for `:make`, `:lmake`, `:grep`, `:lgrep`, `:grepadd`,
+	`:lgrepadd`, `:cfile`, `:cgetfile`, `:caddfile`, `:lfile`, `:lgetfile`,
+	and `:laddfile`.
+
+	This would be mostly useful when you use MS-Windows and set 'encoding'
+	to "utf-8".  If |+iconv| is enabled and GNU libiconv is used, setting
+	'makeencoding' to "char" has the same effect as setting to the system
+	locale encoding.  Example: >
+		:set encoding=utf-8
+		:set makeencoding=char	" system locale is used
+<
+						*'makeprg'* *'mp'*
+'makeprg' 'mp'		string	(default "make", VMS: "MMS")
+			global or local to buffer |global-local|
+			{not in Vi}
+	Program to use for the ":make" command.  See |:make_makeprg|.
+	This option may contain '%' and '#' characters (see  |:_%| and |:_#|),
+	which are expanded to the current and alternate file name.  Use |::S|
+	to escape file names in case they contain special characters.
+	Environment variables are expanded |:set_env|.  See |option-backslash|
+	about including spaces and backslashes.
+	Note that a '|' must be escaped twice: once for ":set" and once for
+	the interpretation of a command.  When you use a filter called
+	"myfilter" do it like this: >
+	    :set makeprg=gmake\ \\\|\ myfilter
+<	The placeholder "$*" can be given (even multiple times) to specify
+	where the arguments will be included, for example: >
+	    :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}
+<	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'matchpairs'* *'mps'*
+'matchpairs' 'mps'	string	(default "(:),{:},[:]")
+			local to buffer
+			{not in Vi}
+	Characters that form pairs.  The |%| command jumps from one to the
+	other.
+	Only character pairs are allowed that are different, thus you cannot
+	jump between two double quotes.
+	The characters must be separated by a colon.
+	The pairs must be separated by a comma.  Example for including '<' and
+	'>' (HTML): >
+		:set mps+=<:>
+
+<	A more exotic example, to jump between the '=' and ';' in an
+	assignment, useful for languages like C and Java: >
+		:au FileType c,cpp,java set mps+==:;
+
+<	For a more advanced way of using "%", see the matchit.vim plugin in
+	the $VIMRUNTIME/pack/dist/opt/matchit directory. |add-local-help|
+
+						*'matchtime'* *'mat'*
+'matchtime' 'mat'	number	(default 5)
+			global
+			{not in Vi}{in Nvi}
+	Tenths of a second to show the matching paren, when 'showmatch' is
+	set.  Note that this is not in milliseconds, like other options that
+	set a time.  This is to be compatible with Nvi.
+
+						*'maxcombine'* *'mco'*
+'maxcombine' 'mco'	number (default 2)
+			global
+			{not in Vi}
+			{only available when compiled with the |+multi_byte|
+			feature}
+	The maximum number of combining characters supported for displaying.
+	Only used when 'encoding' is "utf-8".
+	The default is OK for most languages.  Hebrew may require 4.
+	Maximum value is 6.
+	Even when this option is set to 2 you can still edit text with more
+	combining characters, you just can't see them.  Use |g8| or |ga|.
+	See |mbyte-combining|.
+
+						*'maxfuncdepth'* *'mfd'*
+'maxfuncdepth' 'mfd'	number	(default 100)
+			global
+			{not in Vi}
+			{not available when compiled without the |+eval|
+			feature}
+	Maximum depth of function calls for user functions.  This normally
+	catches endless recursion.  When using a recursive function with
+	more depth, set 'maxfuncdepth' to a bigger number.  But this will use
+	more memory, there is the danger of failing when memory is exhausted.
+	Increasing this limit above 200 also changes the maximum for Ex
+	command recursion, see |E169|.
+	See also |:function|.
+
+						*'maxmapdepth'* *'mmd'* *E223*
+'maxmapdepth' 'mmd'	number	(default 1000)
+			global
+			{not in Vi}
+	Maximum number of times a mapping is done without resulting in a
+	character to be used.  This normally catches endless mappings, like
+	":map x y" with ":map y x".  It still does not catch ":map g wg",
+	because the 'w' is used before the next mapping is done.  See also
+	|key-mapping|.
+
+						*'maxmem'* *'mm'*
+'maxmem' 'mm'		number	(default between 256 to 5120 (system
+				 dependent) or half the amount of memory
+				 available)
+			global
+			{not in Vi}
+	Maximum amount of memory (in Kbyte) to use for one buffer.  When this
+	limit is reached allocating extra memory for a buffer will cause
+	other memory to be freed.
+	The maximum usable value is about 2000000.  Use this to work without a
+	limit.
+	The value is ignored when 'swapfile' is off.
+	Also see 'maxmemtot'.
+
+						*'maxmempattern'* *'mmp'*
+'maxmempattern' 'mmp'	number	(default 1000)
+			global
+			{not in Vi}
+	Maximum amount of memory (in Kbyte) to use for pattern matching.
+	The maximum value is about 2000000.  Use this to work without a limit.
+							*E363*
+	When Vim runs into the limit it gives an error message and mostly
+	behaves like CTRL-C was typed.
+	Running into the limit often means that the pattern is very
+	inefficient or too complex.  This may already happen with the pattern
+	"\(.\)*" on a very long line.  ".*" works much better.
+	Might also happen on redraw, when syntax rules try to match a complex
+	text structure.
+	Vim may run out of memory before hitting the 'maxmempattern' limit, in
+	which case you get an "Out of memory" error instead.
+
+						*'maxmemtot'* *'mmt'*
+'maxmemtot' 'mmt'	number	(default between 2048 and 10240 (system
+				 dependent) or half the amount of memory
+				 available)
+			global
+			{not in Vi}
+	Maximum amount of memory in Kbyte to use for all buffers together.
+	The maximum usable value is about 2000000 (2 Gbyte).  Use this to work
+	without a limit.
+	On 64 bit machines higher values might work.  But hey, do you really
+	need more than 2 Gbyte for text editing?  Keep in mind that text is
+	stored in the swap file, one can edit files > 2 Gbyte anyway.  We do
+	need the memory to store undo info.
+	Buffers with 'swapfile' off still count to the total amount of memory
+	used.
+	Also see 'maxmem'.
+
+						*'menuitems'* *'mis'*
+'menuitems' 'mis'	number	(default 25)
+			global
+			{not in Vi}
+			{not available when compiled without the |+menu|
+			feature}
+	Maximum number of items to use in a menu.  Used for menus that are
+	generated from a list of items, e.g., the Buffers menu.  Changing this
+	option has no direct effect, the menu must be refreshed first.
+
+						*'mkspellmem'* *'msm'*
+'mkspellmem' 'msm'	string	(default "460000,2000,500")
+			global
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	Parameters for |:mkspell|.  This tunes when to start compressing the
+	word tree.  Compression can be slow when there are many words, but
+	it's needed to avoid running out of memory.  The amount of memory used
+	per word depends very much on how similar the words are, that's why
+	this tuning is complicated.
+
+	There are three numbers, separated by commas:
+		{start},{inc},{added}
+
+	For most languages the uncompressed word tree fits in memory.  {start}
+	gives the amount of memory in Kbyte that can be used before any
+	compression is done.  It should be a bit smaller than the amount of
+	memory that is available to Vim.
+
+	When going over the {start} limit the {inc} number specifies the
+	amount of memory in Kbyte that can be allocated before another
+	compression is done.  A low number means compression is done after
+	less words are added, which is slow.  A high number means more memory
+	will be allocated.
+
+	After doing compression, {added} times 1024 words can be added before
+	the {inc} limit is ignored and compression is done when any extra
+	amount of memory is needed.  A low number means there is a smaller
+	chance of hitting the {inc} limit, less memory is used but it's
+	slower.
+
+	The languages for which these numbers are important are Italian and
+	Hungarian.  The default works for when you have about 512 Mbyte.  If
+	you have 1 Gbyte you could use: >
+		:set mkspellmem=900000,3000,800
+<	If you have less than 512 Mbyte |:mkspell| may fail for some
+	languages, no matter what you set 'mkspellmem' to.
+
+				   *'modeline'* *'ml'* *'nomodeline'* *'noml'*
+'modeline' 'ml'		boolean	(Vim default: on (off for root),
+				 Vi default: off)
+			local to buffer
+						*'modelines'* *'mls'*
+'modelines' 'mls'	number	(default 5)
+			global
+			{not in Vi}
+	If 'modeline' is on 'modelines' gives the number of lines that is
+	checked for set commands.  If 'modeline' is off or 'modelines' is zero
+	no lines are checked.  See |modeline|.
+	NOTE: 'modeline' is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+				*'modifiable'* *'ma'* *'nomodifiable'* *'noma'*
+'modifiable' 'ma'	boolean	(default on)
+			local to buffer
+			{not in Vi}		*E21*
+	When off the buffer contents cannot be changed.  The 'fileformat' and
+	'fileencoding' options also can't be changed.
+	Can be reset on startup with the |-M| command line argument.
+
+				*'modified'* *'mod'* *'nomodified'* *'nomod'*
+'modified' 'mod'	boolean	(default off)
+			local to buffer
+			{not in Vi}
+	When on, the buffer is considered to be modified.  This option is set
+	when:
+	1. A change was made to the text since it was last written.  Using the
+	   |undo| command to go back to the original text will reset the
+	   option.  But undoing changes that were made before writing the
+	   buffer will set the option again, since the text is different from
+	   when it was written.
+	2. 'fileformat' or 'fileencoding' is different from its original
+	   value.  The original value is set when the buffer is read or
+	   written.  A ":set nomodified" command also resets the original
+	   values to the current values and the 'modified' option will be
+	   reset.
+	   Similarly for 'eol' and 'bomb'.
+	This option is not set when a change is made to the buffer as the
+	result of a BufNewFile, BufRead/BufReadPost, BufWritePost,
+	FileAppendPost or VimLeave autocommand event.  See |gzip-example| for
+	an explanation.
+	When 'buftype' is "nowrite" or "nofile" this option may be set, but
+	will be ignored.
+	Note that the text may actually be the same, e.g. 'modified' is set
+	when using "rA" on an "A".
+
+						*'more'* *'nomore'*
+'more'			boolean	(Vim default: on, Vi default: off)
+			global
+			{not in Vi}
+	When on, listings pause when the whole screen is filled.  You will get
+	the |more-prompt|.  When this option is off there are no pauses, the
+	listing continues until finished.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'mouse'* *E538*
+'mouse'			string	(default "", "a" for GUI, MS-DOS and Win32,
+						 set to "a" in |defaults.vim|)
+			global
+			{not in Vi}
+	Enable the use of the mouse.  Only works for certain terminals
+	(xterm, MS-DOS, Win32 |win32-mouse|, QNX pterm, *BSD console with
+	sysmouse and Linux console with gpm).  For using the mouse in the
+	GUI, see |gui-mouse|.
+	The mouse can be enabled for different modes:
+		n	Normal mode and Terminal modes
+		v	Visual mode
+		i	Insert mode
+		c	Command-line mode
+		h	all previous modes when editing a help file
+		a	all previous modes
+		r	for |hit-enter| and |more-prompt| prompt
+	Normally you would enable the mouse in all four modes with: >
+		:set mouse=a
+<	When the mouse is not enabled, the GUI will still use the mouse for
+	modeless selection.  This doesn't move the text cursor.
+
+	See |mouse-using|.  Also see |'clipboard'|.
+
+	Note: When enabling the mouse in a terminal, copy/paste will use the
+	"* register if there is access to an X-server.  The xterm handling of
+	the mouse buttons can still be used by keeping the shift key pressed.
+	Also see the 'clipboard' option.
+
+			*'mousefocus'* *'mousef'* *'nomousefocus'* *'nomousef'*
+'mousefocus' 'mousef'	boolean	(default off)
+			global
+			{not in Vi}
+			{only works in the GUI}
+	The window that the mouse pointer is on is automatically activated.
+	When changing the window layout or window focus in another way, the
+	mouse pointer is moved to the window with keyboard focus.  Off is the
+	default because it makes using the pull down menus a little goofy, as
+	a pointer transit may activate a window unintentionally.
+
+			*'mousehide'* *'mh'* *'nomousehide'* *'nomh'*
+'mousehide' 'mh'	boolean	(default on)
+			global
+			{not in Vi}
+			{only works in the GUI}
+	When on, the mouse pointer is hidden when characters are typed.
+	The mouse pointer is restored when the mouse is moved.
+
+						*'mousemodel'* *'mousem'*
+'mousemodel' 'mousem'	string	(default "extend", "popup" for MS-DOS and Win32)
+			global
+			{not in Vi}
+	Sets the model to use for the mouse.  The name mostly specifies what
+	the right mouse button is used for:
+	   extend	Right mouse button extends a selection.  This works
+			like in an xterm.
+	   popup	Right mouse button pops up a menu.  The shifted left
+			mouse button extends a selection.  This works like
+			with Microsoft Windows.
+	   popup_setpos Like "popup", but the cursor will be moved to the
+			position where the mouse was clicked, and thus the
+			selected operation will act upon the clicked object.
+			If clicking inside a selection, that selection will
+			be acted upon, i.e. no cursor move.  This implies of
+			course, that right clicking outside a selection will
+			end Visual mode.
+	Overview of what button does what for each model:
+	mouse		    extend		popup(_setpos) ~
+	left click	    place cursor	place cursor
+	left drag	    start selection	start selection
+	shift-left	    search word		extend selection
+	right click	    extend selection	popup menu (place cursor)
+	right drag	    extend selection	-
+	middle click	    paste		paste
+
+	In the "popup" model the right mouse button produces a pop-up menu.
+	You need to define this first, see |popup-menu|.
+	In a terminal the popup menu works if Vim is compiled with the
+	|+insert_expand| option.
+
+	Note that you can further refine the meaning of buttons with mappings.
+	See |gui-mouse-mapping|.  But mappings are NOT used for modeless
+	selection (because that's handled in the GUI code directly).
+
+	The 'mousemodel' option is set by the |:behave| command.
+
+					*'mouseshape'* *'mouses'* *E547*
+'mouseshape' 'mouses'	string	(default "i:beam,r:beam,s:updown,sd:cross,
+					m:no,ml:up-arrow,v:rightup-arrow")
+			global
+			{not in Vi}
+			{only available when compiled with the |+mouseshape|
+			feature}
+	This option tells Vim what the mouse pointer should look like in
+	different modes.  The option is a comma separated list of parts, much
+	like used for 'guicursor'.  Each part consist of a mode/location-list
+	and an argument-list:
+		mode-list:shape,mode-list:shape,..
+	The mode-list is a dash separated list of these modes/locations:
+			In a normal window: ~
+		n	Normal mode
+		v	Visual mode
+		ve	Visual mode with 'selection' "exclusive" (same as 'v',
+			if not specified)
+		o	Operator-pending mode
+		i	Insert mode
+		r	Replace mode
+
+			Others: ~
+		c	appending to the command-line
+		ci	inserting in the command-line
+		cr	replacing in the command-line
+		m	at the 'Hit ENTER' or 'More' prompts
+		ml	idem, but cursor in the last line
+		e	any mode, pointer below last window
+		s	any mode, pointer on a status line
+		sd	any mode, while dragging a status line
+		vs	any mode, pointer on a vertical separator line
+		vd	any mode, while dragging a vertical separator line
+		a	everywhere
+
+	The shape is one of the following:
+	avail	name		looks like ~
+	w x	arrow		Normal mouse pointer
+	w x	blank		no pointer at all (use with care!)
+	w x	beam		I-beam
+	w x	updown		up-down sizing arrows
+	w x	leftright	left-right sizing arrows
+	w x	busy		The system's usual busy pointer
+	w x	no		The system's usual 'no input' pointer
+	  x	udsizing	indicates up-down resizing
+	  x	lrsizing	indicates left-right resizing
+	  x	crosshair	like a big thin +
+	  x	hand1		black hand
+	  x	hand2		white hand
+	  x	pencil		what you write with
+	  x	question	big ?
+	  x	rightup-arrow	arrow pointing right-up
+	w x	up-arrow	arrow pointing up
+	  x	<number>	any X11 pointer number (see X11/cursorfont.h)
+
+	The "avail" column contains a 'w' if the shape is available for Win32,
+	x for X11.
+	Any modes not specified or shapes not available use the normal mouse
+	pointer.
+
+	Example: >
+		:set mouseshape=s:udsizing,m:no
+<	will make the mouse turn to a sizing arrow over the status lines and
+	indicate no input when the hit-enter prompt is displayed (since
+	clicking the mouse has no effect in this state.)
+
+						*'mousetime'* *'mouset'*
+'mousetime' 'mouset'	number	(default 500)
+			global
+			{not in Vi}
+	Only for GUI, MS-DOS, Win32 and Unix with xterm.  Defines the maximum
+	time in msec between two mouse clicks for the second click to be
+	recognized as a multi click.
+
+						*'mzschemedll'*
+'mzschemedll'		string	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+mzscheme/dyn|
+			feature}
+	Specifies the name of the MzScheme shared library. The default is
+	DYNAMIC_MZSCH_DLL which was specified at compile time.
+	Environment variables are expanded |:set_env|.
+	The value must be set in the |vimrc| script or earlier.  In the
+	startup, before the |load-plugins| step.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'mzschemegcdll'*
+'mzschemegcdll'		string	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+mzscheme/dyn|
+			feature}
+	Specifies the name of the MzScheme GC shared library. The default is
+	DYNAMIC_MZGC_DLL which was specified at compile time.
+	The value can be equal to 'mzschemedll' if it includes the GC code.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						    *'mzquantum'* *'mzq'*
+'mzquantum' 'mzq'	number	(default 100)
+			global
+			{not in Vi}
+			{not available when compiled without the |+mzscheme|
+			feature}
+	The number of milliseconds between polls for MzScheme threads.
+	Negative or zero value means no thread scheduling.
+	NOTE: This option is set to the Vim default value when 'compatible'
+	is reset.
+
+							*'nrformats'* *'nf'*
+'nrformats' 'nf'	string	(default "bin,octal,hex",
+					   set to "bin,hex" in |defaults.vim|)
+			local to buffer
+			{not in Vi}
+	This defines what bases Vim will consider for numbers when using the
+	CTRL-A and CTRL-X commands for adding to and subtracting from a number
+	respectively; see |CTRL-A| for more info on these commands.
+	alpha	If included, single alphabetical characters will be
+		incremented or decremented.  This is useful for a list with a
+		letter index a), b), etc.		*octal-nrformats*
+	octal	If included, numbers that start with a zero will be considered
+		to be octal.  Example: Using CTRL-A on "007" results in "010".
+	hex	If included, numbers starting with "0x" or "0X" will be
+		considered to be hexadecimal.  Example: Using CTRL-X on
+		"0x100" results in "0x0ff".
+	bin	If included, numbers starting with "0b" or "0B" will be
+		considered to be binary.  Example: Using CTRL-X on
+		"0b1000" subtracts one, resulting in "0b0111".
+	Numbers which simply begin with a digit in the range 1-9 are always
+	considered decimal.  This also happens for numbers that are not
+	recognized as octal or hex.
+
+				*'number'* *'nu'* *'nonumber'* *'nonu'*
+'number' 'nu'		boolean	(default off)
+			local to window
+	Print the line number in front of each line.  When the 'n' option is
+	excluded from 'cpoptions' a wrapped line will not use the column of
+	line numbers (this is the default when 'compatible' isn't set).
+	The 'numberwidth' option can be used to set the room used for the line
+	number.
+	When a long, wrapped line doesn't start with the first character, '-'
+	characters are put before the number.
+	See |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for
+	the number.
+						*number_relativenumber*
+	The 'relativenumber' option changes the displayed number to be
+	relative to the cursor.  Together with 'number' there are these
+	four combinations (cursor in line 3):
+
+		'nonu'          'nu'            'nonu'          'nu'
+		'nornu'         'nornu'         'rnu'           'rnu'
+
+	    |apple          |  1 apple      |  2 apple      |  2 apple
+	    |pear           |  2 pear       |  1 pear       |  1 pear
+	    |nobody         |  3 nobody     |  0 nobody     |3   nobody
+	    |there          |  4 there      |  1 there      |  1 there
+
+						*'numberwidth'* *'nuw'*
+'numberwidth' 'nuw'	number	(Vim default: 4  Vi default: 8)
+			local to window
+			{not in Vi}
+			{only available when compiled with the |+linebreak|
+			feature}
+	Minimal number of columns to use for the line number.  Only relevant
+	when the 'number' or 'relativenumber' option is set or printing lines
+	with a line number. Since one space is always between the number and
+	the text, there is one less character for the number itself.
+	The value is the minimum width.  A bigger width is used when needed to
+	fit the highest line number in the buffer respectively the number of
+	rows in the window, depending on whether 'number' or 'relativenumber'
+	is set. Thus with the Vim default of 4 there is room for a line number
+	up to 999. When the buffer has 1000 lines five columns will be used.
+	The minimum value is 1, the maximum value is 10.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'omnifunc'* *'ofu'*
+'omnifunc' 'ofu'	string	(default: empty)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+eval|
+			or |+insert_expand| features}
+	This option specifies a function to be used for Insert mode omni
+	completion with CTRL-X CTRL-O. |i_CTRL-X_CTRL-O|
+	See |complete-functions| for an explanation of how the function is
+	invoked and what it should return.
+	This option is usually set by a filetype plugin:
+	|:filetype-plugin-on|
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+
+			    *'opendevice'* *'odev'* *'noopendevice'* *'noodev'*
+'opendevice' 'odev'	boolean	(default off)
+			global
+			{not in Vi}
+			{only for MS-DOS, MS-Windows and OS/2}
+	Enable reading and writing from devices.  This may get Vim stuck on a
+	device that can be opened but doesn't actually do the I/O.  Therefore
+	it is off by default.
+	Note that on MS-Windows editing "aux.h", "lpt1.txt" and the like also
+	result in editing a device.
+
+
+						*'operatorfunc'* *'opfunc'*
+'operatorfunc' 'opfunc'	string	(default: empty)
+			global
+			{not in Vi}
+	This option specifies a function to be called by the |g@| operator.
+	See |:map-operator| for more info and an example.
+
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+
+					*'osfiletype'* *'oft'*
+'osfiletype' 'oft'	string (default: "")
+			local to buffer
+			{not in Vi}
+	This option was supported on RISC OS, which has been removed.
+
+
+				*'packpath'* *'pp'*
+'packpath' 'pp'		string	(default: see 'runtimepath')
+			{not in Vi}
+	Directories used to find packages.  See |packages|.
+
+
+						*'paragraphs'* *'para'*
+'paragraphs' 'para'	string	(default "IPLPPPQPP TPHPLIPpLpItpplpipbp")
+			global
+	Specifies the nroff macros that separate paragraphs.  These are pairs
+	of two letters (see |object-motions|).
+
+						*'paste'* *'nopaste'*
+'paste'			boolean	(default off)
+			global
+			{not in Vi}
+	Put Vim in Paste mode.  This is useful if you want to cut or copy
+	some text from one window and paste it in Vim.  This will avoid
+	unexpected effects.
+	Setting this option is useful when using Vim in a terminal, where Vim
+	cannot distinguish between typed text and pasted text.  In the GUI, Vim
+	knows about pasting and will mostly do the right thing without 'paste'
+	being set.  The same is true for a terminal where Vim handles the
+	mouse clicks itself.
+	This option is reset when starting the GUI.  Thus if you set it in
+	your .vimrc it will work in a terminal, but not in the GUI.  Setting
+	'paste' in the GUI has side effects: e.g., the Paste toolbar button
+	will no longer work in Insert mode, because it uses a mapping.
+	When the 'paste' option is switched on (also when it was already on):
+		- mapping in Insert mode and Command-line mode is disabled
+		- abbreviations are disabled
+		- 'autoindent' is reset
+		- 'expandtab' is reset
+		- 'formatoptions' is used like it is empty
+		- 'revins' is reset
+		- 'ruler' is reset
+		- 'showmatch' is reset
+		- 'smartindent' is reset
+		- 'smarttab' is reset
+		- 'softtabstop' is set to 0
+		- 'textwidth' is set to 0
+		- 'wrapmargin' is set to 0
+	These options keep their value, but their effect is disabled:
+		- 'cindent'
+		- 'indentexpr'
+		- 'lisp'
+	NOTE: When you start editing another file while the 'paste' option is
+	on, settings from the modelines or autocommands may change the
+	settings again, causing trouble when pasting text.  You might want to
+	set the 'paste' option again.
+	When the 'paste' option is reset the mentioned options are restored to
+	the value before the moment 'paste' was switched from off to on.
+	Resetting 'paste' before ever setting it does not have any effect.
+	Since mapping doesn't work while 'paste' is active, you need to use
+	the 'pastetoggle' option to toggle the 'paste' option with some key.
+
+						*'pastetoggle'* *'pt'*
+'pastetoggle' 'pt'	string	(default "")
+			global
+			{not in Vi}
+	When non-empty, specifies the key sequence that toggles the 'paste'
+	option.  This is like specifying a mapping: >
+	    :map {keys} :set invpaste<CR>
+<	Where {keys} is the value of 'pastetoggle'.
+	The difference is that it will work even when 'paste' is set.
+	'pastetoggle' works in Insert mode and Normal mode, but not in
+	Command-line mode.
+	Mappings are checked first, thus overrule 'pastetoggle'.  However,
+	when 'paste' is on mappings are ignored in Insert mode, thus you can do
+	this: >
+	    :map <F10> :set paste<CR>
+	    :map <F11> :set nopaste<CR>
+	    :imap <F10> <C-O>:set paste<CR>
+	    :imap <F11> <nop>
+	    :set pastetoggle=<F11>
+<	This will make <F10> start paste mode and <F11> stop paste mode.
+	Note that typing <F10> in paste mode inserts "<F10>", since in paste
+	mode everything is inserted literally, except the 'pastetoggle' key
+	sequence.
+	When the value has several bytes 'ttimeoutlen' applies.
+
+						*'pex'* *'patchexpr'*
+'patchexpr' 'pex'	string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+diff|
+			feature}
+	Expression which is evaluated to apply a patch to a file and generate
+	the resulting new version of the file.  See |diff-patchexpr|.
+
+					*'patchmode'* *'pm'* *E205* *E206*
+'patchmode' 'pm'	string	(default "")
+			global
+			{not in Vi}
+	When non-empty the oldest version of a file is kept.  This can be used
+	to keep the original version of a file if you are changing files in a
+	source distribution.  Only the first time that a file is written a
+	copy of the original file will be kept.  The name of the copy is the
+	name of the original file with the string in the 'patchmode' option
+	appended.  This option should start with a dot.  Use a string like
+	".orig" or ".org".  'backupdir' must not be empty for this to work
+	(Detail: The backup file is renamed to the patchmode file after the
+	new file has been successfully written, that's why it must be possible
+	to write a backup file).  If there was no file to be backed up, an
+	empty file is created.
+	When the 'backupskip' pattern matches, a patchmode file is not made.
+	Using 'patchmode' for compressed files appends the extension at the
+	end (e.g., "file.gz.orig"), thus the resulting name isn't always
+	recognized as a compressed file.
+	Only normal file name characters can be used, "/\*?[|<>" are illegal.
+
+				*'path'* *'pa'* *E343* *E345* *E347* *E854*
+'path' 'pa'		string	(default on Unix: ".,/usr/include,,"
+				   on OS/2:	  ".,/emx/include,,"
+				   other systems: ".,,")
+			global or local to buffer |global-local|
+			{not in Vi}
+	This is a list of directories which will be searched when using the
+	|gf|, [f, ]f, ^Wf, |:find|, |:sfind|, |:tabfind| and other commands,
+	provided that the file being searched for has a relative path (not
+	starting with "/", "./" or "../").  The directories in the 'path'
+	option may be relative or absolute.
+	- Use commas to separate directory names: >
+		:set path=.,/usr/local/include,/usr/include
+<	- Spaces can also be used to separate directory names (for backwards
+	  compatibility with version 3.0).  To have a space in a directory
+	  name, precede it with an extra backslash, and escape the space: >
+		:set path=.,/dir/with\\\ space
+<	- To include a comma in a directory name precede it with an extra
+	  backslash: >
+		:set path=.,/dir/with\\,comma
+<	- To search relative to the directory of the current file, use: >
+		:set path=.
+<	- To search in the current directory use an empty string between two
+	  commas: >
+		:set path=,,
+<	- A directory name may end in a ':' or '/'.
+	- Environment variables are expanded |:set_env|.
+	- When using |netrw.vim| URLs can be used.  For example, adding
+	  "http://www.vim.org" will make ":find index.html" work.
+	- Search upwards and downwards in a directory tree using "*", "**" and
+	  ";".  See |file-searching| for info and syntax.
+	  {not available when compiled without the |+path_extra| feature}
+	- Careful with '\' characters, type two to get one in the option: >
+		:set path=.,c:\\include
+<	  Or just use '/' instead: >
+		:set path=.,c:/include
+<	Don't forget "." or files won't even be found in the same directory as
+	the file!
+	The maximum length is limited.  How much depends on the system, mostly
+	it is something like 256 or 1024 characters.
+	You can check if all the include files are found, using the value of
+	'path', see |:checkpath|.
+	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	directories from the list.  This avoids problems when a future version
+	uses another default.  To remove the current directory use: >
+		:set path-=
+<	To add the current directory use: >
+		:set path+=
+<	To use an environment variable, you probably need to replace the
+	separator.  Here is an example to append $INCL, in which directory
+	names are separated with a semi-colon: >
+		:let &path = &path . "," . substitute($INCL, ';', ',', 'g')
+<	Replace the ';' with a ':' or whatever separator is used.  Note that
+	this doesn't work when $INCL contains a comma or white space.
+
+						*'perldll'*
+'perldll'		string	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+perl/dyn|
+			feature}
+	Specifies the name of the Perl shared library. The default is
+	DYNAMIC_PERL_DLL, which was specified at compile time.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+			*'preserveindent'* *'pi'* *'nopreserveindent'* *'nopi'*
+'preserveindent' 'pi'	boolean	(default off)
+			local to buffer
+			{not in Vi}
+	When changing the indent of the current line, preserve as much of the
+	indent structure as possible.  Normally the indent is replaced by a
+	series of tabs followed by spaces as required (unless |'expandtab'| is
+	enabled, in which case only spaces are used).  Enabling this option
+	means the indent will preserve as many existing characters as possible
+	for indenting, and only add additional tabs or spaces as required.
+	'expandtab' does not apply to the preserved white space, a Tab remains
+	a Tab.
+	NOTE: When using ">>" multiple times the resulting indent is a mix of
+	tabs and spaces.  You might not like this.
+	NOTE: This option is reset when 'compatible' is set.
+	Also see 'copyindent'.
+	Use |:retab| to clean up white space.
+
+					*'previewheight'* *'pvh'*
+'previewheight' 'pvh'	number (default 12)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows| or
+			|+quickfix| features}
+	Default height for a preview window.  Used for |:ptag| and associated
+	commands.  Used for |CTRL-W_}| when no count is given.
+
+					*'previewwindow'* *'nopreviewwindow'*
+					*'pvw'* *'nopvw'* *E590*
+'previewwindow' 'pvw'	boolean (default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+windows| or
+			|+quickfix| features}
+	Identifies the preview window.  Only one window can have this option
+	set.  It's normally not set directly, but by using one of the commands
+	|:ptag|, |:pedit|, etc.
+
+						*'printdevice'* *'pdev'*
+'printdevice' 'pdev'	string	(default empty)
+			global
+			{not in Vi}
+			{only available when compiled with the |+printer|
+			feature}
+	The name of the printer to be used for |:hardcopy|.
+	See |pdev-option|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'printencoding'* *'penc'*
+'printencoding' 'penc'	String	(default empty, except for some systems)
+			global
+			{not in Vi}
+			{only available when compiled with the |+printer|
+			and |+postscript| features}
+	Sets the character encoding used when printing.
+	See |penc-option|.
+
+						*'printexpr'* *'pexpr'*
+'printexpr' 'pexpr'	String	(default: see below)
+			global
+			{not in Vi}
+			{only available when compiled with the |+printer|
+			and |+postscript| features}
+	Expression used to print the PostScript produced with |:hardcopy|.
+	See |pexpr-option|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'printfont'* *'pfn'*
+'printfont' 'pfn'	string	(default "courier")
+			global
+			{not in Vi}
+			{only available when compiled with the |+printer|
+			feature}
+	The name of the font that will be used for |:hardcopy|.
+	See |pfn-option|.
+
+						*'printheader'* *'pheader'*
+'printheader' 'pheader'  string  (default "%<%f%h%m%=Page %N")
+			global
+			{not in Vi}
+			{only available when compiled with the |+printer|
+			feature}
+	The format of the header produced in |:hardcopy| output.
+	See |pheader-option|.
+
+						*'printmbcharset'* *'pmbcs'*
+'printmbcharset' 'pmbcs'  string (default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+printer|,
+			|+postscript| and |+multi_byte| features}
+	The CJK character set to be used for CJK output from |:hardcopy|.
+	See |pmbcs-option|.
+
+						*'printmbfont'* *'pmbfn'*
+'printmbfont' 'pmbfn'	string (default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+printer|,
+			|+postscript| and |+multi_byte| features}
+	List of font names to be used for CJK output from |:hardcopy|.
+	See |pmbfn-option|.
+
+						*'printoptions'* *'popt'*
+'printoptions' 'popt' string (default "")
+			global
+			{not in Vi}
+			{only available when compiled with |+printer| feature}
+	List of items that control the format of the output of |:hardcopy|.
+	See |popt-option|.
+
+						*'prompt'* *'noprompt'*
+'prompt'		boolean	(default on)
+			global
+	When on a ":" prompt is used in Ex mode.
+
+						*'pumheight'* *'ph'*
+'pumheight' 'ph'	number	(default 0)
+			global
+			{not available when compiled without the
+			|+insert_expand| feature}
+			{not in Vi}
+	Determines the maximum number of items to show in the popup menu for
+	Insert mode completion.  When zero as much space as available is used.
+	|ins-completion-menu|.
+
+						*'pumwidth'* *'pw'*
+'pumwidth' 'pw'		number	(default 15)
+			global
+			{not available when compiled without the
+			|+insert_expand| feature}
+			{not in Vi}
+	Determines the minimum width to use for the popup menu for Insert mode
+	completion.  |ins-completion-menu|.
+
+						*'pythondll'*
+'pythondll'		string	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+python/dyn|
+			feature}
+	Specifies the name of the Python 2.x shared library. The default is
+	DYNAMIC_PYTHON_DLL, which was specified at compile time.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'pythonhome'*
+'pythonhome'		string	(default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+python/dyn|
+			feature}
+	Specifies the name of the Python 2.x home directory. When 'pythonhome'
+	and the PYTHONHOME environment variable are not set, PYTHON_HOME,
+	which was specified at compile time, will be used for the Python 2.x
+	home directory.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'pythonthreedll'*
+'pythonthreedll'	string	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+python3/dyn|
+			feature}
+	Specifies the name of the Python 3 shared library. The default is
+	DYNAMIC_PYTHON3_DLL, which was specified at compile time.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'pythonthreehome'*
+'pythonthreehome'	string	(default "")
+			global
+			{not in Vi}
+			{only available when compiled with the |+python3/dyn|
+			feature}
+	Specifies the name of the Python 3 home directory. When
+	'pythonthreehome' and the PYTHONHOME environment variable are not set,
+	PYTHON3_HOME, which was specified at compile time, will be used for
+	the Python 3 home directory.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'pyxversion'* *'pyx'*
+'pyxversion' 'pyx'	number	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+python| or
+			the |+python3| feature}
+	Specifies the python version used for pyx* functions and commands
+	|python_x|.  The default value is as follows:
+
+		Compiled with		     Default ~
+		|+python| and |+python3|	0
+		only |+python|			2
+		only |+python3|			3
+
+	Available values are 0, 2 and 3.
+	If 'pyxversion' is 0, it is set to 2 or 3 after the first execution of
+	any python2/3 commands or functions.  E.g. `:py` sets to 2, and `:py3`
+	sets to 3. `:pyx` sets it to 3 if Python 3 is available, otherwise sets
+	to 2 if Python 2 is available.
+	See also: |has-pythonx|
+
+	If Vim is compiled with only |+python| or |+python3| setting
+	'pyxversion' has no effect.  The pyx* functions and commands are
+	always the same as the compiled version.
+
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'quoteescape'* *'qe'*
+'quoteescape' 'qe'	string	(default "\")
+			local to buffer
+			{not in Vi}
+	The characters that are used to escape quotes in a string.  Used for
+	objects like a', a" and a` |a'|.
+	When one of the characters in this option is found inside a string,
+	the following character will be skipped.  The default value makes the
+	text "foo\"bar\\" considered to be one string.
+
+				   *'readonly'* *'ro'* *'noreadonly'* *'noro'*
+'readonly' 'ro'		boolean	(default off)
+			local to buffer
+	If on, writes fail unless you use a '!'.  Protects you from
+	accidentally overwriting a file.  Default on when Vim is started
+	in read-only mode ("vim -R") or when the executable is called "view".
+	When using ":w!" the 'readonly' option is reset for the current
+	buffer, unless the 'Z' flag is in 'cpoptions'.
+	{not in Vi:}  When using the ":view" command the 'readonly' option is
+	set for the newly edited buffer.
+	See 'modifiable' for disallowing changes to the buffer.
+
+						*'redrawtime'* *'rdt'*
+'redrawtime' 'rdt'	number	(default 2000)
+			global
+			{not in Vi}
+			{only available when compiled with the |+reltime|
+			feature}
+	The time in milliseconds for redrawing the display.  This applies to
+	searching for patterns for 'hlsearch', |:match| highlighting and syntax
+	highlighting.
+	When redrawing takes more than this many milliseconds no further
+	matches will be highlighted.
+	For syntax highlighting the time applies per window.  When over the
+	limit syntax highlighting is disabled until |CTRL-L| is used.
+	This is used to avoid that Vim hangs when using a very complicated
+	pattern.
+
+						*'regexpengine'* *'re'*
+'regexpengine' 're'	number	(default 0)
+			global
+			{not in Vi}
+	This selects the default regexp engine. |two-engines|
+	The possible values are:
+		0	automatic selection
+		1	old engine
+		2	NFA engine
+	Note that when using the NFA engine and the pattern contains something
+	that is not supported the pattern will not match.  This is only useful
+	for debugging the regexp engine.
+	Using automatic selection enables Vim to switch the engine, if the
+	default engine becomes too costly.  E.g., when the NFA engine uses too
+	many states.  This should prevent Vim from hanging on a combination of
+	a complex pattern with long text.
+
+		*'relativenumber'* *'rnu'* *'norelativenumber'* *'nornu'*
+'relativenumber' 'rnu'	boolean	(default off)
+			local to window
+			{not in Vi}
+	Show the line number relative to the line with the cursor in front of
+	each line. Relative line numbers help you use the |count| you can
+	precede some vertical motion commands (e.g. j k + -) with, without
+	having to calculate it yourself. Especially useful in combination with
+	other commands (e.g. y d c < > gq gw =).
+	When the 'n' option is excluded from 'cpoptions' a wrapped
+	line will not use the column of line numbers (this is the default when
+	'compatible' isn't set).
+	The 'numberwidth' option can be used to set the room used for the line
+	number.
+	When a long, wrapped line doesn't start with the first character, '-'
+	characters are put before the number.
+	See |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for
+	the number.
+
+	The number in front of the cursor line also depends on the value of
+	'number', see |number_relativenumber| for all combinations of the two
+	options.
+
+						*'remap'* *'noremap'*
+'remap'			boolean	(default on)
+			global
+	Allows for mappings to work recursively.  If you do not want this for
+	a single entry, use the :noremap[!] command.
+	NOTE: To avoid portability problems with Vim scripts, always keep
+	this option at the default "on".  Only switch it off when working with
+	old Vi scripts.
+
+                                               *'renderoptions'* *'rop'*
+'renderoptions' 'rop'	string  (default: empty)
+			global
+			{not in Vi}
+			{only available when compiled with GUI and DIRECTX on
+			MS-Windows}
+	Select a text renderer and set its options.  The options depend on the
+	renderer.
+
+	Syntax: >
+		set rop=type:{renderer}(,{name}:{value})*
+<
+	Currently, only one optional renderer is available.
+
+	render	behavior    ~
+	directx	Vim will draw text using DirectX (DirectWrite).  It makes
+		drawn glyphs more beautiful than default GDI.
+		It requires 'encoding' is "utf-8", and only works on
+		MS-Windows Vista or newer version.
+
+		Options:
+		  name	    meaning		type	value       ~
+		  gamma	    gamma		float	1.0 - 2.2 (maybe)
+		  contrast  enhancedContrast	float	(unknown)
+		  level	    clearTypeLevel	float	(unknown)
+		  geom	    pixelGeometry	int	0 - 2 (see below)
+		  renmode   renderingMode	int	0 - 6 (see below)
+		  taamode   textAntialiasMode	int	0 - 3 (see below)
+		  scrlines  Scroll Lines	int	(deprecated)
+
+		See this URL for detail (except for scrlines):
+		  https://msdn.microsoft.com/en-us/library/dd368190.aspx
+
+		For geom: structure of a device pixel.
+		  0 - DWRITE_PIXEL_GEOMETRY_FLAT
+		  1 - DWRITE_PIXEL_GEOMETRY_RGB
+		  2 - DWRITE_PIXEL_GEOMETRY_BGR
+
+		See this URL for detail:
+		  https://msdn.microsoft.com/en-us/library/dd368114.aspx
+
+		For renmode: method of rendering glyphs.
+		  0 - DWRITE_RENDERING_MODE_DEFAULT
+		  1 - DWRITE_RENDERING_MODE_ALIASED
+		  2 - DWRITE_RENDERING_MODE_GDI_CLASSIC
+		  3 - DWRITE_RENDERING_MODE_GDI_NATURAL
+		  4 - DWRITE_RENDERING_MODE_NATURAL
+		  5 - DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
+		  6 - DWRITE_RENDERING_MODE_OUTLINE
+
+		See this URL for detail:
+		  https://msdn.microsoft.com/en-us/library/dd368118.aspx
+
+		For taamode: antialiasing mode used for drawing text.
+		  0 - D2D1_TEXT_ANTIALIAS_MODE_DEFAULT
+		  1 - D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE
+		  2 - D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE
+		  3 - D2D1_TEXT_ANTIALIAS_MODE_ALIASED
+
+		See this URL for detail:
+		  https://msdn.microsoft.com/en-us/library/dd368170.aspx
+
+		For scrlines:
+		This was used for optimizing scrolling behavior, however this
+		is now deprecated.  If specified, it is simply ignored.
+
+		Example: >
+		  set encoding=utf-8
+		  set gfn=Ricty_Diminished:h12
+		  set rop=type:directx
+<
+		If select a raster font (Courier, Terminal or FixedSys which
+		have ".fon" extension in file name) to 'guifont', it will be
+		drawn by GDI as a fallback.
+
+		NOTE: It is known that some fonts and options combination
+		causes trouble on drawing glyphs.
+
+		  - 'renmode:5' and 'renmode:6' will not work with some
+		    special made fonts (True-Type fonts which includes only
+		    bitmap glyphs).
+		  - 'taamode:3' will not work with some vector fonts.
+
+		NOTE: With this option, you can display colored emoji
+		(emoticon) in Windows 8.1 or later.  To display colored emoji,
+		there are some conditions which you should notice.
+
+		  - If your font includes non-colored emoji already, it will
+		    be used.
+		  - If your font doesn't have emoji, the system chooses an
+		    alternative symbol font.  On Windows 10, "Segoe UI Emoji"
+		    will be used.
+		  - When this alternative font didn't have fixed width glyph,
+		    emoji might be rendered beyond the bounding box of drawing
+		    cell.
+
+	Other render types are currently not supported.
+
+						*'report'*
+'report'		number	(default 2)
+			global
+	Threshold for reporting number of lines changed.  When the number of
+	changed lines is more than 'report' a message will be given for most
+	":" commands.  If you want it always, set 'report' to 0.
+	For the ":substitute" command the number of substitutions is used
+	instead of the number of lines.
+
+			 *'restorescreen'* *'rs'* *'norestorescreen'* *'nors'*
+'restorescreen' 'rs'	boolean	(default on)
+			global
+			{not in Vi}  {only in Windows 95/NT console version}
+	When set, the screen contents is restored when exiting Vim.  This also
+	happens when executing external commands.
+
+	For non-Windows Vim: You can set or reset the 't_ti' and 't_te'
+	options in your .vimrc.  To disable restoring:
+		set t_ti= t_te=
+	To enable restoring (for an xterm):
+		set t_ti=^[7^[[r^[[?47h t_te=^[[?47l^[8
+	(Where ^[ is an <Esc>, type CTRL-V <Esc> to insert it)
+
+				*'revins'* *'ri'* *'norevins'* *'nori'*
+'revins' 'ri'		boolean	(default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	Inserting characters in Insert mode will work backwards.  See "typing
+	backwards" |ins-reverse|.  This option can be toggled with the CTRL-_
+	command in Insert mode, when 'allowrevins' is set.
+	NOTE: This option is reset when 'compatible' is set.
+	This option is reset when 'paste' is set and restored when 'paste' is
+	reset.
+
+				 *'rightleft'* *'rl'* *'norightleft'* *'norl'*
+'rightleft' 'rl'	boolean	(default off)
+			local to window
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	When on, display orientation becomes right-to-left, i.e., characters
+	that are stored in the file appear from the right to the left.
+	Using this option, it is possible to edit files for languages that
+	are written from the right to the left such as Hebrew and Arabic.
+	This option is per window, so it is possible to edit mixed files
+	simultaneously, or to view the same file in both ways (this is
+	useful whenever you have a mixed text file with both right-to-left
+	and left-to-right strings so that both sets are displayed properly
+	in different windows).  Also see |rileft.txt|.
+
+			*'rightleftcmd'* *'rlc'*
+'rightleftcmd' 'rlc'	string	(default "search")
+			local to window
+			{not in Vi}
+			{only available when compiled with the |+rightleft|
+			feature}
+	Each word in this option enables the command line editing to work in
+	right-to-left mode for a group of commands:
+
+		search		"/" and "?" commands
+
+	This is useful for languages such as Hebrew, Arabic and Farsi.
+	The 'rightleft' option must be set for 'rightleftcmd' to take effect.
+
+						*'rubydll'*
+'rubydll'		string	(default: depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+ruby/dyn|
+			feature}
+	Specifies the name of the Ruby shared library. The default is
+	DYNAMIC_RUBY_DLL, which was specified at compile time.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+					 *'ruler'* *'ru'* *'noruler'* *'noru'*
+'ruler' 'ru'		boolean	(default off, set in |defaults.vim|)
+			global
+			{not in Vi}
+			{not available when compiled without the
+			|+cmdline_info| feature}
+	Show the line and column number of the cursor position, separated by a
+	comma.  When there is room, the relative position of the displayed
+	text in the file is shown on the far right:
+		Top	first line is visible
+		Bot	last line is visible
+		All	first and last line are visible
+		45%	relative position in the file
+	If 'rulerformat' is set, it will determine the contents of the ruler.
+	Each window has its own ruler.  If a window has a status line, the
+	ruler is shown there.  Otherwise it is shown in the last line of the
+	screen.  If the statusline is given by 'statusline' (i.e. not empty),
+	this option takes precedence over 'ruler' and 'rulerformat'
+	If the number of characters displayed is different from the number of
+	bytes in the text (e.g., for a TAB or a multi-byte character), both
+	the text column (byte number) and the screen column are shown,
+	separated with a dash.
+	For an empty line "0-1" is shown.
+	For an empty buffer the line number will also be zero: "0,0-1".
+	This option is reset when 'paste' is set and restored when 'paste' is
+	reset.
+	If you don't want to see the ruler all the time but want to know where
+	you are, use "g CTRL-G" |g_CTRL-G|.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'rulerformat'* *'ruf'*
+'rulerformat' 'ruf'	string	(default empty)
+			global
+			{not in Vi}
+			{not available when compiled without the |+statusline|
+			feature}
+	When this option is not empty, it determines the content of the ruler
+	string, as displayed for the 'ruler' option.
+	The format of this option is like that of 'statusline'.
+	The default ruler width is 17 characters.  To make the ruler 15
+	characters wide, put "%15(" at the start and "%)" at the end.
+	Example: >
+		:set rulerformat=%15(%c%V\ %p%%%)
+<
+				*'runtimepath'* *'rtp'* *vimfiles*
+'runtimepath' 'rtp'	string	(default:
+					Unix: "$HOME/.vim,
+						$VIM/vimfiles,
+						$VIMRUNTIME,
+						$VIM/vimfiles/after,
+						$HOME/.vim/after"
+					Amiga: "home:vimfiles,
+						$VIM/vimfiles,
+						$VIMRUNTIME,
+						$VIM/vimfiles/after,
+						home:vimfiles/after"
+					PC, OS/2: "$HOME/vimfiles,
+						$VIM/vimfiles,
+						$VIMRUNTIME,
+						$VIM/vimfiles/after,
+						$HOME/vimfiles/after"
+					Macintosh: "$VIM:vimfiles,
+						$VIMRUNTIME,
+						$VIM:vimfiles:after"
+					RISC-OS: "Choices:vimfiles,
+						$VIMRUNTIME,
+						Choices:vimfiles/after"
+					VMS: "sys$login:vimfiles,
+						$VIM/vimfiles,
+						$VIMRUNTIME,
+						$VIM/vimfiles/after,
+						sys$login:vimfiles/after")
+			global
+			{not in Vi}
+	This is a list of directories which will be searched for runtime
+	files:
+	  filetype.vim	filetypes by file name |new-filetype|
+	  scripts.vim	filetypes by file contents |new-filetype-scripts|
+	  autoload/	automatically loaded scripts |autoload-functions|
+	  colors/	color scheme files |:colorscheme|
+	  compiler/	compiler files |:compiler|
+	  doc/		documentation |write-local-help|
+	  ftplugin/	filetype plugins |write-filetype-plugin|
+	  indent/	indent scripts |indent-expression|
+	  keymap/	key mapping files |mbyte-keymap|
+	  lang/		menu translations |:menutrans|
+	  menu.vim	GUI menus |menu.vim|
+	  pack/		packages |:packadd|
+	  plugin/	plugin scripts |write-plugin|
+	  print/	files for printing |postscript-print-encoding|
+	  spell/	spell checking files |spell|
+	  syntax/	syntax files |mysyntaxfile|
+	  tutor/	files for vimtutor |tutor|
+
+	And any other file searched for with the |:runtime| command.
+
+	The defaults for most systems are setup to search five locations:
+	1. In your home directory, for your personal preferences.
+	2. In a system-wide Vim directory, for preferences from the system
+	   administrator.
+	3. In $VIMRUNTIME, for files distributed with Vim.
+							*after-directory*
+	4. In the "after" directory in the system-wide Vim directory.  This is
+	   for the system administrator to overrule or add to the distributed
+	   defaults (rarely needed)
+	5. In the "after" directory in your home directory.  This is for
+	   personal preferences to overrule or add to the distributed defaults
+	   or system-wide settings (rarely needed).
+
+	More entries are added when using |packages|.  If it gets very long
+	then `:set rtp` will be truncated, use `:echo &rtp` to see the full
+	string.
+
+	Note that, unlike 'path', no wildcards like "**" are allowed.  Normal
+	wildcards are allowed, but can significantly slow down searching for
+	runtime files.  For speed, use as few items as possible and avoid
+	wildcards.
+	See |:runtime|.
+	Example: >
+		:set runtimepath=~/vimruntime,/mygroup/vim,$VIMRUNTIME
+<	This will use the directory "~/vimruntime" first (containing your
+	personal Vim runtime files), then "/mygroup/vim" (shared between a
+	group of people) and finally "$VIMRUNTIME" (the distributed runtime
+	files).
+	You probably should always include $VIMRUNTIME somewhere, to use the
+	distributed runtime files.  You can put a directory before $VIMRUNTIME
+	to find files which replace a distributed runtime files.  You can put
+	a directory after $VIMRUNTIME to find files which add to distributed
+	runtime files.
+	When Vim is started with |--clean| the home directory entries are not
+	included.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'scroll'* *'scr'*
+'scroll' 'scr'		number	(default: half the window height)
+			local to window
+	Number of lines to scroll with CTRL-U and CTRL-D commands.  Will be
+	set to half the number of lines in the window when the window size
+	changes.  If you give a count to the CTRL-U or CTRL-D command it will
+	be used as the new value for 'scroll'.  Reset to half the window
+	height with ":set scroll=0".   {Vi is a bit different: 'scroll' gives
+	the number of screen lines instead of file lines, makes a difference
+	when lines wrap}
+
+			*'scrollbind'* *'scb'* *'noscrollbind'* *'noscb'*
+'scrollbind' 'scb'	boolean  (default off)
+			local to window
+			{not in Vi}
+	See also |scroll-binding|.  When this option is set, the current
+	window scrolls as other scrollbind windows (windows that also have
+	this option set) scroll.  This option is useful for viewing the
+	differences between two versions of a file, see 'diff'.
+	See |'scrollopt'| for options that determine how this option should be
+	interpreted.
+	This option is mostly reset when splitting a window to edit another
+	file.  This means that ":split | edit file" results in two windows
+	with scroll-binding, but ":split file" does not.
+
+						*'scrolljump'* *'sj'*
+'scrolljump' 'sj'	number	(default 1)
+			global
+			{not in Vi}
+	Minimal number of lines to scroll when the cursor gets off the
+	screen (e.g., with "j").  Not used for scroll commands (e.g., CTRL-E,
+	CTRL-D).  Useful if your terminal scrolls very slowly.
+	When set to a negative number from -1 to -100 this is used as the
+	percentage of the window height.  Thus -50 scrolls half the window
+	height.
+	NOTE: This option is set to 1 when 'compatible' is set.
+
+						*'scrolloff'* *'so'*
+'scrolloff' 'so'	number	(default 0, set to 5 in |defaults.vim|)
+			global
+			{not in Vi}
+	Minimal number of screen lines to keep above and below the cursor.
+	This will make some context visible around where you are working.  If
+	you set it to a very large value (999) the cursor line will always be
+	in the middle of the window (except at the start or end of the file or
+	when long lines wrap).
+	For scrolling horizontally see 'sidescrolloff'.
+	NOTE: This option is set to 0 when 'compatible' is set.
+
+						*'scrollopt'* *'sbo'*
+'scrollopt' 'sbo'	string	(default "ver,jump")
+			global
+			{not in Vi}
+	This is a comma-separated list of words that specifies how
+	'scrollbind' windows should behave.  'sbo' stands for ScrollBind
+	Options.
+	The following words are available:
+	    ver		Bind vertical scrolling for 'scrollbind' windows
+	    hor		Bind horizontal scrolling for 'scrollbind' windows
+	    jump	Applies to the offset between two windows for vertical
+			scrolling.  This offset is the difference in the first
+			displayed line of the bound windows.  When moving
+			around in a window, another 'scrollbind' window may
+			reach a position before the start or after the end of
+			the buffer.  The offset is not changed though, when
+			moving back the 'scrollbind' window will try to scroll
+			to the desired position when possible.
+			When now making that window the current one, two
+			things can be done with the relative offset:
+			1. When "jump" is not included, the relative offset is
+			   adjusted for the scroll position in the new current
+			   window.  When going back to the other window, the
+			   new relative offset will be used.
+			2. When "jump" is included, the other windows are
+			   scrolled to keep the same relative offset.  When
+			   going back to the other window, it still uses the
+			   same relative offset.
+	Also see |scroll-binding|.
+	When 'diff' mode is active there always is vertical scroll binding,
+	even when "ver" isn't there.
+
+						*'sections'* *'sect'*
+'sections' 'sect'	string	(default "SHNHH HUnhsh")
+			global
+	Specifies the nroff macros that separate sections.  These are pairs of
+	two letters (See |object-motions|).  The default makes a section start
+	at the nroff macros ".SH", ".NH", ".H", ".HU", ".nh" and ".sh".
+
+						*'secure'* *'nosecure'* *E523*
+'secure'		boolean	(default off)
+			global
+			{not in Vi}
+	When on, ":autocmd", shell and write commands are not allowed in
+	".vimrc" and ".exrc" in the current directory and map commands are
+	displayed.  Switch it off only if you know that you will not run into
+	problems, or when the 'exrc' option is off.  On Unix this option is
+	only used if the ".vimrc" or ".exrc" is not owned by you.  This can be
+	dangerous if the systems allows users to do a "chown".  You better set
+	'secure' at the end of your ~/.vimrc then.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'selection'* *'sel'*
+'selection' 'sel'	string	(default "inclusive")
+			global
+			{not in Vi}
+	This option defines the behavior of the selection.  It is only used
+	in Visual and Select mode.
+	Possible values:
+	   value	past line     inclusive ~
+	   old		   no		yes
+	   inclusive	   yes		yes
+	   exclusive	   yes		no
+	"past line" means that the cursor is allowed to be positioned one
+	character past the line.
+	"inclusive" means that the last character of the selection is included
+	in an operation.  For example, when "x" is used to delete the
+	selection.
+	When "old" is used and 'virtualedit' allows the cursor to move past
+	the end of line the line break still isn't included.
+	Note that when "exclusive" is used and selecting from the end
+	backwards, you cannot include the last character of a line, when
+	starting in Normal mode and 'virtualedit' empty.
+
+	The 'selection' option is set by the |:behave| command.
+
+						*'selectmode'* *'slm'*
+'selectmode' 'slm'	string	(default "")
+			global
+			{not in Vi}
+	This is a comma separated list of words, which specifies when to start
+	Select mode instead of Visual mode, when a selection is started.
+	Possible values:
+	   mouse	when using the mouse
+	   key		when using shifted special keys
+	   cmd		when using "v", "V" or CTRL-V
+	See |Select-mode|.
+	The 'selectmode' option is set by the |:behave| command.
+
+						*'sessionoptions'* *'ssop'*
+'sessionoptions' 'ssop'	string	(default: "blank,buffers,curdir,folds,
+					 help,options,tabpages,winsize,terminal")
+			global
+			{not in Vi}
+			{not available when compiled without the |+mksession|
+			feature}
+	Changes the effect of the |:mksession| command.  It is a comma
+	separated list of words.  Each word enables saving and restoring
+	something:
+	   word		save and restore ~
+	   blank	empty windows
+	   buffers	hidden and unloaded buffers, not just those in windows
+	   curdir	the current directory
+	   folds	manually created folds, opened/closed folds and local
+			fold options
+	   globals	global variables that start with an uppercase letter
+			and contain at least one lowercase letter.  Only
+			String and Number types are stored.
+	   help		the help window
+	   localoptions	options and mappings local to a window or buffer (not
+			global values for local options)
+	   options	all options and mappings (also global values for local
+			options)
+	   resize	size of the Vim window: 'lines' and 'columns'
+	   sesdir	the directory in which the session file is located
+			will become the current directory (useful with
+			projects accessed over a network from different
+			systems)
+	   slash	backslashes in file names replaced with forward
+			slashes
+	   tabpages	all tab pages; without this only the current tab page
+			is restored, so that you can make a session for each
+			tab page separately
+	   terminal	include terminal windows where the command can be
+			restored
+	   unix		with Unix end-of-line format (single <NL>), even when
+			on Windows or DOS
+	   winpos	position of the whole Vim window
+	   winsize	window sizes
+
+	Don't include both "curdir" and "sesdir".
+	When neither "curdir" nor "sesdir" is included, file names are stored
+	with absolute paths.
+	"slash" and "unix" are useful on Windows when sharing session files
+	with Unix.  The Unix version of Vim cannot source dos format scripts,
+	but the Windows version of Vim can source unix format scripts.
+
+						*'shell'* *'sh'* *E91*
+'shell' 'sh'		string	(default $SHELL or "sh",
+					MS-DOS and Win32: "command.com" or
+					"cmd.exe", OS/2: "cmd")
+			global
+	Name of the shell to use for ! and :! commands.  When changing the
+	value also check these options: 'shelltype', 'shellpipe', 'shellslash'
+	'shellredir', 'shellquote', 'shellxquote' and 'shellcmdflag'.
+	It is allowed to give an argument to the command, e.g.  "csh -f".
+	See |option-backslash| about including spaces and backslashes.
+	Environment variables are expanded |:set_env|.
+
+	If the name of the shell contains a space, you might need to enclose
+	it in quotes or escape the space.  Example with quotes: >
+		:set shell=\"c:\program\ files\unix\sh.exe\"\ -f
+<	Note the backslash before each quote (to avoid starting a comment) and
+	each space (to avoid ending the option value).  Also note that the
+	"-f" is not inside the quotes, because it is not part of the command
+	name.  Vim automagically recognizes the backslashes that are path
+	separators.
+	Example with escaped space (Vim will do this when initializing the
+	option from $SHELL): >
+		:set shell=/bin/with\\\ space/sh
+<	The resulting value of 'shell' is "/bin/with\ space/sh", two
+	backslashes are consumed by `:set`.
+
+	Under MS-Windows, when the executable ends in ".com" it must be
+	included.  Thus setting the shell to "command.com" or "4dos.com"
+	works, but "command" and "4dos" do not work for all commands (e.g.,
+	filtering).
+	For unknown reasons, when using "4dos.com" the current directory is
+	changed to "C:\".  To avoid this set 'shell' like this: >
+		:set shell=command.com\ /c\ 4dos
+<	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'shellcmdflag'* *'shcf'*
+'shellcmdflag' 'shcf'	string	(default: "-c";
+				 MS-DOS and Win32, when 'shell' does not
+				 contain "sh" somewhere: "/c")
+			global
+			{not in Vi}
+	Flag passed to the shell to execute "!" and ":!" commands; e.g.,
+	"bash.exe -c ls" or "command.com /c dir".  For the MS-DOS-like
+	systems, the default is set according to the value of 'shell', to
+	reduce the need to set this option by the user.
+	On Unix it can have more than one flag.  Each white space separated
+	part is passed as an argument to the shell command.
+	See |option-backslash| about including spaces and backslashes.
+	Also see |dos-shell| for MS-DOS and MS-Windows.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'shellpipe'* *'sp'*
+'shellpipe' 'sp'	string	(default ">", "| tee", "|& tee" or "2>&1| tee")
+			global
+			{not in Vi}
+			{not available when compiled without the |+quickfix|
+			feature}
+	String to be used to put the output of the ":make" command in the
+	error file.  See also |:make_makeprg|.  See |option-backslash| about
+	including spaces and backslashes.
+	The name of the temporary file can be represented by "%s" if necessary
+	(the file name is appended automatically if no %s appears in the value
+	of this option).
+	For the Amiga and MS-DOS the default is ">".  The output is directly
+	saved in a file and not echoed to the screen.
+	For Unix the default it "| tee".  The stdout of the compiler is saved
+	in a file and echoed to the screen.  If the 'shell' option is "csh" or
+	"tcsh" after initializations, the default becomes "|& tee".  If the
+	'shell' option is "sh", "ksh", "mksh", "pdksh", "zsh" or "bash" the
+	default becomes "2>&1| tee".  This means that stderr is also included.
+	Before using the 'shell' option a path is removed, thus "/bin/sh" uses
+	"sh".
+	The initialization of this option is done after reading the ".vimrc"
+	and the other initializations, so that when the 'shell' option is set
+	there, the 'shellpipe' option changes automatically, unless it was
+	explicitly set before.
+	When 'shellpipe' is set to an empty string, no redirection of the
+	":make" output will be done.  This is useful if you use a 'makeprg'
+	that writes to 'makeef' by itself.  If you want no piping, but do
+	want to include the 'makeef', set 'shellpipe' to a single space.
+	Don't forget to precede the space with a backslash: ":set sp=\ ".
+	In the future pipes may be used for filtering and this option will
+	become obsolete (at least for Unix).
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'shellquote'* *'shq'*
+'shellquote' 'shq'	string	(default: ""; MS-DOS and Win32, when 'shell'
+					contains "sh" somewhere: "\"")
+			global
+			{not in Vi}
+	Quoting character(s), put around the command passed to the shell, for
+	the "!" and ":!" commands.  The redirection is kept outside of the
+	quoting.  See 'shellxquote' to include the redirection.  It's
+	probably not useful to set both options.
+	This is an empty string by default.  Only known to be useful for
+	third-party shells on MS-DOS-like systems, such as the MKS Korn Shell
+	or bash, where it should be "\"".  The default is adjusted according
+	the value of 'shell', to reduce the need to set this option by the
+	user.  See |dos-shell|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'shellredir'* *'srr'*
+'shellredir' 'srr'	string	(default ">", ">&" or ">%s 2>&1")
+			global
+			{not in Vi}
+	String to be used to put the output of a filter command in a temporary
+	file.  See also |:!|.  See |option-backslash| about including spaces
+	and backslashes.
+	The name of the temporary file can be represented by "%s" if necessary
+	(the file name is appended automatically if no %s appears in the value
+	of this option).
+	The default is ">".  For Unix, if the 'shell' option is "csh", "tcsh"
+	or "zsh" during initializations, the default becomes ">&".  If the
+	'shell' option is "sh", "ksh" or "bash" the default becomes
+	">%s 2>&1".  This means that stderr is also included.
+	For Win32, the Unix checks are done and additionally "cmd" is checked
+	for, which makes the default ">%s 2>&1".  Also, the same names with
+	".exe" appended are checked for.
+	The initialization of this option is done after reading the ".vimrc"
+	and the other initializations, so that when the 'shell' option is set
+	there, the 'shellredir' option changes automatically unless it was
+	explicitly set before.
+	In the future pipes may be used for filtering and this option will
+	become obsolete (at least for Unix).
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+			*'shellslash'* *'ssl'* *'noshellslash'* *'nossl'*
+'shellslash' 'ssl'	boolean	(default off)
+			global
+			{not in Vi} {only for MSDOS, MS-Windows and OS/2}
+	When set, a forward slash is used when expanding file names.  This is
+	useful when a Unix-like shell is used instead of command.com or
+	cmd.exe.  Backward slashes can still be typed, but they are changed to
+	forward slashes by Vim.
+	Note that setting or resetting this option has no effect for some
+	existing file names, thus this option needs to be set before opening
+	any file for best results.  This might change in the future.
+	'shellslash' only works when a backslash can be used as a path
+	separator.  To test if this is so use: >
+		if exists('+shellslash')
+<
+			*'shelltemp'* *'stmp'* *'noshelltemp'* *'nostmp'*
+'shelltemp' 'stmp'	boolean	(Vi default off, Vim default on)
+			global
+			{not in Vi}
+	When on, use temp files for shell commands.  When off use a pipe.
+	When using a pipe is not possible temp files are used anyway.
+	Currently a pipe is only supported on Unix and MS-Windows 2K and
+	later.  You can check it with: >
+		:if has("filterpipe")
+<	The advantage of using a pipe is that nobody can read the temp file
+	and the 'shell' command does not need to support redirection.
+	The advantage of using a temp file is that the file type and encoding
+	can be detected.
+	The |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,
+	|FilterWritePost| autocommands event are not triggered when
+	'shelltemp' is off.
+	The `system()` function does not respect this option and always uses
+	temp files.
+	NOTE: This option is set to the Vim default value when 'compatible'
+	is reset.
+
+						*'shelltype'* *'st'*
+'shelltype' 'st'	number	(default 0)
+			global
+			{not in Vi} {only for the Amiga}
+	On the Amiga this option influences the way how the commands work
+	which use a shell.
+	0 and 1: always use the shell
+	2 and 3: use the shell only to filter lines
+	4 and 5: use shell only for ':sh' command
+	When not using the shell, the command is executed directly.
+
+	0 and 2: use "shell 'shellcmdflag' cmd" to start external commands
+	1 and 3: use "shell cmd" to start external commands
+
+						*'shellxescape'* *'sxe'*
+'shellxescape' 'sxe'	string	(default: "";
+				 for MS-DOS and MS-Windows: "\"&|<>()@^")
+			global
+			{not in Vi}
+	When 'shellxquote' is set to "(" then the characters listed in this
+	option will be escaped with a '^' character.  This makes it possible
+	to execute most external commands with cmd.exe.
+
+						*'shellxquote'* *'sxq'*
+'shellxquote' 'sxq'	string	(default: "";
+					for Win32, when 'shell' is cmd.exe: "("
+					for Win32, when 'shell' contains "sh"
+					somewhere: "\""
+					for Unix, when using system(): "\"")
+			global
+			{not in Vi}
+	Quoting character(s), put around the command passed to the shell, for
+	the "!" and ":!" commands.  Includes the redirection.  See
+	'shellquote' to exclude the redirection.  It's probably not useful
+	to set both options.
+	When the value is '(' then ')' is appended. When the value is '"('
+	then ')"' is appended.
+	When the value is '(' then also see 'shellxescape'.
+	This is an empty string by default on most systems, but is known to be
+	useful for on Win32 version, either for cmd.exe which automatically
+	strips off the first and last quote on a command, or 3rd-party shells
+	such as the MKS Korn Shell or bash, where it should be "\"".  The
+	default is adjusted according the value of 'shell', to reduce the need
+	to set this option by the user.  See |dos-shell|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+			*'shiftround'* *'sr'* *'noshiftround'* *'nosr'*
+'shiftround' 'sr'	boolean	(default off)
+			global
+			{not in Vi}
+	Round indent to multiple of 'shiftwidth'.  Applies to > and <
+	commands.  CTRL-T and CTRL-D in Insert mode always round the indent to
+	a multiple of 'shiftwidth' (this is Vi compatible).
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'shiftwidth'* *'sw'*
+'shiftwidth' 'sw'	number	(default 8)
+			local to buffer
+	Number of spaces to use for each step of (auto)indent.  Used for
+	|'cindent'|, |>>|, |<<|, etc.
+	When zero the 'ts' value will be used.  Use the |shiftwidth()|
+	function to get the effective shiftwidth value.
+
+						*'shortmess'* *'shm'*
+'shortmess' 'shm'	string	(Vim default "filnxtToO", Vi default: "",
+							POSIX default: "A")
+			global
+			{not in Vi}
+	This option helps to avoid all the |hit-enter| prompts caused by file
+	messages, for example  with CTRL-G, and to avoid some other messages.
+	It is a list of flags:
+	 flag	meaning when present	~
+	  f	use "(3 of 5)" instead of "(file 3 of 5)"
+	  i	use "[noeol]" instead of "[Incomplete last line]"
+	  l	use "999L, 888C" instead of "999 lines, 888 characters"
+	  m	use "[+]" instead of "[Modified]"
+	  n	use "[New]" instead of "[New File]"
+	  r	use "[RO]" instead of "[readonly]"
+	  w	use "[w]" instead of "written" for file write message
+		and "[a]" instead of "appended" for ':w >> file' command
+	  x	use "[dos]" instead of "[dos format]", "[unix]" instead of
+		"[unix format]" and "[mac]" instead of "[mac format]".
+	  a	all of the above abbreviations
+
+	  o	overwrite message for writing a file with subsequent message
+		for reading a file (useful for ":wn" or when 'autowrite' on)
+	  O	message for reading a file overwrites any previous message.
+		Also for quickfix message (e.g., ":cn").
+	  s	don't give "search hit BOTTOM, continuing at TOP" or "search
+		hit TOP, continuing at BOTTOM" messages
+	  t	truncate file message at the start if it is too long to fit
+		on the command-line, "<" will appear in the left most column.
+		Ignored in Ex mode.
+	  T	truncate other messages in the middle if they are too long to
+		fit on the command line.  "..." will appear in the middle.
+		Ignored in Ex mode.
+	  W	don't give "written" or "[w]" when writing a file
+	  A	don't give the "ATTENTION" message when an existing swap file
+		is found.
+	  I	don't give the intro message when starting Vim |:intro|.
+	  c	don't give |ins-completion-menu| messages.  For example,
+		"-- XXX completion (YYY)", "match 1 of 2", "The only match",
+		"Pattern not found", "Back at original", etc.
+	  q	use "recording" instead of "recording @a"
+	  F	don't give the file info when editing a file, like `:silent`
+		was used for the command
+
+	This gives you the opportunity to avoid that a change between buffers
+	requires you to hit <Enter>, but still gives as useful a message as
+	possible for the space available.  To get the whole message that you
+	would have got with 'shm' empty, use ":file!"
+	Useful values:
+	    shm=	No abbreviation of message.
+	    shm=a	Abbreviation, but no loss of information.
+	    shm=at	Abbreviation, and truncate message when necessary.
+
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+				 *'shortname'* *'sn'* *'noshortname'* *'nosn'*
+'shortname' 'sn'	boolean	(default off)
+			local to buffer
+			{not in Vi, not in MS-DOS versions}
+	Filenames are assumed to be 8 characters plus one extension of 3
+	characters.  Multiple dots in file names are not allowed.  When this
+	option is on, dots in file names are replaced with underscores when
+	adding an extension (".~" or ".swp").  This option is not available
+	for MS-DOS, because then it would always be on.  This option is useful
+	when editing files on an MS-DOS compatible filesystem, e.g., messydos
+	or crossdos.  When running the Win32 GUI version under Win32s, this
+	option is always on by default.
+
+						*'showbreak'* *'sbr'* *E595*
+'showbreak' 'sbr'	string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	String to put at the start of lines that have been wrapped.  Useful
+	values are "> " or "+++ ": >
+		:set showbreak=>\ 
+<	Note the backslash to escape the trailing space.  It's easier like
+	this: >
+		:let &showbreak = '+++ '
+<	Only printable single-cell characters are allowed, excluding <Tab> and
+	comma (in a future version the comma might be used to separate the
+	part that is shown at the end and at the start of a line).
+	The characters are highlighted according to the '@' flag in
+	'highlight'.
+	Note that tabs after the showbreak will be displayed differently.
+	If you want the 'showbreak' to appear in between line numbers, add the
+	"n" flag to 'cpoptions'.
+
+				     *'showcmd'* *'sc'* *'noshowcmd'* *'nosc'*
+'showcmd' 'sc'		boolean	(Vim default: on, off for Unix,
+				       Vi default: off, set in |defaults.vim|)
+			global
+			{not in Vi}
+			{not available when compiled without the
+			|+cmdline_info| feature}
+	Show (partial) command in the last line of the screen.  Set this
+	option off if your terminal is slow.
+	In Visual mode the size of the selected area is shown:
+	- When selecting characters within a line, the number of characters.
+	  If the number of bytes is different it is also displayed: "2-6"
+	  means two characters and six bytes.
+	- When selecting more than one line, the number of lines.
+	- When selecting a block, the size in screen characters:
+	  {lines}x{columns}.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+			*'showfulltag'* *'sft'* *'noshowfulltag'* *'nosft'*
+'showfulltag' 'sft'	boolean (default off)
+			global
+			{not in Vi}
+	When completing a word in insert mode (see |ins-completion|) from the
+	tags file, show both the tag name and a tidied-up form of the search
+	pattern (if there is one) as possible matches.  Thus, if you have
+	matched a C function, you can see a template for what arguments are
+	required (coding style permitting).
+	Note that this doesn't work well together with having "longest" in
+	'completeopt', because the completion from the search pattern may not
+	match the typed text.
+
+				 *'showmatch'* *'sm'* *'noshowmatch'* *'nosm'*
+'showmatch' 'sm'	boolean	(default off)
+			global
+	When a bracket is inserted, briefly jump to the matching one.  The
+	jump is only done if the match can be seen on the screen.  The time to
+	show the match can be set with 'matchtime'.
+	A Beep is given if there is no match (no matter if the match can be
+	seen or not).
+	This option is reset when 'paste' is set and restored when 'paste' is
+	reset.
+	When the 'm' flag is not included in 'cpoptions', typing a character
+	will immediately move the cursor back to where it belongs.
+	See the "sm" field in 'guicursor' for setting the cursor shape and
+	blinking when showing the match.
+	The 'matchpairs' option can be used to specify the characters to show
+	matches for.  'rightleft' and 'revins' are used to look for opposite
+	matches.
+	Also see the matchparen plugin for highlighting the match when moving
+	around |pi_paren.txt|.
+	Note: Use of the short form is rated PG.
+
+				 *'showmode'* *'smd'* *'noshowmode'* *'nosmd'*
+'showmode' 'smd'	boolean	(Vim default: on, Vi default: off)
+			global
+	If in Insert, Replace or Visual mode put a message on the last line.
+	Use the 'M' flag in 'highlight' to set the type of highlighting for
+	this message.
+	When |XIM| may be used the message will include "XIM".  But this
+	doesn't mean XIM is really active, especially when 'imactivatekey' is
+	not set.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'showtabline'* *'stal'*
+'showtabline' 'stal'	number	(default 1)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	The value of this option specifies when the line with tab page labels
+	will be displayed:
+		0: never
+		1: only if there are at least two tab pages
+		2: always
+	This is both for the GUI and non-GUI implementation of the tab pages
+	line.
+	See |tab-page| for more information about tab pages.
+
+						*'sidescroll'* *'ss'*
+'sidescroll' 'ss'	number	(default 0)
+			global
+			{not in Vi}
+	The minimal number of columns to scroll horizontally.  Used only when
+	the 'wrap' option is off and the cursor is moved off of the screen.
+	When it is zero the cursor will be put in the middle of the screen.
+	When using a slow terminal set it to a large number or 0.  When using
+	a fast terminal use a small number or 1.  Not used for "zh" and "zl"
+	commands.
+
+						*'sidescrolloff'* *'siso'*
+'sidescrolloff' 'siso'	number (default 0)
+			global
+			{not in Vi}
+	The minimal number of screen columns to keep to the left and to the
+	right of the cursor if 'nowrap' is set.  Setting this option to a
+	value greater than 0 while having |'sidescroll'| also at a non-zero
+	value makes some context visible in the line you are scrolling in
+	horizontally (except at beginning of the line).  Setting this option
+	to a large value (like 999) has the effect of keeping the cursor
+	horizontally centered in the window, as long as one does not come too
+	close to the beginning of the line.
+	NOTE: This option is set to 0 when 'compatible' is set.
+
+	Example: Try this together with 'sidescroll' and 'listchars' as
+		 in the following example to never allow the cursor to move
+		 onto the "extends" character: >
+
+		 :set nowrap sidescroll=1 listchars=extends:>,precedes:<
+		 :set sidescrolloff=1
+<
+						*'signcolumn'* *'scl'*
+'signcolumn' 'scl'	string	(default "auto")
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+signs|
+			feature}
+	Whether or not to draw the signcolumn. Valid values are:
+	   "auto"   	only when there is a sign to display
+	   "no"	    	never
+	   "yes"    	always
+
+
+			*'smartcase'* *'scs'* *'nosmartcase'* *'noscs'*
+'smartcase' 'scs'	boolean	(default off)
+			global
+			{not in Vi}
+	Override the 'ignorecase' option if the search pattern contains upper
+	case characters.  Only used when the search pattern is typed and
+	'ignorecase' option is on.  Used for the commands "/", "?", "n", "N",
+	":g" and ":s".  Not used for "*", "#", "gd", tag search, etc.  After
+	"*" and "#" you can make 'smartcase' used by doing a "/" command,
+	recalling the search pattern from history and hitting <Enter>.
+	NOTE: This option is reset when 'compatible' is set.
+
+			     *'smartindent'* *'si'* *'nosmartindent'* *'nosi'*
+'smartindent' 'si'	boolean	(default off)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the
+			|+smartindent| feature}
+	Do smart autoindenting when starting a new line.  Works for C-like
+	programs, but can also be used for other languages.  'cindent' does
+	something like this, works better in most cases, but is more strict,
+	see |C-indenting|.  When 'cindent' is on or 'indentexpr' is set,
+	setting 'si' has no effect.  'indentexpr' is a more advanced
+	alternative.
+	Normally 'autoindent' should also be on when using 'smartindent'.
+	An indent is automatically inserted:
+	- After a line ending in '{'.
+	- After a line starting with a keyword from 'cinwords'.
+	- Before a line starting with '}' (only with the "O" command).
+	When typing '}' as the first character in a new line, that line is
+	given the same indent as the matching '{'.
+	When typing '#' as the first character in a new line, the indent for
+	that line is removed, the '#' is put in the first column.  The indent
+	is restored for the next line.  If you don't want this, use this
+	mapping: ":inoremap # X^H#", where ^H is entered with CTRL-V CTRL-H.
+	When using the ">>" command, lines starting with '#' are not shifted
+	right.
+	NOTE: This option is reset when 'compatible' is set.
+	This option is reset when 'paste' is set and restored when 'paste' is
+	reset.
+
+				 *'smarttab'* *'sta'* *'nosmarttab'* *'nosta'*
+'smarttab' 'sta'	boolean	(default off)
+			global
+			{not in Vi}
+	When on, a <Tab> in front of a line inserts blanks according to
+	'shiftwidth'.  'tabstop' or 'softtabstop' is used in other places.  A
+	<BS> will delete a 'shiftwidth' worth of space at the start of the
+	line.
+	When off, a <Tab> always inserts blanks according to 'tabstop' or
+	'softtabstop'.  'shiftwidth' is only used for shifting text left or
+	right |shift-left-right|.
+	What gets inserted (a <Tab> or spaces) depends on the 'expandtab'
+	option.  Also see |ins-expandtab|.  When 'expandtab' is not set, the
+	number of spaces is minimized by using <Tab>s.
+	This option is reset when 'paste' is set and restored when 'paste' is
+	reset.
+	NOTE: This option is reset when 'compatible' is set.
+
+					*'softtabstop'* *'sts'*
+'softtabstop' 'sts'	number	(default 0)
+			local to buffer
+			{not in Vi}
+	Number of spaces that a <Tab> counts for while performing editing
+	operations, like inserting a <Tab> or using <BS>.  It "feels" like
+	<Tab>s are being inserted, while in fact a mix of spaces and <Tab>s is
+	used.  This is useful to keep the 'ts' setting at its standard value
+	of 8, while being able to edit like it is set to 'sts'.  However,
+	commands like "x" still work on the actual characters.
+	When 'sts' is zero, this feature is off.
+	When 'sts' is negative, the value of 'shiftwidth' is used.
+	'softtabstop' is set to 0 when the 'paste' option is set and restored
+	when 'paste' is reset.
+	See also |ins-expandtab|.  When 'expandtab' is not set, the number of
+	spaces is minimized by using <Tab>s.
+	The 'L' flag in 'cpoptions' changes how tabs are used when 'list' is
+	set.
+	NOTE: This option is set to 0 when 'compatible' is set.
+
+	If Vim is compiled with the |+vartabs| feature then the value of
+	'softtabstop' will be ignored if |'varsofttabstop'| is set to
+	anything other than an empty string.
+
+						*'spell'* *'nospell'*
+'spell'			boolean	(default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	When on spell checking will be done.  See |spell|.
+	The languages are specified with 'spelllang'.
+
+						*'spellcapcheck'* *'spc'*
+'spellcapcheck' 'spc'	string	(default "[.?!]\_[\])'" \t]\+")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	Pattern to locate the end of a sentence.  The following word will be
+	checked to start with a capital letter.  If not then it is highlighted
+	with SpellCap |hl-SpellCap| (unless the word is also badly spelled).
+	When this check is not wanted make this option empty.
+	Only used when 'spell' is set.
+	Be careful with special characters, see |option-backslash| about
+	including spaces and backslashes.
+	To set this option automatically depending on the language, see
+	|set-spc-auto|.
+
+						*'spellfile'* *'spf'*
+'spellfile' 'spf'	string	(default empty)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	Name of the word list file where words are added for the |zg| and |zw|
+	commands.  It must end in ".{encoding}.add".  You need to include the
+	path, otherwise the file is placed in the current directory.
+								*E765*
+	It may also be a comma separated list of names.  A count before the
+	|zg| and |zw| commands can be used to access each.  This allows using
+	a personal word list file and a project word list file.
+	When a word is added while this option is empty Vim will set it for
+	you: Using the first directory in 'runtimepath' that is writable.  If
+	there is no "spell" directory yet it will be created.  For the file
+	name the first language name that appears in 'spelllang' is used,
+	ignoring the region.
+	The resulting ".spl" file will be used for spell checking, it does not
+	have to appear in 'spelllang'.
+	Normally one file is used for all regions, but you can add the region
+	name if you want to.  However, it will then only be used when
+	'spellfile' is set to it, for entries in 'spelllang' only files
+	without region name will be found.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'spelllang'* *'spl'*
+'spelllang' 'spl'	string	(default "en")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	A comma separated list of word list names.  When the 'spell' option is
+	on spellchecking will be done for these languages.  Example: >
+		set spelllang=en_us,nl,medical
+<	This means US English, Dutch and medical words are recognized.  Words
+	that are not recognized will be highlighted.
+	The word list name must not include a comma or dot.  Using a dash is
+	recommended to separate the two letter language name from a
+	specification.  Thus "en-rare" is used for rare English words.
+	A region name must come last and have the form "_xx", where "xx" is
+	the two-letter, lower case region name.  You can use more than one
+	region by listing them: "en_us,en_ca" supports both US and Canadian
+	English, but not words specific for Australia, New Zealand or Great
+	Britain. (Note: currently en_au and en_nz dictionaries are older than
+	en_ca, en_gb and en_us).
+	If the name "cjk" is included East Asian characters are excluded from
+	spell checking.  This is useful when editing text that also has Asian
+	words.
+							*E757*
+	As a special case the name of a .spl file can be given as-is.  The
+	first "_xx" in the name is removed and used as the region name
+	(_xx is an underscore, two letters and followed by a non-letter).
+	This is mainly for testing purposes.  You must make sure the correct
+	encoding is used, Vim doesn't check it.
+	When 'encoding' is set the word lists are reloaded.  Thus it's a good
+	idea to set 'spelllang' after setting 'encoding' to avoid loading the
+	files twice.
+	How the related spell files are found is explained here: |spell-load|.
+
+	If the |spellfile.vim| plugin is active and you use a language name
+	for which Vim cannot find the .spl file in 'runtimepath' the plugin
+	will ask you if you want to download the file.
+
+	After this option has been set successfully, Vim will source the files
+	"spell/LANG.vim" in 'runtimepath'.  "LANG" is the value of 'spelllang'
+	up to the first comma, dot or underscore.
+	Also see |set-spc-auto|.
+
+
+						*'spellsuggest'* *'sps'*
+'spellsuggest' 'sps'	string	(default "best")
+			global
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	Methods used for spelling suggestions.  Both for the |z=| command and
+	the |spellsuggest()| function.  This is a comma-separated list of
+	items:
+
+	best		Internal method that works best for English.  Finds
+			changes like "fast" and uses a bit of sound-a-like
+			scoring to improve the ordering.
+
+	double		Internal method that uses two methods and mixes the
+			results.  The first method is "fast", the other method
+			computes how much the suggestion sounds like the bad
+			word.  That only works when the language specifies
+			sound folding.  Can be slow and doesn't always give
+			better results.
+
+	fast		Internal method that only checks for simple changes:
+			character inserts/deletes/swaps.  Works well for
+			simple typing mistakes.
+
+	{number}	The maximum number of suggestions listed for |z=|.
+			Not used for |spellsuggest()|.  The number of
+			suggestions is never more than the value of 'lines'
+			minus two.
+
+	file:{filename} Read file {filename}, which must have two columns,
+			separated by a slash.  The first column contains the
+			bad word, the second column the suggested good word.
+			Example:
+				theribal/terrible ~
+			Use this for common mistakes that do not appear at the
+			top of the suggestion list with the internal methods.
+			Lines without a slash are ignored, use this for
+			comments.
+			The word in the second column must be correct,
+			otherwise it will not be used.  Add the word to an
+			".add" file if it is currently flagged as a spelling
+			mistake.
+			The file is used for all languages.
+
+	expr:{expr}	Evaluate expression {expr}.  Use a function to avoid
+			trouble with spaces.  |v:val| holds the badly spelled
+			word.  The expression must evaluate to a List of
+			Lists, each with a suggestion and a score.
+			Example:
+				[['the', 33], ['that', 44]] ~
+			Set 'verbose' and use |z=| to see the scores that the
+			internal methods use.  A lower score is better.
+			This may invoke |spellsuggest()| if you temporarily
+			set 'spellsuggest' to exclude the "expr:" part.
+			Errors are silently ignored, unless you set the
+			'verbose' option to a non-zero value.
+
+	Only one of "best", "double" or "fast" may be used.  The others may
+	appear several times in any order.  Example: >
+		:set sps=file:~/.vim/sugg,best,expr:MySuggest()
+<
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+
+			*'splitbelow'* *'sb'* *'nosplitbelow'* *'nosb'*
+'splitbelow' 'sb'	boolean	(default off)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	When on, splitting a window will put the new window below the current
+	one. |:split|
+
+			*'splitright'* *'spr'* *'nosplitright'* *'nospr'*
+'splitright' 'spr'	boolean	(default off)
+			global
+			{not in Vi}
+			{not available when compiled without the |+vertsplit|
+			feature}
+	When on, splitting a window will put the new window right of the
+	current one. |:vsplit|
+
+			   *'startofline'* *'sol'* *'nostartofline'* *'nosol'*
+'startofline' 'sol'	boolean	(default on)
+			global
+			{not in Vi}
+	When "on" the commands listed below move the cursor to the first
+	non-blank of the line.  When off the cursor is kept in the same column
+	(if possible).  This applies to the commands: CTRL-D, CTRL-U, CTRL-B,
+	CTRL-F, "G", "H", "M", "L", gg, and to the commands "d", "<<" and ">>"
+	with a linewise operator, with "%" with a count and to buffer changing
+	commands (CTRL-^, :bnext, :bNext, etc.).  Also for an Ex command that
+	only has a line number, e.g., ":25" or ":+".
+	In case of buffer changing commands the cursor is placed at the column
+	where it was the last time the buffer was edited.
+	NOTE: This option is set when 'compatible' is set.
+
+			   *'statusline'* *'stl'* *E540* *E542*
+'statusline' 'stl'	string	(default empty)
+			global or local to window |global-local|
+			{not in Vi}
+			{not available when compiled without the |+statusline|
+			feature}
+	When nonempty, this option determines the content of the status line.
+	Also see |status-line|.
+
+	The option consists of printf style '%' items interspersed with
+	normal text.  Each status line item is of the form:
+	  %-0{minwid}.{maxwid}{item}
+	All fields except the {item} are optional.  A single percent sign can
+	be given as "%%".  Up to 80 items can be specified.  *E541*
+
+	When the option starts with "%!" then it is used as an expression,
+	evaluated and the result is used as the option value.  Example: >
+		:set statusline=%!MyStatusLine()
+<	The result can contain %{} items that will be evaluated too.
+	Note that the "%!" expression is evaluated in the context of the
+	current window and buffer, while %{} items are evaluated in the
+	context of the window that the statusline belongs to.
+
+	When there is error while evaluating the option then it will be made
+	empty to avoid further errors.  Otherwise screen updating would loop.
+
+	Note that the only effect of 'ruler' when this option is set (and
+	'laststatus' is 2) is controlling the output of |CTRL-G|.
+
+	field	    meaning ~
+	-	    Left justify the item.  The default is right justified
+		    when minwid is larger than the length of the item.
+	0	    Leading zeroes in numeric items.  Overridden by '-'.
+	minwid	    Minimum width of the item, padding as set by '-' & '0'.
+		    Value must be 50 or less.
+	maxwid	    Maximum width of the item.  Truncation occurs with a '<'
+		    on the left for text items.  Numeric items will be
+		    shifted down to maxwid-2 digits followed by '>'number
+		    where number is the amount of missing digits, much like
+		    an exponential notation.
+	item	    A one letter code as described below.
+
+	Following is a description of the possible statusline items.  The
+	second character in "item" is the type:
+		N for number
+		S for string
+		F for flags as described below
+		- not applicable
+
+	item  meaning ~
+	f S   Path to the file in the buffer, as typed or relative to current
+	      directory.
+	F S   Full path to the file in the buffer.
+	t S   File name (tail) of file in the buffer.
+	m F   Modified flag, text is "[+]"; "[-]" if 'modifiable' is off.
+	M F   Modified flag, text is ",+" or ",-".
+	r F   Readonly flag, text is "[RO]".
+	R F   Readonly flag, text is ",RO".
+	h F   Help buffer flag, text is "[help]".
+	H F   Help buffer flag, text is ",HLP".
+	w F   Preview window flag, text is "[Preview]".
+	W F   Preview window flag, text is ",PRV".
+	y F   Type of file in the buffer, e.g., "[vim]".  See 'filetype'.
+	Y F   Type of file in the buffer, e.g., ",VIM".  See 'filetype'.
+	q S   "[Quickfix List]", "[Location List]" or empty.
+	k S   Value of "b:keymap_name" or 'keymap' when |:lmap| mappings are
+	      being used: "<keymap>"
+	n N   Buffer number.
+	b N   Value of character under cursor.
+	B N   As above, in hexadecimal.
+	o N   Byte number in file of byte under cursor, first byte is 1.
+	      Mnemonic: Offset from start of file (with one added)
+	      {not available when compiled without |+byte_offset| feature}
+	O N   As above, in hexadecimal.
+	N N   Printer page number.  (Only works in the 'printheader' option.)
+	l N   Line number.
+	L N   Number of lines in buffer.
+	c N   Column number.
+	v N   Virtual column number.
+	V N   Virtual column number as -{num}.  Not displayed if equal to 'c'.
+	p N   Percentage through file in lines as in |CTRL-G|.
+	P S   Percentage through file of displayed window.  This is like the
+	      percentage described for 'ruler'.  Always 3 in length, unless
+	      translated.
+	a S   Argument list status as in default title.  ({current} of {max})
+	      Empty if the argument file count is zero or one.
+	{ NF  Evaluate expression between '%{' and '}' and substitute result.
+	      Note that there is no '%' before the closing '}'.  The
+	      expression cannot contain a '}' character, call a function to
+	      work around that.
+	( -   Start of item group.  Can be used for setting the width and
+	      alignment of a section.  Must be followed by %) somewhere.
+	) -   End of item group.  No width fields allowed.
+	T N   For 'tabline': start of tab page N label.  Use %T after the last
+	      label.  This information is used for mouse clicks.
+	X N   For 'tabline': start of close tab N label.  Use %X after the
+	      label, e.g.: %3Xclose%X.  Use %999X for a "close current tab"
+	      mark.  This information is used for mouse clicks.
+	< -   Where to truncate line if too long.  Default is at the start.
+	      No width fields allowed.
+	= -   Separation point between left and right aligned items.
+	      No width fields allowed.
+	# -   Set highlight group.  The name must follow and then a # again.
+	      Thus use %#HLname# for highlight group HLname.  The same
+	      highlighting is used, also for the statusline of non-current
+	      windows.
+	* -   Set highlight group to User{N}, where {N} is taken from the
+	      minwid field, e.g. %1*.  Restore normal highlight with %* or %0*.
+	      The difference between User{N} and StatusLine  will be applied
+	      to StatusLineNC for the statusline of non-current windows.
+	      The number N must be between 1 and 9.  See |hl-User1..9|
+
+	When displaying a flag, Vim removes the leading comma, if any, when
+	that flag comes right after plaintext.  This will make a nice display
+	when flags are used like in the examples below.
+
+	When all items in a group becomes an empty string (i.e. flags that are
+	not set) and a minwid is not set for the group, the whole group will
+	become empty.  This will make a group like the following disappear
+	completely from the statusline when none of the flags are set. >
+		:set statusline=...%(\ [%M%R%H]%)...
+<							*g:actual_curbuf*
+	Beware that an expression is evaluated each and every time the status
+	line is displayed.  The current buffer and current window will be set
+	temporarily to that of the window (and buffer) whose statusline is
+	currently being drawn.  The expression will evaluate in this context.
+	The variable "g:actual_curbuf" is set to the `bufnr()` number of the
+	real current buffer.
+
+	The 'statusline' option will be evaluated in the |sandbox| if set from
+	a modeline, see |sandbox-option|.
+
+	It is not allowed to change text or jump to another window while
+	evaluating 'statusline' |textlock|.
+
+	If the statusline is not updated when you want it (e.g., after setting
+	a variable that's used in an expression), you can force an update by
+	setting an option without changing its value.  Example: >
+		:let &ro = &ro
+
+<	A result of all digits is regarded a number for display purposes.
+	Otherwise the result is taken as flag text and applied to the rules
+	described above.
+
+	Watch out for errors in expressions.  They may render Vim unusable!
+	If you are stuck, hold down ':' or 'Q' to get a prompt, then quit and
+	edit your .vimrc or whatever with "vim --clean" to get it right.
+
+	Examples:
+	Emulate standard status line with 'ruler' set >
+	  :set statusline=%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
+<	Similar, but add ASCII value of char under the cursor (like "ga") >
+	  :set statusline=%<%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P
+<	Display byte count and byte value, modified flag in red. >
+	  :set statusline=%<%f%=\ [%1*%M%*%n%R%H]\ %-19(%3l,%02c%03V%)%O'%02b'
+	  :hi User1 term=inverse,bold cterm=inverse,bold ctermfg=red
+<	Display a ,GZ flag if a compressed file is loaded >
+	  :set statusline=...%r%{VarExists('b:gzflag','\ [GZ]')}%h...
+<	In the |:autocmd|'s: >
+	  :let b:gzflag = 1
+<	And: >
+	  :unlet b:gzflag
+<	And define this function: >
+	  :function VarExists(var, val)
+	  :    if exists(a:var) | return a:val | else | return '' | endif
+	  :endfunction
+<
+						*'suffixes'* *'su'*
+'suffixes' 'su'		string	(default ".bak,~,.o,.h,.info,.swp,.obj")
+			global
+			{not in Vi}
+	Files with these suffixes get a lower priority when multiple files
+	match a wildcard.  See |suffixes|.  Commas can be used to separate the
+	suffixes.  Spaces after the comma are ignored.  A dot is also seen as
+	the start of a suffix.  To avoid a dot or comma being recognized as a
+	separator, precede it with a backslash (see |option-backslash| about
+	including spaces and backslashes).
+	See 'wildignore' for completely ignoring files.
+	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	suffixes from the list.  This avoids problems when a future version
+	uses another default.
+
+						*'suffixesadd'* *'sua'*
+'suffixesadd' 'sua'	string	(default "")
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the
+			|+file_in_path| feature}
+	Comma separated list of suffixes, which are used when searching for a
+	file for the "gf", "[I", etc. commands.  Example: >
+		:set suffixesadd=.java
+<
+				*'swapfile'* *'swf'* *'noswapfile'* *'noswf'*
+'swapfile' 'swf'	boolean (default on)
+			local to buffer
+			{not in Vi}
+	Use a swapfile for the buffer.  This option can be reset when a
+	swapfile is not wanted for a specific buffer.  For example, with
+	confidential information that even root must not be able to access.
+	Careful: All text will be in memory:
+		- Don't use this for big files.
+		- Recovery will be impossible!
+	A swapfile will only be present when |'updatecount'| is non-zero and
+	'swapfile' is set.
+	When 'swapfile' is reset, the swap file for the current buffer is
+	immediately deleted.  When 'swapfile' is set, and 'updatecount' is
+	non-zero, a swap file is immediately created.
+	Also see |swap-file| and |'swapsync'|.
+	If you want to open a new buffer without creating a swap file for it,
+	use the |:noswapfile| modifier.
+	See 'directory' for where the swap file is created.
+
+	This option is used together with 'bufhidden' and 'buftype' to
+	specify special kinds of buffers.   See |special-buffers|.
+
+						*'swapsync'* *'sws'*
+'swapsync' 'sws'	string	(default "fsync")
+			global
+			{not in Vi}
+	When this option is not empty a swap file is synced to disk after
+	writing to it.  This takes some time, especially on busy unix systems.
+	When this option is empty parts of the swap file may be in memory and
+	not written to disk.  When the system crashes you may lose more work.
+	On Unix the system does a sync now and then without Vim asking for it,
+	so the disadvantage of setting this option off is small.  On some
+	systems the swap file will not be written at all.  For a unix system
+	setting it to "sync" will use the sync() call instead of the default
+	fsync(), which may work better on some systems.
+	The 'fsync' option is used for the actual file.
+
+						*'switchbuf'* *'swb'*
+'switchbuf' 'swb'	string	(default "")
+			global
+			{not in Vi}
+	This option controls the behavior when switching between buffers.
+	Possible values (comma separated list):
+	   useopen	If included, jump to the first open window that
+			contains the specified buffer (if there is one).
+			Otherwise: Do not examine other windows.
+			This setting is checked with |quickfix| commands, when
+			jumping to errors (":cc", ":cn", "cp", etc.).  It is
+			also used in all buffer related split commands, for
+			example ":sbuffer", ":sbnext", or ":sbrewind".
+	   usetab	Like "useopen", but also consider windows in other tab
+			pages.
+	   split	If included, split the current window before loading
+			a buffer for a |quickfix| command that display errors.
+			Otherwise: do not split, use current window.
+	   vsplit	Just like "split" but split vertically.
+	   newtab	Like "split", but open a new tab page.  Overrules
+			"split" when both are present.
+
+						*'synmaxcol'* *'smc'*
+'synmaxcol' 'smc'	number	(default 3000)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	Maximum column in which to search for syntax items.  In long lines the
+	text after this column is not highlighted and following lines may not
+	be highlighted correctly, because the syntax state is cleared.
+	This helps to avoid very slow redrawing for an XML file that is one
+	long line.
+	Set to zero to remove the limit.
+
+						*'syntax'* *'syn'*
+'syntax' 'syn'		string	(default empty)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the |+syntax|
+			feature}
+	When this option is set, the syntax with this name is loaded, unless
+	syntax highlighting has been switched off with ":syntax off".
+	Otherwise this option does not always reflect the current syntax (the
+	b:current_syntax variable does).
+	This option is most useful in a modeline, for a file which syntax is
+	not automatically recognized.  Example, in an IDL file:
+		/* vim: set syntax=idl : */ ~
+	When a dot appears in the value then this separates two filetype
+	names.  Example:
+		/* vim: set syntax=c.doxygen : */ ~
+	This will use the "c" syntax first, then the "doxygen" syntax.
+	Note that the second one must be prepared to be loaded as an addition,
+	otherwise it will be skipped.  More than one dot may appear.
+	To switch off syntax highlighting for the current file, use: >
+		:set syntax=OFF
+<	To switch syntax highlighting on according to the current value of the
+	'filetype' option: >
+		:set syntax=ON
+<	What actually happens when setting the 'syntax' option is that the
+	Syntax autocommand event is triggered with the value as argument.
+	This option is not copied to another buffer, independent of the 's' or
+	'S' flag in 'cpoptions'.
+	Only normal file name characters can be used, "/\*?[|<>" are illegal.
+
+						*'tabline'* *'tal'*
+'tabline' 'tal'		string	(default empty)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	When nonempty, this option determines the content of the tab pages
+	line at the top of the Vim window.  When empty Vim will use a default
+	tab pages line.  See |setting-tabline| for more info.
+
+	The tab pages line only appears as specified with the 'showtabline'
+	option and only when there is no GUI tab line.  When 'e' is in
+	'guioptions' and the GUI supports a tab line 'guitablabel' is used
+	instead.  Note that the two tab pages lines are very different.
+
+	The value is evaluated like with 'statusline'.  You can use
+	|tabpagenr()|, |tabpagewinnr()| and |tabpagebuflist()| to figure out
+	the text to be displayed.  Use "%1T" for the first label, "%2T" for
+	the second one, etc.  Use "%X" items for closing labels.
+
+	Keep in mind that only one of the tab pages is the current one, others
+	are invisible and you can't jump to their windows.
+
+
+						*'tabpagemax'* *'tpm'*
+'tabpagemax' 'tpm'	number	(default 10)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	Maximum number of tab pages to be opened by the |-p| command line
+	argument or the ":tab all" command. |tabpage|
+
+
+						*'tabstop'* *'ts'*
+'tabstop' 'ts'		number	(default 8)
+			local to buffer
+	Number of spaces that a <Tab> in the file counts for.  Also see
+	|:retab| command, and 'softtabstop' option.
+
+	Note: Setting 'tabstop' to any other value than 8 can make your file
+	appear wrong in many places (e.g., when printing it).
+
+	There are four main ways to use tabs in Vim:
+	1. Always keep 'tabstop' at 8, set 'softtabstop' and 'shiftwidth' to 4
+	   (or 3 or whatever you prefer) and use 'noexpandtab'.  Then Vim
+	   will use a mix of tabs and spaces, but typing <Tab> and <BS> will
+	   behave like a tab appears every 4 (or 3) characters.
+	2. Set 'tabstop' and 'shiftwidth' to whatever you prefer and use
+	   'expandtab'.  This way you will always insert spaces.  The
+	   formatting will never be messed up when 'tabstop' is changed.
+	3. Set 'tabstop' and 'shiftwidth' to whatever you prefer and use a
+	   |modeline| to set these values when editing the file again.  Only
+	   works when using Vim to edit the file.
+	4. Always set 'tabstop' and 'shiftwidth' to the same value, and
+	   'noexpandtab'.  This should then work (for initial indents only)
+	   for any tabstop setting that people use.  It might be nice to have
+	   tabs after the first non-blank inserted as spaces if you do this
+	   though.  Otherwise aligned comments will be wrong when 'tabstop' is
+	   changed.
+
+	If Vim is compiled with the |+vartabs| feature then the value of
+	'tabstop' will be ignored if |'vartabstop'| is set to anything other
+	than an empty string.
+
+			*'tagbsearch'* *'tbs'* *'notagbsearch'* *'notbs'*
+'tagbsearch' 'tbs'	boolean	(default on)
+			global
+			{not in Vi}
+	When searching for a tag (e.g., for the |:ta| command), Vim can either
+	use a binary search or a linear search in a tags file.  Binary
+	searching makes searching for a tag a LOT faster, but a linear search
+	will find more tags if the tags file wasn't properly sorted.
+	Vim normally assumes that your tags files are sorted, or indicate that
+	they are not sorted.  Only when this is not the case does the
+	'tagbsearch' option need to be switched off.
+
+	When 'tagbsearch' is on, binary searching is first used in the tags
+	files.  In certain situations, Vim will do a linear search instead for
+	certain files, or retry all files with a linear search.  When
+	'tagbsearch' is off, only a linear search is done.
+
+	Linear searching is done anyway, for one file, when Vim finds a line
+	at the start of the file indicating that it's not sorted: >
+   !_TAG_FILE_SORTED	0	/some comment/
+<	[The whitespace before and after the '0' must be a single <Tab>]
+
+	When a binary search was done and no match was found in any of the
+	files listed in 'tags', and case is ignored or a pattern is used
+	instead of a normal tag name, a retry is done with a linear search.
+	Tags in unsorted tags files, and matches with different case will only
+	be found in the retry.
+
+	If a tag file indicates that it is case-fold sorted, the second,
+	linear search can be avoided when case is ignored.  Use a value of '2'
+	in the "!_TAG_FILE_SORTED" line for this.  A tag file can be case-fold
+	sorted with the -f switch to "sort" in most unices, as in the command:
+	"sort -f -o tags tags".  For "Exuberant ctags" version 5.x or higher
+	(at least 5.5) the --sort=foldcase switch can be used for this as
+	well.  Note that case must be folded to uppercase for this to work.
+
+	By default, tag searches are case-sensitive.  Case is ignored when
+	'ignorecase' is set and 'tagcase' is "followic", or when 'tagcase' is
+	"ignore".
+	Also when 'tagcase' is "followscs" and 'smartcase' is set, or
+	'tagcase' is "smart", and the pattern contains only lowercase
+	characters.
+
+	When 'tagbsearch' is off, tags searching is slower when a full match
+	exists, but faster when no full match exists.  Tags in unsorted tags
+	files may only be found with 'tagbsearch' off.
+	When the tags file is not sorted, or sorted in a wrong way (not on
+	ASCII byte value), 'tagbsearch' should be off, or the line given above
+	must be included in the tags file.
+	This option doesn't affect commands that find all matching tags (e.g.,
+	command-line completion and ":help").
+	{Vi: always uses binary search in some versions}
+
+							*'tagcase'* *'tc'*
+'tagcase' 'tc'		string	(default "followic")
+			global or local to buffer |global-local|
+			{not in Vi}
+	This option specifies how case is handled when searching the tags
+	file:
+	   followic	Follow the 'ignorecase' option
+	   followscs    Follow the 'smartcase' and 'ignorecase' options
+	   ignore	Ignore case
+	   match	Match case
+	   smart	Ignore case unless an upper case letter is used
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'taglength'* *'tl'*
+'taglength' 'tl'	number	(default 0)
+			global
+	If non-zero, tags are significant up to this number of characters.
+
+			*'tagrelative'* *'tr'* *'notagrelative'* *'notr'*
+'tagrelative' 'tr'	boolean	(Vim default: on, Vi default: off)
+			global
+			{not in Vi}
+	If on and using a tags file in another directory, file names in that
+	tags file are relative to the directory where the tags file is.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'tags'* *'tag'* *E433*
+'tags' 'tag'		string	(default "./tags,tags", when compiled with
+				|+emacs_tags|: "./tags,./TAGS,tags,TAGS")
+			global or local to buffer |global-local|
+	Filenames for the tag command, separated by spaces or commas.  To
+	include a space or comma in a file name, precede it with a backslash
+	(see |option-backslash| about including spaces and backslashes).
+	When a file name starts with "./", the '.' is replaced with the path
+	of the current file.  But only when the 'd' flag is not included in
+	'cpoptions'.  Environment variables are expanded |:set_env|.  Also see
+	|tags-option|.
+	"*", "**" and other wildcards can be used to search for tags files in
+	a directory tree.  See |file-searching|.  E.g., "/lib/**/tags" will
+	find all files named "tags" below "/lib".  The filename itself cannot
+	contain wildcards, it is used as-is.  E.g., "/lib/**/tags?" will find
+	files called "tags?".  {not available when compiled without the
+	|+path_extra| feature}
+	The |tagfiles()| function can be used to get a list of the file names
+	actually used.
+	If Vim was compiled with the |+emacs_tags| feature, Emacs-style tag
+	files are also supported.  They are automatically recognized.  The
+	default value becomes "./tags,./TAGS,tags,TAGS", unless case
+	differences are ignored (MS-Windows).  |emacs-tags|
+	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	file names from the list.  This avoids problems when a future version
+	uses another default.
+	{Vi: default is "tags /usr/lib/tags"}
+
+				*'tagstack'* *'tgst'* *'notagstack'* *'notgst'*
+'tagstack' 'tgst'	boolean	(default on)
+			global
+			{not in all versions of Vi}
+	When on, the |tagstack| is used normally.  When off, a ":tag" or
+	":tselect" command with an argument will not push the tag onto the
+	tagstack.  A following ":tag" without an argument, a ":pop" command or
+	any other command that uses the tagstack will use the unmodified
+	tagstack, but does change the pointer to the active entry.
+	Resetting this option is useful when using a ":tag" command in a
+	mapping which should not change the tagstack.
+
+						*'tcldll'*
+'tcldll'		string	(default depends on the build)
+			global
+			{not in Vi}
+			{only available when compiled with the |+tcl/dyn|
+			feature}
+	Specifies the name of the Tcl shared library. The default is
+	DYNAMIC_TCL_DLL, which was specified at compile time.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'term'* *E529* *E530* *E531*
+'term'			string	(default is $TERM, if that fails:
+				      in the GUI: "builtin_gui"
+					on Amiga: "amiga"
+					 on BeOS: "beos-ansi"
+					  on Mac: "mac-ansi"
+					 on MiNT: "vt52"
+				       on MS-DOS: "pcterm"
+					 on OS/2: "os2ansi"
+					 on Unix: "ansi"
+					  on VMS: "ansi"
+				       on Win 32: "win32")
+			global
+	Name of the terminal.  Used for choosing the terminal control
+	characters.  Environment variables are expanded |:set_env|.
+	For example: >
+		:set term=$TERM
+<	See |termcap|.
+
+						*'termbidi'* *'tbidi'*
+						*'notermbidi'* *'notbidi'*
+'termbidi' 'tbidi'	boolean (default off, on for "mlterm")
+			global
+			{not in Vi}
+			{only available when compiled with the |+arabic|
+			feature}
+	The terminal is in charge of Bi-directionality of text (as specified
+	by Unicode).  The terminal is also expected to do the required shaping
+	that some languages (such as Arabic) require.
+	Setting this option implies that 'rightleft' will not be set when
+	'arabic' is set and the value of 'arabicshape' will be ignored.
+	Note that setting 'termbidi' has the immediate effect that
+	'arabicshape' is ignored, but 'rightleft' isn't changed automatically.
+	This option is reset when the GUI is started.
+	For further details see |arabic.txt|.
+
+					*'termencoding'* *'tenc'*
+'termencoding' 'tenc'	string	(default ""; with GTK+ GUI: "utf-8"; with
+						    Macintosh GUI: "macroman")
+			global
+			{only available when compiled with the |+multi_byte|
+			feature}
+			{not in Vi}
+	Encoding used for the terminal.  This specifies what character
+	encoding the keyboard produces and the display will understand.  For
+	the GUI it only applies to the keyboard ('encoding' is used for the
+	display).  Except for the Mac when 'macatsui' is off, then
+	'termencoding' should be "macroman".
+								*E617*
+	Note: This does not apply to the GTK+ GUI.  After the GUI has been
+	successfully initialized, 'termencoding' is forcibly set to "utf-8".
+	Any attempts to set a different value will be rejected, and an error
+	message is shown.
+	For the Win32 GUI and console versions 'termencoding' is not used,
+	because the Win32 system always passes Unicode characters.
+	When empty, the same encoding is used as for the 'encoding' option.
+	This is the normal value.
+	Not all combinations for 'termencoding' and 'encoding' are valid.  See
+	|encoding-table|.
+	The value for this option must be supported by internal conversions or
+	iconv().  When this is not possible no conversion will be done and you
+	will probably experience problems with non-ASCII characters.
+	Example: You are working with the locale set to euc-jp (Japanese) and
+	want to edit a UTF-8 file: >
+		:let &termencoding = &encoding
+		:set encoding=utf-8
+<	You need to do this when your system has no locale support for UTF-8.
+
+					*'termguicolors'* *'tgc'* *E954*
+'termguicolors' 'tgc'	boolean (default off)
+			global
+			{not in Vi}
+			{not available when compiled without the
+			|+termguicolors| feature}
+	When on, uses |highlight-guifg| and |highlight-guibg| attributes in
+	the terminal (thus using 24-bit color).
+
+	Requires a ISO-8613-3 compatible terminal.  If setting this option
+	does not work (produces a colorless UI) reading |xterm-true-color|
+	might help.
+
+	For Win32 console, Windows 10 version 1703 (Creators Update) or later
+	is required. Use this check to find out: >
+		if has('vcon')
+<	This requires Vim to be built with the |+vtp| feature.
+
+	Note that the "cterm" attributes are still used, not the "gui" ones.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'termwinscroll'* *'twsl'*
+'termwinscroll' 'twsl'	number	(default 10000)
+			local to buffer
+			{not in Vi}
+			{not available when compiled without the
+			|+terminal| feature}
+	Number of scrollback lines to keep.  When going over this limit the
+	first 10% of the scrollback lines are deleted.  This is just to reduce
+	the memory usage.  See |Terminal-Normal|.
+
+						*'termwinkey'* *'twk'*
+'termwinkey' 'twk'	string	(default "")
+			local to window
+			{not in Vi}
+	The key that starts a CTRL-W command in a terminal window.  Other keys
+	are sent to the job running in the window.
+	The <> notation can be used, e.g.: >
+		:set termwinkey=<C-L>
+<	The string must be one key stroke but can be multiple bytes.
+	When not set CTRL-W is used, so that CTRL-W : gets you to the command
+	line.  If 'termwinkey' is set to CTRL-L then CTRL-L : gets you to the
+	command line.
+
+						*'termwinsize'* *'tws'*
+'termwinsize' 'tws'	string	(default "")
+			local to window
+			{not in Vi}
+	Size of the |terminal| window.  Format: {rows}x{columns} or
+	{rows}*{columns}.
+	- When empty the terminal gets the size from the window.
+	- When set with a "x" (e.g., "24x80") the terminal size is not
+	  adjusted to the window size.  If the window is smaller only the
+	  top-left part is displayed.
+	- When set with a "*" (e.g., "10*50") the terminal size follows the
+	  window size, but will not be smaller than the specified rows and/or
+	  columns.
+	- When rows is zero then use the height of the window.
+	- When columns is zero then use the width of the window.
+	- Using "0x0" or "0*0" is the same as empty.
+
+	Examples:
+	  "30x0" uses 30 rows and the current window width.
+	  "20*0" uses at least 20 rows and the current window width.
+	  "0*40" uses the current window height and at least 40 columns.
+	Note that the command running in the terminal window may still change
+	the size of the terminal.  In that case the Vim window will be
+	adjusted to that size, if possible.
+
+						*'terse'* *'noterse'*
+'terse'			boolean	(default off)
+			global
+	When set: Add 's' flag to 'shortmess' option (this makes the message
+	for a search that hits the start or end of the file not being
+	displayed).  When reset: Remove 's' flag from 'shortmess' option.  {Vi
+	shortens a lot of messages}
+
+				   *'textauto'* *'ta'* *'notextauto'* *'nota'*
+'textauto' 'ta'		boolean	(Vim default: on, Vi default: off)
+			global
+			{not in Vi}
+	This option is obsolete.  Use 'fileformats'.
+	For backwards compatibility, when 'textauto' is set, 'fileformats' is
+	set to the default value for the current system.  When 'textauto' is
+	reset, 'fileformats' is made empty.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+				   *'textmode'* *'tx'* *'notextmode'* *'notx'*
+'textmode' 'tx'		boolean	(MS-DOS, Win32 and OS/2: default on,
+				 others: default off)
+			local to buffer
+			{not in Vi}
+	This option is obsolete.  Use 'fileformat'.
+	For backwards compatibility, when 'textmode' is set, 'fileformat' is
+	set to "dos".  When 'textmode' is reset, 'fileformat' is set to
+	"unix".
+
+						*'textwidth'* *'tw'*
+'textwidth' 'tw'	number	(default 0)
+			local to buffer
+			{not in Vi}
+	Maximum width of text that is being inserted.  A longer line will be
+	broken after white space to get this width.  A zero value disables
+	this.
+	'textwidth' is set to 0 when the 'paste' option is set and restored
+	when 'paste' is reset.
+	When 'textwidth' is zero, 'wrapmargin' may be used.  See also
+	'formatoptions' and |ins-textwidth|.
+	When 'formatexpr' is set it will be used to break the line.
+	NOTE: This option is set to 0 when 'compatible' is set.
+
+						*'thesaurus'* *'tsr'*
+'thesaurus' 'tsr'	string	(default "")
+			global or local to buffer |global-local|
+			{not in Vi}
+	List of file names, separated by commas, that are used to lookup words
+	for thesaurus completion commands |i_CTRL-X_CTRL-T|.  Each line in
+	the file should contain words with similar meaning, separated by
+	non-keyword characters (white space is preferred).  Maximum line
+	length is 510 bytes.
+	To obtain a file to be used here, check out this ftp site:
+	[Sorry this link doesn't work anymore, do you know the right one?]
+	ftp://ftp.ox.ac.uk/pub/wordlists/  First get the README file.
+	To include a comma in a file name precede it with a backslash.  Spaces
+	after a comma are ignored, otherwise spaces are included in the file
+	name.  See |option-backslash| about using backslashes.
+	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	directories from the list.  This avoids problems when a future version
+	uses another default.
+	Backticks cannot be used in this option for security reasons.
+
+			     *'tildeop'* *'top'* *'notildeop'* *'notop'*
+'tildeop' 'top'		boolean	(default off)
+			global
+			{not in Vi}
+	When on: The tilde command "~" behaves like an operator.
+	NOTE: This option is reset when 'compatible' is set.
+
+				*'timeout'* *'to'* *'notimeout'* *'noto'*
+'timeout' 'to'		boolean (default on)
+			global
+						*'ttimeout'* *'nottimeout'*
+'ttimeout'		boolean (default off, set in |defaults.vim|)
+			global
+			{not in Vi}
+	These two options together determine the behavior when part of a
+	mapped key sequence or keyboard code has been received:
+
+	'timeout'    'ttimeout'		action	~
+	   off		off		do not time out
+	   on		on or off	time out on :mappings and key codes
+	   off		on		time out on key codes
+
+	If both options are off, Vim will wait until either the complete
+	mapping or key sequence has been received, or it is clear that there
+	is no mapping or key sequence for the received characters.  For
+	example: if you have mapped "vl" and Vim has received 'v', the next
+	character is needed to see if the 'v' is followed by an 'l'.
+	When one of the options is on, Vim will wait for about 1 second for
+	the next character to arrive.  After that the already received
+	characters are interpreted as single characters.  The waiting time can
+	be changed with the 'timeoutlen' option.
+	On slow terminals or very busy systems timing out may cause
+	malfunctioning cursor keys.  If both options are off, Vim waits
+	forever after an entered <Esc> if there are key codes that start
+	with <Esc>.  You will have to type <Esc> twice.  If you do not have
+	problems with key codes, but would like to have :mapped key
+	sequences not timing out in 1 second, set the 'ttimeout' option and
+	reset the 'timeout' option.
+
+	NOTE: 'ttimeout' is reset when 'compatible' is set.
+
+						*'timeoutlen'* *'tm'*
+'timeoutlen' 'tm'	number	(default 1000)
+			global
+			{not in all versions of Vi}
+						*'ttimeoutlen'* *'ttm'*
+'ttimeoutlen' 'ttm'	number	(default -1, set to 100 in |defaults.vim|)
+			global
+			{not in Vi}
+	The time in milliseconds that is waited for a key code or mapped key
+	sequence to complete.  Also used for CTRL-\ CTRL-N and CTRL-\ CTRL-G
+	when part of a command has been typed.
+	Normally only 'timeoutlen' is used and 'ttimeoutlen' is -1.  When a
+	different timeout value for key codes is desired set 'ttimeoutlen' to
+	a non-negative number.
+
+		ttimeoutlen	mapping delay	   key code delay	~
+		   < 0		'timeoutlen'	   'timeoutlen'
+		  >= 0		'timeoutlen'	   'ttimeoutlen'
+
+	The timeout only happens when the 'timeout' and 'ttimeout' options
+	tell so.  A useful setting would be >
+		:set timeout timeoutlen=3000 ttimeoutlen=100
+<	(time out on mapping after three seconds, time out on key codes after
+	a tenth of a second).
+
+						*'title'* *'notitle'*
+'title'			boolean	(default off, on when title can be restored)
+			global
+			{not in Vi}
+			{not available when compiled without the |+title|
+			feature}
+	When on, the title of the window will be set to the value of
+	'titlestring' (if it is not empty), or to:
+		filename [+=-] (path) - VIM
+	Where:
+		filename	the name of the file being edited
+		-		indicates the file cannot be modified, 'ma' off
+		+		indicates the file was modified
+		=		indicates the file is read-only
+		=+		indicates the file is read-only and modified
+		(path)		is the path of the file being edited
+		- VIM		the server name |v:servername| or "VIM"
+	Only works if the terminal supports setting window titles
+	(currently Amiga console, Win32 console, all GUI versions and
+	terminals with a non- empty 't_ts' option - these are Unix xterm and
+	iris-ansi by default, where 't_ts' is taken from the builtin termcap).
+								*X11*
+	When Vim was compiled with HAVE_X11 defined, the original title will
+	be restored if possible.  The output of ":version" will include "+X11"
+	when HAVE_X11 was defined, otherwise it will be "-X11".  This also
+	works for the icon name |'icon'|.
+	But: When Vim was started with the |-X| argument, restoring the title
+	will not work (except in the GUI).
+	If the title cannot be restored, it is set to the value of 'titleold'.
+	You might want to restore the title outside of Vim then.
+	When using an xterm from a remote machine you can use this command:
+	    rsh machine_name xterm -display $DISPLAY &
+	then the WINDOWID environment variable should be inherited and the
+	title of the window should change back to what it should be after
+	exiting Vim.
+
+								*'titlelen'*
+'titlelen'		number	(default 85)
+			global
+			{not in Vi}
+			{not available when compiled without the |+title|
+			feature}
+	Gives the percentage of 'columns' to use for the length of the window
+	title.  When the title is longer, only the end of the path name is
+	shown.  A '<' character before the path name is used to indicate this.
+	Using a percentage makes this adapt to the width of the window.  But
+	it won't work perfectly, because the actual number of characters
+	available also depends on the font used and other things in the title
+	bar.  When 'titlelen' is zero the full path is used.  Otherwise,
+	values from 1 to 30000 percent can be used.
+	'titlelen' is also used for the 'titlestring' option.
+
+						*'titleold'*
+'titleold'		string	(default "Thanks for flying Vim")
+			global
+			{not in Vi}
+			{only available when compiled with the |+title|
+			feature}
+	This option will be used for the window title when exiting Vim if the
+	original title cannot be restored.  Only happens if 'title' is on or
+	'titlestring' is not empty.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+						*'titlestring'*
+'titlestring'		string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+title|
+			feature}
+	When this option is not empty, it will be used for the title of the
+	window.  This happens only when the 'title' option is on.
+	Only works if the terminal supports setting window titles (currently
+	Amiga console, Win32 console, all GUI versions and terminals with a
+	non-empty 't_ts' option).
+	When Vim was compiled with HAVE_X11 defined, the original title will
+	be restored if possible, see |X11|.
+	When this option contains printf-style '%' items, they will be
+	expanded according to the rules used for 'statusline'.
+	Example: >
+    :auto BufEnter * let &titlestring = hostname() . "/" . expand("%:p")
+    :set title titlestring=%<%F%=%l/%L-%P titlelen=70
+<	The value of 'titlelen' is used to align items in the middle or right
+	of the available space.
+	Some people prefer to have the file name first: >
+    :set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)
+<	Note the use of "%{ }" and an expression to get the path of the file,
+	without the file name.  The "%( %)" constructs are used to add a
+	separating space only when needed.
+	NOTE: Use of special characters in 'titlestring' may cause the display
+	to be garbled (e.g., when it contains a CR or NL character).
+	{not available when compiled without the |+statusline| feature}
+
+				*'toolbar'* *'tb'*
+'toolbar' 'tb'		string	(default "icons,tooltips")
+			global
+			{only for |+GUI_GTK|, |+GUI_Athena|, |+GUI_Motif| and
+			|+GUI_Photon|}
+	The contents of this option controls various toolbar settings.  The
+	possible values are:
+		icons		Toolbar buttons are shown with icons.
+		text		Toolbar buttons shown with text.
+		horiz		Icon and text of a toolbar button are
+				horizontally arranged.  {only in GTK+ 2 GUI}
+		tooltips	Tooltips are active for toolbar buttons.
+	Tooltips refer to the popup help text which appears after the mouse
+	cursor is placed over a toolbar button for a brief moment.
+
+	If you want the toolbar to be shown with icons as well as text, do the
+	following: >
+		:set tb=icons,text
+<	Motif and Athena cannot display icons and text at the same time.  They
+	will show icons if both are requested.
+
+	If none of the strings specified in 'toolbar' are valid or if
+	'toolbar' is empty, this option is ignored.  If you want to disable
+	the toolbar, you need to set the 'guioptions' option.  For example: >
+		:set guioptions-=T
+<	Also see |gui-toolbar|.
+
+						*'toolbariconsize'* *'tbis'*
+'toolbariconsize' 'tbis'	string	(default "small")
+				global
+				{not in Vi}
+				{only in the GTK+ GUI}
+	Controls the size of toolbar icons.  The possible values are:
+		tiny		Use tiny icons.
+		small		Use small icons (default).
+		medium		Use medium-sized icons.
+		large		Use large icons.
+		huge		Use even larger icons.
+		giant		Use very big icons.
+	The exact dimensions in pixels of the various icon sizes depend on
+	the current theme.  Common dimensions are giant=48x48, huge=32x32,
+	large=24x24, medium=24x24, small=20x20 and tiny=16x16.
+
+	If 'toolbariconsize' is empty, the global default size as determined
+	by user preferences or the current theme is used.
+
+			     *'ttybuiltin'* *'tbi'* *'nottybuiltin'* *'notbi'*
+'ttybuiltin' 'tbi'	boolean	(default on)
+			global
+			{not in Vi}
+	When on, the builtin termcaps are searched before the external ones.
+	When off the builtin termcaps are searched after the external ones.
+	When this option is changed, you should set the 'term' option next for
+	the change to take effect, for example: >
+		:set notbi term=$TERM
+<	See also |termcap|.
+	Rationale: The default for this option is "on", because the builtin
+	termcap entries are generally better (many systems contain faulty
+	xterm entries...).
+
+				     *'ttyfast'* *'tf'* *'nottyfast'* *'notf'*
+'ttyfast' 'tf'		boolean	(default off, on when 'term' is xterm, hpterm,
+					sun-cmd, screen, rxvt, dtterm or
+					iris-ansi; also on when running Vim in
+					a DOS console)
+			global
+			{not in Vi}
+	Indicates a fast terminal connection.  More characters will be sent to
+	the screen for redrawing, instead of using insert/delete line
+	commands.  Improves smoothness of redrawing when there are multiple
+	windows and the terminal does not support a scrolling region.
+	Also enables the extra writing of characters at the end of each screen
+	line for lines that wrap.  This helps when using copy/paste with the
+	mouse in an xterm and other terminals.
+
+						*'ttymouse'* *'ttym'*
+'ttymouse' 'ttym'	string	(default depends on 'term')
+			global
+			{not in Vi}
+			{only in Unix and VMS, doesn't work in the GUI; not
+			available when compiled without |+mouse|}
+	Name of the terminal type for which mouse codes are to be recognized.
+	Currently these strings are valid:
+							*xterm-mouse*
+	   xterm	xterm-like mouse handling.  The mouse generates
+			"<Esc>[Mscr", where "scr" is three bytes:
+				"s"  = button state
+				"c"  = column plus 33
+				"r"  = row plus 33
+			This only works up to 223 columns!  See "dec",
+			"urxvt", and "sgr" for solutions.
+	   xterm2	Works like "xterm", but with the xterm reporting the
+			mouse position while the mouse is dragged.  This works
+			much faster and more precise.  Your xterm must at
+			least at patchlevel 88 / XFree 3.3.3 for this to
+			work.  See below for how Vim detects this
+			automatically.
+							*netterm-mouse*
+	   netterm	NetTerm mouse handling.  The mouse generates
+			"<Esc>}r,c<CR>", where "r,c" are two decimal numbers
+			for the row and column.
+							*dec-mouse*
+	   dec		DEC terminal mouse handling.  The mouse generates a
+			rather complex sequence, starting with "<Esc>[".
+			This is also available for an Xterm, if it was
+			configured with "--enable-dec-locator".
+							*jsbterm-mouse*
+	   jsbterm	JSB term mouse handling.
+							*pterm-mouse*
+	   pterm	QNX pterm mouse handling.
+							*urxvt-mouse*
+	   urxvt	Mouse handling for the urxvt (rxvt-unicode) terminal.
+			The mouse works only if the terminal supports this
+			encoding style, but it does not have 223 columns limit
+			unlike "xterm" or "xterm2".
+							*sgr-mouse*
+	   sgr		Mouse handling for the terminal that emits SGR-styled
+			mouse reporting.  The mouse works even in columns
+			beyond 223.  This option is backward compatible with
+			"xterm2" because it can also decode "xterm2" style
+			mouse codes.
+
+	The mouse handling must be enabled at compile time |+mouse_xterm|
+	|+mouse_dec| |+mouse_netterm| |+mouse_jsbterm| |+mouse_urxvt|
+	|+mouse_sgr|.
+	Only "xterm"(2) is really recognized.  NetTerm mouse codes are always
+	recognized, if enabled at compile time.  DEC terminal mouse codes
+	are recognized if enabled at compile time, and 'ttymouse' is not
+	"xterm", "xterm2", "urxvt" or "sgr" (because dec mouse codes conflict
+	with them).
+	This option is automatically set to "xterm", when the 'term' option is
+	set to a name that starts with "xterm", "mlterm", "screen", "tmux",
+	"st" (full match only), "st-" or "stterm", and 'ttymouse' is not set
+	already.
+	Additionally, if vim is compiled with the |+termresponse| feature and
+	|t_RV| is set to the escape sequence to request the xterm version
+	number, more intelligent detection process runs.
+	The "xterm2" value will be set if the xterm version is reported to be
+	from 95 to 276.  The "sgr" value will be set if the xterm version is
+	277 or higher and when Vim detects Mac Terminal.app or iTerm2.
+	If you do not want 'ttymouse' to be set to "xterm2" or "sgr"
+	automatically, set t_RV to an empty string: >
+		:set t_RV=
+<
+						*'ttyscroll'* *'tsl'*
+'ttyscroll' 'tsl'	number	(default 999)
+			global
+	Maximum number of lines to scroll the screen.  If there are more lines
+	to scroll the window is redrawn.  For terminals where scrolling is
+	very slow and redrawing is not slow this can be set to a small number,
+	e.g., 3, to speed up displaying.
+
+						*'ttytype'* *'tty'*
+'ttytype' 'tty'		string	(default from $TERM)
+			global
+	Alias for 'term', see above.
+
+						*'undodir'* *'udir'*
+'undodir' 'udir'	string	(default ".")
+			global
+			{not in Vi}
+			{only when compiled with the |+persistent_undo| feature}
+	List of directory names for undo files, separated with commas.
+	See |'backupdir'| for details of the format.
+	"." means using the directory of the file.  The undo file name for
+	"file.txt" is ".file.txt.un~".
+	For other directories the file name is the full path of the edited
+	file, with path separators replaced with "%".
+	When writing: The first directory that exists is used. "." always
+	works, no directories after "." will be used for writing.
+	When reading all entries are tried to find an undo file.  The first
+	undo file that exists is used.  When it cannot be read an error is
+	given, no further entry is used.
+	See |undo-persistence|.
+
+				*'undofile'* *'noundofile'* *'udf'* *'noudf'*
+'undofile' 'udf'	boolean	(default off)
+			local to buffer
+			{not in Vi}
+			{only when compiled with the |+persistent_undo| feature}
+	When on, Vim automatically saves undo history to an undo file when
+	writing a buffer to a file, and restores undo history from the same
+	file on buffer read.
+	The directory where the undo file is stored is specified by 'undodir'.
+	For more information about this feature see |undo-persistence|.
+	The undo file is not read when 'undoreload' causes the buffer from
+	before a reload to be saved for undo.
+	When 'undofile' is turned off the undo file is NOT deleted.
+	NOTE: This option is reset when 'compatible' is set.
+
+						*'undolevels'* *'ul'*
+'undolevels' 'ul'	number	(default 100, 1000 for Unix, VMS,
+						Win32 and OS/2)
+			global or local to buffer |global-local|
+			{not in Vi}
+	Maximum number of changes that can be undone.  Since undo information
+	is kept in memory, higher numbers will cause more memory to be used
+	(nevertheless, a single change can use an unlimited amount of memory).
+	Set to 0 for Vi compatibility: One level of undo and "u" undoes
+	itself: >
+		set ul=0
+<	But you can also get Vi compatibility by including the 'u' flag in
+	'cpoptions', and still be able to use CTRL-R to repeat undo.
+	Also see |undo-two-ways|.
+	Set to -1 for no undo at all.  You might want to do this only for the
+	current buffer: >
+		setlocal ul=-1
+<	This helps when you run out of memory for a single change.
+
+	The local value is set to -123456 when the global value is to be used.
+
+	Also see |clear-undo|.
+
+						*'undoreload'* *'ur'*
+'undoreload' 'ur'	number	(default 10000)
+			global
+			{not in Vi}
+	Save the whole buffer for undo when reloading it.  This applies to the
+	":e!" command and reloading for when the buffer changed outside of
+	Vim. |FileChangedShell|
+	The save only happens when this option is negative or when the number
+	of lines is smaller than the value of this option.
+	Set this option to zero to disable undo for a reload.
+
+	When saving undo for a reload, any undo file is not read.
+
+	Note that this causes the whole buffer to be stored in memory.  Set
+	this option to a lower value if you run out of memory.
+
+						*'updatecount'* *'uc'*
+'updatecount' 'uc'	number	(default: 200)
+			global
+			{not in Vi}
+	After typing this many characters the swap file will be written to
+	disk.  When zero, no swap file will be created at all (see chapter on
+	recovery |crash-recovery|).  'updatecount' is set to zero by starting
+	Vim with the "-n" option, see |startup|.  When editing in readonly
+	mode this option will be initialized to 10000.
+	The swapfile can be disabled per buffer with |'swapfile'|.
+	When 'updatecount' is set from zero to non-zero, swap files are
+	created for all buffers that have 'swapfile' set.  When 'updatecount'
+	is set to zero, existing swap files are not deleted.
+	Also see |'swapsync'|.
+	This option has no meaning in buffers where |'buftype'| is "nofile"
+	or "nowrite".
+
+						*'updatetime'* *'ut'*
+'updatetime' 'ut'	number	(default 4000)
+			global
+			{not in Vi}
+	If this many milliseconds nothing is typed the swap file will be
+	written to disk (see |crash-recovery|).  Also used for the
+	|CursorHold| autocommand event.
+
+					*'varsofttabstop'* *'vsts'*
+'varsofttabstop' 'vsts'	string	(default "")
+			local to buffer
+			{only available when compiled with the |+vartabs|
+			feature}
+			{not in Vi}
+	A list of the number of spaces that a <Tab> counts for while editing,
+	such as inserting a <Tab> or using <BS>.  It "feels" like variable-
+	width <Tab>s are being inserted, while in fact a mixture of spaces
+	and <Tab>s is used.  Tab widths are separated with commas, with the
+	final value applying to all subsequent tabs.
+
+	For example, when editing assembly language files where statements
+	start in the 9th column and comments in the 41st, it may be useful
+	to use the following: >
+		:set varsofttabstop=8,32,8
+<	This will set soft tabstops with 8 and 8 + 32 spaces, and 8 more
+	for every column thereafter.
+
+	Note that the value of |'softtabstop'| will be ignored while
+	'varsofttabstop' is set.
+
+						*'vartabstop'* *'vts'*
+'vartabstop' 'vts'	string	(default "")
+			local to buffer
+			{only available when compiled with the |+vartabs|
+			feature}
+			{not in Vi}
+	A list of the number of spaces that a <Tab> in the file counts for,
+	separated by commas.  Each value corresponds to one tab, with the
+	final value applying to all subsequent tabs. For example: >
+		:set vartabstop=4,20,10,8
+<	This will make the first tab 4 spaces wide, the second 20 spaces,
+	the third 10 spaces, and all following tabs 8 spaces.
+
+	Note that the value of |'tabstop'| will be ignored while 'vartabstop'
+	is set.
+
+						*'verbose'* *'vbs'*
+'verbose' 'vbs'		number	(default 0)
+			global
+			{not in Vi, although some versions have a boolean
+			verbose option}
+	When bigger than zero, Vim will give messages about what it is doing.
+	Currently, these messages are given:
+	>= 1	When the viminfo file is read or written.
+	>= 2	When a file is ":source"'ed.
+	>= 5	Every searched tags file and include file.
+	>= 8	Files for which a group of autocommands is executed.
+	>= 9	Every executed autocommand.
+	>= 12	Every executed function.
+	>= 13	When an exception is thrown, caught, finished, or discarded.
+	>= 14	Anything pending in a ":finally" clause.
+	>= 15	Every executed Ex command (truncated at 200 characters).
+
+	This option can also be set with the "-V" argument.  See |-V|.
+	This option is also set by the |:verbose| command.
+
+	When the 'verbosefile' option is set then the verbose messages are not
+	displayed.
+
+						*'verbosefile'* *'vfile'*
+'verbosefile' 'vfile'	string	(default empty)
+			global
+			{not in Vi}
+	When not empty all messages are written in a file with this name.
+	When the file exists messages are appended.
+	Writing to the file ends when Vim exits or when 'verbosefile' is made
+	empty.  Writes are buffered, thus may not show up for some time.
+	Setting 'verbosefile' to a new value is like making it empty first.
+	The difference with |:redir| is that verbose messages are not
+	displayed when 'verbosefile' is set.
+
+						*'viewdir'* *'vdir'*
+'viewdir' 'vdir'	string	(default for Amiga, MS-DOS, OS/2 and Win32:
+							 "$VIM/vimfiles/view",
+				 for Unix: "~/.vim/view",
+				 for Macintosh: "$VIM:vimfiles:view"
+				 for VMS: "sys$login:vimfiles/view"
+				 for RiscOS: "Choices:vimfiles/view")
+			global
+			{not in Vi}
+			{not available when compiled without the |+mksession|
+			feature}
+	Name of the directory where to store files for |:mkview|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'viewoptions'* *'vop'*
+'viewoptions' 'vop'	string	(default: "folds,options,cursor,curdir")
+			global
+			{not in Vi}
+			{not available when compiled without the |+mksession|
+			feature}
+	Changes the effect of the |:mkview| command.  It is a comma separated
+	list of words.  Each word enables saving and restoring something:
+	   word		save and restore ~
+	   cursor	cursor position in file and in window
+	   folds	manually created folds, opened/closed folds and local
+			fold options
+	   options	options and mappings local to a window or buffer (not
+			global values for local options)
+	   localoptions same as "options"
+	   slash	backslashes in file names replaced with forward
+			slashes
+	   unix		with Unix end-of-line format (single <NL>), even when
+			on Windows or DOS
+	   curdir	the window-local directory, if set with `:lcd`
+
+	"slash" and "unix" are useful on Windows when sharing view files
+	with Unix.  The Unix version of Vim cannot source dos format scripts,
+	but the Windows version of Vim can source unix format scripts.
+
+				*'viminfo'* *'vi'* *E526* *E527* *E528*
+'viminfo' 'vi'		string	(Vi default: "", Vim default for MS-DOS,
+				   Windows and OS/2: '100,<50,s10,h,rA:,rB:,
+				   for Amiga: '100,<50,s10,h,rdf0:,rdf1:,rdf2:
+				   for others: '100,<50,s10,h)
+			global
+			{not in Vi}
+			{not available when compiled without the |+viminfo|
+			feature}
+	When non-empty, the viminfo file is read upon startup and written
+	when exiting Vim (see |viminfo-file|). Except when 'viminfofile' is
+	"NONE".
+	The string should be a comma separated list of parameters, each
+	consisting of a single character identifying the particular parameter,
+	followed by a number or string which specifies the value of that
+	parameter.  If a particular character is left out, then the default
+	value is used for that parameter.  The following is a list of the
+	identifying characters and the effect of their value.
+	CHAR	VALUE	~
+							*viminfo-!*
+	!	When included, save and restore global variables that start
+		with an uppercase letter, and don't contain a lowercase
+		letter.  Thus "KEEPTHIS and "K_L_M" are stored, but "KeepThis"
+		and "_K_L_M" are not.  Nested List and Dict items may not be
+		read back correctly, you end up with an empty item.
+							*viminfo-quote*
+	"	Maximum number of lines saved for each register.  Old name of
+		the '<' item, with the disadvantage that you need to put a
+		backslash before the ", otherwise it will be recognized as the
+		start of a comment!
+							*viminfo-%*
+	%	When included, save and restore the buffer list.  If Vim is
+		started with a file name argument, the buffer list is not
+		restored.  If Vim is started without a file name argument, the
+		buffer list is restored from the viminfo file.  Quickfix
+		('buftype'), unlisted ('buflisted'), unnamed and buffers on
+		removable media (|viminfo-r|) are not saved.
+		When followed by a number, the number specifies the maximum
+		number of buffers that are stored.  Without a number all
+		buffers are stored.
+							*viminfo-'*
+	'	Maximum number of previously edited files for which the marks
+		are remembered.  This parameter must always be included when
+		'viminfo' is non-empty.
+		Including this item also means that the |jumplist| and the
+		|changelist| are stored in the viminfo file.
+							*viminfo-/*
+	/	Maximum number of items in the search pattern history to be
+		saved.  If non-zero, then the previous search and substitute
+		patterns are also saved.  When not included, the value of
+		'history' is used.
+							*viminfo-:*
+	:	Maximum number of items in the command-line history to be
+		saved.  When not included, the value of 'history' is used.
+							*viminfo-<*
+	<	Maximum number of lines saved for each register.  If zero then
+		registers are not saved.  When not included, all lines are
+		saved.  '"' is the old name for this item.
+		Also see the 's' item below: limit specified in Kbyte.
+							*viminfo-@*
+	@	Maximum number of items in the input-line history to be
+		saved.  When not included, the value of 'history' is used.
+							*viminfo-c*
+	c	When included, convert the text in the viminfo file from the
+		'encoding' used when writing the file to the current
+		'encoding'.  See |viminfo-encoding|.
+							*viminfo-f*
+	f	Whether file marks need to be stored.  If zero, file marks ('0
+		to '9, 'A to 'Z) are not stored.  When not present or when
+		non-zero, they are all stored.  '0 is used for the current
+		cursor position (when exiting or when doing ":wviminfo").
+							*viminfo-h*
+	h	Disable the effect of 'hlsearch' when loading the viminfo
+		file.  When not included, it depends on whether ":nohlsearch"
+		has been used since the last search command.
+							*viminfo-n*
+	n	Name of the viminfo file.  The name must immediately follow
+		the 'n'.  Must be at the end of the option!  If the
+		'viminfofile' option is set, that file name overrides the one
+		given here with 'viminfo'.  Environment variables are
+		expanded when opening the file, not when setting the option.
+							*viminfo-r*
+	r	Removable media.  The argument is a string (up to the next
+		',').  This parameter can be given several times.  Each
+		specifies the start of a path for which no marks will be
+		stored.  This is to avoid removable media.  For MS-DOS you
+		could use "ra:,rb:", for Amiga "rdf0:,rdf1:,rdf2:".  You can
+		also use it for temp files, e.g., for Unix: "r/tmp".  Case is
+		ignored.  Maximum length of each 'r' argument is 50
+		characters.
+							*viminfo-s*
+	s	Maximum size of an item in Kbyte.  If zero then registers are
+		not saved.  Currently only applies to registers.  The default
+		"s10" will exclude registers with more than 10 Kbyte of text.
+		Also see the '<' item above: line count limit.
+
+	Example: >
+	    :set viminfo='50,<1000,s100,:0,n~/vim/viminfo
+<
+	'50		Marks will be remembered for the last 50 files you
+			edited.
+	<1000		Contents of registers (up to 1000 lines each) will be
+			remembered.
+	s100		Registers with more than 100 Kbyte text are skipped.
+	:0		Command-line history will not be saved.
+	n~/vim/viminfo	The name of the file to use is "~/vim/viminfo".
+	no /		Since '/' is not specified, the default will be used,
+			that is, save all of the search history, and also the
+			previous search and substitute patterns.
+	no %		The buffer list will not be saved nor read back.
+	no h		'hlsearch' highlighting will be restored.
+
+	When setting 'viminfo' from an empty value you can use |:rviminfo| to
+	load the contents of the file, this is not done automatically.
+
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+	NOTE: This option is set to the Vim default value when 'compatible'
+	is reset.
+
+				*'viminfofile'* *'vif'*
+'viminfofile' 'vif'	string	(default: "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+viminfo|
+			feature}
+	When non-empty, overrides the file name used for viminfo.
+	When equal to "NONE" no viminfo file will be read or written.
+	This option can be set with the |-i| command line flag.  The |--clean|
+	command line flag sets it to "NONE".
+
+					    *'virtualedit'* *'ve'*
+'virtualedit' 've'	string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the
+			|+virtualedit| feature}
+	A comma separated list of these words:
+	    block	Allow virtual editing in Visual block mode.
+	    insert	Allow virtual editing in Insert mode.
+	    all		Allow virtual editing in all modes.
+	    onemore	Allow the cursor to move just past the end of the line
+
+	Virtual editing means that the cursor can be positioned where there is
+	no actual character.  This can be halfway into a tab or beyond the end
+	of the line.  Useful for selecting a rectangle in Visual mode and
+	editing a table.
+	"onemore" is not the same, it will only allow moving the cursor just
+	after the last character of the line.  This makes some commands more
+	consistent.  Previously the cursor was always past the end of the line
+	if the line was empty.  But it is far from Vi compatible.  It may also
+	break some plugins or Vim scripts.  For example because |l| can move
+	the cursor after the last character.  Use with care!
+	Using the `$` command will move to the last character in the line, not
+	past it.  This may actually move the cursor to the left!
+	The `g$` command will move to the end of the screen line.
+	It doesn't make sense to combine "all" with "onemore", but you will
+	not get a warning for it.
+	NOTE: This option is set to "" when 'compatible' is set.
+
+			*'visualbell'* *'vb'* *'novisualbell'* *'novb'* *beep*
+'visualbell' 'vb'	boolean	(default off)
+			global
+			{not in Vi}
+	Use a visual bell instead of beeping.  The terminal code to display the
+	visual bell is given with 't_vb'.  When no beep or flash is wanted,
+	use: >
+		:set vb t_vb=
+<	If you want a short flash, you can use this on many terminals: >
+		:set vb t_vb=[?5h$<100>[?5l
+<	Here $<100> specifies the time, you can use a smaller or bigger value
+	to get a shorter or longer flash.
+
+	Note: Vim will limit the bell to once per half a second.  This avoids
+	having to wait for the flashing to finish when there are lots of
+	bells, e.g. on key repeat.  This also happens without 'visualbell'
+	set.
+
+	In the GUI, 't_vb' defaults to "<Esc>|f", which inverts the display
+	for 20 msec.  If you want to use a different time, use "<Esc>|40f",
+	where 40 is the time in msec.
+
+	Note: When the GUI starts, 't_vb' is reset to its default value.  You
+	might want to set it again in your |gvimrc|.
+
+	Does not work on the Amiga, you always get a screen flash.
+	Also see 'errorbells'.
+
+						*'warn'* *'nowarn'*
+'warn'			boolean	(default on)
+			global
+	Give a warning message when a shell command is used while the buffer
+	has been changed.
+
+		     *'weirdinvert'* *'wiv'* *'noweirdinvert'* *'nowiv'*
+'weirdinvert' 'wiv'	boolean	(default off)
+			global
+			{not in Vi}
+	This option has the same effect as the 't_xs' terminal option.
+	It is provided for backwards compatibility with version 4.x.
+	Setting 'weirdinvert' has the effect of making 't_xs' non-empty, and
+	vice versa.  Has no effect when the GUI is running.
+
+						*'whichwrap'* *'ww'*
+'whichwrap' 'ww'	string	(Vim default: "b,s", Vi default: "")
+			global
+			{not in Vi}
+	Allow specified keys that move the cursor left/right to move to the
+	previous/next line when the cursor is on the first/last character in
+	the line.  Concatenate characters to allow this for these keys:
+		char   key	  mode	~
+		 b    <BS>	 Normal and Visual
+		 s    <Space>	 Normal and Visual
+		 h    "h"	 Normal and Visual (not recommended)
+		 l    "l"	 Normal and Visual (not recommended)
+		 <    <Left>	 Normal and Visual
+		 >    <Right>	 Normal and Visual
+		 ~    "~"	 Normal
+		 [    <Left>	 Insert and Replace
+		 ]    <Right>	 Insert and Replace
+	For example: >
+		:set ww=<,>,[,]
+<	allows wrap only when cursor keys are used.
+	When the movement keys are used in combination with a delete or change
+	operator, the <EOL> also counts for a character.  This makes "3h"
+	different from "3dh" when the cursor crosses the end of a line.  This
+	is also true for "x" and "X", because they do the same as "dl" and
+	"dh".  If you use this, you may also want to use the mapping
+	":map <BS> X" to make backspace delete the character in front of the
+	cursor.
+	When 'l' is included and it is used after an operator at the end of a
+	line then it will not move to the next line.  This makes "dl", "cl",
+	"yl" etc. work normally.
+	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'wildchar'* *'wc'*
+'wildchar' 'wc'		number	(Vim default: <Tab>, Vi default: CTRL-E)
+			global
+			{not in Vi}
+	Character you have to type to start wildcard expansion in the
+	command-line, as specified with 'wildmode'.
+	More info here: |cmdline-completion|.
+	The character is not recognized when used inside a macro.  See
+	'wildcharm' for that.
+	Although 'wc' is a number option, you can set it to a special key: >
+		:set wc=<Esc>
+<	NOTE: This option is set to the Vi default value when 'compatible' is
+	set and to the Vim default value when 'compatible' is reset.
+
+						*'wildcharm'* *'wcm'*
+'wildcharm' 'wcm'	number	(default: none (0))
+			global
+			{not in Vi}
+	'wildcharm' works exactly like 'wildchar', except that it is
+	recognized when used inside a macro.  You can find "spare" command-line
+	keys suitable for this option by looking at |ex-edit-index|.  Normally
+	you'll never actually type 'wildcharm', just use it in mappings that
+	automatically invoke completion mode, e.g.: >
+		:set wcm=<C-Z>
+		:cnoremap ss so $vim/sessions/*.vim<C-Z>
+<	Then after typing :ss you can use CTRL-P & CTRL-N.
+
+						*'wildignore'* *'wig'*
+'wildignore' 'wig'	string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+wildignore|
+			feature}
+	A list of file patterns.  A file that matches with one of these
+	patterns is ignored when expanding |wildcards|, completing file or
+	directory names, and influences the result of |expand()|, |glob()| and
+	|globpath()| unless a flag is passed to disable this.
+	The pattern is used like with |:autocmd|, see |autocmd-patterns|.
+	Also see 'suffixes'.
+	Example: >
+		:set wildignore=*.o,*.obj
+<	The use of |:set+=| and |:set-=| is preferred when adding or removing
+	a pattern from the list.  This avoids problems when a future version
+	uses another default.
+
+
+			*'wildignorecase'* *'wic'* *'nowildignorecase'* *'nowic'*
+'wildignorecase' 'wic'	boolean	(default off)
+			global
+			{not in Vi}
+	When set case is ignored when completing file names and directories.
+	Has no effect when 'fileignorecase' is set.
+	Does not apply when the shell is used to expand wildcards, which
+	happens when there are special characters.
+
+
+				*'wildmenu'* *'wmnu'* *'nowildmenu'* *'nowmnu'*
+'wildmenu' 'wmnu'	boolean	(default off, set in |defaults.vim|)
+			global
+			{not in Vi}
+			{not available if compiled without the |+wildmenu|
+			feature}
+	When 'wildmenu' is on, command-line completion operates in an enhanced
+	mode.  On pressing 'wildchar' (usually <Tab>) to invoke completion,
+	the possible matches are shown just above the command line, with the
+	first match highlighted (overwriting the status line, if there is
+	one).  Keys that show the previous/next match, such as <Tab> or
+	CTRL-P/CTRL-N, cause the highlight to move to the appropriate match.
+	When 'wildmode' is used, "wildmenu" mode is used where "full" is
+	specified.  "longest" and "list" do not start "wildmenu" mode.
+	You can check the current mode with |wildmenumode()|.
+	If there are more matches than can fit in the line, a ">" is shown on
+	the right and/or a "<" is shown on the left.  The status line scrolls
+	as needed.
+	The "wildmenu" mode is abandoned when a key is hit that is not used
+	for selecting a completion.
+	While the "wildmenu" is active the following keys have special
+	meanings:
+
+	<Left> <Right>	- select previous/next match (like CTRL-P/CTRL-N)
+	<Down>		- in filename/menu name completion: move into a
+			  subdirectory or submenu.
+	<CR>		- in menu completion, when the cursor is just after a
+			  dot: move into a submenu.
+	<Up>		- in filename/menu name completion: move up into
+			  parent directory or parent menu.
+
+	This makes the menus accessible from the console |console-menus|.
+
+	If you prefer the <Left> and <Right> keys to move the cursor instead
+	of selecting a different match, use this: >
+		:cnoremap <Left> <Space><BS><Left>
+		:cnoremap <Right> <Space><BS><Right>
+<
+	The "WildMenu" highlighting is used for displaying the current match
+	|hl-WildMenu|.
+
+						*'wildmode'* *'wim'*
+'wildmode' 'wim'	string	(Vim default: "full")
+			global
+			{not in Vi}
+	Completion mode that is used for the character specified with
+	'wildchar'.  It is a comma separated list of up to four parts.  Each
+	part specifies what to do for each consecutive use of 'wildchar'.  The
+	first part specifies the behavior for the first use of 'wildchar',
+	The second part for the second use, etc.
+	These are the possible values for each part:
+	""		Complete only the first match.
+	"full"		Complete the next full match.  After the last match,
+			the original string is used and then the first match
+			again.
+	"longest"	Complete till longest common string.  If this doesn't
+			result in a longer string, use the next part.
+	"longest:full"	Like "longest", but also start 'wildmenu' if it is
+			enabled.
+	"list"		When more than one match, list all matches.
+	"list:full"	When more than one match, list all matches and
+			complete first match.
+	"list:longest"	When more than one match, list all matches and
+			complete till longest common string.
+	When there is only a single match, it is fully completed in all cases.
+
+	Examples: >
+		:set wildmode=full
+<	Complete first full match, next match, etc.  (the default) >
+		:set wildmode=longest,full
+<	Complete longest common string, then each full match >
+		:set wildmode=list:full
+<	List all matches and complete each full match >
+		:set wildmode=list,full
+<	List all matches without completing, then each full match >
+		:set wildmode=longest,list
+<	Complete longest common string, then list alternatives.
+	More info here: |cmdline-completion|.
+
+						*'wildoptions'* *'wop'*
+'wildoptions' 'wop'	string	(default "")
+			global
+			{not in Vi}
+			{not available when compiled without the |+wildignore|
+			feature}
+	A list of words that change how command line completion is done.
+	Currently only one word is allowed:
+	  tagfile	When using CTRL-D to list matching tags, the kind of
+			tag and the file of the tag is listed.	Only one match
+			is displayed per line.  Often used tag kinds are:
+				d	#define
+				f	function
+	Also see |cmdline-completion|.
+
+						*'winaltkeys'* *'wak'*
+'winaltkeys' 'wak'	string	(default "menu")
+			global
+			{not in Vi}
+			{only used in Win32, Motif, GTK and Photon GUI}
+	Some GUI versions allow the access to menu entries by using the ALT
+	key in combination with a character that appears underlined in the
+	menu.  This conflicts with the use of the ALT key for mappings and
+	entering special characters.  This option tells what to do:
+	  no	Don't use ALT keys for menus.  ALT key combinations can be
+		mapped, but there is no automatic handling.  This can then be
+		done with the |:simalt| command.
+	  yes	ALT key handling is done by the windowing system.  ALT key
+		combinations cannot be mapped.
+	  menu	Using ALT in combination with a character that is a menu
+		shortcut key, will be handled by the windowing system.  Other
+		keys can be mapped.
+	If the menu is disabled by excluding 'm' from 'guioptions', the ALT
+	key is never used for the menu.
+	This option is not used for <F10>; on Win32 and with GTK <F10> will
+	select the menu, unless it has been mapped.
+
+						*'window'* *'wi'*
+'window' 'wi'		number  (default screen height - 1)
+			global
+	Window height.  Do not confuse this with the height of the Vim window,
+	use 'lines' for that.
+	Used for |CTRL-F| and |CTRL-B| when there is only one window and the
+	value is smaller than 'lines' minus one.  The screen will scroll
+	'window' minus two lines, with a minimum of one.
+	When 'window' is equal to 'lines' minus one CTRL-F and CTRL-B scroll
+	in a much smarter way, taking care of wrapping lines.
+	When resizing the Vim window, the value is smaller than 1 or more than
+	or equal to 'lines' it will be set to 'lines' minus 1.
+	{Vi also uses the option to specify the number of displayed lines}
+
+						*'winheight'* *'wh'* *E591*
+'winheight' 'wh'	number	(default 1)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	Minimal number of lines for the current window.  This is not a hard
+	minimum, Vim will use fewer lines if there is not enough room.  If the
+	focus goes to a window that is smaller, its size is increased, at the
+	cost of the height of other windows.
+	Set 'winheight' to a small number for normal editing.
+	Set it to 999 to make the current window fill most of the screen.
+	Other windows will be only 'winminheight' high.  This has the drawback
+	that ":all" will create only two windows.  To avoid "vim -o 1 2 3 4"
+	to create only two windows, set the option after startup is done,
+	using the |VimEnter| event: >
+		au VimEnter * set winheight=999
+<	Minimum value is 1.
+	The height is not adjusted after one of the commands that change the
+	height of the current window.
+	'winheight' applies to the current window.  Use 'winminheight' to set
+	the minimal height for other windows.
+
+			*'winfixheight'* *'wfh'* *'nowinfixheight'* *'nowfh'*
+'winfixheight' 'wfh'	boolean	(default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	Keep the window height when windows are opened or closed and
+	'equalalways' is set.  Also for |CTRL-W_=|.  Set by default for the
+	|preview-window| and |quickfix-window|.
+	The height may be changed anyway when running out of room.
+
+			*'winfixwidth'* *'wfw'* *'nowinfixwidth'* *'nowfw'*
+'winfixwidth' 'wfw'	boolean	(default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	Keep the window width when windows are opened or closed and
+	'equalalways' is set.  Also for |CTRL-W_=|.
+	The width may be changed anyway when running out of room.
+
+						*'winminheight'* *'wmh'*
+'winminheight' 'wmh'	number	(default 1)
+			global
+			{not in Vi}
+			{not available when compiled without the |+windows|
+			feature}
+	The minimal height of a window, when it's not the current window.
+	This is a hard minimum, windows will never become smaller.
+	When set to zero, windows may be "squashed" to zero lines (i.e. just a
+	status bar) if necessary.  They will return to at least one line when
+	they become active (since the cursor has to have somewhere to go.)
+	Use 'winheight' to set the minimal height of the current window.
+	This option is only checked when making a window smaller.  Don't use a
+	large number, it will cause errors when opening more than a few
+	windows.  A value of 0 to 3 is reasonable.
+
+						*'winminwidth'* *'wmw'*
+'winminwidth' 'wmw'	number	(default 1)
+			global
+			{not in Vi}
+			{not available when compiled without the |+vertsplit|
+			feature}
+	The minimal width of a window, when it's not the current window.
+	This is a hard minimum, windows will never become smaller.
+	When set to zero, windows may be "squashed" to zero columns (i.e. just
+	a vertical separator) if necessary.  They will return to at least one
+	line when they become active (since the cursor has to have somewhere
+	to go.)
+	Use 'winwidth' to set the minimal width of the current window.
+	This option is only checked when making a window smaller.  Don't use a
+	large number, it will cause errors when opening more than a few
+	windows.  A value of 0 to 12 is reasonable.
+
+						*'winptydll'*
+'winptydll'		string	(default "winpty32.dll" or "winpty64.dll")
+			global
+			{not in Vi}
+			{only available when compiled with the |terminal|
+			feature on MS-Windows}
+	Specifies the name of the winpty shared library, used for the
+	|:terminal| command. The default depends on whether was build as a
+	32-bit or 64-bit executable.  If not found, "winpty.dll" is tried as
+	a fallback.
+	Environment variables are expanded |:set_env|.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'winwidth'* *'wiw'* *E592*
+'winwidth' 'wiw'	number	(default 20)
+			global
+			{not in Vi}
+			{not available when compiled without the |+vertsplit|
+			feature}
+	Minimal number of columns for the current window.  This is not a hard
+	minimum, Vim will use fewer columns if there is not enough room.  If
+	the current window is smaller, its size is increased, at the cost of
+	the width of other windows.  Set it to 999 to make the current window
+	always fill the screen.  Set it to a small number for normal editing.
+	The width is not adjusted after one of the commands to change the
+	width of the current window.
+	'winwidth' applies to the current window.  Use 'winminwidth' to set
+	the minimal width for other windows.
+
+						*'wrap'* *'nowrap'*
+'wrap'			boolean	(default on)
+			local to window
+			{not in Vi}
+	This option changes how text is displayed.  It doesn't change the text
+	in the buffer, see 'textwidth' for that.
+	When on, lines longer than the width of the window will wrap and
+	displaying continues on the next line.  When off lines will not wrap
+	and only part of long lines will be displayed.  When the cursor is
+	moved to a part that is not shown, the screen will scroll
+	horizontally.
+	The line will be broken in the middle of a word if necessary.  See
+	'linebreak' to get the break at a word boundary.
+	To make scrolling horizontally a bit more useful, try this: >
+		:set sidescroll=5
+		:set listchars+=precedes:<,extends:>
+<	See 'sidescroll', 'listchars' and |wrap-off|.
+	This option can't be set from a |modeline| when the 'diff' option is
+	on.
+
+						*'wrapmargin'* *'wm'*
+'wrapmargin' 'wm'	number	(default 0)
+			local to buffer
+	Number of characters from the right window border where wrapping
+	starts.  When typing text beyond this limit, an <EOL> will be inserted
+	and inserting continues on the next line.
+	Options that add a margin, such as 'number' and 'foldcolumn', cause
+	the text width to be further reduced.  This is Vi compatible.
+	When 'textwidth' is non-zero, this option is not used.
+	This option is set to 0 when 'paste' is set and restored when 'paste'
+	is reset.
+	See also 'formatoptions' and |ins-textwidth|.  {Vi: works differently
+	and less usefully}
+
+				   *'wrapscan'* *'ws'* *'nowrapscan'* *'nows'*
+'wrapscan' 'ws'		boolean	(default on)			*E384* *E385*
+			global
+	Searches wrap around the end of the file.  Also applies to |]s| and
+	|[s|, searching for spelling mistakes.
+
+						   *'write'* *'nowrite'*
+'write'			boolean	(default on)
+			global
+			{not in Vi}
+	Allows writing files.  When not set, writing a file is not allowed.
+	Can be used for a view-only mode, where modifications to the text are
+	still allowed.  Can be reset with the |-m| or |-M| command line
+	argument.  Filtering text is still possible, even though this requires
+	writing a temporary file.
+
+				   *'writeany'* *'wa'* *'nowriteany'* *'nowa'*
+'writeany' 'wa'		boolean	(default off)
+			global
+	Allows writing to any file with no need for "!" override.
+
+			     *'writebackup'* *'wb'* *'nowritebackup'* *'nowb'*
+'writebackup' 'wb'	boolean	(default on with |+writebackup| feature, off
+					otherwise)
+			global
+			{not in Vi}
+	Make a backup before overwriting a file.  The backup is removed after
+	the file was successfully written, unless the 'backup' option is
+	also on.
+	WARNING: Switching this option off means that when Vim fails to write
+	your buffer correctly and then, for whatever reason, Vim exits, you
+	lose both the original file and what you were writing.  Only reset
+	this option if your file system is almost full and it makes the write
+	fail (and make sure not to exit Vim until the write was successful).
+	See |backup-table| for another explanation.
+	When the 'backupskip' pattern matches, a backup is not made anyway.
+	NOTE: This option is set to the default value when 'compatible' is
+	set.
+
+						*'writedelay'* *'wd'*
+'writedelay' 'wd'	number	(default 0)
+			global
+			{not in Vi}
+	The number of milliseconds to wait for each character sent to the
+	screen.  When non-zero, characters are sent to the terminal one by
+	one.  For MS-DOS pcterm this does not work.  For debugging purposes.
+
+ vim:tw=78:ts=8:noet:ft=help:norl:
diff --git a/b/runtime/doc/os_haiku.txt b/runtime/doc/os_haiku.txt
new file mode 100644
index 0000000..ebcb247
--- /dev/null
+++ b/runtime/doc/os_haiku.txt
@@ -0,0 +1,223 @@
+*os_haiku.txt*	For Vim version 7.4.  Last change: 2013 Sep 12
+
+
+		  VIM REFERENCE MANUAL    by Bram Moolenaar
+
+							*Haiku*
+
+This file contains the particularities for the Haiku version of Vim.  For
+matters not discussed in this file, Vim behaves very much like the Unix
+|os_unix.txt| version.
+
+ 1. General			|haiku-general|
+ 2. Compiling Vim		|haiku-compiling|
+ 3. The Haiku GUI		|haiku-gui|
+ 4. The $VIM directory		|haiku-vimdir|
+ 5. The $BE_USER_SETTINGS
+    directory			|haiku-user-settings-dir|
+ 6. Drag & Drop			|haiku-dragndrop|
+ 7. Single Launch vs. Multiple
+    Launch			|haiku-launch|
+ 8. Fonts			|haiku-fonts|
+ 9. The meta key modifier	|haiku-meta|
+10. Mouse key mappings		|haiku-mouse|
+11. Color names			|haiku-colors|
+12. Credits			|haiku-support-credits|
+13. Bugs & things To Do		|haiku-bugs|
+
+
+1. General						*haiku-general*
+
+The default syntax highlighting mostly works with different foreground colors
+to highlight items.  This works best if you set your Terminal window to a
+darkish background and light letters.  Some middle-grey background (for
+instance (r,g,b)=(168,168,168)) with black letters also works nicely.
+
+
+2. Compiling Vim					*haiku-compiling*
+
+Vim can be compiled using the standard configure/make approach. Running
+./configure without any arguments or passing --enable-gui=haiku, will compile
+vim with the Haiku GUI support.  Run ./configure --help , to find out other
+features you can enable/disable.
+
+Now you should use "make" to compile Vim, then "make install" to install it.
+For seamless integration into the Haiku the GUI-less vim binary should be
+additionally installed over the GUI version. Typical build commands are: >
+
+  ./configure --prefix=`finddir B_COMMON_DIRECTORY` \
+    --datarootdir=`finddir B_COMMON_DATA_DIRECTORY` \
+    --mandir=`finddir B_COMMON_DOCUMENTATION_DIRECTORY`/man \
+  make clean
+  make install
+
+  ./configure --prefix=`finddir B_COMMON_DIRECTORY`  \
+    --datarootdir=`finddir B_COMMON_DATA_DIRECTORY` \
+    --mandir=`finddir B_COMMON_DOCUMENTATION_DIRECTORY`/man \
+    --disable-gui
+  make clean
+  make install
+
+
+3. The Haiku GUI					*haiku-gui*
+
+Normally Vim starts with the GUI if you start it as gvim or vim -g.  The vim
+version with GUI tries to determine if it was started from the Tracker instead
+of the Terminal, and if so, use the GUI anyway. However, the current detection
+scheme is fooled if you use the command "vim - </dev/null".
+
+Stuff that does not work yet:
+
+- Mouse up events are not generated when outside the window. This may be a bug in
+  Haiku. You can notice this when selecting text and moving the cursor outside
+  the window, then letting go of the mouse button.  Another way is when you
+  drag the scrollbar and do the same thing.  Because Vim still thinks you are
+  still playing with the scrollbar it won't change it itself. I provided a
+  workaround which kicks in when the window is activated or deactivated (so it
+  works best with focus- follows-mouse turned on).
+- The cursor does not flash (very low priority; I'm not sure I even like it
+  when it flashes)
+
+
+4. The $VIM directory					*haiku-vimdir*
+
+$VIM is the symbolic name for the place where Vims support files are stored.
+The default value for $VIM is set at compile time and can be determined with >
+
+  :version
+
+The normal value is /boot/common/data/vim.  If you don't like it you can
+set the VIM environment variable to override this, or set 'helpfile' in your
+.vimrc: >
+
+  :if version >= 500
+  :    set helpfile=~/vim/vim74/doc/help.txt
+  :    syntax on
+  :endif
+
+
+5. The $USER_SETTINGS_DIR directory		*haiku-user-settings-dir*
+
+$USER_SETTINGS_DIR is the symbolic name for the place where Haiku
+configuration and settings files are stored.
+
+The normal value is /boot/home/config/settings.
+
+
+6. Drag & Drop						*haiku-dragndrop*
+
+You can drop files and directories on either the Vim icon (starts a new Vim
+session, unless you use the File Types application to set Vim to be "Single
+Launch") or on the Vim window (starts editing the files).  Dropping a folder
+sets Vim's current working directory. |:cd| |:pwd| If you drop files or
+folders with either SHIFT key pressed, Vim changes directory to the folder
+that contains the first item dropped.  When starting Vim, there is no need to
+press shift: Vim behaves as if you do.
+
+Files dropped set the current argument list. |argument-list|
+
+
+7. Single Launch vs. Multiple Launch			*haiku-launch*
+
+As distributed Vim's Application Flags (as seen in the FileTypes preference)
+are set to Multiple Launch.  If you prefer, you can set them to Single Launch
+instead.  Attempts to start a second copy of Vim will cause the first Vim to
+open the files instead.  This works from the Tracker but also from the command
+line.  In the latter case, non-file (option) arguments are not supported.
+Another drawback of the Single Launch is silent ignore of "Open With ..."
+requests by vim instance that running as non-GUI application even GUI support
+was compiled in. Vim instance running with GUI has no such problems.
+
+NB: Only the GUI version has a BApplication (and hence Application Flags).
+This section does not apply to the GUI-less version, should you compile one.
+
+
+8. Fonts						*haiku-fonts*
+
+Set fonts with >
+
+  :set guifont=DejaVu_Sans_Mono/Book/12
+
+where the first part is the font family, the second part the style, and the
+third part the size.  You can use underscores instead of spaces in family and
+style.
+
+Best results are obtained with monospaced fonts.  Vim attempts to use all
+fonts in B_FIXED_SPACING mode but apparently this does not work for
+proportional fonts (despite what the BeBook says).
+
+To verify which encodings are supported by the current font give the >
+
+  :digraphs
+
+command, which lists a bunch of characters with their ISO Latin 1 encoding.
+If, for instance, there are "box" characters among them, or the last character
+isn't a dotted-y, then for this font the encoding does not work.
+
+If the font you specify is unavailable, you get the system fixed font.
+
+GUI Font Selection Dialog is available at giving the >
+
+  :set guifont=*
+
+command.
+
+
+9. The meta key modifier				*haiku-meta*
+
+The META key modifier is obtained by the left or right OPTION keys.  This is
+because the ALT (aka COMMAND) keys are not passed to applications.
+
+
+10. Mouse key mappings					*haiku-mouse*
+
+Vim calls the various mouse buttons LeftMouse, MiddleMouse and RightMouse.  If
+you use the default Mouse preference settings these names indeed correspond to
+reality.  Vim uses this mapping:
+
+    Button 1 -> LeftMouse,
+    Button 2 -> RightMouse,
+    Button 3 -> MiddleMouse.
+
+If your mouse has fewer than 3 buttons you can provide your own mapping from
+mouse clicks with modifier(s) to other mouse buttons.  See the file
+$VIM/macros/swapmous.vim for an example.		|gui-mouse-mapping|
+
+
+11. Color names						*haiku-colors*
+
+Vim has a number of color names built-in.  Additional names are read from the
+file $VIMRUNTIME/rgb.txt, if present.  This file is basically the color
+database from X.  Names used from this file are cached for efficiency.
+
+
+12. GUI Toolbar Images					*haiku-toolbar-images*
+
+Alternative set of toolbar images should be the PNG image of any height you
+like. Image width is calculated to contain at least 32 buttons in one-row
+cells.
+The image should be stored under the name $VIRUNTIME/bitmaps/builtin-tools.png
+More info about the buttons assignment are at |builtin-tools|.
+
+
+13. Credits						*haiku-support-credits*
+
+Haiku port is based on work done for BeOS version by many people
+ - BeBox GUI support Copyright 1998 by Olaf Seibert;
+ - Ported to R4 by Richard Offer <richard@whitequeen.com> Jul 99;
+ - Those who contributed, not listed above but not forgotten;
+ - Haiku support by Siarzhuk Zharski <imker@gmx.li> Apr-Mai 2009.
+
+Thank you, all!
+
+
+13. Bugs & things To Do					*haiku-bugs*
+
+The port is under development now and far away from the perfect state. Bug
+reports, patches and wishes are welcome.
+
+
+ -Siarzhuk Zharski <imker@gmx.li>
+
+
+ vim:tw=78:ts=8:ft=help:norl:
diff --git a/runtime/doc/starting.txt b/runtime/doc/starting.txt
index b060c45..6796ce7 100644
--- a/runtime/doc/starting.txt
+++ b/runtime/doc/starting.txt
@@ -806,6 +806,7 @@ accordingly.  Vim proceeds in this order:
 				or $VIM/_vimrc
 		Amiga		s:.vimrc, home:.vimrc, home:vimfiles:vimrc
 				or $VIM/.vimrc
+		Haiku	    $HOME/config/settings/vim/vimrc
 
 	The files are searched in the order specified above and only the first
 	one that is found is read.
@@ -852,6 +853,7 @@ accordingly.  Vim proceeds in this order:
 		    "$HOME/_vimrc"	   (for MS-DOS and Win32) (*)
 		    "$HOME/vimfiles/vimrc" (for MS-DOS and Win32) (*)
 		    "$VIM/_vimrc"	   (for MS-DOS and Win32) (*)
+		    "$HOME/config/settings/vim/vimrc"	(for Haiku) (*)
 		Note: For Unix, OS/2 and Amiga, when ".vimrc" does not exist,
 		"_vimrc" is also tried, in case an MS-DOS compatible file
 		system is used.  For MS-DOS and Win32 ".vimrc" is checked
@@ -966,6 +968,7 @@ sessions.  Put it in a place so that it will be found by 3b:
 	~/.vimrc	(Unix and OS/2)
 	s:.vimrc	(Amiga)
 	$VIM\_vimrc	(MS-DOS and Win32)
+	~/config/settings/vim/vimrc	(Haiku)
 Note that creating a vimrc file will cause the 'compatible' option to be off
 by default.  See |compatible-default|.
 
diff --git a/b/runtime/doc/starting.txt.orig b/runtime/doc/starting.txt.orig
new file mode 100644
index 0000000..b060c45
--- /dev/null
+++ b/runtime/doc/starting.txt.orig
@@ -0,0 +1,1691 @@
+*starting.txt*  For Vim version 8.1.  Last change: 2018 May 05
+
+
+		  VIM REFERENCE MANUAL    by Bram Moolenaar
+
+
+Starting Vim						*starting*
+
+1. Vim arguments		|vim-arguments|
+2. Vim on the Amiga		|starting-amiga|
+3. Running eVim			|evim-keys|
+4. Initialization		|initialization|
+5. $VIM and $VIMRUNTIME		|$VIM|
+6. Suspending			|suspend|
+7. Exiting			|exiting|
+8. Saving settings		|save-settings|
+9. Views and Sessions		|views-sessions|
+10. The viminfo file		|viminfo-file|
+
+==============================================================================
+1. Vim arguments					*vim-arguments*
+
+Most often, Vim is started to edit a single file with the command
+
+	vim filename					*-vim*
+
+More generally, Vim is started with:
+
+	vim [option | filename] ..
+
+Option arguments and file name arguments can be mixed, and any number of them
+can be given.  However, watch out for options that take an argument.
+
+For compatibility with various Vi versions, see	|cmdline-arguments|.
+
+Exactly one out of the following five items may be used to choose how to
+start editing:
+
+							*-file* *---*
+filename	One or more file names.  The first one will be the current
+		file and read into the buffer.  The cursor will be positioned
+		on the first line of the buffer.
+		To avoid a file name starting with a '-' being interpreted as
+		an option, precede the arglist with "--", e.g.: >
+			vim -- -filename
+<		All arguments after the "--" will be interpreted as file names,
+		no other options or "+command" argument can follow.
+		For behavior of quotes on MS-Windows, see |win32-quotes|.
+
+							*--*
+-		This argument can mean two things, depending on whether Ex
+		mode is to be used.
+
+		Starting in Normal mode: >
+			vim -
+			ex -v -
+<		Start editing a new buffer, which is filled with text
+		that is read from stdin.  The commands that would normally be
+		read from stdin will now be read from stderr.  Example: >
+			find . -name "*.c" -print | vim -
+<		The buffer will not be marked as modified, so that it's easy
+		to exit.  Be careful to mark it as modified if you don't want
+		to accidentally lose it.  Example: >
+			ls | view -
+<
+		Starting in Ex mode: >
+			ex -
+			vim -e -
+			exim -
+			vim -E
+<		Start editing in silent mode.  See |-s-ex|.
+
+							*-t* *-tag*
+-t {tag}	A tag.  "tag" is looked up in the tags file, the associated
+		file becomes the current file, and the associated command is
+		executed.  Mostly this is used for C programs, in which case
+		"tag" often is a function name.  The effect is that the file
+		containing that function becomes the current file and the
+		cursor is positioned on the start of the function (see
+		|tags|).
+
+							*-q* *-qf*
+-q [errorfile]	QuickFix mode.  The file with the name [errorfile] is read
+		and the first error is displayed.  See |quickfix|.
+		If [errorfile] is not given, the 'errorfile' option is used
+		for the file name.  See 'errorfile' for the default value.
+		{not in Vi}
+
+(nothing)	Without one of the four items above, Vim will start editing a
+		new buffer.  It's empty and doesn't have a file name.
+
+
+The startup mode can be changed by using another name instead of "vim", which
+is equal to giving options:
+ex	vim -e	    Start in Ex mode (see |Ex-mode|).		    *ex*
+exim	vim -E	    Start in improved Ex mode (see |Ex-mode|).	    *exim*
+			(normally not installed)
+view	vim -R	    Start in read-only mode (see |-R|).		    *view*
+gvim	vim -g	    Start the GUI (see |gui|).			    *gvim*
+gex	vim -eg	    Start the GUI in Ex mode.			  *gex*
+gview	vim -Rg	    Start the GUI in read-only mode.		  *gview*
+rvim	vim -Z	    Like "vim", but in restricted mode (see |-Z|)   *rvim*
+rview	vim -RZ	    Like "view", but in restricted mode.	  *rview*
+rgvim	vim -gZ	    Like "gvim", but in restricted mode.	  *rgvim*
+rgview	vim -RgZ    Like "gview", but in restricted mode.	  *rgview*
+evim    vim -y      Easy Vim: set 'insertmode' (see |-y|)	    *evim*
+eview   vim -yR     Like "evim" in read-only mode		  *eview*
+vimdiff vim -d	    Start in diff mode |diff-mode|
+gvimdiff vim -gd    Start in diff mode |diff-mode|
+
+Additional characters may follow, they are ignored.  For example, you can have
+"gvim-5" to start the GUI.  You must have an executable by that name then, of
+course.
+
+On Unix, you would normally have one executable called Vim, and links from the
+different startup-names to that executable.  If your system does not support
+links and you do not want to have several copies of the executable, you could
+use an alias instead.  For example: >
+	alias view   vim -R
+	alias gvim   vim -g
+<
+							*startup-options*
+The option arguments may be given in any order.  Single-letter options can be
+combined after one dash.  There can be no option arguments after the "--"
+argument.
+
+On VMS all option arguments are assumed to be lowercase, unless preceded with
+a slash.  Thus "-R" means recovery and "-/R" readonly.
+
+--help							*-h* *--help* *-?*
+-?
+-h		Give usage (help) message and exit.  {not in Vi}
+		See |info-message| about capturing the text.
+
+							*--version*
+--version	Print version information and exit.  Same output as for
+		|:version| command.  {not in Vi}
+		See |info-message| about capturing the text.
+
+							*--noplugin*
+--noplugin	Skip loading plugins.  Resets the 'loadplugins' option.
+		{not in Vi}
+		Note that the |-u| argument may also disable loading plugins:
+			argument   load: vimrc files  plugins  defaults.vim ~
+			(nothing)	     yes	yes	  yes
+			-u NONE		     no		no	  no
+			-u DEFAULTS	     no		no	  yes
+			-u NORC		     no		yes	  no
+			--noplugin	     yes	no	  yes
+
+--startuptime {fname}					*--startuptime*
+		During startup write timing messages to the file {fname}.
+		This can be used to find out where time is spent while loading
+		your .vimrc, plugins and opening the first file.
+		When {fname} already exists new messages are appended.
+		(Only available when compiled with the |+startuptime|
+		feature).
+
+							*--literal*
+--literal	Take file names literally, don't expand wildcards.  Not needed
+		for Unix, because Vim always takes file names literally (the
+		shell expands wildcards).
+		Applies to all the names, also the ones that come before this
+		argument.
+
+							*-+*
++[num]		The cursor will be positioned on line "num" for the first
+		file being edited.  If "num" is missing, the cursor will be
+		positioned on the last line.
+
+							*-+/*
++/{pat}		The cursor will be positioned on the first line containing
+		"pat" in the first file being edited (see |pattern| for the
+		available search patterns).  The search starts at the cursor
+		position, which can be the first line or the cursor position
+		last used from |viminfo|. To force a search from the first
+		line use "+1 +/pat".
+
++{command}						*-+c* *-c*
+-c {command}	{command} will be executed after the first file has been
+		read (and after autocommands and modelines for that file have
+		been processed).  "command" is interpreted as an Ex command.
+		If the "command" contains spaces, it must be enclosed in
+		double quotes (this depends on the shell that is used).
+		Example: >
+			vim  "+set si"  main.c
+			vim  "+find stdio.h"
+			vim  -c "set ff=dos"  -c wq  mine.mak
+<
+		Note: You can use up to 10 "+" or "-c" arguments in a Vim
+		command.  They are executed in the order given.  A "-S"
+		argument counts as a "-c" argument as well.
+		{Vi only allows one command}
+
+--cmd {command}						*--cmd*
+		{command} will be executed before processing any vimrc file.
+		Otherwise it acts like -c {command}.  You can use up to 10 of
+		these commands, independently from "-c" commands.
+		{not in Vi}
+
+							*-S*
+-S {file}	The {file} will be sourced after the first file has been read.
+		This is an easy way to do the equivalent of: >
+			-c "source {file}"
+<		It can be mixed with "-c" arguments and repeated like "-c".
+		The limit of 10 "-c" arguments applies here as well.
+		{file} cannot start with a "-".
+		{not in Vi}
+
+-S		Works like "-S Session.vim".  Only when used as the last
+		argument or when another "-" option follows.
+
+							*-r*
+-r		Recovery mode.  Without a file name argument, a list of
+		existing swap files is given.  With a file name, a swap file
+		is read to recover a crashed editing session.  See
+		|crash-recovery|.
+
+							*-L*
+-L		Same as -r.  {only in some versions of Vi: "List recoverable
+		edit sessions"}
+
+							*-R*
+-R		Readonly mode.  The 'readonly' option will be set for all the
+		files being edited.  You can still edit the buffer, but will
+		be prevented from accidentally overwriting a file.  If you
+		forgot that you are in View mode and did make some changes,
+		you can overwrite a file by adding an exclamation mark to
+		the Ex command, as in ":w!".  The 'readonly' option can be
+		reset with ":set noro" (see the options chapter, |options|).
+		Subsequent edits will not be done in readonly mode.  Calling
+		the executable "view" has the same effect as the -R argument.
+		The 'updatecount' option will be set to 10000, meaning that
+		the swap file will not be updated automatically very often.
+		See |-M| for disallowing modifications.
+
+							*-m*
+-m		Modifications not allowed to be written.  The 'write' option
+		will be reset, so that writing files is disabled.  However,
+		the 'write' option can be set to enable writing again.
+		{not in Vi}
+
+							*-M*
+-M		Modifications not allowed.  The 'modifiable' option will be
+		reset, so that changes are not allowed.  The 'write' option
+		will be reset, so that writing files is disabled.  However,
+		the 'modifiable' and 'write' options can be set to enable
+		changes and writing.
+		{not in Vi}
+
+						*-Z* *restricted-mode* *E145*
+-Z		Restricted mode.  All commands that make use of an external
+		shell are disabled.  This includes suspending with CTRL-Z,
+		":sh", filtering, the system() function, backtick expansion,
+		delete(), rename(), mkdir(), writefile(), libcall(),
+		job_start(), etc.
+		{not in Vi}
+
+							*-g*
+-g		Start Vim in GUI mode.  See |gui|. For the opposite see |-v|.
+		{not in Vi}
+
+							*-v*
+-v		Start Ex in Vi mode.  Only makes a difference when the
+		executable is called "ex" or "gvim".  For gvim the GUI is not
+		started if possible.
+
+							*-e*
+-e		Start Vim in Ex mode |Q|.  Only makes a difference when the
+		executable is not called "ex".
+
+							*-E*
+-E		Start Vim in improved Ex mode |gQ|.  Only makes a difference
+		when the executable is not called "exim".
+		{not in Vi}
+
+							*-s-ex*
+-s		Silent or batch mode.  Only when Vim was started as "ex" or
+		when preceded with the "-e" argument.  Otherwise see |-s|,
+		which does take an argument while this use of "-s" doesn't.
+		To be used when Vim is used to execute Ex commands from a file
+		instead of a terminal.  Switches off most prompts and
+		informative messages.  Also warnings and error messages.
+		The output of these commands is displayed (to stdout):
+			:print
+			:list
+			:number
+			:set      to display option values.
+		When 'verbose' is non-zero messages are printed (for
+		debugging, to stderr).
+		'term' and $TERM are not used.
+		If Vim appears to be stuck try typing "qa!<Enter>".  You don't
+		get a prompt thus you can't see Vim is waiting for you to type
+		something.
+		Initializations are skipped (except the ones given with the
+		"-u" argument).
+		Example: >
+			vim -e -s  < thefilter  thefile
+<
+							*-b*
+-b		Binary mode.  File I/O will only recognize <NL> to separate
+		lines.  The 'expandtab' option will be reset.  The 'textwidth'
+		option is set to 0.  'modeline' is reset.  The 'binary' option
+		is set.  This is done after reading the vimrc/exrc files but
+		before reading any file in the arglist.  See also
+		|edit-binary|.  {not in Vi}
+
+							*-l*
+-l		Lisp mode.  Sets the 'lisp' and 'showmatch' options on.
+
+							*-A*
+-A		Arabic mode.  Sets the 'arabic' option on.  (Only when
+		compiled with the |+arabic| features (which include
+		|+rightleft|), otherwise Vim gives an error message
+		and exits.)  {not in Vi}
+
+							*-F*
+-F		Farsi mode.  Sets the 'fkmap' and 'rightleft' options on.
+		(Only when compiled with |+rightleft| and |+farsi| features,
+		otherwise Vim gives an error message and exits.)  {not in Vi}
+
+							*-H*
+-H		Hebrew mode.  Sets the 'hkmap' and 'rightleft' options on.
+		(Only when compiled with the |+rightleft| feature, otherwise
+		Vim gives an error message and exits.)  {not in Vi}
+
+							*-V* *verbose*
+-V[N]		Verbose.  Sets the 'verbose' option to [N] (default: 10).
+		Messages will be given for each file that is ":source"d and
+		for reading or writing a viminfo file.  Can be used to find
+		out what is happening upon startup and exit.  {not in Vi}
+		Example: >
+			vim -V8 foobar
+
+-V[N]{filename}
+		Like -V and set 'verbosefile' to {filename}.  The result is
+		that messages are not displayed but written to the file
+		{filename}.  {filename} must not start with a digit.
+		Example: >
+			vim -V20vimlog foobar
+<
+							*-D*
+-D		Debugging.  Go to debugging mode when executing the first
+		command from a script. |debug-mode|
+		{not available when compiled without the |+eval| feature}
+		{not in Vi}
+
+							*-C*
+-C		Compatible mode.  Sets the 'compatible' option.  You can use
+		this to get 'compatible', even though a .vimrc file exists.
+		Keep in mind that the command ":set nocompatible" in some
+		plugin or startup script overrules this, so you may end up
+		with 'nocompatible' anyway.  To find out, use: >
+			:verbose set compatible?
+<		Several plugins won't work with 'compatible' set.  You may
+		want to set it after startup this way: >
+			vim "+set cp" filename
+<		Also see |compatible-default|.  {not in Vi}
+
+							*-N*
+-N		Not compatible mode.  Resets the 'compatible' option.  You can
+		use this to get 'nocompatible', when there is no .vimrc file
+		or when using "-u NONE".
+		Also see |compatible-default|.  {not in Vi}
+
+							*-y* *easy*
+-y		Easy mode.  Implied for |evim| and |eview|.  Starts with
+		'insertmode' set and behaves like a click-and-type editor.
+		This sources the script $VIMRUNTIME/evim.vim.  Mappings are
+		set up to work like most click-and-type editors, see
+		|evim-keys|.  The GUI is started when available.
+		{not in Vi}
+
+							*-n*
+-n		No swap file will be used.  Recovery after a crash will be
+		impossible.  Handy if you want to view or edit a file on a
+		very slow medium (e.g., a floppy).
+		Can also be done with ":set updatecount=0".  You can switch it
+		on again by setting the 'updatecount' option to some value,
+		e.g., ":set uc=100".
+		NOTE: Don't combine -n with -b, making -nb, because that has a
+		different meaning: |-nb|.
+		'updatecount' is set to 0 AFTER executing commands from a
+		vimrc file, but before the GUI initializations.  Thus it
+		overrides a setting for 'updatecount' in a vimrc file, but not
+		in a gvimrc file.  See |startup|.
+		When you want to reduce accesses to the disk (e.g., for a
+		laptop), don't use "-n", but set 'updatetime' and
+		'updatecount' to very big numbers, and type ":preserve" when
+		you want to save your work.  This way you keep the possibility
+		for crash recovery.
+		{not in Vi}
+
+							*-o*
+-o[N]		Open N windows, split horizontally.  If [N] is not given,
+		one window is opened for every file given as argument.  If
+		there is not enough room, only the first few files get a
+		window.  If there are more windows than arguments, the last
+		few windows will be editing an empty file.
+		{not in Vi}
+
+							*-O*
+-O[N]		Open N windows, split vertically.  Otherwise it's like -o.
+		If both the -o and the -O option are given, the last one on
+		the command line determines how the windows will be split.
+		{not in Vi}
+
+							*-p*
+-p[N]		Open N tab pages.  If [N] is not given, one tab page is opened
+		for every file given as argument.  The maximum is set with
+		'tabpagemax' pages (default 10).  If there are more tab pages
+		than arguments, the last few tab pages will be editing an
+		empty file.  Also see |tabpage|.
+		{not in Vi}
+
+							*-T*
+-T {terminal}	Set the terminal type to "terminal".  This influences the
+		codes that Vim will send to your terminal.  This is normally
+		not needed, because Vim will be able to find out what type
+		of terminal you are using.  (See |terminal-info|.)  {not in Vi}
+
+							*--not-a-term*
+--not-a-term	Tells Vim that the user knows that the input and/or output is
+		not connected to a terminal.  This will avoid the warning and
+		the two second delay that would happen.
+		Also avoids the "Reading from stdin..." message.
+		{not in Vi}
+
+							*--ttyfail*
+--ttyfail	When the stdin or stdout is not a terminal (tty) then exit
+		right away.
+
+							*-d*
+-d		Start in diff mode, like |vimdiff|.
+		{not in Vi} {not available when compiled without the |+diff|
+		feature}
+
+-d {device}	Only on the Amiga and when not compiled with the |+diff|
+		feature.  Works like "-dev".
+							*-dev*
+-dev {device}	Only on the Amiga: The {device} is opened to be used for
+		editing.
+		Normally you would use this to set the window position and
+		size: "-d con:x/y/width/height", e.g.,
+		"-d con:30/10/600/150".  But you can also use it to start
+		editing on another device, e.g., AUX:.  {not in Vi}
+							*-f*
+-f		GUI: Do not disconnect from the program that started Vim.
+		'f' stands for "foreground".  If omitted, the GUI forks a new
+		process and exits the current one.  "-f" should be used when
+		gvim is started by a program that will wait for the edit
+		session to finish (e.g., mail or readnews).  If you want gvim
+		never to fork, include 'f' in 'guioptions' in your |gvimrc|.
+		Careful: You can use "-gf" to start the GUI in the foreground,
+		but "-fg" is used to specify the foreground color.  |gui-fork|
+
+		Amiga: Do not restart Vim to open a new window.  This
+		option should be used when Vim is started by a program that
+		will wait for the edit session to finish (e.g., mail or
+		readnews).  See |amiga-window|.
+
+		MS-Windows: This option is not supported.  However, when
+		running Vim with an installed vim.bat or gvim.bat file it
+		works.
+		{not in Vi}
+
+
+							*--nofork*
+--nofork	GUI: Do not fork.  Same as |-f|.
+							*-u* *E282*
+-u {vimrc}	The file {vimrc} is read for initializations.  Most other
+		initializations are skipped; see |initialization|.
+
+		This can be used to start Vim in a special mode, with special
+		mappings and settings.  A shell alias can be used to make
+		this easy to use.  For example: >
+			alias vimc vim -u ~/.c_vimrc !*
+<		Also consider using autocommands; see |autocommand|.
+
+		When {vimrc} is equal to "NONE" (all uppercase), all
+		initializations from files and environment variables are
+		skipped, including reading the |gvimrc| file when the GUI
+		starts.  Loading plugins is also skipped.
+
+		When {vimrc} is equal to "NORC" (all uppercase), this has the
+		same effect as "NONE", but loading plugins is not skipped.
+
+		When {vimrc} is equal to "DEFAULTS" (all uppercase), this has
+		the same effect as "NONE", but the |defaults.vim| script is
+		loaded, which will also set 'nocompatible'.  Also see
+		|--clean|.
+
+		Using the "-u" argument with another argument than DEFAULTS
+		has the side effect that the 'compatible' option will be on by
+		default.  This can have unexpected effects.  See
+		|'compatible'|.
+		{not in Vi}
+
+							*-U* *E230*
+-U {gvimrc}	The file {gvimrc} is read for initializations when the GUI
+		starts.  Other GUI initializations are skipped.  When {gvimrc}
+		is equal to "NONE", no file is read for GUI initializations at
+		all.  |gui-init|
+		Exception: Reading the system-wide menu file is always done.
+		{not in Vi}
+
+							*-i*
+-i {viminfo}	The file "viminfo" is used instead of the default viminfo
+		file.  If the name "NONE" is used (all uppercase), no viminfo
+		file is read or written, even if 'viminfo' is set or when
+		":rv" or ":wv" are used.  See also |viminfo-file|.
+		{not in Vi}
+
+							*--clean*
+--clean		Similar to "-u DEFAULTS -U NONE -i NONE":
+		- initializations from files and environment variables is
+		  skipped
+		-'runtimepath'and 'packpath' are set to exclude home
+		  directory entries (does not happen with -u DEFAULTS).
+		- the |defaults.vim| script is loaded, which implies
+		  'nocompatible': use Vim defaults
+		- no |gvimrc| script is loaded
+		- no viminfo file is read or written
+
+							*-x*
+-x		Use encryption to read/write files.  Will prompt for a key,
+		which is then stored in the 'key' option.  All writes will
+		then use this key to encrypt the text.  The '-x' argument is
+		not needed when reading a file, because there is a check if
+		the file that is being read has been encrypted, and Vim asks
+		for a key automatically. |encryption|
+
+							*-X*
+-X		Do not try connecting to the X server to get the current
+		window title and copy/paste using the X clipboard.  This
+		avoids a long startup time when running Vim in a terminal
+		emulator and the connection to the X server is slow.
+		See |--startuptime| to find out if affects you.
+		Only makes a difference on Unix or VMS, when compiled with the
+		|+X11| feature.  Otherwise it's ignored.
+		To disable the connection only for specific terminals, see the
+		'clipboard' option.
+		When the X11 Session Management Protocol (XSMP) handler has
+		been built in, the -X option also disables that connection as
+		it, too, may have undesirable delays.
+		When the connection is desired later anyway (e.g., for
+		client-server messages), call the |serverlist()| function.
+		This does not enable the XSMP handler though.
+		{not in Vi}
+
+							*-s*
+-s {scriptin}	The script file "scriptin" is read.  The characters in the
+		file are interpreted as if you had typed them.  The same can
+		be done with the command ":source! {scriptin}".  If the end
+		of the file is reached before the editor exits, further
+		characters are read from the keyboard.  Only works when not
+		started in Ex mode, see |-s-ex|.  See also |complex-repeat|.
+		{not in Vi}
+
+							*-w_nr*
+-w {number}
+-w{number}	Set the 'window' option to {number}.
+
+							*-w*
+-w {scriptout}	All the characters that you type are recorded in the file
+		"scriptout", until you exit Vim.  This is useful if you want
+		to create a script file to be used with "vim -s" or
+		":source!".  When the "scriptout" file already exists, new
+		characters are appended.  See also |complex-repeat|.
+		{scriptout} cannot start with a digit.
+		{not in Vi}
+
+							*-W*
+-W {scriptout}	Like -w, but do not append, overwrite an existing file.
+		{not in Vi}
+
+--remote [+{cmd}] {file} ...
+		Open the {file} in another Vim that functions as a server.
+		Any non-file arguments must come before this.
+		See |--remote|. {not in Vi}
+
+--remote-silent [+{cmd}] {file} ...
+		Like --remote, but don't complain if there is no server.
+		See |--remote-silent|. {not in Vi}
+
+--remote-wait [+{cmd}] {file} ...
+		Like --remote, but wait for the server to finish editing the
+		file(s).
+		See |--remote-wait|. {not in Vi}
+
+--remote-wait-silent [+{cmd}] {file} ...
+		Like --remote-wait, but don't complain if there is no server.
+		See |--remote-wait-silent|. {not in Vi}
+
+--servername {name}
+		Specify the name of the Vim server to send to or to become.
+		See |--servername|. {not in Vi}
+
+--remote-send {keys}
+		Send {keys} to a Vim server and exit.
+		See |--remote-send|. {not in Vi}
+
+--remote-expr {expr}
+		Evaluate {expr} in another Vim that functions as a server.
+		The result is printed on stdout.
+		See |--remote-expr|. {not in Vi}
+
+--serverlist	Output a list of Vim server names and exit.  See
+		|--serverlist|. {not in Vi}
+
+--socketid {id}						*--socketid*
+		GTK+ GUI Vim only.  Make gvim try to use GtkPlug mechanism, so
+		that it runs inside another window.  See |gui-gtk-socketid|
+		for details. {not in Vi}
+
+--windowid {id}						*--windowid*
+		Win32 GUI Vim only.  Make gvim try to use the window {id} as a
+		parent, so that it runs inside that window.  See
+		|gui-w32-windowid| for details. {not in Vi}
+
+--echo-wid						*--echo-wid*
+		GTK+ GUI Vim only.  Make gvim echo the Window ID on stdout,
+		which can be used to run gvim in a kpart widget.  The format
+		of the output is: >
+			WID: 12345\n
+<		{not in Vi}
+
+--role {role}						*--role*
+		GTK+ 2 GUI only.  Set the role of the main window to {role}.
+		The window role can be used by a window manager to uniquely
+		identify a window, in order to restore window placement and
+		such.  The --role argument is passed automatically when
+		restoring the session on login.  See |gui-gnome-session|
+		{not in Vi}
+
+-P {parent-title}				*-P* *MDI* *E671* *E672*
+		Win32 only: Specify the title of the parent application.  When
+		possible, Vim will run in an MDI window inside the
+		application.
+		{parent-title} must appear in the window title of the parent
+		application.  Make sure that it is specific enough.
+		Note that the implementation is still primitive.  It won't
+		work with all applications and the menu doesn't work.
+
+-nb							*-nb*
+-nb={fname}
+-nb:{hostname}:{addr}:{password}
+		Attempt connecting to Netbeans and become an editor server for
+		it.  The second form specifies a file to read connection info
+		from.  The third form specifies the hostname, address and
+		password for connecting to Netbeans. |netbeans-run|
+		{only available when compiled with the |+netbeans_intg|
+		feature; if not then -nb will make Vim exit}
+
+If the executable is called "view", Vim will start in Readonly mode.  This is
+useful if you can make a hard or symbolic link from "view" to "vim".
+Starting in Readonly mode can also be done with "vim -R".
+
+If the executable is called "ex", Vim will start in "Ex" mode.  This means it
+will accept only ":" commands.  But when the "-v" argument is given, Vim will
+start in Normal mode anyway.
+
+Additional arguments are available on unix like systems when compiled with
+X11 GUI support.  See |gui-resources|.
+
+==============================================================================
+2. Vim on the Amiga					*starting-amiga*
+
+Starting Vim from the Workbench				*workbench*
+-------------------------------
+
+Vim can be started from the Workbench by clicking on its icon twice.  It will
+then start with an empty buffer.
+
+Vim can be started to edit one or more files by using a "Project" icon.  The
+"Default Tool" of the icon must be the full pathname of the Vim executable.
+The name of the ".info" file must be the same as the name of the text file.
+By clicking on this icon twice, Vim will be started with the file name as
+current file name, which will be read into the buffer (if it exists).  You can
+edit multiple files by pressing the shift key while clicking on icons, and
+clicking twice on the last one.  The "Default Tool" for all these icons must
+be the same.
+
+It is not possible to give arguments to Vim, other than file names, from the
+workbench.
+
+Vim window						*amiga-window*
+----------
+
+Vim will run in the CLI window where it was started.  If Vim was started with
+the "run" or "runback" command, or if Vim was started from the workbench, it
+will open a window of its own.
+
+Technical detail:
+	To open the new window a little trick is used.  As soon as Vim
+	recognizes that it does not run in a normal CLI window, it will
+	create a script file in "t:".  This script file contains the same
+	command as the one Vim was started with, and an "endcli" command.
+	This script file is then executed with a "newcli" command (the "c:run"
+	and "c:newcli" commands are required for this to work).  The script
+	file will hang around until reboot, or until you delete it.  This
+	method is required to get the ":sh" and ":!" commands to work
+	correctly.  But when Vim was started with the -f option (foreground
+	mode), this method is not used.  The reason for this is that
+	when a program starts Vim with the -f option it will wait for Vim to
+	exit.  With the script trick, the calling program does not know when
+	Vim exits.  The -f option can be used when Vim is started by a mail
+	program which also waits for the edit session to finish.  As a
+	consequence, the ":sh" and ":!" commands are not available when the
+	-f option is used.
+
+Vim will automatically recognize the window size and react to window
+resizing.  Under Amiga DOS 1.3, it is advised to use the fastfonts program,
+"FF", to speed up display redrawing.
+
+==============================================================================
+3. Running eVim							*evim-keys*
+
+EVim runs Vim as click-and-type editor.  This is very unlike the original Vi
+idea.  But it helps for people that don't use Vim often enough to learn the
+commands.  Hopefully they will find out that learning to use Normal mode
+commands will make their editing much more effective.
+
+In Evim these options are changed from their default value:
+
+	:set nocompatible	Use Vim improvements
+	:set insertmode		Remain in Insert mode most of the time
+	:set hidden		Keep invisible buffers loaded
+	:set backup		Keep backup files (not for VMS)
+	:set backspace=2	Backspace over everything
+	:set autoindent		auto-indent new lines
+	:set history=50		keep 50 lines of Ex commands
+	:set ruler		show the cursor position
+	:set incsearch		show matches halfway typing a pattern
+	:set mouse=a		use the mouse in all modes
+	:set hlsearch		highlight all matches for a search pattern
+	:set whichwrap+=<,>,[,]  <Left> and <Right> wrap around line breaks
+	:set guioptions-=a	non-Unix only: don't do auto-select
+
+Key mappings:
+	<Down>		moves by screen lines rather than file lines
+	<Up>		idem
+	Q		does "gq", formatting, instead of Ex mode
+	<BS>		in Visual mode: deletes the selection
+	CTRL-X		in Visual mode: Cut to clipboard
+	<S-Del>		idem
+	CTRL-C		in Visual mode: Copy to clipboard
+	<C-Insert>	idem
+	CTRL-V		Pastes from the clipboard (in any mode)
+	<S-Insert>	idem
+	CTRL-Q		do what CTRL-V used to do
+	CTRL-Z		undo
+	CTRL-Y		redo
+	<M-Space>	system menu
+	CTRL-A		select all
+	<C-Tab>		next window, CTRL-W w
+	<C-F4>		close window, CTRL-W c
+
+Additionally:
+- ":behave mswin" is used |:behave|
+- syntax highlighting is enabled
+- filetype detection is enabled, filetype plugins and indenting is enabled
+- in a text file 'textwidth' is set to 78
+
+One hint: If you want to go to Normal mode to be able to type a sequence of
+commands, use CTRL-L. |i_CTRL-L|
+
+==============================================================================
+4. Initialization				*initialization* *startup*
+
+This section is about the non-GUI version of Vim.  See |gui-fork| for
+additional initialization when starting the GUI.
+
+At startup, Vim checks environment variables and files and sets values
+accordingly.  Vim proceeds in this order:
+
+1. Set the 'shell' and 'term' option		*SHELL* *COMSPEC* *TERM*
+	The environment variable SHELL, if it exists, is used to set the
+	'shell' option.  On MS-DOS and Win32, the COMSPEC variable is used
+	if SHELL is not set.
+	The environment variable TERM, if it exists, is used to set the 'term'
+	option.  However, 'term' will change later when starting the GUI (step
+	8 below).
+
+2. Process the arguments
+	The options and file names from the command that start Vim are
+	inspected.  Buffers are created for all files (but not loaded yet).
+	The |-V| argument can be used to display or log what happens next,
+	useful for debugging the initializations.
+
+3. Execute Ex commands, from environment variables and/or files
+	An environment variable is read as one Ex command line, where multiple
+	commands must be separated with '|' or "<NL>".
+								*vimrc* *exrc*
+	A file that contains initialization commands is called a "vimrc" file.
+	Each line in a vimrc file is executed as an Ex command line.  It is
+	sometimes also referred to as "exrc" file.  They are the same type of
+	file, but "exrc" is what Vi always used, "vimrc" is a Vim specific
+	name.  Also see |vimrc-intro|.
+
+	Places for your personal initializations:
+		Unix		$HOME/.vimrc or $HOME/.vim/vimrc
+		OS/2		$HOME/.vimrc, $HOME/vimfiles/vimrc
+				or $VIM/.vimrc (or _vimrc)
+		MS-Windows	$HOME/_vimrc, $HOME/vimfiles/vimrc
+				or $VIM/_vimrc
+		Amiga		s:.vimrc, home:.vimrc, home:vimfiles:vimrc
+				or $VIM/.vimrc
+
+	The files are searched in the order specified above and only the first
+	one that is found is read.
+
+	RECOMMENDATION: Put all your Vim configuration stuff in the
+	$HOME/.vim/ directory ($HOME/vimfiles/ for MS-Windows). That makes it
+	easy to copy it to another system.
+
+	If Vim was started with "-u filename", the file "filename" is used.
+	All following initializations until 4. are skipped. $MYVIMRC is not
+	set.
+	"vim -u NORC" can be used to skip these initializations without
+	reading a file.  "vim -u NONE" also skips loading plugins.  |-u|
+
+	If Vim was started in Ex mode with the "-s" argument, all following
+	initializations until 4. are skipped.  Only the "-u" option is
+	interpreted.
+							*evim.vim*
+     a. If vim was started as |evim| or |eview| or with the |-y| argument, the
+	script $VIMRUNTIME/evim.vim will be loaded.
+							*system-vimrc*
+     b. For Unix, MS-DOS, MS-Windows, OS/2, VMS, Macintosh, RISC-OS and Amiga
+	the system vimrc file is read for initializations.  The path of this
+	file is shown with the ":version" command.  Mostly it's "$VIM/vimrc".
+	Note that this file is ALWAYS read in 'compatible' mode, since the
+	automatic resetting of 'compatible' is only done later.  Add a ":set
+	nocp" command if you like.
+	For the Macintosh the $VIMRUNTIME/macmap.vim is read.
+
+	  *VIMINIT* *.vimrc* *_vimrc* *EXINIT* *.exrc* *_exrc* *$MYVIMRC*
+     c. Five places are searched for initializations.  The first that exists
+	is used, the others are ignored.  The $MYVIMRC environment variable is
+	set to the file that was first found, unless $MYVIMRC was already set
+	and when using VIMINIT.
+	I   The environment variable VIMINIT (see also |compatible-default|) (*)
+	    The value of $VIMINIT is used as an Ex command line.
+	II  The user vimrc file(s):
+		    "$HOME/.vimrc"	   (for Unix and OS/2) (*)
+		    "$HOME/.vim/vimrc"	   (for Unix and OS/2) (*)
+		    "s:.vimrc"		   (for Amiga) (*)
+		    "home:.vimrc"	   (for Amiga) (*)
+		    "home:vimfiles:vimrc"  (for Amiga) (*)
+		    "$VIM/.vimrc"	   (for OS/2 and Amiga) (*)
+		    "$HOME/_vimrc"	   (for MS-DOS and Win32) (*)
+		    "$HOME/vimfiles/vimrc" (for MS-DOS and Win32) (*)
+		    "$VIM/_vimrc"	   (for MS-DOS and Win32) (*)
+		Note: For Unix, OS/2 and Amiga, when ".vimrc" does not exist,
+		"_vimrc" is also tried, in case an MS-DOS compatible file
+		system is used.  For MS-DOS and Win32 ".vimrc" is checked
+		after "_vimrc", in case long file names are used.
+		Note: For MS-DOS and Win32, "$HOME" is checked first.  If no
+		"_vimrc" or ".vimrc" is found there, "$VIM" is tried.
+		See |$VIM| for when $VIM is not set.
+	III The environment variable EXINIT.
+	    The value of $EXINIT is used as an Ex command line.
+	IV  The user exrc file(s).  Same as for the user vimrc file, but with
+	    "vimrc" replaced by "exrc".  But only one of ".exrc" and "_exrc" is
+	    used, depending on the system.  And without the (*)!
+	V   The default vimrc file, $VIMRUNTIME/defaults.vim.  This sets up
+	    options values and has "syntax on" and "filetype on" commands,
+	    which is what most new users will want.  See |defaults.vim|.
+
+     d. If the 'exrc' option is on (which is NOT the default), the current
+	directory is searched for three files.  The first that exists is used,
+	the others are ignored.
+	-  The file ".vimrc" (for Unix, Amiga and OS/2) (*)
+		    "_vimrc" (for MS-DOS and Win32) (*)
+	-  The file "_vimrc" (for Unix, Amiga and OS/2) (*)
+		    ".vimrc" (for MS-DOS and Win32) (*)
+	-  The file ".exrc"  (for Unix, Amiga and OS/2)
+		    "_exrc"  (for MS-DOS and Win32)
+
+     (*) Using this file or environment variable will cause 'compatible' to be
+	 off by default.  See |compatible-default|.
+
+     Note: When using the |mzscheme| interface, it is initialized after loading
+     the vimrc file.  Changing 'mzschemedll' later has no effect.
+
+4. Load the plugin scripts.					*load-plugins*
+	This does the same as the command: >
+		:runtime! plugin/**/*.vim
+<	The result is that all directories in the 'runtimepath' option will be
+	searched for the "plugin" sub-directory and all files ending in ".vim"
+	will be sourced (in alphabetical order per directory), also in
+	subdirectories.
+	However, directories in 'runtimepath' ending in "after" are skipped
+	here and only loaded after packages, see below.
+	Loading plugins won't be done when:
+	- The 'loadplugins' option was reset in a vimrc file.
+	- The |--noplugin| command line argument is used.
+	- The |--clean| command line argument is used.
+	- The "-u NONE" command line argument is used |-u|.
+	- When Vim was compiled without the |+eval| feature.
+	Note that using "-c 'set noloadplugins'" doesn't work, because the
+	commands from the command line have not been executed yet.  You can
+	use "--cmd 'set noloadplugins'" or "--cmd 'set loadplugins'" |--cmd|.
+
+	Packages are loaded.  These are plugins, as above, but found in the
+	"start" directory of each entry in 'packpath'.  Every plugin directory
+	found is added in 'runtimepath' and then the plugins are sourced.  See
+	|packages|.
+
+	The plugins scripts are loaded, as above, but now only the directories
+	ending in "after" are used.  Note that 'runtimepath' will have changed
+	if packages have been found, but that should not add a directory
+	ending in "after".
+
+5. Set 'shellpipe' and 'shellredir'
+	The 'shellpipe' and 'shellredir' options are set according to the
+	value of the 'shell' option, unless they have been set before.
+	This means that Vim will figure out the values of 'shellpipe' and
+	'shellredir' for you, unless you have set them yourself.
+
+6. Set 'updatecount' to zero, if "-n" command argument used
+
+7. Set binary options
+	If the "-b" flag was given to Vim, the options for binary editing will
+	be set now.  See |-b|.
+
+8. Perform GUI initializations
+	Only when starting "gvim", the GUI initializations will be done.  See
+	|gui-init|.
+
+9. Read the viminfo file
+	If the 'viminfo' option is not empty, the viminfo file is read.  See
+	|viminfo-file|.
+
+10. Read the quickfix file
+	If the "-q" flag was given to Vim, the quickfix file is read.  If this
+	fails, Vim exits.
+
+11. Open all windows
+	When the |-o| flag was given, windows will be opened (but not
+	displayed yet).
+	When the |-p| flag was given, tab pages will be created (but not
+	displayed yet).
+	When switching screens, it happens now.  Redrawing starts.
+	If the "-q" flag was given to Vim, the first error is jumped to.
+	Buffers for all windows will be loaded.
+
+12. Execute startup commands
+	If a "-t" flag was given to Vim, the tag is jumped to.
+	The commands given with the |-c| and |+cmd| arguments are executed.
+	If the 'insertmode' option is set, Insert mode is entered.
+	The starting flag is reset, has("vim_starting") will now return zero.
+	The |v:vim_did_enter| variable is set to 1.
+	The |VimEnter| autocommands are executed.
+
+The $MYVIMRC or $MYGVIMRC file will be set to the first found vimrc and/or
+gvimrc file.
+
+
+Some hints on using initializations ~
+
+Standard setup:
+Create a vimrc file to set the default settings and mappings for all your edit
+sessions.  Put it in a place so that it will be found by 3b:
+	~/.vimrc	(Unix and OS/2)
+	s:.vimrc	(Amiga)
+	$VIM\_vimrc	(MS-DOS and Win32)
+Note that creating a vimrc file will cause the 'compatible' option to be off
+by default.  See |compatible-default|.
+
+Local setup:
+Put all commands that you need for editing a specific directory only into a
+vimrc file and place it in that directory under the name ".vimrc" ("_vimrc"
+for MS-DOS and Win32).  NOTE: To make Vim look for these special files you
+have to turn on the option 'exrc'.  See |trojan-horse| too.
+
+System setup:
+This only applies if you are managing a Unix system with several users and
+want to set the defaults for all users.  Create a vimrc file with commands
+for default settings and mappings and put it in the place that is given with
+the ":version" command.
+
+
+Saving the current state of Vim to a file ~
+
+Whenever you have changed values of options or when you have created a
+mapping, then you may want to save them in a vimrc file for later use.  See
+|save-settings| about saving the current state of settings to a file.
+
+
+Avoiding setup problems for Vi users ~
+
+Vi uses the variable EXINIT and the file "~/.exrc".  So if you do not want to
+interfere with Vi, then use the variable VIMINIT and the file "vimrc" instead.
+
+
+Amiga environment variables ~
+
+On the Amiga, two types of environment variables exist.  The ones set with the
+DOS 1.3 (or later) setenv command are recognized.  See the AmigaDos 1.3
+manual.  The environment variables set with the old Manx Set command (before
+version 5.0) are not recognized.
+
+
+MS-DOS line separators ~
+
+On MS-DOS-like systems (MS-DOS itself, Win32, and OS/2), Vim assumes that all
+the vimrc files have <CR> <NL> pairs as line separators.  This will give
+problems if you have a file with only <NL>s and have a line like
+":map xx yy^M".  The trailing ^M will be ignored.
+
+
+Vi compatible default value ~
+						     *compatible-default*
+When Vim starts, the 'compatible' option is on.  This will be used when Vim
+starts its initializations.  But as soon as:
+- a user vimrc file is found, or
+- a vimrc file in the current directory is found, or
+- the "VIMINIT" environment variable is set, or
+- the "-N" command line argument is given, or
+- the "--clean" command line argument is given, or
+- the |defaults.vim| script is loaded, or
+- a gvimrc file was found,
+then the option will be set to 'nocompatible'.
+
+Note that this does NOT happen when a system-wide vimrc file was found.
+
+This has the side effect of setting or resetting other options (see
+'compatible').  But only the options that have not been set or reset will be
+changed.  This has the same effect like the value of 'compatible' had this
+value when starting Vim.
+
+'compatible' is NOT reset, and |defaults.vim| is not loaded:
+- when Vim was started with the |-u| command line argument, especially with
+  "-u NONE", or
+- when started with the |-C| command line argument, or
+- when the name of the executable ends in "ex". (This has been done to make
+  Vim behave like "ex", when it is started as "ex")
+
+But there is a side effect of setting or resetting 'compatible' at the moment
+a .vimrc file is found: Mappings are interpreted the moment they are
+encountered.  This makes a difference when using things like "<CR>".  If the
+mappings depend on a certain value of 'compatible', set or reset it before
+giving the mapping.
+
+
+Defaults without a .vimrc file ~
+							*defaults.vim*
+If Vim is started normally and no user vimrc file is found, the
+$VIMRUNTIME/defaults.vim script is loaded.  This will set 'compatible' off,
+switch on syntax highlighting and a few more things.  See the script for
+details.  NOTE: this is done since Vim 8.0, not in Vim 7.4. (it was added in
+patch 7.4.2111 to be exact).
+
+This should work well for new Vim users.  If you create your own .vimrc, it is
+recommended to add these lines somewhere near the top: >
+	unlet! skip_defaults_vim
+	source $VIMRUNTIME/defaults.vim
+Then Vim works like before you had a .vimrc. Copying $VIMRUNTIME/vimrc_example
+is way to do this.  Alternatively, you can copy defaults.vim to your .vimrc
+and modify it (but then you won't get updates when it changes).
+
+If you don't like some of the defaults, you can still source defaults.vim and
+revert individual settings.  See the defaults.vim file for hints on how to
+revert each item.
+						*skip_defaults_vim*
+If you use a system-wide vimrc and don't want defaults.vim to change settings,
+set the "skip_defaults_vim" variable.  If this was set and you want to load
+defaults.vim from your .vimrc, first unlet skip_defaults_vim, as in the
+example above.
+
+
+Avoiding trojan horses ~
+							*trojan-horse*
+While reading the "vimrc" or the "exrc" file in the current directory, some
+commands can be disabled for security reasons by setting the 'secure' option.
+This is always done when executing the command from a tags file.  Otherwise it
+would be possible that you accidentally use a vimrc or tags file that somebody
+else created and contains nasty commands.  The disabled commands are the ones
+that start a shell, the ones that write to a file, and ":autocmd".  The ":map"
+commands are echoed, so you can see which keys are being mapped.
+	If you want Vim to execute all commands in a local vimrc file, you
+can reset the 'secure' option in the EXINIT or VIMINIT environment variable or
+in the global "exrc" or "vimrc" file.  This is not possible in "vimrc" or
+"exrc" in the current directory, for obvious reasons.
+	On Unix systems, this only happens if you are not the owner of the
+vimrc file.  Warning: If you unpack an archive that contains a vimrc or exrc
+file, it will be owned by you.  You won't have the security protection.  Check
+the vimrc file before you start Vim in that directory, or reset the 'exrc'
+option.  Some Unix systems allow a user to do "chown" on a file.  This makes
+it possible for another user to create a nasty vimrc and make you the owner.
+Be careful!
+	When using tag search commands, executing the search command (the last
+part of the line in the tags file) is always done in secure mode.  This works
+just like executing a command from a vimrc/exrc in the current directory.
+
+
+If Vim startup is slow ~
+							*slow-start*
+If Vim takes a long time to start up, use the |--startuptime| argument to find
+out what happens.  There are a few common causes:
+- If the Unix version was compiled with the GUI and/or X11 (check the output
+  of ":version" for "+GUI" and "+X11"), it may need to load shared libraries
+  and connect to the X11 server.  Try compiling a version with GUI and X11
+  disabled.  This also should make the executable smaller.
+  Use the |-X| command line argument to avoid connecting to the X server when
+  running in a terminal.
+- If you have "viminfo" enabled, the loading of the viminfo file may take a
+  while.  You can find out if this is the problem by disabling viminfo for a
+  moment (use the Vim argument "-i NONE", |-i|).  Try reducing the number of
+  lines stored in a register with ":set viminfo='20,<50,s10".  |viminfo-file|.
+
+
+Intro message ~
+							*:intro*
+When Vim starts without a file name, an introductory message is displayed (for
+those who don't know what Vim is).  It is removed as soon as the display is
+redrawn in any way.  To see the message again, use the ":intro" command (if
+there is not enough room, you will see only part of it).
+   To avoid the intro message on startup, add the 'I' flag to 'shortmess'.
+
+							*info-message*
+The |--help| and |--version| arguments cause Vim to print a message and then
+exit.  Normally the message is sent to stdout, thus can be redirected to a
+file with: >
+
+	vim --help >file
+
+From inside Vim: >
+
+	:read !vim --help
+
+When using gvim, it detects that it might have been started from the desktop,
+without a terminal to show messages on.  This is detected when both stdout and
+stderr are not a tty.  This breaks the ":read" command, as used in the example
+above.  To make it work again, set 'shellredir' to ">" instead of the default
+">&": >
+
+	:set shellredir=>
+	:read !gvim --help
+
+This still won't work for systems where gvim does not use stdout at all
+though.
+
+==============================================================================
+5. $VIM and $VIMRUNTIME
+								*$VIM*
+The environment variable "$VIM" is used to locate various user files for Vim,
+such as the user startup script ".vimrc".  This depends on the system, see
+|startup|.
+
+To avoid the need for every user to set the $VIM environment variable, Vim
+will try to get the value for $VIM in this order:
+1. The value defined by the $VIM environment variable.  You can use this to
+   make Vim look in a specific directory for its support files.  Example: >
+	setenv VIM /home/paul/vim
+2. The path from 'helpfile' is used, unless it contains some environment
+   variable too (the default is "$VIMRUNTIME/doc/help.txt": chicken-egg
+   problem).  The file name ("help.txt" or any other) is removed.  Then
+   trailing directory names are removed, in this order: "doc", "runtime" and
+   "vim{version}" (e.g., "vim54").
+3. For MSDOS, Win32 and OS/2 Vim tries to use the directory name of the
+   executable.  If it ends in "/src", this is removed.  This is useful if you
+   unpacked the .zip file in some directory, and adjusted the search path to
+   find the vim executable.  Trailing directory names are removed, in this
+   order: "runtime" and "vim{version}" (e.g., "vim54").
+4. For Unix the compile-time defined installation directory is used (see the
+   output of ":version").
+
+Once Vim has done this once, it will set the $VIM environment variable.  To
+change it later, use a ":let" command like this: >
+	:let $VIM = "/home/paul/vim/"
+<
+								*$VIMRUNTIME*
+The environment variable "$VIMRUNTIME" is used to locate various support
+files, such as the on-line documentation and files used for syntax
+highlighting.  For example, the main help file is normally
+"$VIMRUNTIME/doc/help.txt".
+You don't normally set $VIMRUNTIME yourself, but let Vim figure it out.  This
+is the order used to find the value of $VIMRUNTIME:
+1. If the environment variable $VIMRUNTIME is set, it is used.  You can use
+   this when the runtime files are in an unusual location.
+2. If "$VIM/vim{version}" exists, it is used.  {version} is the version
+   number of Vim, without any '-' or '.'.  For example: "$VIM/vim54".  This is
+   the normal value for $VIMRUNTIME.
+3. If "$VIM/runtime" exists, it is used.
+4. The value of $VIM is used.  This is for backwards compatibility with older
+   versions.
+5. When the 'helpfile' option is set and doesn't contain a '$', its value is
+   used, with "doc/help.txt" removed from the end.
+
+For Unix, when there is a compiled-in default for $VIMRUNTIME (check the
+output of ":version"), steps 2, 3 and 4 are skipped, and the compiled-in
+default is used after step 5.  This means that the compiled-in default
+overrules the value of $VIM.  This is useful if $VIM is "/etc" and the runtime
+files are in "/usr/share/vim/vim54".
+
+Once Vim has done this once, it will set the $VIMRUNTIME environment variable.
+To change it later, use a ":let" command like this: >
+	:let $VIMRUNTIME = "/home/piet/vim/vim54"
+
+In case you need the value of $VIMRUNTIME in a shell (e.g., for a script that
+greps in the help files) you might be able to use this: >
+
+	VIMRUNTIME=`vim -e -T dumb --cmd 'exe "set t_cm=\<C-M>"|echo $VIMRUNTIME|quit' | tr -d '\015' `
+
+==============================================================================
+6. Suspending						*suspend*
+
+					*iconize* *iconise* *CTRL-Z* *v_CTRL-Z*
+CTRL-Z			Suspend Vim, like ":stop".
+			Works in Normal and in Visual mode.  In Insert and
+			Command-line mode, the CTRL-Z is inserted as a normal
+			character.  In Visual mode Vim goes back to Normal
+			mode.
+			Note: if CTRL-Z undoes a change see |mswin.vim|.
+
+
+:sus[pend][!]	or			*:sus* *:suspend* *:st* *:stop*
+:st[op][!]		Suspend Vim.
+			If the '!' is not given and 'autowrite' is set, every
+			buffer with changes and a file name is written out.
+			If the '!' is given or 'autowrite' is not set, changed
+			buffers are not written, don't forget to bring Vim
+			back to the foreground later!
+
+In the GUI, suspending is implemented as iconising gvim.  In Windows 95/NT,
+gvim is minimized.
+
+On many Unix systems, it is possible to suspend Vim with CTRL-Z.  This is only
+possible in Normal and Visual mode (see next chapter, |vim-modes|).  Vim will
+continue if you make it the foreground job again.  On other systems, CTRL-Z
+will start a new shell.  This is the same as the ":sh" command.  Vim will
+continue if you exit from the shell.
+
+In X-windows the selection is disowned when Vim suspends.  this means you
+can't paste it in another application (since Vim is going to sleep an attempt
+to get the selection would make the program hang).
+
+==============================================================================
+7. Exiting						*exiting*
+
+There are several ways to exit Vim:
+- Close the last window with `:quit`.  Only when there are no changes.
+- Close the last window with `:quit!`.  Also when there are changes.
+- Close all windows with `:qall`.  Only when there are no changes.
+- Close all windows with `:qall!`.  Also when there are changes.
+- Use `:cquit`.  Also when there are changes.
+
+When using `:cquit` or when there was an error message Vim exits with exit
+code 1.  Errors can be avoided by using `:silent!` or with `:catch`.
+
+==============================================================================
+8. Saving settings					*save-settings*
+
+Mostly you will edit your vimrc files manually.  This gives you the greatest
+flexibility.  There are a few commands to generate a vimrc file automatically.
+You can use these files as they are, or copy/paste lines to include in another
+vimrc file.
+
+							*:mk* *:mkexrc*
+:mk[exrc] [file]	Write current key mappings and changed options to
+			[file] (default ".exrc" in the current directory),
+			unless it already exists.  {not in Vi}
+
+:mk[exrc]! [file]	Always write current key mappings and changed
+			options to [file] (default ".exrc" in the current
+			directory).  {not in Vi}
+
+							*:mkv* *:mkvimrc*
+:mkv[imrc][!] [file]	Like ":mkexrc", but the default is ".vimrc" in the
+			current directory.  The ":version" command is also
+			written to the file.  {not in Vi}
+
+These commands will write ":map" and ":set" commands to a file, in such a way
+that when these commands are executed, the current key mappings and options
+will be set to the same values.  The options 'columns', 'endofline',
+'fileformat', 'key', 'lines', 'modified', 'scroll', 'term', 'textmode',
+'ttyfast' and 'ttymouse' are not included, because these are terminal or file
+dependent.  Note that the options 'binary', 'paste' and 'readonly' are
+included, this might not always be what you want.
+
+When special keys are used in mappings, The 'cpoptions' option will be
+temporarily set to its Vim default, to avoid the mappings to be
+misinterpreted.  This makes the file incompatible with Vi, but makes sure it
+can be used with different terminals.
+
+Only global mappings are stored, not mappings local to a buffer.
+
+A common method is to use a default ".vimrc" file, make some modifications
+with ":map" and ":set" commands and write the modified file.  First read the
+default ".vimrc" in with a command like ":source ~piet/.vimrc.Cprogs", change
+the settings and then save them in the current directory with ":mkvimrc!".  If
+you want to make this file your default .vimrc, move it to your home directory
+(on Unix), s: (Amiga) or $VIM directory (MS-DOS).  You could also use
+autocommands |autocommand| and/or modelines |modeline|.
+
+						*vimrc-option-example*
+If you only want to add a single option setting to your vimrc, you can use
+these steps:
+1. Edit your vimrc file with Vim.
+2. Play with the option until it's right.  E.g., try out different values for
+   'guifont'.
+3. Append a line to set the value of the option, using the expression register
+   '=' to enter the value.  E.g., for the 'guifont' option: >
+   o:set guifont=<C-R>=&guifont<CR><Esc>
+<  [<C-R> is a CTRL-R, <CR> is a return, <Esc> is the escape key]
+   You need to escape special characters, esp. spaces.
+
+Note that when you create a .vimrc file, this can influence the 'compatible'
+option, which has several side effects.  See |'compatible'|.
+":mkvimrc", ":mkexrc" and ":mksession" write the command to set or reset the
+'compatible' option to the output file first, because of these side effects.
+
+==============================================================================
+9. Views and Sessions					*views-sessions*
+
+This is introduced in sections |21.4| and |21.5| of the user manual.
+
+						*View* *view-file*
+A View is a collection of settings that apply to one window.  You can save a
+View and when you restore it later, the text is displayed in the same way.
+The options and mappings in this window will also be restored, so that you can
+continue editing like when the View was saved.
+
+						*Session* *session-file*
+A Session keeps the Views for all windows, plus the global settings.  You can
+save a Session and when you restore it later the window layout looks the same.
+You can use a Session to quickly switch between different projects,
+automatically loading the files you were last working on in that project.
+
+Views and Sessions are a nice addition to viminfo-files, which are used to
+remember information for all Views and Sessions together |viminfo-file|.
+
+You can quickly start editing with a previously saved View or Session with the
+|-S| argument: >
+	vim -S Session.vim
+<
+All this is {not in Vi} and {not available when compiled without the
+|+mksession| feature}.
+
+							*:mks* *:mksession*
+:mks[ession][!] [file]	Write a Vim script that restores the current editing
+			session.
+			When [!] is included an existing file is overwritten.
+			When [file] is omitted "Session.vim" is used.
+
+The output of ":mksession" is like ":mkvimrc", but additional commands are
+added to the file.  Which ones depends on the 'sessionoptions' option.  The
+resulting file, when executed with a ":source" command:
+1. Restores global mappings and options, if 'sessionoptions' contains
+   "options".  Script-local mappings will not be written.
+2. Restores global variables that start with an uppercase letter and contain
+   at least one lowercase letter, if 'sessionoptions' contains "globals".
+3. Unloads all currently loaded buffers.
+4. Restores the current directory if 'sessionoptions' contains "curdir", or
+   sets the current directory to where the Session file is if 'sessionoptions'
+   contains "sesdir".
+5. Restores GUI Vim window position, if 'sessionoptions' contains "winpos".
+6. Restores screen size, if 'sessionoptions' contains "resize".
+7. Reloads the buffer list, with the last cursor positions.  If
+   'sessionoptions' contains "buffers" then all buffers are restored,
+   including hidden and unloaded buffers.  Otherwise only buffers in windows
+   are restored.
+8. Restores all windows with the same layout.  If 'sessionoptions' contains
+   "help", help windows are restored.  If 'sessionoptions' contains "blank",
+   windows editing a buffer without a name will be restored.
+   If 'sessionoptions' contains "winsize" and no (help/blank) windows were
+   left out, the window sizes are restored (relative to the screen size).
+   Otherwise, the windows are just given sensible sizes.
+9. Restores the Views for all the windows, as with |:mkview|.  But
+   'sessionoptions' is used instead of 'viewoptions'.
+10. If a file exists with the same name as the Session file, but ending in
+   "x.vim" (for eXtra), executes that as well.  You can use *x.vim files to
+   specify additional settings and actions associated with a given Session,
+   such as creating menu items in the GUI version.
+
+After restoring the Session, the full filename of your current Session is
+available in the internal variable "v:this_session" |this_session-variable|.
+An example mapping: >
+  :nmap <F2> :wa<Bar>exe "mksession! " . v:this_session<CR>:so ~/sessions/
+This saves the current Session, and starts off the command to load another.
+
+A session includes all tab pages, unless "tabpages" was removed from
+'sessionoptions'. |tab-page|
+
+The |SessionLoadPost| autocmd event is triggered after a session file is
+loaded/sourced.
+						*SessionLoad-variable*
+While the session file is loading the SessionLoad global variable is set to 1.
+Plugins can use this to postpone some work until the SessionLoadPost event is
+triggered.
+
+							*:mkvie* *:mkview*
+:mkvie[w][!] [file]	Write a Vim script that restores the contents of the
+			current window.
+			When [!] is included an existing file is overwritten.
+			When [file] is omitted or is a number from 1 to 9, a
+			name is generated and 'viewdir' prepended.  When the
+			last path part of 'viewdir' does not exist, this
+			directory is created.  E.g., when 'viewdir' is
+			"$VIM/vimfiles/view" then "view" is created in
+			"$VIM/vimfiles".
+			An existing file is always overwritten then.  Use
+			|:loadview| to load this view again.
+			When [file] is the name of a file ('viewdir' is not
+			used), a command to edit the file is added to the
+			generated file.
+
+The output of ":mkview" contains these items:
+1. The argument list used in the window.  When the global argument list is
+   used it is reset to the global list.
+   The index in the argument list is also restored.
+2. The file being edited in the window.  If there is no file, the window is
+   made empty.
+3. Restore mappings, abbreviations and options local to the window if
+   'viewoptions' contains "options" or "localoptions".  For the options it
+   restores only values that are local to the current buffer and values local
+   to the window.
+   When storing the view as part of a session and "options" is in
+   'sessionoptions', global values for local options will be stored too.
+4. Restore folds when using manual folding and 'viewoptions' contains
+   "folds".  Restore manually opened and closed folds.
+5. The scroll position and the cursor position in the file.  Doesn't work very
+   well when there are closed folds.
+6. The local current directory, if it is different from the global current
+   directory and 'viewoptions' contains "curdir".
+
+Note that Views and Sessions are not perfect:
+- They don't restore everything.  For example, defined functions, autocommands
+  and ":syntax on" are not included.  Things like register contents and
+  command line history are in viminfo, not in Sessions or Views.
+- Global option values are only set when they differ from the default value.
+  When the current value is not the default value, loading a Session will not
+  set it back to the default value.  Local options will be set back to the
+  default value though.
+- Existing mappings will be overwritten without warning.  An existing mapping
+  may cause an error for ambiguity.
+- When storing manual folds and when storing manually opened/closed folds,
+  changes in the file between saving and loading the view will mess it up.
+- The Vim script is not very efficient.  But still faster than typing the
+  commands yourself!
+
+							*:lo* *:loadview*
+:lo[adview] [nr]	Load the view for the current file.  When [nr] is
+			omitted, the view stored with ":mkview" is loaded.
+			When [nr] is specified, the view stored with ":mkview
+			[nr]" is loaded.
+
+The combination of ":mkview" and ":loadview" can be used to store up to ten
+different views of a file.  These are remembered in the directory specified
+with the 'viewdir' option.  The views are stored using the file name.  If a
+file is renamed or accessed through a (symbolic) link the view will not be
+found.
+
+You might want to clean up your 'viewdir' directory now and then.
+
+To automatically save and restore views for *.c files: >
+	au BufWinLeave *.c mkview
+	au BufWinEnter *.c silent loadview
+
+==============================================================================
+10. The viminfo file				*viminfo* *viminfo-file* *E136*
+						*E575* *E576* *E577*
+If you exit Vim and later start it again, you would normally lose a lot of
+information.  The viminfo file can be used to remember that information, which
+enables you to continue where you left off.
+
+This is introduced in section |21.3| of the user manual.
+
+The viminfo file is used to store:
+- The command line history.
+- The search string history.
+- The input-line history.
+- Contents of non-empty registers.
+- Marks for several files.
+- File marks, pointing to locations in files.
+- Last search/substitute pattern (for 'n' and '&').
+- The buffer list.
+- Global variables.
+
+The viminfo file is not supported when the |+viminfo| feature has been
+disabled at compile time.
+
+You could also use a Session file.  The difference is that the viminfo file
+does not depend on what you are working on.  There normally is only one
+viminfo file.  Session files are used to save the state of a specific editing
+Session.  You could have several Session files, one for each project you are
+working on.  Viminfo and Session files together can be used to effectively
+enter Vim and directly start working in your desired setup. |session-file|
+
+							*viminfo-read*
+When Vim is started and the 'viminfo' option is non-empty, the contents of
+the viminfo file are read and the info can be used in the appropriate places.
+The |v:oldfiles| variable is filled.  The marks are not read in at startup
+(but file marks are).  See |initialization| for how to set the 'viminfo'
+option upon startup.
+
+							*viminfo-write*
+When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo
+file (it's actually merged with the existing one, if one exists).  The
+'viminfo' option is a string containing information about what info should be
+stored, and contains limits on how much should be stored (see 'viminfo').
+
+Merging happens in two ways.  Most items that have been changed or set in the
+current Vim session are stored, and what was not changed is filled from what
+is currently in the viminfo file.  For example:
+- Vim session A reads the viminfo, which contains variable START.
+- Vim session B does the same
+- Vim session A sets the variables AAA and BOTH and exits
+- Vim session B sets the variables BBB and BOTH and exits
+Now the viminfo will have:
+   START - it was in the viminfo and wasn't changed in session A or B
+   AAA   - value from session A, session B kept it
+   BBB   - value from session B
+   BOTH  - value from session B, value from session A is lost
+
+							*viminfo-timestamp*
+For some items a timestamp is used to keep the last changed version.  Here it
+doesn't matter in which sequence Vim sessions exit, the newest item(s) are
+always kept.  This is used for:
+- The command line history.
+- The search string history.
+- The input-line history.
+- Contents of non-empty registers.
+- The jump list
+- File marks
+The timestamp feature was added before Vim 8.0.  Older versions of Vim,
+starting with 7.4.1131, will keep the items with timestamp, but not use them.
+Thus when using both an older and a newer version of Vim the most recent data
+will be kept.
+
+Notes for Unix:
+- The file protection for the viminfo file will be set to prevent other users
+  from being able to read it, because it may contain any text or commands that
+  you have worked with.
+- If you want to share the viminfo file with other users (e.g. when you "su"
+  to another user), you can make the file writable for the group or everybody.
+  Vim will preserve this when replacing the viminfo file.  Be careful, don't
+  allow just anybody to read and write your viminfo file!
+- Vim will not overwrite a viminfo file that is not writable by the current
+  "real" user.  This helps for when you did "su" to become root, but your
+  $HOME is still set to a normal user's home directory.  Otherwise Vim would
+  create a viminfo file owned by root that nobody else can read.
+- The viminfo file cannot be a symbolic link.  This is to avoid security
+  issues.
+
+Marks are stored for each file separately.  When a file is read and 'viminfo'
+is non-empty, the marks for that file are read from the viminfo file.  NOTE:
+The marks are only written when exiting Vim, which is fine because marks are
+remembered for all the files you have opened in the current editing session,
+unless ":bdel" is used.  If you want to save the marks for a file that you are
+about to abandon with ":bdel", use ":wv".  The '[' and ']' marks are not
+stored, but the '"' mark is.  The '"' mark is very useful for jumping to the
+cursor position when the file was last exited.  No marks are saved for files
+that start with any string given with the "r" flag in 'viminfo'.  This can be
+used to avoid saving marks for files on removable media (for MS-DOS you would
+use "ra:,rb:", for Amiga "rdf0:,rdf1:,rdf2:").
+The |v:oldfiles| variable is filled with the file names that the viminfo file
+has marks for.
+
+							*viminfo-file-marks*
+Uppercase marks ('A to 'Z) are stored when writing the viminfo file.  The
+numbered marks ('0 to '9) are a bit special.  When the viminfo file is written
+(when exiting or with the ":wviminfo" command), '0 is set to the current cursor
+position and file.  The old '0 is moved to '1, '1 to '2, etc.  This
+resembles what happens with the "1 to "9 delete registers.  If the current
+cursor position is already present in '0 to '9, it is moved to '0, to avoid
+having the same position twice.  The result is that with "'0", you can jump
+back to the file and line where you exited Vim.  To do that right away, try
+using this command: >
+
+	vim -c "normal '0"
+
+In a csh compatible shell you could make an alias for it: >
+
+	alias lvim vim -c '"'normal "'"0'"'
+
+For a bash-like shell: >
+
+	alias lvim='vim -c "normal '\''0"'
+
+Use the "r" flag in 'viminfo' to specify for which files no marks should be
+remembered.
+
+
+VIMINFO FILE NAME					*viminfo-file-name*
+
+- The default name of the viminfo file is "$HOME/.viminfo" for Unix and OS/2,
+  "s:.viminfo" for Amiga, "$HOME\_viminfo" for MS-DOS and Win32.  For the last
+  two, when $HOME is not set, "$VIM\_viminfo" is used.  When $VIM is also not
+  set, "c:\_viminfo" is used.  For OS/2 "$VIM/.viminfo" is used when $HOME is
+  not set and $VIM is set.
+- The 'n' flag in the 'viminfo' option can be used to specify another viminfo
+  file name |'viminfo'|.
+- The "-i" Vim argument can be used to set another file name, |-i|.  When the
+  file name given is "NONE" (all uppercase), no viminfo file is ever read or
+  written.  Also not for the commands below!
+- The 'viminfofile' option can be used like the "-i" argument.  In fact, the
+  value form the "-i" argument is stored in the 'viminfofile' option.
+- For the commands below, another file name can be given, overriding the
+  default and the name given with 'viminfo' or "-i" (unless it's NONE).
+
+
+CHARACTER ENCODING					*viminfo-encoding*
+
+The text in the viminfo file is encoded as specified with the 'encoding'
+option.  Normally you will always work with the same 'encoding' value, and
+this works just fine.  However, if you read the viminfo file with another
+value for 'encoding' than what it was written with, some of the text
+(non-ASCII characters) may be invalid.  If this is unacceptable, add the 'c'
+flag to the 'viminfo' option: >
+	:set viminfo+=c
+Vim will then attempt to convert the text in the viminfo file from the
+'encoding' value it was written with to the current 'encoding' value.  This
+requires Vim to be compiled with the |+iconv| feature.  Filenames are not
+converted.
+
+
+MANUALLY READING AND WRITING				*viminfo-read-write*
+
+Two commands can be used to read and write the viminfo file manually.  This
+can be used to exchange registers between two running Vim programs: First
+type ":wv" in one and then ":rv" in the other.  Note that if the register
+already contained something, then ":rv!" would be required.  Also note
+however that this means everything will be overwritten with information from
+the first Vim, including the command line history, etc.
+
+The viminfo file itself can be edited by hand too, although we suggest you
+start with an existing one to get the format right.  It is reasonably
+self-explanatory once you're in there.  This can be useful in order to
+create a second file, say "~/.my_viminfo" which could contain certain
+settings that you always want when you first start Vim.  For example, you
+can preload registers with particular data, or put certain commands in the
+command line history.  A line in your .vimrc file like >
+	:rviminfo! ~/.my_viminfo
+can be used to load this information.  You could even have different viminfos
+for different types of files (e.g., C code) and load them based on the file
+name, using the ":autocmd" command (see |:autocmd|).
+
+							*viminfo-errors*
+When Vim detects an error while reading a viminfo file, it will not overwrite
+that file.  If there are more than 10 errors, Vim stops reading the viminfo
+file.  This was done to avoid accidentally destroying a file when the file
+name of the viminfo file is wrong.  This could happen when accidentally typing
+"vim -i file" when you wanted "vim -R file" (yes, somebody accidentally did
+that!).  If you want to overwrite a viminfo file with an error in it, you will
+either have to fix the error, or delete the file (while Vim is running, so
+most of the information will be restored).
+
+						   *:rv* *:rviminfo* *E195*
+:rv[iminfo][!] [file]	Read from viminfo file [file] (default: see above).
+			If [!] is given, then any information that is
+			already set (registers, marks, |v:oldfiles|, etc.)
+			will be overwritten   {not in Vi}
+
+			*:wv* *:wviminfo* *E137* *E138* *E574* *E886* *E929*
+:wv[iminfo][!] [file]	Write to viminfo file [file] (default: see above).
+			The information in the file is first read in to make
+			a merge between old and new info.  When [!] is used,
+			the old information is not read first, only the
+			internal info is written.  If 'viminfo' is empty, marks
+			for up to 100 files will be written.
+			When you get error "E929: Too many viminfo temp files"
+			check that no old temp files were left behind (e.g.
+			~/.viminf*) and that you can write in the directory of
+			the .viminfo file.
+			{not in Vi}
+
+						*:ol* *:oldfiles*
+:ol[dfiles]		List the files that have marks stored in the viminfo
+			file.  This list is read on startup and only changes
+			afterwards with `:rviminfo!`.  Also see |v:oldfiles|.
+			The number can be used with |c_#<|.
+			The output can be filtered with |:filter|, e.g.: >
+				filter /\.vim/ oldfiles
+<			The filtering happens on the file name.
+			{not in Vi, only when compiled with the |+eval|
+			feature}
+
+:bro[wse] ol[dfiles][!]
+			List file names as with |:oldfiles|, and then prompt
+			for a number.  When the number is valid that file from
+			the list is edited.
+			If you get the |press-enter| prompt you can press "q"
+			and still get the prompt to enter a file number.
+			Use ! to abandon a modified buffer. |abandon|
+			{not when compiled with tiny or small features}
+
+ vim:tw=78:ts=8:noet:ft=help:norl:
diff --git a/runtime/doc/tags b/runtime/doc/tags
index 9f6f3bd..ee7373e 100644
--- a/runtime/doc/tags
+++ b/runtime/doc/tags
@@ -4681,6 +4681,7 @@ GetLatestVimScripts-copyright	pi_getscript.txt	/*GetLatestVimScripts-copyright*
 GetLatestVimScripts_dat	pi_getscript.txt	/*GetLatestVimScripts_dat*
 Gnome	gui_x11.txt	/*Gnome*
 H	motion.txt	/*H*
+Haiku	os_haiku.txt	/*Haiku*
 I	insert.txt	/*I*
 ICCF	uganda.txt	/*ICCF*
 IM-server	mbyte.txt	/*IM-server*
@@ -6802,6 +6803,20 @@ g~	change.txt	/*g~*
 g~g~	change.txt	/*g~g~*
 g~~	change.txt	/*g~~*
 h	motion.txt	/*h*
+haiku-bugs	os_haiku.txt	/*haiku-bugs*
+haiku-colors	os_haiku.txt	/*haiku-colors*
+haiku-compiling	os_haiku.txt	/*haiku-compiling*
+haiku-dragndrop	os_haiku.txt	/*haiku-dragndrop*
+haiku-fonts	os_haiku.txt	/*haiku-fonts*
+haiku-general	os_haiku.txt	/*haiku-general*
+haiku-gui	os_haiku.txt	/*haiku-gui*
+haiku-launch	os_haiku.txt	/*haiku-launch*
+haiku-meta	os_haiku.txt	/*haiku-meta*
+haiku-mouse	os_haiku.txt	/*haiku-mouse*
+haiku-support-credits	os_haiku.txt	/*haiku-support-credits*
+haiku-toolbar-images	os_haiku.txt	/*haiku-toolbar-images*
+haiku-user-settings-dir	os_haiku.txt	/*haiku-user-settings-dir*
+haiku-vimdir	os_haiku.txt	/*haiku-vimdir*
 hangul	hangulin.txt	/*hangul*
 hangulin.txt	hangulin.txt	/*hangulin.txt*
 has()	eval.txt	/*has()*
@@ -7929,6 +7944,7 @@ os_390.txt	os_390.txt	/*os_390.txt*
 os_amiga.txt	os_amiga.txt	/*os_amiga.txt*
 os_beos.txt	os_beos.txt	/*os_beos.txt*
 os_dos.txt	os_dos.txt	/*os_dos.txt*
+os_haiku.txt	os_haiku.txt	/*os_haiku.txt*
 os_mac.txt	os_mac.txt	/*os_mac.txt*
 os_mint.txt	os_mint.txt	/*os_mint.txt*
 os_msdos.txt	os_msdos.txt	/*os_msdos.txt*
diff --git a/b/runtime/doc/tags.orig b/runtime/doc/tags.orig
new file mode 100644
index 0000000..9f6f3bd
--- /dev/null
+++ b/runtime/doc/tags.orig
@@ -0,0 +1,9810 @@
+!	change.txt	/*!*
+!!	change.txt	/*!!*
+#	pattern.txt	/*#*
+$	motion.txt	/*$*
+$HOME	options.txt	/*$HOME*
+$HOME-use	version5.txt	/*$HOME-use*
+$HOME-windows	options.txt	/*$HOME-windows*
+$MYGVIMRC	gui.txt	/*$MYGVIMRC*
+$MYVIMRC	starting.txt	/*$MYVIMRC*
+$VIM	starting.txt	/*$VIM*
+$VIM-use	version5.txt	/*$VIM-use*
+$VIMRUNTIME	starting.txt	/*$VIMRUNTIME*
+$VIM_POSIX	vi_diff.txt	/*$VIM_POSIX*
+%	motion.txt	/*%*
+%:.	cmdline.txt	/*%:.*
+%:8	cmdline.txt	/*%:8*
+%:S	cmdline.txt	/*%:S*
+%:e	cmdline.txt	/*%:e*
+%:gs	cmdline.txt	/*%:gs*
+%:h	cmdline.txt	/*%:h*
+%:p	cmdline.txt	/*%:p*
+%:r	cmdline.txt	/*%:r*
+%:s	cmdline.txt	/*%:s*
+%:t	cmdline.txt	/*%:t*
+%:~	cmdline.txt	/*%:~*
+&	change.txt	/*&*
+'	motion.txt	/*'*
+''	motion.txt	/*''*
+'(	motion.txt	/*'(*
+')	motion.txt	/*')*
+'.	motion.txt	/*'.*
+'0	motion.txt	/*'0*
+'<	motion.txt	/*'<*
+'>	motion.txt	/*'>*
+'A	motion.txt	/*'A*
+'[	motion.txt	/*'[*
+']	motion.txt	/*']*
+'^	motion.txt	/*'^*
+'a	motion.txt	/*'a*
+'acd'	options.txt	/*'acd'*
+'ai'	options.txt	/*'ai'*
+'akm'	options.txt	/*'akm'*
+'al'	options.txt	/*'al'*
+'aleph'	options.txt	/*'aleph'*
+'allowrevins'	options.txt	/*'allowrevins'*
+'altkeymap'	options.txt	/*'altkeymap'*
+'ambiwidth'	options.txt	/*'ambiwidth'*
+'ambw'	options.txt	/*'ambw'*
+'anti'	options.txt	/*'anti'*
+'antialias'	options.txt	/*'antialias'*
+'ap'	vi_diff.txt	/*'ap'*
+'ar'	options.txt	/*'ar'*
+'arab'	options.txt	/*'arab'*
+'arabic'	options.txt	/*'arabic'*
+'arabicshape'	options.txt	/*'arabicshape'*
+'ari'	options.txt	/*'ari'*
+'arshape'	options.txt	/*'arshape'*
+'as'	todo.txt	/*'as'*
+'autochdir'	options.txt	/*'autochdir'*
+'autoindent'	options.txt	/*'autoindent'*
+'autoprint'	vi_diff.txt	/*'autoprint'*
+'autoread'	options.txt	/*'autoread'*
+'autosave'	todo.txt	/*'autosave'*
+'autowrite'	options.txt	/*'autowrite'*
+'autowriteall'	options.txt	/*'autowriteall'*
+'aw'	options.txt	/*'aw'*
+'awa'	options.txt	/*'awa'*
+'background'	options.txt	/*'background'*
+'backspace'	options.txt	/*'backspace'*
+'backup'	options.txt	/*'backup'*
+'backupcopy'	options.txt	/*'backupcopy'*
+'backupdir'	options.txt	/*'backupdir'*
+'backupext'	options.txt	/*'backupext'*
+'backupskip'	options.txt	/*'backupskip'*
+'balloondelay'	options.txt	/*'balloondelay'*
+'ballooneval'	options.txt	/*'ballooneval'*
+'balloonevalterm'	options.txt	/*'balloonevalterm'*
+'balloonexpr'	options.txt	/*'balloonexpr'*
+'bdir'	options.txt	/*'bdir'*
+'bdlay'	options.txt	/*'bdlay'*
+'beautify'	vi_diff.txt	/*'beautify'*
+'belloff'	options.txt	/*'belloff'*
+'beval'	options.txt	/*'beval'*
+'bevalterm'	options.txt	/*'bevalterm'*
+'bex'	options.txt	/*'bex'*
+'bexpr'	options.txt	/*'bexpr'*
+'bf'	vi_diff.txt	/*'bf'*
+'bg'	options.txt	/*'bg'*
+'bh'	options.txt	/*'bh'*
+'bin'	options.txt	/*'bin'*
+'binary'	options.txt	/*'binary'*
+'biosk'	options.txt	/*'biosk'*
+'bioskey'	options.txt	/*'bioskey'*
+'bk'	options.txt	/*'bk'*
+'bkc'	options.txt	/*'bkc'*
+'bl'	options.txt	/*'bl'*
+'bo'	options.txt	/*'bo'*
+'bomb'	options.txt	/*'bomb'*
+'breakat'	options.txt	/*'breakat'*
+'breakindent'	options.txt	/*'breakindent'*
+'breakindentopt'	options.txt	/*'breakindentopt'*
+'bri'	options.txt	/*'bri'*
+'briopt'	options.txt	/*'briopt'*
+'brk'	options.txt	/*'brk'*
+'browsedir'	options.txt	/*'browsedir'*
+'bs'	options.txt	/*'bs'*
+'bsdir'	options.txt	/*'bsdir'*
+'bsk'	options.txt	/*'bsk'*
+'bt'	options.txt	/*'bt'*
+'bufhidden'	options.txt	/*'bufhidden'*
+'buflisted'	options.txt	/*'buflisted'*
+'buftype'	options.txt	/*'buftype'*
+'casemap'	options.txt	/*'casemap'*
+'cb'	options.txt	/*'cb'*
+'cc'	options.txt	/*'cc'*
+'ccv'	options.txt	/*'ccv'*
+'cd'	options.txt	/*'cd'*
+'cdpath'	options.txt	/*'cdpath'*
+'cedit'	options.txt	/*'cedit'*
+'cf'	options.txt	/*'cf'*
+'cfu'	options.txt	/*'cfu'*
+'ch'	options.txt	/*'ch'*
+'character'	intro.txt	/*'character'*
+'charconvert'	options.txt	/*'charconvert'*
+'ci'	options.txt	/*'ci'*
+'cin'	options.txt	/*'cin'*
+'cindent'	options.txt	/*'cindent'*
+'cink'	options.txt	/*'cink'*
+'cinkeys'	options.txt	/*'cinkeys'*
+'cino'	options.txt	/*'cino'*
+'cinoptions'	options.txt	/*'cinoptions'*
+'cinw'	options.txt	/*'cinw'*
+'cinwords'	options.txt	/*'cinwords'*
+'clipboard'	options.txt	/*'clipboard'*
+'cm'	options.txt	/*'cm'*
+'cmdheight'	options.txt	/*'cmdheight'*
+'cmdwinheight'	options.txt	/*'cmdwinheight'*
+'cmp'	options.txt	/*'cmp'*
+'cms'	options.txt	/*'cms'*
+'co'	options.txt	/*'co'*
+'cocu'	options.txt	/*'cocu'*
+'cole'	options.txt	/*'cole'*
+'colorcolumn'	options.txt	/*'colorcolumn'*
+'columns'	options.txt	/*'columns'*
+'com'	options.txt	/*'com'*
+'comments'	options.txt	/*'comments'*
+'commentstring'	options.txt	/*'commentstring'*
+'compatible'	options.txt	/*'compatible'*
+'complete'	options.txt	/*'complete'*
+'completefunc'	options.txt	/*'completefunc'*
+'completeopt'	options.txt	/*'completeopt'*
+'concealcursor'	options.txt	/*'concealcursor'*
+'conceallevel'	options.txt	/*'conceallevel'*
+'confirm'	options.txt	/*'confirm'*
+'consk'	options.txt	/*'consk'*
+'conskey'	options.txt	/*'conskey'*
+'copyindent'	options.txt	/*'copyindent'*
+'cot'	options.txt	/*'cot'*
+'cp'	options.txt	/*'cp'*
+'cpo'	options.txt	/*'cpo'*
+'cpoptions'	options.txt	/*'cpoptions'*
+'cpt'	options.txt	/*'cpt'*
+'crb'	options.txt	/*'crb'*
+'cryptmethod'	options.txt	/*'cryptmethod'*
+'cscopepathcomp'	options.txt	/*'cscopepathcomp'*
+'cscopeprg'	options.txt	/*'cscopeprg'*
+'cscopequickfix'	options.txt	/*'cscopequickfix'*
+'cscoperelative'	options.txt	/*'cscoperelative'*
+'cscopetag'	options.txt	/*'cscopetag'*
+'cscopetagorder'	options.txt	/*'cscopetagorder'*
+'cscopeverbose'	options.txt	/*'cscopeverbose'*
+'cspc'	options.txt	/*'cspc'*
+'csprg'	options.txt	/*'csprg'*
+'csqf'	options.txt	/*'csqf'*
+'csre'	options.txt	/*'csre'*
+'cst'	options.txt	/*'cst'*
+'csto'	options.txt	/*'csto'*
+'csverb'	options.txt	/*'csverb'*
+'cuc'	options.txt	/*'cuc'*
+'cul'	options.txt	/*'cul'*
+'cursorbind'	options.txt	/*'cursorbind'*
+'cursorcolumn'	options.txt	/*'cursorcolumn'*
+'cursorline'	options.txt	/*'cursorline'*
+'cwh'	options.txt	/*'cwh'*
+'debug'	options.txt	/*'debug'*
+'deco'	options.txt	/*'deco'*
+'def'	options.txt	/*'def'*
+'define'	options.txt	/*'define'*
+'delcombine'	options.txt	/*'delcombine'*
+'dex'	options.txt	/*'dex'*
+'dg'	options.txt	/*'dg'*
+'dict'	options.txt	/*'dict'*
+'dictionary'	options.txt	/*'dictionary'*
+'diff'	options.txt	/*'diff'*
+'diffexpr'	options.txt	/*'diffexpr'*
+'diffopt'	options.txt	/*'diffopt'*
+'digraph'	options.txt	/*'digraph'*
+'dip'	options.txt	/*'dip'*
+'dir'	options.txt	/*'dir'*
+'directory'	options.txt	/*'directory'*
+'display'	options.txt	/*'display'*
+'dy'	options.txt	/*'dy'*
+'ea'	options.txt	/*'ea'*
+'ead'	options.txt	/*'ead'*
+'eadirection'	options.txt	/*'eadirection'*
+'eb'	options.txt	/*'eb'*
+'ed'	options.txt	/*'ed'*
+'edcompatible'	options.txt	/*'edcompatible'*
+'ef'	options.txt	/*'ef'*
+'efm'	options.txt	/*'efm'*
+'ei'	options.txt	/*'ei'*
+'ek'	options.txt	/*'ek'*
+'emo'	options.txt	/*'emo'*
+'emoji'	options.txt	/*'emoji'*
+'enc'	options.txt	/*'enc'*
+'encoding'	options.txt	/*'encoding'*
+'endofline'	options.txt	/*'endofline'*
+'eol'	options.txt	/*'eol'*
+'ep'	options.txt	/*'ep'*
+'equalalways'	options.txt	/*'equalalways'*
+'equalprg'	options.txt	/*'equalprg'*
+'errorbells'	options.txt	/*'errorbells'*
+'errorfile'	options.txt	/*'errorfile'*
+'errorformat'	options.txt	/*'errorformat'*
+'esckeys'	options.txt	/*'esckeys'*
+'et'	options.txt	/*'et'*
+'eventignore'	options.txt	/*'eventignore'*
+'ex'	options.txt	/*'ex'*
+'expandtab'	options.txt	/*'expandtab'*
+'exrc'	options.txt	/*'exrc'*
+'fcl'	options.txt	/*'fcl'*
+'fcs'	options.txt	/*'fcs'*
+'fdc'	options.txt	/*'fdc'*
+'fde'	options.txt	/*'fde'*
+'fdi'	options.txt	/*'fdi'*
+'fdl'	options.txt	/*'fdl'*
+'fdls'	options.txt	/*'fdls'*
+'fdm'	options.txt	/*'fdm'*
+'fdn'	options.txt	/*'fdn'*
+'fdo'	options.txt	/*'fdo'*
+'fdt'	options.txt	/*'fdt'*
+'fe'	options.txt	/*'fe'*
+'fen'	options.txt	/*'fen'*
+'fenc'	options.txt	/*'fenc'*
+'fencs'	options.txt	/*'fencs'*
+'fex'	options.txt	/*'fex'*
+'ff'	options.txt	/*'ff'*
+'ffs'	options.txt	/*'ffs'*
+'fic'	options.txt	/*'fic'*
+'fileencoding'	options.txt	/*'fileencoding'*
+'fileencodings'	options.txt	/*'fileencodings'*
+'fileformat'	options.txt	/*'fileformat'*
+'fileformats'	options.txt	/*'fileformats'*
+'fileignorecase'	options.txt	/*'fileignorecase'*
+'filetype'	options.txt	/*'filetype'*
+'fillchars'	options.txt	/*'fillchars'*
+'fixendofline'	options.txt	/*'fixendofline'*
+'fixeol'	options.txt	/*'fixeol'*
+'fk'	options.txt	/*'fk'*
+'fkmap'	options.txt	/*'fkmap'*
+'fl'	vi_diff.txt	/*'fl'*
+'flash'	vi_diff.txt	/*'flash'*
+'flp'	options.txt	/*'flp'*
+'fml'	options.txt	/*'fml'*
+'fmr'	options.txt	/*'fmr'*
+'fo'	options.txt	/*'fo'*
+'foldclose'	options.txt	/*'foldclose'*
+'foldcolumn'	options.txt	/*'foldcolumn'*
+'foldenable'	options.txt	/*'foldenable'*
+'foldexpr'	options.txt	/*'foldexpr'*
+'foldignore'	options.txt	/*'foldignore'*
+'foldlevel'	options.txt	/*'foldlevel'*
+'foldlevelstart'	options.txt	/*'foldlevelstart'*
+'foldmarker'	options.txt	/*'foldmarker'*
+'foldmethod'	options.txt	/*'foldmethod'*
+'foldminlines'	options.txt	/*'foldminlines'*
+'foldnestmax'	options.txt	/*'foldnestmax'*
+'foldopen'	options.txt	/*'foldopen'*
+'foldtext'	options.txt	/*'foldtext'*
+'formatexpr'	options.txt	/*'formatexpr'*
+'formatlistpat'	options.txt	/*'formatlistpat'*
+'formatoptions'	options.txt	/*'formatoptions'*
+'formatprg'	options.txt	/*'formatprg'*
+'fp'	options.txt	/*'fp'*
+'fs'	options.txt	/*'fs'*
+'fsync'	options.txt	/*'fsync'*
+'ft'	options.txt	/*'ft'*
+'gcr'	options.txt	/*'gcr'*
+'gd'	options.txt	/*'gd'*
+'gdefault'	options.txt	/*'gdefault'*
+'gfm'	options.txt	/*'gfm'*
+'gfn'	options.txt	/*'gfn'*
+'gfs'	options.txt	/*'gfs'*
+'gfw'	options.txt	/*'gfw'*
+'ghr'	options.txt	/*'ghr'*
+'go'	options.txt	/*'go'*
+'go-!'	options.txt	/*'go-!'*
+'go-A'	options.txt	/*'go-A'*
+'go-F'	options.txt	/*'go-F'*
+'go-L'	options.txt	/*'go-L'*
+'go-M'	options.txt	/*'go-M'*
+'go-P'	options.txt	/*'go-P'*
+'go-R'	options.txt	/*'go-R'*
+'go-T'	options.txt	/*'go-T'*
+'go-a'	options.txt	/*'go-a'*
+'go-b'	options.txt	/*'go-b'*
+'go-c'	options.txt	/*'go-c'*
+'go-e'	options.txt	/*'go-e'*
+'go-f'	options.txt	/*'go-f'*
+'go-g'	options.txt	/*'go-g'*
+'go-h'	options.txt	/*'go-h'*
+'go-i'	options.txt	/*'go-i'*
+'go-k'	options.txt	/*'go-k'*
+'go-l'	options.txt	/*'go-l'*
+'go-m'	options.txt	/*'go-m'*
+'go-p'	options.txt	/*'go-p'*
+'go-r'	options.txt	/*'go-r'*
+'go-t'	options.txt	/*'go-t'*
+'go-v'	options.txt	/*'go-v'*
+'gp'	options.txt	/*'gp'*
+'gr'	vi_diff.txt	/*'gr'*
+'graphic'	vi_diff.txt	/*'graphic'*
+'grepformat'	options.txt	/*'grepformat'*
+'grepprg'	options.txt	/*'grepprg'*
+'gtl'	options.txt	/*'gtl'*
+'gtt'	options.txt	/*'gtt'*
+'guicursor'	options.txt	/*'guicursor'*
+'guifont'	options.txt	/*'guifont'*
+'guifontset'	options.txt	/*'guifontset'*
+'guifontwide'	options.txt	/*'guifontwide'*
+'guiheadroom'	options.txt	/*'guiheadroom'*
+'guioptions'	options.txt	/*'guioptions'*
+'guipty'	options.txt	/*'guipty'*
+'guitablabel'	options.txt	/*'guitablabel'*
+'guitabtooltip'	options.txt	/*'guitabtooltip'*
+'hardtabs'	vi_diff.txt	/*'hardtabs'*
+'helpfile'	options.txt	/*'helpfile'*
+'helpheight'	options.txt	/*'helpheight'*
+'helplang'	options.txt	/*'helplang'*
+'hf'	options.txt	/*'hf'*
+'hh'	options.txt	/*'hh'*
+'hi'	options.txt	/*'hi'*
+'hid'	options.txt	/*'hid'*
+'hidden'	options.txt	/*'hidden'*
+'highlight'	options.txt	/*'highlight'*
+'history'	options.txt	/*'history'*
+'hk'	options.txt	/*'hk'*
+'hkmap'	options.txt	/*'hkmap'*
+'hkmapp'	options.txt	/*'hkmapp'*
+'hkp'	options.txt	/*'hkp'*
+'hl'	options.txt	/*'hl'*
+'hlg'	options.txt	/*'hlg'*
+'hls'	options.txt	/*'hls'*
+'hlsearch'	options.txt	/*'hlsearch'*
+'ht'	vi_diff.txt	/*'ht'*
+'ic'	options.txt	/*'ic'*
+'icon'	options.txt	/*'icon'*
+'iconstring'	options.txt	/*'iconstring'*
+'ignorecase'	options.txt	/*'ignorecase'*
+'im'	options.txt	/*'im'*
+'imactivatefunc'	options.txt	/*'imactivatefunc'*
+'imactivatekey'	options.txt	/*'imactivatekey'*
+'imaf'	options.txt	/*'imaf'*
+'imak'	options.txt	/*'imak'*
+'imc'	options.txt	/*'imc'*
+'imcmdline'	options.txt	/*'imcmdline'*
+'imd'	options.txt	/*'imd'*
+'imdisable'	options.txt	/*'imdisable'*
+'imi'	options.txt	/*'imi'*
+'iminsert'	options.txt	/*'iminsert'*
+'ims'	options.txt	/*'ims'*
+'imsearch'	options.txt	/*'imsearch'*
+'imsf'	options.txt	/*'imsf'*
+'imst'	options.txt	/*'imst'*
+'imstatusfunc'	options.txt	/*'imstatusfunc'*
+'imstyle'	options.txt	/*'imstyle'*
+'inc'	options.txt	/*'inc'*
+'include'	options.txt	/*'include'*
+'includeexpr'	options.txt	/*'includeexpr'*
+'incsearch'	options.txt	/*'incsearch'*
+'inde'	options.txt	/*'inde'*
+'indentexpr'	options.txt	/*'indentexpr'*
+'indentkeys'	options.txt	/*'indentkeys'*
+'indk'	options.txt	/*'indk'*
+'inex'	options.txt	/*'inex'*
+'inf'	options.txt	/*'inf'*
+'infercase'	options.txt	/*'infercase'*
+'insertmode'	options.txt	/*'insertmode'*
+'is'	options.txt	/*'is'*
+'isf'	options.txt	/*'isf'*
+'isfname'	options.txt	/*'isfname'*
+'isi'	options.txt	/*'isi'*
+'isident'	options.txt	/*'isident'*
+'isk'	options.txt	/*'isk'*
+'iskeyword'	options.txt	/*'iskeyword'*
+'isp'	options.txt	/*'isp'*
+'isprint'	options.txt	/*'isprint'*
+'joinspaces'	options.txt	/*'joinspaces'*
+'js'	options.txt	/*'js'*
+'key'	options.txt	/*'key'*
+'keymap'	options.txt	/*'keymap'*
+'keymodel'	options.txt	/*'keymodel'*
+'keywordprg'	options.txt	/*'keywordprg'*
+'km'	options.txt	/*'km'*
+'kmp'	options.txt	/*'kmp'*
+'kp'	options.txt	/*'kp'*
+'langmap'	options.txt	/*'langmap'*
+'langmenu'	options.txt	/*'langmenu'*
+'langnoremap'	options.txt	/*'langnoremap'*
+'langremap'	options.txt	/*'langremap'*
+'laststatus'	options.txt	/*'laststatus'*
+'lazyredraw'	options.txt	/*'lazyredraw'*
+'lbr'	options.txt	/*'lbr'*
+'lcs'	options.txt	/*'lcs'*
+'linebreak'	options.txt	/*'linebreak'*
+'lines'	options.txt	/*'lines'*
+'linespace'	options.txt	/*'linespace'*
+'lisp'	options.txt	/*'lisp'*
+'lispwords'	options.txt	/*'lispwords'*
+'list'	options.txt	/*'list'*
+'listchars'	options.txt	/*'listchars'*
+'lm'	options.txt	/*'lm'*
+'lmap'	options.txt	/*'lmap'*
+'lnr'	options.txt	/*'lnr'*
+'loadplugins'	options.txt	/*'loadplugins'*
+'lpl'	options.txt	/*'lpl'*
+'lrm'	options.txt	/*'lrm'*
+'ls'	options.txt	/*'ls'*
+'lsp'	options.txt	/*'lsp'*
+'luadll'	options.txt	/*'luadll'*
+'lw'	options.txt	/*'lw'*
+'lz'	options.txt	/*'lz'*
+'ma'	options.txt	/*'ma'*
+'macatsui'	options.txt	/*'macatsui'*
+'magic'	options.txt	/*'magic'*
+'makeef'	options.txt	/*'makeef'*
+'makeencoding'	options.txt	/*'makeencoding'*
+'makeprg'	options.txt	/*'makeprg'*
+'mat'	options.txt	/*'mat'*
+'matchpairs'	options.txt	/*'matchpairs'*
+'matchtime'	options.txt	/*'matchtime'*
+'maxcombine'	options.txt	/*'maxcombine'*
+'maxfuncdepth'	options.txt	/*'maxfuncdepth'*
+'maxmapdepth'	options.txt	/*'maxmapdepth'*
+'maxmem'	options.txt	/*'maxmem'*
+'maxmempattern'	options.txt	/*'maxmempattern'*
+'maxmemtot'	options.txt	/*'maxmemtot'*
+'mco'	options.txt	/*'mco'*
+'mef'	options.txt	/*'mef'*
+'menc'	options.txt	/*'menc'*
+'menuitems'	options.txt	/*'menuitems'*
+'mesg'	vi_diff.txt	/*'mesg'*
+'mfd'	options.txt	/*'mfd'*
+'mh'	options.txt	/*'mh'*
+'mis'	options.txt	/*'mis'*
+'mkspellmem'	options.txt	/*'mkspellmem'*
+'ml'	options.txt	/*'ml'*
+'mls'	options.txt	/*'mls'*
+'mm'	options.txt	/*'mm'*
+'mmd'	options.txt	/*'mmd'*
+'mmp'	options.txt	/*'mmp'*
+'mmt'	options.txt	/*'mmt'*
+'mod'	options.txt	/*'mod'*
+'modeline'	options.txt	/*'modeline'*
+'modelines'	options.txt	/*'modelines'*
+'modifiable'	options.txt	/*'modifiable'*
+'modified'	options.txt	/*'modified'*
+'more'	options.txt	/*'more'*
+'mouse'	options.txt	/*'mouse'*
+'mousef'	options.txt	/*'mousef'*
+'mousefocus'	options.txt	/*'mousefocus'*
+'mousehide'	options.txt	/*'mousehide'*
+'mousem'	options.txt	/*'mousem'*
+'mousemodel'	options.txt	/*'mousemodel'*
+'mouses'	options.txt	/*'mouses'*
+'mouseshape'	options.txt	/*'mouseshape'*
+'mouset'	options.txt	/*'mouset'*
+'mousetime'	options.txt	/*'mousetime'*
+'mp'	options.txt	/*'mp'*
+'mps'	options.txt	/*'mps'*
+'msm'	options.txt	/*'msm'*
+'mzq'	options.txt	/*'mzq'*
+'mzquantum'	options.txt	/*'mzquantum'*
+'mzschemedll'	options.txt	/*'mzschemedll'*
+'mzschemegcdll'	options.txt	/*'mzschemegcdll'*
+'nf'	options.txt	/*'nf'*
+'noacd'	options.txt	/*'noacd'*
+'noai'	options.txt	/*'noai'*
+'noakm'	options.txt	/*'noakm'*
+'noallowrevins'	options.txt	/*'noallowrevins'*
+'noaltkeymap'	options.txt	/*'noaltkeymap'*
+'noanti'	options.txt	/*'noanti'*
+'noantialias'	options.txt	/*'noantialias'*
+'noar'	options.txt	/*'noar'*
+'noarab'	options.txt	/*'noarab'*
+'noarabic'	options.txt	/*'noarabic'*
+'noarabicshape'	options.txt	/*'noarabicshape'*
+'noari'	options.txt	/*'noari'*
+'noarshape'	options.txt	/*'noarshape'*
+'noas'	todo.txt	/*'noas'*
+'noautochdir'	options.txt	/*'noautochdir'*
+'noautoindent'	options.txt	/*'noautoindent'*
+'noautoread'	options.txt	/*'noautoread'*
+'noautosave'	todo.txt	/*'noautosave'*
+'noautowrite'	options.txt	/*'noautowrite'*
+'noautowriteall'	options.txt	/*'noautowriteall'*
+'noaw'	options.txt	/*'noaw'*
+'noawa'	options.txt	/*'noawa'*
+'nobackup'	options.txt	/*'nobackup'*
+'noballooneval'	options.txt	/*'noballooneval'*
+'noballoonevalterm'	options.txt	/*'noballoonevalterm'*
+'nobeval'	options.txt	/*'nobeval'*
+'nobevalterm'	options.txt	/*'nobevalterm'*
+'nobin'	options.txt	/*'nobin'*
+'nobinary'	options.txt	/*'nobinary'*
+'nobiosk'	options.txt	/*'nobiosk'*
+'nobioskey'	options.txt	/*'nobioskey'*
+'nobk'	options.txt	/*'nobk'*
+'nobl'	options.txt	/*'nobl'*
+'nobomb'	options.txt	/*'nobomb'*
+'nobreakindent'	options.txt	/*'nobreakindent'*
+'nobri'	options.txt	/*'nobri'*
+'nobuflisted'	options.txt	/*'nobuflisted'*
+'nocf'	options.txt	/*'nocf'*
+'noci'	options.txt	/*'noci'*
+'nocin'	options.txt	/*'nocin'*
+'nocindent'	options.txt	/*'nocindent'*
+'nocompatible'	options.txt	/*'nocompatible'*
+'noconfirm'	options.txt	/*'noconfirm'*
+'noconsk'	options.txt	/*'noconsk'*
+'noconskey'	options.txt	/*'noconskey'*
+'nocopyindent'	options.txt	/*'nocopyindent'*
+'nocp'	options.txt	/*'nocp'*
+'nocrb'	options.txt	/*'nocrb'*
+'nocscoperelative'	options.txt	/*'nocscoperelative'*
+'nocscopetag'	options.txt	/*'nocscopetag'*
+'nocscopeverbose'	options.txt	/*'nocscopeverbose'*
+'nocsre'	options.txt	/*'nocsre'*
+'nocst'	options.txt	/*'nocst'*
+'nocsverb'	options.txt	/*'nocsverb'*
+'nocuc'	options.txt	/*'nocuc'*
+'nocul'	options.txt	/*'nocul'*
+'nocursorbind'	options.txt	/*'nocursorbind'*
+'nocursorcolumn'	options.txt	/*'nocursorcolumn'*
+'nocursorline'	options.txt	/*'nocursorline'*
+'nodeco'	options.txt	/*'nodeco'*
+'nodelcombine'	options.txt	/*'nodelcombine'*
+'nodg'	options.txt	/*'nodg'*
+'nodiff'	options.txt	/*'nodiff'*
+'nodigraph'	options.txt	/*'nodigraph'*
+'noea'	options.txt	/*'noea'*
+'noeb'	options.txt	/*'noeb'*
+'noed'	options.txt	/*'noed'*
+'noedcompatible'	options.txt	/*'noedcompatible'*
+'noek'	options.txt	/*'noek'*
+'noemo'	options.txt	/*'noemo'*
+'noemoji'	options.txt	/*'noemoji'*
+'noendofline'	options.txt	/*'noendofline'*
+'noeol'	options.txt	/*'noeol'*
+'noequalalways'	options.txt	/*'noequalalways'*
+'noerrorbells'	options.txt	/*'noerrorbells'*
+'noesckeys'	options.txt	/*'noesckeys'*
+'noet'	options.txt	/*'noet'*
+'noex'	options.txt	/*'noex'*
+'noexpandtab'	options.txt	/*'noexpandtab'*
+'noexrc'	options.txt	/*'noexrc'*
+'nofen'	options.txt	/*'nofen'*
+'nofic'	options.txt	/*'nofic'*
+'nofileignorecase'	options.txt	/*'nofileignorecase'*
+'nofixendofline'	options.txt	/*'nofixendofline'*
+'nofixeol'	options.txt	/*'nofixeol'*
+'nofk'	options.txt	/*'nofk'*
+'nofkmap'	options.txt	/*'nofkmap'*
+'nofoldenable'	options.txt	/*'nofoldenable'*
+'nofs'	options.txt	/*'nofs'*
+'nofsync'	options.txt	/*'nofsync'*
+'nogd'	options.txt	/*'nogd'*
+'nogdefault'	options.txt	/*'nogdefault'*
+'noguipty'	options.txt	/*'noguipty'*
+'nohid'	options.txt	/*'nohid'*
+'nohidden'	options.txt	/*'nohidden'*
+'nohk'	options.txt	/*'nohk'*
+'nohkmap'	options.txt	/*'nohkmap'*
+'nohkmapp'	options.txt	/*'nohkmapp'*
+'nohkp'	options.txt	/*'nohkp'*
+'nohls'	options.txt	/*'nohls'*
+'nohlsearch'	options.txt	/*'nohlsearch'*
+'noic'	options.txt	/*'noic'*
+'noicon'	options.txt	/*'noicon'*
+'noignorecase'	options.txt	/*'noignorecase'*
+'noim'	options.txt	/*'noim'*
+'noimc'	options.txt	/*'noimc'*
+'noimcmdline'	options.txt	/*'noimcmdline'*
+'noimd'	options.txt	/*'noimd'*
+'noimdisable'	options.txt	/*'noimdisable'*
+'noincsearch'	options.txt	/*'noincsearch'*
+'noinf'	options.txt	/*'noinf'*
+'noinfercase'	options.txt	/*'noinfercase'*
+'noinsertmode'	options.txt	/*'noinsertmode'*
+'nois'	options.txt	/*'nois'*
+'nojoinspaces'	options.txt	/*'nojoinspaces'*
+'nojs'	options.txt	/*'nojs'*
+'nolangnoremap'	options.txt	/*'nolangnoremap'*
+'nolangremap'	options.txt	/*'nolangremap'*
+'nolazyredraw'	options.txt	/*'nolazyredraw'*
+'nolbr'	options.txt	/*'nolbr'*
+'nolinebreak'	options.txt	/*'nolinebreak'*
+'nolisp'	options.txt	/*'nolisp'*
+'nolist'	options.txt	/*'nolist'*
+'nolnr'	options.txt	/*'nolnr'*
+'noloadplugins'	options.txt	/*'noloadplugins'*
+'nolpl'	options.txt	/*'nolpl'*
+'nolrm'	options.txt	/*'nolrm'*
+'nolz'	options.txt	/*'nolz'*
+'noma'	options.txt	/*'noma'*
+'nomacatsui'	options.txt	/*'nomacatsui'*
+'nomagic'	options.txt	/*'nomagic'*
+'nomh'	options.txt	/*'nomh'*
+'noml'	options.txt	/*'noml'*
+'nomod'	options.txt	/*'nomod'*
+'nomodeline'	options.txt	/*'nomodeline'*
+'nomodifiable'	options.txt	/*'nomodifiable'*
+'nomodified'	options.txt	/*'nomodified'*
+'nomore'	options.txt	/*'nomore'*
+'nomousef'	options.txt	/*'nomousef'*
+'nomousefocus'	options.txt	/*'nomousefocus'*
+'nomousehide'	options.txt	/*'nomousehide'*
+'nonu'	options.txt	/*'nonu'*
+'nonumber'	options.txt	/*'nonumber'*
+'noodev'	options.txt	/*'noodev'*
+'noopendevice'	options.txt	/*'noopendevice'*
+'nopaste'	options.txt	/*'nopaste'*
+'nopi'	options.txt	/*'nopi'*
+'nopreserveindent'	options.txt	/*'nopreserveindent'*
+'nopreviewwindow'	options.txt	/*'nopreviewwindow'*
+'noprompt'	options.txt	/*'noprompt'*
+'nopvw'	options.txt	/*'nopvw'*
+'noreadonly'	options.txt	/*'noreadonly'*
+'norelativenumber'	options.txt	/*'norelativenumber'*
+'noremap'	options.txt	/*'noremap'*
+'norestorescreen'	options.txt	/*'norestorescreen'*
+'norevins'	options.txt	/*'norevins'*
+'nori'	options.txt	/*'nori'*
+'norightleft'	options.txt	/*'norightleft'*
+'norl'	options.txt	/*'norl'*
+'nornu'	options.txt	/*'nornu'*
+'noro'	options.txt	/*'noro'*
+'nors'	options.txt	/*'nors'*
+'noru'	options.txt	/*'noru'*
+'noruler'	options.txt	/*'noruler'*
+'nosb'	options.txt	/*'nosb'*
+'nosc'	options.txt	/*'nosc'*
+'noscb'	options.txt	/*'noscb'*
+'noscrollbind'	options.txt	/*'noscrollbind'*
+'noscs'	options.txt	/*'noscs'*
+'nosecure'	options.txt	/*'nosecure'*
+'nosft'	options.txt	/*'nosft'*
+'noshellslash'	options.txt	/*'noshellslash'*
+'noshelltemp'	options.txt	/*'noshelltemp'*
+'noshiftround'	options.txt	/*'noshiftround'*
+'noshortname'	options.txt	/*'noshortname'*
+'noshowcmd'	options.txt	/*'noshowcmd'*
+'noshowfulltag'	options.txt	/*'noshowfulltag'*
+'noshowmatch'	options.txt	/*'noshowmatch'*
+'noshowmode'	options.txt	/*'noshowmode'*
+'nosi'	options.txt	/*'nosi'*
+'nosm'	options.txt	/*'nosm'*
+'nosmartcase'	options.txt	/*'nosmartcase'*
+'nosmartindent'	options.txt	/*'nosmartindent'*
+'nosmarttab'	options.txt	/*'nosmarttab'*
+'nosmd'	options.txt	/*'nosmd'*
+'nosn'	options.txt	/*'nosn'*
+'nosol'	options.txt	/*'nosol'*
+'nospell'	options.txt	/*'nospell'*
+'nosplitbelow'	options.txt	/*'nosplitbelow'*
+'nosplitright'	options.txt	/*'nosplitright'*
+'nospr'	options.txt	/*'nospr'*
+'nosr'	options.txt	/*'nosr'*
+'nossl'	options.txt	/*'nossl'*
+'nosta'	options.txt	/*'nosta'*
+'nostartofline'	options.txt	/*'nostartofline'*
+'nostmp'	options.txt	/*'nostmp'*
+'noswapfile'	options.txt	/*'noswapfile'*
+'noswf'	options.txt	/*'noswf'*
+'nota'	options.txt	/*'nota'*
+'notagbsearch'	options.txt	/*'notagbsearch'*
+'notagrelative'	options.txt	/*'notagrelative'*
+'notagstack'	options.txt	/*'notagstack'*
+'notbi'	options.txt	/*'notbi'*
+'notbidi'	options.txt	/*'notbidi'*
+'notbs'	options.txt	/*'notbs'*
+'notermbidi'	options.txt	/*'notermbidi'*
+'noterse'	options.txt	/*'noterse'*
+'notextauto'	options.txt	/*'notextauto'*
+'notextmode'	options.txt	/*'notextmode'*
+'notf'	options.txt	/*'notf'*
+'notgst'	options.txt	/*'notgst'*
+'notildeop'	options.txt	/*'notildeop'*
+'notimeout'	options.txt	/*'notimeout'*
+'notitle'	options.txt	/*'notitle'*
+'noto'	options.txt	/*'noto'*
+'notop'	options.txt	/*'notop'*
+'notr'	options.txt	/*'notr'*
+'nottimeout'	options.txt	/*'nottimeout'*
+'nottybuiltin'	options.txt	/*'nottybuiltin'*
+'nottyfast'	options.txt	/*'nottyfast'*
+'notx'	options.txt	/*'notx'*
+'noudf'	options.txt	/*'noudf'*
+'noundofile'	options.txt	/*'noundofile'*
+'novb'	options.txt	/*'novb'*
+'novice'	vi_diff.txt	/*'novice'*
+'novisualbell'	options.txt	/*'novisualbell'*
+'nowa'	options.txt	/*'nowa'*
+'nowarn'	options.txt	/*'nowarn'*
+'nowb'	options.txt	/*'nowb'*
+'noweirdinvert'	options.txt	/*'noweirdinvert'*
+'nowfh'	options.txt	/*'nowfh'*
+'nowfw'	options.txt	/*'nowfw'*
+'nowic'	options.txt	/*'nowic'*
+'nowildignorecase'	options.txt	/*'nowildignorecase'*
+'nowildmenu'	options.txt	/*'nowildmenu'*
+'nowinfixheight'	options.txt	/*'nowinfixheight'*
+'nowinfixwidth'	options.txt	/*'nowinfixwidth'*
+'nowiv'	options.txt	/*'nowiv'*
+'nowmnu'	options.txt	/*'nowmnu'*
+'nowrap'	options.txt	/*'nowrap'*
+'nowrapscan'	options.txt	/*'nowrapscan'*
+'nowrite'	options.txt	/*'nowrite'*
+'nowriteany'	options.txt	/*'nowriteany'*
+'nowritebackup'	options.txt	/*'nowritebackup'*
+'nows'	options.txt	/*'nows'*
+'nrformats'	options.txt	/*'nrformats'*
+'nu'	options.txt	/*'nu'*
+'number'	options.txt	/*'number'*
+'numberwidth'	options.txt	/*'numberwidth'*
+'nuw'	options.txt	/*'nuw'*
+'odev'	options.txt	/*'odev'*
+'oft'	options.txt	/*'oft'*
+'ofu'	options.txt	/*'ofu'*
+'omnifunc'	options.txt	/*'omnifunc'*
+'op'	vi_diff.txt	/*'op'*
+'open'	vi_diff.txt	/*'open'*
+'opendevice'	options.txt	/*'opendevice'*
+'operatorfunc'	options.txt	/*'operatorfunc'*
+'opfunc'	options.txt	/*'opfunc'*
+'optimize'	vi_diff.txt	/*'optimize'*
+'option'	intro.txt	/*'option'*
+'osfiletype'	options.txt	/*'osfiletype'*
+'pa'	options.txt	/*'pa'*
+'packpath'	options.txt	/*'packpath'*
+'para'	options.txt	/*'para'*
+'paragraphs'	options.txt	/*'paragraphs'*
+'paste'	options.txt	/*'paste'*
+'pastetoggle'	options.txt	/*'pastetoggle'*
+'patchexpr'	options.txt	/*'patchexpr'*
+'patchmode'	options.txt	/*'patchmode'*
+'path'	options.txt	/*'path'*
+'pdev'	options.txt	/*'pdev'*
+'penc'	options.txt	/*'penc'*
+'perldll'	options.txt	/*'perldll'*
+'pex'	options.txt	/*'pex'*
+'pexpr'	options.txt	/*'pexpr'*
+'pfn'	options.txt	/*'pfn'*
+'ph'	options.txt	/*'ph'*
+'pheader'	options.txt	/*'pheader'*
+'pi'	options.txt	/*'pi'*
+'pm'	options.txt	/*'pm'*
+'pmbcs'	options.txt	/*'pmbcs'*
+'pmbfn'	options.txt	/*'pmbfn'*
+'popt'	options.txt	/*'popt'*
+'pp'	options.txt	/*'pp'*
+'preserveindent'	options.txt	/*'preserveindent'*
+'previewheight'	options.txt	/*'previewheight'*
+'previewwindow'	options.txt	/*'previewwindow'*
+'printdevice'	options.txt	/*'printdevice'*
+'printencoding'	options.txt	/*'printencoding'*
+'printexpr'	options.txt	/*'printexpr'*
+'printfont'	options.txt	/*'printfont'*
+'printheader'	options.txt	/*'printheader'*
+'printmbcharset'	options.txt	/*'printmbcharset'*
+'printmbfont'	options.txt	/*'printmbfont'*
+'printoptions'	options.txt	/*'printoptions'*
+'prompt'	options.txt	/*'prompt'*
+'pt'	options.txt	/*'pt'*
+'pumheight'	options.txt	/*'pumheight'*
+'pumwidth'	options.txt	/*'pumwidth'*
+'pvh'	options.txt	/*'pvh'*
+'pvw'	options.txt	/*'pvw'*
+'pw'	options.txt	/*'pw'*
+'pythondll'	options.txt	/*'pythondll'*
+'pythonhome'	options.txt	/*'pythonhome'*
+'pythonthreedll'	options.txt	/*'pythonthreedll'*
+'pythonthreehome'	options.txt	/*'pythonthreehome'*
+'pyx'	options.txt	/*'pyx'*
+'pyxversion'	options.txt	/*'pyxversion'*
+'qe'	options.txt	/*'qe'*
+'quote	motion.txt	/*'quote*
+'quoteescape'	options.txt	/*'quoteescape'*
+'rdt'	options.txt	/*'rdt'*
+'re'	options.txt	/*'re'*
+'readonly'	options.txt	/*'readonly'*
+'redraw'	vi_diff.txt	/*'redraw'*
+'redrawtime'	options.txt	/*'redrawtime'*
+'regexpengine'	options.txt	/*'regexpengine'*
+'relativenumber'	options.txt	/*'relativenumber'*
+'remap'	options.txt	/*'remap'*
+'renderoptions'	options.txt	/*'renderoptions'*
+'report'	options.txt	/*'report'*
+'restorescreen'	options.txt	/*'restorescreen'*
+'revins'	options.txt	/*'revins'*
+'ri'	options.txt	/*'ri'*
+'rightleft'	options.txt	/*'rightleft'*
+'rightleftcmd'	options.txt	/*'rightleftcmd'*
+'rl'	options.txt	/*'rl'*
+'rlc'	options.txt	/*'rlc'*
+'rnu'	options.txt	/*'rnu'*
+'ro'	options.txt	/*'ro'*
+'rop'	options.txt	/*'rop'*
+'rs'	options.txt	/*'rs'*
+'rtp'	options.txt	/*'rtp'*
+'ru'	options.txt	/*'ru'*
+'rubydll'	options.txt	/*'rubydll'*
+'ruf'	options.txt	/*'ruf'*
+'ruler'	options.txt	/*'ruler'*
+'rulerformat'	options.txt	/*'rulerformat'*
+'runtimepath'	options.txt	/*'runtimepath'*
+'sb'	options.txt	/*'sb'*
+'sbo'	options.txt	/*'sbo'*
+'sbr'	options.txt	/*'sbr'*
+'sc'	options.txt	/*'sc'*
+'scb'	options.txt	/*'scb'*
+'scl'	options.txt	/*'scl'*
+'scr'	options.txt	/*'scr'*
+'scroll'	options.txt	/*'scroll'*
+'scrollbind'	options.txt	/*'scrollbind'*
+'scrolljump'	options.txt	/*'scrolljump'*
+'scrolloff'	options.txt	/*'scrolloff'*
+'scrollopt'	options.txt	/*'scrollopt'*
+'scs'	options.txt	/*'scs'*
+'sect'	options.txt	/*'sect'*
+'sections'	options.txt	/*'sections'*
+'secure'	options.txt	/*'secure'*
+'sel'	options.txt	/*'sel'*
+'selection'	options.txt	/*'selection'*
+'selectmode'	options.txt	/*'selectmode'*
+'sessionoptions'	options.txt	/*'sessionoptions'*
+'sft'	options.txt	/*'sft'*
+'sh'	options.txt	/*'sh'*
+'shcf'	options.txt	/*'shcf'*
+'shell'	options.txt	/*'shell'*
+'shellcmdflag'	options.txt	/*'shellcmdflag'*
+'shellpipe'	options.txt	/*'shellpipe'*
+'shellquote'	options.txt	/*'shellquote'*
+'shellredir'	options.txt	/*'shellredir'*
+'shellslash'	options.txt	/*'shellslash'*
+'shelltemp'	options.txt	/*'shelltemp'*
+'shelltype'	options.txt	/*'shelltype'*
+'shellxescape'	options.txt	/*'shellxescape'*
+'shellxquote'	options.txt	/*'shellxquote'*
+'shiftround'	options.txt	/*'shiftround'*
+'shiftwidth'	options.txt	/*'shiftwidth'*
+'shm'	options.txt	/*'shm'*
+'shortmess'	options.txt	/*'shortmess'*
+'shortname'	options.txt	/*'shortname'*
+'showbreak'	options.txt	/*'showbreak'*
+'showcmd'	options.txt	/*'showcmd'*
+'showfulltag'	options.txt	/*'showfulltag'*
+'showmatch'	options.txt	/*'showmatch'*
+'showmode'	options.txt	/*'showmode'*
+'showtabline'	options.txt	/*'showtabline'*
+'shq'	options.txt	/*'shq'*
+'si'	options.txt	/*'si'*
+'sidescroll'	options.txt	/*'sidescroll'*
+'sidescrolloff'	options.txt	/*'sidescrolloff'*
+'signcolumn'	options.txt	/*'signcolumn'*
+'siso'	options.txt	/*'siso'*
+'sj'	options.txt	/*'sj'*
+'slm'	options.txt	/*'slm'*
+'slow'	vi_diff.txt	/*'slow'*
+'slowopen'	vi_diff.txt	/*'slowopen'*
+'sm'	options.txt	/*'sm'*
+'smartcase'	options.txt	/*'smartcase'*
+'smartindent'	options.txt	/*'smartindent'*
+'smarttab'	options.txt	/*'smarttab'*
+'smc'	options.txt	/*'smc'*
+'smd'	options.txt	/*'smd'*
+'sn'	options.txt	/*'sn'*
+'so'	options.txt	/*'so'*
+'softtabstop'	options.txt	/*'softtabstop'*
+'sol'	options.txt	/*'sol'*
+'sourceany'	vi_diff.txt	/*'sourceany'*
+'sp'	options.txt	/*'sp'*
+'spc'	options.txt	/*'spc'*
+'spell'	options.txt	/*'spell'*
+'spellcapcheck'	options.txt	/*'spellcapcheck'*
+'spellfile'	options.txt	/*'spellfile'*
+'spelllang'	options.txt	/*'spelllang'*
+'spellsuggest'	options.txt	/*'spellsuggest'*
+'spf'	options.txt	/*'spf'*
+'spl'	options.txt	/*'spl'*
+'splitbelow'	options.txt	/*'splitbelow'*
+'splitright'	options.txt	/*'splitright'*
+'spr'	options.txt	/*'spr'*
+'sps'	options.txt	/*'sps'*
+'sr'	options.txt	/*'sr'*
+'srr'	options.txt	/*'srr'*
+'ss'	options.txt	/*'ss'*
+'ssl'	options.txt	/*'ssl'*
+'ssop'	options.txt	/*'ssop'*
+'st'	options.txt	/*'st'*
+'sta'	options.txt	/*'sta'*
+'stal'	options.txt	/*'stal'*
+'startofline'	options.txt	/*'startofline'*
+'statusline'	options.txt	/*'statusline'*
+'stl'	options.txt	/*'stl'*
+'stmp'	options.txt	/*'stmp'*
+'sts'	options.txt	/*'sts'*
+'su'	options.txt	/*'su'*
+'sua'	options.txt	/*'sua'*
+'suffixes'	options.txt	/*'suffixes'*
+'suffixesadd'	options.txt	/*'suffixesadd'*
+'sw'	options.txt	/*'sw'*
+'swapfile'	options.txt	/*'swapfile'*
+'swapsync'	options.txt	/*'swapsync'*
+'swb'	options.txt	/*'swb'*
+'swf'	options.txt	/*'swf'*
+'switchbuf'	options.txt	/*'switchbuf'*
+'sws'	options.txt	/*'sws'*
+'sxe'	options.txt	/*'sxe'*
+'sxq'	options.txt	/*'sxq'*
+'syn'	options.txt	/*'syn'*
+'synmaxcol'	options.txt	/*'synmaxcol'*
+'syntax'	options.txt	/*'syntax'*
+'t_#2'	term.txt	/*'t_#2'*
+'t_#4'	term.txt	/*'t_#4'*
+'t_%1'	term.txt	/*'t_%1'*
+'t_%i'	term.txt	/*'t_%i'*
+'t_&8'	term.txt	/*'t_&8'*
+'t_8b'	term.txt	/*'t_8b'*
+'t_8f'	term.txt	/*'t_8f'*
+'t_@7'	term.txt	/*'t_@7'*
+'t_AB'	term.txt	/*'t_AB'*
+'t_AF'	term.txt	/*'t_AF'*
+'t_AL'	term.txt	/*'t_AL'*
+'t_BD'	term.txt	/*'t_BD'*
+'t_BE'	term.txt	/*'t_BE'*
+'t_CS'	term.txt	/*'t_CS'*
+'t_CV'	term.txt	/*'t_CV'*
+'t_Ce'	term.txt	/*'t_Ce'*
+'t_Co'	term.txt	/*'t_Co'*
+'t_Cs'	term.txt	/*'t_Cs'*
+'t_DL'	term.txt	/*'t_DL'*
+'t_EC'	term.txt	/*'t_EC'*
+'t_EI'	term.txt	/*'t_EI'*
+'t_F1'	term.txt	/*'t_F1'*
+'t_F2'	term.txt	/*'t_F2'*
+'t_F3'	term.txt	/*'t_F3'*
+'t_F4'	term.txt	/*'t_F4'*
+'t_F5'	term.txt	/*'t_F5'*
+'t_F6'	term.txt	/*'t_F6'*
+'t_F7'	term.txt	/*'t_F7'*
+'t_F8'	term.txt	/*'t_F8'*
+'t_F9'	term.txt	/*'t_F9'*
+'t_GP'	term.txt	/*'t_GP'*
+'t_IE'	term.txt	/*'t_IE'*
+'t_IS'	term.txt	/*'t_IS'*
+'t_K1'	term.txt	/*'t_K1'*
+'t_K3'	term.txt	/*'t_K3'*
+'t_K4'	term.txt	/*'t_K4'*
+'t_K5'	term.txt	/*'t_K5'*
+'t_K6'	term.txt	/*'t_K6'*
+'t_K7'	term.txt	/*'t_K7'*
+'t_K8'	term.txt	/*'t_K8'*
+'t_K9'	term.txt	/*'t_K9'*
+'t_KA'	term.txt	/*'t_KA'*
+'t_KB'	term.txt	/*'t_KB'*
+'t_KC'	term.txt	/*'t_KC'*
+'t_KD'	term.txt	/*'t_KD'*
+'t_KE'	term.txt	/*'t_KE'*
+'t_KF'	term.txt	/*'t_KF'*
+'t_KG'	term.txt	/*'t_KG'*
+'t_KH'	term.txt	/*'t_KH'*
+'t_KI'	term.txt	/*'t_KI'*
+'t_KJ'	term.txt	/*'t_KJ'*
+'t_KK'	term.txt	/*'t_KK'*
+'t_KL'	term.txt	/*'t_KL'*
+'t_PE'	term.txt	/*'t_PE'*
+'t_PS'	term.txt	/*'t_PS'*
+'t_RB'	term.txt	/*'t_RB'*
+'t_RC'	term.txt	/*'t_RC'*
+'t_RF'	term.txt	/*'t_RF'*
+'t_RI'	term.txt	/*'t_RI'*
+'t_RS'	term.txt	/*'t_RS'*
+'t_RT'	term.txt	/*'t_RT'*
+'t_RV'	term.txt	/*'t_RV'*
+'t_Ri'	term.txt	/*'t_Ri'*
+'t_SC'	term.txt	/*'t_SC'*
+'t_SH'	term.txt	/*'t_SH'*
+'t_SI'	term.txt	/*'t_SI'*
+'t_SR'	term.txt	/*'t_SR'*
+'t_ST'	term.txt	/*'t_ST'*
+'t_Sb'	term.txt	/*'t_Sb'*
+'t_Sf'	term.txt	/*'t_Sf'*
+'t_Si'	term.txt	/*'t_Si'*
+'t_Te'	term.txt	/*'t_Te'*
+'t_Ts'	term.txt	/*'t_Ts'*
+'t_VS'	term.txt	/*'t_VS'*
+'t_WP'	term.txt	/*'t_WP'*
+'t_WS'	term.txt	/*'t_WS'*
+'t_ZH'	term.txt	/*'t_ZH'*
+'t_ZR'	term.txt	/*'t_ZR'*
+'t_al'	term.txt	/*'t_al'*
+'t_bc'	term.txt	/*'t_bc'*
+'t_cd'	term.txt	/*'t_cd'*
+'t_ce'	term.txt	/*'t_ce'*
+'t_cl'	term.txt	/*'t_cl'*
+'t_cm'	term.txt	/*'t_cm'*
+'t_cs'	term.txt	/*'t_cs'*
+'t_da'	term.txt	/*'t_da'*
+'t_db'	term.txt	/*'t_db'*
+'t_dl'	term.txt	/*'t_dl'*
+'t_fs'	term.txt	/*'t_fs'*
+'t_k1'	term.txt	/*'t_k1'*
+'t_k2'	term.txt	/*'t_k2'*
+'t_k3'	term.txt	/*'t_k3'*
+'t_k4'	term.txt	/*'t_k4'*
+'t_k5'	term.txt	/*'t_k5'*
+'t_k6'	term.txt	/*'t_k6'*
+'t_k7'	term.txt	/*'t_k7'*
+'t_k8'	term.txt	/*'t_k8'*
+'t_k9'	term.txt	/*'t_k9'*
+'t_k;'	term.txt	/*'t_k;'*
+'t_kB'	term.txt	/*'t_kB'*
+'t_kD'	term.txt	/*'t_kD'*
+'t_kI'	term.txt	/*'t_kI'*
+'t_kN'	term.txt	/*'t_kN'*
+'t_kP'	term.txt	/*'t_kP'*
+'t_kb'	term.txt	/*'t_kb'*
+'t_kd'	term.txt	/*'t_kd'*
+'t_ke'	term.txt	/*'t_ke'*
+'t_kh'	term.txt	/*'t_kh'*
+'t_kl'	term.txt	/*'t_kl'*
+'t_kr'	term.txt	/*'t_kr'*
+'t_ks'	term.txt	/*'t_ks'*
+'t_ku'	term.txt	/*'t_ku'*
+'t_le'	term.txt	/*'t_le'*
+'t_mb'	term.txt	/*'t_mb'*
+'t_md'	term.txt	/*'t_md'*
+'t_me'	term.txt	/*'t_me'*
+'t_mr'	term.txt	/*'t_mr'*
+'t_ms'	term.txt	/*'t_ms'*
+'t_nd'	term.txt	/*'t_nd'*
+'t_op'	term.txt	/*'t_op'*
+'t_se'	term.txt	/*'t_se'*
+'t_so'	term.txt	/*'t_so'*
+'t_sr'	term.txt	/*'t_sr'*
+'t_star7'	term.txt	/*'t_star7'*
+'t_te'	term.txt	/*'t_te'*
+'t_ti'	term.txt	/*'t_ti'*
+'t_ts'	term.txt	/*'t_ts'*
+'t_u7'	term.txt	/*'t_u7'*
+'t_ue'	term.txt	/*'t_ue'*
+'t_us'	term.txt	/*'t_us'*
+'t_ut'	term.txt	/*'t_ut'*
+'t_vb'	term.txt	/*'t_vb'*
+'t_ve'	term.txt	/*'t_ve'*
+'t_vi'	term.txt	/*'t_vi'*
+'t_vs'	term.txt	/*'t_vs'*
+'t_xn'	term.txt	/*'t_xn'*
+'t_xs'	term.txt	/*'t_xs'*
+'ta'	options.txt	/*'ta'*
+'tabline'	options.txt	/*'tabline'*
+'tabpagemax'	options.txt	/*'tabpagemax'*
+'tabstop'	options.txt	/*'tabstop'*
+'tag'	options.txt	/*'tag'*
+'tagbsearch'	options.txt	/*'tagbsearch'*
+'tagcase'	options.txt	/*'tagcase'*
+'taglength'	options.txt	/*'taglength'*
+'tagrelative'	options.txt	/*'tagrelative'*
+'tags'	options.txt	/*'tags'*
+'tagstack'	options.txt	/*'tagstack'*
+'tal'	options.txt	/*'tal'*
+'tb'	options.txt	/*'tb'*
+'tbi'	options.txt	/*'tbi'*
+'tbidi'	options.txt	/*'tbidi'*
+'tbis'	options.txt	/*'tbis'*
+'tbs'	options.txt	/*'tbs'*
+'tc'	options.txt	/*'tc'*
+'tcldll'	options.txt	/*'tcldll'*
+'tenc'	options.txt	/*'tenc'*
+'term'	options.txt	/*'term'*
+'termbidi'	options.txt	/*'termbidi'*
+'termencoding'	options.txt	/*'termencoding'*
+'termguicolors'	options.txt	/*'termguicolors'*
+'termwinkey'	options.txt	/*'termwinkey'*
+'termwinscroll'	options.txt	/*'termwinscroll'*
+'termwinsize'	options.txt	/*'termwinsize'*
+'terse'	options.txt	/*'terse'*
+'textauto'	options.txt	/*'textauto'*
+'textmode'	options.txt	/*'textmode'*
+'textwidth'	options.txt	/*'textwidth'*
+'tf'	options.txt	/*'tf'*
+'tgc'	options.txt	/*'tgc'*
+'tgst'	options.txt	/*'tgst'*
+'thesaurus'	options.txt	/*'thesaurus'*
+'tildeop'	options.txt	/*'tildeop'*
+'timeout'	options.txt	/*'timeout'*
+'timeoutlen'	options.txt	/*'timeoutlen'*
+'title'	options.txt	/*'title'*
+'titlelen'	options.txt	/*'titlelen'*
+'titleold'	options.txt	/*'titleold'*
+'titlestring'	options.txt	/*'titlestring'*
+'tl'	options.txt	/*'tl'*
+'tm'	options.txt	/*'tm'*
+'to'	options.txt	/*'to'*
+'toolbar'	options.txt	/*'toolbar'*
+'toolbariconsize'	options.txt	/*'toolbariconsize'*
+'top'	options.txt	/*'top'*
+'tpm'	options.txt	/*'tpm'*
+'tr'	options.txt	/*'tr'*
+'ts'	options.txt	/*'ts'*
+'tsl'	options.txt	/*'tsl'*
+'tsr'	options.txt	/*'tsr'*
+'ttimeout'	options.txt	/*'ttimeout'*
+'ttimeoutlen'	options.txt	/*'ttimeoutlen'*
+'ttm'	options.txt	/*'ttm'*
+'tty'	options.txt	/*'tty'*
+'ttybuiltin'	options.txt	/*'ttybuiltin'*
+'ttyfast'	options.txt	/*'ttyfast'*
+'ttym'	options.txt	/*'ttym'*
+'ttymouse'	options.txt	/*'ttymouse'*
+'ttyscroll'	options.txt	/*'ttyscroll'*
+'ttytype'	options.txt	/*'ttytype'*
+'tw'	options.txt	/*'tw'*
+'twk'	options.txt	/*'twk'*
+'tws'	options.txt	/*'tws'*
+'twsl'	options.txt	/*'twsl'*
+'tx'	options.txt	/*'tx'*
+'uc'	options.txt	/*'uc'*
+'udf'	options.txt	/*'udf'*
+'udir'	options.txt	/*'udir'*
+'ul'	options.txt	/*'ul'*
+'undodir'	options.txt	/*'undodir'*
+'undofile'	options.txt	/*'undofile'*
+'undolevels'	options.txt	/*'undolevels'*
+'undoreload'	options.txt	/*'undoreload'*
+'updatecount'	options.txt	/*'updatecount'*
+'updatetime'	options.txt	/*'updatetime'*
+'ur'	options.txt	/*'ur'*
+'ut'	options.txt	/*'ut'*
+'varsofttabstop'	options.txt	/*'varsofttabstop'*
+'vartabstop'	options.txt	/*'vartabstop'*
+'vb'	options.txt	/*'vb'*
+'vbs'	options.txt	/*'vbs'*
+'vdir'	options.txt	/*'vdir'*
+'ve'	options.txt	/*'ve'*
+'verbose'	options.txt	/*'verbose'*
+'verbosefile'	options.txt	/*'verbosefile'*
+'vfile'	options.txt	/*'vfile'*
+'vi'	options.txt	/*'vi'*
+'viewdir'	options.txt	/*'viewdir'*
+'viewoptions'	options.txt	/*'viewoptions'*
+'vif'	options.txt	/*'vif'*
+'viminfo'	options.txt	/*'viminfo'*
+'viminfofile'	options.txt	/*'viminfofile'*
+'virtualedit'	options.txt	/*'virtualedit'*
+'visualbell'	options.txt	/*'visualbell'*
+'vop'	options.txt	/*'vop'*
+'vsts'	options.txt	/*'vsts'*
+'vts'	options.txt	/*'vts'*
+'w1200'	vi_diff.txt	/*'w1200'*
+'w300'	vi_diff.txt	/*'w300'*
+'w9600'	vi_diff.txt	/*'w9600'*
+'wa'	options.txt	/*'wa'*
+'wak'	options.txt	/*'wak'*
+'warn'	options.txt	/*'warn'*
+'wb'	options.txt	/*'wb'*
+'wc'	options.txt	/*'wc'*
+'wcm'	options.txt	/*'wcm'*
+'wd'	options.txt	/*'wd'*
+'weirdinvert'	options.txt	/*'weirdinvert'*
+'wfh'	options.txt	/*'wfh'*
+'wfw'	options.txt	/*'wfw'*
+'wh'	options.txt	/*'wh'*
+'whichwrap'	options.txt	/*'whichwrap'*
+'wi'	options.txt	/*'wi'*
+'wic'	options.txt	/*'wic'*
+'wig'	options.txt	/*'wig'*
+'wildchar'	options.txt	/*'wildchar'*
+'wildcharm'	options.txt	/*'wildcharm'*
+'wildignore'	options.txt	/*'wildignore'*
+'wildignorecase'	options.txt	/*'wildignorecase'*
+'wildmenu'	options.txt	/*'wildmenu'*
+'wildmode'	options.txt	/*'wildmode'*
+'wildoptions'	options.txt	/*'wildoptions'*
+'wim'	options.txt	/*'wim'*
+'winaltkeys'	options.txt	/*'winaltkeys'*
+'window'	options.txt	/*'window'*
+'winfixheight'	options.txt	/*'winfixheight'*
+'winfixwidth'	options.txt	/*'winfixwidth'*
+'winheight'	options.txt	/*'winheight'*
+'winminheight'	options.txt	/*'winminheight'*
+'winminwidth'	options.txt	/*'winminwidth'*
+'winptydll'	options.txt	/*'winptydll'*
+'winwidth'	options.txt	/*'winwidth'*
+'wiv'	options.txt	/*'wiv'*
+'wiw'	options.txt	/*'wiw'*
+'wm'	options.txt	/*'wm'*
+'wmh'	options.txt	/*'wmh'*
+'wmnu'	options.txt	/*'wmnu'*
+'wmw'	options.txt	/*'wmw'*
+'wop'	options.txt	/*'wop'*
+'wrap'	options.txt	/*'wrap'*
+'wrapmargin'	options.txt	/*'wrapmargin'*
+'wrapscan'	options.txt	/*'wrapscan'*
+'write'	options.txt	/*'write'*
+'writeany'	options.txt	/*'writeany'*
+'writebackup'	options.txt	/*'writebackup'*
+'writedelay'	options.txt	/*'writedelay'*
+'ws'	options.txt	/*'ws'*
+'ww'	options.txt	/*'ww'*
+'{	motion.txt	/*'{*
+'}	motion.txt	/*'}*
+(	motion.txt	/*(*
+)	motion.txt	/*)*
++	motion.txt	/*+*
+++bad	editing.txt	/*++bad*
+++bin	editing.txt	/*++bin*
+++builtin_terms	various.txt	/*++builtin_terms*
+++edit	editing.txt	/*++edit*
+++enc	editing.txt	/*++enc*
+++ff	editing.txt	/*++ff*
+++nobin	editing.txt	/*++nobin*
+++opt	editing.txt	/*++opt*
++ARP	various.txt	/*+ARP*
++GUI_Athena	various.txt	/*+GUI_Athena*
++GUI_GTK	various.txt	/*+GUI_GTK*
++GUI_Motif	various.txt	/*+GUI_Motif*
++GUI_Photon	various.txt	/*+GUI_Photon*
++GUI_neXtaw	various.txt	/*+GUI_neXtaw*
++X11	various.txt	/*+X11*
++acl	various.txt	/*+acl*
++arabic	various.txt	/*+arabic*
++autocmd	various.txt	/*+autocmd*
++autoservername	various.txt	/*+autoservername*
++balloon_eval	various.txt	/*+balloon_eval*
++balloon_eval_term	various.txt	/*+balloon_eval_term*
++browse	various.txt	/*+browse*
++builtin_terms	various.txt	/*+builtin_terms*
++byte_offset	various.txt	/*+byte_offset*
++channel	various.txt	/*+channel*
++cindent	various.txt	/*+cindent*
++clientserver	various.txt	/*+clientserver*
++clipboard	various.txt	/*+clipboard*
++cmd	editing.txt	/*+cmd*
++cmdline_compl	various.txt	/*+cmdline_compl*
++cmdline_hist	various.txt	/*+cmdline_hist*
++cmdline_info	various.txt	/*+cmdline_info*
++comments	various.txt	/*+comments*
++conceal	various.txt	/*+conceal*
++cryptv	various.txt	/*+cryptv*
++cscope	various.txt	/*+cscope*
++cursorbind	various.txt	/*+cursorbind*
++cursorshape	various.txt	/*+cursorshape*
++debug	various.txt	/*+debug*
++dialog_con	various.txt	/*+dialog_con*
++dialog_con_gui	various.txt	/*+dialog_con_gui*
++dialog_gui	various.txt	/*+dialog_gui*
++diff	various.txt	/*+diff*
++digraphs	various.txt	/*+digraphs*
++directx	various.txt	/*+directx*
++dnd	various.txt	/*+dnd*
++emacs_tags	various.txt	/*+emacs_tags*
++eval	various.txt	/*+eval*
++ex_extra	various.txt	/*+ex_extra*
++extra_search	various.txt	/*+extra_search*
++farsi	various.txt	/*+farsi*
++feature-list	various.txt	/*+feature-list*
++file_in_path	various.txt	/*+file_in_path*
++find_in_path	various.txt	/*+find_in_path*
++float	various.txt	/*+float*
++folding	various.txt	/*+folding*
++footer	various.txt	/*+footer*
++fork	various.txt	/*+fork*
++gettext	various.txt	/*+gettext*
++hangul_input	various.txt	/*+hangul_input*
++iconv	various.txt	/*+iconv*
++iconv/dyn	various.txt	/*+iconv\/dyn*
++insert_expand	various.txt	/*+insert_expand*
++job	various.txt	/*+job*
++jumplist	various.txt	/*+jumplist*
++keymap	various.txt	/*+keymap*
++lambda	various.txt	/*+lambda*
++langmap	various.txt	/*+langmap*
++libcall	various.txt	/*+libcall*
++linebreak	various.txt	/*+linebreak*
++lispindent	various.txt	/*+lispindent*
++listcmds	various.txt	/*+listcmds*
++localmap	various.txt	/*+localmap*
++lua	various.txt	/*+lua*
++lua/dyn	various.txt	/*+lua\/dyn*
++menu	various.txt	/*+menu*
++mksession	various.txt	/*+mksession*
++modify_fname	various.txt	/*+modify_fname*
++mouse	various.txt	/*+mouse*
++mouse_dec	various.txt	/*+mouse_dec*
++mouse_gpm	various.txt	/*+mouse_gpm*
++mouse_jsbterm	various.txt	/*+mouse_jsbterm*
++mouse_netterm	various.txt	/*+mouse_netterm*
++mouse_pterm	various.txt	/*+mouse_pterm*
++mouse_sgr	various.txt	/*+mouse_sgr*
++mouse_sysmouse	various.txt	/*+mouse_sysmouse*
++mouse_urxvt	various.txt	/*+mouse_urxvt*
++mouse_xterm	various.txt	/*+mouse_xterm*
++mouseshape	various.txt	/*+mouseshape*
++multi_byte	various.txt	/*+multi_byte*
++multi_byte_ime	various.txt	/*+multi_byte_ime*
++multi_lang	various.txt	/*+multi_lang*
++mzscheme	various.txt	/*+mzscheme*
++mzscheme/dyn	various.txt	/*+mzscheme\/dyn*
++netbeans_intg	various.txt	/*+netbeans_intg*
++num64	various.txt	/*+num64*
++ole	various.txt	/*+ole*
++packages	various.txt	/*+packages*
++path_extra	various.txt	/*+path_extra*
++perl	various.txt	/*+perl*
++perl/dyn	various.txt	/*+perl\/dyn*
++persistent_undo	various.txt	/*+persistent_undo*
++postscript	various.txt	/*+postscript*
++printer	various.txt	/*+printer*
++profile	various.txt	/*+profile*
++python	various.txt	/*+python*
++python/dyn	various.txt	/*+python\/dyn*
++python3	various.txt	/*+python3*
++python3/dyn	various.txt	/*+python3\/dyn*
++quickfix	various.txt	/*+quickfix*
++reltime	various.txt	/*+reltime*
++rightleft	various.txt	/*+rightleft*
++ruby	various.txt	/*+ruby*
++ruby/dyn	various.txt	/*+ruby\/dyn*
++scrollbind	various.txt	/*+scrollbind*
++signs	various.txt	/*+signs*
++smartindent	various.txt	/*+smartindent*
++startuptime	various.txt	/*+startuptime*
++statusline	various.txt	/*+statusline*
++sun_workshop	various.txt	/*+sun_workshop*
++syntax	various.txt	/*+syntax*
++system()	various.txt	/*+system()*
++tag_any_white	various.txt	/*+tag_any_white*
++tag_binary	various.txt	/*+tag_binary*
++tag_old_static	various.txt	/*+tag_old_static*
++tcl	various.txt	/*+tcl*
++tcl/dyn	various.txt	/*+tcl\/dyn*
++termguicolors	various.txt	/*+termguicolors*
++terminal	various.txt	/*+terminal*
++terminfo	various.txt	/*+terminfo*
++termresponse	various.txt	/*+termresponse*
++textobjects	various.txt	/*+textobjects*
++tgetent	various.txt	/*+tgetent*
++timers	various.txt	/*+timers*
++title	various.txt	/*+title*
++toolbar	various.txt	/*+toolbar*
++unix	eval.txt	/*+unix*
++user_commands	various.txt	/*+user_commands*
++vartabs	various.txt	/*+vartabs*
++vertsplit	various.txt	/*+vertsplit*
++viminfo	various.txt	/*+viminfo*
++virtualedit	various.txt	/*+virtualedit*
++visual	various.txt	/*+visual*
++visualextra	various.txt	/*+visualextra*
++vreplace	various.txt	/*+vreplace*
++vtp	various.txt	/*+vtp*
++wildignore	various.txt	/*+wildignore*
++wildmenu	various.txt	/*+wildmenu*
++windows	various.txt	/*+windows*
++writebackup	various.txt	/*+writebackup*
++xfontset	various.txt	/*+xfontset*
++xim	various.txt	/*+xim*
++xpm	various.txt	/*+xpm*
++xpm_w32	various.txt	/*+xpm_w32*
++xsmp	various.txt	/*+xsmp*
++xsmp_interact	various.txt	/*+xsmp_interact*
++xterm_clipboard	various.txt	/*+xterm_clipboard*
++xterm_save	various.txt	/*+xterm_save*
+,	motion.txt	/*,*
+-	motion.txt	/*-*
+-+	starting.txt	/*-+*
+-+/	starting.txt	/*-+\/*
+-+c	starting.txt	/*-+c*
+-+reverse	gui_x11.txt	/*-+reverse*
+-+rv	gui_x11.txt	/*-+rv*
+--	starting.txt	/*--*
+---	starting.txt	/*---*
+--clean	starting.txt	/*--clean*
+--cmd	starting.txt	/*--cmd*
+--echo-wid	starting.txt	/*--echo-wid*
+--help	starting.txt	/*--help*
+--literal	starting.txt	/*--literal*
+--nofork	starting.txt	/*--nofork*
+--noplugin	starting.txt	/*--noplugin*
+--not-a-term	starting.txt	/*--not-a-term*
+--remote	remote.txt	/*--remote*
+--remote-expr	remote.txt	/*--remote-expr*
+--remote-send	remote.txt	/*--remote-send*
+--remote-silent	remote.txt	/*--remote-silent*
+--remote-tab	remote.txt	/*--remote-tab*
+--remote-tab-silent	remote.txt	/*--remote-tab-silent*
+--remote-tab-wait	remote.txt	/*--remote-tab-wait*
+--remote-tab-wait-silent	remote.txt	/*--remote-tab-wait-silent*
+--remote-wait	remote.txt	/*--remote-wait*
+--remote-wait-silent	remote.txt	/*--remote-wait-silent*
+--role	starting.txt	/*--role*
+--serverlist	remote.txt	/*--serverlist*
+--servername	remote.txt	/*--servername*
+--socketid	starting.txt	/*--socketid*
+--startuptime	starting.txt	/*--startuptime*
+--ttyfail	starting.txt	/*--ttyfail*
+--version	starting.txt	/*--version*
+--windowid	starting.txt	/*--windowid*
+-?	starting.txt	/*-?*
+-A	starting.txt	/*-A*
+-C	starting.txt	/*-C*
+-D	starting.txt	/*-D*
+-E	starting.txt	/*-E*
+-F	starting.txt	/*-F*
+-H	starting.txt	/*-H*
+-L	starting.txt	/*-L*
+-M	starting.txt	/*-M*
+-N	starting.txt	/*-N*
+-O	starting.txt	/*-O*
+-P	starting.txt	/*-P*
+-R	starting.txt	/*-R*
+-S	starting.txt	/*-S*
+-T	starting.txt	/*-T*
+-U	starting.txt	/*-U*
+-V	starting.txt	/*-V*
+-W	starting.txt	/*-W*
+-X	starting.txt	/*-X*
+-Z	starting.txt	/*-Z*
+-b	starting.txt	/*-b*
+-background	gui_x11.txt	/*-background*
+-bg	gui_x11.txt	/*-bg*
+-boldfont	gui_x11.txt	/*-boldfont*
+-borderwidth	gui_x11.txt	/*-borderwidth*
+-bw	gui_x11.txt	/*-bw*
+-c	starting.txt	/*-c*
+-d	starting.txt	/*-d*
+-dev	starting.txt	/*-dev*
+-display	gui_x11.txt	/*-display*
+-e	starting.txt	/*-e*
+-f	starting.txt	/*-f*
+-fg	gui_x11.txt	/*-fg*
+-file	starting.txt	/*-file*
+-fn	gui_x11.txt	/*-fn*
+-font	gui_x11.txt	/*-font*
+-foreground	gui_x11.txt	/*-foreground*
+-g	starting.txt	/*-g*
+-geom	gui_x11.txt	/*-geom*
+-geometry	gui_x11.txt	/*-geometry*
+-geometry-example	gui_x11.txt	/*-geometry-example*
+-gui	gui_x11.txt	/*-gui*
+-h	starting.txt	/*-h*
+-i	starting.txt	/*-i*
+-iconic	gui_x11.txt	/*-iconic*
+-italicfont	gui_x11.txt	/*-italicfont*
+-l	starting.txt	/*-l*
+-m	starting.txt	/*-m*
+-menufont	gui_x11.txt	/*-menufont*
+-menufontset	gui_x11.txt	/*-menufontset*
+-menuheight	gui_x11.txt	/*-menuheight*
+-mf	gui_x11.txt	/*-mf*
+-mh	gui_x11.txt	/*-mh*
+-n	starting.txt	/*-n*
+-nb	starting.txt	/*-nb*
+-o	starting.txt	/*-o*
+-p	starting.txt	/*-p*
+-q	starting.txt	/*-q*
+-qf	starting.txt	/*-qf*
+-r	starting.txt	/*-r*
+-register	if_ole.txt	/*-register*
+-reverse	gui_x11.txt	/*-reverse*
+-rv	gui_x11.txt	/*-rv*
+-s	starting.txt	/*-s*
+-s-ex	starting.txt	/*-s-ex*
+-scrollbarwidth	gui_x11.txt	/*-scrollbarwidth*
+-silent	if_ole.txt	/*-silent*
+-sw	gui_x11.txt	/*-sw*
+-t	starting.txt	/*-t*
+-tag	starting.txt	/*-tag*
+-u	starting.txt	/*-u*
+-ul	gui_x11.txt	/*-ul*
+-unregister	if_ole.txt	/*-unregister*
+-v	starting.txt	/*-v*
+-vim	starting.txt	/*-vim*
+-w	starting.txt	/*-w*
+-w_nr	starting.txt	/*-w_nr*
+-x	starting.txt	/*-x*
+-xrm	gui_x11.txt	/*-xrm*
+-y	starting.txt	/*-y*
+.	repeat.txt	/*.*
+...	eval.txt	/*...*
+.Xdefaults	gui_x11.txt	/*.Xdefaults*
+.aff	spell.txt	/*.aff*
+.dic	spell.txt	/*.dic*
+.exrc	starting.txt	/*.exrc*
+.gvimrc	gui.txt	/*.gvimrc*
+.netrwbook	pi_netrw.txt	/*.netrwbook*
+.netrwhist	pi_netrw.txt	/*.netrwhist*
+.vimrc	starting.txt	/*.vimrc*
+/	pattern.txt	/*\/*
+/$	pattern.txt	/*\/$*
+/.	pattern.txt	/*\/.*
+//	version7.txt	/*\/\/*
+//;	pattern.txt	/*\/\/;*
+/<CR>	pattern.txt	/*\/<CR>*
+/[[.	pattern.txt	/*\/[[.*
+/[[=	pattern.txt	/*\/[[=*
+/[\n]	pattern.txt	/*\/[\\n]*
+/[]	pattern.txt	/*\/[]*
+/\	pattern.txt	/*\/\\*
+/\$	pattern.txt	/*\/\\$*
+/\%#	pattern.txt	/*\/\\%#*
+/\%#=	pattern.txt	/*\/\\%#=*
+/\%$	pattern.txt	/*\/\\%$*
+/\%'m	pattern.txt	/*\/\\%'m*
+/\%(	pattern.txt	/*\/\\%(*
+/\%(\)	pattern.txt	/*\/\\%(\\)*
+/\%<'m	pattern.txt	/*\/\\%<'m*
+/\%<c	pattern.txt	/*\/\\%<c*
+/\%<l	pattern.txt	/*\/\\%<l*
+/\%<v	pattern.txt	/*\/\\%<v*
+/\%>'m	pattern.txt	/*\/\\%>'m*
+/\%>c	pattern.txt	/*\/\\%>c*
+/\%>l	pattern.txt	/*\/\\%>l*
+/\%>v	pattern.txt	/*\/\\%>v*
+/\%C	pattern.txt	/*\/\\%C*
+/\%U	pattern.txt	/*\/\\%U*
+/\%V	pattern.txt	/*\/\\%V*
+/\%[]	pattern.txt	/*\/\\%[]*
+/\%^	pattern.txt	/*\/\\%^*
+/\%c	pattern.txt	/*\/\\%c*
+/\%d	pattern.txt	/*\/\\%d*
+/\%l	pattern.txt	/*\/\\%l*
+/\%o	pattern.txt	/*\/\\%o*
+/\%u	pattern.txt	/*\/\\%u*
+/\%v	pattern.txt	/*\/\\%v*
+/\%x	pattern.txt	/*\/\\%x*
+/\&	pattern.txt	/*\/\\&*
+/\(	pattern.txt	/*\/\\(*
+/\(\)	pattern.txt	/*\/\\(\\)*
+/\)	pattern.txt	/*\/\\)*
+/\+	pattern.txt	/*\/\\+*
+/\.	pattern.txt	/*\/\\.*
+/\1	pattern.txt	/*\/\\1*
+/\2	pattern.txt	/*\/\\2*
+/\3	pattern.txt	/*\/\\3*
+/\9	pattern.txt	/*\/\\9*
+/\<	pattern.txt	/*\/\\<*
+/\=	pattern.txt	/*\/\\=*
+/\>	pattern.txt	/*\/\\>*
+/\?	pattern.txt	/*\/\\?*
+/\@!	pattern.txt	/*\/\\@!*
+/\@<!	pattern.txt	/*\/\\@<!*
+/\@<=	pattern.txt	/*\/\\@<=*
+/\@=	pattern.txt	/*\/\\@=*
+/\@>	pattern.txt	/*\/\\@>*
+/\A	pattern.txt	/*\/\\A*
+/\C	pattern.txt	/*\/\\C*
+/\D	pattern.txt	/*\/\\D*
+/\F	pattern.txt	/*\/\\F*
+/\H	pattern.txt	/*\/\\H*
+/\I	pattern.txt	/*\/\\I*
+/\K	pattern.txt	/*\/\\K*
+/\L	pattern.txt	/*\/\\L*
+/\M	pattern.txt	/*\/\\M*
+/\O	pattern.txt	/*\/\\O*
+/\P	pattern.txt	/*\/\\P*
+/\S	pattern.txt	/*\/\\S*
+/\U	pattern.txt	/*\/\\U*
+/\V	pattern.txt	/*\/\\V*
+/\W	pattern.txt	/*\/\\W*
+/\X	pattern.txt	/*\/\\X*
+/\Z	pattern.txt	/*\/\\Z*
+/\[]	pattern.txt	/*\/\\[]*
+/\\	pattern.txt	/*\/\\\\*
+/\]	pattern.txt	/*\/\\]*
+/\^	pattern.txt	/*\/\\^*
+/\_	pattern.txt	/*\/\\_*
+/\_$	pattern.txt	/*\/\\_$*
+/\_.	pattern.txt	/*\/\\_.*
+/\_A	pattern.txt	/*\/\\_A*
+/\_D	pattern.txt	/*\/\\_D*
+/\_F	pattern.txt	/*\/\\_F*
+/\_H	pattern.txt	/*\/\\_H*
+/\_I	pattern.txt	/*\/\\_I*
+/\_K	pattern.txt	/*\/\\_K*
+/\_L	pattern.txt	/*\/\\_L*
+/\_O	pattern.txt	/*\/\\_O*
+/\_P	pattern.txt	/*\/\\_P*
+/\_S	pattern.txt	/*\/\\_S*
+/\_U	pattern.txt	/*\/\\_U*
+/\_W	pattern.txt	/*\/\\_W*
+/\_X	pattern.txt	/*\/\\_X*
+/\_[]	pattern.txt	/*\/\\_[]*
+/\_^	pattern.txt	/*\/\\_^*
+/\_a	pattern.txt	/*\/\\_a*
+/\_d	pattern.txt	/*\/\\_d*
+/\_f	pattern.txt	/*\/\\_f*
+/\_h	pattern.txt	/*\/\\_h*
+/\_i	pattern.txt	/*\/\\_i*
+/\_k	pattern.txt	/*\/\\_k*
+/\_l	pattern.txt	/*\/\\_l*
+/\_o	pattern.txt	/*\/\\_o*
+/\_p	pattern.txt	/*\/\\_p*
+/\_s	pattern.txt	/*\/\\_s*
+/\_u	pattern.txt	/*\/\\_u*
+/\_w	pattern.txt	/*\/\\_w*
+/\_x	pattern.txt	/*\/\\_x*
+/\a	pattern.txt	/*\/\\a*
+/\b	pattern.txt	/*\/\\b*
+/\bar	pattern.txt	/*\/\\bar*
+/\c	pattern.txt	/*\/\\c*
+/\d	pattern.txt	/*\/\\d*
+/\e	pattern.txt	/*\/\\e*
+/\f	pattern.txt	/*\/\\f*
+/\h	pattern.txt	/*\/\\h*
+/\i	pattern.txt	/*\/\\i*
+/\k	pattern.txt	/*\/\\k*
+/\l	pattern.txt	/*\/\\l*
+/\m	pattern.txt	/*\/\\m*
+/\n	pattern.txt	/*\/\\n*
+/\o	pattern.txt	/*\/\\o*
+/\p	pattern.txt	/*\/\\p*
+/\r	pattern.txt	/*\/\\r*
+/\s	pattern.txt	/*\/\\s*
+/\star	pattern.txt	/*\/\\star*
+/\t	pattern.txt	/*\/\\t*
+/\u	pattern.txt	/*\/\\u*
+/\v	pattern.txt	/*\/\\v*
+/\w	pattern.txt	/*\/\\w*
+/\x	pattern.txt	/*\/\\x*
+/\z(	syntax.txt	/*\/\\z(*
+/\z(\)	syntax.txt	/*\/\\z(\\)*
+/\z1	syntax.txt	/*\/\\z1*
+/\z2	syntax.txt	/*\/\\z2*
+/\z3	syntax.txt	/*\/\\z3*
+/\z4	syntax.txt	/*\/\\z4*
+/\z5	syntax.txt	/*\/\\z5*
+/\z6	syntax.txt	/*\/\\z6*
+/\z7	syntax.txt	/*\/\\z7*
+/\z8	syntax.txt	/*\/\\z8*
+/\z9	syntax.txt	/*\/\\z9*
+/\ze	pattern.txt	/*\/\\ze*
+/\zs	pattern.txt	/*\/\\zs*
+/\{	pattern.txt	/*\/\\{*
+/\{-	pattern.txt	/*\/\\{-*
+/\~	pattern.txt	/*\/\\~*
+/^	pattern.txt	/*\/^*
+/_CTRL-G	cmdline.txt	/*\/_CTRL-G*
+/_CTRL-L	cmdline.txt	/*\/_CTRL-L*
+/_CTRL-T	cmdline.txt	/*\/_CTRL-T*
+/atom	pattern.txt	/*\/atom*
+/bar	pattern.txt	/*\/bar*
+/branch	pattern.txt	/*\/branch*
+/character-classes	pattern.txt	/*\/character-classes*
+/collection	pattern.txt	/*\/collection*
+/concat	pattern.txt	/*\/concat*
+/dyn	various.txt	/*\/dyn*
+/ignorecase	pattern.txt	/*\/ignorecase*
+/magic	pattern.txt	/*\/magic*
+/multi	pattern.txt	/*\/multi*
+/ordinary-atom	pattern.txt	/*\/ordinary-atom*
+/pattern	pattern.txt	/*\/pattern*
+/piece	pattern.txt	/*\/piece*
+/star	pattern.txt	/*\/star*
+/zero-width	pattern.txt	/*\/zero-width*
+/~	pattern.txt	/*\/~*
+0	motion.txt	/*0*
+01.1	usr_01.txt	/*01.1*
+01.2	usr_01.txt	/*01.2*
+01.3	usr_01.txt	/*01.3*
+01.4	usr_01.txt	/*01.4*
+02.1	usr_02.txt	/*02.1*
+02.2	usr_02.txt	/*02.2*
+02.3	usr_02.txt	/*02.3*
+02.4	usr_02.txt	/*02.4*
+02.5	usr_02.txt	/*02.5*
+02.6	usr_02.txt	/*02.6*
+02.7	usr_02.txt	/*02.7*
+02.8	usr_02.txt	/*02.8*
+03.1	usr_03.txt	/*03.1*
+03.10	usr_03.txt	/*03.10*
+03.2	usr_03.txt	/*03.2*
+03.3	usr_03.txt	/*03.3*
+03.4	usr_03.txt	/*03.4*
+03.5	usr_03.txt	/*03.5*
+03.6	usr_03.txt	/*03.6*
+03.7	usr_03.txt	/*03.7*
+03.8	usr_03.txt	/*03.8*
+03.9	usr_03.txt	/*03.9*
+04.1	usr_04.txt	/*04.1*
+04.10	usr_04.txt	/*04.10*
+04.2	usr_04.txt	/*04.2*
+04.3	usr_04.txt	/*04.3*
+04.4	usr_04.txt	/*04.4*
+04.5	usr_04.txt	/*04.5*
+04.6	usr_04.txt	/*04.6*
+04.7	usr_04.txt	/*04.7*
+04.8	usr_04.txt	/*04.8*
+04.9	usr_04.txt	/*04.9*
+05.1	usr_05.txt	/*05.1*
+05.2	usr_05.txt	/*05.2*
+05.3	usr_05.txt	/*05.3*
+05.4	usr_05.txt	/*05.4*
+05.5	usr_05.txt	/*05.5*
+05.6	usr_05.txt	/*05.6*
+05.7	usr_05.txt	/*05.7*
+05.8	usr_05.txt	/*05.8*
+06.1	usr_06.txt	/*06.1*
+06.2	usr_06.txt	/*06.2*
+06.3	usr_06.txt	/*06.3*
+06.4	usr_06.txt	/*06.4*
+06.5	usr_06.txt	/*06.5*
+06.6	usr_06.txt	/*06.6*
+07.1	usr_07.txt	/*07.1*
+07.2	usr_07.txt	/*07.2*
+07.3	usr_07.txt	/*07.3*
+07.4	usr_07.txt	/*07.4*
+07.5	usr_07.txt	/*07.5*
+07.6	usr_07.txt	/*07.6*
+07.7	usr_07.txt	/*07.7*
+08.1	usr_08.txt	/*08.1*
+08.2	usr_08.txt	/*08.2*
+08.3	usr_08.txt	/*08.3*
+08.4	usr_08.txt	/*08.4*
+08.5	usr_08.txt	/*08.5*
+08.6	usr_08.txt	/*08.6*
+08.7	usr_08.txt	/*08.7*
+08.8	usr_08.txt	/*08.8*
+08.9	usr_08.txt	/*08.9*
+09.1	usr_09.txt	/*09.1*
+09.2	usr_09.txt	/*09.2*
+09.3	usr_09.txt	/*09.3*
+09.4	usr_09.txt	/*09.4*
+10.1	usr_10.txt	/*10.1*
+10.2	usr_10.txt	/*10.2*
+10.3	usr_10.txt	/*10.3*
+10.4	usr_10.txt	/*10.4*
+10.5	usr_10.txt	/*10.5*
+10.6	usr_10.txt	/*10.6*
+10.7	usr_10.txt	/*10.7*
+10.8	usr_10.txt	/*10.8*
+10.9	usr_10.txt	/*10.9*
+11.1	usr_11.txt	/*11.1*
+11.2	usr_11.txt	/*11.2*
+11.3	usr_11.txt	/*11.3*
+11.4	usr_11.txt	/*11.4*
+12.1	usr_12.txt	/*12.1*
+12.2	usr_12.txt	/*12.2*
+12.3	usr_12.txt	/*12.3*
+12.4	usr_12.txt	/*12.4*
+12.5	usr_12.txt	/*12.5*
+12.6	usr_12.txt	/*12.6*
+12.7	usr_12.txt	/*12.7*
+12.8	usr_12.txt	/*12.8*
+1gD	pattern.txt	/*1gD*
+1gd	pattern.txt	/*1gd*
+20.1	usr_20.txt	/*20.1*
+20.2	usr_20.txt	/*20.2*
+20.3	usr_20.txt	/*20.3*
+20.4	usr_20.txt	/*20.4*
+20.5	usr_20.txt	/*20.5*
+21.1	usr_21.txt	/*21.1*
+21.2	usr_21.txt	/*21.2*
+21.3	usr_21.txt	/*21.3*
+21.4	usr_21.txt	/*21.4*
+21.5	usr_21.txt	/*21.5*
+21.6	usr_21.txt	/*21.6*
+22.1	usr_22.txt	/*22.1*
+22.2	usr_22.txt	/*22.2*
+22.3	usr_22.txt	/*22.3*
+22.4	usr_22.txt	/*22.4*
+23.1	usr_23.txt	/*23.1*
+23.2	usr_23.txt	/*23.2*
+23.3	usr_23.txt	/*23.3*
+23.4	usr_23.txt	/*23.4*
+23.5	usr_23.txt	/*23.5*
+24.1	usr_24.txt	/*24.1*
+24.10	usr_24.txt	/*24.10*
+24.2	usr_24.txt	/*24.2*
+24.3	usr_24.txt	/*24.3*
+24.4	usr_24.txt	/*24.4*
+24.5	usr_24.txt	/*24.5*
+24.6	usr_24.txt	/*24.6*
+24.7	usr_24.txt	/*24.7*
+24.8	usr_24.txt	/*24.8*
+24.9	usr_24.txt	/*24.9*
+25.1	usr_25.txt	/*25.1*
+25.2	usr_25.txt	/*25.2*
+25.3	usr_25.txt	/*25.3*
+25.4	usr_25.txt	/*25.4*
+25.5	usr_25.txt	/*25.5*
+26.1	usr_26.txt	/*26.1*
+26.2	usr_26.txt	/*26.2*
+26.3	usr_26.txt	/*26.3*
+26.4	usr_26.txt	/*26.4*
+27.1	usr_27.txt	/*27.1*
+27.2	usr_27.txt	/*27.2*
+27.3	usr_27.txt	/*27.3*
+27.4	usr_27.txt	/*27.4*
+27.5	usr_27.txt	/*27.5*
+27.6	usr_27.txt	/*27.6*
+27.7	usr_27.txt	/*27.7*
+27.8	usr_27.txt	/*27.8*
+27.9	usr_27.txt	/*27.9*
+28.1	usr_28.txt	/*28.1*
+28.10	usr_28.txt	/*28.10*
+28.2	usr_28.txt	/*28.2*
+28.3	usr_28.txt	/*28.3*
+28.4	usr_28.txt	/*28.4*
+28.5	usr_28.txt	/*28.5*
+28.6	usr_28.txt	/*28.6*
+28.7	usr_28.txt	/*28.7*
+28.8	usr_28.txt	/*28.8*
+28.9	usr_28.txt	/*28.9*
+29.1	usr_29.txt	/*29.1*
+29.2	usr_29.txt	/*29.2*
+29.3	usr_29.txt	/*29.3*
+29.4	usr_29.txt	/*29.4*
+29.5	usr_29.txt	/*29.5*
+2html.vim	syntax.txt	/*2html.vim*
+30.1	usr_30.txt	/*30.1*
+30.2	usr_30.txt	/*30.2*
+30.3	usr_30.txt	/*30.3*
+30.4	usr_30.txt	/*30.4*
+30.5	usr_30.txt	/*30.5*
+30.6	usr_30.txt	/*30.6*
+31.1	usr_31.txt	/*31.1*
+31.2	usr_31.txt	/*31.2*
+31.3	usr_31.txt	/*31.3*
+31.4	usr_31.txt	/*31.4*
+31.5	usr_31.txt	/*31.5*
+32.1	usr_32.txt	/*32.1*
+32.2	usr_32.txt	/*32.2*
+32.3	usr_32.txt	/*32.3*
+32.4	usr_32.txt	/*32.4*
+40.1	usr_40.txt	/*40.1*
+40.2	usr_40.txt	/*40.2*
+40.3	usr_40.txt	/*40.3*
+41.1	usr_41.txt	/*41.1*
+41.10	usr_41.txt	/*41.10*
+41.11	usr_41.txt	/*41.11*
+41.12	usr_41.txt	/*41.12*
+41.13	usr_41.txt	/*41.13*
+41.14	usr_41.txt	/*41.14*
+41.15	usr_41.txt	/*41.15*
+41.16	usr_41.txt	/*41.16*
+41.2	usr_41.txt	/*41.2*
+41.3	usr_41.txt	/*41.3*
+41.4	usr_41.txt	/*41.4*
+41.5	usr_41.txt	/*41.5*
+41.6	usr_41.txt	/*41.6*
+41.7	usr_41.txt	/*41.7*
+41.8	usr_41.txt	/*41.8*
+41.9	usr_41.txt	/*41.9*
+42	usr_42.txt	/*42*
+42.1	usr_42.txt	/*42.1*
+42.2	usr_42.txt	/*42.2*
+42.3	usr_42.txt	/*42.3*
+42.4	usr_42.txt	/*42.4*
+43.1	usr_43.txt	/*43.1*
+43.2	usr_43.txt	/*43.2*
+44.1	usr_44.txt	/*44.1*
+44.10	usr_44.txt	/*44.10*
+44.11	usr_44.txt	/*44.11*
+44.12	usr_44.txt	/*44.12*
+44.2	usr_44.txt	/*44.2*
+44.3	usr_44.txt	/*44.3*
+44.4	usr_44.txt	/*44.4*
+44.5	usr_44.txt	/*44.5*
+44.6	usr_44.txt	/*44.6*
+44.7	usr_44.txt	/*44.7*
+44.8	usr_44.txt	/*44.8*
+44.9	usr_44.txt	/*44.9*
+45.1	usr_45.txt	/*45.1*
+45.2	usr_45.txt	/*45.2*
+45.3	usr_45.txt	/*45.3*
+45.4	usr_45.txt	/*45.4*
+45.5	usr_45.txt	/*45.5*
+8g8	various.txt	/*8g8*
+90.1	usr_90.txt	/*90.1*
+90.2	usr_90.txt	/*90.2*
+90.3	usr_90.txt	/*90.3*
+90.4	usr_90.txt	/*90.4*
+90.5	usr_90.txt	/*90.5*
+:	cmdline.txt	/*:*
+:!	various.txt	/*:!*
+:!!	various.txt	/*:!!*
+:!cmd	various.txt	/*:!cmd*
+:!start	os_win32.txt	/*:!start*
+:#	various.txt	/*:#*
+:#!	various.txt	/*:#!*
+:$	cmdline.txt	/*:$*
+:%	cmdline.txt	/*:%*
+:&	change.txt	/*:&*
+:&&	change.txt	/*:&&*
+:'	cmdline.txt	/*:'*
+:,	cmdline.txt	/*:,*
+:.	cmdline.txt	/*:.*
+:/	cmdline.txt	/*:\/*
+:0file	editing.txt	/*:0file*
+:2match	pattern.txt	/*:2match*
+:3match	pattern.txt	/*:3match*
+::.	cmdline.txt	/*::.*
+::8	cmdline.txt	/*::8*
+::S	cmdline.txt	/*::S*
+::e	cmdline.txt	/*::e*
+::gs	cmdline.txt	/*::gs*
+::h	cmdline.txt	/*::h*
+::p	cmdline.txt	/*::p*
+::r	cmdline.txt	/*::r*
+::s	cmdline.txt	/*::s*
+::t	cmdline.txt	/*::t*
+::~	cmdline.txt	/*::~*
+:;	cmdline.txt	/*:;*
+:<	change.txt	/*:<*
+:<abuf>	cmdline.txt	/*:<abuf>*
+:<afile>	cmdline.txt	/*:<afile>*
+:<amatch>	cmdline.txt	/*:<amatch>*
+:<cWORD>	cmdline.txt	/*:<cWORD>*
+:<cexpr>	cmdline.txt	/*:<cexpr>*
+:<cfile>	cmdline.txt	/*:<cfile>*
+:<cword>	cmdline.txt	/*:<cword>*
+:<sfile>	cmdline.txt	/*:<sfile>*
+:=	various.txt	/*:=*
+:>	change.txt	/*:>*
+:?	cmdline.txt	/*:?*
+:@	repeat.txt	/*:@*
+:@:	repeat.txt	/*:@:*
+:@@	repeat.txt	/*:@@*
+:AdaLines	ft_ada.txt	/*:AdaLines*
+:AdaRainbow	ft_ada.txt	/*:AdaRainbow*
+:AdaSpaces	ft_ada.txt	/*:AdaSpaces*
+:AdaTagDir	ft_ada.txt	/*:AdaTagDir*
+:AdaTagFile	ft_ada.txt	/*:AdaTagFile*
+:AdaTypes	ft_ada.txt	/*:AdaTypes*
+:Arguments	terminal.txt	/*:Arguments*
+:Break	terminal.txt	/*:Break*
+:Clear	terminal.txt	/*:Clear*
+:CompilerSet	usr_41.txt	/*:CompilerSet*
+:Continue	terminal.txt	/*:Continue*
+:DiffOrig	diff.txt	/*:DiffOrig*
+:DoMatchParen	pi_paren.txt	/*:DoMatchParen*
+:Evaluate	terminal.txt	/*:Evaluate*
+:Explore	pi_netrw.txt	/*:Explore*
+:Finish	terminal.txt	/*:Finish*
+:GLVS	pi_getscript.txt	/*:GLVS*
+:Gdb	terminal.txt	/*:Gdb*
+:GetLatestVimScripts_dat	pi_getscript.txt	/*:GetLatestVimScripts_dat*
+:GnatFind	ft_ada.txt	/*:GnatFind*
+:GnatPretty	ft_ada.txt	/*:GnatPretty*
+:GnatTags	ft_ada.txt	/*:GnatTags*
+:Hexplore	pi_netrw.txt	/*:Hexplore*
+:LP	pi_logipat.txt	/*:LP*
+:LPE	pi_logipat.txt	/*:LPE*
+:LPF	pi_logipat.txt	/*:LPF*
+:Lexplore	pi_netrw.txt	/*:Lexplore*
+:LogiPat	pi_logipat.txt	/*:LogiPat*
+:Man	filetype.txt	/*:Man*
+:MkVimball	pi_vimball.txt	/*:MkVimball*
+:N	editing.txt	/*:N*
+:NetrwClean	pi_netrw.txt	/*:NetrwClean*
+:Nexplore	pi_netrw.txt	/*:Nexplore*
+:Next	editing.txt	/*:Next*
+:NoMatchParen	pi_paren.txt	/*:NoMatchParen*
+:Nr	pi_netrw.txt	/*:Nr*
+:Nread	pi_netrw.txt	/*:Nread*
+:Ns	pi_netrw.txt	/*:Ns*
+:Nsource	pi_netrw.txt	/*:Nsource*
+:Ntree	pi_netrw.txt	/*:Ntree*
+:Nw	pi_netrw.txt	/*:Nw*
+:Nwrite	pi_netrw.txt	/*:Nwrite*
+:Over	terminal.txt	/*:Over*
+:P	various.txt	/*:P*
+:Pexplore	pi_netrw.txt	/*:Pexplore*
+:Print	various.txt	/*:Print*
+:Program	terminal.txt	/*:Program*
+:Rexplore	pi_netrw.txt	/*:Rexplore*
+:RmVimball	pi_vimball.txt	/*:RmVimball*
+:Run	terminal.txt	/*:Run*
+:RustEmitAsm	ft_rust.txt	/*:RustEmitAsm*
+:RustEmitIr	ft_rust.txt	/*:RustEmitIr*
+:RustExpand	ft_rust.txt	/*:RustExpand*
+:RustFmt	ft_rust.txt	/*:RustFmt*
+:RustFmtRange	ft_rust.txt	/*:RustFmtRange*
+:RustPlay	ft_rust.txt	/*:RustPlay*
+:RustRun	ft_rust.txt	/*:RustRun*
+:Sexplore	pi_netrw.txt	/*:Sexplore*
+:Source	terminal.txt	/*:Source*
+:Step	terminal.txt	/*:Step*
+:Stop	terminal.txt	/*:Stop*
+:TOhtml	syntax.txt	/*:TOhtml*
+:TarDiff	pi_tar.txt	/*:TarDiff*
+:Termdebug	terminal.txt	/*:Termdebug*
+:TermdebugCommand	terminal.txt	/*:TermdebugCommand*
+:Texplore	pi_netrw.txt	/*:Texplore*
+:UseVimball	pi_vimball.txt	/*:UseVimball*
+:Vexplore	pi_netrw.txt	/*:Vexplore*
+:VimballList	pi_vimball.txt	/*:VimballList*
+:Vimuntar	pi_tar.txt	/*:Vimuntar*
+:Winbar	terminal.txt	/*:Winbar*
+:X	editing.txt	/*:X*
+:XMLent	insert.txt	/*:XMLent*
+:XMLns	insert.txt	/*:XMLns*
+:[range]	motion.txt	/*:[range]*
+:\bar	cmdline.txt	/*:\\bar*
+:_!	cmdline.txt	/*:_!*
+:_#	cmdline.txt	/*:_#*
+:_##	cmdline.txt	/*:_##*
+:_#0	cmdline.txt	/*:_#0*
+:_#<	cmdline.txt	/*:_#<*
+:_#n	cmdline.txt	/*:_#n*
+:_%	cmdline.txt	/*:_%*
+:_%:	cmdline.txt	/*:_%:*
+:_%<	cmdline.txt	/*:_%<*
+:a	insert.txt	/*:a*
+:ab	map.txt	/*:ab*
+:abbreviate	map.txt	/*:abbreviate*
+:abbreviate-<buffer>	map.txt	/*:abbreviate-<buffer>*
+:abbreviate-local	map.txt	/*:abbreviate-local*
+:abbreviate-verbose	map.txt	/*:abbreviate-verbose*
+:abc	map.txt	/*:abc*
+:abclear	map.txt	/*:abclear*
+:abo	windows.txt	/*:abo*
+:aboveleft	windows.txt	/*:aboveleft*
+:al	windows.txt	/*:al*
+:all	windows.txt	/*:all*
+:am	gui.txt	/*:am*
+:amenu	gui.txt	/*:amenu*
+:an	gui.txt	/*:an*
+:anoremenu	gui.txt	/*:anoremenu*
+:append	insert.txt	/*:append*
+:ar	editing.txt	/*:ar*
+:arga	editing.txt	/*:arga*
+:argadd	editing.txt	/*:argadd*
+:argd	editing.txt	/*:argd*
+:argdelete	editing.txt	/*:argdelete*
+:argdo	editing.txt	/*:argdo*
+:arge	editing.txt	/*:arge*
+:argedit	editing.txt	/*:argedit*
+:argglobal	editing.txt	/*:argglobal*
+:arglocal	editing.txt	/*:arglocal*
+:args	editing.txt	/*:args*
+:args_f	editing.txt	/*:args_f*
+:args_f!	editing.txt	/*:args_f!*
+:argu	editing.txt	/*:argu*
+:argument	editing.txt	/*:argument*
+:as	various.txt	/*:as*
+:ascii	various.txt	/*:ascii*
+:au	autocmd.txt	/*:au*
+:aug	autocmd.txt	/*:aug*
+:augroup	autocmd.txt	/*:augroup*
+:augroup-delete	autocmd.txt	/*:augroup-delete*
+:aun	gui.txt	/*:aun*
+:aunmenu	gui.txt	/*:aunmenu*
+:autocmd	autocmd.txt	/*:autocmd*
+:autocmd-verbose	autocmd.txt	/*:autocmd-verbose*
+:b	windows.txt	/*:b*
+:bN	windows.txt	/*:bN*
+:bNext	windows.txt	/*:bNext*
+:ba	windows.txt	/*:ba*
+:bad	windows.txt	/*:bad*
+:badd	windows.txt	/*:badd*
+:ball	windows.txt	/*:ball*
+:bar	cmdline.txt	/*:bar*
+:bd	windows.txt	/*:bd*
+:bdel	windows.txt	/*:bdel*
+:bdelete	windows.txt	/*:bdelete*
+:be	gui.txt	/*:be*
+:behave	gui.txt	/*:behave*
+:bel	windows.txt	/*:bel*
+:belowright	windows.txt	/*:belowright*
+:bf	windows.txt	/*:bf*
+:bfirst	windows.txt	/*:bfirst*
+:bl	windows.txt	/*:bl*
+:blast	windows.txt	/*:blast*
+:bm	windows.txt	/*:bm*
+:bmodified	windows.txt	/*:bmodified*
+:bn	windows.txt	/*:bn*
+:bnext	windows.txt	/*:bnext*
+:bo	windows.txt	/*:bo*
+:botright	windows.txt	/*:botright*
+:bp	windows.txt	/*:bp*
+:bprevious	windows.txt	/*:bprevious*
+:br	windows.txt	/*:br*
+:brea	eval.txt	/*:brea*
+:break	eval.txt	/*:break*
+:breaka	repeat.txt	/*:breaka*
+:breakadd	repeat.txt	/*:breakadd*
+:breakd	repeat.txt	/*:breakd*
+:breakdel	repeat.txt	/*:breakdel*
+:breakl	repeat.txt	/*:breakl*
+:breaklist	repeat.txt	/*:breaklist*
+:brewind	windows.txt	/*:brewind*
+:bro	editing.txt	/*:bro*
+:browse	editing.txt	/*:browse*
+:browse-set	options.txt	/*:browse-set*
+:bu	windows.txt	/*:bu*
+:buf	windows.txt	/*:buf*
+:bufdo	windows.txt	/*:bufdo*
+:buffer	windows.txt	/*:buffer*
+:buffer-!	windows.txt	/*:buffer-!*
+:buffers	windows.txt	/*:buffers*
+:bun	windows.txt	/*:bun*
+:bunload	windows.txt	/*:bunload*
+:bw	windows.txt	/*:bw*
+:bwipe	windows.txt	/*:bwipe*
+:bwipeout	windows.txt	/*:bwipeout*
+:c	change.txt	/*:c*
+:cN	quickfix.txt	/*:cN*
+:cNext	quickfix.txt	/*:cNext*
+:cNf	quickfix.txt	/*:cNf*
+:cNfile	quickfix.txt	/*:cNfile*
+:ca	map.txt	/*:ca*
+:cabbrev	map.txt	/*:cabbrev*
+:cabc	map.txt	/*:cabc*
+:cabclear	map.txt	/*:cabclear*
+:cad	quickfix.txt	/*:cad*
+:caddbuffer	quickfix.txt	/*:caddbuffer*
+:cadde	quickfix.txt	/*:cadde*
+:caddexpr	quickfix.txt	/*:caddexpr*
+:caddf	quickfix.txt	/*:caddf*
+:caddfile	quickfix.txt	/*:caddfile*
+:cal	eval.txt	/*:cal*
+:call	eval.txt	/*:call*
+:cat	eval.txt	/*:cat*
+:catch	eval.txt	/*:catch*
+:cb	quickfix.txt	/*:cb*
+:cbo	quickfix.txt	/*:cbo*
+:cbottom	quickfix.txt	/*:cbottom*
+:cbuffer	quickfix.txt	/*:cbuffer*
+:cc	quickfix.txt	/*:cc*
+:ccl	quickfix.txt	/*:ccl*
+:cclose	quickfix.txt	/*:cclose*
+:cd	editing.txt	/*:cd*
+:cd-	editing.txt	/*:cd-*
+:cdo	quickfix.txt	/*:cdo*
+:ce	change.txt	/*:ce*
+:center	change.txt	/*:center*
+:cex	quickfix.txt	/*:cex*
+:cexpr	quickfix.txt	/*:cexpr*
+:cf	quickfix.txt	/*:cf*
+:cfdo	quickfix.txt	/*:cfdo*
+:cfile	quickfix.txt	/*:cfile*
+:cfir	quickfix.txt	/*:cfir*
+:cfirst	quickfix.txt	/*:cfirst*
+:cg	quickfix.txt	/*:cg*
+:cgetb	quickfix.txt	/*:cgetb*
+:cgetbuffer	quickfix.txt	/*:cgetbuffer*
+:cgete	quickfix.txt	/*:cgete*
+:cgetexpr	quickfix.txt	/*:cgetexpr*
+:cgetfile	quickfix.txt	/*:cgetfile*
+:ch	change.txt	/*:ch*
+:change	change.txt	/*:change*
+:changes	motion.txt	/*:changes*
+:chd	editing.txt	/*:chd*
+:chdir	editing.txt	/*:chdir*
+:che	tagsrch.txt	/*:che*
+:checkpath	tagsrch.txt	/*:checkpath*
+:checkt	editing.txt	/*:checkt*
+:checktime	editing.txt	/*:checktime*
+:chi	quickfix.txt	/*:chi*
+:chistory	quickfix.txt	/*:chistory*
+:cl	quickfix.txt	/*:cl*
+:cla	quickfix.txt	/*:cla*
+:clast	quickfix.txt	/*:clast*
+:cle	motion.txt	/*:cle*
+:clearjumps	motion.txt	/*:clearjumps*
+:clist	quickfix.txt	/*:clist*
+:clo	windows.txt	/*:clo*
+:close	windows.txt	/*:close*
+:cm	map.txt	/*:cm*
+:cmap	map.txt	/*:cmap*
+:cmap_l	map.txt	/*:cmap_l*
+:cmapc	map.txt	/*:cmapc*
+:cmapclear	map.txt	/*:cmapclear*
+:cme	gui.txt	/*:cme*
+:cmenu	gui.txt	/*:cmenu*
+:cn	quickfix.txt	/*:cn*
+:cnew	quickfix.txt	/*:cnew*
+:cnewer	quickfix.txt	/*:cnewer*
+:cnext	quickfix.txt	/*:cnext*
+:cnf	quickfix.txt	/*:cnf*
+:cnfile	quickfix.txt	/*:cnfile*
+:cno	map.txt	/*:cno*
+:cnorea	map.txt	/*:cnorea*
+:cnoreabbrev	map.txt	/*:cnoreabbrev*
+:cnoremap	map.txt	/*:cnoremap*
+:cnoreme	gui.txt	/*:cnoreme*
+:cnoremenu	gui.txt	/*:cnoremenu*
+:co	change.txt	/*:co*
+:col	quickfix.txt	/*:col*
+:colder	quickfix.txt	/*:colder*
+:colo	syntax.txt	/*:colo*
+:colorscheme	syntax.txt	/*:colorscheme*
+:com	map.txt	/*:com*
+:comc	map.txt	/*:comc*
+:comclear	map.txt	/*:comclear*
+:command	map.txt	/*:command*
+:command-addr	map.txt	/*:command-addr*
+:command-bang	map.txt	/*:command-bang*
+:command-bar	map.txt	/*:command-bar*
+:command-buffer	map.txt	/*:command-buffer*
+:command-complete	map.txt	/*:command-complete*
+:command-completion	map.txt	/*:command-completion*
+:command-completion-custom	map.txt	/*:command-completion-custom*
+:command-completion-customlist	map.txt	/*:command-completion-customlist*
+:command-count	map.txt	/*:command-count*
+:command-nargs	map.txt	/*:command-nargs*
+:command-range	map.txt	/*:command-range*
+:command-register	map.txt	/*:command-register*
+:command-verbose	map.txt	/*:command-verbose*
+:comment	cmdline.txt	/*:comment*
+:comp	quickfix.txt	/*:comp*
+:compiler	quickfix.txt	/*:compiler*
+:con	eval.txt	/*:con*
+:conf	editing.txt	/*:conf*
+:confirm	editing.txt	/*:confirm*
+:continue	eval.txt	/*:continue*
+:cope	quickfix.txt	/*:cope*
+:copen	quickfix.txt	/*:copen*
+:copy	change.txt	/*:copy*
+:cp	quickfix.txt	/*:cp*
+:cpf	quickfix.txt	/*:cpf*
+:cpfile	quickfix.txt	/*:cpfile*
+:cprevious	quickfix.txt	/*:cprevious*
+:cq	quickfix.txt	/*:cq*
+:cquit	quickfix.txt	/*:cquit*
+:cr	quickfix.txt	/*:cr*
+:crewind	quickfix.txt	/*:crewind*
+:cs	if_cscop.txt	/*:cs*
+:cscope	if_cscop.txt	/*:cscope*
+:cstag	if_cscop.txt	/*:cstag*
+:cu	map.txt	/*:cu*
+:cuna	map.txt	/*:cuna*
+:cunabbrev	map.txt	/*:cunabbrev*
+:cunmap	map.txt	/*:cunmap*
+:cunme	gui.txt	/*:cunme*
+:cunmenu	gui.txt	/*:cunmenu*
+:cw	quickfix.txt	/*:cw*
+:cwindow	quickfix.txt	/*:cwindow*
+:d	change.txt	/*:d*
+:de	change.txt	/*:de*
+:debug	repeat.txt	/*:debug*
+:debug-name	repeat.txt	/*:debug-name*
+:debugg	repeat.txt	/*:debugg*
+:debuggreedy	repeat.txt	/*:debuggreedy*
+:del	change.txt	/*:del*
+:delc	map.txt	/*:delc*
+:delcommand	map.txt	/*:delcommand*
+:delcr	todo.txt	/*:delcr*
+:delete	change.txt	/*:delete*
+:delf	eval.txt	/*:delf*
+:delfunction	eval.txt	/*:delfunction*
+:delm	motion.txt	/*:delm*
+:delmarks	motion.txt	/*:delmarks*
+:di	change.txt	/*:di*
+:dif	diff.txt	/*:dif*
+:diffg	diff.txt	/*:diffg*
+:diffget	diff.txt	/*:diffget*
+:diffo	diff.txt	/*:diffo*
+:diffoff	diff.txt	/*:diffoff*
+:diffp	diff.txt	/*:diffp*
+:diffpatch	diff.txt	/*:diffpatch*
+:diffpu	diff.txt	/*:diffpu*
+:diffput	diff.txt	/*:diffput*
+:diffs	diff.txt	/*:diffs*
+:diffsplit	diff.txt	/*:diffsplit*
+:difft	diff.txt	/*:difft*
+:diffthis	diff.txt	/*:diffthis*
+:diffupdate	diff.txt	/*:diffupdate*
+:dig	digraph.txt	/*:dig*
+:digraphs	digraph.txt	/*:digraphs*
+:display	change.txt	/*:display*
+:dj	tagsrch.txt	/*:dj*
+:djump	tagsrch.txt	/*:djump*
+:dl	change.txt	/*:dl*
+:dli	tagsrch.txt	/*:dli*
+:dlist	tagsrch.txt	/*:dlist*
+:do	autocmd.txt	/*:do*
+:doau	autocmd.txt	/*:doau*
+:doautoa	autocmd.txt	/*:doautoa*
+:doautoall	autocmd.txt	/*:doautoall*
+:doautocmd	autocmd.txt	/*:doautocmd*
+:dp	change.txt	/*:dp*
+:dr	windows.txt	/*:dr*
+:drop	windows.txt	/*:drop*
+:ds	tagsrch.txt	/*:ds*
+:dsearch	tagsrch.txt	/*:dsearch*
+:dsp	tagsrch.txt	/*:dsp*
+:dsplit	tagsrch.txt	/*:dsplit*
+:e	editing.txt	/*:e*
+:ea	undo.txt	/*:ea*
+:earlier	undo.txt	/*:earlier*
+:ec	eval.txt	/*:ec*
+:echo	eval.txt	/*:echo*
+:echo-redraw	eval.txt	/*:echo-redraw*
+:echoe	eval.txt	/*:echoe*
+:echoerr	eval.txt	/*:echoerr*
+:echoh	eval.txt	/*:echoh*
+:echohl	eval.txt	/*:echohl*
+:echom	eval.txt	/*:echom*
+:echomsg	eval.txt	/*:echomsg*
+:echon	eval.txt	/*:echon*
+:edit	editing.txt	/*:edit*
+:edit!	editing.txt	/*:edit!*
+:edit!_f	editing.txt	/*:edit!_f*
+:edit_f	editing.txt	/*:edit_f*
+:el	eval.txt	/*:el*
+:else	eval.txt	/*:else*
+:elsei	eval.txt	/*:elsei*
+:elseif	eval.txt	/*:elseif*
+:em	gui.txt	/*:em*
+:emenu	gui.txt	/*:emenu*
+:en	eval.txt	/*:en*
+:endf	eval.txt	/*:endf*
+:endfo	eval.txt	/*:endfo*
+:endfor	eval.txt	/*:endfor*
+:endfunction	eval.txt	/*:endfunction*
+:endif	eval.txt	/*:endif*
+:endt	eval.txt	/*:endt*
+:endtry	eval.txt	/*:endtry*
+:endw	eval.txt	/*:endw*
+:endwhile	eval.txt	/*:endwhile*
+:ene	editing.txt	/*:ene*
+:ene!	editing.txt	/*:ene!*
+:enew	editing.txt	/*:enew*
+:enew!	editing.txt	/*:enew!*
+:ex	editing.txt	/*:ex*
+:exe	eval.txt	/*:exe*
+:exe-comment	eval.txt	/*:exe-comment*
+:execute	eval.txt	/*:execute*
+:exi	editing.txt	/*:exi*
+:exit	editing.txt	/*:exit*
+:exu	helphelp.txt	/*:exu*
+:exusage	helphelp.txt	/*:exusage*
+:f	editing.txt	/*:f*
+:fi	editing.txt	/*:fi*
+:file	editing.txt	/*:file*
+:file_f	editing.txt	/*:file_f*
+:filename	editing.txt	/*:filename*
+:files	windows.txt	/*:files*
+:filet	filetype.txt	/*:filet*
+:filetype	filetype.txt	/*:filetype*
+:filetype-indent-off	filetype.txt	/*:filetype-indent-off*
+:filetype-indent-on	filetype.txt	/*:filetype-indent-on*
+:filetype-off	filetype.txt	/*:filetype-off*
+:filetype-overview	filetype.txt	/*:filetype-overview*
+:filetype-plugin-off	filetype.txt	/*:filetype-plugin-off*
+:filetype-plugin-on	filetype.txt	/*:filetype-plugin-on*
+:filt	various.txt	/*:filt*
+:filter	various.txt	/*:filter*
+:fin	editing.txt	/*:fin*
+:fina	eval.txt	/*:fina*
+:finally	eval.txt	/*:finally*
+:find	editing.txt	/*:find*
+:fini	repeat.txt	/*:fini*
+:finish	repeat.txt	/*:finish*
+:fir	editing.txt	/*:fir*
+:first	editing.txt	/*:first*
+:fix	options.txt	/*:fix*
+:fixdel	options.txt	/*:fixdel*
+:fo	fold.txt	/*:fo*
+:fold	fold.txt	/*:fold*
+:foldc	fold.txt	/*:foldc*
+:foldclose	fold.txt	/*:foldclose*
+:foldd	fold.txt	/*:foldd*
+:folddoc	fold.txt	/*:folddoc*
+:folddoclosed	fold.txt	/*:folddoclosed*
+:folddoopen	fold.txt	/*:folddoopen*
+:foldo	fold.txt	/*:foldo*
+:foldopen	fold.txt	/*:foldopen*
+:for	eval.txt	/*:for*
+:fu	eval.txt	/*:fu*
+:func-abort	eval.txt	/*:func-abort*
+:func-closure	eval.txt	/*:func-closure*
+:func-dict	eval.txt	/*:func-dict*
+:func-range	eval.txt	/*:func-range*
+:function	eval.txt	/*:function*
+:function-verbose	eval.txt	/*:function-verbose*
+:g	repeat.txt	/*:g*
+:global	repeat.txt	/*:global*
+:go	motion.txt	/*:go*
+:goto	motion.txt	/*:goto*
+:gr	quickfix.txt	/*:gr*
+:grep	quickfix.txt	/*:grep*
+:grepa	quickfix.txt	/*:grepa*
+:grepadd	quickfix.txt	/*:grepadd*
+:gu	gui_x11.txt	/*:gu*
+:gui	gui_x11.txt	/*:gui*
+:gv	gui_x11.txt	/*:gv*
+:gvim	gui_x11.txt	/*:gvim*
+:h	helphelp.txt	/*:h*
+:ha	print.txt	/*:ha*
+:hardcopy	print.txt	/*:hardcopy*
+:help	helphelp.txt	/*:help*
+:helpc	helphelp.txt	/*:helpc*
+:helpclose	helphelp.txt	/*:helpclose*
+:helpf	helphelp.txt	/*:helpf*
+:helpfind	helphelp.txt	/*:helpfind*
+:helpg	helphelp.txt	/*:helpg*
+:helpgrep	helphelp.txt	/*:helpgrep*
+:helpt	helphelp.txt	/*:helpt*
+:helptags	helphelp.txt	/*:helptags*
+:hi	syntax.txt	/*:hi*
+:hi-default	syntax.txt	/*:hi-default*
+:hi-link	syntax.txt	/*:hi-link*
+:hi-normal	syntax.txt	/*:hi-normal*
+:hi-normal-cterm	syntax.txt	/*:hi-normal-cterm*
+:hide	windows.txt	/*:hide*
+:highlight	syntax.txt	/*:highlight*
+:highlight-default	syntax.txt	/*:highlight-default*
+:highlight-link	syntax.txt	/*:highlight-link*
+:highlight-normal	syntax.txt	/*:highlight-normal*
+:highlight-verbose	syntax.txt	/*:highlight-verbose*
+:his	cmdline.txt	/*:his*
+:history	cmdline.txt	/*:history*
+:history-indexing	cmdline.txt	/*:history-indexing*
+:i	insert.txt	/*:i*
+:ia	map.txt	/*:ia*
+:iabbrev	map.txt	/*:iabbrev*
+:iabc	map.txt	/*:iabc*
+:iabclear	map.txt	/*:iabclear*
+:if	eval.txt	/*:if*
+:ij	tagsrch.txt	/*:ij*
+:ijump	tagsrch.txt	/*:ijump*
+:il	tagsrch.txt	/*:il*
+:ilist	tagsrch.txt	/*:ilist*
+:im	map.txt	/*:im*
+:imap	map.txt	/*:imap*
+:imap_l	map.txt	/*:imap_l*
+:imapc	map.txt	/*:imapc*
+:imapclear	map.txt	/*:imapclear*
+:ime	gui.txt	/*:ime*
+:imenu	gui.txt	/*:imenu*
+:in	insert.txt	/*:in*
+:index	index.txt	/*:index*
+:ino	map.txt	/*:ino*
+:inorea	map.txt	/*:inorea*
+:inoreabbrev	map.txt	/*:inoreabbrev*
+:inoremap	map.txt	/*:inoremap*
+:inoreme	gui.txt	/*:inoreme*
+:inoremenu	gui.txt	/*:inoremenu*
+:insert	insert.txt	/*:insert*
+:intro	starting.txt	/*:intro*
+:is	tagsrch.txt	/*:is*
+:isearch	tagsrch.txt	/*:isearch*
+:isp	tagsrch.txt	/*:isp*
+:isplit	tagsrch.txt	/*:isplit*
+:iu	map.txt	/*:iu*
+:iuna	map.txt	/*:iuna*
+:iunabbrev	map.txt	/*:iunabbrev*
+:iunmap	map.txt	/*:iunmap*
+:iunme	gui.txt	/*:iunme*
+:iunmenu	gui.txt	/*:iunmenu*
+:j	change.txt	/*:j*
+:join	change.txt	/*:join*
+:ju	motion.txt	/*:ju*
+:jumps	motion.txt	/*:jumps*
+:k	motion.txt	/*:k*
+:kee	motion.txt	/*:kee*
+:keepa	editing.txt	/*:keepa*
+:keepalt	editing.txt	/*:keepalt*
+:keepj	motion.txt	/*:keepj*
+:keepjumps	motion.txt	/*:keepjumps*
+:keepmarks	motion.txt	/*:keepmarks*
+:keepp	cmdline.txt	/*:keepp*
+:keeppatterns	cmdline.txt	/*:keeppatterns*
+:l	various.txt	/*:l*
+:lN	quickfix.txt	/*:lN*
+:lNext	quickfix.txt	/*:lNext*
+:lNf	quickfix.txt	/*:lNf*
+:lNfile	quickfix.txt	/*:lNfile*
+:la	editing.txt	/*:la*
+:lad	quickfix.txt	/*:lad*
+:laddb	quickfix.txt	/*:laddb*
+:laddbuffer	quickfix.txt	/*:laddbuffer*
+:laddexpr	quickfix.txt	/*:laddexpr*
+:laddf	quickfix.txt	/*:laddf*
+:laddfile	quickfix.txt	/*:laddfile*
+:lan	mlang.txt	/*:lan*
+:lang	mlang.txt	/*:lang*
+:language	mlang.txt	/*:language*
+:last	editing.txt	/*:last*
+:lat	undo.txt	/*:lat*
+:later	undo.txt	/*:later*
+:lb	quickfix.txt	/*:lb*
+:lbo	quickfix.txt	/*:lbo*
+:lbottom	quickfix.txt	/*:lbottom*
+:lbuffer	quickfix.txt	/*:lbuffer*
+:lc	editing.txt	/*:lc*
+:lcd	editing.txt	/*:lcd*
+:lch	editing.txt	/*:lch*
+:lchdir	editing.txt	/*:lchdir*
+:lcl	quickfix.txt	/*:lcl*
+:lclose	quickfix.txt	/*:lclose*
+:lcs	if_cscop.txt	/*:lcs*
+:lcscope	if_cscop.txt	/*:lcscope*
+:ldo	quickfix.txt	/*:ldo*
+:le	change.txt	/*:le*
+:left	change.txt	/*:left*
+:lefta	windows.txt	/*:lefta*
+:leftabove	windows.txt	/*:leftabove*
+:let	eval.txt	/*:let*
+:let+=	eval.txt	/*:let+=*
+:let-$	eval.txt	/*:let-$*
+:let-&	eval.txt	/*:let-&*
+:let-=	eval.txt	/*:let-=*
+:let-@	eval.txt	/*:let-@*
+:let-environment	eval.txt	/*:let-environment*
+:let-option	eval.txt	/*:let-option*
+:let-register	eval.txt	/*:let-register*
+:let-unpack	eval.txt	/*:let-unpack*
+:let.=	eval.txt	/*:let.=*
+:lex	quickfix.txt	/*:lex*
+:lexpr	quickfix.txt	/*:lexpr*
+:lf	quickfix.txt	/*:lf*
+:lfdo	quickfix.txt	/*:lfdo*
+:lfile	quickfix.txt	/*:lfile*
+:lfir	quickfix.txt	/*:lfir*
+:lfirst	quickfix.txt	/*:lfirst*
+:lg	quickfix.txt	/*:lg*
+:lgetb	quickfix.txt	/*:lgetb*
+:lgetbuffer	quickfix.txt	/*:lgetbuffer*
+:lgete	quickfix.txt	/*:lgete*
+:lgetexpr	quickfix.txt	/*:lgetexpr*
+:lgetfile	quickfix.txt	/*:lgetfile*
+:lgr	quickfix.txt	/*:lgr*
+:lgrep	quickfix.txt	/*:lgrep*
+:lgrepa	quickfix.txt	/*:lgrepa*
+:lgrepadd	quickfix.txt	/*:lgrepadd*
+:lh	helphelp.txt	/*:lh*
+:lhelpgrep	helphelp.txt	/*:lhelpgrep*
+:lhi	quickfix.txt	/*:lhi*
+:lhistory	quickfix.txt	/*:lhistory*
+:list	various.txt	/*:list*
+:ll	quickfix.txt	/*:ll*
+:lla	quickfix.txt	/*:lla*
+:llast	quickfix.txt	/*:llast*
+:lli	quickfix.txt	/*:lli*
+:llist	quickfix.txt	/*:llist*
+:lm	map.txt	/*:lm*
+:lmak	quickfix.txt	/*:lmak*
+:lmake	quickfix.txt	/*:lmake*
+:lmap	map.txt	/*:lmap*
+:lmap_l	map.txt	/*:lmap_l*
+:lmapc	map.txt	/*:lmapc*
+:lmapclear	map.txt	/*:lmapclear*
+:ln	map.txt	/*:ln*
+:lne	quickfix.txt	/*:lne*
+:lnew	quickfix.txt	/*:lnew*
+:lnewer	quickfix.txt	/*:lnewer*
+:lnext	quickfix.txt	/*:lnext*
+:lnf	quickfix.txt	/*:lnf*
+:lnfile	quickfix.txt	/*:lnfile*
+:lnoremap	map.txt	/*:lnoremap*
+:lo	starting.txt	/*:lo*
+:loadk	mbyte.txt	/*:loadk*
+:loadkeymap	mbyte.txt	/*:loadkeymap*
+:loadview	starting.txt	/*:loadview*
+:loc	motion.txt	/*:loc*
+:lockmarks	motion.txt	/*:lockmarks*
+:lockv	eval.txt	/*:lockv*
+:lockvar	eval.txt	/*:lockvar*
+:lol	quickfix.txt	/*:lol*
+:lolder	quickfix.txt	/*:lolder*
+:lop	quickfix.txt	/*:lop*
+:lopen	quickfix.txt	/*:lopen*
+:lp	quickfix.txt	/*:lp*
+:lpf	quickfix.txt	/*:lpf*
+:lpfile	quickfix.txt	/*:lpfile*
+:lprevious	quickfix.txt	/*:lprevious*
+:lr	quickfix.txt	/*:lr*
+:lrewind	quickfix.txt	/*:lrewind*
+:ls	windows.txt	/*:ls*
+:lt	tagsrch.txt	/*:lt*
+:ltag	tagsrch.txt	/*:ltag*
+:lu	map.txt	/*:lu*
+:lua	if_lua.txt	/*:lua*
+:luado	if_lua.txt	/*:luado*
+:luafile	if_lua.txt	/*:luafile*
+:lunmap	map.txt	/*:lunmap*
+:lv	quickfix.txt	/*:lv*
+:lvimgrep	quickfix.txt	/*:lvimgrep*
+:lvimgrepa	quickfix.txt	/*:lvimgrepa*
+:lvimgrepadd	quickfix.txt	/*:lvimgrepadd*
+:lw	quickfix.txt	/*:lw*
+:lwindow	quickfix.txt	/*:lwindow*
+:m	change.txt	/*:m*
+:ma	motion.txt	/*:ma*
+:mak	quickfix.txt	/*:mak*
+:make	quickfix.txt	/*:make*
+:make_makeprg	quickfix.txt	/*:make_makeprg*
+:map	map.txt	/*:map*
+:map!	map.txt	/*:map!*
+:map-<buffer>	map.txt	/*:map-<buffer>*
+:map-<expr>	map.txt	/*:map-<expr>*
+:map-<nowait>	map.txt	/*:map-<nowait>*
+:map-<script>	map.txt	/*:map-<script>*
+:map-<silent>	map.txt	/*:map-<silent>*
+:map-<special>	map.txt	/*:map-<special>*
+:map-<unique>	map.txt	/*:map-<unique>*
+:map-alt-keys	map.txt	/*:map-alt-keys*
+:map-arguments	map.txt	/*:map-arguments*
+:map-commands	map.txt	/*:map-commands*
+:map-expression	map.txt	/*:map-expression*
+:map-local	map.txt	/*:map-local*
+:map-modes	map.txt	/*:map-modes*
+:map-nowait	map.txt	/*:map-nowait*
+:map-operator	map.txt	/*:map-operator*
+:map-script	map.txt	/*:map-script*
+:map-silent	map.txt	/*:map-silent*
+:map-special	map.txt	/*:map-special*
+:map-special-chars	map.txt	/*:map-special-chars*
+:map-special-keys	map.txt	/*:map-special-keys*
+:map-undo	map.txt	/*:map-undo*
+:map-verbose	map.txt	/*:map-verbose*
+:map_l	map.txt	/*:map_l*
+:map_l!	map.txt	/*:map_l!*
+:mapc	map.txt	/*:mapc*
+:mapc!	map.txt	/*:mapc!*
+:mapclear	map.txt	/*:mapclear*
+:mapclear!	map.txt	/*:mapclear!*
+:mark	motion.txt	/*:mark*
+:marks	motion.txt	/*:marks*
+:mat	pattern.txt	/*:mat*
+:match	pattern.txt	/*:match*
+:me	gui.txt	/*:me*
+:menu	gui.txt	/*:menu*
+:menu-<script>	gui.txt	/*:menu-<script>*
+:menu-<silent>	gui.txt	/*:menu-<silent>*
+:menu-<special>	gui.txt	/*:menu-<special>*
+:menu-disable	gui.txt	/*:menu-disable*
+:menu-enable	gui.txt	/*:menu-enable*
+:menu-script	gui.txt	/*:menu-script*
+:menu-silent	gui.txt	/*:menu-silent*
+:menu-special	gui.txt	/*:menu-special*
+:menut	mlang.txt	/*:menut*
+:menutrans	mlang.txt	/*:menutrans*
+:menutranslate	mlang.txt	/*:menutranslate*
+:mes	message.txt	/*:mes*
+:messages	message.txt	/*:messages*
+:mk	starting.txt	/*:mk*
+:mkexrc	starting.txt	/*:mkexrc*
+:mks	starting.txt	/*:mks*
+:mksession	starting.txt	/*:mksession*
+:mksp	spell.txt	/*:mksp*
+:mkspell	spell.txt	/*:mkspell*
+:mkv	starting.txt	/*:mkv*
+:mkvie	starting.txt	/*:mkvie*
+:mkview	starting.txt	/*:mkview*
+:mkvimrc	starting.txt	/*:mkvimrc*
+:mo	change.txt	/*:mo*
+:mod	term.txt	/*:mod*
+:mode	term.txt	/*:mode*
+:move	change.txt	/*:move*
+:mz	if_mzsch.txt	/*:mz*
+:mzf	if_mzsch.txt	/*:mzf*
+:mzfile	if_mzsch.txt	/*:mzfile*
+:mzscheme	if_mzsch.txt	/*:mzscheme*
+:n	editing.txt	/*:n*
+:nbclose	netbeans.txt	/*:nbclose*
+:nbkey	netbeans.txt	/*:nbkey*
+:nbstart	netbeans.txt	/*:nbstart*
+:ne	editing.txt	/*:ne*
+:new	windows.txt	/*:new*
+:next	editing.txt	/*:next*
+:next_f	editing.txt	/*:next_f*
+:nm	map.txt	/*:nm*
+:nmap	map.txt	/*:nmap*
+:nmap_l	map.txt	/*:nmap_l*
+:nmapc	map.txt	/*:nmapc*
+:nmapclear	map.txt	/*:nmapclear*
+:nme	gui.txt	/*:nme*
+:nmenu	gui.txt	/*:nmenu*
+:nn	map.txt	/*:nn*
+:nnoremap	map.txt	/*:nnoremap*
+:nnoreme	gui.txt	/*:nnoreme*
+:nnoremenu	gui.txt	/*:nnoremenu*
+:no	map.txt	/*:no*
+:no!	map.txt	/*:no!*
+:noa	autocmd.txt	/*:noa*
+:noautocmd	autocmd.txt	/*:noautocmd*
+:noh	pattern.txt	/*:noh*
+:nohlsearch	pattern.txt	/*:nohlsearch*
+:nor	map.txt	/*:nor*
+:nore	map.txt	/*:nore*
+:norea	map.txt	/*:norea*
+:noreabbrev	map.txt	/*:noreabbrev*
+:norem	map.txt	/*:norem*
+:noremap	map.txt	/*:noremap*
+:noremap!	map.txt	/*:noremap!*
+:noreme	gui.txt	/*:noreme*
+:noremenu	gui.txt	/*:noremenu*
+:norm	various.txt	/*:norm*
+:normal	various.txt	/*:normal*
+:normal-range	various.txt	/*:normal-range*
+:nos	recover.txt	/*:nos*
+:noswapfile	recover.txt	/*:noswapfile*
+:nu	various.txt	/*:nu*
+:number	various.txt	/*:number*
+:nun	map.txt	/*:nun*
+:nunmap	map.txt	/*:nunmap*
+:nunme	gui.txt	/*:nunme*
+:nunmenu	gui.txt	/*:nunmenu*
+:o	vi_diff.txt	/*:o*
+:ol	starting.txt	/*:ol*
+:oldfiles	starting.txt	/*:oldfiles*
+:om	map.txt	/*:om*
+:omap	map.txt	/*:omap*
+:omap_l	map.txt	/*:omap_l*
+:omapc	map.txt	/*:omapc*
+:omapclear	map.txt	/*:omapclear*
+:ome	gui.txt	/*:ome*
+:omenu	gui.txt	/*:omenu*
+:on	windows.txt	/*:on*
+:only	windows.txt	/*:only*
+:ono	map.txt	/*:ono*
+:onoremap	map.txt	/*:onoremap*
+:onoreme	gui.txt	/*:onoreme*
+:onoremenu	gui.txt	/*:onoremenu*
+:op	vi_diff.txt	/*:op*
+:open	vi_diff.txt	/*:open*
+:opt	options.txt	/*:opt*
+:options	options.txt	/*:options*
+:ou	map.txt	/*:ou*
+:ounmap	map.txt	/*:ounmap*
+:ounme	gui.txt	/*:ounme*
+:ounmenu	gui.txt	/*:ounmenu*
+:ownsyntax	syntax.txt	/*:ownsyntax*
+:p	various.txt	/*:p*
+:pa	repeat.txt	/*:pa*
+:packadd	repeat.txt	/*:packadd*
+:packl	repeat.txt	/*:packl*
+:packloadall	repeat.txt	/*:packloadall*
+:pc	windows.txt	/*:pc*
+:pclose	windows.txt	/*:pclose*
+:pe	if_perl.txt	/*:pe*
+:ped	windows.txt	/*:ped*
+:pedit	windows.txt	/*:pedit*
+:perl	if_perl.txt	/*:perl*
+:perld	if_perl.txt	/*:perld*
+:perldo	if_perl.txt	/*:perldo*
+:po	tagsrch.txt	/*:po*
+:pop	tagsrch.txt	/*:pop*
+:popu	gui.txt	/*:popu*
+:popup	gui.txt	/*:popup*
+:pp	windows.txt	/*:pp*
+:ppop	windows.txt	/*:ppop*
+:pr	various.txt	/*:pr*
+:pre	recover.txt	/*:pre*
+:preserve	recover.txt	/*:preserve*
+:prev	editing.txt	/*:prev*
+:previous	editing.txt	/*:previous*
+:print	various.txt	/*:print*
+:pro	change.txt	/*:pro*
+:prof	repeat.txt	/*:prof*
+:profd	repeat.txt	/*:profd*
+:profdel	repeat.txt	/*:profdel*
+:profile	repeat.txt	/*:profile*
+:promptfind	change.txt	/*:promptfind*
+:promptr	change.txt	/*:promptr*
+:promptrepl	change.txt	/*:promptrepl*
+:ps	windows.txt	/*:ps*
+:psearch	windows.txt	/*:psearch*
+:ptN	tagsrch.txt	/*:ptN*
+:ptNext	tagsrch.txt	/*:ptNext*
+:pta	windows.txt	/*:pta*
+:ptag	windows.txt	/*:ptag*
+:ptf	tagsrch.txt	/*:ptf*
+:ptfirst	tagsrch.txt	/*:ptfirst*
+:ptj	tagsrch.txt	/*:ptj*
+:ptjump	tagsrch.txt	/*:ptjump*
+:ptl	tagsrch.txt	/*:ptl*
+:ptlast	tagsrch.txt	/*:ptlast*
+:ptn	tagsrch.txt	/*:ptn*
+:ptnext	tagsrch.txt	/*:ptnext*
+:ptp	tagsrch.txt	/*:ptp*
+:ptprevious	tagsrch.txt	/*:ptprevious*
+:ptr	tagsrch.txt	/*:ptr*
+:ptrewind	tagsrch.txt	/*:ptrewind*
+:pts	tagsrch.txt	/*:pts*
+:ptselect	tagsrch.txt	/*:ptselect*
+:pu	change.txt	/*:pu*
+:put	change.txt	/*:put*
+:pw	editing.txt	/*:pw*
+:pwd	editing.txt	/*:pwd*
+:py	if_pyth.txt	/*:py*
+:py3	if_pyth.txt	/*:py3*
+:py3do	if_pyth.txt	/*:py3do*
+:py3file	if_pyth.txt	/*:py3file*
+:pydo	if_pyth.txt	/*:pydo*
+:pyf	if_pyth.txt	/*:pyf*
+:pyfile	if_pyth.txt	/*:pyfile*
+:python	if_pyth.txt	/*:python*
+:python3	if_pyth.txt	/*:python3*
+:pythonx	if_pyth.txt	/*:pythonx*
+:pyx	if_pyth.txt	/*:pyx*
+:pyxdo	if_pyth.txt	/*:pyxdo*
+:pyxfile	if_pyth.txt	/*:pyxfile*
+:q	editing.txt	/*:q*
+:qa	editing.txt	/*:qa*
+:qall	editing.txt	/*:qall*
+:quit	editing.txt	/*:quit*
+:quita	editing.txt	/*:quita*
+:quitall	editing.txt	/*:quitall*
+:quote	cmdline.txt	/*:quote*
+:r	insert.txt	/*:r*
+:r!	insert.txt	/*:r!*
+:range	cmdline.txt	/*:range*
+:range!	change.txt	/*:range!*
+:re	insert.txt	/*:re*
+:read	insert.txt	/*:read*
+:read!	insert.txt	/*:read!*
+:rec	recover.txt	/*:rec*
+:recover	recover.txt	/*:recover*
+:recover-crypt	recover.txt	/*:recover-crypt*
+:red	undo.txt	/*:red*
+:redi	various.txt	/*:redi*
+:redir	various.txt	/*:redir*
+:redo	undo.txt	/*:redo*
+:redr	various.txt	/*:redr*
+:redraw	various.txt	/*:redraw*
+:redraws	various.txt	/*:redraws*
+:redrawstatus	various.txt	/*:redrawstatus*
+:reg	change.txt	/*:reg*
+:registers	change.txt	/*:registers*
+:res	windows.txt	/*:res*
+:resize	windows.txt	/*:resize*
+:ret	change.txt	/*:ret*
+:retab	change.txt	/*:retab*
+:retab!	change.txt	/*:retab!*
+:retu	eval.txt	/*:retu*
+:return	eval.txt	/*:return*
+:rew	editing.txt	/*:rew*
+:rewind	editing.txt	/*:rewind*
+:ri	change.txt	/*:ri*
+:right	change.txt	/*:right*
+:rightb	windows.txt	/*:rightb*
+:rightbelow	windows.txt	/*:rightbelow*
+:ru	repeat.txt	/*:ru*
+:rub	if_ruby.txt	/*:rub*
+:ruby	if_ruby.txt	/*:ruby*
+:rubyd	if_ruby.txt	/*:rubyd*
+:rubydo	if_ruby.txt	/*:rubydo*
+:rubyf	if_ruby.txt	/*:rubyf*
+:rubyfile	if_ruby.txt	/*:rubyfile*
+:rundo	undo.txt	/*:rundo*
+:runtime	repeat.txt	/*:runtime*
+:rv	starting.txt	/*:rv*
+:rviminfo	starting.txt	/*:rviminfo*
+:s	change.txt	/*:s*
+:s%	change.txt	/*:s%*
+:sI	change.txt	/*:sI*
+:sIc	change.txt	/*:sIc*
+:sIe	change.txt	/*:sIe*
+:sIg	change.txt	/*:sIg*
+:sIl	change.txt	/*:sIl*
+:sIn	change.txt	/*:sIn*
+:sIp	change.txt	/*:sIp*
+:sIr	change.txt	/*:sIr*
+:sN	windows.txt	/*:sN*
+:sNext	windows.txt	/*:sNext*
+:s\=	change.txt	/*:s\\=*
+:s_c	change.txt	/*:s_c*
+:s_flags	change.txt	/*:s_flags*
+:sa	windows.txt	/*:sa*
+:sal	windows.txt	/*:sal*
+:sall	windows.txt	/*:sall*
+:san	eval.txt	/*:san*
+:sandbox	eval.txt	/*:sandbox*
+:sargument	windows.txt	/*:sargument*
+:sav	editing.txt	/*:sav*
+:saveas	editing.txt	/*:saveas*
+:sb	windows.txt	/*:sb*
+:sbN	windows.txt	/*:sbN*
+:sbNext	windows.txt	/*:sbNext*
+:sba	windows.txt	/*:sba*
+:sball	windows.txt	/*:sball*
+:sbf	windows.txt	/*:sbf*
+:sbfirst	windows.txt	/*:sbfirst*
+:sbl	windows.txt	/*:sbl*
+:sblast	windows.txt	/*:sblast*
+:sbm	windows.txt	/*:sbm*
+:sbmodified	windows.txt	/*:sbmodified*
+:sbn	windows.txt	/*:sbn*
+:sbnext	windows.txt	/*:sbnext*
+:sbp	windows.txt	/*:sbp*
+:sbprevious	windows.txt	/*:sbprevious*
+:sbr	windows.txt	/*:sbr*
+:sbrewind	windows.txt	/*:sbrewind*
+:sbuffer	windows.txt	/*:sbuffer*
+:sc	change.txt	/*:sc*
+:scI	change.txt	/*:scI*
+:sce	change.txt	/*:sce*
+:scg	change.txt	/*:scg*
+:sci	change.txt	/*:sci*
+:scl	change.txt	/*:scl*
+:scp	change.txt	/*:scp*
+:scr	repeat.txt	/*:scr*
+:scripte	repeat.txt	/*:scripte*
+:scriptencoding	repeat.txt	/*:scriptencoding*
+:scriptnames	repeat.txt	/*:scriptnames*
+:scs	if_cscop.txt	/*:scs*
+:scscope	if_cscop.txt	/*:scscope*
+:se	options.txt	/*:se*
+:search-args	tagsrch.txt	/*:search-args*
+:set	options.txt	/*:set*
+:set+=	options.txt	/*:set+=*
+:set-!	options.txt	/*:set-!*
+:set-&	options.txt	/*:set-&*
+:set-&vi	options.txt	/*:set-&vi*
+:set-&vim	options.txt	/*:set-&vim*
+:set-=	options.txt	/*:set-=*
+:set-args	options.txt	/*:set-args*
+:set-browse	options.txt	/*:set-browse*
+:set-default	options.txt	/*:set-default*
+:set-inv	options.txt	/*:set-inv*
+:set-termcap	options.txt	/*:set-termcap*
+:set-verbose	options.txt	/*:set-verbose*
+:set^=	options.txt	/*:set^=*
+:set_env	options.txt	/*:set_env*
+:setf	options.txt	/*:setf*
+:setfiletype	options.txt	/*:setfiletype*
+:setg	options.txt	/*:setg*
+:setglobal	options.txt	/*:setglobal*
+:setl	options.txt	/*:setl*
+:setlocal	options.txt	/*:setlocal*
+:sf	windows.txt	/*:sf*
+:sfind	windows.txt	/*:sfind*
+:sfir	windows.txt	/*:sfir*
+:sfirst	windows.txt	/*:sfirst*
+:sg	change.txt	/*:sg*
+:sgI	change.txt	/*:sgI*
+:sgc	change.txt	/*:sgc*
+:sge	change.txt	/*:sge*
+:sgi	change.txt	/*:sgi*
+:sgl	change.txt	/*:sgl*
+:sgn	change.txt	/*:sgn*
+:sgp	change.txt	/*:sgp*
+:sgr	change.txt	/*:sgr*
+:sh	various.txt	/*:sh*
+:shell	various.txt	/*:shell*
+:si	change.txt	/*:si*
+:sic	change.txt	/*:sic*
+:sie	change.txt	/*:sie*
+:sig	sign.txt	/*:sig*
+:sign	sign.txt	/*:sign*
+:sign-define	sign.txt	/*:sign-define*
+:sign-fname	sign.txt	/*:sign-fname*
+:sign-jump	sign.txt	/*:sign-jump*
+:sign-list	sign.txt	/*:sign-list*
+:sign-place	sign.txt	/*:sign-place*
+:sign-place-list	sign.txt	/*:sign-place-list*
+:sign-undefine	sign.txt	/*:sign-undefine*
+:sign-unplace	sign.txt	/*:sign-unplace*
+:sil	various.txt	/*:sil*
+:silent	various.txt	/*:silent*
+:silent!	various.txt	/*:silent!*
+:sim	gui_w32.txt	/*:sim*
+:simalt	gui_w32.txt	/*:simalt*
+:sin	change.txt	/*:sin*
+:sip	change.txt	/*:sip*
+:sir	change.txt	/*:sir*
+:sl	various.txt	/*:sl*
+:sla	windows.txt	/*:sla*
+:slast	windows.txt	/*:slast*
+:sleep	various.txt	/*:sleep*
+:sm	change.txt	/*:sm*
+:smagic	change.txt	/*:smagic*
+:smap	map.txt	/*:smap*
+:smap_l	map.txt	/*:smap_l*
+:smapc	map.txt	/*:smapc*
+:smapclear	map.txt	/*:smapclear*
+:sme	gui.txt	/*:sme*
+:smenu	gui.txt	/*:smenu*
+:smile	index.txt	/*:smile*
+:sn	windows.txt	/*:sn*
+:snext	windows.txt	/*:snext*
+:sno	change.txt	/*:sno*
+:snomagic	change.txt	/*:snomagic*
+:snor	map.txt	/*:snor*
+:snoremap	map.txt	/*:snoremap*
+:snoreme	gui.txt	/*:snoreme*
+:snoremenu	gui.txt	/*:snoremenu*
+:so	repeat.txt	/*:so*
+:sor	change.txt	/*:sor*
+:sort	change.txt	/*:sort*
+:source	repeat.txt	/*:source*
+:source_crnl	repeat.txt	/*:source_crnl*
+:sp	windows.txt	/*:sp*
+:spe	spell.txt	/*:spe*
+:spelld	spell.txt	/*:spelld*
+:spelldump	spell.txt	/*:spelldump*
+:spellgood	spell.txt	/*:spellgood*
+:spelli	spell.txt	/*:spelli*
+:spellinfo	spell.txt	/*:spellinfo*
+:spellr	spell.txt	/*:spellr*
+:spellrepall	spell.txt	/*:spellrepall*
+:spellu	spell.txt	/*:spellu*
+:spellundo	spell.txt	/*:spellundo*
+:spellw	spell.txt	/*:spellw*
+:spellwrong	spell.txt	/*:spellwrong*
+:split	windows.txt	/*:split*
+:split_f	windows.txt	/*:split_f*
+:spr	windows.txt	/*:spr*
+:sprevious	windows.txt	/*:sprevious*
+:sr	change.txt	/*:sr*
+:srI	change.txt	/*:srI*
+:src	change.txt	/*:src*
+:sre	windows.txt	/*:sre*
+:srewind	windows.txt	/*:srewind*
+:srg	change.txt	/*:srg*
+:sri	change.txt	/*:sri*
+:srl	change.txt	/*:srl*
+:srn	change.txt	/*:srn*
+:srp	change.txt	/*:srp*
+:st	starting.txt	/*:st*
+:sta	windows.txt	/*:sta*
+:stag	windows.txt	/*:stag*
+:star	repeat.txt	/*:star*
+:start	insert.txt	/*:start*
+:startgreplace	insert.txt	/*:startgreplace*
+:startinsert	insert.txt	/*:startinsert*
+:startreplace	insert.txt	/*:startreplace*
+:stj	tagsrch.txt	/*:stj*
+:stjump	tagsrch.txt	/*:stjump*
+:stop	starting.txt	/*:stop*
+:stopi	insert.txt	/*:stopi*
+:stopinsert	insert.txt	/*:stopinsert*
+:sts	tagsrch.txt	/*:sts*
+:stselect	tagsrch.txt	/*:stselect*
+:su	change.txt	/*:su*
+:substitute	change.txt	/*:substitute*
+:sun	windows.txt	/*:sun*
+:sunhide	windows.txt	/*:sunhide*
+:sunm	map.txt	/*:sunm*
+:sunmap	map.txt	/*:sunmap*
+:sunme	gui.txt	/*:sunme*
+:sunmenu	gui.txt	/*:sunmenu*
+:sus	starting.txt	/*:sus*
+:suspend	starting.txt	/*:suspend*
+:sv	windows.txt	/*:sv*
+:sview	windows.txt	/*:sview*
+:sw	recover.txt	/*:sw*
+:swapname	recover.txt	/*:swapname*
+:sy	syntax.txt	/*:sy*
+:syn	syntax.txt	/*:syn*
+:syn-arguments	syntax.txt	/*:syn-arguments*
+:syn-case	syntax.txt	/*:syn-case*
+:syn-cchar	syntax.txt	/*:syn-cchar*
+:syn-clear	syntax.txt	/*:syn-clear*
+:syn-cluster	syntax.txt	/*:syn-cluster*
+:syn-conceal	syntax.txt	/*:syn-conceal*
+:syn-conceal-implicit	syntax.txt	/*:syn-conceal-implicit*
+:syn-concealends	syntax.txt	/*:syn-concealends*
+:syn-contained	syntax.txt	/*:syn-contained*
+:syn-containedin	syntax.txt	/*:syn-containedin*
+:syn-contains	syntax.txt	/*:syn-contains*
+:syn-context	syntax.txt	/*:syn-context*
+:syn-default-override	usr_06.txt	/*:syn-default-override*
+:syn-define	syntax.txt	/*:syn-define*
+:syn-display	syntax.txt	/*:syn-display*
+:syn-enable	syntax.txt	/*:syn-enable*
+:syn-end	syntax.txt	/*:syn-end*
+:syn-excludenl	syntax.txt	/*:syn-excludenl*
+:syn-ext-match	syntax.txt	/*:syn-ext-match*
+:syn-extend	syntax.txt	/*:syn-extend*
+:syn-file-remarks	syntax.txt	/*:syn-file-remarks*
+:syn-files	syntax.txt	/*:syn-files*
+:syn-fold	syntax.txt	/*:syn-fold*
+:syn-include	syntax.txt	/*:syn-include*
+:syn-iskeyword	syntax.txt	/*:syn-iskeyword*
+:syn-keepend	syntax.txt	/*:syn-keepend*
+:syn-keyword	syntax.txt	/*:syn-keyword*
+:syn-lc	syntax.txt	/*:syn-lc*
+:syn-leading	syntax.txt	/*:syn-leading*
+:syn-list	syntax.txt	/*:syn-list*
+:syn-manual	usr_06.txt	/*:syn-manual*
+:syn-match	syntax.txt	/*:syn-match*
+:syn-matchgroup	syntax.txt	/*:syn-matchgroup*
+:syn-multi-line	syntax.txt	/*:syn-multi-line*
+:syn-nextgroup	syntax.txt	/*:syn-nextgroup*
+:syn-off	usr_06.txt	/*:syn-off*
+:syn-on	syntax.txt	/*:syn-on*
+:syn-oneline	syntax.txt	/*:syn-oneline*
+:syn-pattern	syntax.txt	/*:syn-pattern*
+:syn-pattern-offset	syntax.txt	/*:syn-pattern-offset*
+:syn-priority	syntax.txt	/*:syn-priority*
+:syn-qstart	syntax.txt	/*:syn-qstart*
+:syn-region	syntax.txt	/*:syn-region*
+:syn-reset	syntax.txt	/*:syn-reset*
+:syn-skip	syntax.txt	/*:syn-skip*
+:syn-skipempty	syntax.txt	/*:syn-skipempty*
+:syn-skipnl	syntax.txt	/*:syn-skipnl*
+:syn-skipwhite	syntax.txt	/*:syn-skipwhite*
+:syn-spell	syntax.txt	/*:syn-spell*
+:syn-start	syntax.txt	/*:syn-start*
+:syn-sync	syntax.txt	/*:syn-sync*
+:syn-sync-ccomment	syntax.txt	/*:syn-sync-ccomment*
+:syn-sync-first	syntax.txt	/*:syn-sync-first*
+:syn-sync-fourth	syntax.txt	/*:syn-sync-fourth*
+:syn-sync-linebreaks	syntax.txt	/*:syn-sync-linebreaks*
+:syn-sync-maxlines	syntax.txt	/*:syn-sync-maxlines*
+:syn-sync-minlines	syntax.txt	/*:syn-sync-minlines*
+:syn-sync-second	syntax.txt	/*:syn-sync-second*
+:syn-sync-third	syntax.txt	/*:syn-sync-third*
+:syn-transparent	syntax.txt	/*:syn-transparent*
+:sync	scroll.txt	/*:sync*
+:syncbind	scroll.txt	/*:syncbind*
+:syntax	syntax.txt	/*:syntax*
+:syntax-enable	syntax.txt	/*:syntax-enable*
+:syntax-on	syntax.txt	/*:syntax-on*
+:syntax-reset	syntax.txt	/*:syntax-reset*
+:syntime	syntax.txt	/*:syntime*
+:t	change.txt	/*:t*
+:tN	tagsrch.txt	/*:tN*
+:tNext	tagsrch.txt	/*:tNext*
+:ta	tagsrch.txt	/*:ta*
+:tab	tabpage.txt	/*:tab*
+:tabN	tabpage.txt	/*:tabN*
+:tabNext	tabpage.txt	/*:tabNext*
+:tabc	tabpage.txt	/*:tabc*
+:tabclose	tabpage.txt	/*:tabclose*
+:tabd	tabpage.txt	/*:tabd*
+:tabdo	tabpage.txt	/*:tabdo*
+:tabe	tabpage.txt	/*:tabe*
+:tabedit	tabpage.txt	/*:tabedit*
+:tabf	tabpage.txt	/*:tabf*
+:tabfind	tabpage.txt	/*:tabfind*
+:tabfir	tabpage.txt	/*:tabfir*
+:tabfirst	tabpage.txt	/*:tabfirst*
+:tabl	tabpage.txt	/*:tabl*
+:tablast	tabpage.txt	/*:tablast*
+:tabm	tabpage.txt	/*:tabm*
+:tabmove	tabpage.txt	/*:tabmove*
+:tabn	tabpage.txt	/*:tabn*
+:tabnew	tabpage.txt	/*:tabnew*
+:tabnext	tabpage.txt	/*:tabnext*
+:tabo	tabpage.txt	/*:tabo*
+:tabonly	tabpage.txt	/*:tabonly*
+:tabp	tabpage.txt	/*:tabp*
+:tabprevious	tabpage.txt	/*:tabprevious*
+:tabr	tabpage.txt	/*:tabr*
+:tabrewind	tabpage.txt	/*:tabrewind*
+:tabs	tabpage.txt	/*:tabs*
+:tag	tagsrch.txt	/*:tag*
+:tags	tagsrch.txt	/*:tags*
+:tc	if_tcl.txt	/*:tc*
+:tcl	if_tcl.txt	/*:tcl*
+:tcld	if_tcl.txt	/*:tcld*
+:tcldo	if_tcl.txt	/*:tcldo*
+:tclf	if_tcl.txt	/*:tclf*
+:tclfile	if_tcl.txt	/*:tclfile*
+:te	gui_w32.txt	/*:te*
+:tearoff	gui_w32.txt	/*:tearoff*
+:ter	terminal.txt	/*:ter*
+:terminal	terminal.txt	/*:terminal*
+:tf	tagsrch.txt	/*:tf*
+:tfirst	tagsrch.txt	/*:tfirst*
+:th	eval.txt	/*:th*
+:throw	eval.txt	/*:throw*
+:tj	tagsrch.txt	/*:tj*
+:tjump	tagsrch.txt	/*:tjump*
+:tl	tagsrch.txt	/*:tl*
+:tlast	tagsrch.txt	/*:tlast*
+:tm	gui.txt	/*:tm*
+:tma	map.txt	/*:tma*
+:tmap	map.txt	/*:tmap*
+:tmap_l	map.txt	/*:tmap_l*
+:tmapc	map.txt	/*:tmapc*
+:tmapclear	map.txt	/*:tmapclear*
+:tmenu	gui.txt	/*:tmenu*
+:tn	tagsrch.txt	/*:tn*
+:tnext	tagsrch.txt	/*:tnext*
+:tno	map.txt	/*:tno*
+:tnoremap	map.txt	/*:tnoremap*
+:topleft	windows.txt	/*:topleft*
+:tp	tagsrch.txt	/*:tp*
+:tprevious	tagsrch.txt	/*:tprevious*
+:tr	tagsrch.txt	/*:tr*
+:trewind	tagsrch.txt	/*:trewind*
+:try	eval.txt	/*:try*
+:ts	tagsrch.txt	/*:ts*
+:tselect	tagsrch.txt	/*:tselect*
+:tu	gui.txt	/*:tu*
+:tunma	map.txt	/*:tunma*
+:tunmap	map.txt	/*:tunmap*
+:tunmenu	gui.txt	/*:tunmenu*
+:u	undo.txt	/*:u*
+:un	undo.txt	/*:un*
+:una	map.txt	/*:una*
+:unabbreviate	map.txt	/*:unabbreviate*
+:undo	undo.txt	/*:undo*
+:undoj	undo.txt	/*:undoj*
+:undojoin	undo.txt	/*:undojoin*
+:undol	undo.txt	/*:undol*
+:undolist	undo.txt	/*:undolist*
+:unh	windows.txt	/*:unh*
+:unhide	windows.txt	/*:unhide*
+:unl	eval.txt	/*:unl*
+:unlet	eval.txt	/*:unlet*
+:unlet-$	eval.txt	/*:unlet-$*
+:unlet-environment	eval.txt	/*:unlet-environment*
+:unlo	eval.txt	/*:unlo*
+:unlockvar	eval.txt	/*:unlockvar*
+:unm	map.txt	/*:unm*
+:unm!	map.txt	/*:unm!*
+:unmap	map.txt	/*:unmap*
+:unmap!	map.txt	/*:unmap!*
+:unme	gui.txt	/*:unme*
+:unmenu	gui.txt	/*:unmenu*
+:unmenu-all	gui.txt	/*:unmenu-all*
+:uns	various.txt	/*:uns*
+:unsilent	various.txt	/*:unsilent*
+:up	editing.txt	/*:up*
+:update	editing.txt	/*:update*
+:v	repeat.txt	/*:v*
+:ve	various.txt	/*:ve*
+:verb	various.txt	/*:verb*
+:verbose	various.txt	/*:verbose*
+:verbose-cmd	various.txt	/*:verbose-cmd*
+:version	various.txt	/*:version*
+:vert	windows.txt	/*:vert*
+:vertical	windows.txt	/*:vertical*
+:vertical-resize	windows.txt	/*:vertical-resize*
+:vglobal	repeat.txt	/*:vglobal*
+:vi	editing.txt	/*:vi*
+:vie	editing.txt	/*:vie*
+:view	editing.txt	/*:view*
+:vim	quickfix.txt	/*:vim*
+:vimgrep	quickfix.txt	/*:vimgrep*
+:vimgrepa	quickfix.txt	/*:vimgrepa*
+:vimgrepadd	quickfix.txt	/*:vimgrepadd*
+:visual	editing.txt	/*:visual*
+:visual_example	visual.txt	/*:visual_example*
+:viu	helphelp.txt	/*:viu*
+:viusage	helphelp.txt	/*:viusage*
+:vm	map.txt	/*:vm*
+:vmap	map.txt	/*:vmap*
+:vmap_l	map.txt	/*:vmap_l*
+:vmapc	map.txt	/*:vmapc*
+:vmapclear	map.txt	/*:vmapclear*
+:vme	gui.txt	/*:vme*
+:vmenu	gui.txt	/*:vmenu*
+:vn	map.txt	/*:vn*
+:vne	windows.txt	/*:vne*
+:vnew	windows.txt	/*:vnew*
+:vnoremap	map.txt	/*:vnoremap*
+:vnoreme	gui.txt	/*:vnoreme*
+:vnoremenu	gui.txt	/*:vnoremenu*
+:vs	windows.txt	/*:vs*
+:vsplit	windows.txt	/*:vsplit*
+:vu	map.txt	/*:vu*
+:vunmap	map.txt	/*:vunmap*
+:vunme	gui.txt	/*:vunme*
+:vunmenu	gui.txt	/*:vunmenu*
+:w	editing.txt	/*:w*
+:w!	editing.txt	/*:w!*
+:wN	editing.txt	/*:wN*
+:wNext	editing.txt	/*:wNext*
+:w_a	editing.txt	/*:w_a*
+:w_c	editing.txt	/*:w_c*
+:w_f	editing.txt	/*:w_f*
+:wa	editing.txt	/*:wa*
+:wall	editing.txt	/*:wall*
+:wh	eval.txt	/*:wh*
+:while	eval.txt	/*:while*
+:win	gui.txt	/*:win*
+:winc	windows.txt	/*:winc*
+:wincmd	windows.txt	/*:wincmd*
+:windo	windows.txt	/*:windo*
+:winp	gui.txt	/*:winp*
+:winpos	gui.txt	/*:winpos*
+:winsize	gui.txt	/*:winsize*
+:wn	editing.txt	/*:wn*
+:wnext	editing.txt	/*:wnext*
+:wp	editing.txt	/*:wp*
+:wprevious	editing.txt	/*:wprevious*
+:wq	editing.txt	/*:wq*
+:wqa	editing.txt	/*:wqa*
+:wqall	editing.txt	/*:wqall*
+:write	editing.txt	/*:write*
+:write_a	editing.txt	/*:write_a*
+:write_c	editing.txt	/*:write_c*
+:write_f	editing.txt	/*:write_f*
+:ws	workshop.txt	/*:ws*
+:wsverb	workshop.txt	/*:wsverb*
+:wundo	undo.txt	/*:wundo*
+:wv	starting.txt	/*:wv*
+:wviminfo	starting.txt	/*:wviminfo*
+:x	editing.txt	/*:x*
+:xa	editing.txt	/*:xa*
+:xall	editing.txt	/*:xall*
+:xit	editing.txt	/*:xit*
+:xm	map.txt	/*:xm*
+:xmap	map.txt	/*:xmap*
+:xmap_l	map.txt	/*:xmap_l*
+:xmapc	map.txt	/*:xmapc*
+:xmapclear	map.txt	/*:xmapclear*
+:xme	gui.txt	/*:xme*
+:xmenu	gui.txt	/*:xmenu*
+:xn	map.txt	/*:xn*
+:xnoremap	map.txt	/*:xnoremap*
+:xnoreme	gui.txt	/*:xnoreme*
+:xnoremenu	gui.txt	/*:xnoremenu*
+:xu	map.txt	/*:xu*
+:xunmap	map.txt	/*:xunmap*
+:xunme	gui.txt	/*:xunme*
+:xunmenu	gui.txt	/*:xunmenu*
+:y	change.txt	/*:y*
+:yank	change.txt	/*:yank*
+:z	various.txt	/*:z*
+:z#	various.txt	/*:z#*
+:~	change.txt	/*:~*
+;	motion.txt	/*;*
+<	change.txt	/*<*
+<2-LeftMouse>	term.txt	/*<2-LeftMouse>*
+<3-LeftMouse>	term.txt	/*<3-LeftMouse>*
+<4-LeftMouse>	term.txt	/*<4-LeftMouse>*
+<<	change.txt	/*<<*
+<>	intro.txt	/*<>*
+<A-	intro.txt	/*<A-*
+<A-LeftMouse>	term.txt	/*<A-LeftMouse>*
+<A-RightMouse>	term.txt	/*<A-RightMouse>*
+<BS>	motion.txt	/*<BS>*
+<Bar>	intro.txt	/*<Bar>*
+<Bslash>	intro.txt	/*<Bslash>*
+<C-	intro.txt	/*<C-*
+<C-Del>	os_dos.txt	/*<C-Del>*
+<C-End>	motion.txt	/*<C-End>*
+<C-Home>	motion.txt	/*<C-Home>*
+<C-Insert>	os_dos.txt	/*<C-Insert>*
+<C-Left>	motion.txt	/*<C-Left>*
+<C-LeftMouse>	tagsrch.txt	/*<C-LeftMouse>*
+<C-PageDown>	tabpage.txt	/*<C-PageDown>*
+<C-PageUp>	tabpage.txt	/*<C-PageUp>*
+<C-Right>	motion.txt	/*<C-Right>*
+<C-RightMouse>	tagsrch.txt	/*<C-RightMouse>*
+<C-ScrollWheelDown>	scroll.txt	/*<C-ScrollWheelDown>*
+<C-ScrollWheelLeft>	scroll.txt	/*<C-ScrollWheelLeft>*
+<C-ScrollWheelRight>	scroll.txt	/*<C-ScrollWheelRight>*
+<C-ScrollWheelUp>	scroll.txt	/*<C-ScrollWheelUp>*
+<CR>	motion.txt	/*<CR>*
+<CSI>	intro.txt	/*<CSI>*
+<Char->	map.txt	/*<Char->*
+<Char>	map.txt	/*<Char>*
+<CursorHold>	autocmd.txt	/*<CursorHold>*
+<D-	intro.txt	/*<D-*
+<D-c>	os_mac.txt	/*<D-c>*
+<D-v>	os_mac.txt	/*<D-v>*
+<D-x>	os_mac.txt	/*<D-x>*
+<Del>	change.txt	/*<Del>*
+<Down>	motion.txt	/*<Down>*
+<Drop>	change.txt	/*<Drop>*
+<EOL>	intro.txt	/*<EOL>*
+<End>	motion.txt	/*<End>*
+<Enter>	intro.txt	/*<Enter>*
+<Esc>	intro.txt	/*<Esc>*
+<F10>	term.txt	/*<F10>*
+<F11>	term.txt	/*<F11>*
+<F12>	term.txt	/*<F12>*
+<F13>	term.txt	/*<F13>*
+<F14>	term.txt	/*<F14>*
+<F15>	term.txt	/*<F15>*
+<F16>	term.txt	/*<F16>*
+<F17>	term.txt	/*<F17>*
+<F18>	term.txt	/*<F18>*
+<F19>	term.txt	/*<F19>*
+<F1>	helphelp.txt	/*<F1>*
+<F2>	term.txt	/*<F2>*
+<F3>	term.txt	/*<F3>*
+<F4>	term.txt	/*<F4>*
+<F5>	term.txt	/*<F5>*
+<F6>	term.txt	/*<F6>*
+<F7>	term.txt	/*<F7>*
+<F8>	term.txt	/*<F8>*
+<F9>	term.txt	/*<F9>*
+<Help>	helphelp.txt	/*<Help>*
+<Home>	motion.txt	/*<Home>*
+<Insert>	insert.txt	/*<Insert>*
+<Leader>	map.txt	/*<Leader>*
+<Left>	motion.txt	/*<Left>*
+<LeftDrag>	term.txt	/*<LeftDrag>*
+<LeftMouse>	visual.txt	/*<LeftMouse>*
+<LeftRelease>	visual.txt	/*<LeftRelease>*
+<LocalLeader>	map.txt	/*<LocalLeader>*
+<M-	intro.txt	/*<M-*
+<MiddleDrag>	term.txt	/*<MiddleDrag>*
+<MiddleMouse>	change.txt	/*<MiddleMouse>*
+<MiddleRelease>	term.txt	/*<MiddleRelease>*
+<Mouse>	term.txt	/*<Mouse>*
+<MouseDown>	scroll.txt	/*<MouseDown>*
+<MouseUp>	scroll.txt	/*<MouseUp>*
+<NL>	motion.txt	/*<NL>*
+<Nop>	map.txt	/*<Nop>*
+<Nul>	intro.txt	/*<Nul>*
+<PageDown>	scroll.txt	/*<PageDown>*
+<PageUp>	scroll.txt	/*<PageUp>*
+<Plug>	map.txt	/*<Plug>*
+<Return>	intro.txt	/*<Return>*
+<Right>	motion.txt	/*<Right>*
+<RightDrag>	term.txt	/*<RightDrag>*
+<RightMouse>	visual.txt	/*<RightMouse>*
+<RightRelease>	term.txt	/*<RightRelease>*
+<S-	intro.txt	/*<S-*
+<S-Del>	os_dos.txt	/*<S-Del>*
+<S-Down>	scroll.txt	/*<S-Down>*
+<S-End>	term.txt	/*<S-End>*
+<S-F10>	term.txt	/*<S-F10>*
+<S-F11>	term.txt	/*<S-F11>*
+<S-F12>	term.txt	/*<S-F12>*
+<S-F1>	intro.txt	/*<S-F1>*
+<S-F2>	term.txt	/*<S-F2>*
+<S-F3>	term.txt	/*<S-F3>*
+<S-F4>	term.txt	/*<S-F4>*
+<S-F5>	term.txt	/*<S-F5>*
+<S-F6>	term.txt	/*<S-F6>*
+<S-F7>	term.txt	/*<S-F7>*
+<S-F8>	term.txt	/*<S-F8>*
+<S-F9>	term.txt	/*<S-F9>*
+<S-Home>	term.txt	/*<S-Home>*
+<S-Insert>	os_dos.txt	/*<S-Insert>*
+<S-Left>	motion.txt	/*<S-Left>*
+<S-LeftMouse>	term.txt	/*<S-LeftMouse>*
+<S-Right>	motion.txt	/*<S-Right>*
+<S-RightMouse>	term.txt	/*<S-RightMouse>*
+<S-ScrollWheelDown>	scroll.txt	/*<S-ScrollWheelDown>*
+<S-ScrollWheelLeft>	scroll.txt	/*<S-ScrollWheelLeft>*
+<S-ScrollWheelRight>	scroll.txt	/*<S-ScrollWheelRight>*
+<S-ScrollWheelUp>	scroll.txt	/*<S-ScrollWheelUp>*
+<S-Tab>	term.txt	/*<S-Tab>*
+<S-Up>	scroll.txt	/*<S-Up>*
+<S-xF1>	term.txt	/*<S-xF1>*
+<S-xF2>	term.txt	/*<S-xF2>*
+<S-xF3>	term.txt	/*<S-xF3>*
+<S-xF4>	term.txt	/*<S-xF4>*
+<SID>	map.txt	/*<SID>*
+<SNR>	map.txt	/*<SNR>*
+<ScrollWheelDown>	scroll.txt	/*<ScrollWheelDown>*
+<ScrollWheelLeft>	scroll.txt	/*<ScrollWheelLeft>*
+<ScrollWheelRight>	scroll.txt	/*<ScrollWheelRight>*
+<ScrollWheelUp>	scroll.txt	/*<ScrollWheelUp>*
+<Space>	motion.txt	/*<Space>*
+<Tab>	motion.txt	/*<Tab>*
+<Undo>	undo.txt	/*<Undo>*
+<Up>	motion.txt	/*<Up>*
+<abuf>	cmdline.txt	/*<abuf>*
+<afile>	cmdline.txt	/*<afile>*
+<amatch>	cmdline.txt	/*<amatch>*
+<args>	map.txt	/*<args>*
+<bang>	map.txt	/*<bang>*
+<buffer=N>	autocmd.txt	/*<buffer=N>*
+<buffer=abuf>	autocmd.txt	/*<buffer=abuf>*
+<cexpr>	cmdline.txt	/*<cexpr>*
+<cfile>	cmdline.txt	/*<cfile>*
+<character>	intro.txt	/*<character>*
+<count>	map.txt	/*<count>*
+<f-args>	map.txt	/*<f-args>*
+<k0>	term.txt	/*<k0>*
+<k1>	term.txt	/*<k1>*
+<k2>	term.txt	/*<k2>*
+<k3>	term.txt	/*<k3>*
+<k4>	term.txt	/*<k4>*
+<k5>	term.txt	/*<k5>*
+<k6>	term.txt	/*<k6>*
+<k7>	term.txt	/*<k7>*
+<k8>	term.txt	/*<k8>*
+<k9>	term.txt	/*<k9>*
+<kDivide>	term.txt	/*<kDivide>*
+<kEnd>	motion.txt	/*<kEnd>*
+<kEnter>	term.txt	/*<kEnter>*
+<kHome>	motion.txt	/*<kHome>*
+<kMinus>	term.txt	/*<kMinus>*
+<kMultiply>	term.txt	/*<kMultiply>*
+<kPageDown>	scroll.txt	/*<kPageDown>*
+<kPageUp>	scroll.txt	/*<kPageUp>*
+<kPlus>	term.txt	/*<kPlus>*
+<kPoint>	term.txt	/*<kPoint>*
+<line1>	map.txt	/*<line1>*
+<line2>	map.txt	/*<line2>*
+<lt>	intro.txt	/*<lt>*
+<mods>	map.txt	/*<mods>*
+<nomodeline>	autocmd.txt	/*<nomodeline>*
+<q-args>	map.txt	/*<q-args>*
+<range>	map.txt	/*<range>*
+<reg>	map.txt	/*<reg>*
+<register>	map.txt	/*<register>*
+<sfile>	cmdline.txt	/*<sfile>*
+<slnum>	cmdline.txt	/*<slnum>*
+<xCSI>	intro.txt	/*<xCSI>*
+<xDown>	term.txt	/*<xDown>*
+<xEnd>	term.txt	/*<xEnd>*
+<xEnd>-xterm	term.txt	/*<xEnd>-xterm*
+<xF1>	term.txt	/*<xF1>*
+<xF1>-xterm	term.txt	/*<xF1>-xterm*
+<xF2>	term.txt	/*<xF2>*
+<xF2>-xterm	term.txt	/*<xF2>-xterm*
+<xF3>	term.txt	/*<xF3>*
+<xF3>-xterm	term.txt	/*<xF3>-xterm*
+<xF4>	term.txt	/*<xF4>*
+<xF4>-xterm	term.txt	/*<xF4>-xterm*
+<xHome>	term.txt	/*<xHome>*
+<xHome>-xterm	term.txt	/*<xHome>-xterm*
+<xLeft>	term.txt	/*<xLeft>*
+<xRight>	term.txt	/*<xRight>*
+<xUp>	term.txt	/*<xUp>*
+=	change.txt	/*=*
+==	change.txt	/*==*
+>	change.txt	/*>*
+>>	change.txt	/*>>*
+>backtrace	repeat.txt	/*>backtrace*
+>bt	repeat.txt	/*>bt*
+>cont	repeat.txt	/*>cont*
+>down	repeat.txt	/*>down*
+>finish	repeat.txt	/*>finish*
+>frame	repeat.txt	/*>frame*
+>interrupt	repeat.txt	/*>interrupt*
+>next	repeat.txt	/*>next*
+>quit	repeat.txt	/*>quit*
+>step	repeat.txt	/*>step*
+>up	repeat.txt	/*>up*
+>where	repeat.txt	/*>where*
+?	pattern.txt	/*?*
+?<CR>	pattern.txt	/*?<CR>*
+@	repeat.txt	/*@*
+@/	change.txt	/*@\/*
+@:	repeat.txt	/*@:*
+@=	change.txt	/*@=*
+@@	repeat.txt	/*@@*
+@r	eval.txt	/*@r*
+A	insert.txt	/*A*
+ACL	editing.txt	/*ACL*
+ANSI-C	develop.txt	/*ANSI-C*
+ATTENTION	usr_11.txt	/*ATTENTION*
+Abbreviations	map.txt	/*Abbreviations*
+Aleph	options.txt	/*Aleph*
+Amiga	os_amiga.txt	/*Amiga*
+Arabic	arabic.txt	/*Arabic*
+Atari	os_mint.txt	/*Atari*
+Athena	gui_x11.txt	/*Athena*
+B	motion.txt	/*B*
+BeBox	os_beos.txt	/*BeBox*
+BeOS	os_beos.txt	/*BeOS*
+Bram	intro.txt	/*Bram*
+BufAdd	autocmd.txt	/*BufAdd*
+BufCreate	autocmd.txt	/*BufCreate*
+BufDelete	autocmd.txt	/*BufDelete*
+BufEnter	autocmd.txt	/*BufEnter*
+BufFilePost	autocmd.txt	/*BufFilePost*
+BufFilePre	autocmd.txt	/*BufFilePre*
+BufHidden	autocmd.txt	/*BufHidden*
+BufLeave	autocmd.txt	/*BufLeave*
+BufNew	autocmd.txt	/*BufNew*
+BufNewFile	autocmd.txt	/*BufNewFile*
+BufRead	autocmd.txt	/*BufRead*
+BufReadCmd	autocmd.txt	/*BufReadCmd*
+BufReadPost	autocmd.txt	/*BufReadPost*
+BufReadPre	autocmd.txt	/*BufReadPre*
+BufUnload	autocmd.txt	/*BufUnload*
+BufWinEnter	autocmd.txt	/*BufWinEnter*
+BufWinLeave	autocmd.txt	/*BufWinLeave*
+BufWipeout	autocmd.txt	/*BufWipeout*
+BufWrite	autocmd.txt	/*BufWrite*
+BufWriteCmd	autocmd.txt	/*BufWriteCmd*
+BufWritePost	autocmd.txt	/*BufWritePost*
+BufWritePre	autocmd.txt	/*BufWritePre*
+C	change.txt	/*C*
+C-editing	tips.txt	/*C-editing*
+C-indenting	indent.txt	/*C-indenting*
+C89	develop.txt	/*C89*
+C99	develop.txt	/*C99*
+COMSPEC	starting.txt	/*COMSPEC*
+CR-used-for-NL	pattern.txt	/*CR-used-for-NL*
+CTRL-6	editing.txt	/*CTRL-6*
+CTRL-<PageDown>	tabpage.txt	/*CTRL-<PageDown>*
+CTRL-<PageUp>	tabpage.txt	/*CTRL-<PageUp>*
+CTRL-A	change.txt	/*CTRL-A*
+CTRL-B	scroll.txt	/*CTRL-B*
+CTRL-C	pattern.txt	/*CTRL-C*
+CTRL-D	scroll.txt	/*CTRL-D*
+CTRL-E	scroll.txt	/*CTRL-E*
+CTRL-F	scroll.txt	/*CTRL-F*
+CTRL-G	editing.txt	/*CTRL-G*
+CTRL-H	motion.txt	/*CTRL-H*
+CTRL-I	motion.txt	/*CTRL-I*
+CTRL-J	motion.txt	/*CTRL-J*
+CTRL-L	various.txt	/*CTRL-L*
+CTRL-M	motion.txt	/*CTRL-M*
+CTRL-N	motion.txt	/*CTRL-N*
+CTRL-O	motion.txt	/*CTRL-O*
+CTRL-P	motion.txt	/*CTRL-P*
+CTRL-Q	gui_w32.txt	/*CTRL-Q*
+CTRL-R	undo.txt	/*CTRL-R*
+CTRL-T	tagsrch.txt	/*CTRL-T*
+CTRL-U	scroll.txt	/*CTRL-U*
+CTRL-U-changed	version6.txt	/*CTRL-U-changed*
+CTRL-V	visual.txt	/*CTRL-V*
+CTRL-V-alternative	gui_w32.txt	/*CTRL-V-alternative*
+CTRL-W	index.txt	/*CTRL-W*
+CTRL-W_+	windows.txt	/*CTRL-W_+*
+CTRL-W_-	windows.txt	/*CTRL-W_-*
+CTRL-W_.	terminal.txt	/*CTRL-W_.*
+CTRL-W_:	windows.txt	/*CTRL-W_:*
+CTRL-W_<	windows.txt	/*CTRL-W_<*
+CTRL-W_<BS>	windows.txt	/*CTRL-W_<BS>*
+CTRL-W_<CR>	quickfix.txt	/*CTRL-W_<CR>*
+CTRL-W_<Down>	windows.txt	/*CTRL-W_<Down>*
+CTRL-W_<Enter>	quickfix.txt	/*CTRL-W_<Enter>*
+CTRL-W_<Left>	windows.txt	/*CTRL-W_<Left>*
+CTRL-W_<Right>	windows.txt	/*CTRL-W_<Right>*
+CTRL-W_<Up>	windows.txt	/*CTRL-W_<Up>*
+CTRL-W_=	windows.txt	/*CTRL-W_=*
+CTRL-W_>	windows.txt	/*CTRL-W_>*
+CTRL-W_CTRL-B	windows.txt	/*CTRL-W_CTRL-B*
+CTRL-W_CTRL-C	windows.txt	/*CTRL-W_CTRL-C*
+CTRL-W_CTRL-D	tagsrch.txt	/*CTRL-W_CTRL-D*
+CTRL-W_CTRL-F	windows.txt	/*CTRL-W_CTRL-F*
+CTRL-W_CTRL-H	windows.txt	/*CTRL-W_CTRL-H*
+CTRL-W_CTRL-I	tagsrch.txt	/*CTRL-W_CTRL-I*
+CTRL-W_CTRL-J	windows.txt	/*CTRL-W_CTRL-J*
+CTRL-W_CTRL-K	windows.txt	/*CTRL-W_CTRL-K*
+CTRL-W_CTRL-L	windows.txt	/*CTRL-W_CTRL-L*
+CTRL-W_CTRL-N	windows.txt	/*CTRL-W_CTRL-N*
+CTRL-W_CTRL-O	windows.txt	/*CTRL-W_CTRL-O*
+CTRL-W_CTRL-P	windows.txt	/*CTRL-W_CTRL-P*
+CTRL-W_CTRL-Q	windows.txt	/*CTRL-W_CTRL-Q*
+CTRL-W_CTRL-R	windows.txt	/*CTRL-W_CTRL-R*
+CTRL-W_CTRL-S	windows.txt	/*CTRL-W_CTRL-S*
+CTRL-W_CTRL-T	windows.txt	/*CTRL-W_CTRL-T*
+CTRL-W_CTRL-V	windows.txt	/*CTRL-W_CTRL-V*
+CTRL-W_CTRL-W	windows.txt	/*CTRL-W_CTRL-W*
+CTRL-W_CTRL-X	windows.txt	/*CTRL-W_CTRL-X*
+CTRL-W_CTRL-Z	windows.txt	/*CTRL-W_CTRL-Z*
+CTRL-W_CTRL-]	windows.txt	/*CTRL-W_CTRL-]*
+CTRL-W_CTRL-^	windows.txt	/*CTRL-W_CTRL-^*
+CTRL-W_CTRL-_	windows.txt	/*CTRL-W_CTRL-_*
+CTRL-W_F	windows.txt	/*CTRL-W_F*
+CTRL-W_H	windows.txt	/*CTRL-W_H*
+CTRL-W_J	windows.txt	/*CTRL-W_J*
+CTRL-W_K	windows.txt	/*CTRL-W_K*
+CTRL-W_L	windows.txt	/*CTRL-W_L*
+CTRL-W_N	terminal.txt	/*CTRL-W_N*
+CTRL-W_P	windows.txt	/*CTRL-W_P*
+CTRL-W_R	windows.txt	/*CTRL-W_R*
+CTRL-W_S	windows.txt	/*CTRL-W_S*
+CTRL-W_T	windows.txt	/*CTRL-W_T*
+CTRL-W_W	windows.txt	/*CTRL-W_W*
+CTRL-W_]	windows.txt	/*CTRL-W_]*
+CTRL-W_^	windows.txt	/*CTRL-W_^*
+CTRL-W__	windows.txt	/*CTRL-W__*
+CTRL-W_b	windows.txt	/*CTRL-W_b*
+CTRL-W_bar	windows.txt	/*CTRL-W_bar*
+CTRL-W_c	windows.txt	/*CTRL-W_c*
+CTRL-W_d	tagsrch.txt	/*CTRL-W_d*
+CTRL-W_f	windows.txt	/*CTRL-W_f*
+CTRL-W_gF	windows.txt	/*CTRL-W_gF*
+CTRL-W_g]	windows.txt	/*CTRL-W_g]*
+CTRL-W_g_CTRL-]	windows.txt	/*CTRL-W_g_CTRL-]*
+CTRL-W_gf	windows.txt	/*CTRL-W_gf*
+CTRL-W_g}	windows.txt	/*CTRL-W_g}*
+CTRL-W_h	windows.txt	/*CTRL-W_h*
+CTRL-W_i	tagsrch.txt	/*CTRL-W_i*
+CTRL-W_j	windows.txt	/*CTRL-W_j*
+CTRL-W_k	windows.txt	/*CTRL-W_k*
+CTRL-W_l	windows.txt	/*CTRL-W_l*
+CTRL-W_n	windows.txt	/*CTRL-W_n*
+CTRL-W_o	windows.txt	/*CTRL-W_o*
+CTRL-W_p	windows.txt	/*CTRL-W_p*
+CTRL-W_q	windows.txt	/*CTRL-W_q*
+CTRL-W_quote	terminal.txt	/*CTRL-W_quote*
+CTRL-W_r	windows.txt	/*CTRL-W_r*
+CTRL-W_s	windows.txt	/*CTRL-W_s*
+CTRL-W_t	windows.txt	/*CTRL-W_t*
+CTRL-W_v	windows.txt	/*CTRL-W_v*
+CTRL-W_w	windows.txt	/*CTRL-W_w*
+CTRL-W_x	windows.txt	/*CTRL-W_x*
+CTRL-W_z	windows.txt	/*CTRL-W_z*
+CTRL-W_}	windows.txt	/*CTRL-W_}*
+CTRL-X	change.txt	/*CTRL-X*
+CTRL-Y	scroll.txt	/*CTRL-Y*
+CTRL-Z	starting.txt	/*CTRL-Z*
+CTRL-\_CTRL-G	intro.txt	/*CTRL-\\_CTRL-G*
+CTRL-\_CTRL-N	intro.txt	/*CTRL-\\_CTRL-N*
+CTRL-]	tagsrch.txt	/*CTRL-]*
+CTRL-^	editing.txt	/*CTRL-^*
+CTRL-{char}	intro.txt	/*CTRL-{char}*
+Channel	eval.txt	/*Channel*
+Channels	eval.txt	/*Channels*
+Chinese	mbyte.txt	/*Chinese*
+Cmd-event	autocmd.txt	/*Cmd-event*
+CmdUndefined	autocmd.txt	/*CmdUndefined*
+Cmdline	cmdline.txt	/*Cmdline*
+Cmdline-mode	cmdline.txt	/*Cmdline-mode*
+CmdlineChanged	autocmd.txt	/*CmdlineChanged*
+CmdlineEnter	autocmd.txt	/*CmdlineEnter*
+CmdlineLeave	autocmd.txt	/*CmdlineLeave*
+CmdwinEnter	autocmd.txt	/*CmdwinEnter*
+CmdwinLeave	autocmd.txt	/*CmdwinLeave*
+ColorScheme	autocmd.txt	/*ColorScheme*
+ColorSchemePre	autocmd.txt	/*ColorSchemePre*
+Command-line	cmdline.txt	/*Command-line*
+Command-line-mode	cmdline.txt	/*Command-line-mode*
+CompleteDone	autocmd.txt	/*CompleteDone*
+Contents	quickref.txt	/*Contents*
+Cscope	if_cscop.txt	/*Cscope*
+CursorHold	autocmd.txt	/*CursorHold*
+CursorHold-example	windows.txt	/*CursorHold-example*
+CursorHoldI	autocmd.txt	/*CursorHoldI*
+CursorIM	mbyte.txt	/*CursorIM*
+CursorMoved	autocmd.txt	/*CursorMoved*
+CursorMovedI	autocmd.txt	/*CursorMovedI*
+D	change.txt	/*D*
+DOS	os_dos.txt	/*DOS*
+DOS-format	editing.txt	/*DOS-format*
+DOS-format-write	editing.txt	/*DOS-format-write*
+Dictionaries	eval.txt	/*Dictionaries*
+Dictionary	eval.txt	/*Dictionary*
+Dictionary-function	eval.txt	/*Dictionary-function*
+Digraphs	digraph.txt	/*Digraphs*
+DirChanged	autocmd.txt	/*DirChanged*
+E	motion.txt	/*E*
+E10	message.txt	/*E10*
+E100	diff.txt	/*E100*
+E101	diff.txt	/*E101*
+E102	diff.txt	/*E102*
+E103	diff.txt	/*E103*
+E104	digraph.txt	/*E104*
+E105	mbyte.txt	/*E105*
+E107	eval.txt	/*E107*
+E108	eval.txt	/*E108*
+E109	eval.txt	/*E109*
+E11	cmdline.txt	/*E11*
+E110	eval.txt	/*E110*
+E111	eval.txt	/*E111*
+E112	eval.txt	/*E112*
+E113	eval.txt	/*E113*
+E114	eval.txt	/*E114*
+E115	eval.txt	/*E115*
+E116	eval.txt	/*E116*
+E117	eval.txt	/*E117*
+E118	eval.txt	/*E118*
+E119	eval.txt	/*E119*
+E12	message.txt	/*E12*
+E120	eval.txt	/*E120*
+E121	eval.txt	/*E121*
+E122	eval.txt	/*E122*
+E123	eval.txt	/*E123*
+E124	eval.txt	/*E124*
+E125	eval.txt	/*E125*
+E126	eval.txt	/*E126*
+E127	eval.txt	/*E127*
+E128	eval.txt	/*E128*
+E129	eval.txt	/*E129*
+E13	message.txt	/*E13*
+E130	eval.txt	/*E130*
+E131	eval.txt	/*E131*
+E132	eval.txt	/*E132*
+E133	eval.txt	/*E133*
+E134	change.txt	/*E134*
+E135	autocmd.txt	/*E135*
+E136	starting.txt	/*E136*
+E137	starting.txt	/*E137*
+E138	starting.txt	/*E138*
+E139	message.txt	/*E139*
+E14	cmdline.txt	/*E14*
+E140	message.txt	/*E140*
+E141	message.txt	/*E141*
+E142	message.txt	/*E142*
+E143	autocmd.txt	/*E143*
+E144	various.txt	/*E144*
+E145	starting.txt	/*E145*
+E146	change.txt	/*E146*
+E147	repeat.txt	/*E147*
+E148	repeat.txt	/*E148*
+E149	helphelp.txt	/*E149*
+E15	eval.txt	/*E15*
+E150	helphelp.txt	/*E150*
+E151	helphelp.txt	/*E151*
+E152	helphelp.txt	/*E152*
+E153	helphelp.txt	/*E153*
+E154	helphelp.txt	/*E154*
+E155	sign.txt	/*E155*
+E156	sign.txt	/*E156*
+E157	sign.txt	/*E157*
+E158	sign.txt	/*E158*
+E159	sign.txt	/*E159*
+E16	cmdline.txt	/*E16*
+E160	sign.txt	/*E160*
+E161	repeat.txt	/*E161*
+E162	message.txt	/*E162*
+E163	editing.txt	/*E163*
+E164	editing.txt	/*E164*
+E165	editing.txt	/*E165*
+E166	message.txt	/*E166*
+E167	repeat.txt	/*E167*
+E168	repeat.txt	/*E168*
+E169	message.txt	/*E169*
+E17	message.txt	/*E17*
+E170	eval.txt	/*E170*
+E171	eval.txt	/*E171*
+E173	message.txt	/*E173*
+E174	map.txt	/*E174*
+E175	map.txt	/*E175*
+E176	map.txt	/*E176*
+E177	map.txt	/*E177*
+E178	map.txt	/*E178*
+E179	map.txt	/*E179*
+E18	eval.txt	/*E18*
+E180	map.txt	/*E180*
+E181	map.txt	/*E181*
+E182	map.txt	/*E182*
+E183	map.txt	/*E183*
+E184	map.txt	/*E184*
+E185	syntax.txt	/*E185*
+E186	editing.txt	/*E186*
+E187	editing.txt	/*E187*
+E188	gui.txt	/*E188*
+E189	message.txt	/*E189*
+E19	message.txt	/*E19*
+E190	message.txt	/*E190*
+E191	motion.txt	/*E191*
+E192	message.txt	/*E192*
+E193	eval.txt	/*E193*
+E194	message.txt	/*E194*
+E195	starting.txt	/*E195*
+E196	various.txt	/*E196*
+E197	mlang.txt	/*E197*
+E198	options.txt	/*E198*
+E199	cmdline.txt	/*E199*
+E20	motion.txt	/*E20*
+E200	autocmd.txt	/*E200*
+E201	autocmd.txt	/*E201*
+E202	options.txt	/*E202*
+E203	autocmd.txt	/*E203*
+E204	autocmd.txt	/*E204*
+E205	options.txt	/*E205*
+E206	options.txt	/*E206*
+E207	editing.txt	/*E207*
+E208	message.txt	/*E208*
+E209	message.txt	/*E209*
+E21	options.txt	/*E21*
+E210	message.txt	/*E210*
+E211	message.txt	/*E211*
+E212	message.txt	/*E212*
+E213	options.txt	/*E213*
+E214	options.txt	/*E214*
+E215	autocmd.txt	/*E215*
+E216	autocmd.txt	/*E216*
+E217	autocmd.txt	/*E217*
+E218	autocmd.txt	/*E218*
+E219	message.txt	/*E219*
+E22	message.txt	/*E22*
+E220	message.txt	/*E220*
+E222	message.txt	/*E222*
+E223	options.txt	/*E223*
+E224	map.txt	/*E224*
+E225	map.txt	/*E225*
+E226	map.txt	/*E226*
+E227	map.txt	/*E227*
+E228	message.txt	/*E228*
+E229	gui.txt	/*E229*
+E23	message.txt	/*E23*
+E230	starting.txt	/*E230*
+E231	options.txt	/*E231*
+E232	message.txt	/*E232*
+E233	gui.txt	/*E233*
+E234	options.txt	/*E234*
+E235	options.txt	/*E235*
+E236	options.txt	/*E236*
+E237	print.txt	/*E237*
+E238	print.txt	/*E238*
+E239	sign.txt	/*E239*
+E24	message.txt	/*E24*
+E240	remote.txt	/*E240*
+E241	eval.txt	/*E241*
+E243	if_ole.txt	/*E243*
+E244	options.txt	/*E244*
+E245	options.txt	/*E245*
+E246	autocmd.txt	/*E246*
+E247	remote.txt	/*E247*
+E248	remote.txt	/*E248*
+E25	message.txt	/*E25*
+E250	options.txt	/*E250*
+E251	remote.txt	/*E251*
+E252	options.txt	/*E252*
+E253	mbyte.txt	/*E253*
+E254	message.txt	/*E254*
+E255	sign.txt	/*E255*
+E256	message.txt	/*E256*
+E257	if_cscop.txt	/*E257*
+E258	remote.txt	/*E258*
+E259	if_cscop.txt	/*E259*
+E26	rileft.txt	/*E26*
+E261	if_cscop.txt	/*E261*
+E262	if_cscop.txt	/*E262*
+E263	if_pyth.txt	/*E263*
+E264	if_pyth.txt	/*E264*
+E265	if_ruby.txt	/*E265*
+E266	if_ruby.txt	/*E266*
+E267	if_ruby.txt	/*E267*
+E268	if_ruby.txt	/*E268*
+E269	if_ruby.txt	/*E269*
+E27	farsi.txt	/*E27*
+E270	if_ruby.txt	/*E270*
+E271	if_ruby.txt	/*E271*
+E272	if_ruby.txt	/*E272*
+E273	if_ruby.txt	/*E273*
+E277	remote.txt	/*E277*
+E28	syntax.txt	/*E28*
+E280	if_tcl.txt	/*E280*
+E282	starting.txt	/*E282*
+E283	motion.txt	/*E283*
+E284	mbyte.txt	/*E284*
+E285	mbyte.txt	/*E285*
+E286	mbyte.txt	/*E286*
+E287	mbyte.txt	/*E287*
+E288	mbyte.txt	/*E288*
+E289	mbyte.txt	/*E289*
+E29	change.txt	/*E29*
+E293	message.txt	/*E293*
+E294	message.txt	/*E294*
+E295	message.txt	/*E295*
+E296	message.txt	/*E296*
+E297	message.txt	/*E297*
+E298	message.txt	/*E298*
+E299	if_perl.txt	/*E299*
+E30	change.txt	/*E30*
+E300	message.txt	/*E300*
+E301	message.txt	/*E301*
+E302	message.txt	/*E302*
+E303	message.txt	/*E303*
+E304	message.txt	/*E304*
+E305	recover.txt	/*E305*
+E306	recover.txt	/*E306*
+E307	recover.txt	/*E307*
+E308	recover.txt	/*E308*
+E309	recover.txt	/*E309*
+E31	message.txt	/*E31*
+E310	recover.txt	/*E310*
+E311	recover.txt	/*E311*
+E312	recover.txt	/*E312*
+E313	recover.txt	/*E313*
+E314	recover.txt	/*E314*
+E315	message.txt	/*E315*
+E316	message.txt	/*E316*
+E317	message.txt	/*E317*
+E318	message.txt	/*E318*
+E319	message.txt	/*E319*
+E32	message.txt	/*E32*
+E320	message.txt	/*E320*
+E321	editing.txt	/*E321*
+E322	message.txt	/*E322*
+E323	message.txt	/*E323*
+E324	print.txt	/*E324*
+E325	usr_11.txt	/*E325*
+E326	recover.txt	/*E326*
+E327	gui.txt	/*E327*
+E328	gui.txt	/*E328*
+E329	gui.txt	/*E329*
+E33	message.txt	/*E33*
+E330	gui.txt	/*E330*
+E331	gui.txt	/*E331*
+E332	gui.txt	/*E332*
+E333	gui.txt	/*E333*
+E334	gui.txt	/*E334*
+E335	gui.txt	/*E335*
+E336	gui.txt	/*E336*
+E337	gui.txt	/*E337*
+E338	editing.txt	/*E338*
+E339	message.txt	/*E339*
+E34	various.txt	/*E34*
+E340	vi_diff.txt	/*E340*
+E341	message.txt	/*E341*
+E342	message.txt	/*E342*
+E343	options.txt	/*E343*
+E344	options.txt	/*E344*
+E345	options.txt	/*E345*
+E346	options.txt	/*E346*
+E347	options.txt	/*E347*
+E348	pattern.txt	/*E348*
+E349	pattern.txt	/*E349*
+E35	message.txt	/*E35*
+E350	fold.txt	/*E350*
+E351	fold.txt	/*E351*
+E352	fold.txt	/*E352*
+E353	change.txt	/*E353*
+E354	change.txt	/*E354*
+E355	options.txt	/*E355*
+E356	message.txt	/*E356*
+E357	options.txt	/*E357*
+E358	options.txt	/*E358*
+E359	term.txt	/*E359*
+E36	windows.txt	/*E36*
+E360	various.txt	/*E360*
+E363	options.txt	/*E363*
+E364	eval.txt	/*E364*
+E365	print.txt	/*E365*
+E367	autocmd.txt	/*E367*
+E368	eval.txt	/*E368*
+E369	pattern.txt	/*E369*
+E37	message.txt	/*E37*
+E370	various.txt	/*E370*
+E371	various.txt	/*E371*
+E372	quickfix.txt	/*E372*
+E373	quickfix.txt	/*E373*
+E374	quickfix.txt	/*E374*
+E375	quickfix.txt	/*E375*
+E376	quickfix.txt	/*E376*
+E377	quickfix.txt	/*E377*
+E378	quickfix.txt	/*E378*
+E379	quickfix.txt	/*E379*
+E38	message.txt	/*E38*
+E380	quickfix.txt	/*E380*
+E381	quickfix.txt	/*E381*
+E382	options.txt	/*E382*
+E383	pattern.txt	/*E383*
+E384	options.txt	/*E384*
+E385	options.txt	/*E385*
+E386	pattern.txt	/*E386*
+E387	tagsrch.txt	/*E387*
+E388	tagsrch.txt	/*E388*
+E389	tagsrch.txt	/*E389*
+E39	digraph.txt	/*E39*
+E390	syntax.txt	/*E390*
+E391	syntax.txt	/*E391*
+E392	syntax.txt	/*E392*
+E393	syntax.txt	/*E393*
+E394	syntax.txt	/*E394*
+E395	syntax.txt	/*E395*
+E397	syntax.txt	/*E397*
+E398	syntax.txt	/*E398*
+E399	syntax.txt	/*E399*
+E40	message.txt	/*E40*
+E400	syntax.txt	/*E400*
+E401	syntax.txt	/*E401*
+E402	syntax.txt	/*E402*
+E403	syntax.txt	/*E403*
+E404	syntax.txt	/*E404*
+E405	syntax.txt	/*E405*
+E406	syntax.txt	/*E406*
+E407	syntax.txt	/*E407*
+E408	syntax.txt	/*E408*
+E409	syntax.txt	/*E409*
+E41	message.txt	/*E41*
+E410	syntax.txt	/*E410*
+E411	syntax.txt	/*E411*
+E412	syntax.txt	/*E412*
+E413	syntax.txt	/*E413*
+E414	syntax.txt	/*E414*
+E415	syntax.txt	/*E415*
+E416	syntax.txt	/*E416*
+E417	syntax.txt	/*E417*
+E418	syntax.txt	/*E418*
+E419	syntax.txt	/*E419*
+E42	quickfix.txt	/*E42*
+E420	syntax.txt	/*E420*
+E421	syntax.txt	/*E421*
+E422	syntax.txt	/*E422*
+E423	syntax.txt	/*E423*
+E424	message.txt	/*E424*
+E425	tagsrch.txt	/*E425*
+E426	tagsrch.txt	/*E426*
+E427	tagsrch.txt	/*E427*
+E428	tagsrch.txt	/*E428*
+E429	tagsrch.txt	/*E429*
+E43	message.txt	/*E43*
+E430	tagsrch.txt	/*E430*
+E431	tagsrch.txt	/*E431*
+E432	message.txt	/*E432*
+E433	options.txt	/*E433*
+E434	tagsrch.txt	/*E434*
+E435	tagsrch.txt	/*E435*
+E436	term.txt	/*E436*
+E437	term.txt	/*E437*
+E438	message.txt	/*E438*
+E439	message.txt	/*E439*
+E44	message.txt	/*E44*
+E440	message.txt	/*E440*
+E441	windows.txt	/*E441*
+E442	windows.txt	/*E442*
+E443	windows.txt	/*E443*
+E444	windows.txt	/*E444*
+E445	windows.txt	/*E445*
+E446	editing.txt	/*E446*
+E447	editing.txt	/*E447*
+E448	various.txt	/*E448*
+E449	eval.txt	/*E449*
+E45	message.txt	/*E45*
+E455	print.txt	/*E455*
+E456	print.txt	/*E456*
+E457	print.txt	/*E457*
+E458	message.txt	/*E458*
+E459	message.txt	/*E459*
+E46	message.txt	/*E46*
+E460	message.txt	/*E460*
+E461	eval.txt	/*E461*
+E462	editing.txt	/*E462*
+E463	netbeans.txt	/*E463*
+E464	message.txt	/*E464*
+E465	gui.txt	/*E465*
+E466	gui.txt	/*E466*
+E467	map.txt	/*E467*
+E468	map.txt	/*E468*
+E469	if_cscop.txt	/*E469*
+E47	message.txt	/*E47*
+E470	change.txt	/*E470*
+E471	message.txt	/*E471*
+E472	editing.txt	/*E472*
+E473	message.txt	/*E473*
+E474	message.txt	/*E474*
+E475	message.txt	/*E475*
+E476	pattern.txt	/*E476*
+E477	message.txt	/*E477*
+E478	message.txt	/*E478*
+E479	editing.txt	/*E479*
+E48	eval.txt	/*E48*
+E480	editing.txt	/*E480*
+E481	message.txt	/*E481*
+E482	message.txt	/*E482*
+E483	message.txt	/*E483*
+E484	message.txt	/*E484*
+E485	message.txt	/*E485*
+E486	pattern.txt	/*E486*
+E487	options.txt	/*E487*
+E488	message.txt	/*E488*
+E49	message.txt	/*E49*
+E490	fold.txt	/*E490*
+E492	message.txt	/*E492*
+E493	cmdline.txt	/*E493*
+E494	editing.txt	/*E494*
+E495	cmdline.txt	/*E495*
+E496	cmdline.txt	/*E496*
+E497	cmdline.txt	/*E497*
+E498	cmdline.txt	/*E498*
+E499	cmdline.txt	/*E499*
+E50	syntax.txt	/*E50*
+E500	cmdline.txt	/*E500*
+E501	intro.txt	/*E501*
+E502	editing.txt	/*E502*
+E503	editing.txt	/*E503*
+E504	editing.txt	/*E504*
+E505	editing.txt	/*E505*
+E506	editing.txt	/*E506*
+E507	editing.txt	/*E507*
+E508	editing.txt	/*E508*
+E509	editing.txt	/*E509*
+E51	pattern.txt	/*E51*
+E510	editing.txt	/*E510*
+E511	netbeans.txt	/*E511*
+E512	editing.txt	/*E512*
+E513	options.txt	/*E513*
+E514	editing.txt	/*E514*
+E515	windows.txt	/*E515*
+E516	windows.txt	/*E516*
+E517	windows.txt	/*E517*
+E518	options.txt	/*E518*
+E519	options.txt	/*E519*
+E52	syntax.txt	/*E52*
+E520	options.txt	/*E520*
+E521	options.txt	/*E521*
+E522	options.txt	/*E522*
+E523	options.txt	/*E523*
+E524	options.txt	/*E524*
+E525	options.txt	/*E525*
+E526	options.txt	/*E526*
+E527	options.txt	/*E527*
+E528	options.txt	/*E528*
+E529	options.txt	/*E529*
+E53	pattern.txt	/*E53*
+E530	options.txt	/*E530*
+E531	options.txt	/*E531*
+E532	netbeans.txt	/*E532*
+E533	options.txt	/*E533*
+E534	options.txt	/*E534*
+E535	options.txt	/*E535*
+E536	options.txt	/*E536*
+E537	options.txt	/*E537*
+E538	options.txt	/*E538*
+E539	options.txt	/*E539*
+E54	pattern.txt	/*E54*
+E540	options.txt	/*E540*
+E541	options.txt	/*E541*
+E542	options.txt	/*E542*
+E543	options.txt	/*E543*
+E544	options.txt	/*E544*
+E545	options.txt	/*E545*
+E546	options.txt	/*E546*
+E547	options.txt	/*E547*
+E548	options.txt	/*E548*
+E549	options.txt	/*E549*
+E55	pattern.txt	/*E55*
+E550	options.txt	/*E550*
+E551	options.txt	/*E551*
+E552	options.txt	/*E552*
+E553	quickfix.txt	/*E553*
+E554	pattern.txt	/*E554*
+E555	tagsrch.txt	/*E555*
+E556	tagsrch.txt	/*E556*
+E557	term.txt	/*E557*
+E558	term.txt	/*E558*
+E559	term.txt	/*E559*
+E560	if_cscop.txt	/*E560*
+E561	if_cscop.txt	/*E561*
+E562	if_cscop.txt	/*E562*
+E563	if_cscop.txt	/*E563*
+E564	if_cscop.txt	/*E564*
+E566	if_cscop.txt	/*E566*
+E567	if_cscop.txt	/*E567*
+E568	if_cscop.txt	/*E568*
+E570	message.txt	/*E570*
+E571	if_tcl.txt	/*E571*
+E572	if_tcl.txt	/*E572*
+E573	remote.txt	/*E573*
+E574	starting.txt	/*E574*
+E575	starting.txt	/*E575*
+E576	starting.txt	/*E576*
+E577	starting.txt	/*E577*
+E579	eval.txt	/*E579*
+E580	eval.txt	/*E580*
+E581	eval.txt	/*E581*
+E582	eval.txt	/*E582*
+E583	eval.txt	/*E583*
+E584	eval.txt	/*E584*
+E585	eval.txt	/*E585*
+E586	eval.txt	/*E586*
+E587	eval.txt	/*E587*
+E588	eval.txt	/*E588*
+E589	options.txt	/*E589*
+E59	pattern.txt	/*E59*
+E590	options.txt	/*E590*
+E591	options.txt	/*E591*
+E592	options.txt	/*E592*
+E593	options.txt	/*E593*
+E594	options.txt	/*E594*
+E595	options.txt	/*E595*
+E596	options.txt	/*E596*
+E597	options.txt	/*E597*
+E598	options.txt	/*E598*
+E599	options.txt	/*E599*
+E60	pattern.txt	/*E60*
+E600	eval.txt	/*E600*
+E601	eval.txt	/*E601*
+E602	eval.txt	/*E602*
+E603	eval.txt	/*E603*
+E604	eval.txt	/*E604*
+E605	eval.txt	/*E605*
+E606	eval.txt	/*E606*
+E607	eval.txt	/*E607*
+E608	eval.txt	/*E608*
+E609	if_cscop.txt	/*E609*
+E61	pattern.txt	/*E61*
+E612	sign.txt	/*E612*
+E613	print.txt	/*E613*
+E614	editing.txt	/*E614*
+E615	editing.txt	/*E615*
+E616	editing.txt	/*E616*
+E617	options.txt	/*E617*
+E618	print.txt	/*E618*
+E619	print.txt	/*E619*
+E62	pattern.txt	/*E62*
+E620	print.txt	/*E620*
+E621	print.txt	/*E621*
+E622	if_cscop.txt	/*E622*
+E623	if_cscop.txt	/*E623*
+E624	print.txt	/*E624*
+E625	if_cscop.txt	/*E625*
+E626	if_cscop.txt	/*E626*
+E627	netbeans.txt	/*E627*
+E628	netbeans.txt	/*E628*
+E629	netbeans.txt	/*E629*
+E63	pattern.txt	/*E63*
+E630	channel.txt	/*E630*
+E631	channel.txt	/*E631*
+E632	netbeans.txt	/*E632*
+E633	netbeans.txt	/*E633*
+E634	netbeans.txt	/*E634*
+E635	netbeans.txt	/*E635*
+E636	netbeans.txt	/*E636*
+E637	netbeans.txt	/*E637*
+E638	netbeans.txt	/*E638*
+E639	netbeans.txt	/*E639*
+E64	pattern.txt	/*E64*
+E640	netbeans.txt	/*E640*
+E641	netbeans.txt	/*E641*
+E642	netbeans.txt	/*E642*
+E643	netbeans.txt	/*E643*
+E644	netbeans.txt	/*E644*
+E645	netbeans.txt	/*E645*
+E646	netbeans.txt	/*E646*
+E647	netbeans.txt	/*E647*
+E648	netbeans.txt	/*E648*
+E649	netbeans.txt	/*E649*
+E65	pattern.txt	/*E65*
+E650	netbeans.txt	/*E650*
+E651	netbeans.txt	/*E651*
+E652	netbeans.txt	/*E652*
+E655	eval.txt	/*E655*
+E656	netbeans.txt	/*E656*
+E657	netbeans.txt	/*E657*
+E658	netbeans.txt	/*E658*
+E659	if_pyth.txt	/*E659*
+E66	syntax.txt	/*E66*
+E660	netbeans.txt	/*E660*
+E661	helphelp.txt	/*E661*
+E662	motion.txt	/*E662*
+E663	motion.txt	/*E663*
+E664	motion.txt	/*E664*
+E665	gui_x11.txt	/*E665*
+E666	quickfix.txt	/*E666*
+E667	editing.txt	/*E667*
+E668	netbeans.txt	/*E668*
+E669	syntax.txt	/*E669*
+E67	syntax.txt	/*E67*
+E670	helphelp.txt	/*E670*
+E671	starting.txt	/*E671*
+E672	starting.txt	/*E672*
+E673	print.txt	/*E673*
+E674	print.txt	/*E674*
+E675	print.txt	/*E675*
+E676	options.txt	/*E676*
+E677	eval.txt	/*E677*
+E678	pattern.txt	/*E678*
+E679	syntax.txt	/*E679*
+E68	pattern.txt	/*E68*
+E680	autocmd.txt	/*E680*
+E681	quickfix.txt	/*E681*
+E682	quickfix.txt	/*E682*
+E683	quickfix.txt	/*E683*
+E684	eval.txt	/*E684*
+E685	message.txt	/*E685*
+E686	eval.txt	/*E686*
+E687	eval.txt	/*E687*
+E688	eval.txt	/*E688*
+E689	eval.txt	/*E689*
+E69	pattern.txt	/*E69*
+E690	eval.txt	/*E690*
+E691	eval.txt	/*E691*
+E692	eval.txt	/*E692*
+E694	eval.txt	/*E694*
+E695	eval.txt	/*E695*
+E696	eval.txt	/*E696*
+E697	eval.txt	/*E697*
+E698	eval.txt	/*E698*
+E699	eval.txt	/*E699*
+E70	pattern.txt	/*E70*
+E700	eval.txt	/*E700*
+E701	eval.txt	/*E701*
+E702	eval.txt	/*E702*
+E703	eval.txt	/*E703*
+E704	eval.txt	/*E704*
+E705	eval.txt	/*E705*
+E707	eval.txt	/*E707*
+E708	eval.txt	/*E708*
+E709	eval.txt	/*E709*
+E71	pattern.txt	/*E71*
+E710	eval.txt	/*E710*
+E711	eval.txt	/*E711*
+E712	eval.txt	/*E712*
+E713	eval.txt	/*E713*
+E714	eval.txt	/*E714*
+E715	eval.txt	/*E715*
+E716	eval.txt	/*E716*
+E717	eval.txt	/*E717*
+E718	eval.txt	/*E718*
+E719	eval.txt	/*E719*
+E72	message.txt	/*E72*
+E720	eval.txt	/*E720*
+E721	eval.txt	/*E721*
+E722	eval.txt	/*E722*
+E723	eval.txt	/*E723*
+E724	eval.txt	/*E724*
+E725	eval.txt	/*E725*
+E726	eval.txt	/*E726*
+E727	eval.txt	/*E727*
+E728	eval.txt	/*E728*
+E729	eval.txt	/*E729*
+E73	tagsrch.txt	/*E73*
+E730	eval.txt	/*E730*
+E731	eval.txt	/*E731*
+E732	eval.txt	/*E732*
+E733	eval.txt	/*E733*
+E734	eval.txt	/*E734*
+E735	eval.txt	/*E735*
+E736	eval.txt	/*E736*
+E737	eval.txt	/*E737*
+E738	eval.txt	/*E738*
+E739	eval.txt	/*E739*
+E74	message.txt	/*E74*
+E740	eval.txt	/*E740*
+E741	eval.txt	/*E741*
+E742	eval.txt	/*E742*
+E743	eval.txt	/*E743*
+E744	netbeans.txt	/*E744*
+E745	eval.txt	/*E745*
+E746	eval.txt	/*E746*
+E747	editing.txt	/*E747*
+E748	repeat.txt	/*E748*
+E749	various.txt	/*E749*
+E75	vi_diff.txt	/*E75*
+E750	repeat.txt	/*E750*
+E751	spell.txt	/*E751*
+E752	spell.txt	/*E752*
+E753	spell.txt	/*E753*
+E754	spell.txt	/*E754*
+E755	spell.txt	/*E755*
+E756	spell.txt	/*E756*
+E757	options.txt	/*E757*
+E758	spell.txt	/*E758*
+E759	spell.txt	/*E759*
+E76	pattern.txt	/*E76*
+E760	spell.txt	/*E760*
+E761	spell.txt	/*E761*
+E762	spell.txt	/*E762*
+E763	spell.txt	/*E763*
+E764	options.txt	/*E764*
+E765	options.txt	/*E765*
+E766	eval.txt	/*E766*
+E767	eval.txt	/*E767*
+E768	message.txt	/*E768*
+E769	pattern.txt	/*E769*
+E77	message.txt	/*E77*
+E770	spell.txt	/*E770*
+E771	spell.txt	/*E771*
+E772	spell.txt	/*E772*
+E773	recover.txt	/*E773*
+E774	map.txt	/*E774*
+E775	map.txt	/*E775*
+E776	quickfix.txt	/*E776*
+E777	quickfix.txt	/*E777*
+E778	spell.txt	/*E778*
+E779	spell.txt	/*E779*
+E78	motion.txt	/*E78*
+E780	spell.txt	/*E780*
+E781	spell.txt	/*E781*
+E782	spell.txt	/*E782*
+E783	spell.txt	/*E783*
+E784	tabpage.txt	/*E784*
+E785	eval.txt	/*E785*
+E786	eval.txt	/*E786*
+E787	diff.txt	/*E787*
+E788	autocmd.txt	/*E788*
+E789	syntax.txt	/*E789*
+E79	message.txt	/*E79*
+E790	undo.txt	/*E790*
+E791	mbyte.txt	/*E791*
+E792	gui.txt	/*E792*
+E793	diff.txt	/*E793*
+E794	eval.txt	/*E794*
+E795	eval.txt	/*E795*
+E796	editing.txt	/*E796*
+E797	spell.txt	/*E797*
+E798	eval.txt	/*E798*
+E799	eval.txt	/*E799*
+E80	message.txt	/*E80*
+E800	arabic.txt	/*E800*
+E801	eval.txt	/*E801*
+E802	eval.txt	/*E802*
+E803	eval.txt	/*E803*
+E804	eval.txt	/*E804*
+E805	eval.txt	/*E805*
+E806	eval.txt	/*E806*
+E807	eval.txt	/*E807*
+E808	eval.txt	/*E808*
+E809	cmdline.txt	/*E809*
+E81	map.txt	/*E81*
+E810	diff.txt	/*E810*
+E811	autocmd.txt	/*E811*
+E812	autocmd.txt	/*E812*
+E813	editing.txt	/*E813*
+E814	editing.txt	/*E814*
+E815	if_mzsch.txt	/*E815*
+E816	diff.txt	/*E816*
+E817	editing.txt	/*E817*
+E818	editing.txt	/*E818*
+E819	editing.txt	/*E819*
+E82	message.txt	/*E82*
+E820	editing.txt	/*E820*
+E821	options.txt	/*E821*
+E822	undo.txt	/*E822*
+E823	undo.txt	/*E823*
+E824	undo.txt	/*E824*
+E825	undo.txt	/*E825*
+E826	undo.txt	/*E826*
+E827	undo.txt	/*E827*
+E828	undo.txt	/*E828*
+E829	undo.txt	/*E829*
+E83	message.txt	/*E83*
+E830	undo.txt	/*E830*
+E831	editing.txt	/*E831*
+E832	undo.txt	/*E832*
+E833	editing.txt	/*E833*
+E834	options.txt	/*E834*
+E835	options.txt	/*E835*
+E836	if_pyth.txt	/*E836*
+E837	if_pyth.txt	/*E837*
+E838	netbeans.txt	/*E838*
+E839	insert.txt	/*E839*
+E84	windows.txt	/*E84*
+E840	insert.txt	/*E840*
+E841	map.txt	/*E841*
+E842	cmdline.txt	/*E842*
+E843	editing.txt	/*E843*
+E844	syntax.txt	/*E844*
+E845	spell.txt	/*E845*
+E846	options.txt	/*E846*
+E847	syntax.txt	/*E847*
+E848	syntax.txt	/*E848*
+E849	syntax.txt	/*E849*
+E85	options.txt	/*E85*
+E850	change.txt	/*E850*
+E851	gui_x11.txt	/*E851*
+E852	gui_x11.txt	/*E852*
+E853	eval.txt	/*E853*
+E854	options.txt	/*E854*
+E855	autocmd.txt	/*E855*
+E858	eval.txt	/*E858*
+E859	eval.txt	/*E859*
+E86	windows.txt	/*E86*
+E862	eval.txt	/*E862*
+E864	pattern.txt	/*E864*
+E865	pattern.txt	/*E865*
+E866	pattern.txt	/*E866*
+E867	pattern.txt	/*E867*
+E868	pattern.txt	/*E868*
+E869	pattern.txt	/*E869*
+E87	windows.txt	/*E87*
+E870	pattern.txt	/*E870*
+E871	pattern.txt	/*E871*
+E872	pattern.txt	/*E872*
+E873	pattern.txt	/*E873*
+E874	pattern.txt	/*E874*
+E875	pattern.txt	/*E875*
+E876	pattern.txt	/*E876*
+E877	pattern.txt	/*E877*
+E878	pattern.txt	/*E878*
+E879	syntax.txt	/*E879*
+E88	windows.txt	/*E88*
+E880	if_pyth.txt	/*E880*
+E881	autocmd.txt	/*E881*
+E882	eval.txt	/*E882*
+E883	eval.txt	/*E883*
+E884	eval.txt	/*E884*
+E885	sign.txt	/*E885*
+E886	starting.txt	/*E886*
+E887	if_pyth.txt	/*E887*
+E888	pattern.txt	/*E888*
+E89	message.txt	/*E89*
+E890	syntax.txt	/*E890*
+E891	eval.txt	/*E891*
+E892	eval.txt	/*E892*
+E893	eval.txt	/*E893*
+E894	eval.txt	/*E894*
+E895	if_mzsch.txt	/*E895*
+E898	channel.txt	/*E898*
+E90	message.txt	/*E90*
+E901	channel.txt	/*E901*
+E902	channel.txt	/*E902*
+E903	channel.txt	/*E903*
+E904	channel.txt	/*E904*
+E905	channel.txt	/*E905*
+E906	channel.txt	/*E906*
+E907	eval.txt	/*E907*
+E908	eval.txt	/*E908*
+E909	eval.txt	/*E909*
+E91	options.txt	/*E91*
+E910	eval.txt	/*E910*
+E911	eval.txt	/*E911*
+E912	eval.txt	/*E912*
+E913	eval.txt	/*E913*
+E914	eval.txt	/*E914*
+E915	channel.txt	/*E915*
+E916	eval.txt	/*E916*
+E917	eval.txt	/*E917*
+E918	channel.txt	/*E918*
+E919	repeat.txt	/*E919*
+E92	message.txt	/*E92*
+E920	channel.txt	/*E920*
+E921	channel.txt	/*E921*
+E922	eval.txt	/*E922*
+E923	eval.txt	/*E923*
+E924	quickfix.txt	/*E924*
+E925	quickfix.txt	/*E925*
+E926	quickfix.txt	/*E926*
+E927	eval.txt	/*E927*
+E928	eval.txt	/*E928*
+E929	starting.txt	/*E929*
+E93	windows.txt	/*E93*
+E930	eval.txt	/*E930*
+E931	message.txt	/*E931*
+E932	eval.txt	/*E932*
+E933	eval.txt	/*E933*
+E934	sign.txt	/*E934*
+E935	eval.txt	/*E935*
+E936	autocmd.txt	/*E936*
+E937	autocmd.txt	/*E937*
+E938	eval.txt	/*E938*
+E939	change.txt	/*E939*
+E94	windows.txt	/*E94*
+E940	eval.txt	/*E940*
+E941	eval.txt	/*E941*
+E942	eval.txt	/*E942*
+E943	message.txt	/*E943*
+E944	pattern.txt	/*E944*
+E945	pattern.txt	/*E945*
+E946	terminal.txt	/*E946*
+E947	terminal.txt	/*E947*
+E948	terminal.txt	/*E948*
+E949	editing.txt	/*E949*
+E95	message.txt	/*E95*
+E950	message.txt	/*E950*
+E951	pattern.txt	/*E951*
+E952	autocmd.txt	/*E952*
+E953	eval.txt	/*E953*
+E954	options.txt	/*E954*
+E955	eval.txt	/*E955*
+E956	pattern.txt	/*E956*
+E957	eval.txt	/*E957*
+E96	diff.txt	/*E96*
+E97	diff.txt	/*E97*
+E98	diff.txt	/*E98*
+E99	diff.txt	/*E99*
+EX	intro.txt	/*EX*
+EXINIT	starting.txt	/*EXINIT*
+Elvis	intro.txt	/*Elvis*
+EncodingChanged	autocmd.txt	/*EncodingChanged*
+Eterm	syntax.txt	/*Eterm*
+Ex	intro.txt	/*Ex*
+Ex-mode	intro.txt	/*Ex-mode*
+ExitPre	autocmd.txt	/*ExitPre*
+Exuberant_ctags	tagsrch.txt	/*Exuberant_ctags*
+F	motion.txt	/*F*
+FALSE	eval.txt	/*FALSE*
+FAQ	intro.txt	/*FAQ*
+Farsi	farsi.txt	/*Farsi*
+FileAppendCmd	autocmd.txt	/*FileAppendCmd*
+FileAppendPost	autocmd.txt	/*FileAppendPost*
+FileAppendPre	autocmd.txt	/*FileAppendPre*
+FileChangedRO	autocmd.txt	/*FileChangedRO*
+FileChangedShell	autocmd.txt	/*FileChangedShell*
+FileChangedShellPost	autocmd.txt	/*FileChangedShellPost*
+FileEncoding	autocmd.txt	/*FileEncoding*
+FileReadCmd	autocmd.txt	/*FileReadCmd*
+FileReadPost	autocmd.txt	/*FileReadPost*
+FileReadPre	autocmd.txt	/*FileReadPre*
+FileType	autocmd.txt	/*FileType*
+FileWriteCmd	autocmd.txt	/*FileWriteCmd*
+FileWritePost	autocmd.txt	/*FileWritePost*
+FileWritePre	autocmd.txt	/*FileWritePre*
+FilterReadPost	autocmd.txt	/*FilterReadPost*
+FilterReadPre	autocmd.txt	/*FilterReadPre*
+FilterWritePost	autocmd.txt	/*FilterWritePost*
+FilterWritePre	autocmd.txt	/*FilterWritePre*
+Float	eval.txt	/*Float*
+FocusGained	autocmd.txt	/*FocusGained*
+FocusLost	autocmd.txt	/*FocusLost*
+Folding	fold.txt	/*Folding*
+FuncUndefined	autocmd.txt	/*FuncUndefined*
+Funcref	eval.txt	/*Funcref*
+G	motion.txt	/*G*
+GNOME	gui_x11.txt	/*GNOME*
+GTK	gui_x11.txt	/*GTK*
+GTK+	gui_x11.txt	/*GTK+*
+GTK3	gui_x11.txt	/*GTK3*
+GUI	gui.txt	/*GUI*
+GUI-X11	gui_x11.txt	/*GUI-X11*
+GUIEnter	autocmd.txt	/*GUIEnter*
+GUIFailed	autocmd.txt	/*GUIFailed*
+GetLatestVimScripts	pi_getscript.txt	/*GetLatestVimScripts*
+GetLatestVimScripts-copyright	pi_getscript.txt	/*GetLatestVimScripts-copyright*
+GetLatestVimScripts_dat	pi_getscript.txt	/*GetLatestVimScripts_dat*
+Gnome	gui_x11.txt	/*Gnome*
+H	motion.txt	/*H*
+I	insert.txt	/*I*
+ICCF	uganda.txt	/*ICCF*
+IM-server	mbyte.txt	/*IM-server*
+IME	mbyte.txt	/*IME*
+Insert	insert.txt	/*Insert*
+Insert-mode	insert.txt	/*Insert-mode*
+InsertChange	autocmd.txt	/*InsertChange*
+InsertCharPre	autocmd.txt	/*InsertCharPre*
+InsertEnter	autocmd.txt	/*InsertEnter*
+InsertLeave	autocmd.txt	/*InsertLeave*
+J	change.txt	/*J*
+Japanese	mbyte.txt	/*Japanese*
+Job	eval.txt	/*Job*
+Jobs	eval.txt	/*Jobs*
+K	various.txt	/*K*
+KDE	gui_x11.txt	/*KDE*
+KVim	gui_x11.txt	/*KVim*
+Kibaale	uganda.txt	/*Kibaale*
+Korean	mbyte.txt	/*Korean*
+L	motion.txt	/*L*
+Linux-backspace	options.txt	/*Linux-backspace*
+List	eval.txt	/*List*
+Lists	eval.txt	/*Lists*
+LogiPat()	pi_logipat.txt	/*LogiPat()*
+LogiPat-flags	pi_logipat.txt	/*LogiPat-flags*
+Lua	if_lua.txt	/*Lua*
+M	motion.txt	/*M*
+MDI	starting.txt	/*MDI*
+MS-DOS	os_msdos.txt	/*MS-DOS*
+MS-Windows	os_win32.txt	/*MS-Windows*
+MSDOS	os_msdos.txt	/*MSDOS*
+MSVisualStudio	if_ole.txt	/*MSVisualStudio*
+MVS	os_390.txt	/*MVS*
+Mac	os_mac.txt	/*Mac*
+Mac-format	editing.txt	/*Mac-format*
+Mac-format-write	editing.txt	/*Mac-format-write*
+Macintosh	os_mac.txt	/*Macintosh*
+Mark	motion.txt	/*Mark*
+MenuPopup	autocmd.txt	/*MenuPopup*
+MiNT	os_mint.txt	/*MiNT*
+Moolenaar	intro.txt	/*Moolenaar*
+MorphOS	os_amiga.txt	/*MorphOS*
+Motif	gui_x11.txt	/*Motif*
+Myspell	spell.txt	/*Myspell*
+MzScheme	if_mzsch.txt	/*MzScheme*
+N	pattern.txt	/*N*
+N%	motion.txt	/*N%*
+N:	cmdline.txt	/*N:*
+N<Del>	various.txt	/*N<Del>*
+NFA	pattern.txt	/*NFA*
+NL-used-for-Nul	pattern.txt	/*NL-used-for-Nul*
+NetBSD-backspace	options.txt	/*NetBSD-backspace*
+NetUserPass()	pi_netrw.txt	/*NetUserPass()*
+Normal	intro.txt	/*Normal*
+Normal-mode	intro.txt	/*Normal-mode*
+Number	eval.txt	/*Number*
+Nvi	intro.txt	/*Nvi*
+O	insert.txt	/*O*
+OS/2	os_os2.txt	/*OS\/2*
+OS2	os_os2.txt	/*OS2*
+OS390	os_390.txt	/*OS390*
+OS390-Motif	os_390.txt	/*OS390-Motif*
+OS390-PuTTY	os_390.txt	/*OS390-PuTTY*
+OS390-bugs	os_390.txt	/*OS390-bugs*
+OS390-has-ebcdic	os_390.txt	/*OS390-has-ebcdic*
+OS390-limitations	os_390.txt	/*OS390-limitations*
+OS390-open-source	os_390.txt	/*OS390-open-source*
+OffTheSpot	mbyte.txt	/*OffTheSpot*
+OnTheSpot	mbyte.txt	/*OnTheSpot*
+Operator-pending	intro.txt	/*Operator-pending*
+Operator-pending-mode	intro.txt	/*Operator-pending-mode*
+OptionSet	autocmd.txt	/*OptionSet*
+OverTheSpot	mbyte.txt	/*OverTheSpot*
+P	change.txt	/*P*
+PATHEXT	eval.txt	/*PATHEXT*
+PEP8	filetype.txt	/*PEP8*
+PHP_BracesAtCodeLevel	indent.txt	/*PHP_BracesAtCodeLevel*
+PHP_autoformatcomment	indent.txt	/*PHP_autoformatcomment*
+PHP_default_indenting	indent.txt	/*PHP_default_indenting*
+PHP_noArrowMatching	indent.txt	/*PHP_noArrowMatching*
+PHP_outdentSLComments	indent.txt	/*PHP_outdentSLComments*
+PHP_outdentphpescape	indent.txt	/*PHP_outdentphpescape*
+PHP_removeCRwhenUnix	indent.txt	/*PHP_removeCRwhenUnix*
+PHP_vintage_case_default_indent	indent.txt	/*PHP_vintage_case_default_indent*
+Partial	eval.txt	/*Partial*
+Pattern	pattern.txt	/*Pattern*
+Perl	if_perl.txt	/*Perl*
+Posix	intro.txt	/*Posix*
+Python	if_pyth.txt	/*Python*
+Q	intro.txt	/*Q*
+Q-command-changed	version5.txt	/*Q-command-changed*
+QNX	os_qnx.txt	/*QNX*
+Q_ab	quickref.txt	/*Q_ab*
+Q_ac	quickref.txt	/*Q_ac*
+Q_ai	quickref.txt	/*Q_ai*
+Q_bu	quickref.txt	/*Q_bu*
+Q_ce	quickref.txt	/*Q_ce*
+Q_ch	quickref.txt	/*Q_ch*
+Q_cm	quickref.txt	/*Q_cm*
+Q_co	quickref.txt	/*Q_co*
+Q_ct	help.txt	/*Q_ct*
+Q_de	quickref.txt	/*Q_de*
+Q_di	quickref.txt	/*Q_di*
+Q_ed	quickref.txt	/*Q_ed*
+Q_et	quickref.txt	/*Q_et*
+Q_ex	quickref.txt	/*Q_ex*
+Q_fl	quickref.txt	/*Q_fl*
+Q_fo	quickref.txt	/*Q_fo*
+Q_gu	quickref.txt	/*Q_gu*
+Q_in	quickref.txt	/*Q_in*
+Q_km	quickref.txt	/*Q_km*
+Q_lr	quickref.txt	/*Q_lr*
+Q_ma	quickref.txt	/*Q_ma*
+Q_op	quickref.txt	/*Q_op*
+Q_pa	quickref.txt	/*Q_pa*
+Q_qf	quickref.txt	/*Q_qf*
+Q_ra	quickref.txt	/*Q_ra*
+Q_re	quickref.txt	/*Q_re*
+Q_sc	quickref.txt	/*Q_sc*
+Q_si	quickref.txt	/*Q_si*
+Q_ss	quickref.txt	/*Q_ss*
+Q_st	quickref.txt	/*Q_st*
+Q_sy	quickref.txt	/*Q_sy*
+Q_ta	quickref.txt	/*Q_ta*
+Q_tm	quickref.txt	/*Q_tm*
+Q_to	quickref.txt	/*Q_to*
+Q_ud	quickref.txt	/*Q_ud*
+Q_ur	quickref.txt	/*Q_ur*
+Q_vc	quickref.txt	/*Q_vc*
+Q_vi	quickref.txt	/*Q_vi*
+Q_vm	quickref.txt	/*Q_vm*
+Q_wi	quickref.txt	/*Q_wi*
+Q_wq	quickref.txt	/*Q_wq*
+QuickFixCmdPost	autocmd.txt	/*QuickFixCmdPost*
+QuickFixCmdPost-example	quickfix.txt	/*QuickFixCmdPost-example*
+QuickFixCmdPre	autocmd.txt	/*QuickFixCmdPre*
+Quickfix	quickfix.txt	/*Quickfix*
+QuitPre	autocmd.txt	/*QuitPre*
+R	change.txt	/*R*
+RISC-OS	os_risc.txt	/*RISC-OS*
+RISCOS	os_risc.txt	/*RISCOS*
+RemoteReply	autocmd.txt	/*RemoteReply*
+Replace	insert.txt	/*Replace*
+Replace-mode	insert.txt	/*Replace-mode*
+Root	mbyte.txt	/*Root*
+Ruby	if_ruby.txt	/*Ruby*
+Russian	russian.txt	/*Russian*
+S	change.txt	/*S*
+SHELL	starting.txt	/*SHELL*
+SQLGetType	ft_sql.txt	/*SQLGetType*
+SQLSetType	ft_sql.txt	/*SQLSetType*
+Select	visual.txt	/*Select*
+Select-mode	visual.txt	/*Select-mode*
+Select-mode-mapping	visual.txt	/*Select-mode-mapping*
+Session	starting.txt	/*Session*
+SessionLoad-variable	starting.txt	/*SessionLoad-variable*
+SessionLoadPost	autocmd.txt	/*SessionLoadPost*
+ShellCmdPost	autocmd.txt	/*ShellCmdPost*
+ShellFilterPost	autocmd.txt	/*ShellFilterPost*
+SourceCmd	autocmd.txt	/*SourceCmd*
+SourcePre	autocmd.txt	/*SourcePre*
+Special	eval.txt	/*Special*
+SpellFileMissing	autocmd.txt	/*SpellFileMissing*
+StdinReadPost	autocmd.txt	/*StdinReadPost*
+StdinReadPre	autocmd.txt	/*StdinReadPre*
+String	eval.txt	/*String*
+SwapExists	autocmd.txt	/*SwapExists*
+Syntax	autocmd.txt	/*Syntax*
+T	motion.txt	/*T*
+TCL	if_tcl.txt	/*TCL*
+TERM	starting.txt	/*TERM*
+TOhtml-encoding	syntax.txt	/*TOhtml-encoding*
+TOhtml-encoding-detect	syntax.txt	/*TOhtml-encoding-detect*
+TOhtml-performance	syntax.txt	/*TOhtml-performance*
+TOhtml-uncopyable-text	syntax.txt	/*TOhtml-uncopyable-text*
+TOhtml-wrap-text	syntax.txt	/*TOhtml-wrap-text*
+TRUE	eval.txt	/*TRUE*
+TSQL	ft_sql.txt	/*TSQL*
+TTpro-telnet	syntax.txt	/*TTpro-telnet*
+Tab	intro.txt	/*Tab*
+TabClosed	autocmd.txt	/*TabClosed*
+TabEnter	autocmd.txt	/*TabEnter*
+TabLeave	autocmd.txt	/*TabLeave*
+TabNew	autocmd.txt	/*TabNew*
+Tcl	if_tcl.txt	/*Tcl*
+TermChanged	autocmd.txt	/*TermChanged*
+TermResponse	autocmd.txt	/*TermResponse*
+Terminal-Job	terminal.txt	/*Terminal-Job*
+Terminal-Normal	terminal.txt	/*Terminal-Normal*
+Terminal-mode	terminal.txt	/*Terminal-mode*
+TerminalOpen	autocmd.txt	/*TerminalOpen*
+TextChanged	autocmd.txt	/*TextChanged*
+TextChangedI	autocmd.txt	/*TextChangedI*
+TextChangedP	autocmd.txt	/*TextChangedP*
+TextYankPost	autocmd.txt	/*TextYankPost*
+Transact-SQL	ft_sql.txt	/*Transact-SQL*
+U	undo.txt	/*U*
+UTF-8	mbyte.txt	/*UTF-8*
+UTF8-xterm	mbyte.txt	/*UTF8-xterm*
+Uganda	uganda.txt	/*Uganda*
+Unicode	mbyte.txt	/*Unicode*
+Unix	os_unix.txt	/*Unix*
+Unix-format	editing.txt	/*Unix-format*
+Unix-format-write	editing.txt	/*Unix-format-write*
+User	autocmd.txt	/*User*
+UserGettingBored	autocmd.txt	/*UserGettingBored*
+V	visual.txt	/*V*
+VIMINIT	starting.txt	/*VIMINIT*
+VMS	os_vms.txt	/*VMS*
+Vi	intro.txt	/*Vi*
+View	starting.txt	/*View*
+VimEnter	autocmd.txt	/*VimEnter*
+VimLeave	autocmd.txt	/*VimLeave*
+VimLeavePre	autocmd.txt	/*VimLeavePre*
+VimResized	autocmd.txt	/*VimResized*
+Vimball-copyright	pi_vimball.txt	/*Vimball-copyright*
+Virtual-Replace-mode	insert.txt	/*Virtual-Replace-mode*
+VisVim	if_ole.txt	/*VisVim*
+Visual	visual.txt	/*Visual*
+Visual-mode	visual.txt	/*Visual-mode*
+W	motion.txt	/*W*
+W10	message.txt	/*W10*
+W11	message.txt	/*W11*
+W12	message.txt	/*W12*
+W13	message.txt	/*W13*
+W14	message.txt	/*W14*
+W15	repeat.txt	/*W15*
+W16	message.txt	/*W16*
+W17	arabic.txt	/*W17*
+W18	syntax.txt	/*W18*
+W19	autocmd.txt	/*W19*
+W20	if_pyth.txt	/*W20*
+W21	if_pyth.txt	/*W21*
+W22	eval.txt	/*W22*
+WORD	motion.txt	/*WORD*
+WWW	intro.txt	/*WWW*
+Win32	os_win32.txt	/*Win32*
+WinBar	gui.txt	/*WinBar*
+WinEnter	autocmd.txt	/*WinEnter*
+WinLeave	autocmd.txt	/*WinLeave*
+WinNew	autocmd.txt	/*WinNew*
+X	change.txt	/*X*
+X11	options.txt	/*X11*
+X11-icon	gui_x11.txt	/*X11-icon*
+X11_mouse_shapes	gui_x11.txt	/*X11_mouse_shapes*
+X1Drag	term.txt	/*X1Drag*
+X1Mouse	term.txt	/*X1Mouse*
+X1Release	term.txt	/*X1Release*
+X2Drag	term.txt	/*X2Drag*
+X2Mouse	term.txt	/*X2Mouse*
+X2Release	term.txt	/*X2Release*
+XIM	mbyte.txt	/*XIM*
+XLFD	mbyte.txt	/*XLFD*
+Y	change.txt	/*Y*
+Y2K	intro.txt	/*Y2K*
+ZQ	editing.txt	/*ZQ*
+ZZ	editing.txt	/*ZZ*
+[	index.txt	/*[*
+[#	motion.txt	/*[#*
+['	motion.txt	/*['*
+[(	motion.txt	/*[(*
+[++opt]	editing.txt	/*[++opt]*
+[+cmd]	editing.txt	/*[+cmd]*
+[..]	pattern.txt	/*[..]*
+[/	motion.txt	/*[\/*
+[:alnum:]	pattern.txt	/*[:alnum:]*
+[:alpha:]	pattern.txt	/*[:alpha:]*
+[:backspace:]	pattern.txt	/*[:backspace:]*
+[:blank:]	pattern.txt	/*[:blank:]*
+[:cntrl:]	pattern.txt	/*[:cntrl:]*
+[:digit:]	pattern.txt	/*[:digit:]*
+[:escape:]	pattern.txt	/*[:escape:]*
+[:graph:]	pattern.txt	/*[:graph:]*
+[:lower:]	pattern.txt	/*[:lower:]*
+[:print:]	pattern.txt	/*[:print:]*
+[:punct:]	pattern.txt	/*[:punct:]*
+[:return:]	pattern.txt	/*[:return:]*
+[:space:]	pattern.txt	/*[:space:]*
+[:tab:]	pattern.txt	/*[:tab:]*
+[:upper:]	pattern.txt	/*[:upper:]*
+[:xdigit:]	pattern.txt	/*[:xdigit:]*
+[<MiddleMouse>	change.txt	/*[<MiddleMouse>*
+[==]	pattern.txt	/*[==]*
+[D	tagsrch.txt	/*[D*
+[I	tagsrch.txt	/*[I*
+[M	motion.txt	/*[M*
+[P	change.txt	/*[P*
+[S	spell.txt	/*[S*
+[[	motion.txt	/*[[*
+[]	motion.txt	/*[]*
+[_CTRL-D	tagsrch.txt	/*[_CTRL-D*
+[_CTRL-I	tagsrch.txt	/*[_CTRL-I*
+[`	motion.txt	/*[`*
+[c	diff.txt	/*[c*
+[count]	intro.txt	/*[count]*
+[d	tagsrch.txt	/*[d*
+[f	editing.txt	/*[f*
+[i	tagsrch.txt	/*[i*
+[m	motion.txt	/*[m*
+[p	change.txt	/*[p*
+[pattern]	pattern.txt	/*[pattern]*
+[quotex]	intro.txt	/*[quotex]*
+[range]	cmdline.txt	/*[range]*
+[s	spell.txt	/*[s*
+[star	motion.txt	/*[star*
+[z	fold.txt	/*[z*
+[{	motion.txt	/*[{*
+\0	change.txt	/*\\0*
+]	index.txt	/*]*
+]#	motion.txt	/*]#*
+]'	motion.txt	/*]'*
+])	motion.txt	/*])*
+]/	motion.txt	/*]\/*
+]<MiddleMouse>	change.txt	/*]<MiddleMouse>*
+]D	tagsrch.txt	/*]D*
+]I	tagsrch.txt	/*]I*
+]M	motion.txt	/*]M*
+]P	change.txt	/*]P*
+]S	spell.txt	/*]S*
+][	motion.txt	/*][*
+]]	motion.txt	/*]]*
+]_CTRL-D	tagsrch.txt	/*]_CTRL-D*
+]_CTRL-I	tagsrch.txt	/*]_CTRL-I*
+]`	motion.txt	/*]`*
+]c	diff.txt	/*]c*
+]d	tagsrch.txt	/*]d*
+]f	editing.txt	/*]f*
+]i	tagsrch.txt	/*]i*
+]m	motion.txt	/*]m*
+]p	change.txt	/*]p*
+]s	spell.txt	/*]s*
+]star	motion.txt	/*]star*
+]z	fold.txt	/*]z*
+]}	motion.txt	/*]}*
+^	motion.txt	/*^*
+_	motion.txt	/*_*
+_exrc	starting.txt	/*_exrc*
+_gvimrc	gui.txt	/*_gvimrc*
+_vimrc	starting.txt	/*_vimrc*
+`	motion.txt	/*`*
+`(	motion.txt	/*`(*
+`)	motion.txt	/*`)*
+`-expansion	editing.txt	/*`-expansion*
+`.	motion.txt	/*`.*
+`0	motion.txt	/*`0*
+`<	motion.txt	/*`<*
+`=	editing.txt	/*`=*
+`>	motion.txt	/*`>*
+`A	motion.txt	/*`A*
+`[	motion.txt	/*`[*
+`]	motion.txt	/*`]*
+`^	motion.txt	/*`^*
+``	motion.txt	/*``*
+`a	motion.txt	/*`a*
+`quote	motion.txt	/*`quote*
+`{	motion.txt	/*`{*
+`}	motion.txt	/*`}*
+a	insert.txt	/*a*
+a'	motion.txt	/*a'*
+a(	motion.txt	/*a(*
+a)	motion.txt	/*a)*
+a4	print.txt	/*a4*
+a:0	eval.txt	/*a:0*
+a:000	eval.txt	/*a:000*
+a:1	eval.txt	/*a:1*
+a:firstline	eval.txt	/*a:firstline*
+a:lastline	eval.txt	/*a:lastline*
+a:var	eval.txt	/*a:var*
+a<	motion.txt	/*a<*
+a>	motion.txt	/*a>*
+aB	motion.txt	/*aB*
+aW	motion.txt	/*aW*
+a[	motion.txt	/*a[*
+a]	motion.txt	/*a]*
+a`	motion.txt	/*a`*
+ab	motion.txt	/*ab*
+abandon	editing.txt	/*abandon*
+abbreviations	map.txt	/*abbreviations*
+abel.vim	syntax.txt	/*abel.vim*
+abs()	eval.txt	/*abs()*
+acos()	eval.txt	/*acos()*
+active-buffer	windows.txt	/*active-buffer*
+ada#Create_Tags()	ft_ada.txt	/*ada#Create_Tags()*
+ada#Jump_Tag()	ft_ada.txt	/*ada#Jump_Tag()*
+ada#Listtags()	ft_ada.txt	/*ada#Listtags()*
+ada#Switch_Syntax_Option()	ft_ada.txt	/*ada#Switch_Syntax_Option()*
+ada#Word()	ft_ada.txt	/*ada#Word()*
+ada-compiler	ft_ada.txt	/*ada-compiler*
+ada-ctags	ft_ada.txt	/*ada-ctags*
+ada-extra-plugins	ft_ada.txt	/*ada-extra-plugins*
+ada-reference	ft_ada.txt	/*ada-reference*
+ada.vim	ft_ada.txt	/*ada.vim*
+add()	eval.txt	/*add()*
+add-filetype-plugin	usr_05.txt	/*add-filetype-plugin*
+add-global-plugin	usr_05.txt	/*add-global-plugin*
+add-local-help	usr_05.txt	/*add-local-help*
+add-option-flags	options.txt	/*add-option-flags*
+add-package	usr_05.txt	/*add-package*
+add-plugin	usr_05.txt	/*add-plugin*
+added-5.1	version5.txt	/*added-5.1*
+added-5.2	version5.txt	/*added-5.2*
+added-5.3	version5.txt	/*added-5.3*
+added-5.4	version5.txt	/*added-5.4*
+added-5.5	version5.txt	/*added-5.5*
+added-5.6	version5.txt	/*added-5.6*
+added-5.7	version5.txt	/*added-5.7*
+added-5.8	version5.txt	/*added-5.8*
+added-6.1	version6.txt	/*added-6.1*
+added-6.2	version6.txt	/*added-6.2*
+added-6.3	version6.txt	/*added-6.3*
+added-6.4	version6.txt	/*added-6.4*
+added-7.1	version7.txt	/*added-7.1*
+added-7.2	version7.txt	/*added-7.2*
+added-7.3	version7.txt	/*added-7.3*
+added-7.4	version7.txt	/*added-7.4*
+added-8.1	version8.txt	/*added-8.1*
+added-BeOS	version5.txt	/*added-BeOS*
+added-Mac	version5.txt	/*added-Mac*
+added-VMS	version5.txt	/*added-VMS*
+added-cmdline-args	version5.txt	/*added-cmdline-args*
+added-options	version5.txt	/*added-options*
+added-regexp	version5.txt	/*added-regexp*
+added-various	version5.txt	/*added-various*
+added-win32-GUI	version5.txt	/*added-win32-GUI*
+aff-dic-format	spell.txt	/*aff-dic-format*
+after-directory	options.txt	/*after-directory*
+aleph	options.txt	/*aleph*
+alt	intro.txt	/*alt*
+alt-input	debugger.txt	/*alt-input*
+alternate-file	editing.txt	/*alternate-file*
+amiga-window	starting.txt	/*amiga-window*
+and()	eval.txt	/*and()*
+anonymous-function	eval.txt	/*anonymous-function*
+ant.vim	syntax.txt	/*ant.vim*
+ap	motion.txt	/*ap*
+apache.vim	syntax.txt	/*apache.vim*
+append()	eval.txt	/*append()*
+appendbufline()	eval.txt	/*appendbufline()*
+aquote	motion.txt	/*aquote*
+arabic.txt	arabic.txt	/*arabic.txt*
+arabicfonts	arabic.txt	/*arabicfonts*
+arabickeymap	arabic.txt	/*arabickeymap*
+arg-functions	usr_41.txt	/*arg-functions*
+argc()	eval.txt	/*argc()*
+argidx()	eval.txt	/*argidx()*
+arglist	editing.txt	/*arglist*
+arglist-position	editing.txt	/*arglist-position*
+arglist-quit	usr_07.txt	/*arglist-quit*
+arglistid()	eval.txt	/*arglistid()*
+argument-list	editing.txt	/*argument-list*
+argv()	eval.txt	/*argv()*
+as	motion.txt	/*as*
+asin()	eval.txt	/*asin()*
+asm.vim	syntax.txt	/*asm.vim*
+asm68k	syntax.txt	/*asm68k*
+asmh8300.vim	syntax.txt	/*asmh8300.vim*
+assert-return	eval.txt	/*assert-return*
+assert_beeps()	eval.txt	/*assert_beeps()*
+assert_equal()	eval.txt	/*assert_equal()*
+assert_equalfile()	eval.txt	/*assert_equalfile()*
+assert_exception()	eval.txt	/*assert_exception()*
+assert_fails()	eval.txt	/*assert_fails()*
+assert_false()	eval.txt	/*assert_false()*
+assert_inrange()	eval.txt	/*assert_inrange()*
+assert_match()	eval.txt	/*assert_match()*
+assert_notequal()	eval.txt	/*assert_notequal()*
+assert_notmatch()	eval.txt	/*assert_notmatch()*
+assert_report()	eval.txt	/*assert_report()*
+assert_true()	eval.txt	/*assert_true()*
+at	motion.txt	/*at*
+atan()	eval.txt	/*atan()*
+atan2()	eval.txt	/*atan2()*
+athena-intellimouse	gui.txt	/*athena-intellimouse*
+attr-list	syntax.txt	/*attr-list*
+author	intro.txt	/*author*
+auto-format	change.txt	/*auto-format*
+auto-setting	options.txt	/*auto-setting*
+auto-shortname	editing.txt	/*auto-shortname*
+autocmd-<>	tips.txt	/*autocmd-<>*
+autocmd-buffer-local	autocmd.txt	/*autocmd-buffer-local*
+autocmd-buflocal	autocmd.txt	/*autocmd-buflocal*
+autocmd-changes	autocmd.txt	/*autocmd-changes*
+autocmd-define	autocmd.txt	/*autocmd-define*
+autocmd-disable	autocmd.txt	/*autocmd-disable*
+autocmd-events	autocmd.txt	/*autocmd-events*
+autocmd-events-abc	autocmd.txt	/*autocmd-events-abc*
+autocmd-execute	autocmd.txt	/*autocmd-execute*
+autocmd-groups	autocmd.txt	/*autocmd-groups*
+autocmd-intro	autocmd.txt	/*autocmd-intro*
+autocmd-list	autocmd.txt	/*autocmd-list*
+autocmd-nested	autocmd.txt	/*autocmd-nested*
+autocmd-osfiletypes	filetype.txt	/*autocmd-osfiletypes*
+autocmd-patterns	autocmd.txt	/*autocmd-patterns*
+autocmd-remove	autocmd.txt	/*autocmd-remove*
+autocmd-searchpat	autocmd.txt	/*autocmd-searchpat*
+autocmd-use	autocmd.txt	/*autocmd-use*
+autocmd.txt	autocmd.txt	/*autocmd.txt*
+autocmds-kept	version5.txt	/*autocmds-kept*
+autocommand	autocmd.txt	/*autocommand*
+autocommand-events	autocmd.txt	/*autocommand-events*
+autocommand-pattern	autocmd.txt	/*autocommand-pattern*
+autocommands	autocmd.txt	/*autocommands*
+autoformat	change.txt	/*autoformat*
+autoload	eval.txt	/*autoload*
+autoload-functions	eval.txt	/*autoload-functions*
+avoid-hit-enter	version5.txt	/*avoid-hit-enter*
+aw	motion.txt	/*aw*
+a{	motion.txt	/*a{*
+a}	motion.txt	/*a}*
+b	motion.txt	/*b*
+b:	eval.txt	/*b:*
+b:changedtick	eval.txt	/*b:changedtick*
+b:changelog_name	filetype.txt	/*b:changelog_name*
+b:clojure_syntax_keywords	syntax.txt	/*b:clojure_syntax_keywords*
+b:clojure_syntax_without_core_keywords	syntax.txt	/*b:clojure_syntax_without_core_keywords*
+b:current_syntax-variable	syntax.txt	/*b:current_syntax-variable*
+b:netrw_lastfile	pi_netrw.txt	/*b:netrw_lastfile*
+b:tex_stylish	syntax.txt	/*b:tex_stylish*
+b:var	eval.txt	/*b:var*
+b:yaml_schema	syntax.txt	/*b:yaml_schema*
+baan-folding	syntax.txt	/*baan-folding*
+baan-syntax	syntax.txt	/*baan-syntax*
+baan.vim	syntax.txt	/*baan.vim*
+backslash	intro.txt	/*backslash*
+backspace	intro.txt	/*backspace*
+backspace-delete	version4.txt	/*backspace-delete*
+backtick-expansion	editing.txt	/*backtick-expansion*
+backup	editing.txt	/*backup*
+backup-changed	version4.txt	/*backup-changed*
+backup-extension	version4.txt	/*backup-extension*
+backup-table	editing.txt	/*backup-table*
+balloon-eval	debugger.txt	/*balloon-eval*
+balloon_show()	eval.txt	/*balloon_show()*
+balloon_split()	eval.txt	/*balloon_split()*
+bar	motion.txt	/*bar*
+bars	help.txt	/*bars*
+base_font_name_list	mbyte.txt	/*base_font_name_list*
+basic.vim	syntax.txt	/*basic.vim*
+beep	options.txt	/*beep*
+beos-colors	os_beos.txt	/*beos-colors*
+beos-compiling	os_beos.txt	/*beos-compiling*
+beos-dragndrop	os_beos.txt	/*beos-dragndrop*
+beos-fonts	os_beos.txt	/*beos-fonts*
+beos-general	os_beos.txt	/*beos-general*
+beos-gui	os_beos.txt	/*beos-gui*
+beos-launch	os_beos.txt	/*beos-launch*
+beos-meta	os_beos.txt	/*beos-meta*
+beos-mouse	os_beos.txt	/*beos-mouse*
+beos-perl	os_beos.txt	/*beos-perl*
+beos-timeout	os_beos.txt	/*beos-timeout*
+beos-unicode	os_beos.txt	/*beos-unicode*
+beos-utf8	os_beos.txt	/*beos-utf8*
+beos-vimdir	os_beos.txt	/*beos-vimdir*
+better-python-interface	version7.txt	/*better-python-interface*
+beval_bufnr-variable	eval.txt	/*beval_bufnr-variable*
+beval_col-variable	eval.txt	/*beval_col-variable*
+beval_lnum-variable	eval.txt	/*beval_lnum-variable*
+beval_text-variable	eval.txt	/*beval_text-variable*
+beval_winid-variable	eval.txt	/*beval_winid-variable*
+beval_winnr-variable	eval.txt	/*beval_winnr-variable*
+binary-number	eval.txt	/*binary-number*
+bitwise-function	usr_41.txt	/*bitwise-function*
+blockwise-examples	visual.txt	/*blockwise-examples*
+blockwise-operators	visual.txt	/*blockwise-operators*
+blockwise-register	change.txt	/*blockwise-register*
+blockwise-visual	visual.txt	/*blockwise-visual*
+blowfish	options.txt	/*blowfish*
+blowfish2	options.txt	/*blowfish2*
+bold	syntax.txt	/*bold*
+bom-bytes	mbyte.txt	/*bom-bytes*
+book	intro.txt	/*book*
+bookmark	usr_03.txt	/*bookmark*
+boolean	options.txt	/*boolean*
+break-finally	eval.txt	/*break-finally*
+browse()	eval.txt	/*browse()*
+browsedir()	eval.txt	/*browsedir()*
+browsefilter	editing.txt	/*browsefilter*
+bufexists()	eval.txt	/*bufexists()*
+buffer-functions	usr_41.txt	/*buffer-functions*
+buffer-hidden	windows.txt	/*buffer-hidden*
+buffer-list	windows.txt	/*buffer-list*
+buffer-variable	eval.txt	/*buffer-variable*
+buffer-write	editing.txt	/*buffer-write*
+buffer_exists()	eval.txt	/*buffer_exists()*
+buffer_name()	eval.txt	/*buffer_name()*
+buffer_number()	eval.txt	/*buffer_number()*
+buffers	windows.txt	/*buffers*
+buffers-menu	gui.txt	/*buffers-menu*
+buflisted()	eval.txt	/*buflisted()*
+bufloaded()	eval.txt	/*bufloaded()*
+bufname()	eval.txt	/*bufname()*
+bufnr()	eval.txt	/*bufnr()*
+bufwinid()	eval.txt	/*bufwinid()*
+bufwinnr()	eval.txt	/*bufwinnr()*
+bug-fixes-5	version5.txt	/*bug-fixes-5*
+bug-fixes-6	version6.txt	/*bug-fixes-6*
+bug-fixes-7	version7.txt	/*bug-fixes-7*
+bug-fixes-8	version8.txt	/*bug-fixes-8*
+bug-reports	intro.txt	/*bug-reports*
+bugreport.vim	intro.txt	/*bugreport.vim*
+bugs	intro.txt	/*bugs*
+builtin-terms	term.txt	/*builtin-terms*
+builtin-tools	gui.txt	/*builtin-tools*
+builtin_terms	term.txt	/*builtin_terms*
+byte-count	editing.txt	/*byte-count*
+byte2line()	eval.txt	/*byte2line()*
+byteidx()	eval.txt	/*byteidx()*
+byteidxcomp()	eval.txt	/*byteidxcomp()*
+bzip2	pi_gzip.txt	/*bzip2*
+c	change.txt	/*c*
+c.vim	syntax.txt	/*c.vim*
+cW	change.txt	/*cW*
+c_#	cmdline.txt	/*c_#*
+c_##	cmdline.txt	/*c_##*
+c_#<	cmdline.txt	/*c_#<*
+c_#n	cmdline.txt	/*c_#n*
+c_%	cmdline.txt	/*c_%*
+c_<BS>	cmdline.txt	/*c_<BS>*
+c_<C-Left>	cmdline.txt	/*c_<C-Left>*
+c_<C-R>	cmdline.txt	/*c_<C-R>*
+c_<C-R>_<C-A>	cmdline.txt	/*c_<C-R>_<C-A>*
+c_<C-R>_<C-F>	cmdline.txt	/*c_<C-R>_<C-F>*
+c_<C-R>_<C-L>	cmdline.txt	/*c_<C-R>_<C-L>*
+c_<C-R>_<C-O>	cmdline.txt	/*c_<C-R>_<C-O>*
+c_<C-R>_<C-P>	cmdline.txt	/*c_<C-R>_<C-P>*
+c_<C-R>_<C-R>	cmdline.txt	/*c_<C-R>_<C-R>*
+c_<C-R>_<C-W>	cmdline.txt	/*c_<C-R>_<C-W>*
+c_<C-Right>	cmdline.txt	/*c_<C-Right>*
+c_<CR>	cmdline.txt	/*c_<CR>*
+c_<Del>	cmdline.txt	/*c_<Del>*
+c_<Down>	cmdline.txt	/*c_<Down>*
+c_<End>	cmdline.txt	/*c_<End>*
+c_<Esc>	cmdline.txt	/*c_<Esc>*
+c_<Home>	cmdline.txt	/*c_<Home>*
+c_<Insert>	cmdline.txt	/*c_<Insert>*
+c_<Left>	cmdline.txt	/*c_<Left>*
+c_<LeftMouse>	cmdline.txt	/*c_<LeftMouse>*
+c_<MiddleMouse>	cmdline.txt	/*c_<MiddleMouse>*
+c_<NL>	cmdline.txt	/*c_<NL>*
+c_<PageDown>	cmdline.txt	/*c_<PageDown>*
+c_<PageUp>	cmdline.txt	/*c_<PageUp>*
+c_<Right>	cmdline.txt	/*c_<Right>*
+c_<S-Down>	cmdline.txt	/*c_<S-Down>*
+c_<S-Left>	cmdline.txt	/*c_<S-Left>*
+c_<S-Right>	cmdline.txt	/*c_<S-Right>*
+c_<S-Tab>	cmdline.txt	/*c_<S-Tab>*
+c_<S-Up>	cmdline.txt	/*c_<S-Up>*
+c_<Tab>	cmdline.txt	/*c_<Tab>*
+c_<Up>	cmdline.txt	/*c_<Up>*
+c_BS	cmdline.txt	/*c_BS*
+c_CR	cmdline.txt	/*c_CR*
+c_CTRL-A	cmdline.txt	/*c_CTRL-A*
+c_CTRL-B	cmdline.txt	/*c_CTRL-B*
+c_CTRL-C	cmdline.txt	/*c_CTRL-C*
+c_CTRL-D	cmdline.txt	/*c_CTRL-D*
+c_CTRL-E	cmdline.txt	/*c_CTRL-E*
+c_CTRL-F	cmdline.txt	/*c_CTRL-F*
+c_CTRL-G	cmdline.txt	/*c_CTRL-G*
+c_CTRL-H	cmdline.txt	/*c_CTRL-H*
+c_CTRL-I	cmdline.txt	/*c_CTRL-I*
+c_CTRL-J	cmdline.txt	/*c_CTRL-J*
+c_CTRL-K	cmdline.txt	/*c_CTRL-K*
+c_CTRL-L	cmdline.txt	/*c_CTRL-L*
+c_CTRL-M	cmdline.txt	/*c_CTRL-M*
+c_CTRL-N	cmdline.txt	/*c_CTRL-N*
+c_CTRL-P	cmdline.txt	/*c_CTRL-P*
+c_CTRL-Q	cmdline.txt	/*c_CTRL-Q*
+c_CTRL-R	cmdline.txt	/*c_CTRL-R*
+c_CTRL-R_=	cmdline.txt	/*c_CTRL-R_=*
+c_CTRL-R_CTRL-A	cmdline.txt	/*c_CTRL-R_CTRL-A*
+c_CTRL-R_CTRL-F	cmdline.txt	/*c_CTRL-R_CTRL-F*
+c_CTRL-R_CTRL-L	cmdline.txt	/*c_CTRL-R_CTRL-L*
+c_CTRL-R_CTRL-O	cmdline.txt	/*c_CTRL-R_CTRL-O*
+c_CTRL-R_CTRL-P	cmdline.txt	/*c_CTRL-R_CTRL-P*
+c_CTRL-R_CTRL-R	cmdline.txt	/*c_CTRL-R_CTRL-R*
+c_CTRL-R_CTRL-W	cmdline.txt	/*c_CTRL-R_CTRL-W*
+c_CTRL-T	cmdline.txt	/*c_CTRL-T*
+c_CTRL-U	cmdline.txt	/*c_CTRL-U*
+c_CTRL-V	cmdline.txt	/*c_CTRL-V*
+c_CTRL-W	cmdline.txt	/*c_CTRL-W*
+c_CTRL-Y	cmdline.txt	/*c_CTRL-Y*
+c_CTRL-[	cmdline.txt	/*c_CTRL-[*
+c_CTRL-\_CTRL-G	intro.txt	/*c_CTRL-\\_CTRL-G*
+c_CTRL-\_CTRL-N	intro.txt	/*c_CTRL-\\_CTRL-N*
+c_CTRL-\_e	cmdline.txt	/*c_CTRL-\\_e*
+c_CTRL-]	cmdline.txt	/*c_CTRL-]*
+c_CTRL-^	cmdline.txt	/*c_CTRL-^*
+c_CTRL-_	cmdline.txt	/*c_CTRL-_*
+c_Del	cmdline.txt	/*c_Del*
+c_Down	cmdline.txt	/*c_Down*
+c_End	cmdline.txt	/*c_End*
+c_Esc	cmdline.txt	/*c_Esc*
+c_Home	cmdline.txt	/*c_Home*
+c_Insert	cmdline.txt	/*c_Insert*
+c_Left	cmdline.txt	/*c_Left*
+c_Right	cmdline.txt	/*c_Right*
+c_Up	cmdline.txt	/*c_Up*
+c_ansi_constants	syntax.txt	/*c_ansi_constants*
+c_ansi_typedefs	syntax.txt	/*c_ansi_typedefs*
+c_comment_strings	syntax.txt	/*c_comment_strings*
+c_curly_error	syntax.txt	/*c_curly_error*
+c_digraph	cmdline.txt	/*c_digraph*
+c_gnu	syntax.txt	/*c_gnu*
+c_no_ansi	syntax.txt	/*c_no_ansi*
+c_no_bracket_error	syntax.txt	/*c_no_bracket_error*
+c_no_bsd	syntax.txt	/*c_no_bsd*
+c_no_c11	syntax.txt	/*c_no_c11*
+c_no_c99	syntax.txt	/*c_no_c99*
+c_no_cformat	syntax.txt	/*c_no_cformat*
+c_no_curly_error	syntax.txt	/*c_no_curly_error*
+c_no_if0	syntax.txt	/*c_no_if0*
+c_no_tab_space_error	syntax.txt	/*c_no_tab_space_error*
+c_no_trail_space_error	syntax.txt	/*c_no_trail_space_error*
+c_no_utf	syntax.txt	/*c_no_utf*
+c_space_errors	syntax.txt	/*c_space_errors*
+c_syntax_for_h	syntax.txt	/*c_syntax_for_h*
+c_wildchar	cmdline.txt	/*c_wildchar*
+call()	eval.txt	/*call()*
+carriage-return	intro.txt	/*carriage-return*
+case	change.txt	/*case*
+catch-all	eval.txt	/*catch-all*
+catch-errors	eval.txt	/*catch-errors*
+catch-interrupt	eval.txt	/*catch-interrupt*
+catch-order	eval.txt	/*catch-order*
+catch-text	eval.txt	/*catch-text*
+cc	change.txt	/*cc*
+ceil()	eval.txt	/*ceil()*
+cfilter-plugin	quickfix.txt	/*cfilter-plugin*
+ch.vim	syntax.txt	/*ch.vim*
+ch_canread()	eval.txt	/*ch_canread()*
+ch_close()	eval.txt	/*ch_close()*
+ch_close_in()	eval.txt	/*ch_close_in()*
+ch_evalexpr()	eval.txt	/*ch_evalexpr()*
+ch_evalraw()	eval.txt	/*ch_evalraw()*
+ch_getbufnr()	eval.txt	/*ch_getbufnr()*
+ch_getjob()	eval.txt	/*ch_getjob()*
+ch_info()	eval.txt	/*ch_info()*
+ch_log()	eval.txt	/*ch_log()*
+ch_logfile()	eval.txt	/*ch_logfile()*
+ch_open()	eval.txt	/*ch_open()*
+ch_read()	eval.txt	/*ch_read()*
+ch_readraw()	eval.txt	/*ch_readraw()*
+ch_sendexpr()	eval.txt	/*ch_sendexpr()*
+ch_sendraw()	eval.txt	/*ch_sendraw()*
+ch_setoptions()	eval.txt	/*ch_setoptions()*
+ch_status()	eval.txt	/*ch_status()*
+change-list-jumps	motion.txt	/*change-list-jumps*
+change-name	tips.txt	/*change-name*
+change-tabs	change.txt	/*change-tabs*
+change.txt	change.txt	/*change.txt*
+changed-5.1	version5.txt	/*changed-5.1*
+changed-5.2	version5.txt	/*changed-5.2*
+changed-5.3	version5.txt	/*changed-5.3*
+changed-5.4	version5.txt	/*changed-5.4*
+changed-5.5	version5.txt	/*changed-5.5*
+changed-5.6	version5.txt	/*changed-5.6*
+changed-5.7	version5.txt	/*changed-5.7*
+changed-5.8	version5.txt	/*changed-5.8*
+changed-6.1	version6.txt	/*changed-6.1*
+changed-6.2	version6.txt	/*changed-6.2*
+changed-6.3	version6.txt	/*changed-6.3*
+changed-6.4	version6.txt	/*changed-6.4*
+changed-7.1	version7.txt	/*changed-7.1*
+changed-7.2	version7.txt	/*changed-7.2*
+changed-7.3	version7.txt	/*changed-7.3*
+changed-7.4	version7.txt	/*changed-7.4*
+changed-8.1	version8.txt	/*changed-8.1*
+changelist	motion.txt	/*changelist*
+changelog.vim	syntax.txt	/*changelog.vim*
+changenr()	eval.txt	/*changenr()*
+changetick	eval.txt	/*changetick*
+changing	change.txt	/*changing*
+channel	channel.txt	/*channel*
+channel-callback	channel.txt	/*channel-callback*
+channel-close	channel.txt	/*channel-close*
+channel-close-in	channel.txt	/*channel-close-in*
+channel-commands	channel.txt	/*channel-commands*
+channel-demo	channel.txt	/*channel-demo*
+channel-drop	channel.txt	/*channel-drop*
+channel-functions	usr_41.txt	/*channel-functions*
+channel-mode	channel.txt	/*channel-mode*
+channel-more	channel.txt	/*channel-more*
+channel-open	channel.txt	/*channel-open*
+channel-open-options	channel.txt	/*channel-open-options*
+channel-raw	channel.txt	/*channel-raw*
+channel-timeout	channel.txt	/*channel-timeout*
+channel-use	channel.txt	/*channel-use*
+channel.txt	channel.txt	/*channel.txt*
+char-variable	eval.txt	/*char-variable*
+char2nr()	eval.txt	/*char2nr()*
+characterwise	motion.txt	/*characterwise*
+characterwise-register	change.txt	/*characterwise-register*
+characterwise-visual	visual.txt	/*characterwise-visual*
+charconvert_from-variable	eval.txt	/*charconvert_from-variable*
+charconvert_to-variable	eval.txt	/*charconvert_to-variable*
+charity	uganda.txt	/*charity*
+charset	mbyte.txt	/*charset*
+charset-conversion	mbyte.txt	/*charset-conversion*
+chill.vim	syntax.txt	/*chill.vim*
+chmod	eval.txt	/*chmod*
+cindent()	eval.txt	/*cindent()*
+cinkeys-format	indent.txt	/*cinkeys-format*
+cino-#	indent.txt	/*cino-#*
+cino-(	indent.txt	/*cino-(*
+cino-)	indent.txt	/*cino-)*
+cino-+	indent.txt	/*cino-+*
+cino-/	indent.txt	/*cino-\/*
+cino-:	indent.txt	/*cino-:*
+cino-=	indent.txt	/*cino-=*
+cino->	indent.txt	/*cino->*
+cino-C	indent.txt	/*cino-C*
+cino-E	indent.txt	/*cino-E*
+cino-J	indent.txt	/*cino-J*
+cino-L	indent.txt	/*cino-L*
+cino-M	indent.txt	/*cino-M*
+cino-N	indent.txt	/*cino-N*
+cino-U	indent.txt	/*cino-U*
+cino-W	indent.txt	/*cino-W*
+cino-^	indent.txt	/*cino-^*
+cino-b	indent.txt	/*cino-b*
+cino-c	indent.txt	/*cino-c*
+cino-e	indent.txt	/*cino-e*
+cino-f	indent.txt	/*cino-f*
+cino-g	indent.txt	/*cino-g*
+cino-h	indent.txt	/*cino-h*
+cino-i	indent.txt	/*cino-i*
+cino-j	indent.txt	/*cino-j*
+cino-k	indent.txt	/*cino-k*
+cino-l	indent.txt	/*cino-l*
+cino-m	indent.txt	/*cino-m*
+cino-n	indent.txt	/*cino-n*
+cino-p	indent.txt	/*cino-p*
+cino-star	indent.txt	/*cino-star*
+cino-t	indent.txt	/*cino-t*
+cino-u	indent.txt	/*cino-u*
+cino-w	indent.txt	/*cino-w*
+cino-{	indent.txt	/*cino-{*
+cino-}	indent.txt	/*cino-}*
+cinoptions-values	indent.txt	/*cinoptions-values*
+clear-undo	undo.txt	/*clear-undo*
+clearmatches()	eval.txt	/*clearmatches()*
+client-server	remote.txt	/*client-server*
+client-server-name	remote.txt	/*client-server-name*
+clientserver	remote.txt	/*clientserver*
+clipboard	gui.txt	/*clipboard*
+clipboard-autoselect	options.txt	/*clipboard-autoselect*
+clipboard-autoselectml	options.txt	/*clipboard-autoselectml*
+clipboard-autoselectplus	options.txt	/*clipboard-autoselectplus*
+clipboard-exclude	options.txt	/*clipboard-exclude*
+clipboard-html	options.txt	/*clipboard-html*
+clipboard-unnamed	options.txt	/*clipboard-unnamed*
+clipboard-unnamedplus	options.txt	/*clipboard-unnamedplus*
+clojure-indent	indent.txt	/*clojure-indent*
+close_cb	channel.txt	/*close_cb*
+closure	eval.txt	/*closure*
+cmdarg-variable	eval.txt	/*cmdarg-variable*
+cmdbang-variable	eval.txt	/*cmdbang-variable*
+cmdline-arguments	vi_diff.txt	/*cmdline-arguments*
+cmdline-changed	version5.txt	/*cmdline-changed*
+cmdline-completion	cmdline.txt	/*cmdline-completion*
+cmdline-editing	cmdline.txt	/*cmdline-editing*
+cmdline-history	cmdline.txt	/*cmdline-history*
+cmdline-lines	cmdline.txt	/*cmdline-lines*
+cmdline-ranges	cmdline.txt	/*cmdline-ranges*
+cmdline-special	cmdline.txt	/*cmdline-special*
+cmdline-too-long	cmdline.txt	/*cmdline-too-long*
+cmdline-window	cmdline.txt	/*cmdline-window*
+cmdline.txt	cmdline.txt	/*cmdline.txt*
+cmdwin	cmdline.txt	/*cmdwin*
+cmdwin-char	cmdline.txt	/*cmdwin-char*
+cobol.vim	syntax.txt	/*cobol.vim*
+codeset	mbyte.txt	/*codeset*
+coding-style	develop.txt	/*coding-style*
+col()	eval.txt	/*col()*
+coldfusion.vim	syntax.txt	/*coldfusion.vim*
+collapse	tips.txt	/*collapse*
+color-xterm	syntax.txt	/*color-xterm*
+coloring	syntax.txt	/*coloring*
+colortest.vim	syntax.txt	/*colortest.vim*
+command-line-functions	usr_41.txt	/*command-line-functions*
+command-line-window	cmdline.txt	/*command-line-window*
+command-mode	intro.txt	/*command-mode*
+compatible-default	starting.txt	/*compatible-default*
+compile-changes-5	version5.txt	/*compile-changes-5*
+compile-changes-6	version6.txt	/*compile-changes-6*
+compile-changes-7	version7.txt	/*compile-changes-7*
+compile-changes-8	version8.txt	/*compile-changes-8*
+compiler-compaqada	ft_ada.txt	/*compiler-compaqada*
+compiler-decada	ft_ada.txt	/*compiler-decada*
+compiler-gcc	quickfix.txt	/*compiler-gcc*
+compiler-gnat	ft_ada.txt	/*compiler-gnat*
+compiler-hpada	ft_ada.txt	/*compiler-hpada*
+compiler-manx	quickfix.txt	/*compiler-manx*
+compiler-perl	quickfix.txt	/*compiler-perl*
+compiler-pyunit	quickfix.txt	/*compiler-pyunit*
+compiler-select	quickfix.txt	/*compiler-select*
+compiler-tex	quickfix.txt	/*compiler-tex*
+compiler-vaxada	ft_ada.txt	/*compiler-vaxada*
+compl-current	insert.txt	/*compl-current*
+compl-define	insert.txt	/*compl-define*
+compl-dictionary	insert.txt	/*compl-dictionary*
+compl-filename	insert.txt	/*compl-filename*
+compl-function	insert.txt	/*compl-function*
+compl-generic	insert.txt	/*compl-generic*
+compl-keyword	insert.txt	/*compl-keyword*
+compl-omni	insert.txt	/*compl-omni*
+compl-omni-filetypes	insert.txt	/*compl-omni-filetypes*
+compl-spelling	insert.txt	/*compl-spelling*
+compl-tag	insert.txt	/*compl-tag*
+compl-vim	insert.txt	/*compl-vim*
+compl-whole-line	insert.txt	/*compl-whole-line*
+complete()	eval.txt	/*complete()*
+complete-functions	insert.txt	/*complete-functions*
+complete-items	insert.txt	/*complete-items*
+complete_CTRL-E	insert.txt	/*complete_CTRL-E*
+complete_CTRL-Y	insert.txt	/*complete_CTRL-Y*
+complete_add()	eval.txt	/*complete_add()*
+complete_check()	eval.txt	/*complete_check()*
+completed_item-variable	eval.txt	/*completed_item-variable*
+completion-functions	usr_41.txt	/*completion-functions*
+complex-change	change.txt	/*complex-change*
+complex-repeat	repeat.txt	/*complex-repeat*
+compress	pi_gzip.txt	/*compress*
+conceal	syntax.txt	/*conceal*
+confirm()	eval.txt	/*confirm()*
+connection-refused	message.txt	/*connection-refused*
+console-menus	gui.txt	/*console-menus*
+control	intro.txt	/*control*
+conversion-server	mbyte.txt	/*conversion-server*
+convert-to-HTML	syntax.txt	/*convert-to-HTML*
+convert-to-XHTML	syntax.txt	/*convert-to-XHTML*
+convert-to-XML	syntax.txt	/*convert-to-XML*
+copy()	eval.txt	/*copy()*
+copy-diffs	diff.txt	/*copy-diffs*
+copy-move	change.txt	/*copy-move*
+copying	uganda.txt	/*copying*
+copyright	uganda.txt	/*copyright*
+cos()	eval.txt	/*cos()*
+cosh()	eval.txt	/*cosh()*
+count	intro.txt	/*count*
+count()	eval.txt	/*count()*
+count-bytes	tips.txt	/*count-bytes*
+count-items	tips.txt	/*count-items*
+count-variable	eval.txt	/*count-variable*
+count1-variable	eval.txt	/*count1-variable*
+cp-default	version5.txt	/*cp-default*
+cpo	options.txt	/*cpo*
+cpo-!	options.txt	/*cpo-!*
+cpo-#	options.txt	/*cpo-#*
+cpo-$	options.txt	/*cpo-$*
+cpo-%	options.txt	/*cpo-%*
+cpo-&	options.txt	/*cpo-&*
+cpo-+	options.txt	/*cpo-+*
+cpo--	options.txt	/*cpo--*
+cpo-.	options.txt	/*cpo-.*
+cpo-/	options.txt	/*cpo-\/*
+cpo-;	options.txt	/*cpo-;*
+cpo-<	options.txt	/*cpo-<*
+cpo->	options.txt	/*cpo->*
+cpo-A	options.txt	/*cpo-A*
+cpo-B	options.txt	/*cpo-B*
+cpo-C	options.txt	/*cpo-C*
+cpo-D	options.txt	/*cpo-D*
+cpo-E	options.txt	/*cpo-E*
+cpo-F	options.txt	/*cpo-F*
+cpo-H	options.txt	/*cpo-H*
+cpo-I	options.txt	/*cpo-I*
+cpo-J	options.txt	/*cpo-J*
+cpo-K	options.txt	/*cpo-K*
+cpo-L	options.txt	/*cpo-L*
+cpo-M	options.txt	/*cpo-M*
+cpo-O	options.txt	/*cpo-O*
+cpo-P	options.txt	/*cpo-P*
+cpo-R	options.txt	/*cpo-R*
+cpo-S	options.txt	/*cpo-S*
+cpo-W	options.txt	/*cpo-W*
+cpo-X	options.txt	/*cpo-X*
+cpo-Z	options.txt	/*cpo-Z*
+cpo-\	options.txt	/*cpo-\\*
+cpo-a	options.txt	/*cpo-a*
+cpo-b	options.txt	/*cpo-b*
+cpo-bar	options.txt	/*cpo-bar*
+cpo-c	options.txt	/*cpo-c*
+cpo-d	options.txt	/*cpo-d*
+cpo-e	options.txt	/*cpo-e*
+cpo-f	options.txt	/*cpo-f*
+cpo-g	options.txt	/*cpo-g*
+cpo-i	options.txt	/*cpo-i*
+cpo-j	options.txt	/*cpo-j*
+cpo-k	options.txt	/*cpo-k*
+cpo-l	options.txt	/*cpo-l*
+cpo-m	options.txt	/*cpo-m*
+cpo-n	options.txt	/*cpo-n*
+cpo-o	options.txt	/*cpo-o*
+cpo-p	options.txt	/*cpo-p*
+cpo-q	options.txt	/*cpo-q*
+cpo-r	options.txt	/*cpo-r*
+cpo-s	options.txt	/*cpo-s*
+cpo-star	options.txt	/*cpo-star*
+cpo-t	options.txt	/*cpo-t*
+cpo-u	options.txt	/*cpo-u*
+cpo-v	options.txt	/*cpo-v*
+cpo-w	options.txt	/*cpo-w*
+cpo-x	options.txt	/*cpo-x*
+cpo-y	options.txt	/*cpo-y*
+cpo-{	options.txt	/*cpo-{*
+cpp.vim	syntax.txt	/*cpp.vim*
+crash-recovery	recover.txt	/*crash-recovery*
+creating-menus	gui.txt	/*creating-menus*
+credits	intro.txt	/*credits*
+crontab	options.txt	/*crontab*
+cs-find	if_cscop.txt	/*cs-find*
+cs7-problem	term.txt	/*cs7-problem*
+cscope	if_cscop.txt	/*cscope*
+cscope-commands	if_cscop.txt	/*cscope-commands*
+cscope-find	if_cscop.txt	/*cscope-find*
+cscope-howtouse	if_cscop.txt	/*cscope-howtouse*
+cscope-info	if_cscop.txt	/*cscope-info*
+cscope-intro	if_cscop.txt	/*cscope-intro*
+cscope-limitations	if_cscop.txt	/*cscope-limitations*
+cscope-options	if_cscop.txt	/*cscope-options*
+cscope-suggestions	if_cscop.txt	/*cscope-suggestions*
+cscope-win32	if_cscop.txt	/*cscope-win32*
+cscope_connection()	eval.txt	/*cscope_connection()*
+cscopepathcomp	if_cscop.txt	/*cscopepathcomp*
+cscopeprg	if_cscop.txt	/*cscopeprg*
+cscopequickfix	if_cscop.txt	/*cscopequickfix*
+cscoperelative	if_cscop.txt	/*cscoperelative*
+cscopetag	if_cscop.txt	/*cscopetag*
+cscopetagorder	if_cscop.txt	/*cscopetagorder*
+cscopeverbose	if_cscop.txt	/*cscopeverbose*
+csh.vim	syntax.txt	/*csh.vim*
+cspc	if_cscop.txt	/*cspc*
+csprg	if_cscop.txt	/*csprg*
+csqf	if_cscop.txt	/*csqf*
+csre	if_cscop.txt	/*csre*
+cst	if_cscop.txt	/*cst*
+csto	if_cscop.txt	/*csto*
+csverb	if_cscop.txt	/*csverb*
+ctags	tagsrch.txt	/*ctags*
+ctags-gone	version6.txt	/*ctags-gone*
+cterm-colors	syntax.txt	/*cterm-colors*
+ctrl	intro.txt	/*ctrl*
+ctype-variable	eval.txt	/*ctype-variable*
+curly-braces-function-names	eval.txt	/*curly-braces-function-names*
+curly-braces-names	eval.txt	/*curly-braces-names*
+curpos-visual	version6.txt	/*curpos-visual*
+current-directory	editing.txt	/*current-directory*
+current-file	editing.txt	/*current-file*
+current_compiler	quickfix.txt	/*current_compiler*
+cursor()	eval.txt	/*cursor()*
+cursor-blinking	options.txt	/*cursor-blinking*
+cursor-down	intro.txt	/*cursor-down*
+cursor-functions	usr_41.txt	/*cursor-functions*
+cursor-left	intro.txt	/*cursor-left*
+cursor-motions	motion.txt	/*cursor-motions*
+cursor-position	pattern.txt	/*cursor-position*
+cursor-right	intro.txt	/*cursor-right*
+cursor-up	intro.txt	/*cursor-up*
+cursor_down	intro.txt	/*cursor_down*
+cursor_left	intro.txt	/*cursor_left*
+cursor_right	intro.txt	/*cursor_right*
+cursor_up	intro.txt	/*cursor_up*
+cw	change.txt	/*cw*
+cweb.vim	syntax.txt	/*cweb.vim*
+cynlib.vim	syntax.txt	/*cynlib.vim*
+d	change.txt	/*d*
+daB	motion.txt	/*daB*
+daW	motion.txt	/*daW*
+dab	motion.txt	/*dab*
+dap	motion.txt	/*dap*
+das	motion.txt	/*das*
+date-functions	usr_41.txt	/*date-functions*
+dav	pi_netrw.txt	/*dav*
+davs	pi_netrw.txt	/*davs*
+daw	motion.txt	/*daw*
+dd	change.txt	/*dd*
+debug-gcc	debug.txt	/*debug-gcc*
+debug-highlight	debugger.txt	/*debug-highlight*
+debug-leaks	debug.txt	/*debug-leaks*
+debug-minidump	debug.txt	/*debug-minidump*
+debug-mode	repeat.txt	/*debug-mode*
+debug-scripts	repeat.txt	/*debug-scripts*
+debug-signs	debugger.txt	/*debug-signs*
+debug-vim	debug.txt	/*debug-vim*
+debug-vs2005	debug.txt	/*debug-vs2005*
+debug-win32	debug.txt	/*debug-win32*
+debug-windbg	debug.txt	/*debug-windbg*
+debug.txt	debug.txt	/*debug.txt*
+debugbreak()	eval.txt	/*debugbreak()*
+debugger-compilation	debugger.txt	/*debugger-compilation*
+debugger-features	debugger.txt	/*debugger-features*
+debugger-integration	debugger.txt	/*debugger-integration*
+debugger-support	debugger.txt	/*debugger-support*
+debugger.txt	debugger.txt	/*debugger.txt*
+dec-mouse	options.txt	/*dec-mouse*
+decada_members	ft_ada.txt	/*decada_members*
+deepcopy()	eval.txt	/*deepcopy()*
+defaults.vim	starting.txt	/*defaults.vim*
+definition-search	tagsrch.txt	/*definition-search*
+definitions	intro.txt	/*definitions*
+delete()	eval.txt	/*delete()*
+delete-insert	change.txt	/*delete-insert*
+delete-menus	gui.txt	/*delete-menus*
+deletebufline()	eval.txt	/*deletebufline()*
+deleting	change.txt	/*deleting*
+demoserver.py	channel.txt	/*demoserver.py*
+design-assumptions	develop.txt	/*design-assumptions*
+design-compatible	develop.txt	/*design-compatible*
+design-decisions	develop.txt	/*design-decisions*
+design-documented	develop.txt	/*design-documented*
+design-flexible	develop.txt	/*design-flexible*
+design-goals	develop.txt	/*design-goals*
+design-improved	develop.txt	/*design-improved*
+design-maintain	develop.txt	/*design-maintain*
+design-multi-platform	develop.txt	/*design-multi-platform*
+design-not	develop.txt	/*design-not*
+design-speed-size	develop.txt	/*design-speed-size*
+desktop.vim	syntax.txt	/*desktop.vim*
+develop-spell	develop.txt	/*develop-spell*
+develop-spell-suggestions	develop.txt	/*develop-spell-suggestions*
+develop.txt	develop.txt	/*develop.txt*
+development	develop.txt	/*development*
+dgn	motion.txt	/*dgn*
+dh	change.txt	/*dh*
+diB	motion.txt	/*diB*
+diW	motion.txt	/*diW*
+dialog	gui_w32.txt	/*dialog*
+dialogs-added	version5.txt	/*dialogs-added*
+dib	motion.txt	/*dib*
+dict	eval.txt	/*dict*
+dict-functions	usr_41.txt	/*dict-functions*
+dict-identity	eval.txt	/*dict-identity*
+dict-modification	eval.txt	/*dict-modification*
+did_filetype()	eval.txt	/*did_filetype()*
+diff	diff.txt	/*diff*
+diff-diffexpr	diff.txt	/*diff-diffexpr*
+diff-mode	diff.txt	/*diff-mode*
+diff-options	diff.txt	/*diff-options*
+diff-original-file	diff.txt	/*diff-original-file*
+diff-patchexpr	diff.txt	/*diff-patchexpr*
+diff-slow	diff.txt	/*diff-slow*
+diff.txt	diff.txt	/*diff.txt*
+diff.vim	syntax.txt	/*diff.vim*
+diff_filler()	eval.txt	/*diff_filler()*
+diff_hlID()	eval.txt	/*diff_hlID()*
+diff_translations	diff.txt	/*diff_translations*
+digraph	digraph.txt	/*digraph*
+digraph-arg	change.txt	/*digraph-arg*
+digraph-encoding	digraph.txt	/*digraph-encoding*
+digraph-table	digraph.txt	/*digraph-table*
+digraph-table-mbyte	digraph.txt	/*digraph-table-mbyte*
+digraph.txt	digraph.txt	/*digraph.txt*
+digraphs	digraph.txt	/*digraphs*
+digraphs-changed	version6.txt	/*digraphs-changed*
+digraphs-default	digraph.txt	/*digraphs-default*
+digraphs-define	digraph.txt	/*digraphs-define*
+digraphs-use	digraph.txt	/*digraphs-use*
+dip	motion.txt	/*dip*
+dircolors.vim	syntax.txt	/*dircolors.vim*
+dis	motion.txt	/*dis*
+disable-menus	gui.txt	/*disable-menus*
+discard	editing.txt	/*discard*
+distribute-script	usr_41.txt	/*distribute-script*
+distribution	intro.txt	/*distribution*
+diw	motion.txt	/*diw*
+dl	change.txt	/*dl*
+do	diff.txt	/*do*
+doc-file-list	help.txt	/*doc-file-list*
+docbk.vim	syntax.txt	/*docbk.vim*
+docbksgml.vim	syntax.txt	/*docbksgml.vim*
+docbkxml.vim	syntax.txt	/*docbkxml.vim*
+docbook	syntax.txt	/*docbook*
+documentation-6	version6.txt	/*documentation-6*
+donate	uganda.txt	/*donate*
+dos	os_dos.txt	/*dos*
+dos-:cd	os_dos.txt	/*dos-:cd*
+dos-CTRL-Break	os_dos.txt	/*dos-CTRL-Break*
+dos-backslash	os_dos.txt	/*dos-backslash*
+dos-colors	os_dos.txt	/*dos-colors*
+dos-file-formats	os_dos.txt	/*dos-file-formats*
+dos-locations	os_dos.txt	/*dos-locations*
+dos-shell	os_dos.txt	/*dos-shell*
+dos-standard-mappings	os_dos.txt	/*dos-standard-mappings*
+dos-temp-files	os_dos.txt	/*dos-temp-files*
+dosbatch.vim	syntax.txt	/*dosbatch.vim*
+double-click	term.txt	/*double-click*
+download	intro.txt	/*download*
+doxygen-syntax	syntax.txt	/*doxygen-syntax*
+doxygen.vim	syntax.txt	/*doxygen.vim*
+dp	diff.txt	/*dp*
+drag-n-drop	gui.txt	/*drag-n-drop*
+drag-n-drop-win32	gui_w32.txt	/*drag-n-drop-win32*
+drag-status-line	term.txt	/*drag-status-line*
+dtd.vim	syntax.txt	/*dtd.vim*
+dtd2vim	insert.txt	/*dtd2vim*
+dying-variable	eval.txt	/*dying-variable*
+e	motion.txt	/*e*
+easy	starting.txt	/*easy*
+edit-a-file	editing.txt	/*edit-a-file*
+edit-binary	editing.txt	/*edit-binary*
+edit-dialogs	editing.txt	/*edit-dialogs*
+edit-files	editing.txt	/*edit-files*
+edit-intro	editing.txt	/*edit-intro*
+edit-no-break	usr_25.txt	/*edit-no-break*
+edit-paragraph-join	usr_25.txt	/*edit-paragraph-join*
+editing.txt	editing.txt	/*editing.txt*
+efm-%>	quickfix.txt	/*efm-%>*
+efm-entries	quickfix.txt	/*efm-entries*
+efm-ignore	quickfix.txt	/*efm-ignore*
+eiffel.vim	syntax.txt	/*eiffel.vim*
+emacs-keys	tips.txt	/*emacs-keys*
+emacs-tags	tagsrch.txt	/*emacs-tags*
+emacs_tags	tagsrch.txt	/*emacs_tags*
+empty()	eval.txt	/*empty()*
+encoding-names	mbyte.txt	/*encoding-names*
+encoding-table	mbyte.txt	/*encoding-table*
+encoding-values	mbyte.txt	/*encoding-values*
+encryption	editing.txt	/*encryption*
+end	intro.txt	/*end*
+end-of-file	pattern.txt	/*end-of-file*
+enlightened-terminal	syntax.txt	/*enlightened-terminal*
+erlang.vim	syntax.txt	/*erlang.vim*
+err_buf	channel.txt	/*err_buf*
+err_cb	channel.txt	/*err_cb*
+err_mode	channel.txt	/*err_mode*
+err_modifiable	channel.txt	/*err_modifiable*
+err_msg	channel.txt	/*err_msg*
+err_name	channel.txt	/*err_name*
+err_timeout	channel.txt	/*err_timeout*
+errmsg-variable	eval.txt	/*errmsg-variable*
+error-file-format	quickfix.txt	/*error-file-format*
+error-messages	message.txt	/*error-messages*
+errorformat	quickfix.txt	/*errorformat*
+errorformat-Jikes	quickfix.txt	/*errorformat-Jikes*
+errorformat-LaTeX	quickfix.txt	/*errorformat-LaTeX*
+errorformat-Perl	quickfix.txt	/*errorformat-Perl*
+errorformat-ant	quickfix.txt	/*errorformat-ant*
+errorformat-changed	version4.txt	/*errorformat-changed*
+errorformat-jade	quickfix.txt	/*errorformat-jade*
+errorformat-javac	quickfix.txt	/*errorformat-javac*
+errorformat-multi-line	quickfix.txt	/*errorformat-multi-line*
+errorformat-separate-filename	quickfix.txt	/*errorformat-separate-filename*
+errorformats	quickfix.txt	/*errorformats*
+errors	message.txt	/*errors*
+errors-variable	eval.txt	/*errors-variable*
+escape	intro.txt	/*escape*
+escape()	eval.txt	/*escape()*
+escape-bar	version4.txt	/*escape-bar*
+euphoria3.vim	syntax.txt	/*euphoria3.vim*
+euphoria4.vim	syntax.txt	/*euphoria4.vim*
+eval	eval.txt	/*eval*
+eval()	eval.txt	/*eval()*
+eval-examples	eval.txt	/*eval-examples*
+eval-sandbox	eval.txt	/*eval-sandbox*
+eval.txt	eval.txt	/*eval.txt*
+event-variable	eval.txt	/*event-variable*
+eventhandler()	eval.txt	/*eventhandler()*
+eview	starting.txt	/*eview*
+evim	starting.txt	/*evim*
+evim-keys	starting.txt	/*evim-keys*
+evim.vim	starting.txt	/*evim.vim*
+ex	starting.txt	/*ex*
+ex-cmd-index	index.txt	/*ex-cmd-index*
+ex-edit-index	index.txt	/*ex-edit-index*
+ex-flags	cmdline.txt	/*ex-flags*
+ex:	options.txt	/*ex:*
+except-autocmd	eval.txt	/*except-autocmd*
+except-autocmd-Cmd	eval.txt	/*except-autocmd-Cmd*
+except-autocmd-Post	eval.txt	/*except-autocmd-Post*
+except-autocmd-Pre	eval.txt	/*except-autocmd-Pre*
+except-autocmd-ill	eval.txt	/*except-autocmd-ill*
+except-compat	eval.txt	/*except-compat*
+except-examine	eval.txt	/*except-examine*
+except-from-finally	eval.txt	/*except-from-finally*
+except-hier-param	eval.txt	/*except-hier-param*
+except-several-errors	eval.txt	/*except-several-errors*
+except-single-line	eval.txt	/*except-single-line*
+except-syntax-err	eval.txt	/*except-syntax-err*
+except-syntax-error	eval.txt	/*except-syntax-error*
+exception-handling	eval.txt	/*exception-handling*
+exception-variable	eval.txt	/*exception-variable*
+exclusive	motion.txt	/*exclusive*
+exclusive-linewise	motion.txt	/*exclusive-linewise*
+executable()	eval.txt	/*executable()*
+execute()	eval.txt	/*execute()*
+execute-menus	gui.txt	/*execute-menus*
+exepath()	eval.txt	/*exepath()*
+exim	starting.txt	/*exim*
+exists()	eval.txt	/*exists()*
+exiting	starting.txt	/*exiting*
+exp()	eval.txt	/*exp()*
+expand()	eval.txt	/*expand()*
+expand-env	options.txt	/*expand-env*
+expand-environment-var	options.txt	/*expand-environment-var*
+expr	eval.txt	/*expr*
+expr-!	eval.txt	/*expr-!*
+expr-!=	eval.txt	/*expr-!=*
+expr-!=#	eval.txt	/*expr-!=#*
+expr-!=?	eval.txt	/*expr-!=?*
+expr-!~	eval.txt	/*expr-!~*
+expr-!~#	eval.txt	/*expr-!~#*
+expr-!~?	eval.txt	/*expr-!~?*
+expr-%	eval.txt	/*expr-%*
+expr-&&	eval.txt	/*expr-&&*
+expr-'	eval.txt	/*expr-'*
+expr-+	eval.txt	/*expr-+*
+expr--	eval.txt	/*expr--*
+expr-.	eval.txt	/*expr-.*
+expr-/	eval.txt	/*expr-\/*
+expr-<	eval.txt	/*expr-<*
+expr-<#	eval.txt	/*expr-<#*
+expr-<=	eval.txt	/*expr-<=*
+expr-<=#	eval.txt	/*expr-<=#*
+expr-<=?	eval.txt	/*expr-<=?*
+expr-<?	eval.txt	/*expr-<?*
+expr-==	eval.txt	/*expr-==*
+expr-==#	eval.txt	/*expr-==#*
+expr-==?	eval.txt	/*expr-==?*
+expr-=~	eval.txt	/*expr-=~*
+expr-=~#	eval.txt	/*expr-=~#*
+expr-=~?	eval.txt	/*expr-=~?*
+expr->	eval.txt	/*expr->*
+expr->#	eval.txt	/*expr->#*
+expr->=	eval.txt	/*expr->=*
+expr->=#	eval.txt	/*expr->=#*
+expr->=?	eval.txt	/*expr->=?*
+expr->?	eval.txt	/*expr->?*
+expr-[:]	eval.txt	/*expr-[:]*
+expr-[]	eval.txt	/*expr-[]*
+expr-barbar	eval.txt	/*expr-barbar*
+expr-entry	eval.txt	/*expr-entry*
+expr-env	eval.txt	/*expr-env*
+expr-env-expand	eval.txt	/*expr-env-expand*
+expr-function	eval.txt	/*expr-function*
+expr-is	eval.txt	/*expr-is*
+expr-is#	eval.txt	/*expr-is#*
+expr-is?	eval.txt	/*expr-is?*
+expr-isnot	eval.txt	/*expr-isnot*
+expr-isnot#	eval.txt	/*expr-isnot#*
+expr-isnot?	eval.txt	/*expr-isnot?*
+expr-lambda	eval.txt	/*expr-lambda*
+expr-nesting	eval.txt	/*expr-nesting*
+expr-number	eval.txt	/*expr-number*
+expr-option	eval.txt	/*expr-option*
+expr-quote	eval.txt	/*expr-quote*
+expr-register	eval.txt	/*expr-register*
+expr-star	eval.txt	/*expr-star*
+expr-string	eval.txt	/*expr-string*
+expr-unary-+	eval.txt	/*expr-unary-+*
+expr-unary--	eval.txt	/*expr-unary--*
+expr-variable	eval.txt	/*expr-variable*
+expr1	eval.txt	/*expr1*
+expr2	eval.txt	/*expr2*
+expr3	eval.txt	/*expr3*
+expr4	eval.txt	/*expr4*
+expr5	eval.txt	/*expr5*
+expr6	eval.txt	/*expr6*
+expr7	eval.txt	/*expr7*
+expr8	eval.txt	/*expr8*
+expr9	eval.txt	/*expr9*
+expression	eval.txt	/*expression*
+expression-commands	eval.txt	/*expression-commands*
+expression-syntax	eval.txt	/*expression-syntax*
+exrc	starting.txt	/*exrc*
+extend()	eval.txt	/*extend()*
+extension-removal	cmdline.txt	/*extension-removal*
+extensions-improvements	todo.txt	/*extensions-improvements*
+f	motion.txt	/*f*
+false-variable	eval.txt	/*false-variable*
+faq	intro.txt	/*faq*
+farsi	farsi.txt	/*farsi*
+farsi-fonts	farsi.txt	/*farsi-fonts*
+farsi.txt	farsi.txt	/*farsi.txt*
+fasm.vim	syntax.txt	/*fasm.vim*
+fcs_choice-variable	eval.txt	/*fcs_choice-variable*
+fcs_reason-variable	eval.txt	/*fcs_reason-variable*
+feature-list	eval.txt	/*feature-list*
+feedkeys()	eval.txt	/*feedkeys()*
+fetch	pi_netrw.txt	/*fetch*
+file-browser-5.2	version5.txt	/*file-browser-5.2*
+file-formats	editing.txt	/*file-formats*
+file-functions	usr_41.txt	/*file-functions*
+file-pattern	autocmd.txt	/*file-pattern*
+file-read	insert.txt	/*file-read*
+file-searching	editing.txt	/*file-searching*
+file-type	filetype.txt	/*file-type*
+file-types	filetype.txt	/*file-types*
+file_readable()	eval.txt	/*file_readable()*
+fileencoding-changed	version6.txt	/*fileencoding-changed*
+filename-backslash	cmdline.txt	/*filename-backslash*
+filename-modifiers	cmdline.txt	/*filename-modifiers*
+filereadable()	eval.txt	/*filereadable()*
+filetype	filetype.txt	/*filetype*
+filetype-detect	filetype.txt	/*filetype-detect*
+filetype-ignore	filetype.txt	/*filetype-ignore*
+filetype-overrule	filetype.txt	/*filetype-overrule*
+filetype-plugin	usr_43.txt	/*filetype-plugin*
+filetype-plugins	filetype.txt	/*filetype-plugins*
+filetype.txt	filetype.txt	/*filetype.txt*
+filetypedetect-changed	version6.txt	/*filetypedetect-changed*
+filetypes	filetype.txt	/*filetypes*
+filewritable()	eval.txt	/*filewritable()*
+filter	change.txt	/*filter*
+filter()	eval.txt	/*filter()*
+find-manpage	usr_12.txt	/*find-manpage*
+find-replace	usr_10.txt	/*find-replace*
+finddir()	eval.txt	/*finddir()*
+findfile()	eval.txt	/*findfile()*
+fixed-5.1	version5.txt	/*fixed-5.1*
+fixed-5.2	version5.txt	/*fixed-5.2*
+fixed-5.3	version5.txt	/*fixed-5.3*
+fixed-5.4	version5.txt	/*fixed-5.4*
+fixed-5.5	version5.txt	/*fixed-5.5*
+fixed-5.6	version5.txt	/*fixed-5.6*
+fixed-5.7	version5.txt	/*fixed-5.7*
+fixed-5.8	version5.txt	/*fixed-5.8*
+fixed-6.1	version6.txt	/*fixed-6.1*
+fixed-6.2	version6.txt	/*fixed-6.2*
+fixed-6.3	version6.txt	/*fixed-6.3*
+fixed-6.4	version6.txt	/*fixed-6.4*
+fixed-7.1	version7.txt	/*fixed-7.1*
+fixed-7.2	version7.txt	/*fixed-7.2*
+fixed-7.3	version7.txt	/*fixed-7.3*
+fixed-7.4	version7.txt	/*fixed-7.4*
+flexwiki.vim	syntax.txt	/*flexwiki.vim*
+float-e	eval.txt	/*float-e*
+float-functions	usr_41.txt	/*float-functions*
+float-pi	eval.txt	/*float-pi*
+float2nr()	eval.txt	/*float2nr()*
+floating-point-format	eval.txt	/*floating-point-format*
+floating-point-precision	eval.txt	/*floating-point-precision*
+floor()	eval.txt	/*floor()*
+fmod()	eval.txt	/*fmod()*
+fname_diff-variable	eval.txt	/*fname_diff-variable*
+fname_in-variable	eval.txt	/*fname_in-variable*
+fname_new-variable	eval.txt	/*fname_new-variable*
+fname_out-variable	eval.txt	/*fname_out-variable*
+fnameescape()	eval.txt	/*fnameescape()*
+fnamemodify()	eval.txt	/*fnamemodify()*
+fo-table	change.txt	/*fo-table*
+fold-behavior	fold.txt	/*fold-behavior*
+fold-colors	fold.txt	/*fold-colors*
+fold-commands	fold.txt	/*fold-commands*
+fold-create-marker	fold.txt	/*fold-create-marker*
+fold-delete-marker	fold.txt	/*fold-delete-marker*
+fold-diff	fold.txt	/*fold-diff*
+fold-expr	fold.txt	/*fold-expr*
+fold-foldcolumn	fold.txt	/*fold-foldcolumn*
+fold-foldlevel	fold.txt	/*fold-foldlevel*
+fold-foldtext	fold.txt	/*fold-foldtext*
+fold-indent	fold.txt	/*fold-indent*
+fold-manual	fold.txt	/*fold-manual*
+fold-marker	fold.txt	/*fold-marker*
+fold-methods	fold.txt	/*fold-methods*
+fold-options	fold.txt	/*fold-options*
+fold-syntax	fold.txt	/*fold-syntax*
+fold.txt	fold.txt	/*fold.txt*
+foldclosed()	eval.txt	/*foldclosed()*
+foldclosedend()	eval.txt	/*foldclosedend()*
+folddashes-variable	eval.txt	/*folddashes-variable*
+foldend-variable	eval.txt	/*foldend-variable*
+folding	fold.txt	/*folding*
+folding-functions	usr_41.txt	/*folding-functions*
+foldlevel()	eval.txt	/*foldlevel()*
+foldlevel-variable	eval.txt	/*foldlevel-variable*
+folds	fold.txt	/*folds*
+foldstart-variable	eval.txt	/*foldstart-variable*
+foldtext()	eval.txt	/*foldtext()*
+foldtextresult()	eval.txt	/*foldtextresult()*
+font-sizes	gui_x11.txt	/*font-sizes*
+fontset	mbyte.txt	/*fontset*
+foreground()	eval.txt	/*foreground()*
+fork	os_unix.txt	/*fork*
+form.vim	syntax.txt	/*form.vim*
+format-bullet-list	tips.txt	/*format-bullet-list*
+format-comments	change.txt	/*format-comments*
+format-formatexpr	change.txt	/*format-formatexpr*
+formatting	change.txt	/*formatting*
+formfeed	intro.txt	/*formfeed*
+fortran.vim	syntax.txt	/*fortran.vim*
+friendship	intro.txt	/*friendship*
+frombook	usr_01.txt	/*frombook*
+ft-abel-syntax	syntax.txt	/*ft-abel-syntax*
+ft-ada-commands	ft_ada.txt	/*ft-ada-commands*
+ft-ada-constants	ft_ada.txt	/*ft-ada-constants*
+ft-ada-functions	ft_ada.txt	/*ft-ada-functions*
+ft-ada-indent	ft_ada.txt	/*ft-ada-indent*
+ft-ada-omni	ft_ada.txt	/*ft-ada-omni*
+ft-ada-options	ft_ada.txt	/*ft-ada-options*
+ft-ada-plugin	ft_ada.txt	/*ft-ada-plugin*
+ft-ada-syntax	ft_ada.txt	/*ft-ada-syntax*
+ft-ada-variables	ft_ada.txt	/*ft-ada-variables*
+ft-ant-syntax	syntax.txt	/*ft-ant-syntax*
+ft-apache-syntax	syntax.txt	/*ft-apache-syntax*
+ft-asm-syntax	syntax.txt	/*ft-asm-syntax*
+ft-asm68k-syntax	syntax.txt	/*ft-asm68k-syntax*
+ft-asmh8300-syntax	syntax.txt	/*ft-asmh8300-syntax*
+ft-aspperl-syntax	syntax.txt	/*ft-aspperl-syntax*
+ft-aspvbs-syntax	syntax.txt	/*ft-aspvbs-syntax*
+ft-bash-syntax	syntax.txt	/*ft-bash-syntax*
+ft-basic-syntax	syntax.txt	/*ft-basic-syntax*
+ft-c-omni	insert.txt	/*ft-c-omni*
+ft-c-syntax	syntax.txt	/*ft-c-syntax*
+ft-ch-syntax	syntax.txt	/*ft-ch-syntax*
+ft-changelog-plugin	filetype.txt	/*ft-changelog-plugin*
+ft-changelog-syntax	syntax.txt	/*ft-changelog-syntax*
+ft-chill-syntax	syntax.txt	/*ft-chill-syntax*
+ft-clojure-indent	indent.txt	/*ft-clojure-indent*
+ft-clojure-syntax	syntax.txt	/*ft-clojure-syntax*
+ft-cobol-syntax	syntax.txt	/*ft-cobol-syntax*
+ft-coldfusion-syntax	syntax.txt	/*ft-coldfusion-syntax*
+ft-cpp-syntax	syntax.txt	/*ft-cpp-syntax*
+ft-csh-syntax	syntax.txt	/*ft-csh-syntax*
+ft-css-omni	insert.txt	/*ft-css-omni*
+ft-cweb-syntax	syntax.txt	/*ft-cweb-syntax*
+ft-cynlib-syntax	syntax.txt	/*ft-cynlib-syntax*
+ft-dash-syntax	syntax.txt	/*ft-dash-syntax*
+ft-desktop-syntax	syntax.txt	/*ft-desktop-syntax*
+ft-dircolors-syntax	syntax.txt	/*ft-dircolors-syntax*
+ft-docbk-syntax	syntax.txt	/*ft-docbk-syntax*
+ft-docbksgml-syntax	syntax.txt	/*ft-docbksgml-syntax*
+ft-docbkxml-syntax	syntax.txt	/*ft-docbkxml-syntax*
+ft-dosbatch-syntax	syntax.txt	/*ft-dosbatch-syntax*
+ft-dtd-syntax	syntax.txt	/*ft-dtd-syntax*
+ft-eiffel-syntax	syntax.txt	/*ft-eiffel-syntax*
+ft-erlang-syntax	syntax.txt	/*ft-erlang-syntax*
+ft-euphoria-syntax	syntax.txt	/*ft-euphoria-syntax*
+ft-flexwiki-syntax	syntax.txt	/*ft-flexwiki-syntax*
+ft-form-syntax	syntax.txt	/*ft-form-syntax*
+ft-fortran-indent	indent.txt	/*ft-fortran-indent*
+ft-fortran-plugin	filetype.txt	/*ft-fortran-plugin*
+ft-fortran-syntax	syntax.txt	/*ft-fortran-syntax*
+ft-fvwm-syntax	syntax.txt	/*ft-fvwm-syntax*
+ft-gitcommit-plugin	filetype.txt	/*ft-gitcommit-plugin*
+ft-groff-syntax	syntax.txt	/*ft-groff-syntax*
+ft-gsp-syntax	syntax.txt	/*ft-gsp-syntax*
+ft-haskell-syntax	syntax.txt	/*ft-haskell-syntax*
+ft-html-indent	indent.txt	/*ft-html-indent*
+ft-html-omni	insert.txt	/*ft-html-omni*
+ft-html-syntax	syntax.txt	/*ft-html-syntax*
+ft-htmlos-syntax	syntax.txt	/*ft-htmlos-syntax*
+ft-ia64-syntax	syntax.txt	/*ft-ia64-syntax*
+ft-inform-syntax	syntax.txt	/*ft-inform-syntax*
+ft-java-syntax	syntax.txt	/*ft-java-syntax*
+ft-javascript-omni	insert.txt	/*ft-javascript-omni*
+ft-ksh-syntax	syntax.txt	/*ft-ksh-syntax*
+ft-lace-syntax	syntax.txt	/*ft-lace-syntax*
+ft-lex-syntax	syntax.txt	/*ft-lex-syntax*
+ft-lifelines-syntax	syntax.txt	/*ft-lifelines-syntax*
+ft-lisp-syntax	syntax.txt	/*ft-lisp-syntax*
+ft-lite-syntax	syntax.txt	/*ft-lite-syntax*
+ft-lpc-syntax	syntax.txt	/*ft-lpc-syntax*
+ft-lua-syntax	syntax.txt	/*ft-lua-syntax*
+ft-mail-plugin	filetype.txt	/*ft-mail-plugin*
+ft-mail.vim	syntax.txt	/*ft-mail.vim*
+ft-make-syntax	syntax.txt	/*ft-make-syntax*
+ft-man-plugin	filetype.txt	/*ft-man-plugin*
+ft-maple-syntax	syntax.txt	/*ft-maple-syntax*
+ft-masm-syntax	syntax.txt	/*ft-masm-syntax*
+ft-mathematica-syntax	syntax.txt	/*ft-mathematica-syntax*
+ft-mma-syntax	syntax.txt	/*ft-mma-syntax*
+ft-moo-syntax	syntax.txt	/*ft-moo-syntax*
+ft-msql-syntax	syntax.txt	/*ft-msql-syntax*
+ft-n1ql-syntax	syntax.txt	/*ft-n1ql-syntax*
+ft-nasm-syntax	syntax.txt	/*ft-nasm-syntax*
+ft-ncf-syntax	syntax.txt	/*ft-ncf-syntax*
+ft-nroff-syntax	syntax.txt	/*ft-nroff-syntax*
+ft-ocaml-syntax	syntax.txt	/*ft-ocaml-syntax*
+ft-papp-syntax	syntax.txt	/*ft-papp-syntax*
+ft-pascal-syntax	syntax.txt	/*ft-pascal-syntax*
+ft-pdf-plugin	filetype.txt	/*ft-pdf-plugin*
+ft-perl-syntax	syntax.txt	/*ft-perl-syntax*
+ft-php-indent	indent.txt	/*ft-php-indent*
+ft-php-omni	insert.txt	/*ft-php-omni*
+ft-php-syntax	syntax.txt	/*ft-php-syntax*
+ft-php3-syntax	syntax.txt	/*ft-php3-syntax*
+ft-phtml-syntax	syntax.txt	/*ft-phtml-syntax*
+ft-plaintex-syntax	syntax.txt	/*ft-plaintex-syntax*
+ft-posix-synax	syntax.txt	/*ft-posix-synax*
+ft-postscr-syntax	syntax.txt	/*ft-postscr-syntax*
+ft-ppwiz-syntax	syntax.txt	/*ft-ppwiz-syntax*
+ft-printcap-syntax	syntax.txt	/*ft-printcap-syntax*
+ft-progress-syntax	syntax.txt	/*ft-progress-syntax*
+ft-ptcap-syntax	syntax.txt	/*ft-ptcap-syntax*
+ft-python-indent	indent.txt	/*ft-python-indent*
+ft-python-plugin	filetype.txt	/*ft-python-plugin*
+ft-python-syntax	syntax.txt	/*ft-python-syntax*
+ft-quake-syntax	syntax.txt	/*ft-quake-syntax*
+ft-r-indent	indent.txt	/*ft-r-indent*
+ft-r-syntax	syntax.txt	/*ft-r-syntax*
+ft-readline-syntax	syntax.txt	/*ft-readline-syntax*
+ft-rexx-syntax	syntax.txt	/*ft-rexx-syntax*
+ft-rmd-plugin	filetype.txt	/*ft-rmd-plugin*
+ft-rmd-syntax	syntax.txt	/*ft-rmd-syntax*
+ft-rrst-plugin	filetype.txt	/*ft-rrst-plugin*
+ft-rrst-syntax	syntax.txt	/*ft-rrst-syntax*
+ft-rst-syntax	syntax.txt	/*ft-rst-syntax*
+ft-ruby-omni	insert.txt	/*ft-ruby-omni*
+ft-ruby-syntax	syntax.txt	/*ft-ruby-syntax*
+ft-rust	filetype.txt	/*ft-rust*
+ft-scheme-syntax	syntax.txt	/*ft-scheme-syntax*
+ft-sdl-syntax	syntax.txt	/*ft-sdl-syntax*
+ft-sed-syntax	syntax.txt	/*ft-sed-syntax*
+ft-sgml-syntax	syntax.txt	/*ft-sgml-syntax*
+ft-sh-indent	indent.txt	/*ft-sh-indent*
+ft-sh-syntax	syntax.txt	/*ft-sh-syntax*
+ft-spec-plugin	filetype.txt	/*ft-spec-plugin*
+ft-spup-syntax	syntax.txt	/*ft-spup-syntax*
+ft-sql	filetype.txt	/*ft-sql*
+ft-sql-omni	insert.txt	/*ft-sql-omni*
+ft-sql-syntax	syntax.txt	/*ft-sql-syntax*
+ft-sqlanywhere-syntax	syntax.txt	/*ft-sqlanywhere-syntax*
+ft-sqlinformix-syntax	syntax.txt	/*ft-sqlinformix-syntax*
+ft-syntax-omni	insert.txt	/*ft-syntax-omni*
+ft-tcsh-syntax	syntax.txt	/*ft-tcsh-syntax*
+ft-termcap-syntax	syntax.txt	/*ft-termcap-syntax*
+ft-tex-plugin	filetype.txt	/*ft-tex-plugin*
+ft-tex-syntax	syntax.txt	/*ft-tex-syntax*
+ft-tf-syntax	syntax.txt	/*ft-tf-syntax*
+ft-vb-syntax	syntax.txt	/*ft-vb-syntax*
+ft-verilog-indent	indent.txt	/*ft-verilog-indent*
+ft-vhdl-indent	indent.txt	/*ft-vhdl-indent*
+ft-vim-indent	indent.txt	/*ft-vim-indent*
+ft-vim-plugin	filetype.txt	/*ft-vim-plugin*
+ft-vim-syntax	syntax.txt	/*ft-vim-syntax*
+ft-xf86conf-syntax	syntax.txt	/*ft-xf86conf-syntax*
+ft-xhtml-omni	insert.txt	/*ft-xhtml-omni*
+ft-xml-omni	insert.txt	/*ft-xml-omni*
+ft-xml-syntax	syntax.txt	/*ft-xml-syntax*
+ft-xpm-syntax	syntax.txt	/*ft-xpm-syntax*
+ft-yaml-syntax	syntax.txt	/*ft-yaml-syntax*
+ft-zimbu-plugin	filetype.txt	/*ft-zimbu-plugin*
+ft-zsh-syntax	syntax.txt	/*ft-zsh-syntax*
+ft_ada.txt	ft_ada.txt	/*ft_ada.txt*
+ft_rust.txt	ft_rust.txt	/*ft_rust.txt*
+ft_sql.txt	ft_sql.txt	/*ft_sql.txt*
+ftdetect	filetype.txt	/*ftdetect*
+ftp	pi_netrw.txt	/*ftp*
+ftplugin	usr_41.txt	/*ftplugin*
+ftplugin-docs	filetype.txt	/*ftplugin-docs*
+ftplugin-name	usr_05.txt	/*ftplugin-name*
+ftplugin-overrule	filetype.txt	/*ftplugin-overrule*
+ftplugin-special	usr_41.txt	/*ftplugin-special*
+ftplugins	usr_05.txt	/*ftplugins*
+funcref()	eval.txt	/*funcref()*
+function()	eval.txt	/*function()*
+function-argument	eval.txt	/*function-argument*
+function-key	intro.txt	/*function-key*
+function-list	usr_41.txt	/*function-list*
+function-range-example	eval.txt	/*function-range-example*
+function-search-undo	eval.txt	/*function-search-undo*
+function_key	intro.txt	/*function_key*
+functions	eval.txt	/*functions*
+fvwm.vim	syntax.txt	/*fvwm.vim*
+fvwm2rc	syntax.txt	/*fvwm2rc*
+fvwmrc	syntax.txt	/*fvwmrc*
+g	index.txt	/*g*
+g#	pattern.txt	/*g#*
+g$	motion.txt	/*g$*
+g&	change.txt	/*g&*
+g'	motion.txt	/*g'*
+g'a	motion.txt	/*g'a*
+g+	undo.txt	/*g+*
+g,	motion.txt	/*g,*
+g-	undo.txt	/*g-*
+g0	motion.txt	/*g0*
+g8	various.txt	/*g8*
+g:	eval.txt	/*g:*
+g:NetrwTopLvlMenu	pi_netrw.txt	/*g:NetrwTopLvlMenu*
+g:Netrw_UserMaps	pi_netrw.txt	/*g:Netrw_UserMaps*
+g:Netrw_corehandler	pi_netrw.txt	/*g:Netrw_corehandler*
+g:Netrw_funcref	pi_netrw.txt	/*g:Netrw_funcref*
+g:actual_curbuf	options.txt	/*g:actual_curbuf*
+g:ada#Comment	ft_ada.txt	/*g:ada#Comment*
+g:ada#Ctags_Kinds	ft_ada.txt	/*g:ada#Ctags_Kinds*
+g:ada#DotWordRegex	ft_ada.txt	/*g:ada#DotWordRegex*
+g:ada#Keywords	ft_ada.txt	/*g:ada#Keywords*
+g:ada#WordRegex	ft_ada.txt	/*g:ada#WordRegex*
+g:ada_abbrev	ft_ada.txt	/*g:ada_abbrev*
+g:ada_all_tab_usage	ft_ada.txt	/*g:ada_all_tab_usage*
+g:ada_begin_preproc	ft_ada.txt	/*g:ada_begin_preproc*
+g:ada_default_compiler	ft_ada.txt	/*g:ada_default_compiler*
+g:ada_extended_completion	ft_ada.txt	/*g:ada_extended_completion*
+g:ada_extended_tagging	ft_ada.txt	/*g:ada_extended_tagging*
+g:ada_folding	ft_ada.txt	/*g:ada_folding*
+g:ada_gnat_extensions	ft_ada.txt	/*g:ada_gnat_extensions*
+g:ada_line_errors	ft_ada.txt	/*g:ada_line_errors*
+g:ada_no_tab_space_error	ft_ada.txt	/*g:ada_no_tab_space_error*
+g:ada_no_trail_space_error	ft_ada.txt	/*g:ada_no_trail_space_error*
+g:ada_omni_with_keywords	ft_ada.txt	/*g:ada_omni_with_keywords*
+g:ada_rainbow_color	ft_ada.txt	/*g:ada_rainbow_color*
+g:ada_space_errors	ft_ada.txt	/*g:ada_space_errors*
+g:ada_standard_types	ft_ada.txt	/*g:ada_standard_types*
+g:ada_with_gnat_project_files	ft_ada.txt	/*g:ada_with_gnat_project_files*
+g:ada_withuse_ordinary	ft_ada.txt	/*g:ada_withuse_ordinary*
+g:clojure_align_multiline_strings	indent.txt	/*g:clojure_align_multiline_strings*
+g:clojure_align_subforms	indent.txt	/*g:clojure_align_subforms*
+g:clojure_fold	syntax.txt	/*g:clojure_fold*
+g:clojure_fuzzy_indent	indent.txt	/*g:clojure_fuzzy_indent*
+g:clojure_fuzzy_indent_blacklist	indent.txt	/*g:clojure_fuzzy_indent_blacklist*
+g:clojure_fuzzy_indent_patterns	indent.txt	/*g:clojure_fuzzy_indent_patterns*
+g:clojure_maxlines	indent.txt	/*g:clojure_maxlines*
+g:clojure_special_indent_words	indent.txt	/*g:clojure_special_indent_words*
+g:clojure_syntax_keywords	syntax.txt	/*g:clojure_syntax_keywords*
+g:colors_name	options.txt	/*g:colors_name*
+g:decada	ft_ada.txt	/*g:decada*
+g:decada.Error_Format	ft_ada.txt	/*g:decada.Error_Format*
+g:decada.Make()	ft_ada.txt	/*g:decada.Make()*
+g:decada.Make_Command	ft_ada.txt	/*g:decada.Make_Command*
+g:decada.Unit_Name()	ft_ada.txt	/*g:decada.Unit_Name()*
+g:filetype_csh	syntax.txt	/*g:filetype_csh*
+g:filetype_r	syntax.txt	/*g:filetype_r*
+g:ftplugin_rust_source_path	ft_rust.txt	/*g:ftplugin_rust_source_path*
+g:gnat	ft_ada.txt	/*g:gnat*
+g:gnat.Error_Format	ft_ada.txt	/*g:gnat.Error_Format*
+g:gnat.Find()	ft_ada.txt	/*g:gnat.Find()*
+g:gnat.Find_Program	ft_ada.txt	/*g:gnat.Find_Program*
+g:gnat.Make()	ft_ada.txt	/*g:gnat.Make()*
+g:gnat.Make_Command	ft_ada.txt	/*g:gnat.Make_Command*
+g:gnat.Pretty()	ft_ada.txt	/*g:gnat.Pretty()*
+g:gnat.Pretty_Program	ft_ada.txt	/*g:gnat.Pretty_Program*
+g:gnat.Project_File	ft_ada.txt	/*g:gnat.Project_File*
+g:gnat.Set_Project_File()	ft_ada.txt	/*g:gnat.Set_Project_File()*
+g:gnat.Tags()	ft_ada.txt	/*g:gnat.Tags()*
+g:gnat.Tags_Command	ft_ada.txt	/*g:gnat.Tags_Command*
+g:html_charset_override	syntax.txt	/*g:html_charset_override*
+g:html_diff_one_file	syntax.txt	/*g:html_diff_one_file*
+g:html_dynamic_folds	syntax.txt	/*g:html_dynamic_folds*
+g:html_encoding_override	syntax.txt	/*g:html_encoding_override*
+g:html_end_line	syntax.txt	/*g:html_end_line*
+g:html_expand_tabs	syntax.txt	/*g:html_expand_tabs*
+g:html_font	syntax.txt	/*g:html_font*
+g:html_hover_unfold	syntax.txt	/*g:html_hover_unfold*
+g:html_id_expr	syntax.txt	/*g:html_id_expr*
+g:html_ignore_conceal	syntax.txt	/*g:html_ignore_conceal*
+g:html_ignore_folding	syntax.txt	/*g:html_ignore_folding*
+g:html_line_ids	syntax.txt	/*g:html_line_ids*
+g:html_no_foldcolumn	syntax.txt	/*g:html_no_foldcolumn*
+g:html_no_invalid	syntax.txt	/*g:html_no_invalid*
+g:html_no_pre	syntax.txt	/*g:html_no_pre*
+g:html_no_progress	syntax.txt	/*g:html_no_progress*
+g:html_number_lines	syntax.txt	/*g:html_number_lines*
+g:html_pre_wrap	syntax.txt	/*g:html_pre_wrap*
+g:html_prevent_copy	syntax.txt	/*g:html_prevent_copy*
+g:html_start_line	syntax.txt	/*g:html_start_line*
+g:html_use_css	syntax.txt	/*g:html_use_css*
+g:html_use_encoding	syntax.txt	/*g:html_use_encoding*
+g:html_use_xhtml	syntax.txt	/*g:html_use_xhtml*
+g:html_whole_filler	syntax.txt	/*g:html_whole_filler*
+g:netrw_altfile	pi_netrw.txt	/*g:netrw_altfile*
+g:netrw_alto	pi_netrw.txt	/*g:netrw_alto*
+g:netrw_altv	pi_netrw.txt	/*g:netrw_altv*
+g:netrw_banner	pi_netrw.txt	/*g:netrw_banner*
+g:netrw_bannerbackslash	pi_netrw.txt	/*g:netrw_bannerbackslash*
+g:netrw_browse_split	pi_netrw.txt	/*g:netrw_browse_split*
+g:netrw_browsex_viewer	pi_netrw.txt	/*g:netrw_browsex_viewer*
+g:netrw_bufsettings	pi_netrw.txt	/*g:netrw_bufsettings*
+g:netrw_chgperm	pi_netrw.txt	/*g:netrw_chgperm*
+g:netrw_chgwin	pi_netrw.txt	/*g:netrw_chgwin*
+g:netrw_compress	pi_netrw.txt	/*g:netrw_compress*
+g:netrw_ctags	pi_netrw.txt	/*g:netrw_ctags*
+g:netrw_cursor	pi_netrw.txt	/*g:netrw_cursor*
+g:netrw_cygwin	pi_netrw.txt	/*g:netrw_cygwin*
+g:netrw_dav_cmd	pi_netrw.txt	/*g:netrw_dav_cmd*
+g:netrw_decompress	pi_netrw.txt	/*g:netrw_decompress*
+g:netrw_dirhistmax	pi_netrw.txt	/*g:netrw_dirhistmax*
+g:netrw_dynamic_maxfilenamelen	pi_netrw.txt	/*g:netrw_dynamic_maxfilenamelen*
+g:netrw_errorlvl	pi_netrw.txt	/*g:netrw_errorlvl*
+g:netrw_fastbrowse	pi_netrw.txt	/*g:netrw_fastbrowse*
+g:netrw_fetch_cmd	pi_netrw.txt	/*g:netrw_fetch_cmd*
+g:netrw_ffkeep	pi_netrw.txt	/*g:netrw_ffkeep*
+g:netrw_file_cmd	pi_netrw.txt	/*g:netrw_file_cmd*
+g:netrw_fname_escape	pi_netrw.txt	/*g:netrw_fname_escape*
+g:netrw_ftp	pi_netrw.txt	/*g:netrw_ftp*
+g:netrw_ftp_browse_reject	pi_netrw.txt	/*g:netrw_ftp_browse_reject*
+g:netrw_ftp_cmd	pi_netrw.txt	/*g:netrw_ftp_cmd*
+g:netrw_ftp_list_cmd	pi_netrw.txt	/*g:netrw_ftp_list_cmd*
+g:netrw_ftp_options	pi_netrw.txt	/*g:netrw_ftp_options*
+g:netrw_ftp_sizelist_cmd	pi_netrw.txt	/*g:netrw_ftp_sizelist_cmd*
+g:netrw_ftp_timelist_cmd	pi_netrw.txt	/*g:netrw_ftp_timelist_cmd*
+g:netrw_ftpextracmd	pi_netrw.txt	/*g:netrw_ftpextracmd*
+g:netrw_ftpmode	pi_netrw.txt	/*g:netrw_ftpmode*
+g:netrw_glob_escape	pi_netrw.txt	/*g:netrw_glob_escape*
+g:netrw_gx	pi_netrw.txt	/*g:netrw_gx*
+g:netrw_hide	pi_netrw.txt	/*g:netrw_hide*
+g:netrw_home	pi_netrw.txt	/*g:netrw_home*
+g:netrw_http_cmd	pi_netrw.txt	/*g:netrw_http_cmd*
+g:netrw_http_put_cmd	pi_netrw.txt	/*g:netrw_http_put_cmd*
+g:netrw_http_xcmd	pi_netrw.txt	/*g:netrw_http_xcmd*
+g:netrw_ignorenetrc	pi_netrw.txt	/*g:netrw_ignorenetrc*
+g:netrw_keepdir	pi_netrw.txt	/*g:netrw_keepdir*
+g:netrw_keepj	pi_netrw.txt	/*g:netrw_keepj*
+g:netrw_list_cmd	pi_netrw.txt	/*g:netrw_list_cmd*
+g:netrw_list_cmd_options	pi_netrw.txt	/*g:netrw_list_cmd_options*
+g:netrw_list_hide	pi_netrw.txt	/*g:netrw_list_hide*
+g:netrw_liststyle	pi_netrw.txt	/*g:netrw_liststyle*
+g:netrw_localcopycmd	pi_netrw.txt	/*g:netrw_localcopycmd*
+g:netrw_localcopycmdopt	pi_netrw.txt	/*g:netrw_localcopycmdopt*
+g:netrw_localcopydircmd	pi_netrw.txt	/*g:netrw_localcopydircmd*
+g:netrw_localcopydircmdopt	pi_netrw.txt	/*g:netrw_localcopydircmdopt*
+g:netrw_localmkdir	pi_netrw.txt	/*g:netrw_localmkdir*
+g:netrw_localmkdiropt	pi_netrw.txt	/*g:netrw_localmkdiropt*
+g:netrw_localmovecmd	pi_netrw.txt	/*g:netrw_localmovecmd*
+g:netrw_localmovecmdopt	pi_netrw.txt	/*g:netrw_localmovecmdopt*
+g:netrw_localrmdir	pi_netrw.txt	/*g:netrw_localrmdir*
+g:netrw_localrmdiropt	pi_netrw.txt	/*g:netrw_localrmdiropt*
+g:netrw_maxfilenamelen	pi_netrw.txt	/*g:netrw_maxfilenamelen*
+g:netrw_menu	pi_netrw.txt	/*g:netrw_menu*
+g:netrw_mkdir_cmd	pi_netrw.txt	/*g:netrw_mkdir_cmd*
+g:netrw_mousemaps	pi_netrw.txt	/*g:netrw_mousemaps*
+g:netrw_nobeval	pi_netrw.txt	/*g:netrw_nobeval*
+g:netrw_nogx	pi_netrw.txt	/*g:netrw_nogx*
+g:netrw_preview	pi_netrw.txt	/*g:netrw_preview*
+g:netrw_rcp_cmd	pi_netrw.txt	/*g:netrw_rcp_cmd*
+g:netrw_remote_mkdir	pi_netrw.txt	/*g:netrw_remote_mkdir*
+g:netrw_rename_cmd	pi_netrw.txt	/*g:netrw_rename_cmd*
+g:netrw_retmap	pi_netrw.txt	/*g:netrw_retmap*
+g:netrw_rm_cmd	pi_netrw.txt	/*g:netrw_rm_cmd*
+g:netrw_rmdir_cmd	pi_netrw.txt	/*g:netrw_rmdir_cmd*
+g:netrw_rmf_cmd	pi_netrw.txt	/*g:netrw_rmf_cmd*
+g:netrw_rsync_cmd	pi_netrw.txt	/*g:netrw_rsync_cmd*
+g:netrw_rsync_sep	pi_netrw.txt	/*g:netrw_rsync_sep*
+g:netrw_scp_cmd	pi_netrw.txt	/*g:netrw_scp_cmd*
+g:netrw_scpport	pi_netrw.txt	/*g:netrw_scpport*
+g:netrw_sepchr	pi_netrw.txt	/*g:netrw_sepchr*
+g:netrw_servername	pi_netrw.txt	/*g:netrw_servername*
+g:netrw_sftp_cmd	pi_netrw.txt	/*g:netrw_sftp_cmd*
+g:netrw_silent	pi_netrw.txt	/*g:netrw_silent*
+g:netrw_sizestyle	pi_netrw.txt	/*g:netrw_sizestyle*
+g:netrw_sort_by	pi_netrw.txt	/*g:netrw_sort_by*
+g:netrw_sort_direction	pi_netrw.txt	/*g:netrw_sort_direction*
+g:netrw_sort_options	pi_netrw.txt	/*g:netrw_sort_options*
+g:netrw_sort_sequence	pi_netrw.txt	/*g:netrw_sort_sequence*
+g:netrw_special_syntax	pi_netrw.txt	/*g:netrw_special_syntax*
+g:netrw_ssh_browse_reject	pi_netrw.txt	/*g:netrw_ssh_browse_reject*
+g:netrw_ssh_cmd	pi_netrw.txt	/*g:netrw_ssh_cmd*
+g:netrw_sshport	pi_netrw.txt	/*g:netrw_sshport*
+g:netrw_suppress_gx_mesg	pi_netrw.txt	/*g:netrw_suppress_gx_mesg*
+g:netrw_timefmt	pi_netrw.txt	/*g:netrw_timefmt*
+g:netrw_tmpfile_escape	pi_netrw.txt	/*g:netrw_tmpfile_escape*
+g:netrw_uid	pi_netrw.txt	/*g:netrw_uid*
+g:netrw_use_errorwindow	pi_netrw.txt	/*g:netrw_use_errorwindow*
+g:netrw_use_noswf	pi_netrw.txt	/*g:netrw_use_noswf*
+g:netrw_use_nt_rcp	pi_netrw.txt	/*g:netrw_use_nt_rcp*
+g:netrw_usetab	pi_netrw.txt	/*g:netrw_usetab*
+g:netrw_win95ftp	pi_netrw.txt	/*g:netrw_win95ftp*
+g:netrw_winsize	pi_netrw.txt	/*g:netrw_winsize*
+g:netrw_wiw	pi_netrw.txt	/*g:netrw_wiw*
+g:netrw_xstrlen	pi_netrw.txt	/*g:netrw_xstrlen*
+g:rust_bang_comment_leader	ft_rust.txt	/*g:rust_bang_comment_leader*
+g:rust_conceal	ft_rust.txt	/*g:rust_conceal*
+g:rust_conceal_mod_path	ft_rust.txt	/*g:rust_conceal_mod_path*
+g:rust_conceal_pub	ft_rust.txt	/*g:rust_conceal_pub*
+g:rust_fold	ft_rust.txt	/*g:rust_fold*
+g:rust_playpen_url	ft_rust.txt	/*g:rust_playpen_url*
+g:rust_recommended_style	ft_rust.txt	/*g:rust_recommended_style*
+g:rust_shortener_url	ft_rust.txt	/*g:rust_shortener_url*
+g:rustc_makeprg_no_percent	ft_rust.txt	/*g:rustc_makeprg_no_percent*
+g:rustc_path	ft_rust.txt	/*g:rustc_path*
+g:rustfmt_autosave	ft_rust.txt	/*g:rustfmt_autosave*
+g:rustfmt_command	ft_rust.txt	/*g:rustfmt_command*
+g:rustfmt_fail_silently	ft_rust.txt	/*g:rustfmt_fail_silently*
+g:rustfmt_options	ft_rust.txt	/*g:rustfmt_options*
+g:syntax_on	syntax.txt	/*g:syntax_on*
+g:tar_browseoptions	pi_tar.txt	/*g:tar_browseoptions*
+g:tar_cmd	pi_tar.txt	/*g:tar_cmd*
+g:tar_copycmd	pi_tar.txt	/*g:tar_copycmd*
+g:tar_extractcmd	pi_tar.txt	/*g:tar_extractcmd*
+g:tar_nomax	pi_tar.txt	/*g:tar_nomax*
+g:tar_readoptions	pi_tar.txt	/*g:tar_readoptions*
+g:tar_secure	pi_tar.txt	/*g:tar_secure*
+g:tar_writeoptions	pi_tar.txt	/*g:tar_writeoptions*
+g:terminal_ansi_colors	terminal.txt	/*g:terminal_ansi_colors*
+g:tex_comment_nospell	syntax.txt	/*g:tex_comment_nospell*
+g:tex_conceal	syntax.txt	/*g:tex_conceal*
+g:tex_fast	syntax.txt	/*g:tex_fast*
+g:tex_flavor	filetype.txt	/*g:tex_flavor*
+g:tex_fold_enabled	syntax.txt	/*g:tex_fold_enabled*
+g:tex_isk	syntax.txt	/*g:tex_isk*
+g:tex_no_error	syntax.txt	/*g:tex_no_error*
+g:tex_nospell	syntax.txt	/*g:tex_nospell*
+g:tex_stylish	syntax.txt	/*g:tex_stylish*
+g:tex_subscripts	syntax.txt	/*g:tex_subscripts*
+g:tex_superscripts	syntax.txt	/*g:tex_superscripts*
+g:tex_verbspell	syntax.txt	/*g:tex_verbspell*
+g:var	eval.txt	/*g:var*
+g:vimball_home	pi_vimball.txt	/*g:vimball_home*
+g:vimball_mkdir	pi_vimball.txt	/*g:vimball_mkdir*
+g:vimsyn_embed	syntax.txt	/*g:vimsyn_embed*
+g:vimsyn_folding	syntax.txt	/*g:vimsyn_folding*
+g:vimsyn_maxlines	syntax.txt	/*g:vimsyn_maxlines*
+g:vimsyn_minlines	syntax.txt	/*g:vimsyn_minlines*
+g:vimsyn_noerror	syntax.txt	/*g:vimsyn_noerror*
+g:yaml_schema	syntax.txt	/*g:yaml_schema*
+g:zipPlugin_ext	pi_zip.txt	/*g:zipPlugin_ext*
+g:zip_extractcmd	pi_zip.txt	/*g:zip_extractcmd*
+g:zip_nomax	pi_zip.txt	/*g:zip_nomax*
+g:zip_shq	pi_zip.txt	/*g:zip_shq*
+g:zip_unzipcmd	pi_zip.txt	/*g:zip_unzipcmd*
+g:zip_zipcmd	pi_zip.txt	/*g:zip_zipcmd*
+g;	motion.txt	/*g;*
+g<	message.txt	/*g<*
+g<Down>	motion.txt	/*g<Down>*
+g<End>	motion.txt	/*g<End>*
+g<Home>	motion.txt	/*g<Home>*
+g<LeftMouse>	tagsrch.txt	/*g<LeftMouse>*
+g<RightMouse>	tagsrch.txt	/*g<RightMouse>*
+g<Up>	motion.txt	/*g<Up>*
+g?	change.txt	/*g?*
+g??	change.txt	/*g??*
+g?g?	change.txt	/*g?g?*
+g@	map.txt	/*g@*
+gD	pattern.txt	/*gD*
+gE	motion.txt	/*gE*
+gF	editing.txt	/*gF*
+gH	visual.txt	/*gH*
+gI	insert.txt	/*gI*
+gJ	change.txt	/*gJ*
+gN	visual.txt	/*gN*
+gP	change.txt	/*gP*
+gQ	intro.txt	/*gQ*
+gR	change.txt	/*gR*
+gT	tabpage.txt	/*gT*
+gU	change.txt	/*gU*
+gUU	change.txt	/*gUU*
+gUgU	change.txt	/*gUgU*
+gV	visual.txt	/*gV*
+g]	tagsrch.txt	/*g]*
+g^	motion.txt	/*g^*
+g_	motion.txt	/*g_*
+g_CTRL-A	various.txt	/*g_CTRL-A*
+g_CTRL-G	editing.txt	/*g_CTRL-G*
+g_CTRL-H	visual.txt	/*g_CTRL-H*
+g_CTRL-]	tagsrch.txt	/*g_CTRL-]*
+g`	motion.txt	/*g`*
+g`a	motion.txt	/*g`a*
+ga	various.txt	/*ga*
+garbagecollect()	eval.txt	/*garbagecollect()*
+gd	pattern.txt	/*gd*
+gdb	debug.txt	/*gdb*
+gdb-version	terminal.txt	/*gdb-version*
+ge	motion.txt	/*ge*
+get()	eval.txt	/*get()*
+get-ms-debuggers	debug.txt	/*get-ms-debuggers*
+getbufinfo()	eval.txt	/*getbufinfo()*
+getbufline()	eval.txt	/*getbufline()*
+getbufvar()	eval.txt	/*getbufvar()*
+getchangelist()	eval.txt	/*getchangelist()*
+getchar()	eval.txt	/*getchar()*
+getcharmod()	eval.txt	/*getcharmod()*
+getcharsearch()	eval.txt	/*getcharsearch()*
+getcmdline()	eval.txt	/*getcmdline()*
+getcmdpos()	eval.txt	/*getcmdpos()*
+getcmdtype()	eval.txt	/*getcmdtype()*
+getcmdwintype()	eval.txt	/*getcmdwintype()*
+getcompletion()	eval.txt	/*getcompletion()*
+getcurpos()	eval.txt	/*getcurpos()*
+getcwd()	eval.txt	/*getcwd()*
+getfontname()	eval.txt	/*getfontname()*
+getfperm()	eval.txt	/*getfperm()*
+getfsize()	eval.txt	/*getfsize()*
+getftime()	eval.txt	/*getftime()*
+getftype()	eval.txt	/*getftype()*
+getjumplist()	eval.txt	/*getjumplist()*
+getlatestvimscripts-install	pi_getscript.txt	/*getlatestvimscripts-install*
+getline()	eval.txt	/*getline()*
+getloclist()	eval.txt	/*getloclist()*
+getmatches()	eval.txt	/*getmatches()*
+getpid()	eval.txt	/*getpid()*
+getpos()	eval.txt	/*getpos()*
+getqflist()	eval.txt	/*getqflist()*
+getqflist-examples	quickfix.txt	/*getqflist-examples*
+getreg()	eval.txt	/*getreg()*
+getregtype()	eval.txt	/*getregtype()*
+getscript	pi_getscript.txt	/*getscript*
+getscript-autoinstall	pi_getscript.txt	/*getscript-autoinstall*
+getscript-data	pi_getscript.txt	/*getscript-data*
+getscript-history	pi_getscript.txt	/*getscript-history*
+getscript-plugins	pi_getscript.txt	/*getscript-plugins*
+getscript-start	pi_getscript.txt	/*getscript-start*
+gettabinfo()	eval.txt	/*gettabinfo()*
+gettabvar()	eval.txt	/*gettabvar()*
+gettabwinvar()	eval.txt	/*gettabwinvar()*
+getwininfo()	eval.txt	/*getwininfo()*
+getwinpos()	eval.txt	/*getwinpos()*
+getwinposx()	eval.txt	/*getwinposx()*
+getwinposy()	eval.txt	/*getwinposy()*
+getwinvar()	eval.txt	/*getwinvar()*
+gex	starting.txt	/*gex*
+gf	editing.txt	/*gf*
+gg	motion.txt	/*gg*
+gh	visual.txt	/*gh*
+gi	insert.txt	/*gi*
+gj	motion.txt	/*gj*
+gk	motion.txt	/*gk*
+glob()	eval.txt	/*glob()*
+glob2regpat()	eval.txt	/*glob2regpat()*
+global-ime	mbyte.txt	/*global-ime*
+global-local	options.txt	/*global-local*
+global-variable	eval.txt	/*global-variable*
+global_markfilelist	pi_netrw.txt	/*global_markfilelist*
+globpath()	eval.txt	/*globpath()*
+glvs	pi_getscript.txt	/*glvs*
+glvs-alg	pi_getscript.txt	/*glvs-alg*
+glvs-algorithm	pi_getscript.txt	/*glvs-algorithm*
+glvs-autoinstall	pi_getscript.txt	/*glvs-autoinstall*
+glvs-contents	pi_getscript.txt	/*glvs-contents*
+glvs-copyright	pi_getscript.txt	/*glvs-copyright*
+glvs-data	pi_getscript.txt	/*glvs-data*
+glvs-dist-install	pi_getscript.txt	/*glvs-dist-install*
+glvs-hist	pi_getscript.txt	/*glvs-hist*
+glvs-install	pi_getscript.txt	/*glvs-install*
+glvs-options	pi_getscript.txt	/*glvs-options*
+glvs-plugins	pi_getscript.txt	/*glvs-plugins*
+glvs-usage	pi_getscript.txt	/*glvs-usage*
+gm	motion.txt	/*gm*
+gn	visual.txt	/*gn*
+gnat#Insert_Tags_Header()	ft_ada.txt	/*gnat#Insert_Tags_Header()*
+gnat#New()	ft_ada.txt	/*gnat#New()*
+gnat-xref	ft_ada.txt	/*gnat-xref*
+gnat_members	ft_ada.txt	/*gnat_members*
+gnome-session	gui_x11.txt	/*gnome-session*
+go	motion.txt	/*go*
+gp	change.txt	/*gp*
+gpm-mouse	term.txt	/*gpm-mouse*
+gq	change.txt	/*gq*
+gqap	change.txt	/*gqap*
+gqgq	change.txt	/*gqgq*
+gqq	change.txt	/*gqq*
+gr	change.txt	/*gr*
+graphic-option-gone	version4.txt	/*graphic-option-gone*
+greek	options.txt	/*greek*
+grep	quickfix.txt	/*grep*
+groff.vim	syntax.txt	/*groff.vim*
+gross-national-happiness	intro.txt	/*gross-national-happiness*
+group-name	syntax.txt	/*group-name*
+gs	various.txt	/*gs*
+gsp.vim	syntax.txt	/*gsp.vim*
+gstar	pattern.txt	/*gstar*
+gt	tabpage.txt	/*gt*
+gtk-css	gui_x11.txt	/*gtk-css*
+gtk-tooltip-colors	gui_x11.txt	/*gtk-tooltip-colors*
+gu	change.txt	/*gu*
+gugu	change.txt	/*gugu*
+gui	gui.txt	/*gui*
+gui-IME	gui.txt	/*gui-IME*
+gui-clipboard	gui_w32.txt	/*gui-clipboard*
+gui-colors	syntax.txt	/*gui-colors*
+gui-extras	gui.txt	/*gui-extras*
+gui-footer	debugger.txt	/*gui-footer*
+gui-fork	gui_x11.txt	/*gui-fork*
+gui-functions	usr_41.txt	/*gui-functions*
+gui-gnome	gui_x11.txt	/*gui-gnome*
+gui-gnome-session	gui_x11.txt	/*gui-gnome-session*
+gui-gtk	gui_x11.txt	/*gui-gtk*
+gui-gtk-socketid	gui_x11.txt	/*gui-gtk-socketid*
+gui-horiz-scroll	gui.txt	/*gui-horiz-scroll*
+gui-init	gui.txt	/*gui-init*
+gui-kde	gui_x11.txt	/*gui-kde*
+gui-mouse	gui.txt	/*gui-mouse*
+gui-mouse-focus	gui.txt	/*gui-mouse-focus*
+gui-mouse-mapping	gui.txt	/*gui-mouse-mapping*
+gui-mouse-modeless	gui.txt	/*gui-mouse-modeless*
+gui-mouse-move	gui.txt	/*gui-mouse-move*
+gui-mouse-select	gui.txt	/*gui-mouse-select*
+gui-mouse-status	gui.txt	/*gui-mouse-status*
+gui-mouse-various	gui.txt	/*gui-mouse-various*
+gui-pty	gui_x11.txt	/*gui-pty*
+gui-pty-erase	gui_x11.txt	/*gui-pty-erase*
+gui-resources	gui_x11.txt	/*gui-resources*
+gui-scrollbars	gui.txt	/*gui-scrollbars*
+gui-selections	gui.txt	/*gui-selections*
+gui-shell	gui.txt	/*gui-shell*
+gui-shell-win32	gui_w32.txt	/*gui-shell-win32*
+gui-start	gui.txt	/*gui-start*
+gui-toolbar	gui.txt	/*gui-toolbar*
+gui-vert-scroll	gui.txt	/*gui-vert-scroll*
+gui-w32	gui_w32.txt	/*gui-w32*
+gui-w32-cmdargs	gui_w32.txt	/*gui-w32-cmdargs*
+gui-w32-dialogs	gui_w32.txt	/*gui-w32-dialogs*
+gui-w32-printing	gui_w32.txt	/*gui-w32-printing*
+gui-w32-start	gui_w32.txt	/*gui-w32-start*
+gui-w32-various	gui_w32.txt	/*gui-w32-various*
+gui-w32-windowid	gui_w32.txt	/*gui-w32-windowid*
+gui-w32s	os_win32.txt	/*gui-w32s*
+gui-win32-maximized	gui_w32.txt	/*gui-win32-maximized*
+gui-x11	gui_x11.txt	/*gui-x11*
+gui-x11-athena	gui_x11.txt	/*gui-x11-athena*
+gui-x11-compiling	gui_x11.txt	/*gui-x11-compiling*
+gui-x11-gtk	gui_x11.txt	/*gui-x11-gtk*
+gui-x11-kde	gui_x11.txt	/*gui-x11-kde*
+gui-x11-misc	gui_x11.txt	/*gui-x11-misc*
+gui-x11-motif	gui_x11.txt	/*gui-x11-motif*
+gui-x11-neXtaw	gui_x11.txt	/*gui-x11-neXtaw*
+gui-x11-printing	gui_x11.txt	/*gui-x11-printing*
+gui-x11-start	gui_x11.txt	/*gui-x11-start*
+gui-x11-various	gui_x11.txt	/*gui-x11-various*
+gui.txt	gui.txt	/*gui.txt*
+gui_w32.txt	gui_w32.txt	/*gui_w32.txt*
+gui_x11.txt	gui_x11.txt	/*gui_x11.txt*
+guifontwide_gtk	options.txt	/*guifontwide_gtk*
+guifontwide_win_mbyte	options.txt	/*guifontwide_win_mbyte*
+guioptions_a	options.txt	/*guioptions_a*
+guu	change.txt	/*guu*
+gv	visual.txt	/*gv*
+gview	starting.txt	/*gview*
+gvim	starting.txt	/*gvim*
+gvimdiff	diff.txt	/*gvimdiff*
+gvimrc	gui.txt	/*gvimrc*
+gw	change.txt	/*gw*
+gwgw	change.txt	/*gwgw*
+gww	change.txt	/*gww*
+gzip	pi_gzip.txt	/*gzip*
+gzip-autocmd	pi_gzip.txt	/*gzip-autocmd*
+gzip-example	autocmd.txt	/*gzip-example*
+gzip-helpfile	tips.txt	/*gzip-helpfile*
+g~	change.txt	/*g~*
+g~g~	change.txt	/*g~g~*
+g~~	change.txt	/*g~~*
+h	motion.txt	/*h*
+hangul	hangulin.txt	/*hangul*
+hangulin.txt	hangulin.txt	/*hangulin.txt*
+has()	eval.txt	/*has()*
+has-patch	eval.txt	/*has-patch*
+has-python	if_pyth.txt	/*has-python*
+has-pythonx	if_pyth.txt	/*has-pythonx*
+has_key()	eval.txt	/*has_key()*
+haskell.vim	syntax.txt	/*haskell.vim*
+haslocaldir()	eval.txt	/*haslocaldir()*
+hasmapto()	eval.txt	/*hasmapto()*
+hebrew	hebrew.txt	/*hebrew*
+hebrew.txt	hebrew.txt	/*hebrew.txt*
+help	helphelp.txt	/*help*
+help-context	help.txt	/*help-context*
+help-summary	usr_02.txt	/*help-summary*
+help-tags	tags	1
+help-translated	helphelp.txt	/*help-translated*
+help-writing	helphelp.txt	/*help-writing*
+help-xterm-window	helphelp.txt	/*help-xterm-window*
+help.txt	help.txt	/*help.txt*
+helpfile_name.txt	helphelp.txt	/*helpfile_name.txt*
+helphelp	helphelp.txt	/*helphelp*
+helphelp.txt	helphelp.txt	/*helphelp.txt*
+hex-editing	tips.txt	/*hex-editing*
+hex-number	eval.txt	/*hex-number*
+hidden-buffer	windows.txt	/*hidden-buffer*
+hidden-changed	version5.txt	/*hidden-changed*
+hidden-menus	gui.txt	/*hidden-menus*
+hidden-options	options.txt	/*hidden-options*
+hidden-quit	windows.txt	/*hidden-quit*
+highlight-args	syntax.txt	/*highlight-args*
+highlight-changed	version4.txt	/*highlight-changed*
+highlight-cterm	syntax.txt	/*highlight-cterm*
+highlight-ctermbg	syntax.txt	/*highlight-ctermbg*
+highlight-ctermfg	syntax.txt	/*highlight-ctermfg*
+highlight-default	syntax.txt	/*highlight-default*
+highlight-font	syntax.txt	/*highlight-font*
+highlight-groups	syntax.txt	/*highlight-groups*
+highlight-gui	syntax.txt	/*highlight-gui*
+highlight-guibg	syntax.txt	/*highlight-guibg*
+highlight-guifg	syntax.txt	/*highlight-guifg*
+highlight-guisp	syntax.txt	/*highlight-guisp*
+highlight-start	syntax.txt	/*highlight-start*
+highlight-stop	syntax.txt	/*highlight-stop*
+highlight-term	syntax.txt	/*highlight-term*
+highlightID()	eval.txt	/*highlightID()*
+highlight_exists()	eval.txt	/*highlight_exists()*
+highlighting-functions	usr_41.txt	/*highlighting-functions*
+hist-names	eval.txt	/*hist-names*
+histadd()	eval.txt	/*histadd()*
+histdel()	eval.txt	/*histdel()*
+histget()	eval.txt	/*histget()*
+histnr()	eval.txt	/*histnr()*
+history	cmdline.txt	/*history*
+history-functions	usr_41.txt	/*history-functions*
+hit-enter	message.txt	/*hit-enter*
+hit-enter-prompt	message.txt	/*hit-enter-prompt*
+hit-return	message.txt	/*hit-return*
+hitest.vim	syntax.txt	/*hitest.vim*
+hjkl	usr_02.txt	/*hjkl*
+hl-ColorColumn	syntax.txt	/*hl-ColorColumn*
+hl-Conceal	syntax.txt	/*hl-Conceal*
+hl-Cursor	syntax.txt	/*hl-Cursor*
+hl-CursorColumn	syntax.txt	/*hl-CursorColumn*
+hl-CursorIM	syntax.txt	/*hl-CursorIM*
+hl-CursorLine	syntax.txt	/*hl-CursorLine*
+hl-CursorLineNr	syntax.txt	/*hl-CursorLineNr*
+hl-DiffAdd	syntax.txt	/*hl-DiffAdd*
+hl-DiffChange	syntax.txt	/*hl-DiffChange*
+hl-DiffDelete	syntax.txt	/*hl-DiffDelete*
+hl-DiffText	syntax.txt	/*hl-DiffText*
+hl-Directory	syntax.txt	/*hl-Directory*
+hl-EndOfBuffer	syntax.txt	/*hl-EndOfBuffer*
+hl-ErrorMsg	syntax.txt	/*hl-ErrorMsg*
+hl-FoldColumn	syntax.txt	/*hl-FoldColumn*
+hl-Folded	syntax.txt	/*hl-Folded*
+hl-Ignore	syntax.txt	/*hl-Ignore*
+hl-IncSearch	syntax.txt	/*hl-IncSearch*
+hl-LineNr	syntax.txt	/*hl-LineNr*
+hl-MatchParen	syntax.txt	/*hl-MatchParen*
+hl-Menu	syntax.txt	/*hl-Menu*
+hl-ModeMsg	syntax.txt	/*hl-ModeMsg*
+hl-MoreMsg	syntax.txt	/*hl-MoreMsg*
+hl-NonText	syntax.txt	/*hl-NonText*
+hl-Normal	syntax.txt	/*hl-Normal*
+hl-Pmenu	syntax.txt	/*hl-Pmenu*
+hl-PmenuSbar	syntax.txt	/*hl-PmenuSbar*
+hl-PmenuSel	syntax.txt	/*hl-PmenuSel*
+hl-PmenuThumb	syntax.txt	/*hl-PmenuThumb*
+hl-Question	syntax.txt	/*hl-Question*
+hl-QuickFixLine	syntax.txt	/*hl-QuickFixLine*
+hl-Scrollbar	syntax.txt	/*hl-Scrollbar*
+hl-Search	syntax.txt	/*hl-Search*
+hl-SignColumn	syntax.txt	/*hl-SignColumn*
+hl-SpecialKey	syntax.txt	/*hl-SpecialKey*
+hl-SpellBad	syntax.txt	/*hl-SpellBad*
+hl-SpellCap	syntax.txt	/*hl-SpellCap*
+hl-SpellLocal	syntax.txt	/*hl-SpellLocal*
+hl-SpellRare	syntax.txt	/*hl-SpellRare*
+hl-StatusLine	syntax.txt	/*hl-StatusLine*
+hl-StatusLineNC	syntax.txt	/*hl-StatusLineNC*
+hl-StatusLineTerm	syntax.txt	/*hl-StatusLineTerm*
+hl-StatusLineTermNC	syntax.txt	/*hl-StatusLineTermNC*
+hl-TabLine	syntax.txt	/*hl-TabLine*
+hl-TabLineFill	syntax.txt	/*hl-TabLineFill*
+hl-TabLineSel	syntax.txt	/*hl-TabLineSel*
+hl-Terminal	syntax.txt	/*hl-Terminal*
+hl-Title	syntax.txt	/*hl-Title*
+hl-Tooltip	syntax.txt	/*hl-Tooltip*
+hl-User1	syntax.txt	/*hl-User1*
+hl-User1..9	syntax.txt	/*hl-User1..9*
+hl-User9	syntax.txt	/*hl-User9*
+hl-VertSplit	syntax.txt	/*hl-VertSplit*
+hl-Visual	syntax.txt	/*hl-Visual*
+hl-VisualNOS	syntax.txt	/*hl-VisualNOS*
+hl-WarningMsg	syntax.txt	/*hl-WarningMsg*
+hl-WildMenu	syntax.txt	/*hl-WildMenu*
+hl-debugBreakpoint	terminal.txt	/*hl-debugBreakpoint*
+hl-debugPC	terminal.txt	/*hl-debugPC*
+hlID()	eval.txt	/*hlID()*
+hlexists()	eval.txt	/*hlexists()*
+hlsearch-variable	eval.txt	/*hlsearch-variable*
+holy-grail	index.txt	/*holy-grail*
+home	intro.txt	/*home*
+home-replace	editing.txt	/*home-replace*
+hostname()	eval.txt	/*hostname()*
+how-do-i	howto.txt	/*how-do-i*
+how-to	howto.txt	/*how-to*
+howdoi	howto.txt	/*howdoi*
+howto	howto.txt	/*howto*
+howto.txt	howto.txt	/*howto.txt*
+hpterm	term.txt	/*hpterm*
+hpterm-color	syntax.txt	/*hpterm-color*
+html-flavor	insert.txt	/*html-flavor*
+html-indent	indent.txt	/*html-indent*
+html-indenting	indent.txt	/*html-indenting*
+html.vim	syntax.txt	/*html.vim*
+htmlos.vim	syntax.txt	/*htmlos.vim*
+http	pi_netrw.txt	/*http*
+i	insert.txt	/*i*
+i'	motion.txt	/*i'*
+i(	motion.txt	/*i(*
+i)	motion.txt	/*i)*
+i<	motion.txt	/*i<*
+i>	motion.txt	/*i>*
+iB	motion.txt	/*iB*
+iBus	gui.txt	/*iBus*
+iW	motion.txt	/*iW*
+i[	motion.txt	/*i[*
+i]	motion.txt	/*i]*
+i_0_CTRL-D	insert.txt	/*i_0_CTRL-D*
+i_<BS>	insert.txt	/*i_<BS>*
+i_<C-End>	insert.txt	/*i_<C-End>*
+i_<C-Home>	insert.txt	/*i_<C-Home>*
+i_<C-Left>	insert.txt	/*i_<C-Left>*
+i_<C-PageDown>	tabpage.txt	/*i_<C-PageDown>*
+i_<C-PageUp>	tabpage.txt	/*i_<C-PageUp>*
+i_<C-Right>	insert.txt	/*i_<C-Right>*
+i_<CR>	insert.txt	/*i_<CR>*
+i_<Del>	insert.txt	/*i_<Del>*
+i_<Down>	insert.txt	/*i_<Down>*
+i_<End>	insert.txt	/*i_<End>*
+i_<Esc>	insert.txt	/*i_<Esc>*
+i_<F1>	helphelp.txt	/*i_<F1>*
+i_<Help>	helphelp.txt	/*i_<Help>*
+i_<Home>	insert.txt	/*i_<Home>*
+i_<Insert>	insert.txt	/*i_<Insert>*
+i_<Left>	insert.txt	/*i_<Left>*
+i_<LeftMouse>	insert.txt	/*i_<LeftMouse>*
+i_<NL>	insert.txt	/*i_<NL>*
+i_<PageDown>	insert.txt	/*i_<PageDown>*
+i_<PageUp>	insert.txt	/*i_<PageUp>*
+i_<Right>	insert.txt	/*i_<Right>*
+i_<S-Down>	insert.txt	/*i_<S-Down>*
+i_<S-Left>	insert.txt	/*i_<S-Left>*
+i_<S-Right>	insert.txt	/*i_<S-Right>*
+i_<S-ScrollWheelDown>	insert.txt	/*i_<S-ScrollWheelDown>*
+i_<S-ScrollWheelLeft>	insert.txt	/*i_<S-ScrollWheelLeft>*
+i_<S-ScrollWheelRight>	insert.txt	/*i_<S-ScrollWheelRight>*
+i_<S-ScrollWheelUp>	insert.txt	/*i_<S-ScrollWheelUp>*
+i_<S-Up>	insert.txt	/*i_<S-Up>*
+i_<ScrollWheelDown>	insert.txt	/*i_<ScrollWheelDown>*
+i_<ScrollWheelLeft>	insert.txt	/*i_<ScrollWheelLeft>*
+i_<ScrollWheelRight>	insert.txt	/*i_<ScrollWheelRight>*
+i_<ScrollWheelUp>	insert.txt	/*i_<ScrollWheelUp>*
+i_<Tab>	insert.txt	/*i_<Tab>*
+i_<Up>	insert.txt	/*i_<Up>*
+i_BS	insert.txt	/*i_BS*
+i_CTRL-<PageDown>	tabpage.txt	/*i_CTRL-<PageDown>*
+i_CTRL-<PageUp>	tabpage.txt	/*i_CTRL-<PageUp>*
+i_CTRL-@	insert.txt	/*i_CTRL-@*
+i_CTRL-A	insert.txt	/*i_CTRL-A*
+i_CTRL-B-gone	version5.txt	/*i_CTRL-B-gone*
+i_CTRL-C	insert.txt	/*i_CTRL-C*
+i_CTRL-D	insert.txt	/*i_CTRL-D*
+i_CTRL-E	insert.txt	/*i_CTRL-E*
+i_CTRL-F	indent.txt	/*i_CTRL-F*
+i_CTRL-G_<Down>	insert.txt	/*i_CTRL-G_<Down>*
+i_CTRL-G_<Up>	insert.txt	/*i_CTRL-G_<Up>*
+i_CTRL-G_CTRL-J	insert.txt	/*i_CTRL-G_CTRL-J*
+i_CTRL-G_CTRL-K	insert.txt	/*i_CTRL-G_CTRL-K*
+i_CTRL-G_U	insert.txt	/*i_CTRL-G_U*
+i_CTRL-G_j	insert.txt	/*i_CTRL-G_j*
+i_CTRL-G_k	insert.txt	/*i_CTRL-G_k*
+i_CTRL-G_u	insert.txt	/*i_CTRL-G_u*
+i_CTRL-H	insert.txt	/*i_CTRL-H*
+i_CTRL-I	insert.txt	/*i_CTRL-I*
+i_CTRL-J	insert.txt	/*i_CTRL-J*
+i_CTRL-K	insert.txt	/*i_CTRL-K*
+i_CTRL-L	insert.txt	/*i_CTRL-L*
+i_CTRL-M	insert.txt	/*i_CTRL-M*
+i_CTRL-N	insert.txt	/*i_CTRL-N*
+i_CTRL-O	insert.txt	/*i_CTRL-O*
+i_CTRL-P	insert.txt	/*i_CTRL-P*
+i_CTRL-Q	insert.txt	/*i_CTRL-Q*
+i_CTRL-R	insert.txt	/*i_CTRL-R*
+i_CTRL-R_=	insert.txt	/*i_CTRL-R_=*
+i_CTRL-R_CTRL-O	insert.txt	/*i_CTRL-R_CTRL-O*
+i_CTRL-R_CTRL-P	insert.txt	/*i_CTRL-R_CTRL-P*
+i_CTRL-R_CTRL-R	insert.txt	/*i_CTRL-R_CTRL-R*
+i_CTRL-T	insert.txt	/*i_CTRL-T*
+i_CTRL-U	insert.txt	/*i_CTRL-U*
+i_CTRL-V	insert.txt	/*i_CTRL-V*
+i_CTRL-V_digit	insert.txt	/*i_CTRL-V_digit*
+i_CTRL-W	insert.txt	/*i_CTRL-W*
+i_CTRL-X	insert.txt	/*i_CTRL-X*
+i_CTRL-X_CTRL-D	insert.txt	/*i_CTRL-X_CTRL-D*
+i_CTRL-X_CTRL-E	insert.txt	/*i_CTRL-X_CTRL-E*
+i_CTRL-X_CTRL-F	insert.txt	/*i_CTRL-X_CTRL-F*
+i_CTRL-X_CTRL-I	insert.txt	/*i_CTRL-X_CTRL-I*
+i_CTRL-X_CTRL-K	insert.txt	/*i_CTRL-X_CTRL-K*
+i_CTRL-X_CTRL-L	insert.txt	/*i_CTRL-X_CTRL-L*
+i_CTRL-X_CTRL-N	insert.txt	/*i_CTRL-X_CTRL-N*
+i_CTRL-X_CTRL-O	insert.txt	/*i_CTRL-X_CTRL-O*
+i_CTRL-X_CTRL-P	insert.txt	/*i_CTRL-X_CTRL-P*
+i_CTRL-X_CTRL-S	insert.txt	/*i_CTRL-X_CTRL-S*
+i_CTRL-X_CTRL-T	insert.txt	/*i_CTRL-X_CTRL-T*
+i_CTRL-X_CTRL-U	insert.txt	/*i_CTRL-X_CTRL-U*
+i_CTRL-X_CTRL-V	insert.txt	/*i_CTRL-X_CTRL-V*
+i_CTRL-X_CTRL-Y	insert.txt	/*i_CTRL-X_CTRL-Y*
+i_CTRL-X_CTRL-]	insert.txt	/*i_CTRL-X_CTRL-]*
+i_CTRL-X_index	index.txt	/*i_CTRL-X_index*
+i_CTRL-X_s	insert.txt	/*i_CTRL-X_s*
+i_CTRL-Y	insert.txt	/*i_CTRL-Y*
+i_CTRL-Z	options.txt	/*i_CTRL-Z*
+i_CTRL-[	insert.txt	/*i_CTRL-[*
+i_CTRL-\_CTRL-G	intro.txt	/*i_CTRL-\\_CTRL-G*
+i_CTRL-\_CTRL-N	intro.txt	/*i_CTRL-\\_CTRL-N*
+i_CTRL-\_CTRL-O	insert.txt	/*i_CTRL-\\_CTRL-O*
+i_CTRL-]	insert.txt	/*i_CTRL-]*
+i_CTRL-^	insert.txt	/*i_CTRL-^*
+i_CTRL-_	insert.txt	/*i_CTRL-_*
+i_DEL	insert.txt	/*i_DEL*
+i_Tab	insert.txt	/*i_Tab*
+i_^_CTRL-D	insert.txt	/*i_^_CTRL-D*
+i_backspacing	insert.txt	/*i_backspacing*
+i_digraph	digraph.txt	/*i_digraph*
+i_esc	intro.txt	/*i_esc*
+i`	motion.txt	/*i`*
+ia64.vim	syntax.txt	/*ia64.vim*
+ib	motion.txt	/*ib*
+iccf	uganda.txt	/*iccf*
+iccf-donations	uganda.txt	/*iccf-donations*
+icon-changed	version4.txt	/*icon-changed*
+iconise	starting.txt	/*iconise*
+iconize	starting.txt	/*iconize*
+iconv()	eval.txt	/*iconv()*
+iconv-dynamic	mbyte.txt	/*iconv-dynamic*
+ident-search	tips.txt	/*ident-search*
+idl-syntax	syntax.txt	/*idl-syntax*
+idl.vim	syntax.txt	/*idl.vim*
+if_cscop.txt	if_cscop.txt	/*if_cscop.txt*
+if_lua.txt	if_lua.txt	/*if_lua.txt*
+if_mzsch.txt	if_mzsch.txt	/*if_mzsch.txt*
+if_ole.txt	if_ole.txt	/*if_ole.txt*
+if_perl.txt	if_perl.txt	/*if_perl.txt*
+if_pyth.txt	if_pyth.txt	/*if_pyth.txt*
+if_ruby.txt	if_ruby.txt	/*if_ruby.txt*
+if_sniff.txt	if_sniff.txt	/*if_sniff.txt*
+if_tcl.txt	if_tcl.txt	/*if_tcl.txt*
+ignore-errors	eval.txt	/*ignore-errors*
+improved-autocmds-5.4	version5.txt	/*improved-autocmds-5.4*
+improved-quickfix	version5.txt	/*improved-quickfix*
+improved-sessions	version5.txt	/*improved-sessions*
+improved-viminfo	version5.txt	/*improved-viminfo*
+improvements-5	version5.txt	/*improvements-5*
+improvements-6	version6.txt	/*improvements-6*
+improvements-7	version7.txt	/*improvements-7*
+improvements-8	version8.txt	/*improvements-8*
+in_bot	channel.txt	/*in_bot*
+in_buf	channel.txt	/*in_buf*
+in_io-buffer	channel.txt	/*in_io-buffer*
+in_mode	channel.txt	/*in_mode*
+in_name	channel.txt	/*in_name*
+in_top	channel.txt	/*in_top*
+inactive-buffer	windows.txt	/*inactive-buffer*
+include-search	tagsrch.txt	/*include-search*
+inclusive	motion.txt	/*inclusive*
+incomp-small-6	version6.txt	/*incomp-small-6*
+incompatible-5	version5.txt	/*incompatible-5*
+incompatible-6	version6.txt	/*incompatible-6*
+incompatible-7	version7.txt	/*incompatible-7*
+incompatible-8	version8.txt	/*incompatible-8*
+indent()	eval.txt	/*indent()*
+indent-expression	indent.txt	/*indent-expression*
+indent.txt	indent.txt	/*indent.txt*
+indentkeys-format	indent.txt	/*indentkeys-format*
+index	index.txt	/*index*
+index()	eval.txt	/*index()*
+index.txt	index.txt	/*index.txt*
+info-message	starting.txt	/*info-message*
+inform.vim	syntax.txt	/*inform.vim*
+informix	ft_sql.txt	/*informix*
+initialization	starting.txt	/*initialization*
+input()	eval.txt	/*input()*
+inputdialog()	eval.txt	/*inputdialog()*
+inputlist()	eval.txt	/*inputlist()*
+inputrestore()	eval.txt	/*inputrestore()*
+inputsave()	eval.txt	/*inputsave()*
+inputsecret()	eval.txt	/*inputsecret()*
+ins-completion	insert.txt	/*ins-completion*
+ins-completion-menu	insert.txt	/*ins-completion-menu*
+ins-expandtab	insert.txt	/*ins-expandtab*
+ins-reverse	rileft.txt	/*ins-reverse*
+ins-smarttab	insert.txt	/*ins-smarttab*
+ins-softtabstop	insert.txt	/*ins-softtabstop*
+ins-special-keys	insert.txt	/*ins-special-keys*
+ins-special-special	insert.txt	/*ins-special-special*
+ins-textwidth	insert.txt	/*ins-textwidth*
+insert	insert.txt	/*insert*
+insert()	eval.txt	/*insert()*
+insert-index	index.txt	/*insert-index*
+insert.txt	insert.txt	/*insert.txt*
+insert_expand	insert.txt	/*insert_expand*
+inserting	insert.txt	/*inserting*
+inserting-ex	insert.txt	/*inserting-ex*
+inserting-file	insert.txt	/*inserting-file*
+insertmode-variable	eval.txt	/*insertmode-variable*
+install	usr_90.txt	/*install*
+install-home	usr_90.txt	/*install-home*
+install-registry	gui_w32.txt	/*install-registry*
+intel-itanium	syntax.txt	/*intel-itanium*
+intellimouse-wheel-problems	gui_w32.txt	/*intellimouse-wheel-problems*
+interactive-functions	usr_41.txt	/*interactive-functions*
+interfaces-5.2	version5.txt	/*interfaces-5.2*
+internal-variables	eval.txt	/*internal-variables*
+internal-wordlist	spell.txt	/*internal-wordlist*
+internet	intro.txt	/*internet*
+intro	intro.txt	/*intro*
+intro.txt	intro.txt	/*intro.txt*
+inverse	syntax.txt	/*inverse*
+invert()	eval.txt	/*invert()*
+ip	motion.txt	/*ip*
+iquote	motion.txt	/*iquote*
+is	motion.txt	/*is*
+isdirectory()	eval.txt	/*isdirectory()*
+islocked()	eval.txt	/*islocked()*
+isnan()	eval.txt	/*isnan()*
+it	motion.txt	/*it*
+italic	syntax.txt	/*italic*
+items()	eval.txt	/*items()*
+iw	motion.txt	/*iw*
+i{	motion.txt	/*i{*
+i}	motion.txt	/*i}*
+j	motion.txt	/*j*
+java-cinoptions	indent.txt	/*java-cinoptions*
+java-indenting	indent.txt	/*java-indenting*
+java.vim	syntax.txt	/*java.vim*
+javascript-cinoptions	indent.txt	/*javascript-cinoptions*
+javascript-indenting	indent.txt	/*javascript-indenting*
+job	channel.txt	/*job*
+job-callback	channel.txt	/*job-callback*
+job-channel-overview	channel.txt	/*job-channel-overview*
+job-close_cb	channel.txt	/*job-close_cb*
+job-control	channel.txt	/*job-control*
+job-drop	channel.txt	/*job-drop*
+job-err_cb	channel.txt	/*job-err_cb*
+job-err_io	channel.txt	/*job-err_io*
+job-exit_cb	channel.txt	/*job-exit_cb*
+job-functions	usr_41.txt	/*job-functions*
+job-in_io	channel.txt	/*job-in_io*
+job-options	channel.txt	/*job-options*
+job-out_cb	channel.txt	/*job-out_cb*
+job-out_io	channel.txt	/*job-out_io*
+job-start	channel.txt	/*job-start*
+job-start-if-needed	channel.txt	/*job-start-if-needed*
+job-start-nochannel	channel.txt	/*job-start-nochannel*
+job-stoponexit	channel.txt	/*job-stoponexit*
+job-term	channel.txt	/*job-term*
+job-timeout	channel.txt	/*job-timeout*
+job_getchannel()	eval.txt	/*job_getchannel()*
+job_info()	eval.txt	/*job_info()*
+job_setoptions()	eval.txt	/*job_setoptions()*
+job_start()	eval.txt	/*job_start()*
+job_status()	eval.txt	/*job_status()*
+job_stop()	eval.txt	/*job_stop()*
+join()	eval.txt	/*join()*
+js_decode()	eval.txt	/*js_decode()*
+js_encode()	eval.txt	/*js_encode()*
+jsbterm-mouse	options.txt	/*jsbterm-mouse*
+json_decode()	eval.txt	/*json_decode()*
+json_encode()	eval.txt	/*json_encode()*
+jtags	tagsrch.txt	/*jtags*
+jump-motions	motion.txt	/*jump-motions*
+jumplist	motion.txt	/*jumplist*
+jumpto-diffs	diff.txt	/*jumpto-diffs*
+k	motion.txt	/*k*
+kcc	uganda.txt	/*kcc*
+kde	gui_x11.txt	/*kde*
+key-codes	intro.txt	/*key-codes*
+key-codes-changed	version4.txt	/*key-codes-changed*
+key-mapping	map.txt	/*key-mapping*
+key-notation	intro.txt	/*key-notation*
+key-variable	eval.txt	/*key-variable*
+keycodes	intro.txt	/*keycodes*
+keymap-accents	mbyte.txt	/*keymap-accents*
+keymap-file-format	mbyte.txt	/*keymap-file-format*
+keymap-hebrew	mbyte.txt	/*keymap-hebrew*
+keypad-0	intro.txt	/*keypad-0*
+keypad-9	intro.txt	/*keypad-9*
+keypad-comma	term.txt	/*keypad-comma*
+keypad-divide	intro.txt	/*keypad-divide*
+keypad-end	intro.txt	/*keypad-end*
+keypad-enter	intro.txt	/*keypad-enter*
+keypad-home	intro.txt	/*keypad-home*
+keypad-minus	intro.txt	/*keypad-minus*
+keypad-multiply	intro.txt	/*keypad-multiply*
+keypad-page-down	intro.txt	/*keypad-page-down*
+keypad-page-up	intro.txt	/*keypad-page-up*
+keypad-plus	intro.txt	/*keypad-plus*
+keypad-point	intro.txt	/*keypad-point*
+keys()	eval.txt	/*keys()*
+known-bugs	todo.txt	/*known-bugs*
+l	motion.txt	/*l*
+l:	eval.txt	/*l:*
+l:var	eval.txt	/*l:var*
+lCursor	mbyte.txt	/*lCursor*
+lace.vim	syntax.txt	/*lace.vim*
+lambda	eval.txt	/*lambda*
+lang-variable	eval.txt	/*lang-variable*
+language-mapping	map.txt	/*language-mapping*
+last-pattern	pattern.txt	/*last-pattern*
+last-position-jump	eval.txt	/*last-position-jump*
+last_buffer_nr()	eval.txt	/*last_buffer_nr()*
+latex-syntax	syntax.txt	/*latex-syntax*
+lc_time-variable	eval.txt	/*lc_time-variable*
+lcs-conceal	options.txt	/*lcs-conceal*
+lcs-eol	options.txt	/*lcs-eol*
+lcs-extends	options.txt	/*lcs-extends*
+lcs-nbsp	options.txt	/*lcs-nbsp*
+lcs-precedes	options.txt	/*lcs-precedes*
+lcs-space	options.txt	/*lcs-space*
+lcs-tab	options.txt	/*lcs-tab*
+lcs-trail	options.txt	/*lcs-trail*
+left-right-motions	motion.txt	/*left-right-motions*
+len()	eval.txt	/*len()*
+less	various.txt	/*less*
+letter	print.txt	/*letter*
+lex.vim	syntax.txt	/*lex.vim*
+lhaskell.vim	syntax.txt	/*lhaskell.vim*
+libcall()	eval.txt	/*libcall()*
+libcallnr()	eval.txt	/*libcallnr()*
+license	uganda.txt	/*license*
+lid	quickfix.txt	/*lid*
+lifelines.vim	syntax.txt	/*lifelines.vim*
+limits	vi_diff.txt	/*limits*
+line()	eval.txt	/*line()*
+line-continuation	repeat.txt	/*line-continuation*
+line2byte()	eval.txt	/*line2byte()*
+linefeed	intro.txt	/*linefeed*
+linewise	motion.txt	/*linewise*
+linewise-register	change.txt	/*linewise-register*
+linewise-visual	visual.txt	/*linewise-visual*
+lisp.vim	syntax.txt	/*lisp.vim*
+lispindent()	eval.txt	/*lispindent()*
+list	eval.txt	/*list*
+list-functions	usr_41.txt	/*list-functions*
+list-identity	eval.txt	/*list-identity*
+list-index	eval.txt	/*list-index*
+list-modification	eval.txt	/*list-modification*
+list-repeat	windows.txt	/*list-repeat*
+lite.vim	syntax.txt	/*lite.vim*
+literal-string	eval.txt	/*literal-string*
+lnum-variable	eval.txt	/*lnum-variable*
+load-plugins	starting.txt	/*load-plugins*
+load-vim-script	repeat.txt	/*load-vim-script*
+local-additions	help.txt	/*local-additions*
+local-function	eval.txt	/*local-function*
+local-options	options.txt	/*local-options*
+local-variable	eval.txt	/*local-variable*
+local-variables	eval.txt	/*local-variables*
+local_markfilelist	pi_netrw.txt	/*local_markfilelist*
+locale	mbyte.txt	/*locale*
+locale-name	mbyte.txt	/*locale-name*
+localtime()	eval.txt	/*localtime()*
+location-list	quickfix.txt	/*location-list*
+location-list-window	quickfix.txt	/*location-list-window*
+log()	eval.txt	/*log()*
+log10()	eval.txt	/*log10()*
+logiPat	pi_logipat.txt	/*logiPat*
+logiPat-arg	pi_logipat.txt	/*logiPat-arg*
+logiPat-caveat	pi_logipat.txt	/*logiPat-caveat*
+logiPat-contents	pi_logipat.txt	/*logiPat-contents*
+logiPat-copyright	pi_logipat.txt	/*logiPat-copyright*
+logiPat-examples	pi_logipat.txt	/*logiPat-examples*
+logiPat-history	pi_logipat.txt	/*logiPat-history*
+logiPat-input	pi_logipat.txt	/*logiPat-input*
+logiPat-man	pi_logipat.txt	/*logiPat-man*
+logiPat-manual	pi_logipat.txt	/*logiPat-manual*
+logiPat-operators	pi_logipat.txt	/*logiPat-operators*
+logiPat-pattern	pi_logipat.txt	/*logiPat-pattern*
+long-lines	version5.txt	/*long-lines*
+love	intro.txt	/*love*
+lowercase	change.txt	/*lowercase*
+lpc.vim	syntax.txt	/*lpc.vim*
+lua	if_lua.txt	/*lua*
+lua-buffer	if_lua.txt	/*lua-buffer*
+lua-commands	if_lua.txt	/*lua-commands*
+lua-dict	if_lua.txt	/*lua-dict*
+lua-dynamic	if_lua.txt	/*lua-dynamic*
+lua-eval	if_lua.txt	/*lua-eval*
+lua-funcref	if_lua.txt	/*lua-funcref*
+lua-list	if_lua.txt	/*lua-list*
+lua-luaeval	if_lua.txt	/*lua-luaeval*
+lua-vim	if_lua.txt	/*lua-vim*
+lua-window	if_lua.txt	/*lua-window*
+lua.vim	syntax.txt	/*lua.vim*
+luaeval()	eval.txt	/*luaeval()*
+m	motion.txt	/*m*
+m'	motion.txt	/*m'*
+m<	motion.txt	/*m<*
+m>	motion.txt	/*m>*
+m[	motion.txt	/*m[*
+m]	motion.txt	/*m]*
+m`	motion.txt	/*m`*
+mac	os_mac.txt	/*mac*
+mac-bug	os_mac.txt	/*mac-bug*
+mac-compile	os_mac.txt	/*mac-compile*
+mac-darwin-feature	os_mac.txt	/*mac-darwin-feature*
+mac-faq	os_mac.txt	/*mac-faq*
+mac-filename	os_mac.txt	/*mac-filename*
+mac-lack	os_mac.txt	/*mac-lack*
+mac-standard-mappings	os_mac.txt	/*mac-standard-mappings*
+mac-vimfile	os_mac.txt	/*mac-vimfile*
+macintosh	os_mac.txt	/*macintosh*
+macro	map.txt	/*macro*
+mail-list	intro.txt	/*mail-list*
+mail.vim	syntax.txt	/*mail.vim*
+maillist	intro.txt	/*maillist*
+maillist-archive	intro.txt	/*maillist-archive*
+make.vim	syntax.txt	/*make.vim*
+man.vim	filetype.txt	/*man.vim*
+manpager.vim	filetype.txt	/*manpager.vim*
+manual-copyright	usr_01.txt	/*manual-copyright*
+map()	eval.txt	/*map()*
+map-<SID>	map.txt	/*map-<SID>*
+map-CTRL-C	map.txt	/*map-CTRL-C*
+map-ambiguous	map.txt	/*map-ambiguous*
+map-backslash	map.txt	/*map-backslash*
+map-backtick	tips.txt	/*map-backtick*
+map-bar	map.txt	/*map-bar*
+map-comments	map.txt	/*map-comments*
+map-empty-rhs	map.txt	/*map-empty-rhs*
+map-error	map.txt	/*map-error*
+map-examples	map.txt	/*map-examples*
+map-keys-fails	map.txt	/*map-keys-fails*
+map-listing	map.txt	/*map-listing*
+map-modes	map.txt	/*map-modes*
+map-multibyte	map.txt	/*map-multibyte*
+map-overview	map.txt	/*map-overview*
+map-precedence	map.txt	/*map-precedence*
+map-return	map.txt	/*map-return*
+map-self-destroy	tips.txt	/*map-self-destroy*
+map-space_in_lhs	map.txt	/*map-space_in_lhs*
+map-space_in_rhs	map.txt	/*map-space_in_rhs*
+map-typing	map.txt	/*map-typing*
+map-which-keys	map.txt	/*map-which-keys*
+map.txt	map.txt	/*map.txt*
+map_CTRL-C	map.txt	/*map_CTRL-C*
+map_backslash	map.txt	/*map_backslash*
+map_bar	map.txt	/*map_bar*
+map_empty_rhs	map.txt	/*map_empty_rhs*
+map_return	map.txt	/*map_return*
+map_space_in_lhs	map.txt	/*map_space_in_lhs*
+map_space_in_rhs	map.txt	/*map_space_in_rhs*
+maparg()	eval.txt	/*maparg()*
+mapcheck()	eval.txt	/*mapcheck()*
+maple.vim	syntax.txt	/*maple.vim*
+mapleader	map.txt	/*mapleader*
+maplocalleader	map.txt	/*maplocalleader*
+mapmode-c	map.txt	/*mapmode-c*
+mapmode-i	map.txt	/*mapmode-i*
+mapmode-ic	map.txt	/*mapmode-ic*
+mapmode-l	map.txt	/*mapmode-l*
+mapmode-n	map.txt	/*mapmode-n*
+mapmode-nvo	map.txt	/*mapmode-nvo*
+mapmode-o	map.txt	/*mapmode-o*
+mapmode-s	map.txt	/*mapmode-s*
+mapmode-t	map.txt	/*mapmode-t*
+mapmode-v	map.txt	/*mapmode-v*
+mapmode-x	map.txt	/*mapmode-x*
+mapping	map.txt	/*mapping*
+mapping-functions	usr_41.txt	/*mapping-functions*
+mark	motion.txt	/*mark*
+mark-functions	usr_41.txt	/*mark-functions*
+mark-motions	motion.txt	/*mark-motions*
+markfilelist	pi_netrw.txt	/*markfilelist*
+masm.vim	syntax.txt	/*masm.vim*
+match()	eval.txt	/*match()*
+match-highlight	pattern.txt	/*match-highlight*
+match-parens	tips.txt	/*match-parens*
+matchadd()	eval.txt	/*matchadd()*
+matchaddpos()	eval.txt	/*matchaddpos()*
+matcharg()	eval.txt	/*matcharg()*
+matchdelete()	eval.txt	/*matchdelete()*
+matchend()	eval.txt	/*matchend()*
+matchit-install	usr_05.txt	/*matchit-install*
+matchlist()	eval.txt	/*matchlist()*
+matchparen	pi_paren.txt	/*matchparen*
+matchstr()	eval.txt	/*matchstr()*
+matchstrpos()	eval.txt	/*matchstrpos()*
+max()	eval.txt	/*max()*
+mbyte-IME	mbyte.txt	/*mbyte-IME*
+mbyte-XIM	mbyte.txt	/*mbyte-XIM*
+mbyte-combining	mbyte.txt	/*mbyte-combining*
+mbyte-composing	mbyte.txt	/*mbyte-composing*
+mbyte-conversion	mbyte.txt	/*mbyte-conversion*
+mbyte-encoding	mbyte.txt	/*mbyte-encoding*
+mbyte-first	mbyte.txt	/*mbyte-first*
+mbyte-fonts-MSwin	mbyte.txt	/*mbyte-fonts-MSwin*
+mbyte-fonts-X11	mbyte.txt	/*mbyte-fonts-X11*
+mbyte-func	mbyte.txt	/*mbyte-func*
+mbyte-keymap	mbyte.txt	/*mbyte-keymap*
+mbyte-locale	mbyte.txt	/*mbyte-locale*
+mbyte-options	mbyte.txt	/*mbyte-options*
+mbyte-terminal	mbyte.txt	/*mbyte-terminal*
+mbyte-utf8	mbyte.txt	/*mbyte-utf8*
+mbyte.txt	mbyte.txt	/*mbyte.txt*
+menu-changes-5.4	version5.txt	/*menu-changes-5.4*
+menu-examples	gui.txt	/*menu-examples*
+menu-priority	gui.txt	/*menu-priority*
+menu-separator	gui.txt	/*menu-separator*
+menu.vim	gui.txt	/*menu.vim*
+menus	gui.txt	/*menus*
+merge	diff.txt	/*merge*
+message-history	message.txt	/*message-history*
+message.txt	message.txt	/*message.txt*
+messages	message.txt	/*messages*
+meta	intro.txt	/*meta*
+min()	eval.txt	/*min()*
+missing-options	vi_diff.txt	/*missing-options*
+mkdir()	eval.txt	/*mkdir()*
+mlang.txt	mlang.txt	/*mlang.txt*
+mma.vim	syntax.txt	/*mma.vim*
+mode()	eval.txt	/*mode()*
+mode-Ex	intro.txt	/*mode-Ex*
+mode-cmdline	cmdline.txt	/*mode-cmdline*
+mode-ins-repl	insert.txt	/*mode-ins-repl*
+mode-replace	insert.txt	/*mode-replace*
+mode-switching	intro.txt	/*mode-switching*
+modeless-and-clipboard	version6.txt	/*modeless-and-clipboard*
+modeless-selection	gui.txt	/*modeless-selection*
+modeline	options.txt	/*modeline*
+modeline-local	options.txt	/*modeline-local*
+modeline-version	options.txt	/*modeline-version*
+moo.vim	syntax.txt	/*moo.vim*
+more-compatible	version5.txt	/*more-compatible*
+more-prompt	message.txt	/*more-prompt*
+more-variables	eval.txt	/*more-variables*
+motion.txt	motion.txt	/*motion.txt*
+mouse-mode-table	term.txt	/*mouse-mode-table*
+mouse-overview	term.txt	/*mouse-overview*
+mouse-swap-buttons	term.txt	/*mouse-swap-buttons*
+mouse-using	term.txt	/*mouse-using*
+mouse_col-variable	eval.txt	/*mouse_col-variable*
+mouse_lnum-variable	eval.txt	/*mouse_lnum-variable*
+mouse_win-variable	eval.txt	/*mouse_win-variable*
+mouse_winid-variable	eval.txt	/*mouse_winid-variable*
+movement	intro.txt	/*movement*
+ms-dos	os_msdos.txt	/*ms-dos*
+msdos	os_msdos.txt	/*msdos*
+msql.vim	syntax.txt	/*msql.vim*
+mswin.vim	gui_w32.txt	/*mswin.vim*
+multi-byte	mbyte.txt	/*multi-byte*
+multi-lang	mlang.txt	/*multi-lang*
+multi-repeat	repeat.txt	/*multi-repeat*
+multibyte	mbyte.txt	/*multibyte*
+multibyte-ime	mbyte.txt	/*multibyte-ime*
+multibyte-input	mbyte.txt	/*multibyte-input*
+multilang	mlang.txt	/*multilang*
+multilang-menus	mlang.txt	/*multilang-menus*
+multilang-messages	mlang.txt	/*multilang-messages*
+multilang-scripts	mlang.txt	/*multilang-scripts*
+myfiletypefile	syntax.txt	/*myfiletypefile*
+myscriptsfile	syntax.txt	/*myscriptsfile*
+mysql	ft_sql.txt	/*mysql*
+mysyntaxfile	syntax.txt	/*mysyntaxfile*
+mysyntaxfile-add	syntax.txt	/*mysyntaxfile-add*
+mysyntaxfile-replace	syntax.txt	/*mysyntaxfile-replace*
+mzeval()	eval.txt	/*mzeval()*
+mzscheme	if_mzsch.txt	/*mzscheme*
+mzscheme-buffer	if_mzsch.txt	/*mzscheme-buffer*
+mzscheme-commands	if_mzsch.txt	/*mzscheme-commands*
+mzscheme-dynamic	if_mzsch.txt	/*mzscheme-dynamic*
+mzscheme-examples	if_mzsch.txt	/*mzscheme-examples*
+mzscheme-funcref	if_mzsch.txt	/*mzscheme-funcref*
+mzscheme-mzeval	if_mzsch.txt	/*mzscheme-mzeval*
+mzscheme-sandbox	if_mzsch.txt	/*mzscheme-sandbox*
+mzscheme-setup	if_mzsch.txt	/*mzscheme-setup*
+mzscheme-threads	if_mzsch.txt	/*mzscheme-threads*
+mzscheme-vim	if_mzsch.txt	/*mzscheme-vim*
+mzscheme-vimext	if_mzsch.txt	/*mzscheme-vimext*
+mzscheme-window	if_mzsch.txt	/*mzscheme-window*
+n	pattern.txt	/*n*
+n1ql.vim	syntax.txt	/*n1ql.vim*
+nasm.vim	syntax.txt	/*nasm.vim*
+navigation	motion.txt	/*navigation*
+nb-commands	netbeans.txt	/*nb-commands*
+nb-events	netbeans.txt	/*nb-events*
+nb-functions	netbeans.txt	/*nb-functions*
+nb-messages	netbeans.txt	/*nb-messages*
+nb-protocol_errors	netbeans.txt	/*nb-protocol_errors*
+nb-special	netbeans.txt	/*nb-special*
+nb-terms	netbeans.txt	/*nb-terms*
+ncf.vim	syntax.txt	/*ncf.vim*
+netbeans	netbeans.txt	/*netbeans*
+netbeans-commands	netbeans.txt	/*netbeans-commands*
+netbeans-configure	netbeans.txt	/*netbeans-configure*
+netbeans-debugging	netbeans.txt	/*netbeans-debugging*
+netbeans-download	netbeans.txt	/*netbeans-download*
+netbeans-integration	netbeans.txt	/*netbeans-integration*
+netbeans-intro	netbeans.txt	/*netbeans-intro*
+netbeans-keybindings	netbeans.txt	/*netbeans-keybindings*
+netbeans-messages	netbeans.txt	/*netbeans-messages*
+netbeans-parameters	netbeans.txt	/*netbeans-parameters*
+netbeans-preparation	netbeans.txt	/*netbeans-preparation*
+netbeans-problems	netbeans.txt	/*netbeans-problems*
+netbeans-protocol	netbeans.txt	/*netbeans-protocol*
+netbeans-run	netbeans.txt	/*netbeans-run*
+netbeans-setup	netbeans.txt	/*netbeans-setup*
+netbeans-support	netbeans.txt	/*netbeans-support*
+netbeans.txt	netbeans.txt	/*netbeans.txt*
+netreadfixup	pi_netrw.txt	/*netreadfixup*
+netrw	pi_netrw.txt	/*netrw*
+netrw-%	pi_netrw.txt	/*netrw-%*
+netrw--	pi_netrw.txt	/*netrw--*
+netrw-:Explore	pi_netrw.txt	/*netrw-:Explore*
+netrw-:Hexplore	pi_netrw.txt	/*netrw-:Hexplore*
+netrw-:Lexplore	pi_netrw.txt	/*netrw-:Lexplore*
+netrw-:MF	pi_netrw.txt	/*netrw-:MF*
+netrw-:MT	pi_netrw.txt	/*netrw-:MT*
+netrw-:NetrwC	pi_netrw.txt	/*netrw-:NetrwC*
+netrw-:NetrwMB	pi_netrw.txt	/*netrw-:NetrwMB*
+netrw-:Rexplore	pi_netrw.txt	/*netrw-:Rexplore*
+netrw-:Sexplore	pi_netrw.txt	/*netrw-:Sexplore*
+netrw-:Texplore	pi_netrw.txt	/*netrw-:Texplore*
+netrw-:Vexplore	pi_netrw.txt	/*netrw-:Vexplore*
+netrw-C	pi_netrw.txt	/*netrw-C*
+netrw-D	pi_netrw.txt	/*netrw-D*
+netrw-I	pi_netrw.txt	/*netrw-I*
+netrw-O	pi_netrw.txt	/*netrw-O*
+netrw-P	pi_netrw.txt	/*netrw-P*
+netrw-P18	pi_netrw.txt	/*netrw-P18*
+netrw-P19	pi_netrw.txt	/*netrw-P19*
+netrw-P20	pi_netrw.txt	/*netrw-P20*
+netrw-P21	pi_netrw.txt	/*netrw-P21*
+netrw-P22	pi_netrw.txt	/*netrw-P22*
+netrw-R	pi_netrw.txt	/*netrw-R*
+netrw-S	pi_netrw.txt	/*netrw-S*
+netrw-Tb	pi_netrw.txt	/*netrw-Tb*
+netrw-Th	pi_netrw.txt	/*netrw-Th*
+netrw-U	pi_netrw.txt	/*netrw-U*
+netrw-X	pi_netrw.txt	/*netrw-X*
+netrw-a	pi_netrw.txt	/*netrw-a*
+netrw-activate	pi_netrw.txt	/*netrw-activate*
+netrw-bookmark	pi_netrw.txt	/*netrw-bookmark*
+netrw-bookmarks	pi_netrw.txt	/*netrw-bookmarks*
+netrw-browse	pi_netrw.txt	/*netrw-browse*
+netrw-browse-cmds	pi_netrw.txt	/*netrw-browse-cmds*
+netrw-browse-maps	pi_netrw.txt	/*netrw-browse-maps*
+netrw-browser	pi_netrw.txt	/*netrw-browser*
+netrw-browser-options	pi_netrw.txt	/*netrw-browser-options*
+netrw-browser-settings	pi_netrw.txt	/*netrw-browser-settings*
+netrw-browser-var	pi_netrw.txt	/*netrw-browser-var*
+netrw-browsing	pi_netrw.txt	/*netrw-browsing*
+netrw-c	pi_netrw.txt	/*netrw-c*
+netrw-c-tab	pi_netrw.txt	/*netrw-c-tab*
+netrw-cB	pi_netrw.txt	/*netrw-cB*
+netrw-cadaver	pi_netrw.txt	/*netrw-cadaver*
+netrw-call	pi_netrw.txt	/*netrw-call*
+netrw-cb	pi_netrw.txt	/*netrw-cb*
+netrw-cd	pi_netrw.txt	/*netrw-cd*
+netrw-chgup	pi_netrw.txt	/*netrw-chgup*
+netrw-clean	pi_netrw.txt	/*netrw-clean*
+netrw-contents	pi_netrw.txt	/*netrw-contents*
+netrw-copyright	pi_netrw.txt	/*netrw-copyright*
+netrw-cr	pi_netrw.txt	/*netrw-cr*
+netrw-createfile	pi_netrw.txt	/*netrw-createfile*
+netrw-credits	pi_netrw.txt	/*netrw-credits*
+netrw-ctrl-h	pi_netrw.txt	/*netrw-ctrl-h*
+netrw-ctrl-l	pi_netrw.txt	/*netrw-ctrl-l*
+netrw-ctrl-r	pi_netrw.txt	/*netrw-ctrl-r*
+netrw-ctrl_l	pi_netrw.txt	/*netrw-ctrl_l*
+netrw-curdir	pi_netrw.txt	/*netrw-curdir*
+netrw-d	pi_netrw.txt	/*netrw-d*
+netrw-debug	pi_netrw.txt	/*netrw-debug*
+netrw-del	pi_netrw.txt	/*netrw-del*
+netrw-delete	pi_netrw.txt	/*netrw-delete*
+netrw-dir	pi_netrw.txt	/*netrw-dir*
+netrw-dirlist	pi_netrw.txt	/*netrw-dirlist*
+netrw-downdir	pi_netrw.txt	/*netrw-downdir*
+netrw-edithide	pi_netrw.txt	/*netrw-edithide*
+netrw-editwindow	pi_netrw.txt	/*netrw-editwindow*
+netrw-enter	pi_netrw.txt	/*netrw-enter*
+netrw-ex	pi_netrw.txt	/*netrw-ex*
+netrw-explore	pi_netrw.txt	/*netrw-explore*
+netrw-explore-cmds	pi_netrw.txt	/*netrw-explore-cmds*
+netrw-expose	pi_netrw.txt	/*netrw-expose*
+netrw-externapp	pi_netrw.txt	/*netrw-externapp*
+netrw-file	pi_netrw.txt	/*netrw-file*
+netrw-filigree	pi_netrw.txt	/*netrw-filigree*
+netrw-fixup	pi_netrw.txt	/*netrw-fixup*
+netrw-ftp	pi_netrw.txt	/*netrw-ftp*
+netrw-ftype	pi_netrw.txt	/*netrw-ftype*
+netrw-gb	pi_netrw.txt	/*netrw-gb*
+netrw-gd	pi_netrw.txt	/*netrw-gd*
+netrw-getftype	pi_netrw.txt	/*netrw-getftype*
+netrw-gf	pi_netrw.txt	/*netrw-gf*
+netrw-gh	pi_netrw.txt	/*netrw-gh*
+netrw-gitignore	pi_netrw.txt	/*netrw-gitignore*
+netrw-gn	pi_netrw.txt	/*netrw-gn*
+netrw-gp	pi_netrw.txt	/*netrw-gp*
+netrw-grep	pi_netrw.txt	/*netrw-grep*
+netrw-gx	pi_netrw.txt	/*netrw-gx*
+netrw-handler	pi_netrw.txt	/*netrw-handler*
+netrw-help	pi_netrw.txt	/*netrw-help*
+netrw-hexplore	pi_netrw.txt	/*netrw-hexplore*
+netrw-hide	pi_netrw.txt	/*netrw-hide*
+netrw-hiding	pi_netrw.txt	/*netrw-hiding*
+netrw-history	pi_netrw.txt	/*netrw-history*
+netrw-horiz	pi_netrw.txt	/*netrw-horiz*
+netrw-i	pi_netrw.txt	/*netrw-i*
+netrw-incompatible	pi_netrw.txt	/*netrw-incompatible*
+netrw-internal-variables	pi_netrw.txt	/*netrw-internal-variables*
+netrw-intro-browse	pi_netrw.txt	/*netrw-intro-browse*
+netrw-leftmouse	pi_netrw.txt	/*netrw-leftmouse*
+netrw-lexplore	pi_netrw.txt	/*netrw-lexplore*
+netrw-list	pi_netrw.txt	/*netrw-list*
+netrw-listbookmark	pi_netrw.txt	/*netrw-listbookmark*
+netrw-listhack	pi_netrw.txt	/*netrw-listhack*
+netrw-login	pi_netrw.txt	/*netrw-login*
+netrw-mA	pi_netrw.txt	/*netrw-mA*
+netrw-mB	pi_netrw.txt	/*netrw-mB*
+netrw-mF	pi_netrw.txt	/*netrw-mF*
+netrw-mT	pi_netrw.txt	/*netrw-mT*
+netrw-mX	pi_netrw.txt	/*netrw-mX*
+netrw-ma	pi_netrw.txt	/*netrw-ma*
+netrw-mb	pi_netrw.txt	/*netrw-mb*
+netrw-mc	pi_netrw.txt	/*netrw-mc*
+netrw-md	pi_netrw.txt	/*netrw-md*
+netrw-me	pi_netrw.txt	/*netrw-me*
+netrw-mf	pi_netrw.txt	/*netrw-mf*
+netrw-mg	pi_netrw.txt	/*netrw-mg*
+netrw-mh	pi_netrw.txt	/*netrw-mh*
+netrw-middlemouse	pi_netrw.txt	/*netrw-middlemouse*
+netrw-ml_get	pi_netrw.txt	/*netrw-ml_get*
+netrw-mm	pi_netrw.txt	/*netrw-mm*
+netrw-modify	pi_netrw.txt	/*netrw-modify*
+netrw-mouse	pi_netrw.txt	/*netrw-mouse*
+netrw-move	pi_netrw.txt	/*netrw-move*
+netrw-mp	pi_netrw.txt	/*netrw-mp*
+netrw-mr	pi_netrw.txt	/*netrw-mr*
+netrw-ms	pi_netrw.txt	/*netrw-ms*
+netrw-mt	pi_netrw.txt	/*netrw-mt*
+netrw-mu	pi_netrw.txt	/*netrw-mu*
+netrw-mv	pi_netrw.txt	/*netrw-mv*
+netrw-mx	pi_netrw.txt	/*netrw-mx*
+netrw-mz	pi_netrw.txt	/*netrw-mz*
+netrw-netrc	pi_netrw.txt	/*netrw-netrc*
+netrw-newfile	pi_netrw.txt	/*netrw-newfile*
+netrw-nexplore	pi_netrw.txt	/*netrw-nexplore*
+netrw-noload	pi_netrw.txt	/*netrw-noload*
+netrw-nread	pi_netrw.txt	/*netrw-nread*
+netrw-ntree	pi_netrw.txt	/*netrw-ntree*
+netrw-nwrite	pi_netrw.txt	/*netrw-nwrite*
+netrw-o	pi_netrw.txt	/*netrw-o*
+netrw-obtain	pi_netrw.txt	/*netrw-obtain*
+netrw-options	pi_netrw.txt	/*netrw-options*
+netrw-p	pi_netrw.txt	/*netrw-p*
+netrw-p1	pi_netrw.txt	/*netrw-p1*
+netrw-p10	pi_netrw.txt	/*netrw-p10*
+netrw-p11	pi_netrw.txt	/*netrw-p11*
+netrw-p12	pi_netrw.txt	/*netrw-p12*
+netrw-p13	pi_netrw.txt	/*netrw-p13*
+netrw-p14	pi_netrw.txt	/*netrw-p14*
+netrw-p15	pi_netrw.txt	/*netrw-p15*
+netrw-p16	pi_netrw.txt	/*netrw-p16*
+netrw-p17	pi_netrw.txt	/*netrw-p17*
+netrw-p2	pi_netrw.txt	/*netrw-p2*
+netrw-p3	pi_netrw.txt	/*netrw-p3*
+netrw-p4	pi_netrw.txt	/*netrw-p4*
+netrw-p5	pi_netrw.txt	/*netrw-p5*
+netrw-p6	pi_netrw.txt	/*netrw-p6*
+netrw-p7	pi_netrw.txt	/*netrw-p7*
+netrw-p8	pi_netrw.txt	/*netrw-p8*
+netrw-p9	pi_netrw.txt	/*netrw-p9*
+netrw-passwd	pi_netrw.txt	/*netrw-passwd*
+netrw-password	pi_netrw.txt	/*netrw-password*
+netrw-path	pi_netrw.txt	/*netrw-path*
+netrw-pexplore	pi_netrw.txt	/*netrw-pexplore*
+netrw-preview	pi_netrw.txt	/*netrw-preview*
+netrw-problems	pi_netrw.txt	/*netrw-problems*
+netrw-protocol	pi_netrw.txt	/*netrw-protocol*
+netrw-prvwin	pi_netrw.txt	/*netrw-prvwin*
+netrw-pscp	pi_netrw.txt	/*netrw-pscp*
+netrw-psftp	pi_netrw.txt	/*netrw-psftp*
+netrw-putty	pi_netrw.txt	/*netrw-putty*
+netrw-qF	pi_netrw.txt	/*netrw-qF*
+netrw-qL	pi_netrw.txt	/*netrw-qL*
+netrw-qb	pi_netrw.txt	/*netrw-qb*
+netrw-qf	pi_netrw.txt	/*netrw-qf*
+netrw-quickcom	pi_netrw.txt	/*netrw-quickcom*
+netrw-quickcoms	pi_netrw.txt	/*netrw-quickcoms*
+netrw-quickhelp	pi_netrw.txt	/*netrw-quickhelp*
+netrw-quickmap	pi_netrw.txt	/*netrw-quickmap*
+netrw-quickmaps	pi_netrw.txt	/*netrw-quickmaps*
+netrw-r	pi_netrw.txt	/*netrw-r*
+netrw-read	pi_netrw.txt	/*netrw-read*
+netrw-ref	pi_netrw.txt	/*netrw-ref*
+netrw-refresh	pi_netrw.txt	/*netrw-refresh*
+netrw-rename	pi_netrw.txt	/*netrw-rename*
+netrw-reverse	pi_netrw.txt	/*netrw-reverse*
+netrw-rexplore	pi_netrw.txt	/*netrw-rexplore*
+netrw-rightmouse	pi_netrw.txt	/*netrw-rightmouse*
+netrw-s	pi_netrw.txt	/*netrw-s*
+netrw-s-cr	pi_netrw.txt	/*netrw-s-cr*
+netrw-settings	pi_netrw.txt	/*netrw-settings*
+netrw-settings-window	pi_netrw.txt	/*netrw-settings-window*
+netrw-sexplore	pi_netrw.txt	/*netrw-sexplore*
+netrw-sort	pi_netrw.txt	/*netrw-sort*
+netrw-sort-sequence	pi_netrw.txt	/*netrw-sort-sequence*
+netrw-sortsequence	pi_netrw.txt	/*netrw-sortsequence*
+netrw-source	pi_netrw.txt	/*netrw-source*
+netrw-ssh-hack	pi_netrw.txt	/*netrw-ssh-hack*
+netrw-star	pi_netrw.txt	/*netrw-star*
+netrw-starpat	pi_netrw.txt	/*netrw-starpat*
+netrw-starstar	pi_netrw.txt	/*netrw-starstar*
+netrw-starstarpat	pi_netrw.txt	/*netrw-starstarpat*
+netrw-start	pi_netrw.txt	/*netrw-start*
+netrw-t	pi_netrw.txt	/*netrw-t*
+netrw-texplore	pi_netrw.txt	/*netrw-texplore*
+netrw-todo	pi_netrw.txt	/*netrw-todo*
+netrw-trailingslash	pi_netrw.txt	/*netrw-trailingslash*
+netrw-transparent	pi_netrw.txt	/*netrw-transparent*
+netrw-u	pi_netrw.txt	/*netrw-u*
+netrw-updir	pi_netrw.txt	/*netrw-updir*
+netrw-urls	pi_netrw.txt	/*netrw-urls*
+netrw-usermaps	pi_netrw.txt	/*netrw-usermaps*
+netrw-userpass	pi_netrw.txt	/*netrw-userpass*
+netrw-v	pi_netrw.txt	/*netrw-v*
+netrw-var	pi_netrw.txt	/*netrw-var*
+netrw-variables	pi_netrw.txt	/*netrw-variables*
+netrw-vexplore	pi_netrw.txt	/*netrw-vexplore*
+netrw-windows-netrc	pi_netrw.txt	/*netrw-windows-netrc*
+netrw-windows-s	pi_netrw.txt	/*netrw-windows-s*
+netrw-write	pi_netrw.txt	/*netrw-write*
+netrw-x	pi_netrw.txt	/*netrw-x*
+netrw-xfer	pi_netrw.txt	/*netrw-xfer*
+netrw.vim	pi_netrw.txt	/*netrw.vim*
+netrw_filehandler	pi_netrw.txt	/*netrw_filehandler*
+netterm-mouse	options.txt	/*netterm-mouse*
+network	pi_netrw.txt	/*network*
+new-5	version5.txt	/*new-5*
+new-6	version6.txt	/*new-6*
+new-7	version7.txt	/*new-7*
+new-8	version8.txt	/*new-8*
+new-GTK-GUI	version5.txt	/*new-GTK-GUI*
+new-MzScheme	version7.txt	/*new-MzScheme*
+new-Select-mode	version5.txt	/*new-Select-mode*
+new-View	version6.txt	/*new-View*
+new-argument-list	version6.txt	/*new-argument-list*
+new-buftype	version6.txt	/*new-buftype*
+new-cmdwin	version6.txt	/*new-cmdwin*
+new-color-schemes	version6.txt	/*new-color-schemes*
+new-commands	version5.txt	/*new-commands*
+new-commands-5.4	version5.txt	/*new-commands-5.4*
+new-conceal	version7.txt	/*new-conceal*
+new-debug-itf	version6.txt	/*new-debug-itf*
+new-debug-mode	version6.txt	/*new-debug-mode*
+new-debug-support	version7.txt	/*new-debug-support*
+new-define-operator	version7.txt	/*new-define-operator*
+new-diff-mode	version6.txt	/*new-diff-mode*
+new-encryption	version5.txt	/*new-encryption*
+new-evim	version6.txt	/*new-evim*
+new-ex-commands-5.2	version5.txt	/*new-ex-commands-5.2*
+new-file-browser	version6.txt	/*new-file-browser*
+new-file-writing	version6.txt	/*new-file-writing*
+new-filetype	filetype.txt	/*new-filetype*
+new-filetype-5.4	version5.txt	/*new-filetype-5.4*
+new-filetype-plugins	version6.txt	/*new-filetype-plugins*
+new-filetype-scripts	filetype.txt	/*new-filetype-scripts*
+new-folding	version6.txt	/*new-folding*
+new-functions-5.2	version5.txt	/*new-functions-5.2*
+new-global-values	version6.txt	/*new-global-values*
+new-highlighting	version5.txt	/*new-highlighting*
+new-indent-flex	version6.txt	/*new-indent-flex*
+new-items-6	version6.txt	/*new-items-6*
+new-items-7	version7.txt	/*new-items-7*
+new-items-8	version8.txt	/*new-items-8*
+new-line-continuation	version5.txt	/*new-line-continuation*
+new-location-list	version7.txt	/*new-location-list*
+new-lua	version7.txt	/*new-lua*
+new-manpage-trans	version7.txt	/*new-manpage-trans*
+new-map-expression	version7.txt	/*new-map-expression*
+new-map-select	version7.txt	/*new-map-select*
+new-more-encryption	version7.txt	/*new-more-encryption*
+new-more-highlighting	version7.txt	/*new-more-highlighting*
+new-more-unicode	version7.txt	/*new-more-unicode*
+new-multi-byte	version5.txt	/*new-multi-byte*
+new-multi-lang	version6.txt	/*new-multi-lang*
+new-netrw-explore	version7.txt	/*new-netrw-explore*
+new-network-files	version6.txt	/*new-network-files*
+new-omni-completion	version7.txt	/*new-omni-completion*
+new-onemore	version7.txt	/*new-onemore*
+new-operator-mod	version6.txt	/*new-operator-mod*
+new-options-5.2	version5.txt	/*new-options-5.2*
+new-options-5.4	version5.txt	/*new-options-5.4*
+new-perl-python	version5.txt	/*new-perl-python*
+new-persistent-undo	version7.txt	/*new-persistent-undo*
+new-plugins	version6.txt	/*new-plugins*
+new-posix	version7.txt	/*new-posix*
+new-print-multi-byte	version7.txt	/*new-print-multi-byte*
+new-printing	version6.txt	/*new-printing*
+new-python3	version7.txt	/*new-python3*
+new-regexp-engine	version7.txt	/*new-regexp-engine*
+new-runtime-dir	version5.txt	/*new-runtime-dir*
+new-script	version5.txt	/*new-script*
+new-script-5.4	version5.txt	/*new-script-5.4*
+new-scroll-back	version7.txt	/*new-scroll-back*
+new-search-path	version6.txt	/*new-search-path*
+new-searchpat	version6.txt	/*new-searchpat*
+new-session-files	version5.txt	/*new-session-files*
+new-spell	version7.txt	/*new-spell*
+new-style-testing	eval.txt	/*new-style-testing*
+new-tab-pages	version7.txt	/*new-tab-pages*
+new-terminal-window	version8.txt	/*new-terminal-window*
+new-undo-branches	version7.txt	/*new-undo-branches*
+new-unlisted-buffers	version6.txt	/*new-unlisted-buffers*
+new-user-defined	version5.txt	/*new-user-defined*
+new-user-manual	version6.txt	/*new-user-manual*
+new-utf-8	version6.txt	/*new-utf-8*
+new-vertsplit	version6.txt	/*new-vertsplit*
+new-vim-script	version7.txt	/*new-vim-script*
+new-vim-script-8	version8.txt	/*new-vim-script-8*
+new-vim-server	version6.txt	/*new-vim-server*
+new-vimgrep	version7.txt	/*new-vimgrep*
+new-virtedit	version6.txt	/*new-virtedit*
+news	intro.txt	/*news*
+nextnonblank()	eval.txt	/*nextnonblank()*
+nice	todo.txt	/*nice*
+no-eval-feature	eval.txt	/*no-eval-feature*
+no-type-checking	eval.txt	/*no-type-checking*
+no_buffers_menu	gui.txt	/*no_buffers_menu*
+no_mail_maps	filetype.txt	/*no_mail_maps*
+no_plugin_maps	filetype.txt	/*no_plugin_maps*
+nocombine	syntax.txt	/*nocombine*
+non-greedy	pattern.txt	/*non-greedy*
+non-zero-arg	eval.txt	/*non-zero-arg*
+none-variable	eval.txt	/*none-variable*
+normal-index	index.txt	/*normal-index*
+not-compatible	usr_01.txt	/*not-compatible*
+not-edited	editing.txt	/*not-edited*
+notation	intro.txt	/*notation*
+notepad	gui_w32.txt	/*notepad*
+nr2char()	eval.txt	/*nr2char()*
+nroff.vim	syntax.txt	/*nroff.vim*
+null-variable	eval.txt	/*null-variable*
+number_relativenumber	options.txt	/*number_relativenumber*
+numbered-function	eval.txt	/*numbered-function*
+o	insert.txt	/*o*
+o_CTRL-V	motion.txt	/*o_CTRL-V*
+o_V	motion.txt	/*o_V*
+o_v	motion.txt	/*o_v*
+object-motions	motion.txt	/*object-motions*
+object-select	motion.txt	/*object-select*
+objects	index.txt	/*objects*
+obtaining-exted	netbeans.txt	/*obtaining-exted*
+ocaml.vim	syntax.txt	/*ocaml.vim*
+octal	eval.txt	/*octal*
+octal-nrformats	options.txt	/*octal-nrformats*
+octal-number	eval.txt	/*octal-number*
+old-style-testing	eval.txt	/*old-style-testing*
+oldfiles-variable	eval.txt	/*oldfiles-variable*
+ole-activation	if_ole.txt	/*ole-activation*
+ole-eval	if_ole.txt	/*ole-eval*
+ole-gethwnd	if_ole.txt	/*ole-gethwnd*
+ole-interface	if_ole.txt	/*ole-interface*
+ole-methods	if_ole.txt	/*ole-methods*
+ole-normal	if_ole.txt	/*ole-normal*
+ole-registration	if_ole.txt	/*ole-registration*
+ole-sendkeys	if_ole.txt	/*ole-sendkeys*
+ole-setforeground	if_ole.txt	/*ole-setforeground*
+omap-info	map.txt	/*omap-info*
+omni-sql-completion	ft_sql.txt	/*omni-sql-completion*
+online-help	helphelp.txt	/*online-help*
+opening-window	windows.txt	/*opening-window*
+operator	motion.txt	/*operator*
+operator-variable	eval.txt	/*operator-variable*
+option-backslash	options.txt	/*option-backslash*
+option-list	quickref.txt	/*option-list*
+option-summary	options.txt	/*option-summary*
+option-window	options.txt	/*option-window*
+option_restore()	todo.txt	/*option_restore()*
+option_save()	todo.txt	/*option_save()*
+options	options.txt	/*options*
+options-changed	version5.txt	/*options-changed*
+options-in-terminal	terminal.txt	/*options-in-terminal*
+options.txt	options.txt	/*options.txt*
+optwin	options.txt	/*optwin*
+or()	eval.txt	/*or()*
+oracle	ft_sql.txt	/*oracle*
+os2	os_os2.txt	/*os2*
+os390	os_390.txt	/*os390*
+os_390.txt	os_390.txt	/*os_390.txt*
+os_amiga.txt	os_amiga.txt	/*os_amiga.txt*
+os_beos.txt	os_beos.txt	/*os_beos.txt*
+os_dos.txt	os_dos.txt	/*os_dos.txt*
+os_mac.txt	os_mac.txt	/*os_mac.txt*
+os_mint.txt	os_mint.txt	/*os_mint.txt*
+os_msdos.txt	os_msdos.txt	/*os_msdos.txt*
+os_os2.txt	os_os2.txt	/*os_os2.txt*
+os_qnx.txt	os_qnx.txt	/*os_qnx.txt*
+os_risc.txt	os_risc.txt	/*os_risc.txt*
+os_unix.txt	os_unix.txt	/*os_unix.txt*
+os_vms.txt	os_vms.txt	/*os_vms.txt*
+os_win32.txt	os_win32.txt	/*os_win32.txt*
+other-features	vi_diff.txt	/*other-features*
+out_buf	channel.txt	/*out_buf*
+out_cb	channel.txt	/*out_cb*
+out_io-buffer	channel.txt	/*out_io-buffer*
+out_mode	channel.txt	/*out_mode*
+out_modifiable	channel.txt	/*out_modifiable*
+out_msg	channel.txt	/*out_msg*
+out_name	channel.txt	/*out_name*
+out_timeout	channel.txt	/*out_timeout*
+p	change.txt	/*p*
+pack-add	repeat.txt	/*pack-add*
+package-create	repeat.txt	/*package-create*
+packages	repeat.txt	/*packages*
+packload-two-steps	repeat.txt	/*packload-two-steps*
+page-down	intro.txt	/*page-down*
+page-up	intro.txt	/*page-up*
+page_down	intro.txt	/*page_down*
+page_up	intro.txt	/*page_up*
+pager	message.txt	/*pager*
+papp.vim	syntax.txt	/*papp.vim*
+paragraph	motion.txt	/*paragraph*
+pascal.vim	syntax.txt	/*pascal.vim*
+patches-8	version8.txt	/*patches-8*
+patches-8.1	version8.txt	/*patches-8.1*
+pathshorten()	eval.txt	/*pathshorten()*
+pattern	pattern.txt	/*pattern*
+pattern-atoms	pattern.txt	/*pattern-atoms*
+pattern-multi-byte	pattern.txt	/*pattern-multi-byte*
+pattern-multi-items	pattern.txt	/*pattern-multi-items*
+pattern-overview	pattern.txt	/*pattern-overview*
+pattern-searches	pattern.txt	/*pattern-searches*
+pattern.txt	pattern.txt	/*pattern.txt*
+patterns-composing	pattern.txt	/*patterns-composing*
+pdev-option	print.txt	/*pdev-option*
+peace	intro.txt	/*peace*
+penc-option	print.txt	/*penc-option*
+perl	if_perl.txt	/*perl*
+perl-Append	if_perl.txt	/*perl-Append*
+perl-Buffer	if_perl.txt	/*perl-Buffer*
+perl-Buffers	if_perl.txt	/*perl-Buffers*
+perl-Count	if_perl.txt	/*perl-Count*
+perl-Delete	if_perl.txt	/*perl-Delete*
+perl-DoCommand	if_perl.txt	/*perl-DoCommand*
+perl-Eval	if_perl.txt	/*perl-Eval*
+perl-Get	if_perl.txt	/*perl-Get*
+perl-GetCursor	if_perl.txt	/*perl-GetCursor*
+perl-Msg	if_perl.txt	/*perl-Msg*
+perl-Name	if_perl.txt	/*perl-Name*
+perl-Number	if_perl.txt	/*perl-Number*
+perl-Set	if_perl.txt	/*perl-Set*
+perl-SetHeight	if_perl.txt	/*perl-SetHeight*
+perl-SetOption	if_perl.txt	/*perl-SetOption*
+perl-Windows	if_perl.txt	/*perl-Windows*
+perl-compiling	if_perl.txt	/*perl-compiling*
+perl-dynamic	if_perl.txt	/*perl-dynamic*
+perl-editing	if_perl.txt	/*perl-editing*
+perl-overview	if_perl.txt	/*perl-overview*
+perl-patterns	pattern.txt	/*perl-patterns*
+perl-using	if_perl.txt	/*perl-using*
+perl.vim	syntax.txt	/*perl.vim*
+perleval()	eval.txt	/*perleval()*
+persistent-undo	undo.txt	/*persistent-undo*
+pexpr-option	print.txt	/*pexpr-option*
+pfn-option	print.txt	/*pfn-option*
+pheader-option	print.txt	/*pheader-option*
+photon-fonts	os_qnx.txt	/*photon-fonts*
+photon-gui	os_qnx.txt	/*photon-gui*
+php-comment	indent.txt	/*php-comment*
+php-indent	indent.txt	/*php-indent*
+php-indenting	indent.txt	/*php-indenting*
+php.vim	syntax.txt	/*php.vim*
+php3.vim	syntax.txt	/*php3.vim*
+phtml.vim	syntax.txt	/*phtml.vim*
+pi_getscript.txt	pi_getscript.txt	/*pi_getscript.txt*
+pi_gzip.txt	pi_gzip.txt	/*pi_gzip.txt*
+pi_logipat.txt	pi_logipat.txt	/*pi_logipat.txt*
+pi_netrw.txt	pi_netrw.txt	/*pi_netrw.txt*
+pi_paren.txt	pi_paren.txt	/*pi_paren.txt*
+pi_spec.txt	pi_spec.txt	/*pi_spec.txt*
+pi_tar.txt	pi_tar.txt	/*pi_tar.txt*
+pi_vimball.txt	pi_vimball.txt	/*pi_vimball.txt*
+pi_zip.txt	pi_zip.txt	/*pi_zip.txt*
+pkzip	options.txt	/*pkzip*
+plaintex.vim	syntax.txt	/*plaintex.vim*
+plsql	ft_sql.txt	/*plsql*
+plugin	usr_05.txt	/*plugin*
+plugin-details	filetype.txt	/*plugin-details*
+plugin-filetype	usr_41.txt	/*plugin-filetype*
+plugin-special	usr_41.txt	/*plugin-special*
+pmbcs-option	print.txt	/*pmbcs-option*
+pmbfn-option	print.txt	/*pmbfn-option*
+popt-option	print.txt	/*popt-option*
+popup-menu	gui.txt	/*popup-menu*
+popup-menu-added	version5.txt	/*popup-menu-added*
+popupmenu-completion	insert.txt	/*popupmenu-completion*
+popupmenu-keys	insert.txt	/*popupmenu-keys*
+ports-5.2	version5.txt	/*ports-5.2*
+ports-6	version6.txt	/*ports-6*
+posix	vi_diff.txt	/*posix*
+posix-compliance	vi_diff.txt	/*posix-compliance*
+posix-screen-size	vi_diff.txt	/*posix-screen-size*
+postgresql	ft_sql.txt	/*postgresql*
+postscr.vim	syntax.txt	/*postscr.vim*
+postscript-cjk-printing	print.txt	/*postscript-cjk-printing*
+postscript-print-encoding	print.txt	/*postscript-print-encoding*
+postscript-print-trouble	print.txt	/*postscript-print-trouble*
+postscript-print-util	print.txt	/*postscript-print-util*
+postscript-printing	print.txt	/*postscript-printing*
+pow()	eval.txt	/*pow()*
+ppwiz.vim	syntax.txt	/*ppwiz.vim*
+press-enter	message.txt	/*press-enter*
+press-return	message.txt	/*press-return*
+prevcount-variable	eval.txt	/*prevcount-variable*
+preview-window	windows.txt	/*preview-window*
+prevnonblank()	eval.txt	/*prevnonblank()*
+print-intro	print.txt	/*print-intro*
+print-options	print.txt	/*print-options*
+print.txt	print.txt	/*print.txt*
+printf()	eval.txt	/*printf()*
+printf-%	eval.txt	/*printf-%*
+printf-B	eval.txt	/*printf-B*
+printf-E	eval.txt	/*printf-E*
+printf-G	eval.txt	/*printf-G*
+printf-S	eval.txt	/*printf-S*
+printf-X	eval.txt	/*printf-X*
+printf-b	eval.txt	/*printf-b*
+printf-c	eval.txt	/*printf-c*
+printf-d	eval.txt	/*printf-d*
+printf-e	eval.txt	/*printf-e*
+printf-f	eval.txt	/*printf-f*
+printf-g	eval.txt	/*printf-g*
+printf-o	eval.txt	/*printf-o*
+printf-s	eval.txt	/*printf-s*
+printf-x	eval.txt	/*printf-x*
+printing	print.txt	/*printing*
+printing-formfeed	print.txt	/*printing-formfeed*
+profile	repeat.txt	/*profile*
+profiling	repeat.txt	/*profiling*
+profiling-variable	eval.txt	/*profiling-variable*
+progname-variable	eval.txt	/*progname-variable*
+progpath-variable	eval.txt	/*progpath-variable*
+progress.vim	syntax.txt	/*progress.vim*
+prompt-buffer	channel.txt	/*prompt-buffer*
+prompt_setcallback()	eval.txt	/*prompt_setcallback()*
+prompt_setinterrupt()	eval.txt	/*prompt_setinterrupt()*
+prompt_setprompt()	eval.txt	/*prompt_setprompt()*
+pronounce	intro.txt	/*pronounce*
+psql	ft_sql.txt	/*psql*
+ptcap.vim	syntax.txt	/*ptcap.vim*
+pterm-mouse	options.txt	/*pterm-mouse*
+pumvisible()	eval.txt	/*pumvisible()*
+put	change.txt	/*put*
+put-Visual-mode	change.txt	/*put-Visual-mode*
+py3eval()	eval.txt	/*py3eval()*
+pyeval()	eval.txt	/*pyeval()*
+python	if_pyth.txt	/*python*
+python-.locked	if_pyth.txt	/*python-.locked*
+python-2-and-3	if_pyth.txt	/*python-2-and-3*
+python-Dictionary	if_pyth.txt	/*python-Dictionary*
+python-Function	if_pyth.txt	/*python-Function*
+python-List	if_pyth.txt	/*python-List*
+python-VIM_SPECIAL_PATH	if_pyth.txt	/*python-VIM_SPECIAL_PATH*
+python-_get_paths	if_pyth.txt	/*python-_get_paths*
+python-bindeval	if_pyth.txt	/*python-bindeval*
+python-bindeval-objects	if_pyth.txt	/*python-bindeval-objects*
+python-buffer	if_pyth.txt	/*python-buffer*
+python-buffers	if_pyth.txt	/*python-buffers*
+python-building	if_pyth.txt	/*python-building*
+python-chdir	if_pyth.txt	/*python-chdir*
+python-command	if_pyth.txt	/*python-command*
+python-commands	if_pyth.txt	/*python-commands*
+python-current	if_pyth.txt	/*python-current*
+python-dynamic	if_pyth.txt	/*python-dynamic*
+python-error	if_pyth.txt	/*python-error*
+python-eval	if_pyth.txt	/*python-eval*
+python-examples	if_pyth.txt	/*python-examples*
+python-fchdir	if_pyth.txt	/*python-fchdir*
+python-find_module	if_pyth.txt	/*python-find_module*
+python-foreach_rtp	if_pyth.txt	/*python-foreach_rtp*
+python-input	if_pyth.txt	/*python-input*
+python-options	if_pyth.txt	/*python-options*
+python-output	if_pyth.txt	/*python-output*
+python-path_hook	if_pyth.txt	/*python-path_hook*
+python-pyeval	if_pyth.txt	/*python-pyeval*
+python-range	if_pyth.txt	/*python-range*
+python-special-path	if_pyth.txt	/*python-special-path*
+python-strwidth	if_pyth.txt	/*python-strwidth*
+python-tabpage	if_pyth.txt	/*python-tabpage*
+python-tabpages	if_pyth.txt	/*python-tabpages*
+python-vars	if_pyth.txt	/*python-vars*
+python-vim	if_pyth.txt	/*python-vim*
+python-vvars	if_pyth.txt	/*python-vvars*
+python-window	if_pyth.txt	/*python-window*
+python-windows	if_pyth.txt	/*python-windows*
+python.vim	syntax.txt	/*python.vim*
+python2-directory	if_pyth.txt	/*python2-directory*
+python3	if_pyth.txt	/*python3*
+python3-directory	if_pyth.txt	/*python3-directory*
+python_x	if_pyth.txt	/*python_x*
+python_x-special-comments	if_pyth.txt	/*python_x-special-comments*
+pythonx	if_pyth.txt	/*pythonx*
+pythonx-directory	if_pyth.txt	/*pythonx-directory*
+pyxeval()	eval.txt	/*pyxeval()*
+q	repeat.txt	/*q*
+q/	cmdline.txt	/*q\/*
+q:	cmdline.txt	/*q:*
+q?	cmdline.txt	/*q?*
+qnx	os_qnx.txt	/*qnx*
+qnx-compiling	os_qnx.txt	/*qnx-compiling*
+qnx-general	os_qnx.txt	/*qnx-general*
+qnx-terminal	os_qnx.txt	/*qnx-terminal*
+quake.vim	syntax.txt	/*quake.vim*
+quickfix	quickfix.txt	/*quickfix*
+quickfix-6	version6.txt	/*quickfix-6*
+quickfix-ID	quickfix.txt	/*quickfix-ID*
+quickfix-changedtick	quickfix.txt	/*quickfix-changedtick*
+quickfix-context	quickfix.txt	/*quickfix-context*
+quickfix-directory-stack	quickfix.txt	/*quickfix-directory-stack*
+quickfix-error-lists	quickfix.txt	/*quickfix-error-lists*
+quickfix-functions	usr_41.txt	/*quickfix-functions*
+quickfix-gcc	quickfix.txt	/*quickfix-gcc*
+quickfix-manx	quickfix.txt	/*quickfix-manx*
+quickfix-parse	quickfix.txt	/*quickfix-parse*
+quickfix-perl	quickfix.txt	/*quickfix-perl*
+quickfix-size	quickfix.txt	/*quickfix-size*
+quickfix-title	quickfix.txt	/*quickfix-title*
+quickfix-valid	quickfix.txt	/*quickfix-valid*
+quickfix-window	quickfix.txt	/*quickfix-window*
+quickfix-window-ID	quickfix.txt	/*quickfix-window-ID*
+quickfix.txt	quickfix.txt	/*quickfix.txt*
+quickref	quickref.txt	/*quickref*
+quickref.txt	quickref.txt	/*quickref.txt*
+quote	change.txt	/*quote*
+quote#	change.txt	/*quote#*
+quote%	change.txt	/*quote%*
+quote+	gui_x11.txt	/*quote+*
+quote-	change.txt	/*quote-*
+quote.	change.txt	/*quote.*
+quote/	change.txt	/*quote\/*
+quote0	change.txt	/*quote0*
+quote1	change.txt	/*quote1*
+quote2	change.txt	/*quote2*
+quote3	change.txt	/*quote3*
+quote4	change.txt	/*quote4*
+quote9	change.txt	/*quote9*
+quote:	change.txt	/*quote:*
+quote=	change.txt	/*quote=*
+quote_	change.txt	/*quote_*
+quote_#	change.txt	/*quote_#*
+quote_%	change.txt	/*quote_%*
+quote_-	change.txt	/*quote_-*
+quote_.	change.txt	/*quote_.*
+quote_/	change.txt	/*quote_\/*
+quote_:	change.txt	/*quote_:*
+quote_=	change.txt	/*quote_=*
+quote_alpha	change.txt	/*quote_alpha*
+quote_number	change.txt	/*quote_number*
+quote_quote	change.txt	/*quote_quote*
+quote_~	change.txt	/*quote_~*
+quotea	change.txt	/*quotea*
+quotecommandquote	intro.txt	/*quotecommandquote*
+quoteplus	gui_x11.txt	/*quoteplus*
+quotequote	change.txt	/*quotequote*
+quotes	quotes.txt	/*quotes*
+quotes.txt	quotes.txt	/*quotes.txt*
+quotestar	gui.txt	/*quotestar*
+quote~	change.txt	/*quote~*
+r	change.txt	/*r*
+r.vim	syntax.txt	/*r.vim*
+range()	eval.txt	/*range()*
+raw-terminal-mode	term.txt	/*raw-terminal-mode*
+rcp	pi_netrw.txt	/*rcp*
+read-in-close-cb	channel.txt	/*read-in-close-cb*
+read-messages	insert.txt	/*read-messages*
+read-only-share	editing.txt	/*read-only-share*
+read-stdin	version5.txt	/*read-stdin*
+readfile()	eval.txt	/*readfile()*
+readline.vim	syntax.txt	/*readline.vim*
+recording	repeat.txt	/*recording*
+recover.txt	recover.txt	/*recover.txt*
+recovery	recover.txt	/*recovery*
+recursive_mapping	map.txt	/*recursive_mapping*
+redo	undo.txt	/*redo*
+redo-register	undo.txt	/*redo-register*
+ref	intro.txt	/*ref*
+reference	intro.txt	/*reference*
+reference_toc	help.txt	/*reference_toc*
+reg_executing()	eval.txt	/*reg_executing()*
+reg_recording()	eval.txt	/*reg_recording()*
+regexp	pattern.txt	/*regexp*
+regexp-changes-5.4	version5.txt	/*regexp-changes-5.4*
+register	sponsor.txt	/*register*
+register-faq	sponsor.txt	/*register-faq*
+register-variable	eval.txt	/*register-variable*
+registers	change.txt	/*registers*
+regular-expression	pattern.txt	/*regular-expression*
+reload	editing.txt	/*reload*
+reltime()	eval.txt	/*reltime()*
+reltimefloat()	eval.txt	/*reltimefloat()*
+reltimestr()	eval.txt	/*reltimestr()*
+remote.txt	remote.txt	/*remote.txt*
+remote_expr()	eval.txt	/*remote_expr()*
+remote_foreground()	eval.txt	/*remote_foreground()*
+remote_peek()	eval.txt	/*remote_peek()*
+remote_read()	eval.txt	/*remote_read()*
+remote_send()	eval.txt	/*remote_send()*
+remote_startserver()	eval.txt	/*remote_startserver()*
+remove()	eval.txt	/*remove()*
+remove-filetype	filetype.txt	/*remove-filetype*
+remove-option-flags	options.txt	/*remove-option-flags*
+rename()	eval.txt	/*rename()*
+rename-files	tips.txt	/*rename-files*
+repeat()	eval.txt	/*repeat()*
+repeat.txt	repeat.txt	/*repeat.txt*
+repeating	repeat.txt	/*repeating*
+replacing	change.txt	/*replacing*
+replacing-ex	insert.txt	/*replacing-ex*
+reselect-Visual	visual.txt	/*reselect-Visual*
+resolve()	eval.txt	/*resolve()*
+restore-cursor	usr_05.txt	/*restore-cursor*
+restore-position	tips.txt	/*restore-position*
+restricted-mode	starting.txt	/*restricted-mode*
+retab-example	change.txt	/*retab-example*
+rethrow	eval.txt	/*rethrow*
+reverse()	eval.txt	/*reverse()*
+rexx.vim	syntax.txt	/*rexx.vim*
+rgb.txt	gui_w32.txt	/*rgb.txt*
+rgview	starting.txt	/*rgview*
+rgvim	starting.txt	/*rgvim*
+right-justify	change.txt	/*right-justify*
+rileft	rileft.txt	/*rileft*
+rileft.txt	rileft.txt	/*rileft.txt*
+riscos	os_risc.txt	/*riscos*
+rmd.vim	syntax.txt	/*rmd.vim*
+rot13	change.txt	/*rot13*
+round()	eval.txt	/*round()*
+rrst.vim	syntax.txt	/*rrst.vim*
+rst.vim	syntax.txt	/*rst.vim*
+rsync	pi_netrw.txt	/*rsync*
+ruby	if_ruby.txt	/*ruby*
+ruby-buffer	if_ruby.txt	/*ruby-buffer*
+ruby-command	if_ruby.txt	/*ruby-command*
+ruby-commands	if_ruby.txt	/*ruby-commands*
+ruby-dynamic	if_ruby.txt	/*ruby-dynamic*
+ruby-evaluate	if_ruby.txt	/*ruby-evaluate*
+ruby-globals	if_ruby.txt	/*ruby-globals*
+ruby-message	if_ruby.txt	/*ruby-message*
+ruby-set_option	if_ruby.txt	/*ruby-set_option*
+ruby-vim	if_ruby.txt	/*ruby-vim*
+ruby-window	if_ruby.txt	/*ruby-window*
+ruby.vim	syntax.txt	/*ruby.vim*
+ruby_fold	syntax.txt	/*ruby_fold*
+ruby_foldable_groups	syntax.txt	/*ruby_foldable_groups*
+ruby_minlines	syntax.txt	/*ruby_minlines*
+ruby_no_expensive	syntax.txt	/*ruby_no_expensive*
+ruby_operators	syntax.txt	/*ruby_operators*
+ruby_space_errors	syntax.txt	/*ruby_space_errors*
+ruby_spellcheck_strings	syntax.txt	/*ruby_spellcheck_strings*
+russian	russian.txt	/*russian*
+russian-intro	russian.txt	/*russian-intro*
+russian-issues	russian.txt	/*russian-issues*
+russian-keymap	russian.txt	/*russian-keymap*
+russian-l18n	russian.txt	/*russian-l18n*
+russian.txt	russian.txt	/*russian.txt*
+rust	ft_rust.txt	/*rust*
+rust-commands	ft_rust.txt	/*rust-commands*
+rust-intro	ft_rust.txt	/*rust-intro*
+rust-mappings	ft_rust.txt	/*rust-mappings*
+rust-settings	ft_rust.txt	/*rust-settings*
+rust_<D-R>	ft_rust.txt	/*rust_<D-R>*
+rust_<D-r>	ft_rust.txt	/*rust_<D-r>*
+rview	starting.txt	/*rview*
+rvim	starting.txt	/*rvim*
+rxvt	syntax.txt	/*rxvt*
+s	change.txt	/*s*
+s/\&	change.txt	/*s\/\\&*
+s/\0	change.txt	/*s\/\\0*
+s/\1	change.txt	/*s\/\\1*
+s/\2	change.txt	/*s\/\\2*
+s/\3	change.txt	/*s\/\\3*
+s/\9	change.txt	/*s\/\\9*
+s/\<CR>	change.txt	/*s\/\\<CR>*
+s/\=	change.txt	/*s\/\\=*
+s/\E	change.txt	/*s\/\\E*
+s/\L	change.txt	/*s\/\\L*
+s/\U	change.txt	/*s\/\\U*
+s/\\	change.txt	/*s\/\\\\*
+s/\b	change.txt	/*s\/\\b*
+s/\e	change.txt	/*s\/\\e*
+s/\l	change.txt	/*s\/\\l*
+s/\n	change.txt	/*s\/\\n*
+s/\r	change.txt	/*s\/\\r*
+s/\t	change.txt	/*s\/\\t*
+s/\u	change.txt	/*s\/\\u*
+s/\~	change.txt	/*s\/\\~*
+s:netrw_passwd	pi_netrw.txt	/*s:netrw_passwd*
+s:var	eval.txt	/*s:var*
+s<CR>	change.txt	/*s<CR>*
+sandbox	eval.txt	/*sandbox*
+sandbox-option	eval.txt	/*sandbox-option*
+save-file	editing.txt	/*save-file*
+save-settings	starting.txt	/*save-settings*
+scheme.vim	syntax.txt	/*scheme.vim*
+scp	pi_netrw.txt	/*scp*
+screenattr()	eval.txt	/*screenattr()*
+screenchar()	eval.txt	/*screenchar()*
+screencol()	eval.txt	/*screencol()*
+screenrow()	eval.txt	/*screenrow()*
+script	usr_41.txt	/*script*
+script-here	if_perl.txt	/*script-here*
+script-local	map.txt	/*script-local*
+script-variable	eval.txt	/*script-variable*
+scriptnames-dictionary	eval.txt	/*scriptnames-dictionary*
+scriptout-changed	version4.txt	/*scriptout-changed*
+scroll-binding	scroll.txt	/*scroll-binding*
+scroll-cursor	scroll.txt	/*scroll-cursor*
+scroll-down	scroll.txt	/*scroll-down*
+scroll-horizontal	scroll.txt	/*scroll-horizontal*
+scroll-insert	tips.txt	/*scroll-insert*
+scroll-mouse-wheel	scroll.txt	/*scroll-mouse-wheel*
+scroll-region	term.txt	/*scroll-region*
+scroll-smooth	tips.txt	/*scroll-smooth*
+scroll-up	scroll.txt	/*scroll-up*
+scroll.txt	scroll.txt	/*scroll.txt*
+scrollbind-quickadj	scroll.txt	/*scrollbind-quickadj*
+scrollbind-relative	scroll.txt	/*scrollbind-relative*
+scrolling	scroll.txt	/*scrolling*
+scrollstart-variable	eval.txt	/*scrollstart-variable*
+sdl.vim	syntax.txt	/*sdl.vim*
+search()	eval.txt	/*search()*
+search()-sub-match	eval.txt	/*search()-sub-match*
+search-commands	pattern.txt	/*search-commands*
+search-offset	pattern.txt	/*search-offset*
+search-pattern	pattern.txt	/*search-pattern*
+search-range	pattern.txt	/*search-range*
+search-replace	change.txt	/*search-replace*
+searchdecl()	eval.txt	/*searchdecl()*
+searchforward-variable	eval.txt	/*searchforward-variable*
+searchpair()	eval.txt	/*searchpair()*
+searchpairpos()	eval.txt	/*searchpairpos()*
+searchpos()	eval.txt	/*searchpos()*
+section	motion.txt	/*section*
+sed.vim	syntax.txt	/*sed.vim*
+self	eval.txt	/*self*
+send-money	sponsor.txt	/*send-money*
+send-to-menu	gui_w32.txt	/*send-to-menu*
+sendto	gui_w32.txt	/*sendto*
+sentence	motion.txt	/*sentence*
+server-functions	usr_41.txt	/*server-functions*
+server2client()	eval.txt	/*server2client()*
+serverlist()	eval.txt	/*serverlist()*
+servername-variable	eval.txt	/*servername-variable*
+session-file	starting.txt	/*session-file*
+set-option	options.txt	/*set-option*
+set-spc-auto	spell.txt	/*set-spc-auto*
+setbufline()	eval.txt	/*setbufline()*
+setbufvar()	eval.txt	/*setbufvar()*
+setcharsearch()	eval.txt	/*setcharsearch()*
+setcmdpos()	eval.txt	/*setcmdpos()*
+setfperm()	eval.txt	/*setfperm()*
+setline()	eval.txt	/*setline()*
+setloclist()	eval.txt	/*setloclist()*
+setmatches()	eval.txt	/*setmatches()*
+setpos()	eval.txt	/*setpos()*
+setqflist()	eval.txt	/*setqflist()*
+setqflist-examples	quickfix.txt	/*setqflist-examples*
+setreg()	eval.txt	/*setreg()*
+settabvar()	eval.txt	/*settabvar()*
+settabwinvar()	eval.txt	/*settabwinvar()*
+setting-guifont	gui.txt	/*setting-guifont*
+setting-guitablabel	tabpage.txt	/*setting-guitablabel*
+setting-tabline	tabpage.txt	/*setting-tabline*
+setuid	change.txt	/*setuid*
+setwinvar()	eval.txt	/*setwinvar()*
+sftp	pi_netrw.txt	/*sftp*
+sgml.vim	syntax.txt	/*sgml.vim*
+sgr-mouse	options.txt	/*sgr-mouse*
+sh-awk	syntax.txt	/*sh-awk*
+sh-embed	syntax.txt	/*sh-embed*
+sh.vim	syntax.txt	/*sh.vim*
+sha256()	eval.txt	/*sha256()*
+shell-window	tips.txt	/*shell-window*
+shell_error-variable	eval.txt	/*shell_error-variable*
+shellescape()	eval.txt	/*shellescape()*
+shift	intro.txt	/*shift*
+shift-left-right	change.txt	/*shift-left-right*
+shiftwidth()	eval.txt	/*shiftwidth()*
+short-name-changed	version4.txt	/*short-name-changed*
+showing-menus	gui.txt	/*showing-menus*
+sign-commands	sign.txt	/*sign-commands*
+sign-intro	sign.txt	/*sign-intro*
+sign-support	sign.txt	/*sign-support*
+sign.txt	sign.txt	/*sign.txt*
+signs	sign.txt	/*signs*
+simple-change	change.txt	/*simple-change*
+simplify()	eval.txt	/*simplify()*
+simulated-command	vi_diff.txt	/*simulated-command*
+sin()	eval.txt	/*sin()*
+single-repeat	repeat.txt	/*single-repeat*
+sinh()	eval.txt	/*sinh()*
+skeleton	autocmd.txt	/*skeleton*
+skip_defaults_vim	starting.txt	/*skip_defaults_vim*
+slice	eval.txt	/*slice*
+slow-fast-terminal	term.txt	/*slow-fast-terminal*
+slow-start	starting.txt	/*slow-start*
+slow-terminal	term.txt	/*slow-terminal*
+socket-interface	channel.txt	/*socket-interface*
+sort()	eval.txt	/*sort()*
+sorting	change.txt	/*sorting*
+soundfold()	eval.txt	/*soundfold()*
+space	intro.txt	/*space*
+spec-customizing	pi_spec.txt	/*spec-customizing*
+spec-how-to-use-it	pi_spec.txt	/*spec-how-to-use-it*
+spec-setting-a-map	pi_spec.txt	/*spec-setting-a-map*
+spec_chglog_format	pi_spec.txt	/*spec_chglog_format*
+spec_chglog_prepend	pi_spec.txt	/*spec_chglog_prepend*
+spec_chglog_release_info	pi_spec.txt	/*spec_chglog_release_info*
+special-buffers	windows.txt	/*special-buffers*
+speed-up	tips.txt	/*speed-up*
+spell	spell.txt	/*spell*
+spell-ACCENT	spell.txt	/*spell-ACCENT*
+spell-AUTHOR	spell.txt	/*spell-AUTHOR*
+spell-BAD	spell.txt	/*spell-BAD*
+spell-BREAK	spell.txt	/*spell-BREAK*
+spell-CHECKCOMPOUNDCASE	spell.txt	/*spell-CHECKCOMPOUNDCASE*
+spell-CHECKCOMPOUNDDUP	spell.txt	/*spell-CHECKCOMPOUNDDUP*
+spell-CHECKCOMPOUNDPATTERN	spell.txt	/*spell-CHECKCOMPOUNDPATTERN*
+spell-CHECKCOMPOUNDREP	spell.txt	/*spell-CHECKCOMPOUNDREP*
+spell-CHECKCOMPOUNDTRIPLE	spell.txt	/*spell-CHECKCOMPOUNDTRIPLE*
+spell-CIRCUMFIX	spell.txt	/*spell-CIRCUMFIX*
+spell-COMMON	spell.txt	/*spell-COMMON*
+spell-COMPLEXPREFIXES	spell.txt	/*spell-COMPLEXPREFIXES*
+spell-COMPOUND	spell.txt	/*spell-COMPOUND*
+spell-COMPOUNDBEGIN	spell.txt	/*spell-COMPOUNDBEGIN*
+spell-COMPOUNDEND	spell.txt	/*spell-COMPOUNDEND*
+spell-COMPOUNDFIRST	spell.txt	/*spell-COMPOUNDFIRST*
+spell-COMPOUNDFLAG	spell.txt	/*spell-COMPOUNDFLAG*
+spell-COMPOUNDFORBIDFLAG	spell.txt	/*spell-COMPOUNDFORBIDFLAG*
+spell-COMPOUNDMIDDLE	spell.txt	/*spell-COMPOUNDMIDDLE*
+spell-COMPOUNDMIN	spell.txt	/*spell-COMPOUNDMIN*
+spell-COMPOUNDPERMITFLAG	spell.txt	/*spell-COMPOUNDPERMITFLAG*
+spell-COMPOUNDROOT	spell.txt	/*spell-COMPOUNDROOT*
+spell-COMPOUNDRULE	spell.txt	/*spell-COMPOUNDRULE*
+spell-COMPOUNDRULES	spell.txt	/*spell-COMPOUNDRULES*
+spell-COMPOUNDSYLLABLE	spell.txt	/*spell-COMPOUNDSYLLABLE*
+spell-COMPOUNDSYLMAX	spell.txt	/*spell-COMPOUNDSYLMAX*
+spell-COMPOUNDWORDMAX	spell.txt	/*spell-COMPOUNDWORDMAX*
+spell-COPYRIGHT	spell.txt	/*spell-COPYRIGHT*
+spell-EMAIL	spell.txt	/*spell-EMAIL*
+spell-FLAG	spell.txt	/*spell-FLAG*
+spell-FOL	spell.txt	/*spell-FOL*
+spell-FORBIDDENWORD	spell.txt	/*spell-FORBIDDENWORD*
+spell-HOME	spell.txt	/*spell-HOME*
+spell-IGNOREEXTRA	spell.txt	/*spell-IGNOREEXTRA*
+spell-KEEPCASE	spell.txt	/*spell-KEEPCASE*
+spell-KEY	spell.txt	/*spell-KEY*
+spell-LANG	spell.txt	/*spell-LANG*
+spell-LEMMA_PRESENT	spell.txt	/*spell-LEMMA_PRESENT*
+spell-LOW	spell.txt	/*spell-LOW*
+spell-MAP	spell.txt	/*spell-MAP*
+spell-MAXNGRAMSUGS	spell.txt	/*spell-MAXNGRAMSUGS*
+spell-NAME	spell.txt	/*spell-NAME*
+spell-NEEDAFFIX	spell.txt	/*spell-NEEDAFFIX*
+spell-NEEDCOMPOUND	spell.txt	/*spell-NEEDCOMPOUND*
+spell-NOBREAK	spell.txt	/*spell-NOBREAK*
+spell-NOCOMPOUNDSUGS	spell.txt	/*spell-NOCOMPOUNDSUGS*
+spell-NOSPLITSUGS	spell.txt	/*spell-NOSPLITSUGS*
+spell-NOSUGFILE	spell.txt	/*spell-NOSUGFILE*
+spell-NOSUGGEST	spell.txt	/*spell-NOSUGGEST*
+spell-ONLYINCOMPOUND	spell.txt	/*spell-ONLYINCOMPOUND*
+spell-PFX	spell.txt	/*spell-PFX*
+spell-PFXPOSTPONE	spell.txt	/*spell-PFXPOSTPONE*
+spell-PSEUDOROOT	spell.txt	/*spell-PSEUDOROOT*
+spell-RARE	spell.txt	/*spell-RARE*
+spell-REP	spell.txt	/*spell-REP*
+spell-SAL	spell.txt	/*spell-SAL*
+spell-SET	spell.txt	/*spell-SET*
+spell-SFX	spell.txt	/*spell-SFX*
+spell-SLASH	spell.txt	/*spell-SLASH*
+spell-SOFOFROM	spell.txt	/*spell-SOFOFROM*
+spell-SOFOTO	spell.txt	/*spell-SOFOTO*
+spell-SUGSWITHDOTS	spell.txt	/*spell-SUGSWITHDOTS*
+spell-SYLLABLE	spell.txt	/*spell-SYLLABLE*
+spell-SYLLABLENUM	spell.txt	/*spell-SYLLABLENUM*
+spell-SpellFileMissing	spell.txt	/*spell-SpellFileMissing*
+spell-TRY	spell.txt	/*spell-TRY*
+spell-UPP	spell.txt	/*spell-UPP*
+spell-VERSION	spell.txt	/*spell-VERSION*
+spell-WORDCHARS	spell.txt	/*spell-WORDCHARS*
+spell-aff-format	spell.txt	/*spell-aff-format*
+spell-affix-chars	spell.txt	/*spell-affix-chars*
+spell-affix-comment	spell.txt	/*spell-affix-comment*
+spell-affix-flags	spell.txt	/*spell-affix-flags*
+spell-affix-mbyte	spell.txt	/*spell-affix-mbyte*
+spell-affix-not-supported	spell.txt	/*spell-affix-not-supported*
+spell-affix-vim	spell.txt	/*spell-affix-vim*
+spell-cjk	spell.txt	/*spell-cjk*
+spell-compound	spell.txt	/*spell-compound*
+spell-dic-format	spell.txt	/*spell-dic-format*
+spell-double-scoring	spell.txt	/*spell-double-scoring*
+spell-file-format	spell.txt	/*spell-file-format*
+spell-functions	usr_41.txt	/*spell-functions*
+spell-german	spell.txt	/*spell-german*
+spell-load	spell.txt	/*spell-load*
+spell-midword	spell.txt	/*spell-midword*
+spell-mkspell	spell.txt	/*spell-mkspell*
+spell-quickstart	spell.txt	/*spell-quickstart*
+spell-remarks	spell.txt	/*spell-remarks*
+spell-russian	spell.txt	/*spell-russian*
+spell-sug-file	spell.txt	/*spell-sug-file*
+spell-syntax	spell.txt	/*spell-syntax*
+spell-wordlist-format	spell.txt	/*spell-wordlist-format*
+spell-yiddish	spell.txt	/*spell-yiddish*
+spell.txt	spell.txt	/*spell.txt*
+spellbadword()	eval.txt	/*spellbadword()*
+spellfile-cleanup	spell.txt	/*spellfile-cleanup*
+spellfile.vim	spell.txt	/*spellfile.vim*
+spellsuggest()	eval.txt	/*spellsuggest()*
+split()	eval.txt	/*split()*
+splitfind	windows.txt	/*splitfind*
+splitview	windows.txt	/*splitview*
+sponsor	sponsor.txt	/*sponsor*
+sponsor-faq	sponsor.txt	/*sponsor-faq*
+sponsor.txt	sponsor.txt	/*sponsor.txt*
+spoon	os_unix.txt	/*spoon*
+spup.vim	syntax.txt	/*spup.vim*
+sql-adding-dialects	ft_sql.txt	/*sql-adding-dialects*
+sql-completion	ft_sql.txt	/*sql-completion*
+sql-completion-columns	ft_sql.txt	/*sql-completion-columns*
+sql-completion-customization	ft_sql.txt	/*sql-completion-customization*
+sql-completion-dynamic	ft_sql.txt	/*sql-completion-dynamic*
+sql-completion-filetypes	ft_sql.txt	/*sql-completion-filetypes*
+sql-completion-maps	ft_sql.txt	/*sql-completion-maps*
+sql-completion-procedures	ft_sql.txt	/*sql-completion-procedures*
+sql-completion-static	ft_sql.txt	/*sql-completion-static*
+sql-completion-tables	ft_sql.txt	/*sql-completion-tables*
+sql-completion-tutorial	ft_sql.txt	/*sql-completion-tutorial*
+sql-completion-views	ft_sql.txt	/*sql-completion-views*
+sql-dialects	ft_sql.txt	/*sql-dialects*
+sql-macros	ft_sql.txt	/*sql-macros*
+sql-matchit	ft_sql.txt	/*sql-matchit*
+sql-navigation	ft_sql.txt	/*sql-navigation*
+sql-object-motions	ft_sql.txt	/*sql-object-motions*
+sql-predefined-objects	ft_sql.txt	/*sql-predefined-objects*
+sql-type-default	ft_sql.txt	/*sql-type-default*
+sql-types	ft_sql.txt	/*sql-types*
+sql.vim	syntax.txt	/*sql.vim*
+sqlanywhere	ft_sql.txt	/*sqlanywhere*
+sqlanywhere.vim	syntax.txt	/*sqlanywhere.vim*
+sqlgettype	ft_sql.txt	/*sqlgettype*
+sqlinformix.vim	syntax.txt	/*sqlinformix.vim*
+sqlj	ft_sql.txt	/*sqlj*
+sqlserver	ft_sql.txt	/*sqlserver*
+sqlsettype	ft_sql.txt	/*sqlsettype*
+sqrt()	eval.txt	/*sqrt()*
+sscanf	eval.txt	/*sscanf*
+standard-plugin	usr_05.txt	/*standard-plugin*
+standard-plugin-list	help.txt	/*standard-plugin-list*
+standout	syntax.txt	/*standout*
+star	pattern.txt	/*star*
+starstar	editing.txt	/*starstar*
+starstar-wildcard	editing.txt	/*starstar-wildcard*
+start-of-file	pattern.txt	/*start-of-file*
+start-vimdiff	diff.txt	/*start-vimdiff*
+starting	starting.txt	/*starting*
+starting-amiga	starting.txt	/*starting-amiga*
+starting.txt	starting.txt	/*starting.txt*
+startup	starting.txt	/*startup*
+startup-options	starting.txt	/*startup-options*
+startup-terminal	term.txt	/*startup-terminal*
+static-tag	tagsrch.txt	/*static-tag*
+status-line	windows.txt	/*status-line*
+statusmsg-variable	eval.txt	/*statusmsg-variable*
+str2float()	eval.txt	/*str2float()*
+str2nr()	eval.txt	/*str2nr()*
+strcasestr()	eval.txt	/*strcasestr()*
+strcharpart()	eval.txt	/*strcharpart()*
+strchars()	eval.txt	/*strchars()*
+strchr()	eval.txt	/*strchr()*
+strcspn()	eval.txt	/*strcspn()*
+strdisplaywidth()	eval.txt	/*strdisplaywidth()*
+strftime()	eval.txt	/*strftime()*
+strgetchar()	eval.txt	/*strgetchar()*
+stridx()	eval.txt	/*stridx()*
+strikethrough	syntax.txt	/*strikethrough*
+string	eval.txt	/*string*
+string()	eval.txt	/*string()*
+string-functions	usr_41.txt	/*string-functions*
+string-match	eval.txt	/*string-match*
+strlen()	eval.txt	/*strlen()*
+strpart()	eval.txt	/*strpart()*
+strpbrk()	eval.txt	/*strpbrk()*
+strrchr()	eval.txt	/*strrchr()*
+strridx()	eval.txt	/*strridx()*
+strspn()	eval.txt	/*strspn()*
+strstr()	eval.txt	/*strstr()*
+strtrans()	eval.txt	/*strtrans()*
+strwidth()	eval.txt	/*strwidth()*
+style-changes	develop.txt	/*style-changes*
+style-compiler	develop.txt	/*style-compiler*
+style-examples	develop.txt	/*style-examples*
+style-functions	develop.txt	/*style-functions*
+style-names	develop.txt	/*style-names*
+style-spaces	develop.txt	/*style-spaces*
+style-various	develop.txt	/*style-various*
+sub-menu-priority	gui.txt	/*sub-menu-priority*
+sub-replace-\=	change.txt	/*sub-replace-\\=*
+sub-replace-expression	change.txt	/*sub-replace-expression*
+sub-replace-special	change.txt	/*sub-replace-special*
+sublist	eval.txt	/*sublist*
+submatch()	eval.txt	/*submatch()*
+subscribe-maillist	intro.txt	/*subscribe-maillist*
+subscript	eval.txt	/*subscript*
+substitute()	eval.txt	/*substitute()*
+substitute-CR	version6.txt	/*substitute-CR*
+suffixes	cmdline.txt	/*suffixes*
+suspend	starting.txt	/*suspend*
+swap-exists-choices	usr_11.txt	/*swap-exists-choices*
+swap-file	recover.txt	/*swap-file*
+swapchoice-variable	eval.txt	/*swapchoice-variable*
+swapcommand-variable	eval.txt	/*swapcommand-variable*
+swapfile-changed	version4.txt	/*swapfile-changed*
+swapinfo()	eval.txt	/*swapinfo()*
+swapname-variable	eval.txt	/*swapname-variable*
+sybase	ft_sql.txt	/*sybase*
+syn-sync-grouphere	syntax.txt	/*syn-sync-grouphere*
+syn-sync-groupthere	syntax.txt	/*syn-sync-groupthere*
+syn-sync-linecont	syntax.txt	/*syn-sync-linecont*
+synID()	eval.txt	/*synID()*
+synIDattr()	eval.txt	/*synIDattr()*
+synIDtrans()	eval.txt	/*synIDtrans()*
+syncbind	scroll.txt	/*syncbind*
+syncolor	syntax.txt	/*syncolor*
+synconcealed()	eval.txt	/*synconcealed()*
+synload-1	syntax.txt	/*synload-1*
+synload-2	syntax.txt	/*synload-2*
+synload-3	syntax.txt	/*synload-3*
+synload-4	syntax.txt	/*synload-4*
+synload-5	syntax.txt	/*synload-5*
+synload-6	syntax.txt	/*synload-6*
+synstack()	eval.txt	/*synstack()*
+syntax	syntax.txt	/*syntax*
+syntax-functions	usr_41.txt	/*syntax-functions*
+syntax-highlighting	syntax.txt	/*syntax-highlighting*
+syntax-loading	syntax.txt	/*syntax-loading*
+syntax-printing	usr_06.txt	/*syntax-printing*
+syntax.txt	syntax.txt	/*syntax.txt*
+syntax_cmd	syntax.txt	/*syntax_cmd*
+sys-file-list	help.txt	/*sys-file-list*
+sysmouse	term.txt	/*sysmouse*
+system()	eval.txt	/*system()*
+system-functions	usr_41.txt	/*system-functions*
+system-vimrc	starting.txt	/*system-vimrc*
+systemlist()	eval.txt	/*systemlist()*
+s~	change.txt	/*s~*
+t	motion.txt	/*t*
+t:	eval.txt	/*t:*
+t:var	eval.txt	/*t:var*
+t_#2	term.txt	/*t_#2*
+t_#4	term.txt	/*t_#4*
+t_%1	term.txt	/*t_%1*
+t_%i	term.txt	/*t_%i*
+t_&8	term.txt	/*t_&8*
+t_8b	term.txt	/*t_8b*
+t_8f	term.txt	/*t_8f*
+t_@7	term.txt	/*t_@7*
+t_AB	term.txt	/*t_AB*
+t_AF	term.txt	/*t_AF*
+t_AL	term.txt	/*t_AL*
+t_BD	term.txt	/*t_BD*
+t_BE	term.txt	/*t_BE*
+t_CS	term.txt	/*t_CS*
+t_CTRL-W_CTRL-C	terminal.txt	/*t_CTRL-W_CTRL-C*
+t_CTRL-\_CTRL-N	terminal.txt	/*t_CTRL-\\_CTRL-N*
+t_CV	term.txt	/*t_CV*
+t_Ce	term.txt	/*t_Ce*
+t_Co	term.txt	/*t_Co*
+t_Cs	term.txt	/*t_Cs*
+t_DL	term.txt	/*t_DL*
+t_EC	term.txt	/*t_EC*
+t_EI	term.txt	/*t_EI*
+t_F1	term.txt	/*t_F1*
+t_F2	term.txt	/*t_F2*
+t_F3	term.txt	/*t_F3*
+t_F4	term.txt	/*t_F4*
+t_F5	term.txt	/*t_F5*
+t_F6	term.txt	/*t_F6*
+t_F7	term.txt	/*t_F7*
+t_F8	term.txt	/*t_F8*
+t_F9	term.txt	/*t_F9*
+t_GP	term.txt	/*t_GP*
+t_IE	term.txt	/*t_IE*
+t_IS	term.txt	/*t_IS*
+t_K1	term.txt	/*t_K1*
+t_K3	term.txt	/*t_K3*
+t_K4	term.txt	/*t_K4*
+t_K5	term.txt	/*t_K5*
+t_K6	term.txt	/*t_K6*
+t_K7	term.txt	/*t_K7*
+t_K8	term.txt	/*t_K8*
+t_K9	term.txt	/*t_K9*
+t_KA	term.txt	/*t_KA*
+t_KB	term.txt	/*t_KB*
+t_KC	term.txt	/*t_KC*
+t_KD	term.txt	/*t_KD*
+t_KE	term.txt	/*t_KE*
+t_KF	term.txt	/*t_KF*
+t_KG	term.txt	/*t_KG*
+t_KH	term.txt	/*t_KH*
+t_KI	term.txt	/*t_KI*
+t_KJ	term.txt	/*t_KJ*
+t_KK	term.txt	/*t_KK*
+t_KL	term.txt	/*t_KL*
+t_PE	term.txt	/*t_PE*
+t_PS	term.txt	/*t_PS*
+t_RB	term.txt	/*t_RB*
+t_RC	term.txt	/*t_RC*
+t_RF	term.txt	/*t_RF*
+t_RI	term.txt	/*t_RI*
+t_RS	term.txt	/*t_RS*
+t_RT	term.txt	/*t_RT*
+t_RV	term.txt	/*t_RV*
+t_Ri	term.txt	/*t_Ri*
+t_SC	term.txt	/*t_SC*
+t_SH	term.txt	/*t_SH*
+t_SI	term.txt	/*t_SI*
+t_SR	term.txt	/*t_SR*
+t_ST	term.txt	/*t_ST*
+t_Sb	term.txt	/*t_Sb*
+t_Sf	term.txt	/*t_Sf*
+t_Si	term.txt	/*t_Si*
+t_Te	term.txt	/*t_Te*
+t_Ts	term.txt	/*t_Ts*
+t_VS	term.txt	/*t_VS*
+t_WP	term.txt	/*t_WP*
+t_WS	term.txt	/*t_WS*
+t_ZH	term.txt	/*t_ZH*
+t_ZR	term.txt	/*t_ZR*
+t_al	term.txt	/*t_al*
+t_bc	term.txt	/*t_bc*
+t_bool-variable	eval.txt	/*t_bool-variable*
+t_cd	term.txt	/*t_cd*
+t_cdl	version4.txt	/*t_cdl*
+t_ce	term.txt	/*t_ce*
+t_channel-variable	eval.txt	/*t_channel-variable*
+t_ci	version4.txt	/*t_ci*
+t_cil	version4.txt	/*t_cil*
+t_cl	term.txt	/*t_cl*
+t_cm	term.txt	/*t_cm*
+t_cri	version4.txt	/*t_cri*
+t_cs	term.txt	/*t_cs*
+t_csc	version4.txt	/*t_csc*
+t_cv	version4.txt	/*t_cv*
+t_cvv	version4.txt	/*t_cvv*
+t_da	term.txt	/*t_da*
+t_db	term.txt	/*t_db*
+t_dict-variable	eval.txt	/*t_dict-variable*
+t_dl	term.txt	/*t_dl*
+t_ed	version4.txt	/*t_ed*
+t_el	version4.txt	/*t_el*
+t_f1	version4.txt	/*t_f1*
+t_f10	version4.txt	/*t_f10*
+t_f2	version4.txt	/*t_f2*
+t_f3	version4.txt	/*t_f3*
+t_f4	version4.txt	/*t_f4*
+t_f5	version4.txt	/*t_f5*
+t_f6	version4.txt	/*t_f6*
+t_f7	version4.txt	/*t_f7*
+t_f8	version4.txt	/*t_f8*
+t_f9	version4.txt	/*t_f9*
+t_float-variable	eval.txt	/*t_float-variable*
+t_fs	term.txt	/*t_fs*
+t_func-variable	eval.txt	/*t_func-variable*
+t_help	version4.txt	/*t_help*
+t_il	version4.txt	/*t_il*
+t_job-variable	eval.txt	/*t_job-variable*
+t_k1	term.txt	/*t_k1*
+t_k2	term.txt	/*t_k2*
+t_k3	term.txt	/*t_k3*
+t_k4	term.txt	/*t_k4*
+t_k5	term.txt	/*t_k5*
+t_k6	term.txt	/*t_k6*
+t_k7	term.txt	/*t_k7*
+t_k8	term.txt	/*t_k8*
+t_k9	term.txt	/*t_k9*
+t_k;	term.txt	/*t_k;*
+t_kB	term.txt	/*t_kB*
+t_kD	term.txt	/*t_kD*
+t_kI	term.txt	/*t_kI*
+t_kN	term.txt	/*t_kN*
+t_kP	term.txt	/*t_kP*
+t_kb	term.txt	/*t_kb*
+t_kd	term.txt	/*t_kd*
+t_ke	term.txt	/*t_ke*
+t_kh	term.txt	/*t_kh*
+t_kl	term.txt	/*t_kl*
+t_kr	term.txt	/*t_kr*
+t_ks	term.txt	/*t_ks*
+t_ku	term.txt	/*t_ku*
+t_le	term.txt	/*t_le*
+t_list-variable	eval.txt	/*t_list-variable*
+t_mb	term.txt	/*t_mb*
+t_md	term.txt	/*t_md*
+t_me	term.txt	/*t_me*
+t_mr	term.txt	/*t_mr*
+t_ms	term.txt	/*t_ms*
+t_nd	term.txt	/*t_nd*
+t_none-variable	eval.txt	/*t_none-variable*
+t_number-variable	eval.txt	/*t_number-variable*
+t_op	term.txt	/*t_op*
+t_se	term.txt	/*t_se*
+t_sf1	version4.txt	/*t_sf1*
+t_sf10	version4.txt	/*t_sf10*
+t_sf2	version4.txt	/*t_sf2*
+t_sf3	version4.txt	/*t_sf3*
+t_sf4	version4.txt	/*t_sf4*
+t_sf5	version4.txt	/*t_sf5*
+t_sf6	version4.txt	/*t_sf6*
+t_sf7	version4.txt	/*t_sf7*
+t_sf8	version4.txt	/*t_sf8*
+t_sf9	version4.txt	/*t_sf9*
+t_skd	version4.txt	/*t_skd*
+t_skl	version4.txt	/*t_skl*
+t_skr	version4.txt	/*t_skr*
+t_sku	version4.txt	/*t_sku*
+t_so	term.txt	/*t_so*
+t_sr	term.txt	/*t_sr*
+t_star7	term.txt	/*t_star7*
+t_string-variable	eval.txt	/*t_string-variable*
+t_tb	version4.txt	/*t_tb*
+t_te	term.txt	/*t_te*
+t_ti	term.txt	/*t_ti*
+t_tp	version4.txt	/*t_tp*
+t_ts	term.txt	/*t_ts*
+t_ts_old	version4.txt	/*t_ts_old*
+t_u7	term.txt	/*t_u7*
+t_ue	term.txt	/*t_ue*
+t_undo	version4.txt	/*t_undo*
+t_us	term.txt	/*t_us*
+t_ut	term.txt	/*t_ut*
+t_vb	term.txt	/*t_vb*
+t_ve	term.txt	/*t_ve*
+t_vi	term.txt	/*t_vi*
+t_vs	term.txt	/*t_vs*
+t_xn	term.txt	/*t_xn*
+t_xs	term.txt	/*t_xs*
+tab	intro.txt	/*tab*
+tab-page	tabpage.txt	/*tab-page*
+tab-page-commands	tabpage.txt	/*tab-page-commands*
+tab-page-intro	tabpage.txt	/*tab-page-intro*
+tab-page-other	tabpage.txt	/*tab-page-other*
+tabline-menu	tabpage.txt	/*tabline-menu*
+tabnew-autocmd	tabpage.txt	/*tabnew-autocmd*
+tabpage	tabpage.txt	/*tabpage*
+tabpage-variable	eval.txt	/*tabpage-variable*
+tabpage.txt	tabpage.txt	/*tabpage.txt*
+tabpagebuflist()	eval.txt	/*tabpagebuflist()*
+tabpagenr()	eval.txt	/*tabpagenr()*
+tabpagewinnr()	eval.txt	/*tabpagewinnr()*
+tag	tagsrch.txt	/*tag*
+tag-!	tagsrch.txt	/*tag-!*
+tag-any-white	tagsrch.txt	/*tag-any-white*
+tag-binary-search	tagsrch.txt	/*tag-binary-search*
+tag-blocks	motion.txt	/*tag-blocks*
+tag-commands	tagsrch.txt	/*tag-commands*
+tag-details	tagsrch.txt	/*tag-details*
+tag-highlight	syntax.txt	/*tag-highlight*
+tag-matchlist	tagsrch.txt	/*tag-matchlist*
+tag-old-static	tagsrch.txt	/*tag-old-static*
+tag-overloaded	version5.txt	/*tag-overloaded*
+tag-preview	tagsrch.txt	/*tag-preview*
+tag-priority	tagsrch.txt	/*tag-priority*
+tag-regexp	tagsrch.txt	/*tag-regexp*
+tag-search	tagsrch.txt	/*tag-search*
+tag-security	tagsrch.txt	/*tag-security*
+tag-skip-file	tagsrch.txt	/*tag-skip-file*
+tag-stack	tagsrch.txt	/*tag-stack*
+tagfiles()	eval.txt	/*tagfiles()*
+taglist()	eval.txt	/*taglist()*
+tags	tagsrch.txt	/*tags*
+tags-and-searches	tagsrch.txt	/*tags-and-searches*
+tags-file-changed	version5.txt	/*tags-file-changed*
+tags-file-format	tagsrch.txt	/*tags-file-format*
+tags-option	tagsrch.txt	/*tags-option*
+tagsrch.txt	tagsrch.txt	/*tagsrch.txt*
+tagstack	tagsrch.txt	/*tagstack*
+tan()	eval.txt	/*tan()*
+tanh()	eval.txt	/*tanh()*
+tar	pi_tar.txt	/*tar*
+tar-contents	pi_tar.txt	/*tar-contents*
+tar-copyright	pi_tar.txt	/*tar-copyright*
+tar-history	pi_tar.txt	/*tar-history*
+tar-manual	pi_tar.txt	/*tar-manual*
+tar-options	pi_tar.txt	/*tar-options*
+tar-usage	pi_tar.txt	/*tar-usage*
+tcl	if_tcl.txt	/*tcl*
+tcl-beep	if_tcl.txt	/*tcl-beep*
+tcl-buffer	if_tcl.txt	/*tcl-buffer*
+tcl-buffer-append	if_tcl.txt	/*tcl-buffer-append*
+tcl-buffer-cmds	if_tcl.txt	/*tcl-buffer-cmds*
+tcl-buffer-command	if_tcl.txt	/*tcl-buffer-command*
+tcl-buffer-count	if_tcl.txt	/*tcl-buffer-count*
+tcl-buffer-delcmd	if_tcl.txt	/*tcl-buffer-delcmd*
+tcl-buffer-delete	if_tcl.txt	/*tcl-buffer-delete*
+tcl-buffer-expr	if_tcl.txt	/*tcl-buffer-expr*
+tcl-buffer-get	if_tcl.txt	/*tcl-buffer-get*
+tcl-buffer-insert	if_tcl.txt	/*tcl-buffer-insert*
+tcl-buffer-last	if_tcl.txt	/*tcl-buffer-last*
+tcl-buffer-mark	if_tcl.txt	/*tcl-buffer-mark*
+tcl-buffer-option	if_tcl.txt	/*tcl-buffer-option*
+tcl-buffer-set	if_tcl.txt	/*tcl-buffer-set*
+tcl-buffer-windows	if_tcl.txt	/*tcl-buffer-windows*
+tcl-bugs	if_tcl.txt	/*tcl-bugs*
+tcl-command	if_tcl.txt	/*tcl-command*
+tcl-commands	if_tcl.txt	/*tcl-commands*
+tcl-dynamic	if_tcl.txt	/*tcl-dynamic*
+tcl-ex-commands	if_tcl.txt	/*tcl-ex-commands*
+tcl-examples	if_tcl.txt	/*tcl-examples*
+tcl-expr	if_tcl.txt	/*tcl-expr*
+tcl-linenumbers	if_tcl.txt	/*tcl-linenumbers*
+tcl-misc	if_tcl.txt	/*tcl-misc*
+tcl-option	if_tcl.txt	/*tcl-option*
+tcl-output	if_tcl.txt	/*tcl-output*
+tcl-var-current	if_tcl.txt	/*tcl-var-current*
+tcl-var-lbase	if_tcl.txt	/*tcl-var-lbase*
+tcl-var-line	if_tcl.txt	/*tcl-var-line*
+tcl-var-lnum	if_tcl.txt	/*tcl-var-lnum*
+tcl-var-range	if_tcl.txt	/*tcl-var-range*
+tcl-variables	if_tcl.txt	/*tcl-variables*
+tcl-window	if_tcl.txt	/*tcl-window*
+tcl-window-buffer	if_tcl.txt	/*tcl-window-buffer*
+tcl-window-cmds	if_tcl.txt	/*tcl-window-cmds*
+tcl-window-command	if_tcl.txt	/*tcl-window-command*
+tcl-window-cursor	if_tcl.txt	/*tcl-window-cursor*
+tcl-window-delcmd	if_tcl.txt	/*tcl-window-delcmd*
+tcl-window-expr	if_tcl.txt	/*tcl-window-expr*
+tcl-window-height	if_tcl.txt	/*tcl-window-height*
+tcl-window-option	if_tcl.txt	/*tcl-window-option*
+tcsh-style	cmdline.txt	/*tcsh-style*
+tcsh.vim	syntax.txt	/*tcsh.vim*
+tear-off-menus	gui.txt	/*tear-off-menus*
+telnet-CTRL-]	tagsrch.txt	/*telnet-CTRL-]*
+temp-file-name	eval.txt	/*temp-file-name*
+tempfile	change.txt	/*tempfile*
+template	autocmd.txt	/*template*
+tempname()	eval.txt	/*tempname()*
+term++close	terminal.txt	/*term++close*
+term++open	terminal.txt	/*term++open*
+term-dependent-settings	term.txt	/*term-dependent-settings*
+term-list	syntax.txt	/*term-list*
+term.txt	term.txt	/*term.txt*
+term_dumpdiff()	eval.txt	/*term_dumpdiff()*
+term_dumpload()	eval.txt	/*term_dumpload()*
+term_dumpwrite()	eval.txt	/*term_dumpwrite()*
+term_getaltscreen()	eval.txt	/*term_getaltscreen()*
+term_getansicolors()	eval.txt	/*term_getansicolors()*
+term_getattr()	eval.txt	/*term_getattr()*
+term_getcursor()	eval.txt	/*term_getcursor()*
+term_getjob()	eval.txt	/*term_getjob()*
+term_getline()	eval.txt	/*term_getline()*
+term_getscrolled()	eval.txt	/*term_getscrolled()*
+term_getsize()	eval.txt	/*term_getsize()*
+term_getstatus()	eval.txt	/*term_getstatus()*
+term_gettitle()	eval.txt	/*term_gettitle()*
+term_gettty()	eval.txt	/*term_gettty()*
+term_list()	eval.txt	/*term_list()*
+term_scrape()	eval.txt	/*term_scrape()*
+term_sendkeys()	eval.txt	/*term_sendkeys()*
+term_setansicolors()	eval.txt	/*term_setansicolors()*
+term_setkill()	eval.txt	/*term_setkill()*
+term_setrestore()	eval.txt	/*term_setrestore()*
+term_setsize()	eval.txt	/*term_setsize()*
+term_start()	eval.txt	/*term_start()*
+term_wait()	eval.txt	/*term_wait()*
+termcap	term.txt	/*termcap*
+termcap-changed	version4.txt	/*termcap-changed*
+termcap-colors	term.txt	/*termcap-colors*
+termcap-cursor-color	term.txt	/*termcap-cursor-color*
+termcap-cursor-shape	term.txt	/*termcap-cursor-shape*
+termcap-options	term.txt	/*termcap-options*
+termcap-title	term.txt	/*termcap-title*
+termdebug-commands	terminal.txt	/*termdebug-commands*
+termdebug-communication	terminal.txt	/*termdebug-communication*
+termdebug-customizing	terminal.txt	/*termdebug-customizing*
+termdebug-example	terminal.txt	/*termdebug-example*
+termdebug-prompt	terminal.txt	/*termdebug-prompt*
+termdebug-starting	terminal.txt	/*termdebug-starting*
+termdebug-stepping	terminal.txt	/*termdebug-stepping*
+termdebug-variables	terminal.txt	/*termdebug-variables*
+termdebug_popup	terminal.txt	/*termdebug_popup*
+termdebug_shortcuts	terminal.txt	/*termdebug_shortcuts*
+termdebug_use_prompt	terminal.txt	/*termdebug_use_prompt*
+termdebug_wide	terminal.txt	/*termdebug_wide*
+terminal	terminal.txt	/*terminal*
+terminal-api	terminal.txt	/*terminal-api*
+terminal-client-server	terminal.txt	/*terminal-client-server*
+terminal-colors	os_unix.txt	/*terminal-colors*
+terminal-communication	terminal.txt	/*terminal-communication*
+terminal-cursor-style	terminal.txt	/*terminal-cursor-style*
+terminal-debug	terminal.txt	/*terminal-debug*
+terminal-debugger	terminal.txt	/*terminal-debugger*
+terminal-diff	terminal.txt	/*terminal-diff*
+terminal-diffscreendump	terminal.txt	/*terminal-diffscreendump*
+terminal-dumptest	terminal.txt	/*terminal-dumptest*
+terminal-functions	usr_41.txt	/*terminal-functions*
+terminal-info	term.txt	/*terminal-info*
+terminal-key-codes	term.txt	/*terminal-key-codes*
+terminal-ms-windows	terminal.txt	/*terminal-ms-windows*
+terminal-options	term.txt	/*terminal-options*
+terminal-output-codes	term.txt	/*terminal-output-codes*
+terminal-resizing	terminal.txt	/*terminal-resizing*
+terminal-screendump	terminal.txt	/*terminal-screendump*
+terminal-session	terminal.txt	/*terminal-session*
+terminal-size-color	terminal.txt	/*terminal-size-color*
+terminal-special-keys	terminal.txt	/*terminal-special-keys*
+terminal-testing	terminal.txt	/*terminal-testing*
+terminal-to-job	terminal.txt	/*terminal-to-job*
+terminal-typing	terminal.txt	/*terminal-typing*
+terminal-unix	terminal.txt	/*terminal-unix*
+terminal-use	terminal.txt	/*terminal-use*
+terminal-window	terminal.txt	/*terminal-window*
+terminal.txt	terminal.txt	/*terminal.txt*
+terminfo	term.txt	/*terminfo*
+termresponse-variable	eval.txt	/*termresponse-variable*
+test-functions	usr_41.txt	/*test-functions*
+test_alloc_fail()	eval.txt	/*test_alloc_fail()*
+test_autochdir()	eval.txt	/*test_autochdir()*
+test_feedinput()	eval.txt	/*test_feedinput()*
+test_garbagecollect_now()	eval.txt	/*test_garbagecollect_now()*
+test_ignore_error()	eval.txt	/*test_ignore_error()*
+test_null_channel()	eval.txt	/*test_null_channel()*
+test_null_dict()	eval.txt	/*test_null_dict()*
+test_null_job()	eval.txt	/*test_null_job()*
+test_null_list()	eval.txt	/*test_null_list()*
+test_null_partial()	eval.txt	/*test_null_partial()*
+test_null_string()	eval.txt	/*test_null_string()*
+test_override()	eval.txt	/*test_override()*
+test_settime()	eval.txt	/*test_settime()*
+testing	eval.txt	/*testing*
+testing-variable	eval.txt	/*testing-variable*
+tex-cchar	syntax.txt	/*tex-cchar*
+tex-cole	syntax.txt	/*tex-cole*
+tex-conceal	syntax.txt	/*tex-conceal*
+tex-error	syntax.txt	/*tex-error*
+tex-folding	syntax.txt	/*tex-folding*
+tex-math	syntax.txt	/*tex-math*
+tex-morecommands	syntax.txt	/*tex-morecommands*
+tex-nospell	syntax.txt	/*tex-nospell*
+tex-package	syntax.txt	/*tex-package*
+tex-runon	syntax.txt	/*tex-runon*
+tex-slow	syntax.txt	/*tex-slow*
+tex-stopzone	syntax.txt	/*tex-stopzone*
+tex-style	syntax.txt	/*tex-style*
+tex-supersub	syntax.txt	/*tex-supersub*
+tex-sync	syntax.txt	/*tex-sync*
+tex-verb	syntax.txt	/*tex-verb*
+tex.vim	syntax.txt	/*tex.vim*
+text-functions	usr_41.txt	/*text-functions*
+text-objects	motion.txt	/*text-objects*
+text-objects-changed	version5.txt	/*text-objects-changed*
+textlock	eval.txt	/*textlock*
+tf.vim	syntax.txt	/*tf.vim*
+this_session-variable	eval.txt	/*this_session-variable*
+throw-catch	eval.txt	/*throw-catch*
+throw-expression	eval.txt	/*throw-expression*
+throw-from-catch	eval.txt	/*throw-from-catch*
+throw-variables	eval.txt	/*throw-variables*
+throwpoint-variable	eval.txt	/*throwpoint-variable*
+time-functions	usr_41.txt	/*time-functions*
+timer	eval.txt	/*timer*
+timer-functions	usr_41.txt	/*timer-functions*
+timer_info()	eval.txt	/*timer_info()*
+timer_pause()	eval.txt	/*timer_pause()*
+timer_start()	eval.txt	/*timer_start()*
+timer_stop()	eval.txt	/*timer_stop()*
+timer_stopall()	eval.txt	/*timer_stopall()*
+timers	eval.txt	/*timers*
+timestamp	editing.txt	/*timestamp*
+timestamps	editing.txt	/*timestamps*
+tips	tips.txt	/*tips*
+tips.txt	tips.txt	/*tips.txt*
+todo	todo.txt	/*todo*
+todo.txt	todo.txt	/*todo.txt*
+toggle	options.txt	/*toggle*
+toggle-revins	version4.txt	/*toggle-revins*
+tolower()	eval.txt	/*tolower()*
+toolbar-icon	gui.txt	/*toolbar-icon*
+toupper()	eval.txt	/*toupper()*
+tr()	eval.txt	/*tr()*
+trim()	eval.txt	/*trim()*
+trojan-horse	starting.txt	/*trojan-horse*
+true-variable	eval.txt	/*true-variable*
+trunc()	eval.txt	/*trunc()*
+try-conditionals	eval.txt	/*try-conditionals*
+try-echoerr	eval.txt	/*try-echoerr*
+try-finally	eval.txt	/*try-finally*
+try-nested	eval.txt	/*try-nested*
+try-nesting	eval.txt	/*try-nesting*
+tutor	usr_01.txt	/*tutor*
+twice	if_cscop.txt	/*twice*
+two-engines	pattern.txt	/*two-engines*
+type()	eval.txt	/*type()*
+type-mistakes	tips.txt	/*type-mistakes*
+typecorr-settings	usr_41.txt	/*typecorr-settings*
+typecorr.txt	usr_41.txt	/*typecorr.txt*
+u	undo.txt	/*u*
+uganda	uganda.txt	/*uganda*
+uganda.txt	uganda.txt	/*uganda.txt*
+undercurl	syntax.txt	/*undercurl*
+underline	syntax.txt	/*underline*
+undo	undo.txt	/*undo*
+undo-blocks	undo.txt	/*undo-blocks*
+undo-branches	undo.txt	/*undo-branches*
+undo-commands	undo.txt	/*undo-commands*
+undo-persistence	undo.txt	/*undo-persistence*
+undo-redo	undo.txt	/*undo-redo*
+undo-remarks	undo.txt	/*undo-remarks*
+undo-tree	undo.txt	/*undo-tree*
+undo-two-ways	undo.txt	/*undo-two-ways*
+undo.txt	undo.txt	/*undo.txt*
+undo_ftplugin	usr_41.txt	/*undo_ftplugin*
+undo_indent	usr_41.txt	/*undo_indent*
+undofile()	eval.txt	/*undofile()*
+undotree()	eval.txt	/*undotree()*
+unicode	mbyte.txt	/*unicode*
+uniq()	eval.txt	/*uniq()*
+unix	os_unix.txt	/*unix*
+unlisted-buffer	windows.txt	/*unlisted-buffer*
+up-down-motions	motion.txt	/*up-down-motions*
+uppercase	change.txt	/*uppercase*
+urxvt-mouse	options.txt	/*urxvt-mouse*
+use-cpo-save	usr_41.txt	/*use-cpo-save*
+use-visual-cmds	version4.txt	/*use-visual-cmds*
+useful-mappings	tips.txt	/*useful-mappings*
+usenet	intro.txt	/*usenet*
+user-cmd-ambiguous	map.txt	/*user-cmd-ambiguous*
+user-commands	map.txt	/*user-commands*
+user-functions	eval.txt	/*user-functions*
+user-manual	usr_toc.txt	/*user-manual*
+using-<Plug>	usr_41.txt	/*using-<Plug>*
+using-menus	gui.txt	/*using-menus*
+using-scripts	repeat.txt	/*using-scripts*
+using-xxd	tips.txt	/*using-xxd*
+using_CTRL-V	map.txt	/*using_CTRL-V*
+usr_01.txt	usr_01.txt	/*usr_01.txt*
+usr_02.txt	usr_02.txt	/*usr_02.txt*
+usr_03.txt	usr_03.txt	/*usr_03.txt*
+usr_04.txt	usr_04.txt	/*usr_04.txt*
+usr_05.txt	usr_05.txt	/*usr_05.txt*
+usr_06.txt	usr_06.txt	/*usr_06.txt*
+usr_07.txt	usr_07.txt	/*usr_07.txt*
+usr_08.txt	usr_08.txt	/*usr_08.txt*
+usr_09.txt	usr_09.txt	/*usr_09.txt*
+usr_10.txt	usr_10.txt	/*usr_10.txt*
+usr_11.txt	usr_11.txt	/*usr_11.txt*
+usr_12.txt	usr_12.txt	/*usr_12.txt*
+usr_20.txt	usr_20.txt	/*usr_20.txt*
+usr_21.txt	usr_21.txt	/*usr_21.txt*
+usr_22.txt	usr_22.txt	/*usr_22.txt*
+usr_23.txt	usr_23.txt	/*usr_23.txt*
+usr_24.txt	usr_24.txt	/*usr_24.txt*
+usr_25.txt	usr_25.txt	/*usr_25.txt*
+usr_26.txt	usr_26.txt	/*usr_26.txt*
+usr_27.txt	usr_27.txt	/*usr_27.txt*
+usr_28.txt	usr_28.txt	/*usr_28.txt*
+usr_29.txt	usr_29.txt	/*usr_29.txt*
+usr_30.txt	usr_30.txt	/*usr_30.txt*
+usr_31.txt	usr_31.txt	/*usr_31.txt*
+usr_32.txt	usr_32.txt	/*usr_32.txt*
+usr_40.txt	usr_40.txt	/*usr_40.txt*
+usr_41.txt	usr_41.txt	/*usr_41.txt*
+usr_42.txt	usr_42.txt	/*usr_42.txt*
+usr_43.txt	usr_43.txt	/*usr_43.txt*
+usr_44.txt	usr_44.txt	/*usr_44.txt*
+usr_45.txt	usr_45.txt	/*usr_45.txt*
+usr_90.txt	usr_90.txt	/*usr_90.txt*
+usr_toc.txt	usr_toc.txt	/*usr_toc.txt*
+utf-8	mbyte.txt	/*utf-8*
+utf-8-char-arg	mbyte.txt	/*utf-8-char-arg*
+utf-8-in-xwindows	mbyte.txt	/*utf-8-in-xwindows*
+utf-8-typing	mbyte.txt	/*utf-8-typing*
+utf8	mbyte.txt	/*utf8*
+v	visual.txt	/*v*
+v:	eval.txt	/*v:*
+v:beval_bufnr	eval.txt	/*v:beval_bufnr*
+v:beval_col	eval.txt	/*v:beval_col*
+v:beval_lnum	eval.txt	/*v:beval_lnum*
+v:beval_text	eval.txt	/*v:beval_text*
+v:beval_winid	eval.txt	/*v:beval_winid*
+v:beval_winnr	eval.txt	/*v:beval_winnr*
+v:char	eval.txt	/*v:char*
+v:charconvert_from	eval.txt	/*v:charconvert_from*
+v:charconvert_to	eval.txt	/*v:charconvert_to*
+v:cmdarg	eval.txt	/*v:cmdarg*
+v:cmdbang	eval.txt	/*v:cmdbang*
+v:completed_item	eval.txt	/*v:completed_item*
+v:count	eval.txt	/*v:count*
+v:count1	eval.txt	/*v:count1*
+v:ctype	eval.txt	/*v:ctype*
+v:dying	eval.txt	/*v:dying*
+v:errmsg	eval.txt	/*v:errmsg*
+v:errors	eval.txt	/*v:errors*
+v:event	eval.txt	/*v:event*
+v:exception	eval.txt	/*v:exception*
+v:false	eval.txt	/*v:false*
+v:fcs_choice	eval.txt	/*v:fcs_choice*
+v:fcs_reason	eval.txt	/*v:fcs_reason*
+v:fname_diff	eval.txt	/*v:fname_diff*
+v:fname_in	eval.txt	/*v:fname_in*
+v:fname_new	eval.txt	/*v:fname_new*
+v:fname_out	eval.txt	/*v:fname_out*
+v:folddashes	eval.txt	/*v:folddashes*
+v:foldend	eval.txt	/*v:foldend*
+v:foldlevel	eval.txt	/*v:foldlevel*
+v:foldstart	eval.txt	/*v:foldstart*
+v:hlsearch	eval.txt	/*v:hlsearch*
+v:insertmode	eval.txt	/*v:insertmode*
+v:key	eval.txt	/*v:key*
+v:lang	eval.txt	/*v:lang*
+v:lc_time	eval.txt	/*v:lc_time*
+v:lnum	eval.txt	/*v:lnum*
+v:mouse_col	eval.txt	/*v:mouse_col*
+v:mouse_lnum	eval.txt	/*v:mouse_lnum*
+v:mouse_win	eval.txt	/*v:mouse_win*
+v:mouse_winid	eval.txt	/*v:mouse_winid*
+v:none	eval.txt	/*v:none*
+v:null	eval.txt	/*v:null*
+v:oldfiles	eval.txt	/*v:oldfiles*
+v:operator	eval.txt	/*v:operator*
+v:option_new	eval.txt	/*v:option_new*
+v:option_old	eval.txt	/*v:option_old*
+v:option_type	eval.txt	/*v:option_type*
+v:prevcount	eval.txt	/*v:prevcount*
+v:profiling	eval.txt	/*v:profiling*
+v:progname	eval.txt	/*v:progname*
+v:progpath	eval.txt	/*v:progpath*
+v:register	eval.txt	/*v:register*
+v:scrollstart	eval.txt	/*v:scrollstart*
+v:searchforward	eval.txt	/*v:searchforward*
+v:servername	eval.txt	/*v:servername*
+v:shell_error	eval.txt	/*v:shell_error*
+v:statusmsg	eval.txt	/*v:statusmsg*
+v:swapchoice	eval.txt	/*v:swapchoice*
+v:swapcommand	eval.txt	/*v:swapcommand*
+v:swapname	eval.txt	/*v:swapname*
+v:t_TYPE	eval.txt	/*v:t_TYPE*
+v:t_bool	eval.txt	/*v:t_bool*
+v:t_channel	eval.txt	/*v:t_channel*
+v:t_dict	eval.txt	/*v:t_dict*
+v:t_float	eval.txt	/*v:t_float*
+v:t_func	eval.txt	/*v:t_func*
+v:t_job	eval.txt	/*v:t_job*
+v:t_list	eval.txt	/*v:t_list*
+v:t_none	eval.txt	/*v:t_none*
+v:t_number	eval.txt	/*v:t_number*
+v:t_string	eval.txt	/*v:t_string*
+v:termblinkresp	eval.txt	/*v:termblinkresp*
+v:termrbgresp	eval.txt	/*v:termrbgresp*
+v:termresponse	eval.txt	/*v:termresponse*
+v:termrfgresp	eval.txt	/*v:termrfgresp*
+v:termstyleresp	eval.txt	/*v:termstyleresp*
+v:termu7resp	eval.txt	/*v:termu7resp*
+v:testing	eval.txt	/*v:testing*
+v:this_session	eval.txt	/*v:this_session*
+v:throwpoint	eval.txt	/*v:throwpoint*
+v:true	eval.txt	/*v:true*
+v:val	eval.txt	/*v:val*
+v:var	eval.txt	/*v:var*
+v:version	eval.txt	/*v:version*
+v:vim_did_enter	eval.txt	/*v:vim_did_enter*
+v:warningmsg	eval.txt	/*v:warningmsg*
+v:windowid	eval.txt	/*v:windowid*
+v_!	change.txt	/*v_!*
+v_$	visual.txt	/*v_$*
+v_:	cmdline.txt	/*v_:*
+v_<	change.txt	/*v_<*
+v_<BS>	change.txt	/*v_<BS>*
+v_<Del>	change.txt	/*v_<Del>*
+v_<Esc>	visual.txt	/*v_<Esc>*
+v_=	change.txt	/*v_=*
+v_>	change.txt	/*v_>*
+v_C	change.txt	/*v_C*
+v_CTRL-A	change.txt	/*v_CTRL-A*
+v_CTRL-C	visual.txt	/*v_CTRL-C*
+v_CTRL-G	visual.txt	/*v_CTRL-G*
+v_CTRL-H	change.txt	/*v_CTRL-H*
+v_CTRL-O	visual.txt	/*v_CTRL-O*
+v_CTRL-V	visual.txt	/*v_CTRL-V*
+v_CTRL-X	change.txt	/*v_CTRL-X*
+v_CTRL-Z	starting.txt	/*v_CTRL-Z*
+v_CTRL-\_CTRL-G	intro.txt	/*v_CTRL-\\_CTRL-G*
+v_CTRL-\_CTRL-N	intro.txt	/*v_CTRL-\\_CTRL-N*
+v_CTRL-]	tagsrch.txt	/*v_CTRL-]*
+v_D	change.txt	/*v_D*
+v_J	change.txt	/*v_J*
+v_K	various.txt	/*v_K*
+v_O	visual.txt	/*v_O*
+v_P	change.txt	/*v_P*
+v_R	change.txt	/*v_R*
+v_S	change.txt	/*v_S*
+v_U	change.txt	/*v_U*
+v_V	visual.txt	/*v_V*
+v_X	change.txt	/*v_X*
+v_Y	change.txt	/*v_Y*
+v_a	motion.txt	/*v_a*
+v_a'	motion.txt	/*v_a'*
+v_a(	motion.txt	/*v_a(*
+v_a)	motion.txt	/*v_a)*
+v_a<	motion.txt	/*v_a<*
+v_a>	motion.txt	/*v_a>*
+v_aB	motion.txt	/*v_aB*
+v_aW	motion.txt	/*v_aW*
+v_a[	motion.txt	/*v_a[*
+v_a]	motion.txt	/*v_a]*
+v_a`	motion.txt	/*v_a`*
+v_ab	motion.txt	/*v_ab*
+v_ap	motion.txt	/*v_ap*
+v_aquote	motion.txt	/*v_aquote*
+v_as	motion.txt	/*v_as*
+v_at	motion.txt	/*v_at*
+v_aw	motion.txt	/*v_aw*
+v_a{	motion.txt	/*v_a{*
+v_a}	motion.txt	/*v_a}*
+v_b_<	visual.txt	/*v_b_<*
+v_b_<_example	visual.txt	/*v_b_<_example*
+v_b_>	visual.txt	/*v_b_>*
+v_b_>_example	visual.txt	/*v_b_>_example*
+v_b_A	visual.txt	/*v_b_A*
+v_b_A_example	visual.txt	/*v_b_A_example*
+v_b_C	visual.txt	/*v_b_C*
+v_b_D	change.txt	/*v_b_D*
+v_b_I	visual.txt	/*v_b_I*
+v_b_I_example	visual.txt	/*v_b_I_example*
+v_b_c	visual.txt	/*v_b_c*
+v_b_r	visual.txt	/*v_b_r*
+v_b_r_example	visual.txt	/*v_b_r_example*
+v_c	change.txt	/*v_c*
+v_d	change.txt	/*v_d*
+v_g?	change.txt	/*v_g?*
+v_gF	editing.txt	/*v_gF*
+v_gJ	change.txt	/*v_gJ*
+v_gN	visual.txt	/*v_gN*
+v_gV	visual.txt	/*v_gV*
+v_g]	tagsrch.txt	/*v_g]*
+v_g_CTRL-A	change.txt	/*v_g_CTRL-A*
+v_g_CTRL-G	editing.txt	/*v_g_CTRL-G*
+v_g_CTRL-X	change.txt	/*v_g_CTRL-X*
+v_g_CTRL-]	tagsrch.txt	/*v_g_CTRL-]*
+v_gf	editing.txt	/*v_gf*
+v_gn	visual.txt	/*v_gn*
+v_gq	change.txt	/*v_gq*
+v_gv	visual.txt	/*v_gv*
+v_gw	change.txt	/*v_gw*
+v_i	motion.txt	/*v_i*
+v_i'	motion.txt	/*v_i'*
+v_i(	motion.txt	/*v_i(*
+v_i)	motion.txt	/*v_i)*
+v_i<	motion.txt	/*v_i<*
+v_i>	motion.txt	/*v_i>*
+v_iB	motion.txt	/*v_iB*
+v_iW	motion.txt	/*v_iW*
+v_i[	motion.txt	/*v_i[*
+v_i]	motion.txt	/*v_i]*
+v_i`	motion.txt	/*v_i`*
+v_ib	motion.txt	/*v_ib*
+v_ip	motion.txt	/*v_ip*
+v_iquote	motion.txt	/*v_iquote*
+v_is	motion.txt	/*v_is*
+v_it	motion.txt	/*v_it*
+v_iw	motion.txt	/*v_iw*
+v_i{	motion.txt	/*v_i{*
+v_i}	motion.txt	/*v_i}*
+v_o	visual.txt	/*v_o*
+v_p	change.txt	/*v_p*
+v_r	change.txt	/*v_r*
+v_s	change.txt	/*v_s*
+v_u	change.txt	/*v_u*
+v_v	visual.txt	/*v_v*
+v_x	change.txt	/*v_x*
+v_y	change.txt	/*v_y*
+v_~	change.txt	/*v_~*
+vab	motion.txt	/*vab*
+val-variable	eval.txt	/*val-variable*
+valgrind	debug.txt	/*valgrind*
+values()	eval.txt	/*values()*
+var-functions	usr_41.txt	/*var-functions*
+variables	eval.txt	/*variables*
+various	various.txt	/*various*
+various-cmds	various.txt	/*various-cmds*
+various-functions	usr_41.txt	/*various-functions*
+various-motions	motion.txt	/*various-motions*
+various.txt	various.txt	/*various.txt*
+vb.vim	syntax.txt	/*vb.vim*
+vba	pi_vimball.txt	/*vba*
+verbose	starting.txt	/*verbose*
+version-5.1	version5.txt	/*version-5.1*
+version-5.2	version5.txt	/*version-5.2*
+version-5.3	version5.txt	/*version-5.3*
+version-5.4	version5.txt	/*version-5.4*
+version-5.5	version5.txt	/*version-5.5*
+version-5.6	version5.txt	/*version-5.6*
+version-5.7	version5.txt	/*version-5.7*
+version-5.8	version5.txt	/*version-5.8*
+version-6.1	version6.txt	/*version-6.1*
+version-6.2	version6.txt	/*version-6.2*
+version-6.3	version6.txt	/*version-6.3*
+version-6.4	version6.txt	/*version-6.4*
+version-7.0	version7.txt	/*version-7.0*
+version-7.1	version7.txt	/*version-7.1*
+version-7.2	version7.txt	/*version-7.2*
+version-7.3	version7.txt	/*version-7.3*
+version-7.4	version7.txt	/*version-7.4*
+version-8.0	version8.txt	/*version-8.0*
+version-8.1	version8.txt	/*version-8.1*
+version-variable	eval.txt	/*version-variable*
+version4.txt	version4.txt	/*version4.txt*
+version5.txt	version5.txt	/*version5.txt*
+version6.txt	version6.txt	/*version6.txt*
+version7.0	version7.txt	/*version7.0*
+version7.1	version7.txt	/*version7.1*
+version7.2	version7.txt	/*version7.2*
+version7.3	version7.txt	/*version7.3*
+version7.4	version7.txt	/*version7.4*
+version7.txt	version7.txt	/*version7.txt*
+version8.0	version8.txt	/*version8.0*
+version8.1	version8.txt	/*version8.1*
+version8.txt	version8.txt	/*version8.txt*
+vi	intro.txt	/*vi*
+vi-differences	vi_diff.txt	/*vi-differences*
+vi:	options.txt	/*vi:*
+vi_diff.txt	vi_diff.txt	/*vi_diff.txt*
+vib	motion.txt	/*vib*
+view	starting.txt	/*view*
+view-diffs	diff.txt	/*view-diffs*
+view-file	starting.txt	/*view-file*
+views-sessions	starting.txt	/*views-sessions*
+vim-7.4	version7.txt	/*vim-7.4*
+vim-8	version8.txt	/*vim-8*
+vim-8.1	version8.txt	/*vim-8.1*
+vim-additions	vi_diff.txt	/*vim-additions*
+vim-announce	intro.txt	/*vim-announce*
+vim-arguments	starting.txt	/*vim-arguments*
+vim-default-editor	gui_w32.txt	/*vim-default-editor*
+vim-dev	intro.txt	/*vim-dev*
+vim-mac	intro.txt	/*vim-mac*
+vim-modes	intro.txt	/*vim-modes*
+vim-modes-intro	intro.txt	/*vim-modes-intro*
+vim-script-intro	usr_41.txt	/*vim-script-intro*
+vim-use	intro.txt	/*vim-use*
+vim-variable	eval.txt	/*vim-variable*
+vim.vim	syntax.txt	/*vim.vim*
+vim7	version7.txt	/*vim7*
+vim8	version8.txt	/*vim8*
+vim:	options.txt	/*vim:*
+vim_announce	intro.txt	/*vim_announce*
+vim_dev	intro.txt	/*vim_dev*
+vim_did_enter-variable	eval.txt	/*vim_did_enter-variable*
+vim_mac	intro.txt	/*vim_mac*
+vim_starting	eval.txt	/*vim_starting*
+vim_use	intro.txt	/*vim_use*
+vimball	pi_vimball.txt	/*vimball*
+vimball-contents	pi_vimball.txt	/*vimball-contents*
+vimball-extract	pi_vimball.txt	/*vimball-extract*
+vimball-history	pi_vimball.txt	/*vimball-history*
+vimball-intro	pi_vimball.txt	/*vimball-intro*
+vimball-manual	pi_vimball.txt	/*vimball-manual*
+vimball-windows	pi_vimball.txt	/*vimball-windows*
+vimdev	intro.txt	/*vimdev*
+vimdiff	diff.txt	/*vimdiff*
+vimfiles	options.txt	/*vimfiles*
+viminfo	starting.txt	/*viminfo*
+viminfo-!	options.txt	/*viminfo-!*
+viminfo-%	options.txt	/*viminfo-%*
+viminfo-'	options.txt	/*viminfo-'*
+viminfo-/	options.txt	/*viminfo-\/*
+viminfo-:	options.txt	/*viminfo-:*
+viminfo-<	options.txt	/*viminfo-<*
+viminfo-@	options.txt	/*viminfo-@*
+viminfo-c	options.txt	/*viminfo-c*
+viminfo-encoding	starting.txt	/*viminfo-encoding*
+viminfo-errors	starting.txt	/*viminfo-errors*
+viminfo-f	options.txt	/*viminfo-f*
+viminfo-file	starting.txt	/*viminfo-file*
+viminfo-file-marks	starting.txt	/*viminfo-file-marks*
+viminfo-file-name	starting.txt	/*viminfo-file-name*
+viminfo-h	options.txt	/*viminfo-h*
+viminfo-n	options.txt	/*viminfo-n*
+viminfo-quote	options.txt	/*viminfo-quote*
+viminfo-r	options.txt	/*viminfo-r*
+viminfo-read	starting.txt	/*viminfo-read*
+viminfo-read-write	starting.txt	/*viminfo-read-write*
+viminfo-s	options.txt	/*viminfo-s*
+viminfo-timestamp	starting.txt	/*viminfo-timestamp*
+viminfo-write	starting.txt	/*viminfo-write*
+vimrc	starting.txt	/*vimrc*
+vimrc-filetype	usr_05.txt	/*vimrc-filetype*
+vimrc-intro	usr_05.txt	/*vimrc-intro*
+vimrc-option-example	starting.txt	/*vimrc-option-example*
+vimrc_example.vim	usr_05.txt	/*vimrc_example.vim*
+vimtutor	usr_01.txt	/*vimtutor*
+virtcol()	eval.txt	/*virtcol()*
+visual-block	visual.txt	/*visual-block*
+visual-change	visual.txt	/*visual-change*
+visual-examples	visual.txt	/*visual-examples*
+visual-index	index.txt	/*visual-index*
+visual-mode	visual.txt	/*visual-mode*
+visual-operators	visual.txt	/*visual-operators*
+visual-repeat	visual.txt	/*visual-repeat*
+visual-search	visual.txt	/*visual-search*
+visual-start	visual.txt	/*visual-start*
+visual-use	visual.txt	/*visual-use*
+visual.txt	visual.txt	/*visual.txt*
+visualmode()	eval.txt	/*visualmode()*
+vms	os_vms.txt	/*vms*
+vms-authors	os_vms.txt	/*vms-authors*
+vms-changes	os_vms.txt	/*vms-changes*
+vms-compiling	os_vms.txt	/*vms-compiling*
+vms-deploy	os_vms.txt	/*vms-deploy*
+vms-download	os_vms.txt	/*vms-download*
+vms-gui	os_vms.txt	/*vms-gui*
+vms-notes	os_vms.txt	/*vms-notes*
+vms-problems	os_vms.txt	/*vms-problems*
+vms-started	os_vms.txt	/*vms-started*
+vms-usage	os_vms.txt	/*vms-usage*
+vote-for-features	sponsor.txt	/*vote-for-features*
+votes-counted	sponsor.txt	/*votes-counted*
+votes-for-changes	todo.txt	/*votes-for-changes*
+vreplace-mode	insert.txt	/*vreplace-mode*
+vt100-cursor-keys	term.txt	/*vt100-cursor-keys*
+vt100-function-keys	term.txt	/*vt100-function-keys*
+w	motion.txt	/*w*
+w32-clientserver	remote.txt	/*w32-clientserver*
+w32-xpm-support	gui_w32.txt	/*w32-xpm-support*
+w:	eval.txt	/*w:*
+w:current_syntax	syntax.txt	/*w:current_syntax*
+w:quickfix_title	quickfix.txt	/*w:quickfix_title*
+w:var	eval.txt	/*w:var*
+waittime	channel.txt	/*waittime*
+warningmsg-variable	eval.txt	/*warningmsg-variable*
+white-space	pattern.txt	/*white-space*
+whitespace	pattern.txt	/*whitespace*
+wildcard	editing.txt	/*wildcard*
+wildcards	editing.txt	/*wildcards*
+wildmenumode()	eval.txt	/*wildmenumode()*
+win16	os_win32.txt	/*win16*
+win32	os_win32.txt	/*win32*
+win32-!start	gui_w32.txt	/*win32-!start*
+win32-PATH	os_win32.txt	/*win32-PATH*
+win32-backslashes	os_win32.txt	/*win32-backslashes*
+win32-cmdargs	os_win32.txt	/*win32-cmdargs*
+win32-colors	gui_w32.txt	/*win32-colors*
+win32-compiling	os_win32.txt	/*win32-compiling*
+win32-curdir	os_win32.txt	/*win32-curdir*
+win32-faq	os_win32.txt	/*win32-faq*
+win32-gettext	mlang.txt	/*win32-gettext*
+win32-gui	gui_w32.txt	/*win32-gui*
+win32-hidden-menus	gui.txt	/*win32-hidden-menus*
+win32-mouse	os_win32.txt	/*win32-mouse*
+win32-open-with-menu	gui_w32.txt	/*win32-open-with-menu*
+win32-popup-menu	gui_w32.txt	/*win32-popup-menu*
+win32-problems	os_win32.txt	/*win32-problems*
+win32-quotes	os_win32.txt	/*win32-quotes*
+win32-restore	os_win32.txt	/*win32-restore*
+win32-startup	os_win32.txt	/*win32-startup*
+win32-term	os_win32.txt	/*win32-term*
+win32-vimrun	gui_w32.txt	/*win32-vimrun*
+win32-win3.1	os_win32.txt	/*win32-win3.1*
+win32-win95	os_win32.txt	/*win32-win95*
+win32s	os_win32.txt	/*win32s*
+win_findbuf()	eval.txt	/*win_findbuf()*
+win_getid()	eval.txt	/*win_getid()*
+win_gotoid()	eval.txt	/*win_gotoid()*
+win_id2tabwin()	eval.txt	/*win_id2tabwin()*
+win_id2win()	eval.txt	/*win_id2win()*
+win_screenpos()	eval.txt	/*win_screenpos()*
+winbufnr()	eval.txt	/*winbufnr()*
+wincol()	eval.txt	/*wincol()*
+window	windows.txt	/*window*
+window-ID	windows.txt	/*window-ID*
+window-contents	intro.txt	/*window-contents*
+window-exit	editing.txt	/*window-exit*
+window-functions	usr_41.txt	/*window-functions*
+window-move-cursor	windows.txt	/*window-move-cursor*
+window-moving	windows.txt	/*window-moving*
+window-resize	windows.txt	/*window-resize*
+window-size	term.txt	/*window-size*
+window-size-functions	usr_41.txt	/*window-size-functions*
+window-tag	windows.txt	/*window-tag*
+window-toolbar	gui.txt	/*window-toolbar*
+window-variable	eval.txt	/*window-variable*
+windowid	windows.txt	/*windowid*
+windowid-variable	eval.txt	/*windowid-variable*
+windows	windows.txt	/*windows*
+windows-3.1	os_win32.txt	/*windows-3.1*
+windows-icon	os_win32.txt	/*windows-icon*
+windows-intro	windows.txt	/*windows-intro*
+windows-starting	windows.txt	/*windows-starting*
+windows.txt	windows.txt	/*windows.txt*
+windows95	os_win32.txt	/*windows95*
+windows98	os_win32.txt	/*windows98*
+windowsme	os_win32.txt	/*windowsme*
+winheight()	eval.txt	/*winheight()*
+winid	windows.txt	/*winid*
+winlayout()	eval.txt	/*winlayout()*
+winline()	eval.txt	/*winline()*
+winnr()	eval.txt	/*winnr()*
+winrestcmd()	eval.txt	/*winrestcmd()*
+winrestview()	eval.txt	/*winrestview()*
+winsaveview()	eval.txt	/*winsaveview()*
+winwidth()	eval.txt	/*winwidth()*
+word	motion.txt	/*word*
+word-count	editing.txt	/*word-count*
+word-motions	motion.txt	/*word-motions*
+wordcount()	eval.txt	/*wordcount()*
+workbench	starting.txt	/*workbench*
+workshop	workshop.txt	/*workshop*
+workshop-commands	workshop.txt	/*workshop-commands*
+workshop-compiling	workshop.txt	/*workshop-compiling*
+workshop-configure	workshop.txt	/*workshop-configure*
+workshop-intro	workshop.txt	/*workshop-intro*
+workshop-support	workshop.txt	/*workshop-support*
+workshop-xpm	workshop.txt	/*workshop-xpm*
+workshop.txt	workshop.txt	/*workshop.txt*
+wrap-off	intro.txt	/*wrap-off*
+write-compiler-plugin	usr_41.txt	/*write-compiler-plugin*
+write-device	editing.txt	/*write-device*
+write-fail	editing.txt	/*write-fail*
+write-filetype-plugin	usr_41.txt	/*write-filetype-plugin*
+write-library-script	usr_41.txt	/*write-library-script*
+write-local-help	usr_41.txt	/*write-local-help*
+write-permissions	editing.txt	/*write-permissions*
+write-plugin	usr_41.txt	/*write-plugin*
+write-plugin-quickload	usr_41.txt	/*write-plugin-quickload*
+write-quit	editing.txt	/*write-quit*
+write-readonly	editing.txt	/*write-readonly*
+writefile()	eval.txt	/*writefile()*
+writing	editing.txt	/*writing*
+www	intro.txt	/*www*
+x	change.txt	/*x*
+x-input-method	mbyte.txt	/*x-input-method*
+x-resources	version5.txt	/*x-resources*
+x11-clientserver	remote.txt	/*x11-clientserver*
+x11-cut-buffer	gui_x11.txt	/*x11-cut-buffer*
+x11-selection	gui_x11.txt	/*x11-selection*
+xf86conf.vim	syntax.txt	/*xf86conf.vim*
+xfontset	mbyte.txt	/*xfontset*
+xfree-xterm	syntax.txt	/*xfree-xterm*
+xim	mbyte.txt	/*xim*
+xim-input-style	mbyte.txt	/*xim-input-style*
+xiterm	syntax.txt	/*xiterm*
+xml-folding	syntax.txt	/*xml-folding*
+xml-omni-datafile	insert.txt	/*xml-omni-datafile*
+xml.vim	syntax.txt	/*xml.vim*
+xor()	eval.txt	/*xor()*
+xpm.vim	syntax.txt	/*xpm.vim*
+xterm-8-bit	term.txt	/*xterm-8-bit*
+xterm-8bit	term.txt	/*xterm-8bit*
+xterm-blink	syntax.txt	/*xterm-blink*
+xterm-blinking-cursor	syntax.txt	/*xterm-blinking-cursor*
+xterm-bracketed-paste	term.txt	/*xterm-bracketed-paste*
+xterm-clipboard	term.txt	/*xterm-clipboard*
+xterm-codes	term.txt	/*xterm-codes*
+xterm-color	syntax.txt	/*xterm-color*
+xterm-command-server	term.txt	/*xterm-command-server*
+xterm-copy-paste	term.txt	/*xterm-copy-paste*
+xterm-cursor-keys	term.txt	/*xterm-cursor-keys*
+xterm-end-home-keys	term.txt	/*xterm-end-home-keys*
+xterm-function-keys	term.txt	/*xterm-function-keys*
+xterm-modifier-keys	term.txt	/*xterm-modifier-keys*
+xterm-mouse	options.txt	/*xterm-mouse*
+xterm-mouse-wheel	scroll.txt	/*xterm-mouse-wheel*
+xterm-resize	term.txt	/*xterm-resize*
+xterm-save-screen	tips.txt	/*xterm-save-screen*
+xterm-screens	tips.txt	/*xterm-screens*
+xterm-scroll-region	term.txt	/*xterm-scroll-region*
+xterm-shifted-keys	term.txt	/*xterm-shifted-keys*
+xterm-true-color	term.txt	/*xterm-true-color*
+y	change.txt	/*y*
+yaml.vim	syntax.txt	/*yaml.vim*
+yank	change.txt	/*yank*
+ye-option-gone	version4.txt	/*ye-option-gone*
+year-2000	intro.txt	/*year-2000*
+your-runtime-dir	usr_43.txt	/*your-runtime-dir*
+yy	change.txt	/*yy*
+z	index.txt	/*z*
+z+	scroll.txt	/*z+*
+z-	scroll.txt	/*z-*
+z.	scroll.txt	/*z.*
+z/OS	os_390.txt	/*z\/OS*
+z<CR>	scroll.txt	/*z<CR>*
+z<Left>	scroll.txt	/*z<Left>*
+z<Right>	scroll.txt	/*z<Right>*
+z=	spell.txt	/*z=*
+zA	fold.txt	/*zA*
+zC	fold.txt	/*zC*
+zD	fold.txt	/*zD*
+zE	fold.txt	/*zE*
+zF	fold.txt	/*zF*
+zG	spell.txt	/*zG*
+zH	scroll.txt	/*zH*
+zL	scroll.txt	/*zL*
+zM	fold.txt	/*zM*
+zN	fold.txt	/*zN*
+zN<CR>	scroll.txt	/*zN<CR>*
+zO	fold.txt	/*zO*
+zOS	os_390.txt	/*zOS*
+zOS-Bugs	os_390.txt	/*zOS-Bugs*
+zOS-Motif	os_390.txt	/*zOS-Motif*
+zOS-PuTTY	os_390.txt	/*zOS-PuTTY*
+zOS-has-ebcdic	os_390.txt	/*zOS-has-ebcdic*
+zOS-limitations	os_390.txt	/*zOS-limitations*
+zOS-open-source	os_390.txt	/*zOS-open-source*
+zR	fold.txt	/*zR*
+zW	spell.txt	/*zW*
+zX	fold.txt	/*zX*
+z^	scroll.txt	/*z^*
+za	fold.txt	/*za*
+zb	scroll.txt	/*zb*
+zc	fold.txt	/*zc*
+zd	fold.txt	/*zd*
+ze	scroll.txt	/*ze*
+zf	fold.txt	/*zf*
+zg	spell.txt	/*zg*
+zh	scroll.txt	/*zh*
+zi	fold.txt	/*zi*
+zip	pi_zip.txt	/*zip*
+zip-contents	pi_zip.txt	/*zip-contents*
+zip-copyright	pi_zip.txt	/*zip-copyright*
+zip-extension	pi_zip.txt	/*zip-extension*
+zip-history	pi_zip.txt	/*zip-history*
+zip-manual	pi_zip.txt	/*zip-manual*
+zip-usage	pi_zip.txt	/*zip-usage*
+zip-x	pi_zip.txt	/*zip-x*
+zj	fold.txt	/*zj*
+zk	fold.txt	/*zk*
+zl	scroll.txt	/*zl*
+zm	fold.txt	/*zm*
+zn	fold.txt	/*zn*
+zo	fold.txt	/*zo*
+zr	fold.txt	/*zr*
+zs	scroll.txt	/*zs*
+zsh.vim	syntax.txt	/*zsh.vim*
+zt	scroll.txt	/*zt*
+zuG	spell.txt	/*zuG*
+zuW	spell.txt	/*zuW*
+zug	spell.txt	/*zug*
+zuw	spell.txt	/*zuw*
+zv	fold.txt	/*zv*
+zw	spell.txt	/*zw*
+zx	fold.txt	/*zx*
+zz	scroll.txt	/*zz*
+{	motion.txt	/*{*
+{Visual}	intro.txt	/*{Visual}*
+{address}	cmdline.txt	/*{address}*
+{arglist}	editing.txt	/*{arglist}*
+{bufname}	windows.txt	/*{bufname}*
+{char1-char2}	intro.txt	/*{char1-char2}*
+{event}	autocmd.txt	/*{event}*
+{file}	editing.txt	/*{file}*
+{group-name}	syntax.txt	/*{group-name}*
+{lhs}	map.txt	/*{lhs}*
+{motion}	intro.txt	/*{motion}*
+{move-around}	visual.txt	/*{move-around}*
+{offset}	pattern.txt	/*{offset}*
+{pat}	autocmd.txt	/*{pat}*
+{rhs}	map.txt	/*{rhs}*
+{subject}	helphelp.txt	/*{subject}*
+{}	intro.txt	/*{}*
+}	motion.txt	/*}*
+~	change.txt	/*~*
diff --git a/b/runtime/lang/menu_pl.utf-8.vim b/runtime/lang/menu_pl.utf-8.vim
new file mode 100644
index 0000000..a746df2
--- /dev/null
+++ b/runtime/lang/menu_pl.utf-8.vim
@@ -0,0 +1,3 @@
+" Menu Translations:	Polish
+
+source <sfile>:p:h/menu_pl_pl.utf-8.vim
diff --git a/src/Makefile b/src/Makefile
index f2fafa4..7a1b345 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1385,6 +1385,23 @@ CARBONGUI_BUNDLE = gui_bundle
 APPDIR = $(VIMNAME).app
 CARBONGUI_TESTARG = VIMPROG=../$(APPDIR)/Contents/MacOS/$(VIMTARGET)
 
+### Haiku GUI
+HAIKUGUI_SRC	= gui.c gui_haiku.cc
+HAIKUGUI_OBJ	= objects/gui.o objects/gui_haiku.o
+HAIKUGUI_DEFS	= -DFEAT_GUI_HAIKU
+HAIKUGUI_IPATH	=
+HAIKUGUI_LIBS_DIR =
+HAIKUGUI_LIBS1	= -lbe -lroot -ltracker -ltranslation
+ifeq ($(strip $(word 1, $(subst -, , $(subst ., , $(shell $(CC) -dumpversion))))), 5)
+HAIKUGUI_LIBS1	+= -lsupc++ -lstdc++
+endif
+HAIKUGUI_LIBS2	=
+HAIKUGUI_INSTALL = install_normal install_haiku_extra
+HAIKUGUI_TARGETS	= installglinks_haiku
+HAIKUGUI_MAN_TARGETS =
+HAIKUGUI_TESTTARGET = gui
+HAIKUGUI_BUNDLE =
+
 # All GUI files
 ALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c
 ALL_GUI_PRO  = gui.pro gui_gtk.pro gui_motif.pro gui_xmdlg.pro gui_athena.pro gui_gtk_x11.pro gui_x11.pro gui_w32.pro gui_photon.pro
@@ -2993,6 +3010,9 @@ objects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c
 objects/gui_gtk_x11.o: gui_gtk_x11.c
 	$(CCC) -o $@ gui_gtk_x11.c
 
+objects/gui_haiku.o: gui_haiku.cc
+	$(CCC) -o $@ gui_haiku.cc
+
 objects/gui_motif.o: gui_motif.c
 	$(CCC) -o $@ gui_motif.c
 
@@ -3110,6 +3130,9 @@ objects/option.o: option.c
 objects/os_beos.o: os_beos.c
 	$(CCC) -o $@ os_beos.c
 
+objects/os_haiku.rsrc: os_haiku.rdef
+	cat $< | $(CCC) -E - | grep -v '^#' | rc -o "$@" -
+
 objects/os_qnx.o: os_qnx.c
 	$(CCC) -o $@ os_qnx.c
 
@@ -3312,6 +3335,63 @@ $(APPDIR)/Contents:
 
 
 ###############################################################################
+###
+### Haiku installation
+###
+### This rule:
+###		- add resources to already installed vim binary to avoid stripping
+###			them during install;
+###		- copy rgb.txt to runtime directory;
+###		- update system MIME database with info about vim application.
+###
+install_haiku_extra: $(DEST_BIN)/$(VIMTARGET) objects/os_haiku.rsrc
+	xres -o $(DEST_BIN)/$(VIMTARGET) objects/os_haiku.rsrc
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/rgb.txt $(DEST_RT)
+	mimeset	$(DEST_BIN)/$(VIMTARGET)
+
+###
+###	List of g*-links that should be replaced with shell script equivalents.
+###	This solves the problem of them from Tracker.
+###
+HAIKU_GLINKS = 	$(DEST_BIN)/$(GVIMTARGET) \
+				$(DEST_BIN)/$(GVIEWTARGET) \
+				$(DEST_BIN)/$(GVIMDIFFTARGET) \
+				$(DEST_BIN)/$(RGVIMTARGET) \
+				$(DEST_BIN)/$(RGVIEWTARGET)
+###
+###	This rule:
+###		- Replace gvim link with copy of vim binary.
+###		- Replace g*-links with shell script equivalents to solve the problem
+###			of calling them from Tracker,
+###		- Add icon resources to mentioned g*-link shell scripts
+###		- in case gui-less vim.con executable available use it.
+###
+installglinks_haiku: $(HAIKU_GLINKS) install_haiku_extra
+	@catattr -r "BEOS:ICON" $(DEST_BIN)/$(GVIMTARGET) > ~icon.attr
+	for i in $(HAIKU_GLINKS); do \
+		rm $$i ; \
+		echo "#!/bin/sh" > $$i ; \
+		case $$i in \
+			$(DEST_BIN)/$(GVIMTARGET)) \
+				cp $(DEST_BIN)/$(VIMTARGET) $$i ; \
+				if [ -f $(VIMTARGET).con ] ; then \
+					$(STRIP) $(VIMTARGET).con ; \
+					mv $(VIMTARGET).con $(DEST_BIN)/$(VIMTARGET) ; \
+				fi ;; \
+			$(DEST_BIN)/$(GVIEWTARGET))    printf "%s -R %c%c" $(GVIMTARGET) '$$' '*' >> $$i;; \
+			$(DEST_BIN)/$(GVIMDIFFTARGET)) printf "%s -d %c%c" $(GVIMTARGET) '$$' '*' >> $$i;; \
+			$(DEST_BIN)/$(RGVIMTARGET))    printf "%s -Z %c%c" $(GVIMTARGET) '$$' '*' >> $$i;; \
+			$(DEST_BIN)/$(RGVIEWTARGET))   printf "%s -Z -R %c%c" $(GVIMTARGET) '$$' '*' >> $$i;; \
+			*) printf "%s %c%c" $(GVIMTARGET) '$$' '*' >> $$i;; \
+		esac ; \
+		chmod $(BINMOD) $$i ; \
+		addattr -f ~icon.attr  -t \'VICN\' BEOS:ICON $$i ; \
+	done
+	addattr -f ~icon.attr  -t \'VICN\' BEOS:ICON $(DEST_BIN)/$(VIMNAME)tutor
+	@rm ~icon.attr
+
+###############################################################################
+
 ### (automatically generated by 'make depend')
 ### Dependencies:
 objects/arabic.o: arabic.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
diff --git a/b/src/Makefile.orig b/src/Makefile.orig
new file mode 100644
index 0000000..f2fafa4
--- /dev/null
+++ b/src/Makefile.orig
@@ -0,0 +1,3714 @@
+# Makefile for Vim on Unix and Unix-like systems	vim:ts=8:sw=8:tw=78
+#
+# This Makefile is loosely based on the GNU Makefile conventions found in
+# standards.info.
+#
+# Compiling Vim, summary:
+#
+#	3. make
+#	5. make install
+#
+# Compiling Vim, details:
+#
+# Edit this file for adjusting to your system. You should not need to edit any
+# other file for machine specific things!
+# The name of this file MUST be Makefile (note the uppercase 'M').
+#
+# 1. Edit this Makefile  {{{1
+#	The defaults for Vim should work on most machines, but you may want to
+#	uncomment some lines or make other changes below to tune it to your
+#	system, compiler or preferences.  Uncommenting means that the '#' in
+#	the first column of a line is removed.
+#	- If you want a version of Vim that is small and starts up quickly,
+#	  you might want to disable the GUI, X11, Perl, Python and Tcl.
+#	- Uncomment the line with --disable-gui if you have Motif, GTK and/or
+#	  Athena but don't want to make gvim (the GUI version of Vim with nice
+#	  menus and scrollbars, but makes Vim bigger and startup slower).
+#	- Uncomment --disable-darwin if on Mac OS X but you want to compile a
+#	  Unix version.
+#	- Uncomment the line "CONF_OPT_X = --without-x" if you have X11 but
+#	  want to disable using X11 libraries.	This speeds up starting Vim,
+#	  but the window title will not be set and the X11 selection can not
+#	  be used.
+#	- Uncomment the line "CONF_OPT_XSMP = --disable-xsmp" if you have the
+#	  X11 Session Management Protocol (XSMP) library (libSM) but do not
+#	  want to use it.
+#	  This can speedup Vim startup but Vim loses the ability to catch the
+#	  user logging out from session-managers like GNOME and work
+#	  could be lost.
+#	- Uncomment one or more of these lines to include an interface;
+#	  each makes Vim quite a bit bigger:
+#		--enable-luainterp	for Lua interpreter
+#		--enable-mzschemeinterp	for MzScheme interpreter
+#		--enable-perlinterp	for Perl interpreter
+#		--enable-python3interp	for Python3 interpreter
+#		--enable-pythoninterp	for Python interpreter
+#		--enable-rubyinterp	for Ruby interpreter
+#		--enable-tclinterp	for Tcl interpreter
+#		--enable-cscope		for Cscope interface
+#	- Uncomment one of the lines with --with-features= to enable a set of
+#	  features (but not the interfaces just mentioned).
+#	- Uncomment the line with --disable-acl to disable ACL support even
+#	  though your system supports it.
+#	- Uncomment the line with --disable-gpm to disable gpm support
+#	  even though you have gpm libraries and includes.
+#	- Uncomment the line with --disable-sysmouse to disable sysmouse
+#	  support even though you have /dev/sysmouse and includes.
+#	- Uncomment one of the lines with CFLAGS and/or CC if you have
+#	  something very special or want to tune the optimizer.
+#	- Search for the name of your system to see if it needs anything
+#	  special.
+#	- A few versions of make use '.include "file"' instead of 'include
+#	  file'.  Adjust the include line below if yours does.
+#
+# 2. Edit feature.h  {{{1
+#	Only if you do not agree with the default compile features, e.g.:
+#	- you want Vim to be as vi compatible as it can be
+#	- you want to use Emacs tags files
+#	- you want right-to-left editing (Hebrew)
+#	- you want 'langmap' support (Greek)
+#	- you want to remove features to make Vim smaller
+#
+# 3. "make"  {{{1
+#	Will first run ./configure with the options in this file. Then it will
+#	start make again on this Makefile to do the compiling. You can also do
+#	this in two steps with:
+#		make config
+#		make
+#	The configuration phase creates/overwrites auto/config.h and
+#	auto/config.mk.
+#	The configure script is created with "make autoconf".  It can detect
+#	different features of your system and act accordingly.  However, it is
+#	not correct for all systems.  Check this:
+#	- If you have X windows, but configure could not find it or reported
+#	  another include/library directory then you wanted to use, you have
+#	  to set CONF_OPT_X below.  You might also check the installation of
+#	  xmkmf.
+#	- If you have --enable-gui=motif and have Motif on your system, but
+#	  configure reports "checking for location of gui... <not found>", you
+#	  have to set GUI_INC_LOC and GUI_LIB_LOC below.
+#	If you changed something, do this to run configure again:
+#		make reconfig
+#
+#	- If you do not trust the automatic configuration code, then inspect
+#	  auto/config.h and auto/config.mk, before starting the actual build
+#	  phase. If possible edit this Makefile, rather than auto/config.mk --
+#	  especially look at the definition of VIMLOC below. Note that the
+#	  configure phase overwrites auto/config.mk and auto/config.h again.
+#	- If you get error messages, find out what is wrong and try to correct
+#	  it in this Makefile. You may need to do "make reconfig" when you
+#	  change anything that configure uses (e.g. switching from an old C
+#	  compiler to an ANSI C compiler). Only when auto/configure does
+#	  something wrong you may need to change one of the other files. If
+#	  you find a clean way to fix the problem, consider sending a note to
+#	  the author of autoconf (bug-gnu-utils@prep.ai.mit.edu) or Vim
+#	  (Bram@vim.org). Don't bother to do that when you made a hack
+#	  solution for a non-standard system.
+#
+# 4. "make test"  {{{1
+#	This is optional.  This will run Vim scripts on a number of test
+#	files, and compare the produced output with the expected output.
+#	If all is well, you will get the "ALL DONE" message in the end.  If a
+#	test fails you get "TEST FAILURE".  See below (search for "/^test").
+#
+# 5. "make install"  {{{1
+#	If the new Vim seems to be working OK you can install it and the
+#	documentation in the appropriate location. The default is
+#	"/usr/local".  Change "prefix" below to change the location.
+#	"auto/pathdef.c" will be compiled again after changing this to make
+#	the executable know where the help files are located.
+#	Note that any existing executable is removed or overwritten.  If you
+#	want to keep it you will have to make a backup copy first.
+#	The runtime files are in a different directory for each version.  You
+#	might want to delete an older version.
+#	If you don't want to install everything, there are other targets:
+#		make installvim		only installs Vim, not the tools
+#		make installvimbin	only installs the Vim executable
+#		make installruntime	installs most of the runtime files
+#		make installrtbase	only installs the Vim help and
+#							runtime files
+#		make installlinks	only installs the Vim binary links
+#		make installmanlinks	only installs the Vim manpage links
+#		make installmacros	only installs the Vim macros
+#		make installpack	only installs the packages
+#		make installtutorbin	only installs the Vim tutor program
+#		make installtutor	only installs the Vim tutor files
+#		make installspell	only installs the spell files
+#		make installtools	only installs xxd
+#	If you install Vim, not to install for real but to prepare a package
+#	or RPM, set DESTDIR to the root of the tree.
+#
+# 6. Use Vim until a new version comes out.  {{{1
+#
+# 7. "make uninstall_runtime"  {{{1
+#	Will remove the runtime files for the current version.	This is safe
+#	to use while another version is being used, only version-specific
+#	files will be deleted.
+#	To remove the runtime files of another version:
+#		make uninstall_runtime VIMRTDIR=/vim54
+#	If you want to delete all installed files, use:
+#		make uninstall
+#	Note that this will delete files that have the same name for any
+#	version, thus you might need to do a "make install" soon after this.
+#	Be careful not to remove a version of Vim that is still being used!
+#	To find out which files and directories will be deleted, use:
+#		make -n uninstall
+# }}}
+#
+### This Makefile has been successfully tested on many systems. {{{
+### Only the ones that require special options are mentioned here.
+### Check the (*) column for remarks, listed below.
+### Later code changes may cause small problems, otherwise Vim is supposed to
+### compile and run without problems.
+
+#system:	      configurations:		     version (*) tested by:
+#-------------	      ------------------------	     -------  -  ----------
+#AIX 3.2.5	      cc (not gcc)   -			4.5  (M) Will Fiveash
+#AIX 4		      cc	     +X11 -GUI		3.27 (4) Axel Kielhorn
+#AIX 4.1.4	      cc	     +X11 +GUI		4.5  (5) Nico Bakker
+#AIX 4.2.1	      cc				5.2k (C) Will Fiveash
+#AIX 4.3.3.12	      xic 3.6.6				5.6  (5) David R. Favor
+#A/UX 3.1.1	      gcc	     +X11		4.0  (6) Jim Jagielski
+#BeOS PR	      mwcc DR3				5.0n (T) Olaf Seibert
+#BSDI 2.1 (x86)       shlicc2 gcc-2.6.3 -X11 X11R6	4.5  (1) Jos Backus
+#BSD/OS 3.0 (x86)     gcc gcc-2.7.2.1 -X11 X11R6	4.6c (1) Jos Backus
+#CX/UX 6.2	      cc	     +X11 +GUI_Mofif	5.4  (V) Kipp E. Howard
+#DG/UX 5.4*	      gcc 2.5.8      GUI		5.0e (H) Jonas Schlein
+#DG/UX 5.4R4.20       gcc 2.7.2      GUI		5.0s (H) Rocky Olive
+#HP-UX (most)	      c89 cc				5.1  (2) Bram Moolenaar
+#HP-UX_9.04	      cc	     +X11 +Motif	5.0  (2) Carton Lao
+#Irix 6.3 (O2)	      cc	     ?			4.5  (L) Edouard Poor
+#Irix 6.4	      cc	     ?			5.0m (S) Rick Sayre
+#Irix 6.5	      cc	     ?			6.0  (S) David Harrison
+#Irix 64 bit						4.5  (K) Jon Wright
+#Linux 2.0	      gcc-2.7.2      Infomagic Motif	4.3  (3) Ronald Rietman
+#Linux 2.0.31	      gcc	     +X11 +GUI Athena	5.0w (U) Darren Hiebert
+#LynxOS 3.0.1	      2.9-gnupro-98r2 +X11 +GUI Athena  5.7.1(O) Lorenz Hahn
+#LynxOS 3.1.0	      2.9-gnupro-98r2 +X11 +GUI Athena  5.7.1(O) Lorenz Hahn
+#NEC UP4800 UNIX_SV 4.2MP  cc	     +X11R6 Motif,Athena4.6b (Q) Lennart Schultz
+#NetBSD 1.0A	      gcc-2.4.5      -X11 -GUI		3.21 (X) Juergen Weigert
+#QNX 4.2	      wcc386-10.6    -X11		4.2  (D) G.F. Desrochers
+#QNX 4.23	      Watcom	     -X11		4.2  (F) John Oleynick
+#SCO Unix v3.2.5      cc	     +X11 Motif		3.27 (C) M. Kuperblum
+#SCO Open Server 5    gcc 2.7.2.3    +X11 +GUI Motif	5.3  (A) Glauber Ribeiro
+#SINIX-N 5.43 RM400 R4000   cc	     +X11 +GUI		5.0l (I) Martin Furter
+#SINIX-Z 5.42 i386    gcc 2.7.2.3    +X11 +GUI Motif	5.1  (I) Joachim Fehn
+#SINIX-Y 5.43 RM600 R4000  gcc 2.7.2.3 +X11 +GUI Motif	5.1  (I) Joachim Fehn
+#Reliant/SINIX 5.44   cc	     +X11 +GUI		5.5a (I) B. Pruemmer
+#SNI Targon31 TOS 4.1.11 gcc-2.4.5   +X11 -GUI		4.6c (B) Paul Slootman
+#Solaris 2.4 (Sparc)  cc	     +X11 +GUI		3.29 (9) Glauber
+#Solaris 2.4/2.5      clcc	     +X11 -GUI openwin	3.20 (7) Robert Colon
+#Solaris 2.5 (sun4m)  cc (SC4.0)     +X11R6 +GUI (CDE)	4.6b (E) Andrew Large
+#Solaris 2.5	      cc	     +X11 +GUI Athena	4.2  (9) Sonia Heimann
+#Solaris 2.5	      gcc 2.5.6      +X11 Motif		5.0m (R) Ant. Colombo
+#Solaris 2.6	      gcc 2.8.1      ncurses		5.3  (G) Larry W. Virden
+#Solaris with -lthread					5.5  (W) K. Nagano
+#Solaris	      gcc				     (b) Riccardo
+#SunOS 4.1.x			     +X11 -GUI		5.1b (J) Bram Moolenaar
+#SunOS 4.1.3_U1 (sun4c) gcc	     +X11 +GUI Athena	5.0w (J) Darren Hiebert
+#SUPER-UX 6.2 (NEC SX-4) cc	     +X11R6 Motif,Athena4.6b (P) Lennart Schultz
+#Tandem/NSK						     (c) Matthew Woehlke
+#Unisys 6035	      cc	     +X11 Motif		5.3  (8) Glauber Ribeiro
+#ESIX V4.2	      cc	     +X11		6.0  (a) Reinhard Wobst
+#Mac OS X 10.[23]     gcc	     Carbon		6.2  (x) Bram Moolenaar
+# }}}
+
+# (*)  Remarks: {{{
+#
+# (1)  Uncomment line below for shlicc2
+# (2)  HPUX with compile problems or wrong digraphs, uncomment line below
+# (3)  Infomagic Motif needs GUI_LIB_LOC and GUI_INC_LOC set, see below.
+#      And add "-lXpm" to MOTIF_LIBS2.
+# (4)  For cc the optimizer must be disabled (use CFLAGS= after running
+#      configure) (symptom: ":set termcap" output looks weird).
+# (5)  Compiler may need extra argument, see below.
+# (6)  See below for a few lines to uncomment
+# (7)  See below for lines which enable the use of clcc
+# (8)  Needs some EXTRA_LIBS, search for Unisys below
+# (9)  Needs an extra compiler flag to compile gui_at_sb.c, see below.
+# (A)  May need EXTRA_LIBS, see below
+# (B)  Can't compile GUI because there is no waitpid()...  Disable GUI below.
+# (C)  Force the use of curses instead of termcap, see below.
+# (D)  Uncomment lines below for QNX
+# (E)  You might want to use termlib instead of termcap, see below.
+# (F)  See below for instructions.
+# (G)  Using ncurses version 4.2 has reported to cause a crash.  Use the
+#      Sun curses library instead.
+# (H)  See line for EXTRA_LIBS below.
+# (I)  SINIX-N 5.42 and 5.43 need some EXTRA_LIBS.  Also for Reliant-Unix.
+# (J)  If you get undefined symbols, see below for a solution.
+# (K)  See lines to uncomment below for machines with 64 bit pointers.
+# (L)  For Silicon Graphics O2 workstations remove "-lnsl" from auto/config.mk
+# (M)  gcc version cygnus-2.0.1 does NOT work (symptom: "dl" deletes two
+#      characters instead of one).
+# (N)  SCO with decmouse.
+# (O)  LynxOS needs EXTRA_LIBS, see below.
+# (P)  For SuperUX 6.2 on NEC SX-4 see a few lines below to uncomment.
+# (Q)  For UNIXSVR 4.2MP on NEC UP4800 see below for lines to uncomment.
+# (R)  For Solaris 2.5 (or 2.5.1) with gcc > 2.5.6, uncomment line below.
+# (S)  For Irix 6.x with MipsPro compiler, use -OPT:Olimit.  See line below.
+# (T)  See ../doc/os_beos.txt.
+# (U)  Must uncomment CONF_OPT_PYTHON option below to disable Python
+#      detection, since the configure script runs into an error when it
+#      detects Python (probably because of the bash shell).
+# (V)  See lines to uncomment below.
+# (X)  Need to use the .include "auto/config.mk" line below
+# (Y)  See line with c89 below
+# (Z)  See lines with cc or c89 below
+# (a)  See line with EXTRA_LIBS below.
+# (b)  When using gcc with the Solaris linker, make sure you don't use GNU
+#      strip, otherwise the binary may not run: "Cannot find ELF".
+# (c)  Add -lfloss to EXTRA_LIBS, see below.
+# (x)  When you get warnings for precompiled header files, run
+#      "sudo fixPrecomps".  Also see CONF_OPT_DARWIN below.
+# }}}
+
+
+#DO NOT CHANGE the next line, we need it for configure to find the compiler
+#instead of using the default from the "make" program.
+#Use a line further down to change the value for CC.
+CC=
+
+# Change and use these defines if configure cannot find your Motif stuff.
+# Unfortunately there is no "standard" location for Motif. {{{
+# These defines can contain a single directory (recommended) or a list of
+# directories (for when you are working with several systems). The LAST
+# directory that exists is used.
+# When changed, run "make reconfig" next!
+#GUI_INC_LOC = -I/usr/include/Motif2.0 -I/usr/include/Motif1.2
+#GUI_LIB_LOC = -L/usr/lib/Motif2.0 -L/usr/lib/Motif1.2
+### Use these two lines for Infomagic Motif (3)
+#GUI_INC_LOC = -I/usr/X11R6/include
+#GUI_LIB_LOC = -L/usr/X11R6/lib
+# }}}
+
+# Defaults used when auto/config.mk does not exist.
+srcdir = .
+VIMNAME = vim
+EXNAME = ex
+VIEWNAME = view
+
+######################## auto/config.mk ######################## {{{1
+# At this position auto/config.mk is included. When starting from the
+# toplevel Makefile it is almost empty. After running auto/configure it
+# contains settings that have been discovered for your system. Settings below
+# this include override settings in auto/config.mk!
+
+# Note: If make fails because auto/config.mk does not exist (it is not
+# included in the repository), do:
+#    cp config.mk.dist auto/config.mk
+
+# (X) How to include auto/config.mk depends on the version of "make" you have,
+#     if the current choice doesn't work, try the other one.
+
+include auto/config.mk
+#.include "auto/config.mk"
+CClink = $(CC)
+
+#}}}
+
+# Include the configuration choices first, so we can override everything
+# below. As shipped, this file contains a target that causes to run
+# configure. Once configure was run, this file contains a list of
+# make variables with predefined values instead. Thus any second invocation
+# of make, will build Vim.
+
+# CONFIGURE - configure arguments {{{1
+# You can give a lot of options to configure.
+# Change this to your desire and do 'make config' afterwards
+
+# examples (can only use one!):
+#CONF_ARGS = --exec-prefix=/usr
+#CONF_ARGS = --with-vim-name=vim7 --with-ex-name=ex7 --with-view-name=view7
+#CONF_ARGS = --with-global-runtime=/etc/vim
+#CONF_ARGS = --with-local-dir=/usr/share
+#CONF_ARGS = --without-local-dir
+
+# Use this one if you distribute a modified version of Vim.
+#CONF_ARGS = --with-modified-by="John Doe"
+
+# GUI - For creating Vim with GUI (gvim) (B)
+# Uncomment this line when you don't want to get the GUI version, although you
+# have GTK, Motif and/or Athena.  Also use --without-x if you don't want X11
+# at all.
+#CONF_OPT_GUI = --disable-gui
+
+# Uncomment one of these lines if you have that GUI but don't want to use it.
+# The automatic check will use another one that can be found.
+# Gnome is disabled by default, because it may cause trouble.
+#
+# When both GTK+ 2 and GTK+ 3 are possible then GTK+ 2 will be selected.
+# To use GTK+ 3 instead use --enable-gui=gtk3 (see below).
+#CONF_OPT_GUI = --disable-gtk2-check
+#CONF_OPT_GUI = --enable-gnome-check
+#CONF_OPT_GUI = --disable-gtk3-check
+#CONF_OPT_GUI = --disable-motif-check
+#CONF_OPT_GUI = --disable-athena-check
+#CONF_OPT_GUI = --disable-nextaw-check
+
+# Uncomment one of these lines to select a specific GUI to use.
+# When using "yes" or nothing, configure will use the first one found: GTK+,
+# Motif or Athena.
+#
+# GTK versions that are known not to work 100% are rejected.
+# Use "--disable-gtktest" to accept them anyway.
+# For GTK 1 use Vim 7.2.
+#
+# GNOME means GTK with Gnome support.  If using GTK and --enable-gnome-check
+# is used then GNOME will automatically be used if it is found.  If you have
+# GNOME, but do not want to use it (e.g., want a GTK-only version), then use
+# --enable-gui=gtk or leave out --enable-gnome-check.
+#
+# GNOME makes sense only for GTK+ 2.  Avoid use of --enable-gnome-check with
+# GTK+ 3 build, as the functionality of GNOME is already incooperated into
+# GTK+ 3.
+#
+# If the selected GUI isn't found, the GUI is disabled automatically
+#CONF_OPT_GUI = --enable-gui=gtk2
+#CONF_OPT_GUI = --enable-gui=gtk2 --disable-gtktest
+#CONF_OPT_GUI = --enable-gui=gnome2
+#CONF_OPT_GUI = --enable-gui=gnome2 --disable-gtktest
+#CONF_OPT_GUI = --enable-gui=gtk3
+#CONF_OPT_GUI = --enable-gui=gtk3 --disable-gtktest
+#CONF_OPT_GUI = --enable-gui=motif
+#CONF_OPT_GUI = --enable-gui=motif --with-motif-lib="-static -lXm -shared"
+#CONF_OPT_GUI = --enable-gui=athena
+#CONF_OPT_GUI = --enable-gui=nextaw
+
+# Carbon GUI for Mac OS X
+#CONF_OPT_GUI = --enable-gui=carbon
+
+# Uncomment this line to run an individual test with gvim.
+#GUI_TESTARG = GUI_FLAG=-g 
+
+# DARWIN - detecting Mac OS X
+# Uncomment this line when you want to compile a Unix version of Vim on
+# Darwin.  None of the Mac specific options or files will be used.
+#CONF_OPT_DARWIN = --disable-darwin
+
+# Select the architecture supported.  Default is to build for the current
+# platform.  Use "both" for a universal binary.  That probably doesn't work
+# when including Perl, Python, etc.
+#CONF_OPT_DARWIN = --with-mac-arch=i386
+#CONF_OPT_DARWIN = --with-mac-arch=ppc
+#CONF_OPT_DARWIN = --with-mac-arch=both
+
+# Uncomment the next line to fail if one of the requested language interfaces
+# cannot be configured.  Without this Vim will be build anyway, without
+# the failing interfaces.
+#CONF_OPT_FAIL = --enable-fail-if-missing
+
+# LUA
+# Uncomment one of these when you want to include the Lua interface.
+# First one is for static linking, second one for dynamic loading.
+# Use --with-luajit if you want to use LuaJIT instead of Lua.
+# Set PATH environment variable to find lua or luajit executable.
+# This requires at least "normal" features, "tiny" and "small" don't work.
+#CONF_OPT_LUA = --enable-luainterp
+#CONF_OPT_LUA = --enable-luainterp=dynamic
+#CONF_OPT_LUA = --enable-luainterp --with-luajit
+#CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit
+# Lua installation dir (when not set uses $LUA_PREFIX or defaults to /usr)
+#CONF_OPT_LUA_PREFIX = --with-lua-prefix=/usr/local
+
+# MZSCHEME
+# Uncomment this when you want to include the MzScheme interface.
+# NOTE: does not work well together with valgrind.
+#CONF_OPT_MZSCHEME = --enable-mzschemeinterp
+# PLT/mrscheme/drscheme Home dir; the PLTHOME environment variable also works
+#CONF_OPT_PLTHOME  = --with-plthome=/usr/local/plt
+#CONF_OPT_PLTHOME  = --with-plthome=/usr/local/drscheme
+#CONF_OPT_PLTHOME  = --with-plthome=/home/me/mz
+
+# PERL
+# Uncomment one of these when you want to include the Perl interface.
+# First one is for static linking, second one for dynamic loading.
+# The Perl option sometimes causes problems, because it adds extra flags
+#
+# to the command line.	If you see strange flags during compilation, check in
+# auto/config.mk where they come from.  If it's PERL_CFLAGS, try commenting
+# the next line.
+# When you get an error for a missing "perl.exp" file, try creating an empty
+# one: "touch perl.exp".
+# This requires at least "normal" features, "tiny" and "small" don't work.
+#CONF_OPT_PERL = --enable-perlinterp
+#CONF_OPT_PERL = --enable-perlinterp=dynamic
+
+# PYTHON
+# Uncomment lines here when you want to include the Python interface.
+# This requires at least "normal" features, "tiny" and "small" don't work.
+# NOTE: This may cause threading to be enabled, which has side effects (such
+# as using different libraries and debugging becomes more difficult).
+# For Python3 support make a symbolic link in /usr/local/bin:
+#	ln -s python3 python3.1
+# If both python2.x and python3.x are enabled then the linking will be via
+# dlopen(), dlsym(), dlclose(), i.e. pythonX.Y.so must be available
+# However, this may still cause problems, such as "import termios" failing.
+# Build two separate versions of Vim in that case.
+#CONF_OPT_PYTHON = --enable-pythoninterp
+#CONF_OPT_PYTHON = --enable-pythoninterp --with-python-command=python2.7
+#CONF_OPT_PYTHON = --enable-pythoninterp=dynamic
+#CONF_OPT_PYTHON3 = --enable-python3interp
+#CONF_OPT_PYTHON3 = --enable-python3interp --with-python3-command=python3.6
+#CONF_OPT_PYTHON3 = --enable-python3interp=dynamic
+
+# RUBY
+# Uncomment this when you want to include the Ruby interface.
+# First one for static linking, second one for loading when used.
+# Note: you need the development package (e.g., ruby1.9.1-dev on Ubuntu).
+# This requires at least "normal" features, "tiny" and "small" don't work.
+#CONF_OPT_RUBY = --enable-rubyinterp
+#CONF_OPT_RUBY = --enable-rubyinterp=dynamic
+#CONF_OPT_RUBY = --enable-rubyinterp --with-ruby-command=ruby1.9.1
+
+# TCL
+# Uncomment this when you want to include the Tcl interface.
+# First one is for static linking, second one for dynamic loading.
+#CONF_OPT_TCL = --enable-tclinterp
+#CONF_OPT_TCL = --enable-tclinterp=dynamic
+#CONF_OPT_TCL = --enable-tclinterp --with-tclsh=tclsh8.4
+
+# CSCOPE
+# Uncomment this when you want to include the Cscope interface.
+#CONF_OPT_CSCOPE = --enable-cscope
+
+# WORKSHOP - Sun Visual Workshop interface.  Only works with Motif!
+#CONF_OPT_WORKSHOP = --enable-workshop
+
+# NETBEANS - NetBeans interface. Only works with Motif, GTK, and gnome.
+# Motif version must have XPM libraries (see |workshop-xpm|).
+# Uncomment this when you do not want the netbeans interface.
+#CONF_OPT_NETBEANS = --disable-netbeans
+
+# CHANNEL - inter process communication. Same conditions as NetBeans.
+# Uncomment this when you do not want inter process communication.
+#CONF_OPT_CHANNEL = --disable-channel
+
+# TERMINAL - Terminal emulator support, :terminal command.  Requires the
+# channel feature. The default is enable for when using "huge" features.
+# Uncomment the first line when you want terminal emulator support for
+# not-huge builds.  Uncomment the second line when you don't want terminal
+# emulator support in the huge build.
+#CONF_OPT_TERMINAL = --enable-terminal
+#CONF_OPT_TERMINAL = --disable-terminal
+
+# MULTIBYTE - To edit multi-byte characters.
+# Uncomment this when you want to edit a multibyte language.
+# It's automatically enabled with normal features, GTK or IME support.
+# Note: Compile on a machine where setlocale() actually works, otherwise the
+# configure tests may fail.
+#CONF_OPT_MULTIBYTE = --enable-multibyte
+
+# NLS - National Language Support
+# Uncomment this when you do not want to support translated messages, even
+# though configure can find support for it.
+#CONF_OPT_NLS = --disable-nls
+
+# XIM - X Input Method.  Special character input support for X11 (Chinese,
+# Japanese, special symbols, etc).  Also needed for dead-key support.
+# When omitted it's automatically enabled for the X-windows GUI.
+# HANGUL - Input Hangul (Korean) language using internal routines.
+# Uncomment one of these when you want to input a multibyte language.
+#CONF_OPT_INPUT = --enable-xim
+#CONF_OPT_INPUT = --disable-xim
+#CONF_OPT_INPUT = --enable-hangulinput
+
+# FONTSET - X fontset support for output of languages with many characters.
+# Uncomment this when you want to output a multibyte language.
+#CONF_OPT_OUTPUT = --enable-fontset
+
+# ACL - Uncomment this when you do not want to include ACL support, even
+# though your system does support it.  E.g., when it's buggy.
+#CONF_OPT_ACL = --disable-acl
+
+# gpm - For mouse support on Linux console via gpm
+# Uncomment this when you do not want to include gpm support, even
+# though you have gpm libraries and includes.
+#CONF_OPT_GPM = --disable-gpm
+
+# sysmouse - For mouse support on FreeBSD and DragonFly console via sysmouse
+# Uncomment this when you do not want do include sysmouse support, even
+# though you have /dev/sysmouse and includes.
+#CONF_OPT_SYSMOUSE = --disable-sysmouse
+
+# FEATURES - For creating Vim with more or less features
+# Uncomment one of these lines when you want to include few to many features.
+# The default is "huge" for most systems.
+#CONF_OPT_FEAT = --with-features=tiny
+#CONF_OPT_FEAT = --with-features=small
+#CONF_OPT_FEAT = --with-features=normal
+#CONF_OPT_FEAT = --with-features=big
+#CONF_OPT_FEAT = --with-features=huge
+
+# COMPILED BY - For including a specific e-mail address for ":version".
+#CONF_OPT_COMPBY = "--with-compiledby=John Doe <JohnDoe@yahoo.com>"
+
+# X WINDOWS DISABLE - For creating a plain Vim without any X11 related fancies
+# (otherwise Vim configure will try to include xterm titlebar access)
+# Also disable the GUI above, otherwise it will be included anyway.
+# When both GUI and X11 have been disabled this may save about 15% of the
+# code and make Vim startup quicker.
+#CONF_OPT_X = --without-x
+
+# X WINDOWS DIRECTORY - specify X directories
+# If configure can't find you X stuff, or if you have multiple X11 derivatives
+# installed, you may wish to specify which one to use.
+# Select nothing to let configure choose.
+# This here selects openwin (as found on sun).
+#XROOT = /usr/openwin
+#CONF_OPT_X = --x-include=$(XROOT)/include --x-libraries=$(XROOT)/lib
+
+# X11 Session Management Protocol support
+# Vim will try to use XSMP to catch the user logging out if there are unsaved
+# files.  Uncomment this line to disable that (it prevents vim trying to open
+# communications with the session manager).
+#CONF_OPT_XSMP = --disable-xsmp
+
+# You may wish to include xsmp but use exclude xsmp-interact if the logout
+# XSMP functionality does not work well with your session-manager (at time of
+# writing, this would be early GNOME-1 gnome-session: it 'freezes' other
+# applications after Vim has cancelled a logout (until Vim quits).  This
+# *might* be the Vim code, but is more likely a bug in early GNOME-1.
+# This disables the dialog that asks you if you want to save files or not.
+#CONF_OPT_XSMP = --disable-xsmp-interact
+
+# If you want to always automatically add a servername, also in the terminal.
+#CONF_OPT_AUTOSERVE = --enable-autoservername
+
+# COMPILER - Name of the compiler {{{1
+# The default from configure will mostly be fine, no need to change this, just
+# an example. If a compiler is defined here, configure will use it rather than
+# probing for one. It is dangerous to change this after configure was run.
+# Make will use your choice then -- but beware: Many things may change with
+# another compiler.  It is wise to run 'make reconfig' to start all over
+# again.
+#CC = cc
+#CC = gcc
+#CC = clang
+
+# COMPILER FLAGS - change as you please. Either before running {{{1
+# configure or afterwards. For examples see below.
+# When using -g with some older versions of Linux you might get a
+# statically linked executable.
+# When not defined, configure will try to use -O2 -g for gcc and -O for cc.
+#CFLAGS = -g
+#CFLAGS = -O
+
+# Optimization limits - depends on the compiler.  Automatic check in configure
+# doesn't work very well, because many compilers only give a warning for
+# unrecognized arguments.
+#CFLAGS = -O -OPT:Olimit=2600
+#CFLAGS = -O -Olimit 2000
+#CFLAGS = -O -FOlimit,2000
+
+# Often used for GCC: mixed optimizing, lot of optimizing, debugging
+#CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes
+#CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wmissing-prototypes
+#CFLAGS = -g -Wall -Wmissing-prototypes
+#CFLAGS = -O6 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes
+#CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes
+#CFLAGS = -g -O2 '-DSTARTUPTIME="vimstartup"' -fno-strength-reduce -Wall -Wmissing-prototypes
+
+# Use this with GCC to check for mistakes, unused arguments, etc.
+#CFLAGS = -g -Wall -Wextra -Wshadow -Wmissing-prototypes -Wunreachable-code -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1
+# Add -Wpedantic to find // comments and other C99 constructs.
+# Better disable Perl and Python to avoid a lot of warnings.
+#CFLAGS = -g -Wall -Wextra -Wshadow -Wmissing-prototypes -Wpedantic -Wunreachable-code -Wunused-result -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1
+#CFLAGS = -g -O2 -Wall -Wextra -Wshadow -Wmissing-prototypes -Wpedantic -Wunreachable-code -Wunused-result -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1
+#PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
+#MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter
+
+# EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
+# allocated memory (and makes every malloc()/free() very slow).
+# Electric Fence is free (search ftp sites).
+# You may want to set the EF_PROTECT_BELOW environment variable to check the
+# other side of allocated memory.
+# On FreeBSD you might need to enlarge the number of mmaps allowed.  Do this
+# as root: sysctl -w vm.max_proc_mmap=30000
+#EXTRA_LIBS = /usr/local/lib/libefence.a
+
+# Autoconf binary.
+AUTOCONF = autoconf
+
+# PURIFY - remove the # to use the "purify" program (hoi Nia++!)
+#PURIFY = purify
+
+# VALGRIND - remove the # to use valgrind for memory leaks and access errors.
+#	     Used for the unittest targets.
+# VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=25 --log-file=valgrind.$@
+
+# NBDEBUG - debugging the netbeans interface.
+#EXTRA_DEFS = -DNBDEBUG
+
+# }}}
+
+# LINT - for running lint
+#  For standard Unix lint
+LINT = lint
+LINT_OPTIONS = -beprxzF
+#  For splint
+#  It doesn't work well, crashes on include files and non-ascii characters.
+#LINT = splint
+#LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999
+
+# PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
+# Might not work with GUI or Perl.
+# After running Vim see the profile result with: gprof vim gmon.out | vim -
+# Need to recompile everything after changing this: "make clean" "make".
+#PROFILE_CFLAGS = -pg -g -DWE_ARE_PROFILING
+#PROFILE_LIBS = -pg
+
+# GCC 5 and later need the -no-pie argument.
+#PROFILE_LIBS = -pg -no-pie
+
+# For unknown reasons adding "-lc" fixes a linking problem with some versions
+# of GCC.  That's probably a bug in the "-pg" implementation.
+#PROFILE_LIBS = -pg -lc
+
+
+# TEST COVERAGE - Uncomment the two lines below the explanation to get code
+# coverage information. (provided by Yegappan Lakshmanan)
+# 1. make clean, run configure and build Vim as usual.
+# 2. Generate the baseline code coverage information:
+#	$ lcov -c -i -b . -d objects -o objects/coverage_base.info
+# 3. Run "make test" to run the unit tests.  The code coverage information will
+#    be generated in the src/objects directory.
+# 4. Generate the code coverage information from the tests:
+#	$ lcov -c -b . -d objects/ -o objects/coverage_test.info
+# 5. Combine the baseline and test code coverage data:
+#	$ lcov -a objects/coverage_base.info -a objects/coverage_test.info -o objects/coverage_total.info
+# 6. Process the test coverage data and generate a report in html:
+#	$ genhtml objects/coverage_total.info -o objects
+# 7. Open the objects/index.html file in a web browser to view the coverage
+#    information.
+#
+# PROFILE_CFLAGS=-g -O0 -fprofile-arcs -ftest-coverage
+# LDFLAGS=--coverage
+
+
+# Uncomment one of the next two lines to compile Vim with the
+# address sanitizer or with the undefined sanitizer.  Works with gcc and
+# clang.  May make Vim twice as slow.  Errors reported on stderr.
+# More at: https://code.google.com/p/address-sanitizer/
+#SANITIZER_CFLAGS = -g -O0 -fsanitize=address -fno-omit-frame-pointer
+#SANITIZER_CFLAGS = -g -O0 -fsanitize=undefined -fno-omit-frame-pointer
+SANITIZER_LIBS = $(SANITIZER_CFLAGS)
+
+# MEMORY LEAK DETECTION
+# Requires installing the ccmalloc library.
+# Configuration is in the .ccmalloc or ~/.ccmalloc file.
+# Doesn't work very well, since memory linked to from global variables
+# (in libraries) is also marked as leaked memory.
+#LEAK_CFLAGS = -DEXITFREE
+#LEAK_LIBS = -lccmalloc
+
+# Uncomment this line to have Vim call abort() when an internal error is
+# detected.  Useful when using a tool to find errors.
+#ABORT_CLFAGS = -DABORT_ON_INTERNAL_ERROR
+
+#####################################################
+###  Specific systems, check if yours is listed!  ### {{{
+#####################################################
+
+### Uncomment things here only if the values chosen by configure are wrong.
+### It's better to adjust configure.ac and "make autoconf", if you can!
+### Then send the required changes to configure.ac to the bugs list.
+
+### (1) BSD/OS 2.0.1, 2.1 or 3.0 using shared libraries
+###
+#CC = shlicc2
+#CFLAGS = -O2 -g -m486 -Wall -Wshadow -Wmissing-prototypes -fno-builtin
+
+### (2) HP-UX with a non-ANSI cc, use the c89 ANSI compiler
+###	The first probably works on all systems
+###	The second should work a bit better on newer systems
+###	The third should work a bit better on HPUX 11.11
+###	Information provided by: Richard Allen <ra@rhi.hi.is>
+#CC = c89 -D_HPUX_SOURCE
+#CC = c89 -O +Onolimit +ESlit -D_HPUX_SOURCE
+#CC = c89 -O +Onolimit +ESlit +e -D_HPUX_SOURCE
+
+### (2) For HP-UX: Enable the use of a different set of digraphs.  Use this
+###	when the default (ISO) digraphs look completely wrong.
+###	After changing this do "touch digraph.c; make".
+#EXTRA_DEFS = -DHPUX_DIGRAPHS
+
+### (2) For HP-UX: 9.04 cpp default macro definition table of 128000 bytes
+###	is too small to compile many routines.	It produces too much defining
+###	and no space errors.
+###	Uncomment the following to specify a larger macro definition table.
+#CFLAGS = -Wp,-H256000
+
+### (2) For HP-UX 10.20 using the HP cc, with X11R6 and Motif 1.2, with
+###	libraries in /usr/lib instead of /lib (avoiding transition links).
+###	Information provided by: David Green
+#XROOT = /usr
+#CONF_OPT_X = --x-include=$(XROOT)/include/X11R6 --x-libraries=$(XROOT)/lib/X11R6
+#GUI_INC_LOC = -I/usr/include/Motif1.2
+#GUI_LIB_LOC = -L/usr/lib/Motif1.2_R6
+
+### (5) AIX 4.1.4 with cc
+#CFLAGS = -O -qmaxmem=8192
+
+###     AIX with c89 (Walter Briscoe)
+#CC = c89
+#CPPFLAGS = -D_ALL_SOURCE
+
+###     AIX 4.3.3.12 with xic 3.6.6 (David R. Favor)
+#       needed to avoid a problem where strings.h gets included
+#CFLAGS = -qsrcmsg -O2 -qmaxmem=8192 -D__STR31__
+
+### (W) Solaris with multi-threaded libraries (-lthread):
+###	If suspending doesn't work properly, try using this line:
+#EXTRA_DEFS = -D_REENTRANT
+
+### (7) Solaris 2.4/2.5 with Centerline compiler
+#CC = clcc
+#X_LIBS_DIR = -L/usr/openwin/lib -R/usr/openwin/lib
+#CFLAGS = -O
+
+### (9) Solaris 2.x with cc (SunPro), using Athena.
+###	Only required for compiling gui_at_sb.c.
+###	Symptom: "identifier redeclared: vim_XawScrollbarSetThumb"
+###	Use one of the lines (either Full ANSI or no ANSI at all)
+#CFLAGS = $(CFLAGS) -Xc
+#CFLAGS = $(CFLAGS) -Xs
+
+### Solaris 2.3 with X11 and specific cc
+#CC=/opt/SUNWspro/bin/cc -O -Xa -v -R/usr/openwin/lib
+
+### Solaris with /usr/ucb/cc (it is rejected by autoconf as "cc")
+#CC	    = /usr/ucb/cc
+#EXTRA_LIBS = -R/usr/ucblib
+
+### Solaris with Forte Developer and FEAT_SUN_WORKSHOP
+# The Xpm library is available from http://koala.ilog.fr/ftp/pub/xpm.
+#CC		= cc
+#XPM_DIR		= /usr/local/xpm/xpm-3.4k-solaris
+#XPM_LIB		= -L$(XPM_DIR)/lib -R$(XPM_DIR)/lib -lXpm
+#XPM_IPATH	= -I$(XPM_DIR)/include
+#EXTRA_LIBS	= $(XPM_LIB)
+#EXTRA_IPATHS	= $(XPM_IPATH)
+#EXTRA_DEFS	= -xCC -DHAVE_X11_XPM_H
+
+### Solaris with workshop compilers: Vim is unstable when compiled with
+# "-fast".  Use this instead. (Shea Martin)
+#CFLAGS = -x02 -xtarget=ultra
+
+### (R) for Solaris 2.5 (or 2.5.1) with gcc > 2.5.6 you might need this:
+#LDFLAGS = -lw -ldl -lXmu
+#GUI_LIB_LOC = -L/usr/local/lib
+
+### (8) Unisys 6035 (Glauber Ribeiro)
+#EXTRA_LIBS = -lnsl -lsocket -lgen
+
+### When builtin functions cause problems with gcc (for Sun 4.1.x)
+#CFLAGS = -O2 -Wall -traditional -Wno-implicit
+
+### Apollo DOMAIN (with SYSTYPE = bsd4.3) (TESTED for version 3.0)
+#EXTRA_DEFS = -DDOMAIN
+#CFLAGS= -O -A systype,bsd4.3
+
+### Coherent 4.2.10 on Intel 386 platform
+#EXTRA_DEFS = -Dvoid=int
+#EXTRA_LIBS = -lterm -lsocket
+
+### SCO 3.2, with different library name for terminfo
+#EXTRA_LIBS = -ltinfo
+
+### UTS2 for Amdahl UTS 2.1.x
+#EXTRA_DEFS = -DUTS2
+#EXTRA_LIBS = -lsocket
+
+### UTS4 for Amdahl UTS 4.x
+#EXTRA_DEFS = -DUTS4 -Xa
+
+### USL for Unix Systems Laboratories (SYSV 4.2)
+#EXTRA_DEFS = -DUSL
+
+### (6)  A/UX 3.1.1 with gcc (Jim Jagielski)
+#CC= gcc -D_POSIX_SOURCE
+#CFLAGS= -O2
+#EXTRA_LIBS = -lposix -lbsd -ltermcap -lX11
+
+### (A)  Some versions of SCO Open Server 5 (Jan Christiaan van Winkel)
+###	 Also use the CONF_TERM_LIB below!
+#EXTRA_LIBS = -lgen
+
+### (D)  QNX (by G.F. Desrochers)
+#CFLAGS = -g -O -mf -4
+
+### (F)  QNX (by John Oleynick)
+# 1. If you don't have an X server: Comment out CONF_OPT_GUI and uncomment
+#    CONF_OPT_X = --without-x.
+# 2. make config
+# 3. edit auto/config.mk and remove -ldir and -ltermcap from LIBS.  It doesn't
+#	have -ldir (does config find it somewhere?) and -ltermcap has at
+#	least one problem so I use termlib.o instead.  The problem with
+#	termcap is that it segfaults if you call it with the name of
+#	a non-existent terminal type.
+# 4. edit auto/config.h and add #define USE_TMPNAM
+# 5. add termlib.o to OBJ
+# 6. make
+
+### (H)  for Data general DG/UX 5.4.2 and 5.4R3.10 (Jonas J. Schlein)
+#EXTRA_LIBS = -lgen
+
+### (I) SINIX-N 5.42 or 5.43 RM400 R4000 (also SINIX-Y and SINIX-Z)
+#EXTRA_LIBS = -lgen -lnsl
+###   For SINIX-Y this is needed for the right prototype of gettimeofday()
+#EXTRA_DEFS = -D_XPG_IV
+
+### (I) Reliant-Unix (aka SINIX) 5.44 with standard cc
+#	Use both "-F O3" lines for optimization or the "-g" line for debugging
+#EXTRA_LIBS = -lgen -lsocket -lnsl -lSM -lICE
+#CFLAGS = -F O3 -DSINIXN
+#LDFLAGS = -F O3
+#CFLAGS = -g -DSINIXN
+
+### (P)  SCO 3.2.42, with different termcap names for some useful keys DJB
+#EXTRA_DEFS = -DSCOKEYS -DNETTERM_MOUSE -DDEC_MOUSE -DXTERM_MOUSE -DHAVE_GETTIMEOFDAY
+#EXTRA_LIBS = -lsocket -ltermcap -lmalloc -lc_s
+
+### (P)  SuperUX 6.2 on NEC SX-4 (Lennart Schultz)
+#GUI_INC_LOC = -I/usr/include
+#GUI_LIB_LOC = -L/usr/lib
+#EXTRA_LIBS = -lgen
+
+### (Q) UNIXSVR 4.2MP on NEC UP4800 (Lennart Schultz)
+#GUI_INC_LOC = -I/usr/necccs/include
+#GUI_LIB_LOC = -L/usr/necccs/lib/X11R6
+#XROOT = /usr/necccs
+#CONF_OPT_X = --x-include=$(XROOT)/include --x-libraries=$(XROOT)/lib/X11R6
+#EXTRA_LIBS = -lsocket -lgen
+
+### Irix 4.0 & 5.2 (Silicon Graphics Machines, __sgi will be defined)
+# Not needed for Irix 5.3, Ives Aerts reported
+#EXTRA_LIBS = -lmalloc -lc_s
+# Irix 4.0, when regexp and regcmp cannot be found when linking:
+#EXTRA_LIBS = -lmalloc -lc_s -lPW
+
+### (S) Irix 6.x (MipsPro compiler): Uses different Olimit flag:
+# Note:	This newer option style is used with the MipsPro compilers ONLY if
+#	you are compiling an "n32" or "64" ABI binary (use either a -n32
+#	flag or a -64 flag for CFLAGS).  If you explicitly use a -o32 flag,
+#	then the CFLAGS option format will be the typical style (i.e.
+#	-Olimit 3000).
+#CFLAGS = -OPT:Olimit=3000 -O
+
+### (S) Irix 6.5 with MipsPro C compiler.  Try this as a test to see new
+#	compiler features!  Beware, the optimization is EXTREMELY thorough
+#	and takes quite a long time.
+# Note: See the note above.  Here, the -mips3 option automatically
+#	enables either the "n32" or "64" ABI, depending on what machine you
+#	are compiling on (n32 is explicitly enabled here, just to make sure).
+#CFLAGS = -OPT:Olimit=3500 -O -n32 -mips3 -IPA:aggr_cprop=ON -INLINE:dfe=ON:list=ON:must=screen_char,out_char,ui_write,out_flush
+#LDFLAGS= -OPT:Olimit=3500 -O -n32 -mips3 -IPA:aggr_cprop=ON -INLINE:dfe=ON:list=ON:must=screen_char,out_char,ui_write,out_flush
+
+### (K) for SGI Irix machines with 64 bit pointers ("uname -s" says IRIX64)
+###	Suggested by Jon Wright <jon@gate.sinica.edu.tw>.
+###	Tested on R8000 IRIX6.1 Power Indigo2.
+###	Check /etc/compiler.defaults for your compiler settings.
+# either (for 64 bit pointers) uncomment the following line
+#GUI_LIB_LOC = -L/usr/lib64
+# then
+# 1) make config
+# 2) edit auto/config.mk and delete the -lelf entry in the LIBS line
+# 3) make
+#
+# or (for 32bit pointers) uncomment the following line
+#EXTRA_DEFS = -n32
+#GUI_LIB_LOC = -L/usr/lib32
+# then
+# 1) make config
+# 2) edit auto/config.mk, add -n32 to LDFLAGS
+# 3) make
+#
+#Alternatively: use -o32 instead of -n32.
+###
+
+### (C)  On SCO Unix v3.2.5 (and probably other versions) the termcap library,
+###	 which is found by configure, doesn't work correctly.  Symptom is the
+###	 error message "Termcap entry too long".  Uncomment the next line.
+###	 On AIX 4.2.1 (and other versions probably), libtermcap is reported
+###	 not to display properly.
+### after changing this, you need to do "make reconfig".
+#CONF_TERM_LIB = --with-tlib=curses
+
+### (E)  If you want to use termlib library instead of the automatically found
+###	 one.  After changing this, you need to do "make reconfig".
+#CONF_TERM_LIB = --with-tlib=termlib
+
+### (a)  ESIX V4.2 (Reinhard Wobst)
+#EXTRA_LIBS = -lnsl -lsocket -lgen -lXIM -lXmu -lXext
+
+### (c)  Tandem/NSK (Matthew Woehlke)
+#EXTRA_LIBS = -lfloss
+
+### If you want to use ncurses library instead of the automatically found one
+### after changing this, you need to do "make reconfig".
+#CONF_TERM_LIB = --with-tlib=ncurses
+
+### For GCC on MS-Windows, the ".exe" suffix will be added.
+#EXEEXT = .exe
+#LNKEXT = .exe
+
+### (O)  For LynxOS 2.5.0, tested on PC.
+#EXTRA_LIBS = -lXext -lSM -lICE -lbsd
+###	 For LynxOS 3.0.1, tested on PPC
+#EXTRA_LIBS= -lXext -lSM -lICE -lnetinet -lXmu -liberty -lX11
+###	 For LynxOS 3.1.0, tested on PC
+#EXTRA_LIBS= -lXext -lSM -lICE -lnetinet -lXmu
+
+
+### (V)  For CX/UX 6.2	(on Harris/Concurrent NightHawk 4800, 5800). Remove
+###	 -Qtarget if only in a 5800 environment.  (Kipp E. Howard)
+#CFLAGS = -O -Qtarget=m88110compat
+#EXTRA_LIBS = -lgen
+
+# The value of QUOTESED comes from auto/config.mk.
+# Uncomment the next line to use the default value.
+# QUOTESED = sed -e 's/[\\"]/\\&/g' -e 's/\\"/"/' -e 's/\\";$$/";/'
+
+##################### end of system specific lines ################### }}}
+
+### Names of the programs and targets  {{{1
+VIMTARGET	= $(VIMNAME)$(EXEEXT)
+EXTARGET	= $(EXNAME)$(LNKEXT)
+VIEWTARGET	= $(VIEWNAME)$(LNKEXT)
+GVIMNAME	= g$(VIMNAME)
+GVIMTARGET	= $(GVIMNAME)$(LNKEXT)
+GVIEWNAME	= g$(VIEWNAME)
+GVIEWTARGET	= $(GVIEWNAME)$(LNKEXT)
+RVIMNAME	= r$(VIMNAME)
+RVIMTARGET	= $(RVIMNAME)$(LNKEXT)
+RVIEWNAME	= r$(VIEWNAME)
+RVIEWTARGET	= $(RVIEWNAME)$(LNKEXT)
+RGVIMNAME	= r$(GVIMNAME)
+RGVIMTARGET	= $(RGVIMNAME)$(LNKEXT)
+RGVIEWNAME	= r$(GVIEWNAME)
+RGVIEWTARGET	= $(RGVIEWNAME)$(LNKEXT)
+VIMDIFFNAME	= $(VIMNAME)diff
+GVIMDIFFNAME	= g$(VIMDIFFNAME)
+VIMDIFFTARGET	= $(VIMDIFFNAME)$(LNKEXT)
+GVIMDIFFTARGET	= $(GVIMDIFFNAME)$(LNKEXT)
+EVIMNAME	= e$(VIMNAME)
+EVIMTARGET	= $(EVIMNAME)$(LNKEXT)
+EVIEWNAME	= e$(VIEWNAME)
+EVIEWTARGET	= $(EVIEWNAME)$(LNKEXT)
+
+### Names of the tools that are also made  {{{1
+TOOLS = xxd/xxd$(EXEEXT)
+
+### Installation directories.  The defaults come from configure. {{{1
+#
+### prefix	the top directory for the data (default "/usr/local")
+#
+# Uncomment the next line to install Vim in your home directory.
+#prefix = $(HOME)
+
+### exec_prefix	is the top directory for the executable (default $(prefix))
+#
+# Uncomment the next line to install the Vim executable in "/usr/machine/bin"
+#exec_prefix = /usr/machine
+
+### BINDIR	dir for the executable	 (default "$(exec_prefix)/bin")
+### MANDIR	dir for the manual pages (default "$(prefix)/man")
+### DATADIR	dir for the other files  (default "$(prefix)/lib" or
+#						  "$(prefix)/share")
+# They may be different when using different architectures for the
+# executable and a common directory for the other files.
+#
+# Uncomment the next line to install Vim in "/usr/bin"
+#BINDIR   = /usr/bin
+# Uncomment the next line to install Vim manuals in "/usr/share/man/man1"
+#MANDIR   = /usr/share/man
+# Uncomment the next line to install Vim help files in "/usr/share/vim"
+#DATADIR  = /usr/share
+
+### DESTDIR	root of the installation tree.  This is prepended to the other
+#		directories.  This directory must exist.
+#DESTDIR  = ~/pkg/vim
+
+### Directory of the man pages
+MAN1DIR = /man1
+
+### Vim version (adjusted by a script)
+VIMMAJOR = 8
+VIMMINOR = 1
+
+### Location of Vim files (should not need to be changed, and  {{{1
+### some things might not work when they are changed!)
+VIMDIR = /vim
+VIMRTDIR = /vim$(VIMMAJOR)$(VIMMINOR)
+HELPSUBDIR = /doc
+COLSUBDIR = /colors
+SYNSUBDIR = /syntax
+INDSUBDIR = /indent
+AUTOSUBDIR = /autoload
+PLUGSUBDIR = /plugin
+FTPLUGSUBDIR = /ftplugin
+LANGSUBDIR = /lang
+COMPSUBDIR = /compiler
+KMAPSUBDIR = /keymap
+MACROSUBDIR = /macros
+PACKSUBDIR = /pack
+TOOLSSUBDIR = /tools
+TUTORSUBDIR = /tutor
+SPELLSUBDIR = /spell
+PRINTSUBDIR = /print
+PODIR = po
+
+### VIMLOC	common root of the Vim files (all versions)
+### VIMRTLOC	common root of the runtime Vim files (this version)
+### VIMRCLOC	compiled-in location for global [g]vimrc files (all versions)
+### VIMRUNTIMEDIR  compiled-in location for runtime files (optional)
+### HELPSUBLOC	location for help files
+### COLSUBLOC	location for colorscheme files
+### SYNSUBLOC	location for syntax files
+### INDSUBLOC	location for indent files
+### AUTOSUBLOC	location for standard autoload files
+### PLUGSUBLOC	location for standard plugin files
+### FTPLUGSUBLOC  location for ftplugin files
+### LANGSUBLOC	location for language files
+### COMPSUBLOC	location for compiler files
+### KMAPSUBLOC	location for keymap files
+### MACROSUBLOC	location for macro files
+### PACKSUBLOC	location for packages
+### TOOLSSUBLOC	location for tools files
+### TUTORSUBLOC	location for tutor files
+### SPELLSUBLOC	location for spell files
+### PRINTSUBLOC	location for PostScript files (prolog, latin1, ..)
+### SCRIPTLOC	location for script files (menu.vim, bugreport.vim, ..)
+### You can override these if you want to install them somewhere else.
+### Edit feature.h for compile-time settings.
+VIMLOC		= $(DATADIR)$(VIMDIR)
+VIMRTLOC	= $(DATADIR)$(VIMDIR)$(VIMRTDIR)
+VIMRCLOC	= $(VIMLOC)
+HELPSUBLOC	= $(VIMRTLOC)$(HELPSUBDIR)
+COLSUBLOC	= $(VIMRTLOC)$(COLSUBDIR)
+SYNSUBLOC	= $(VIMRTLOC)$(SYNSUBDIR)
+INDSUBLOC	= $(VIMRTLOC)$(INDSUBDIR)
+AUTOSUBLOC	= $(VIMRTLOC)$(AUTOSUBDIR)
+PLUGSUBLOC	= $(VIMRTLOC)$(PLUGSUBDIR)
+FTPLUGSUBLOC	= $(VIMRTLOC)$(FTPLUGSUBDIR)
+LANGSUBLOC	= $(VIMRTLOC)$(LANGSUBDIR)
+COMPSUBLOC	= $(VIMRTLOC)$(COMPSUBDIR)
+KMAPSUBLOC	= $(VIMRTLOC)$(KMAPSUBDIR)
+MACROSUBLOC	= $(VIMRTLOC)$(MACROSUBDIR)
+PACKSUBLOC	= $(VIMRTLOC)$(PACKSUBDIR)
+TOOLSSUBLOC	= $(VIMRTLOC)$(TOOLSSUBDIR)
+TUTORSUBLOC	= $(VIMRTLOC)$(TUTORSUBDIR)
+SPELLSUBLOC	= $(VIMRTLOC)$(SPELLSUBDIR)
+PRINTSUBLOC	= $(VIMRTLOC)$(PRINTSUBDIR)
+SCRIPTLOC	= $(VIMRTLOC)
+
+### Only set VIMRUNTIMEDIR when VIMRTLOC is set to a different location and
+### the runtime directory is not below it.
+#VIMRUNTIMEDIR = $(VIMRTLOC)
+
+### Name of the defaults/evim/mswin file target.
+VIM_DEFAULTS_FILE = $(DESTDIR)$(SCRIPTLOC)/defaults.vim
+EVIM_FILE	= $(DESTDIR)$(SCRIPTLOC)/evim.vim
+MSWIN_FILE	= $(DESTDIR)$(SCRIPTLOC)/mswin.vim
+
+### Name of the menu file target.
+SYS_MENU_FILE	= $(DESTDIR)$(SCRIPTLOC)/menu.vim
+SYS_SYNMENU_FILE = $(DESTDIR)$(SCRIPTLOC)/synmenu.vim
+SYS_DELMENU_FILE = $(DESTDIR)$(SCRIPTLOC)/delmenu.vim
+
+### Name of the bugreport file target.
+SYS_BUGR_FILE	= $(DESTDIR)$(SCRIPTLOC)/bugreport.vim
+
+### Name of the rgb.txt file target.
+SYS_RGB_FILE   = $(DESTDIR)$(SCRIPTLOC)/rgb.txt
+
+### Name of the file type detection file target.
+SYS_FILETYPE_FILE = $(DESTDIR)$(SCRIPTLOC)/filetype.vim
+
+### Name of the file type detection file target.
+SYS_FTOFF_FILE	= $(DESTDIR)$(SCRIPTLOC)/ftoff.vim
+
+### Name of the file type detection script file target.
+SYS_SCRIPTS_FILE = $(DESTDIR)$(SCRIPTLOC)/scripts.vim
+
+### Name of the ftplugin-on file target.
+SYS_FTPLUGIN_FILE = $(DESTDIR)$(SCRIPTLOC)/ftplugin.vim
+
+### Name of the ftplugin-off file target.
+SYS_FTPLUGOF_FILE = $(DESTDIR)$(SCRIPTLOC)/ftplugof.vim
+
+### Name of the indent-on file target.
+SYS_INDENT_FILE = $(DESTDIR)$(SCRIPTLOC)/indent.vim
+
+### Name of the indent-off file target.
+SYS_INDOFF_FILE = $(DESTDIR)$(SCRIPTLOC)/indoff.vim
+
+### Name of the option window script file target.
+SYS_OPTWIN_FILE = $(DESTDIR)$(SCRIPTLOC)/optwin.vim
+
+# Program to install the program in the target directory.  Could also be "mv".
+INSTALL_PROG	= cp
+
+# Program to install the data in the target directory.	Cannot be "mv"!
+INSTALL_DATA	= cp
+INSTALL_DATA_R	= cp -r
+
+### Program to run on installed binary.  Use the second one to disable strip.
+#STRIP = strip
+#STRIP = /bin/true
+
+### Permissions for binaries  {{{1
+BINMOD = 755
+
+### Permissions for man page
+MANMOD = 644
+
+### Permissions for help files
+HELPMOD = 644
+
+### Permissions for Perl and shell scripts
+SCRIPTMOD = 755
+
+### Permission for Vim script files (menu.vim, bugreport.vim, ..)
+VIMSCRIPTMOD = 644
+
+### Permissions for all directories that are created
+DIRMOD = 755
+
+### Permissions for all other files that are created
+FILEMOD = 644
+
+# Where to copy the man and help files from
+HELPSOURCE = ../runtime/doc
+
+# Where to copy the script files from (menu, bugreport)
+SCRIPTSOURCE = ../runtime
+
+# Where to copy the colorscheme files from
+COLSOURCE = ../runtime/colors
+
+# Where to copy the syntax files from
+SYNSOURCE = ../runtime/syntax
+
+# Where to copy the indent files from
+INDSOURCE = ../runtime/indent
+
+# Where to copy the standard plugin files from
+AUTOSOURCE = ../runtime/autoload
+
+# Where to copy the standard plugin files from
+PLUGSOURCE = ../runtime/plugin
+
+# Where to copy the ftplugin files from
+FTPLUGSOURCE = ../runtime/ftplugin
+
+# Where to copy the macro files from
+MACROSOURCE = ../runtime/macros
+
+# Where to copy the package files from
+PACKSOURCE = ../runtime/pack
+
+# Where to copy the tools files from
+TOOLSSOURCE = ../runtime/tools
+
+# Where to copy the tutor files from
+TUTORSOURCE = ../runtime/tutor
+
+# Where to copy the spell files from
+SPELLSOURCE = ../runtime/spell
+
+# Where to look for language specific files
+LANGSOURCE = ../runtime/lang
+
+# Where to look for compiler files
+COMPSOURCE = ../runtime/compiler
+
+# Where to look for keymap files
+KMAPSOURCE = ../runtime/keymap
+
+# Where to look for print resource files
+PRINTSOURCE = ../runtime/print
+
+# If you are using Linux, you might want to use this to make vim the
+# default vi editor, it will create a link from vi to Vim when doing
+# "make install".  An existing file will be overwritten!
+# When not using it, some make programs can't handle an undefined $(LINKIT).
+#LINKIT = ln -f -s $(DEST_BIN)/$(VIMTARGET) $(DESTDIR)/usr/bin/vi
+LINKIT = @echo >/dev/null
+
+###
+### GRAPHICAL USER INTERFACE (GUI).  {{{1
+### 'configure --enable-gui' can enable one of these for you if you did set
+### a corresponding CONF_OPT_GUI above and have X11.
+### Override configures choice by uncommenting all the following lines.
+### As they are, the GUI is disabled.  Replace "NONE" with "ATHENA" or "MOTIF"
+### for enabling the Athena or Motif GUI.
+#GUI_SRC	= $(NONE_SRC)
+#GUI_OBJ	= $(NONE_OBJ)
+#GUI_DEFS	= $(NONE_DEFS)
+#GUI_IPATH	= $(NONE_IPATH)
+#GUI_LIBS_DIR	= $(NONE_LIBS_DIR)
+#GUI_LIBS1	= $(NONE_LIBS1)
+#GUI_LIBS2	= $(NONE_LIBS2)
+#GUI_INSTALL    = $(NONE_INSTALL)
+#GUI_TARGETS	= $(NONE_TARGETS)
+#GUI_MAN_TARGETS= $(NONE_MAN_TARGETS)
+#GUI_TESTTARGET = $(NONE_TESTTARGET)
+#GUI_BUNDLE	= $(NONE_BUNDLE)
+
+# Without a GUI install the normal way.
+NONE_INSTALL = install_normal
+
+### GTK GUI
+GTK_SRC		= gui.c gui_gtk.c gui_gtk_x11.c gui_gtk_f.c \
+			gui_beval.c $(GRESOURCE_SRC)
+GTK_OBJ		= objects/gui.o objects/gui_gtk.o objects/gui_gtk_x11.o \
+			objects/gui_gtk_f.o \
+			objects/gui_beval.o $(GRESOURCE_OBJ)
+GTK_DEFS	= -DFEAT_GUI_GTK $(NARROW_PROTO)
+GTK_IPATH	= $(GUI_INC_LOC)
+GTK_LIBS_DIR	= $(GUI_LIB_LOC)
+GTK_LIBS1	=
+GTK_LIBS2	= $(GTK_LIBNAME)
+GTK_INSTALL     = install_normal install_gui_extra
+GTK_TARGETS	= installglinks
+GTK_MAN_TARGETS = yes
+GTK_TESTTARGET  = gui
+GTK_BUNDLE	=
+
+### Motif GUI
+MOTIF_SRC	= gui.c gui_motif.c gui_x11.c gui_beval.c \
+			gui_xmdlg.c gui_xmebw.c
+MOTIF_OBJ	= objects/gui.o objects/gui_motif.o objects/gui_x11.o \
+			objects/gui_beval.o \
+			objects/gui_xmdlg.o objects/gui_xmebw.o
+MOTIF_DEFS	= -DFEAT_GUI_MOTIF $(NARROW_PROTO)
+MOTIF_IPATH	= $(GUI_INC_LOC)
+MOTIF_LIBS_DIR	= $(GUI_LIB_LOC)
+MOTIF_LIBS1	=
+MOTIF_LIBS2	= $(MOTIF_LIBNAME) -lXt
+MOTIF_INSTALL   = install_normal install_gui_extra
+MOTIF_TARGETS	= installglinks
+MOTIF_MAN_TARGETS = yes
+MOTIF_TESTTARGET = gui
+MOTIF_BUNDLE	=
+
+### Athena GUI
+### Use Xaw3d to make the menus look a little bit nicer
+#XAW_LIB = -lXaw3d
+XAW_LIB = -lXaw
+
+### When using Xaw3d, uncomment/comment the following lines to also get the
+### scrollbars from Xaw3d.
+#ATHENA_SRC	= gui.c gui_athena.c gui_x11.c gui_beval.c gui_at_fs.c
+#ATHENA_OBJ	= objects/gui.o objects/gui_athena.o objects/gui_x11.o \
+#			objects/gui_beval.o objects/gui_at_fs.o
+#ATHENA_DEFS	= -DFEAT_GUI_ATHENA $(NARROW_PROTO) \
+#		    -Dvim_scrollbarWidgetClass=scrollbarWidgetClass \
+#		    -Dvim_XawScrollbarSetThumb=XawScrollbarSetThumb
+ATHENA_SRC	= gui.c gui_athena.c gui_x11.c gui_beval.c \
+			gui_at_sb.c gui_at_fs.c
+ATHENA_OBJ	= objects/gui.o objects/gui_athena.o objects/gui_x11.o \
+			objects/gui_beval.o \
+			objects/gui_at_sb.o objects/gui_at_fs.o
+ATHENA_DEFS	= -DFEAT_GUI_ATHENA $(NARROW_PROTO)
+
+ATHENA_IPATH	= $(GUI_INC_LOC)
+ATHENA_LIBS_DIR = $(GUI_LIB_LOC)
+ATHENA_LIBS1	= $(XAW_LIB)
+ATHENA_LIBS2	= -lXt
+ATHENA_INSTALL  = install_normal install_gui_extra
+ATHENA_TARGETS	= installglinks
+ATHENA_MAN_TARGETS = yes
+ATHENA_TESTTARGET = gui
+ATHENA_BUNDLE	=
+
+### neXtaw GUI
+NEXTAW_LIB = -lneXtaw
+
+NEXTAW_SRC	= gui.c gui_athena.c gui_x11.c gui_beval.c gui_at_fs.c
+NEXTAW_OBJ	= objects/gui.o objects/gui_athena.o objects/gui_x11.o \
+			objects/gui_beval.o objects/gui_at_fs.o
+NEXTAW_DEFS	= -DFEAT_GUI_ATHENA -DFEAT_GUI_NEXTAW $(NARROW_PROTO)
+
+NEXTAW_IPATH	= $(GUI_INC_LOC)
+NEXTAW_LIBS_DIR = $(GUI_LIB_LOC)
+NEXTAW_LIBS1	= $(NEXTAW_LIB)
+NEXTAW_LIBS2	= -lXt
+NEXTAW_INSTALL  =  install_normal install_gui_extra
+NEXTAW_TARGETS	=  installglinks
+NEXTAW_MAN_TARGETS = yes
+NEXTAW_TESTTARGET = gui
+NEXTAW_BUNDLE	=
+
+### (J)  Sun OpenWindows 3.2 (SunOS 4.1.x) or earlier that produce these ld
+#	 errors:  ld: Undefined symbol
+#		      _get_wmShellWidgetClass
+#		      _get_applicationShellWidgetClass
+# then you need to get patches 100512-02 and 100573-03 from Sun.  In the
+# meantime, uncomment the following GUI_X_LIBS definition as a workaround:
+#GUI_X_LIBS = -Bstatic -lXmu -Bdynamic -lXext
+# If you also get cos, sin etc. as undefined symbols, try uncommenting this
+# too:
+#EXTRA_LIBS = /usr/openwin/lib/libXmu.sa -lm
+
+# PHOTON GUI
+PHOTONGUI_SRC	= gui.c gui_photon.c
+PHOTONGUI_OBJ	= objects/gui.o objects/gui_photon.o
+PHOTONGUI_DEFS	= -DFEAT_GUI_PHOTON
+PHOTONGUI_IPATH	=
+PHOTONGUI_LIBS_DIR =
+PHOTONGUI_LIBS1	= -lph -lphexlib
+PHOTONGUI_LIBS2	=
+PHOTONGUI_INSTALL = install_normal install_gui_extra
+PHOTONGUI_TARGETS = installglinks
+PHOTONGUI_MAN_TARGETS = yes
+PHOTONGUI_TESTTARGET = gui
+PHOTONGUI_BUNDLE =
+
+# CARBON GUI
+CARBONGUI_SRC	= gui.c gui_mac.c
+CARBONGUI_OBJ	= objects/gui.o objects/gui_mac.o
+CARBONGUI_DEFS	= -DFEAT_GUI_MAC -fno-common -fpascal-strings \
+		  -Wall -Wno-unknown-pragmas \
+		  -mdynamic-no-pic -pipe
+CARBONGUI_IPATH	= -I. -Iproto
+CARBONGUI_LIBS_DIR =
+CARBONGUI_LIBS1	= -framework Carbon
+CARBONGUI_LIBS2	=
+CARBONGUI_INSTALL = install_macosx
+CARBONGUI_TARGETS =
+CARBONGUI_MAN_TARGETS =
+CARBONGUI_TESTTARGET = gui
+CARBONGUI_BUNDLE = gui_bundle
+APPDIR = $(VIMNAME).app
+CARBONGUI_TESTARG = VIMPROG=../$(APPDIR)/Contents/MacOS/$(VIMTARGET)
+
+# All GUI files
+ALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c
+ALL_GUI_PRO  = gui.pro gui_gtk.pro gui_motif.pro gui_xmdlg.pro gui_athena.pro gui_gtk_x11.pro gui_x11.pro gui_w32.pro gui_photon.pro
+
+# }}}
+
+TERM_DEPS = \
+	libvterm/include/vterm.h \
+	libvterm/include/vterm_keycodes.h \
+	libvterm/src/rect.h \
+	libvterm/src/utf8.h \
+	libvterm/src/vterm_internal.h
+
+TERM_SRC = libvterm/src/*.c
+
+### Command to create dependencies based on #include "..."
+### prototype headers are ignored due to -DPROTO, system
+### headers #include <...> are ignored if we use the -MM option, as
+### e.g. provided by gcc-cpp.
+### Include FEAT_GUI to get dependency on gui.h
+### Need to change "-I /<path>" to "-isystem /<path>" for GCC 3.x.
+CPP_DEPEND = $(CC) -I$(srcdir) -M$(CPP_MM) \
+		`echo "$(DEPEND_CFLAGS)" $(DEPEND_CFLAGS_FILTER)`
+
+# flags for cproto
+#     This is for cproto 3 patchlevel 8 or below
+#     __inline, __attribute__ and __extension__ are not recognized by cproto
+#     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.
+#NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
+#	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
+#	  -D__extension__= -D__restrict="" \
+#	  -D__gnuc_va_list=char -D__builtin_va_list=char
+
+#
+#     This is for cproto 3 patchlevel 9 or above (currently 4.6, 4.7g)
+#     __inline and __attribute__ are now recognized by cproto
+#     -D"foo()=" is not supported by all compilers so do not use it
+NO_ATTR=
+#
+# Use this for cproto 3 patchlevel 6 or below (use "cproto -V" to check):
+# PROTO_FLAGS = -f4 -d -E"$(CPP)" $(NO_ATTR)
+#
+# Use this for cproto 3 patchlevel 7 or above (use "cproto -V" to check):
+PROTO_FLAGS = -d -E"$(CPP)" $(NO_ATTR)
+
+
+################################################
+##   no changes required below this line      ##
+################################################
+
+SHELL = /bin/sh
+
+# We would normally use "mkdir -p" but it doesn't work properly everywhere.
+# Using AC_PROG_MKDIR_P in configure.ac has a problem with the "auto"
+# directory.  Always use the install-sh script, it's slower but reliable.
+MKDIR_P = $(SHELL) install-sh -c -d
+
+.SUFFIXES:
+.SUFFIXES: .c .o .pro
+
+PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
+POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
+
+ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(ABORT_CLFAGS) $(POST_DEFS)
+
+# Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
+# with "-E".
+OSDEF_CFLAGS = $(PRE_DEFS) $(POST_DEFS)
+
+LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(TCL_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
+
+LINT_EXTRA = -DHANGUL_INPUT -D"__attribute__(x)="
+
+DEPEND_CFLAGS = -DPROTO -DDEPEND -DFEAT_GUI $(LINT_CFLAGS)
+
+# Note: MZSCHEME_LIBS must come before LIBS, because LIBS adds -lm which is
+# needed by racket.
+ALL_LIB_DIRS = $(GUI_LIBS_DIR) $(X_LIBS_DIR)
+ALL_LIBS = \
+	   $(GUI_LIBS1) \
+	   $(GUI_X_LIBS) \
+	   $(GUI_LIBS2) \
+	   $(X_PRE_LIBS) \
+	   $(X_LIBS) \
+	   $(X_EXTRA_LIBS) \
+	   $(MZSCHEME_LIBS) \
+	   $(LIBS) \
+	   $(EXTRA_LIBS) \
+	   $(LUA_LIBS) \
+	   $(PERL_LIBS) \
+	   $(PYTHON_LIBS) \
+	   $(PYTHON3_LIBS) \
+	   $(TCL_LIBS) \
+	   $(RUBY_LIBS) \
+	   $(PROFILE_LIBS) \
+	   $(SANITIZER_LIBS) \
+	   $(LEAK_LIBS)
+
+# abbreviations
+DEST_BIN = $(DESTDIR)$(BINDIR)
+DEST_VIM = $(DESTDIR)$(VIMLOC)
+DEST_RT = $(DESTDIR)$(VIMRTLOC)
+DEST_HELP = $(DESTDIR)$(HELPSUBLOC)
+DEST_COL = $(DESTDIR)$(COLSUBLOC)
+DEST_SYN = $(DESTDIR)$(SYNSUBLOC)
+DEST_IND = $(DESTDIR)$(INDSUBLOC)
+DEST_AUTO = $(DESTDIR)$(AUTOSUBLOC)
+DEST_PLUG = $(DESTDIR)$(PLUGSUBLOC)
+DEST_FTP = $(DESTDIR)$(FTPLUGSUBLOC)
+DEST_LANG = $(DESTDIR)$(LANGSUBLOC)
+DEST_COMP = $(DESTDIR)$(COMPSUBLOC)
+DEST_KMAP = $(DESTDIR)$(KMAPSUBLOC)
+DEST_MACRO = $(DESTDIR)$(MACROSUBLOC)
+DEST_PACK = $(DESTDIR)$(PACKSUBLOC)
+DEST_TOOLS = $(DESTDIR)$(TOOLSSUBLOC)
+DEST_TUTOR = $(DESTDIR)$(TUTORSUBLOC)
+DEST_SPELL = $(DESTDIR)$(SPELLSUBLOC)
+DEST_SCRIPT = $(DESTDIR)$(SCRIPTLOC)
+DEST_PRINT = $(DESTDIR)$(PRINTSUBLOC)
+DEST_MAN_TOP = $(DESTDIR)$(MANDIR)
+
+# We assume that the ".../man/xx/man1/" directory is for latin1 manual pages.
+# Some systems use UTF-8, but these should find the ".../man/xx.UTF-8/man1/"
+# directory first.
+# FreeBSD uses ".../man/xx.ISO8859-1/man1" for latin1, use that one too.
+DEST_MAN = $(DEST_MAN_TOP)$(MAN1DIR)
+DEST_MAN_DA = $(DEST_MAN_TOP)/da$(MAN1DIR)
+DEST_MAN_DA_I = $(DEST_MAN_TOP)/da.ISO8859-1$(MAN1DIR)
+DEST_MAN_DA_U = $(DEST_MAN_TOP)/da.UTF-8$(MAN1DIR)
+DEST_MAN_DE = $(DEST_MAN_TOP)/de$(MAN1DIR)
+DEST_MAN_DE_I = $(DEST_MAN_TOP)/de.ISO8859-1$(MAN1DIR)
+DEST_MAN_DE_U = $(DEST_MAN_TOP)/de.UTF-8$(MAN1DIR)
+DEST_MAN_FR = $(DEST_MAN_TOP)/fr$(MAN1DIR)
+DEST_MAN_FR_I = $(DEST_MAN_TOP)/fr.ISO8859-1$(MAN1DIR)
+DEST_MAN_FR_U = $(DEST_MAN_TOP)/fr.UTF-8$(MAN1DIR)
+DEST_MAN_IT = $(DEST_MAN_TOP)/it$(MAN1DIR)
+DEST_MAN_IT_I = $(DEST_MAN_TOP)/it.ISO8859-1$(MAN1DIR)
+DEST_MAN_IT_U = $(DEST_MAN_TOP)/it.UTF-8$(MAN1DIR)
+DEST_MAN_JA_U = $(DEST_MAN_TOP)/ja$(MAN1DIR)
+DEST_MAN_PL = $(DEST_MAN_TOP)/pl$(MAN1DIR)
+DEST_MAN_PL_I = $(DEST_MAN_TOP)/pl.ISO8859-2$(MAN1DIR)
+DEST_MAN_PL_U = $(DEST_MAN_TOP)/pl.UTF-8$(MAN1DIR)
+DEST_MAN_RU = $(DEST_MAN_TOP)/ru.KOI8-R$(MAN1DIR)
+DEST_MAN_RU_U = $(DEST_MAN_TOP)/ru.UTF-8$(MAN1DIR)
+
+# The list of tests is common to all systems.
+include Make_all.mak
+
+#	     BASIC_SRC: files that are always used
+#	       GUI_SRC: extra GUI files for current configuration
+#	   ALL_GUI_SRC: all GUI files for Unix
+#
+#		   SRC: files used for current configuration
+#	      TAGS_SRC: source files used for make tags
+#	     TAGS_INCL: include files used for make tags
+#	       ALL_SRC: source files used for make depend and make lint
+
+TAGS_INCL = *.h
+
+BASIC_SRC = \
+	arabic.c \
+	beval.c \
+	blowfish.c \
+	buffer.c \
+	charset.c \
+	crypt.c \
+	crypt_zip.c \
+	dict.c \
+	diff.c \
+	digraph.c \
+	edit.c \
+	eval.c \
+	evalfunc.c \
+	ex_cmds.c \
+	ex_cmds2.c \
+	ex_docmd.c \
+	ex_eval.c \
+	ex_getln.c \
+	farsi.c \
+	fileio.c \
+	fold.c \
+	getchar.c \
+	hardcopy.c \
+	hashtab.c \
+	if_cscope.c \
+	if_xcmdsrv.c \
+	json.c \
+	list.c \
+	main.c \
+	mark.c \
+	memfile.c \
+	memline.c \
+	menu.c \
+	message.c \
+	misc1.c \
+	misc2.c \
+	move.c \
+	mbyte.c \
+	normal.c \
+	ops.c \
+	option.c \
+	os_unix.c \
+	auto/pathdef.c \
+	popupmnu.c \
+	pty.c \
+	quickfix.c \
+	regexp.c \
+	screen.c \
+	search.c \
+	sha256.c \
+	spell.c \
+	spellfile.c \
+	syntax.c \
+	tag.c \
+	term.c \
+	terminal.c \
+	ui.c \
+	undo.c \
+	userfunc.c \
+	version.c \
+	window.c \
+	$(OS_EXTRA_SRC)
+
+SRC =	$(BASIC_SRC) \
+	$(GUI_SRC) \
+	$(TERM_SRC) \
+	$(HANGULIN_SRC) \
+	$(LUA_SRC) \
+	$(MZSCHEME_SRC) \
+	$(PERL_SRC) \
+	$(PYTHON_SRC) $(PYTHON3_SRC) \
+	$(TCL_SRC) \
+	$(RUBY_SRC) \
+	$(WORKSHOP_SRC) \
+	$(WSDEBUG_SRC)
+
+TAGS_SRC = *.c *.cpp if_perl.xs
+
+EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
+	    if_python.c if_python3.c if_tcl.c if_ruby.c \
+	    gui_beval.c workshop.c wsdebug.c integration.c \
+	    netbeans.c channel.c \
+	    $(GRESOURCE_SRC)
+
+# Unittest files
+JSON_TEST_SRC = json_test.c
+JSON_TEST_TARGET = json_test$(EXEEXT)
+KWORD_TEST_SRC = kword_test.c
+KWORD_TEST_TARGET = kword_test$(EXEEXT)
+MEMFILE_TEST_SRC = memfile_test.c
+MEMFILE_TEST_TARGET = memfile_test$(EXEEXT)
+MESSAGE_TEST_SRC = message_test.c
+MESSAGE_TEST_TARGET = message_test$(EXEEXT)
+
+UNITTEST_SRC = $(JSON_TEST_SRC) $(KWORD_TEST_SRC) $(MEMFILE_TEST_SRC) $(MESSAGE_TEST_SRC)
+UNITTEST_TARGETS = $(JSON_TEST_TARGET) $(KWORD_TEST_TARGET) $(MEMFILE_TEST_TARGET) $(MESSAGE_TEST_TARGET)
+RUN_UNITTESTS = run_json_test run_kword_test run_memfile_test run_message_test
+
+# All sources, also the ones that are not configured
+ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)
+
+# Which files to check with lint.  Select one of these three lines.  ALL_SRC
+# checks more, but may not work well for checking a GUI that wasn't configured.
+# The perl sources also don't work well with lint.
+LINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) \
+	   $(PYTHON_SRC) $(PYTHON3_SRC) $(TCL_SRC) \
+	   $(WORKSHOP_SRC) $(WSDEBUG_SRC) \
+	   $(NETBEANS_SRC) $(CHANNEL_SRC) $(TERM_SRC)
+#LINT_SRC = $(SRC)
+#LINT_SRC = $(ALL_SRC)
+#LINT_SRC = $(BASIC_SRC)
+
+OBJ_COMMON = \
+	objects/arabic.o \
+	objects/beval.o \
+	objects/buffer.o \
+	objects/blowfish.o \
+	objects/crypt.o \
+	objects/crypt_zip.o \
+	objects/dict.o \
+	objects/diff.o \
+	objects/digraph.o \
+	objects/edit.o \
+	objects/eval.o \
+	objects/evalfunc.o \
+	objects/ex_cmds.o \
+	objects/ex_cmds2.o \
+	objects/ex_docmd.o \
+	objects/ex_eval.o \
+	objects/ex_getln.o \
+	objects/farsi.o \
+	objects/fileio.o \
+	objects/fold.o \
+	objects/getchar.o \
+	objects/hardcopy.o \
+	objects/hashtab.o \
+	$(HANGULIN_OBJ) \
+	objects/if_cscope.o \
+	objects/if_xcmdsrv.o \
+	objects/list.o \
+	objects/mark.o \
+	objects/memline.o \
+	objects/menu.o \
+	objects/misc1.o \
+	objects/misc2.o \
+	objects/move.o \
+	objects/mbyte.o \
+	objects/normal.o \
+	objects/ops.o \
+	objects/option.o \
+	objects/os_unix.o \
+	objects/pathdef.o \
+	objects/popupmnu.o \
+	objects/pty.o \
+	objects/quickfix.o \
+	objects/regexp.o \
+	objects/screen.o \
+	objects/search.o \
+	objects/sha256.o \
+	objects/spell.o \
+	objects/spellfile.o \
+	objects/syntax.o \
+	objects/tag.o \
+	objects/term.o \
+	objects/terminal.o \
+	objects/ui.o \
+	objects/undo.o \
+	objects/userfunc.o \
+	objects/version.o \
+	objects/window.o \
+	$(GUI_OBJ) \
+	$(TERM_OBJ) \
+	$(LUA_OBJ) \
+	$(MZSCHEME_OBJ) \
+	$(PERL_OBJ) \
+	$(PYTHON_OBJ) \
+	$(PYTHON3_OBJ) \
+	$(TCL_OBJ) \
+	$(RUBY_OBJ) \
+	$(OS_EXTRA_OBJ) \
+	$(WORKSHOP_OBJ) \
+	$(NETBEANS_OBJ) \
+	$(CHANNEL_OBJ) \
+	$(WSDEBUG_OBJ)
+
+# The files included by tests are not in OBJ_COMMON.
+OBJ_MAIN = \
+	objects/charset.o \
+	objects/json.o \
+	objects/main.o \
+	objects/memfile.o \
+	objects/message.o
+
+OBJ = $(OBJ_COMMON) $(OBJ_MAIN)
+
+OBJ_JSON_TEST = \
+	objects/charset.o \
+	objects/memfile.o \
+	objects/message.o \
+	objects/json_test.o
+
+JSON_TEST_OBJ = $(OBJ_COMMON) $(OBJ_JSON_TEST)
+
+OBJ_KWORD_TEST = \
+	objects/json.o \
+	objects/memfile.o \
+	objects/message.o \
+	objects/kword_test.o
+
+KWORD_TEST_OBJ = $(OBJ_COMMON) $(OBJ_KWORD_TEST)
+
+OBJ_MEMFILE_TEST = \
+	objects/charset.o \
+	objects/json.o \
+	objects/message.o \
+	objects/memfile_test.o
+
+MEMFILE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MEMFILE_TEST)
+
+OBJ_MESSAGE_TEST = \
+	objects/charset.o \
+	objects/json.o \
+	objects/memfile.o \
+	objects/message_test.o
+
+MESSAGE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MESSAGE_TEST)
+
+ALL_OBJ = $(OBJ_COMMON) \
+	  $(OBJ_MAIN) \
+	  $(OBJ_JSON_TEST) \
+	  $(OBJ_KWORD_TEST) \
+	  $(OBJ_MEMFILE_TEST) \
+	  $(OBJ_MESSAGE_TEST)
+
+
+PRO_AUTO = \
+	arabic.pro \
+	blowfish.pro \
+	buffer.pro \
+	charset.pro \
+	crypt.pro \
+	crypt_zip.pro \
+	dict.pro \
+	diff.pro \
+	digraph.pro \
+	edit.pro \
+	eval.pro \
+	evalfunc.pro \
+	ex_cmds.pro \
+	ex_cmds2.pro \
+	ex_docmd.pro \
+	ex_eval.pro \
+	ex_getln.pro \
+	farsi.pro \
+	fileio.pro \
+	fold.pro \
+	getchar.pro \
+	hardcopy.pro \
+	hashtab.pro \
+	hangulin.pro \
+	if_cscope.pro \
+	if_lua.pro \
+	if_mzsch.pro \
+	if_python.pro \
+	if_python3.pro \
+	if_ruby.pro \
+	if_xcmdsrv.pro \
+	json.pro \
+	list.pro \
+	main.pro \
+	mark.pro \
+	mbyte.pro \
+	memfile.pro \
+	memline.pro \
+	menu.pro \
+	message.pro \
+	misc1.pro \
+	misc2.pro \
+	move.pro \
+	normal.pro \
+	ops.pro \
+	option.pro \
+	os_mac_conv.pro \
+	os_unix.pro \
+	popupmnu.pro \
+	pty.pro \
+	quickfix.pro \
+	regexp.pro \
+	screen.pro \
+	search.pro \
+	sha256.pro \
+	spell.pro \
+	spellfile.pro \
+	syntax.pro \
+	tag.pro \
+	term.pro \
+	terminal.pro \
+	termlib.pro \
+	ui.pro \
+	undo.pro \
+	userfunc.pro \
+	version.pro \
+	window.pro \
+	beval.pro \
+	gui_beval.pro \
+	workshop.pro \
+	netbeans.pro \
+	channel.pro \
+	$(ALL_GUI_PRO) \
+	$(TCL_PRO)
+
+# Resources used for the Mac are in one directory.
+RSRC_DIR = os_mac_rsrc
+
+PRO_MANUAL = os_amiga.pro os_win32.pro \
+	os_mswin.pro winclip.pro os_beos.pro os_vms.pro $(PERL_PRO)
+
+# Default target is making the executable and tools
+all: $(VIMTARGET) $(TOOLS) languages $(GUI_BUNDLE)
+
+tools: $(TOOLS)
+
+# Run configure with all the setting from above.
+#
+# Note: auto/config.h doesn't depend on configure, because running configure
+# doesn't always update auto/config.h.  The timestamp isn't changed if the
+# file contents didn't change (to avoid recompiling everything).  Including a
+# dependency on auto/config.h would cause running configure each time when
+# auto/config.h isn't updated.  The dependency on auto/config.mk should make
+# sure configure is run when it's needed.
+#
+# Remove the config.cache every time, once in a while it causes problems that
+# are very hard to figure out.
+#
+config auto/config.mk: auto/configure config.mk.in config.h.in
+	-rm -f auto/config.cache
+	if test "X$(MAKECMDGOALS)" != "Xclean" \
+		-a "X$(MAKECMDGOALS)" != "Xdistclean" \
+		-a "X$(MAKECMDGOALS)" != "Xautoconf" \
+		-a "X$(MAKECMDGOALS)" != "Xreconfig"; then \
+	    GUI_INC_LOC="$(GUI_INC_LOC)" GUI_LIB_LOC="$(GUI_LIB_LOC)" \
+		CC="$(CC)" CPPFLAGS="$(CPPFLAGS)" CFLAGS="$(CFLAGS)" \
+		LDFLAGS="$(LDFLAGS)" $(CONF_SHELL) srcdir="$(srcdir)" \
+		./configure $(CONF_OPT_GUI) $(CONF_OPT_X) $(CONF_OPT_XSMP) \
+		$(CONF_OPT_AUTOSERVE) $(CONF_OPT_DARWIN) $(CONF_OPT_FAIL) \
+		$(CONF_OPT_PERL) $(CONF_OPT_PYTHON) $(CONF_OPT_PYTHON3) \
+		$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \
+		$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \
+		$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \
+		$(CONF_OPT_FEAT) $(CONF_TERM_LIB) \
+		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL) $(CONF_OPT_NETBEANS) \
+		$(CONF_OPT_CHANNEL) $(CONF_OPT_TERMINAL) \
+		$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \
+		$(CONF_OPT_LUA) $(CONF_OPT_LUA_PREFIX) \
+		$(CONF_OPT_SYSMOUSE); \
+	fi
+
+# Use "make reconfig" to rerun configure without cached values.
+# When config.h changes, most things will be recompiled automatically.
+# Invoke $(MAKE) to run config with the empty auto/config.mk.
+# Invoke $(MAKE) to build all with the filled auto/config.mk.
+reconfig: scratch clean
+	$(MAKE) -f Makefile config
+	$(MAKE) -f Makefile all
+
+# Run autoconf to produce auto/configure.
+# Note:
+# - DO NOT RUN autoconf MANUALLY!  It will overwrite ./configure instead of
+#   producing auto/configure.
+# - autoconf is not run automatically, because a patch usually changes both
+#   configure.ac and auto/configure but can't update the timestamps.  People
+#   who do not have (the correct version of) autoconf would run into trouble.
+#
+# Two tricks are required to make autoconf put its output in the "auto" dir:
+# - Temporarily move the ./configure script to ./configure.save.  Don't
+#   overwrite it, it's probably the result of an aborted autoconf.
+# - Use sed to change ./config.log to auto/config.log in the configure script.
+# Autoconf 2.5x (2.59 at least) produces a few more files that we need to take
+# care of:
+# - configure.lineno: has the line numbers replaced with $LINENO.  That
+#   improves patches a LOT, thus use it instead (until someone says it doesn't
+#   work on some system).
+# - autom4te.cache directory is created and not cleaned up.  Delete it.
+# - Uses ">config.log" instead of "./config.log".
+autoconf:
+	if test ! -f configure.save; then mv configure configure.save; fi
+	$(AUTOCONF)
+	sed -e 's+>config.log+>auto/config.log+' -e 's+\./config.log+auto/config.log+' configure > auto/configure
+	chmod 755 auto/configure
+	mv -f configure.save configure
+	-rm -rf autom4te.cache
+	-rm -f auto/config.status auto/config.cache
+
+# Run vim script to generate the Ex command lookup table.
+# This only needs to be run when a command name has been added or changed.
+# If this fails because you don't have Vim yet, first build and install Vim
+# without changes.
+cmdidxs: ex_cmds.h
+	vim -u NONE -i NONE -X -S create_cmdidxs.vim
+
+
+# The normal command to compile a .c file to its .o file.
+# Without or with ALL_CFLAGS.
+CCC_NF = $(CC) -c -I$(srcdir)
+CCC = $(CCC_NF) $(ALL_CFLAGS)
+
+
+# Link the target for normal use or debugging.
+# A shell script is used to try linking without unnecessary libraries.
+$(VIMTARGET): auto/config.mk objects $(OBJ) version.c version.h
+	$(CCC) version.c -o objects/version.o
+	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
+		-o $(VIMTARGET) $(OBJ) $(ALL_LIBS)" \
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
+
+xxd/xxd$(EXEEXT): xxd/xxd.c
+	cd xxd; CC="$(CC)" CFLAGS="$(CPPFLAGS) $(CFLAGS)" LDFLAGS="$(LDFLAGS)" \
+		$(MAKE) -f Makefile
+
+# Build the language specific files if they were unpacked.
+# Generate the converted .mo files separately, it's no problem if this fails.
+languages:
+	@if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
+		cd $(PODIR); \
+		  CC="$(CC)" $(MAKE) prefix=$(DESTDIR)$(prefix); \
+	fi
+	-@if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
+		cd $(PODIR); \
+		  CC="$(CC)" $(MAKE) prefix=$(DESTDIR)$(prefix) converted; \
+	fi
+
+# Update the *.po files for changes in the sources.  Only run manually.
+update-po:
+	cd $(PODIR); CC="$(CC)" $(MAKE) prefix=$(DESTDIR)$(prefix) update-po
+
+# Generate function prototypes.  This is not needed to compile vim, but if
+# you want to use it, cproto is out there on the net somewhere -- Webb
+#
+# When generating os_amiga.pro and os_win32.pro there will be a
+# few include files that can not be found, that's OK.
+
+proto: $(PRO_AUTO) $(PRO_MANUAL)
+
+# Filter out arguments that cproto doesn't support.
+# Don't pass "-pthread", "-fwrapv" and similar arguments to cproto, it sees
+# them as a list of individual flags.
+# The -E"gcc -E" argument must be separate to avoid problems with shell
+# quoting.
+CPROTO = cproto $(PROTO_FLAGS) -DPROTO \
+	 `echo '$(LINT_CFLAGS)' | sed -e 's/ -[a-z-]\+//g'`
+
+### Would be nice if this would work for "normal" make.
+### Currently it only works for (Free)BSD make.
+#$(PRO_AUTO): $$(*F).c
+#	$(CPROTO) -DFEAT_GUI $(*F).c > $@
+
+# Always define FEAT_GUI.  This may generate a few warnings if it's also
+# defined in auto/config.h, you can ignore that.
+.c.pro:
+	$(CPROTO) -DFEAT_GUI $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+
+os_amiga.pro: os_amiga.c
+	$(CPROTO) -DAMIGA -UHAVE_CONFIG_H -DBPTR=char* $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+
+os_win32.pro: os_win32.c
+	$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+
+os_mswin.pro: os_mswin.c
+	$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+
+winclip.pro: winclip.c
+	$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+
+os_beos.pro: os_beos.c
+	$(CPROTO) -D__BEOS__ -UHAVE_CONFIG_H $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+
+os_vms.pro: os_vms.c
+# must use os_vms_conf.h for auto/config.h
+	mv auto/config.h auto/config.h.save
+	cp os_vms_conf.h auto/config.h
+	$(CPROTO) -DVMS -UFEAT_GUI_ATHENA -UFEAT_GUI_NEXTAW -UFEAT_GUI_MOTIF -UFEAT_GUI_GTK $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+	rm auto/config.h
+	mv auto/config.h.save auto/config.h
+
+# if_perl.pro is special: Use the generated if_perl.c for input and remove
+# prototypes for local functions.
+if_perl.pro: auto/if_perl.c
+	$(CPROTO) -DFEAT_GUI auto/if_perl.c | sed "/_VI/d" > proto/$@
+
+gui_gtk_gresources.pro: auto/gui_gtk_gresources.c
+	$(CPROTO) -DFEAT_GUI $< > proto/$@
+	echo "/* vim: set ft=c : */" >> proto/$@
+
+notags:
+	-rm -f tags
+
+# Note: tags is made for the currently configured version, can't include both
+#	Motif and Athena GUI
+# You can ignore error messages for missing files.
+tags TAGS: notags
+	$(TAGPRG) $(TAGS_SRC) $(TAGS_INCL) $(TERM_SRC) $(TERM_DEPS)
+
+# Make a highlight file for types.  Requires Exuberant ctags and awk
+types: types.vim
+types.vim: $(TAGS_SRC) $(TAGS_INCL)
+	ctags --c-kinds=gstu -o- $(TAGS_SRC) $(TAGS_INCL) |\
+		awk 'BEGIN{printf("syntax keyword Type\t")}\
+			{printf("%s ", $$1)}END{print ""}' > $@
+	echo "syn keyword Constant OK FAIL TRUE FALSE MAYBE" >> $@
+
+# TESTING
+#
+# Execute the test scripts and the unittests.
+test check: scripttests unittests
+
+# Execute the test scripts.  Run these after compiling Vim, before installing.
+# This doesn't depend on $(VIMTARGET), because that won't work when configure
+# wasn't run yet.  Restart make to build it instead.
+#
+# This will produce a lot of garbage on your screen, including a few error
+# messages.  Don't worry about that.
+# If there is a real error, there will be a difference between "testXX.out" and
+# a "testXX.ok" file.
+# If everything is alright, the final message will be "ALL DONE".  If not you
+# get "TEST FAILURE".
+#
+scripttests:
+	$(MAKE) -f Makefile $(VIMTARGET)
+	if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
+		cd $(PODIR); $(MAKE) -f Makefile check VIM=../$(VIMTARGET); \
+	fi
+	-if test $(VIMTARGET) != vim -a ! -r vim; then \
+		ln -s $(VIMTARGET) vim; \
+	fi
+	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
+
+# Run the tests with the GUI.  Assumes vim/gvim was already built
+testgui:
+	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) GUI_FLAG=-g $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
+
+benchmark:
+	cd testdir; $(MAKE) -f Makefile benchmark VIMPROG=../$(VIMTARGET) SCRIPTSOURCE=../$(SCRIPTSOURCE)
+
+unittesttargets:
+	$(MAKE) -f Makefile $(UNITTEST_TARGETS)
+
+# Swap these lines to run individual tests with gvim instead of vim.
+VIMTESTTARGET = $(VIMTARGET)
+# VIMTESTTARGET = $(GVIMTARGET)
+
+# Execute the unittests one by one.
+unittest unittests: $(RUN_UNITTESTS)
+
+run_json_test: $(JSON_TEST_TARGET)
+	$(VALGRIND) ./$(JSON_TEST_TARGET) || exit 1; echo $* passed;
+
+run_kword_test: $(KWORD_TEST_TARGET)
+	$(VALGRIND) ./$(KWORD_TEST_TARGET) || exit 1; echo $* passed;
+
+run_memfile_test: $(MEMFILE_TEST_TARGET)
+	$(VALGRIND) ./$(MEMFILE_TEST_TARGET) || exit 1; echo $* passed;
+
+run_message_test: $(MESSAGE_TEST_TARGET)
+	$(VALGRIND) ./$(MESSAGE_TEST_TARGET) || exit 1; echo $* passed;
+
+# Run individual OLD style test.
+# These do not depend on the executable, compile it when needed.
+test1 \
+	test_eval \
+	test3 test11 test14 test17 \
+	test29 test30 test37 test39 \
+	test42 test44 test48 test49 \
+	test52 test59 \
+	test64 test69 \
+	test70 test72 \
+	test86 test87 test88 \
+	test94 test95 test99 test108:
+	cd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTESTTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
+
+# Run individual NEW style test.
+# These do not depend on the executable, compile it when needed.
+$(NEW_TESTS):
+	cd testdir; rm -f $@.res test.log messages; $(MAKE) -f Makefile $@.res VIMPROG=../$(VIMTESTTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
+	@if test -f testdir/test.log; then \
+		cat testdir/test.log; \
+	fi
+	cat testdir/messages
+
+newtests:
+	cd testdir; rm -f $@.res test.log messages; $(MAKE) -f Makefile newtestssilent VIMPROG=../$(VIMTESTTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
+	@if test -f testdir/test.log; then \
+		cat testdir/test.log; \
+	fi
+	cat testdir/messages
+
+testclean:
+	cd testdir; $(MAKE) -f Makefile clean
+	if test -d $(PODIR); then \
+		cd $(PODIR); $(MAKE) checkclean; \
+	fi
+
+# Unittests
+# It's build just like Vim to satisfy all dependencies.
+$(JSON_TEST_TARGET): auto/config.mk objects $(JSON_TEST_OBJ)
+	$(CCC) version.c -o objects/version.o
+	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
+		-o $(JSON_TEST_TARGET) $(JSON_TEST_OBJ) $(ALL_LIBS)" \
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
+
+$(KWORD_TEST_TARGET): auto/config.mk objects $(KWORD_TEST_OBJ)
+	$(CCC) version.c -o objects/version.o
+	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
+		-o $(KWORD_TEST_TARGET) $(KWORD_TEST_OBJ) $(ALL_LIBS)" \
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
+
+$(MEMFILE_TEST_TARGET): auto/config.mk objects $(MEMFILE_TEST_OBJ)
+	$(CCC) version.c -o objects/version.o
+	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
+		-o $(MEMFILE_TEST_TARGET) $(MEMFILE_TEST_OBJ) $(ALL_LIBS)" \
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
+
+$(MESSAGE_TEST_TARGET): auto/config.mk objects $(MESSAGE_TEST_OBJ)
+	$(CCC) version.c -o objects/version.o
+	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
+		-o $(MESSAGE_TEST_TARGET) $(MESSAGE_TEST_OBJ) $(ALL_LIBS)" \
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
+
+# install targets
+
+install: $(GUI_INSTALL)
+
+install_normal: installvim installtools $(INSTALL_LANGS) install-icons
+
+install_gui_extra: installgtutorbin
+
+installvim: installvimbin installtutorbin \
+		installruntime installlinks installmanlinks
+
+#
+# Avoid overwriting an existing executable, somebody might be running it and
+# overwriting it could cause it to crash.  Deleting it is OK, it won't be
+# really deleted until all running processes for it have exited.  It is
+# renamed first, in case the deleting doesn't work.
+#
+# If you want to keep an older version, rename it before running "make
+# install".
+#
+installvimbin: $(VIMTARGET) $(DESTDIR)$(exec_prefix) $(DEST_BIN)
+	-if test -f $(DEST_BIN)/$(VIMTARGET); then \
+	  mv -f $(DEST_BIN)/$(VIMTARGET) $(DEST_BIN)/$(VIMNAME).rm; \
+	  rm -f $(DEST_BIN)/$(VIMNAME).rm; \
+	fi
+	$(INSTALL_PROG) $(VIMTARGET) $(DEST_BIN)
+	$(STRIP) $(DEST_BIN)/$(VIMTARGET)
+	chmod $(BINMOD) $(DEST_BIN)/$(VIMTARGET)
+# may create a link to the new executable from /usr/bin/vi
+	-$(LINKIT)
+
+# Long list of arguments for the shell script that installs the manual pages
+# for one language.
+INSTALLMANARGS = $(VIMLOC) $(SCRIPTLOC) $(VIMRCLOC) $(HELPSOURCE) $(MANMOD) \
+		$(VIMNAME) $(VIMDIFFNAME) $(EVIMNAME)
+
+# Install most of the runtime files
+installruntime: installrtbase installmacros installpack installtutor installspell
+
+# install the help files; first adjust the contents for the final location
+installrtbase: $(HELPSOURCE)/vim.1 $(DEST_VIM) $(DEST_RT) \
+		$(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) \
+		$(DEST_FTP) $(DEST_AUTO) $(DEST_AUTO)/dist $(DEST_AUTO)/xml \
+		$(DEST_PLUG) $(DEST_TUTOR) $(DEST_SPELL) $(DEST_COMP)
+	-$(SHELL) ./installman.sh install $(DEST_MAN) "" $(INSTALLMANARGS)
+# Generate the help tags with ":helptags" to handle all languages.
+# Move the distributed tags file aside and restore it, to avoid it being
+# different from the repository.
+	cd $(HELPSOURCE); if test -z "$(CROSS_COMPILING)" -a -f tags; then \
+		mv -f tags tags.dist; fi
+	@echo generating help tags
+	-@cd $(HELPSOURCE); if test -z "$(CROSS_COMPILING)"; then \
+		$(MAKE) VIMEXE=$(DEST_BIN)/$(VIMTARGET) vimtags; fi
+	cd $(HELPSOURCE); \
+		files=`ls *.txt tags`; \
+		files="$$files `ls *.??x tags-?? 2>/dev/null || true`"; \
+		$(INSTALL_DATA) $$files  $(DEST_HELP); \
+		cd $(DEST_HELP); \
+		chmod $(HELPMOD) $$files
+	$(INSTALL_DATA)  $(HELPSOURCE)/*.pl $(DEST_HELP)
+	chmod $(SCRIPTMOD) $(DEST_HELP)/*.pl
+	cd $(HELPSOURCE); if test -f tags.dist; then mv -f tags.dist tags; fi
+# install the menu files
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/menu.vim $(SYS_MENU_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_MENU_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/synmenu.vim $(SYS_SYNMENU_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_SYNMENU_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/delmenu.vim $(SYS_DELMENU_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_DELMENU_FILE)
+# install the defaults/evim/mswin file
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/defaults.vim $(VIM_DEFAULTS_FILE)
+	chmod $(VIMSCRIPTMOD) $(VIM_DEFAULTS_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/evim.vim $(EVIM_FILE)
+	chmod $(VIMSCRIPTMOD) $(EVIM_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/mswin.vim $(MSWIN_FILE)
+	chmod $(VIMSCRIPTMOD) $(MSWIN_FILE)
+# install the rgb.txt file
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/rgb.txt $(SYS_RGB_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_RGB_FILE)
+# install the bugreport file
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/bugreport.vim $(SYS_BUGR_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_BUGR_FILE)
+# install the example vimrc files
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/vimrc_example.vim $(DEST_SCRIPT)
+	chmod $(VIMSCRIPTMOD) $(DEST_SCRIPT)/vimrc_example.vim
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/gvimrc_example.vim $(DEST_SCRIPT)
+	chmod $(VIMSCRIPTMOD) $(DEST_SCRIPT)/gvimrc_example.vim
+# install the file type detection files
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/filetype.vim $(SYS_FILETYPE_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_FILETYPE_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/ftoff.vim $(SYS_FTOFF_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_FTOFF_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/scripts.vim $(SYS_SCRIPTS_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_SCRIPTS_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/ftplugin.vim $(SYS_FTPLUGIN_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_FTPLUGIN_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/ftplugof.vim $(SYS_FTPLUGOF_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_FTPLUGOF_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/indent.vim $(SYS_INDENT_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_INDENT_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/indoff.vim $(SYS_INDOFF_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_INDOFF_FILE)
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/optwin.vim $(SYS_OPTWIN_FILE)
+	chmod $(VIMSCRIPTMOD) $(SYS_OPTWIN_FILE)
+# install the print resource files
+	cd $(PRINTSOURCE); $(INSTALL_DATA) *.ps $(DEST_PRINT)
+	cd $(DEST_PRINT); chmod $(FILEMOD) *.ps
+# install the colorscheme files
+	cd $(COLSOURCE); $(INSTALL_DATA_R) *.vim tools README.txt $(DEST_COL)
+	cd $(DEST_COL); chmod $(DIRMOD) tools
+	cd $(DEST_COL); chmod $(HELPMOD) *.vim README.txt tools/*.vim
+# install the syntax files
+	cd $(SYNSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_SYN)
+	cd $(DEST_SYN); chmod $(HELPMOD) *.vim README.txt
+# install the indent files
+	cd $(INDSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_IND)
+	cd $(DEST_IND); chmod $(HELPMOD) *.vim README.txt
+# install the standard autoload files
+	cd $(AUTOSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_AUTO)
+	cd $(DEST_AUTO); chmod $(HELPMOD) *.vim README.txt
+	cd $(AUTOSOURCE)/dist; $(INSTALL_DATA) *.vim $(DEST_AUTO)/dist
+	cd $(DEST_AUTO)/dist; chmod $(HELPMOD) *.vim
+	cd $(AUTOSOURCE)/xml; $(INSTALL_DATA) *.vim $(DEST_AUTO)/xml
+	cd $(DEST_AUTO)/xml; chmod $(HELPMOD) *.vim
+# install the standard plugin files
+	cd $(PLUGSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_PLUG)
+	cd $(DEST_PLUG); chmod $(HELPMOD) *.vim README.txt
+# install the ftplugin files
+	cd $(FTPLUGSOURCE); $(INSTALL_DATA) *.vim README.txt logtalk.dict $(DEST_FTP)
+	cd $(DEST_FTP); chmod $(HELPMOD) *.vim README.txt
+# install the compiler files
+	cd $(COMPSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_COMP)
+	cd $(DEST_COMP); chmod $(HELPMOD) *.vim README.txt
+
+installmacros: $(DEST_VIM) $(DEST_RT) $(DEST_MACRO)
+	$(INSTALL_DATA_R) $(MACROSOURCE)/* $(DEST_MACRO)
+	chmod $(DIRMOD) `find $(DEST_MACRO) -type d -print`
+	chmod $(FILEMOD) `find $(DEST_MACRO) -type f -print`
+	chmod $(SCRIPTMOD) $(DEST_MACRO)/less.sh
+# When using CVS some CVS directories might have been copied.
+# Also delete AAPDIR and *.info files.
+	cvs=`find $(DEST_MACRO) \( -name CVS -o -name AAPDIR -o -name "*.info" \) -print`; \
+	      if test -n "$$cvs"; then \
+		 rm -rf $$cvs; \
+	      fi
+
+installpack: $(DEST_VIM) $(DEST_RT) $(DEST_PACK)
+	$(INSTALL_DATA_R) $(PACKSOURCE)/* $(DEST_PACK)
+	chmod $(DIRMOD) `find $(DEST_PACK) -type d -print`
+	chmod $(FILEMOD) `find $(DEST_PACK) -type f -print`
+
+# install the tutor files
+installtutorbin: $(DEST_VIM)
+	$(INSTALL_DATA) vimtutor $(DEST_BIN)/$(VIMNAME)tutor
+	chmod $(SCRIPTMOD) $(DEST_BIN)/$(VIMNAME)tutor
+
+installgtutorbin: $(DEST_VIM)
+	$(INSTALL_DATA) gvimtutor $(DEST_BIN)/$(GVIMNAME)tutor
+	chmod $(SCRIPTMOD) $(DEST_BIN)/$(GVIMNAME)tutor
+
+installtutor: $(DEST_RT) $(DEST_TUTOR)
+	-$(INSTALL_DATA) $(TUTORSOURCE)/README* $(TUTORSOURCE)/tutor* $(DEST_TUTOR)
+	-rm -f $(DEST_TUTOR)/*.info
+	chmod $(HELPMOD) $(DEST_TUTOR)/*
+
+# Install the spell files, if they exist.  This assumes at least the English
+# spell file is there.
+installspell: $(DEST_VIM) $(DEST_RT) $(DEST_SPELL)
+	if test -f $(SPELLSOURCE)/en.latin1.spl; then \
+	  $(INSTALL_DATA) $(SPELLSOURCE)/*.spl $(SPELLSOURCE)/*.sug $(SPELLSOURCE)/*.vim $(DEST_SPELL); \
+	  chmod $(HELPMOD) $(DEST_SPELL)/*.spl $(DEST_SPELL)/*.sug $(DEST_SPELL)/*.vim; \
+	fi
+
+# install helper program xxd
+installtools: $(TOOLS) $(DESTDIR)$(exec_prefix) $(DEST_BIN) \
+		$(TOOLSSOURCE) $(DEST_VIM) $(DEST_RT) $(DEST_TOOLS) \
+		$(INSTALL_TOOL_LANGS)
+	if test -f $(DEST_BIN)/xxd$(EXEEXT); then \
+	  mv -f $(DEST_BIN)/xxd$(EXEEXT) $(DEST_BIN)/xxd.rm; \
+	  rm -f $(DEST_BIN)/xxd.rm; \
+	fi
+	$(INSTALL_PROG) xxd/xxd$(EXEEXT) $(DEST_BIN)
+	$(STRIP) $(DEST_BIN)/xxd$(EXEEXT)
+	chmod $(BINMOD) $(DEST_BIN)/xxd$(EXEEXT)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN) "" $(INSTALLMANARGS)
+
+# install the runtime tools
+	$(INSTALL_DATA_R) $(TOOLSSOURCE)/* $(DEST_TOOLS)
+# When using CVS some CVS directories might have been copied.
+	cvs=`find $(DEST_TOOLS) \( -name CVS -o -name AAPDIR \) -print`; \
+	      if test -n "$$cvs"; then \
+		 rm -rf $$cvs; \
+	      fi
+	-chmod $(FILEMOD) $(DEST_TOOLS)/*
+# replace the path in some tools
+	perlpath=`./which.sh perl` && sed -e "s+/usr/bin/perl+$$perlpath+" $(TOOLSSOURCE)/efm_perl.pl >$(DEST_TOOLS)/efm_perl.pl
+	awkpath=`./which.sh nawk` && sed -e "s+/usr/bin/nawk+$$awkpath+" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; if test -z "$$awkpath"; then \
+		awkpath=`./which.sh gawk` && sed -e "s+/usr/bin/nawk+$$awkpath+" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; if test -z "$$awkpath"; then \
+		awkpath=`./which.sh awk` && sed -e "s+/usr/bin/nawk+$$awkpath+" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; fi; fi
+	-chmod $(SCRIPTMOD) `grep -l "^#!" $(DEST_TOOLS)/*`
+
+# install the language specific files for tools, if they were unpacked
+install-tool-languages:
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_DA) "-da" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_DA_I) "-da" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_DA_U) "-da.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_DE) "-de" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_DE_I) "-de" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_DE_U) "-de.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR) "-fr" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR_I) "-fr" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR_U) "-fr.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT) "-it" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT_I) "-it" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT_U) "-it.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_JA_U) "-ja.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL) "-pl" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL_I) "-pl" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL_U) "-pl.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_RU) "-ru" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh xxd $(DEST_MAN_RU_U) "-ru.UTF-8" $(INSTALLMANARGS)
+
+# install the language specific files, if they were unpacked
+install-languages: languages $(DEST_LANG) $(DEST_KMAP)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_DA) "-da" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_DA_I) "-da" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_DA_U) "-da.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_DE) "-de" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_DE_I) "-de" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_DE_U) "-de.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_FR) "-fr" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_FR_I) "-fr" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_FR_U) "-fr.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_IT) "-it" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_IT_I) "-it" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_IT_U) "-it.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_JA_U) "-ja.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_PL) "-pl" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_PL_I) "-pl" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_PL_U) "-pl.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_RU) "-ru" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh install $(DEST_MAN_RU_U) "-ru.UTF-8" $(INSTALLMANARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DA) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DA_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DA_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DE) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DE_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DE_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_FR) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_FR_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_FR_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_IT) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_IT_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_IT_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_JA_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_PL) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_PL_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_PL_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_RU) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_RU_U) $(INSTALLMLARGS)
+	if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
+	   cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) LOCALEDIR=$(DEST_LANG) \
+	   INSTALL_DATA=$(INSTALL_DATA) FILEMOD=$(FILEMOD) install; \
+	fi
+	if test -d $(LANGSOURCE); then \
+	   $(INSTALL_DATA) $(LANGSOURCE)/README.txt $(LANGSOURCE)/*.vim $(DEST_LANG); \
+	   chmod $(FILEMOD) $(DEST_LANG)/README.txt $(DEST_LANG)/*.vim; \
+	fi
+	if test -d $(KMAPSOURCE); then \
+	   $(INSTALL_DATA) $(KMAPSOURCE)/README.txt $(KMAPSOURCE)/*.vim $(DEST_KMAP); \
+	   chmod $(FILEMOD) $(DEST_KMAP)/README.txt $(DEST_KMAP)/*.vim; \
+	fi
+
+# Install the icons for KDE, if the directory exists and the icon doesn't.
+# Always when $(DESTDIR) is not empty.
+ICON48PATH = $(DESTDIR)$(DATADIR)/icons/hicolor/48x48/apps
+ICON32PATH = $(DESTDIR)$(DATADIR)/icons/locolor/32x32/apps
+ICON16PATH = $(DESTDIR)$(DATADIR)/icons/locolor/16x16/apps
+ICONTHEMEPATH = $(DATADIR)/icons/hicolor
+DESKTOPPATH = $(DESTDIR)$(DATADIR)/applications
+KDEPATH = $(HOME)/.kde/share/icons
+install-icons:
+	if test -n "$(DESTDIR)"; then \
+		$(MKDIR_P) $(ICON48PATH) $(ICON32PATH) \
+		$(ICON16PATH) $(DESKTOPPATH); \
+	fi
+
+	if test -d $(ICON48PATH) -a -w $(ICON48PATH) \
+		-a ! -f $(ICON48PATH)/gvim.png; then \
+	   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim48x48.png $(ICON48PATH)/gvim.png; \
+	   if test -z "$(DESTDIR)" -a -x "$(GTK_UPDATE_ICON_CACHE)" \
+		   -a -w $(ICONTHEMEPATH) \
+		   -a -f $(ICONTHEMEPATH)/index.theme; then \
+		$(GTK_UPDATE_ICON_CACHE) -q $(ICONTHEMEPATH); \
+	   fi \
+	fi
+	if test -d $(ICON32PATH) -a -w $(ICON32PATH) \
+		-a ! -f $(ICON32PATH)/gvim.png; then \
+	   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim32x32.png $(ICON32PATH)/gvim.png; \
+	fi
+	if test -d $(ICON16PATH) -a -w $(ICON16PATH) \
+		-a ! -f $(ICON16PATH)/gvim.png; then \
+	   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim16x16.png $(ICON16PATH)/gvim.png; \
+	fi
+	if test -d $(DESKTOPPATH) -a -w $(DESKTOPPATH); then \
+	   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim.desktop \
+		$(SCRIPTSOURCE)/gvim.desktop \
+		$(DESKTOPPATH); \
+	   if test -z "$(DESTDIR)" -a -x "$(UPDATE_DESKTOP_DATABASE)"; then \
+	      $(UPDATE_DESKTOP_DATABASE) -q $(DESKTOPPATH); \
+	   fi \
+	fi
+
+$(HELPSOURCE)/vim.1 $(MACROSOURCE) $(TOOLSSOURCE):
+	@echo Runtime files not found.
+	@echo You need to unpack the runtime archive before running "make install".
+	test -f error
+
+$(DESTDIR)$(exec_prefix) $(DEST_BIN) \
+		$(DEST_VIM) $(DEST_RT) $(DEST_HELP) \
+		$(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) $(DEST_FTP) \
+		$(DEST_LANG) $(DEST_KMAP) $(DEST_COMP) $(DEST_MACRO) \
+		$(DEST_PACK) $(DEST_TOOLS) $(DEST_TUTOR) $(DEST_SPELL) \
+		$(DEST_AUTO) $(DEST_AUTO)/dist $(DEST_AUTO)/xml $(DEST_PLUG):
+	$(MKDIR_P) $@
+	-chmod $(DIRMOD) $@
+
+# create links from various names to vim.  This is only done when the links
+# (or executables with the same name) don't exist yet.
+installlinks: $(GUI_TARGETS) \
+			$(DEST_BIN)/$(EXTARGET) \
+			$(DEST_BIN)/$(VIEWTARGET) \
+			$(DEST_BIN)/$(RVIMTARGET) \
+			$(DEST_BIN)/$(RVIEWTARGET) \
+			$(INSTALLVIMDIFF)
+
+installglinks: $(DEST_BIN)/$(GVIMTARGET) \
+			$(DEST_BIN)/$(GVIEWTARGET) \
+			$(DEST_BIN)/$(RGVIMTARGET) \
+			$(DEST_BIN)/$(RGVIEWTARGET) \
+			$(DEST_BIN)/$(EVIMTARGET) \
+			$(DEST_BIN)/$(EVIEWTARGET) \
+			$(INSTALLGVIMDIFF)
+
+installvimdiff: $(DEST_BIN)/$(VIMDIFFTARGET)
+installgvimdiff: $(DEST_BIN)/$(GVIMDIFFTARGET)
+
+$(DEST_BIN)/$(EXTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(EXTARGET)
+
+$(DEST_BIN)/$(VIEWTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(VIEWTARGET)
+
+$(DEST_BIN)/$(GVIMTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIMTARGET)
+
+$(DEST_BIN)/$(GVIEWTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIEWTARGET)
+
+$(DEST_BIN)/$(RVIMTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(RVIMTARGET)
+
+$(DEST_BIN)/$(RVIEWTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(RVIEWTARGET)
+
+$(DEST_BIN)/$(RGVIMTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(RGVIMTARGET)
+
+$(DEST_BIN)/$(RGVIEWTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(RGVIEWTARGET)
+
+$(DEST_BIN)/$(VIMDIFFTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(VIMDIFFTARGET)
+
+$(DEST_BIN)/$(GVIMDIFFTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIMDIFFTARGET)
+
+$(DEST_BIN)/$(EVIMTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(EVIMTARGET)
+
+$(DEST_BIN)/$(EVIEWTARGET):
+	cd $(DEST_BIN); ln -s $(VIMTARGET) $(EVIEWTARGET)
+
+# Create links for the manual pages with various names to vim.	This is only
+# done when the links (or manpages with the same name) don't exist yet.
+
+INSTALLMLARGS = $(VIMNAME) $(VIMDIFFNAME) $(EVIMNAME) \
+		$(EXNAME) $(VIEWNAME) $(RVIMNAME) $(RVIEWNAME) \
+		$(GVIMNAME) $(GVIEWNAME) $(RGVIMNAME) $(RGVIEWNAME) \
+		$(GVIMDIFFNAME) $(EVIEWNAME)
+
+installmanlinks:
+	-$(SHELL) ./installml.sh install "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN) $(INSTALLMLARGS)
+
+uninstall: uninstall_runtime
+	-rm -f $(DEST_BIN)/$(VIMTARGET)
+	-rm -f $(DEST_BIN)/vimtutor
+	-rm -f $(DEST_BIN)/gvimtutor
+	-rm -f $(DEST_BIN)/$(EXTARGET) $(DEST_BIN)/$(VIEWTARGET)
+	-rm -f $(DEST_BIN)/$(GVIMTARGET) $(DEST_BIN)/$(GVIEWTARGET)
+	-rm -f $(DEST_BIN)/$(RVIMTARGET) $(DEST_BIN)/$(RVIEWTARGET)
+	-rm -f $(DEST_BIN)/$(RGVIMTARGET) $(DEST_BIN)/$(RGVIEWTARGET)
+	-rm -f $(DEST_BIN)/$(VIMDIFFTARGET) $(DEST_BIN)/$(GVIMDIFFTARGET)
+	-rm -f $(DEST_BIN)/$(EVIMTARGET) $(DEST_BIN)/$(EVIEWTARGET)
+	-rm -f $(DEST_BIN)/xxd$(EXEEXT)
+
+# Note: the "rmdir" will fail if any files were added after "make install"
+uninstall_runtime:
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_DA) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_DA_I) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_DA_U) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_DE) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_DE_I) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_DE_U) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR_I) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR_U) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT_I) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT_U) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_JA_U) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL_I) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL_U) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_RU) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installman.sh uninstall $(DEST_MAN_RU_U) "" $(INSTALLMANARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DA) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DA_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DA_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DE) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DE_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_DE_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_FR) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_FR_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_FR_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_IT) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_IT_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_IT_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_JA_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_PL) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_PL_I) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_PL_U) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_RU) $(INSTALLMLARGS)
+	-$(SHELL) ./installml.sh uninstall "$(GUI_MAN_TARGETS)" \
+		$(DEST_MAN_RU_U) $(INSTALLMLARGS)
+	-rm -f $(DEST_MAN)/xxd.1
+	-rm -f $(DEST_MAN_DA)/xxd.1 $(DEST_MAN_DA_I)/xxd.1 $(DEST_MAN_DA_U)/xxd.1
+	-rm -f $(DEST_MAN_DE)/xxd.1 $(DEST_MAN_DE_I)/xxd.1 $(DEST_MAN_DE_U)/xxd.1
+	-rm -f $(DEST_MAN_FR)/xxd.1 $(DEST_MAN_FR_I)/xxd.1 $(DEST_MAN_FR_U)/xxd.1
+	-rm -f $(DEST_MAN_IT)/xxd.1 $(DEST_MAN_IT_I)/xxd.1 $(DEST_MAN_IT_U)/xxd.1
+	-rm -f $(DEST_MAN_JA_U)/xxd.1
+	-rm -f $(DEST_MAN_PL)/xxd.1 $(DEST_MAN_PL_I)/xxd.1 $(DEST_MAN_PL_U)/xxd.1
+	-rm -f $(DEST_MAN_RU)/xxd.1 $(DEST_MAN_RU_U)/xxd.1
+	-rm -f $(DEST_HELP)/*.txt $(DEST_HELP)/tags $(DEST_HELP)/*.pl
+	-rm -f $(DEST_HELP)/*.??x $(DEST_HELP)/tags-??
+	-rm -f $(SYS_RGB_FILE)
+	-rm -f $(SYS_MENU_FILE) $(SYS_SYNMENU_FILE) $(SYS_DELMENU_FILE)
+	-rm -f $(SYS_BUGR_FILE) $(VIM_DEFAULTS_FILE) $(EVIM_FILE) $(MSWIN_FILE)
+	-rm -f $(DEST_SCRIPT)/gvimrc_example.vim $(DEST_SCRIPT)/vimrc_example.vim
+	-rm -f $(SYS_FILETYPE_FILE) $(SYS_FTOFF_FILE) $(SYS_SCRIPTS_FILE)
+	-rm -f $(SYS_INDOFF_FILE) $(SYS_INDENT_FILE)
+	-rm -f $(SYS_FTPLUGOF_FILE) $(SYS_FTPLUGIN_FILE)
+	-rm -f $(SYS_OPTWIN_FILE)
+	-rm -f $(DEST_COL)/*.vim $(DEST_COL)/README.txt
+	-rm -rf $(DEST_COL)/tools
+	-rm -f $(DEST_SYN)/*.vim $(DEST_SYN)/README.txt
+	-rm -f $(DEST_IND)/*.vim $(DEST_IND)/README.txt
+	-rm -rf $(DEST_MACRO)
+	-rm -rf $(DEST_PACK)
+	-rm -rf $(DEST_TUTOR)
+	-rm -rf $(DEST_SPELL)
+	-rm -rf $(DEST_TOOLS)
+	-rm -rf $(DEST_LANG)
+	-rm -rf $(DEST_KMAP)
+	-rm -rf $(DEST_COMP)
+	-rm -f $(DEST_PRINT)/*.ps
+	-rmdir $(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND)
+	-rm -rf $(DEST_FTP)/*.vim $(DEST_FTP)/README.txt $(DEST_FTP)/logtalk.dict
+	-rm -f $(DEST_AUTO)/*.vim $(DEST_AUTO)/README.txt
+	-rm -f $(DEST_AUTO)/dist/*.vim $(DEST_AUTO)/xml/*.vim
+	-rm -f $(DEST_PLUG)/*.vim $(DEST_PLUG)/README.txt
+	-rmdir $(DEST_FTP) $(DEST_AUTO)/dist $(DEST_AUTO)/xml $(DEST_AUTO)
+	-rmdir $(DEST_PLUG) $(DEST_RT)
+#	This will fail when other Vim versions are installed, no worries.
+	-rmdir $(DEST_VIM)
+
+# Clean up all the files that have been produced, except configure's.
+# We support common typing mistakes for Juergen! :-)
+clean celan: testclean
+	-rm -f *.o core $(VIMTARGET).core $(VIMTARGET) vim xxd/*.o
+	-rm -rf objects
+	-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c auto/gui_gtk_gresources.c auto/gui_gtk_gresources.h
+	-rm -f conftest* *~ auto/link.sed
+	-rm -f testdir/opt_test.vim
+	-rm -f $(UNITTEST_TARGETS)
+	-rm -f runtime pixmaps
+	-rm -rf $(APPDIR)
+	-rm -rf mzscheme_base.c
+	if test -d $(PODIR); then \
+		cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \
+	fi
+
+# Make a shadow directory for compilation on another system or with different
+# features.
+SHADOWDIR = shadow
+
+shadow:	runtime pixmaps
+	$(MKDIR_P) $(SHADOWDIR)
+	cd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../libvterm ../vimtutor ../gvimtutor ../install-sh ../Make_all.mak .
+	mkdir $(SHADOWDIR)/auto
+	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
+	$(MKDIR_P) $(SHADOWDIR)/po
+	cd $(SHADOWDIR)/po; ln -s ../../po/*.po ../../po/*.mak ../../po/*.vim ../../po/Makefile .
+	cd $(SHADOWDIR); rm -f auto/link.sed
+	cp Makefile configure $(SHADOWDIR)
+	rm -f $(SHADOWDIR)/auto/config.mk $(SHADOWDIR)/config.mk.dist
+	cp config.mk.dist $(SHADOWDIR)/auto/config.mk
+	cp config.mk.dist $(SHADOWDIR)
+	$(MKDIR_P) $(SHADOWDIR)/xxd
+	cd $(SHADOWDIR)/xxd; ln -s ../../xxd/*.[ch] ../../xxd/Make* .
+	if test -d $(RSRC_DIR); then \
+		cd $(SHADOWDIR); \
+		ln -s ../infplist.xml .; \
+		ln -s ../$(RSRC_DIR) ../os_mac.rsr.hqx ../dehqx.py .; \
+	fi
+	$(MKDIR_P) $(SHADOWDIR)/testdir
+	cd $(SHADOWDIR)/testdir; ln -s ../../testdir/Makefile \
+				 ../../testdir/Make_all.mak \
+				 ../../testdir/README.txt \
+				 ../../testdir/*.in \
+				 ../../testdir/*.vim \
+				 ../../testdir/*.py \
+				 ../../testdir/python* \
+				 ../../testdir/pyxfile \
+				 ../../testdir/sautest \
+				 ../../testdir/samples \
+				 ../../testdir/dumps \
+				 ../../testdir/test83-tags? \
+				 ../../testdir/*.ok .
+
+# Link needed for doing "make install" in a shadow directory.
+runtime:
+	-ln -s ../runtime .
+
+# Link needed for doing "make" using GTK in a shadow directory.
+pixmaps:
+	-ln -s ../pixmaps .
+
+# Update the synmenu.vim file with the latest Syntax menu.
+# This is only needed when runtime/makemenu.vim was changed.
+menu: ./vim ../runtime/makemenu.vim
+	./vim -u ../runtime/makemenu.vim
+
+# Start configure from scratch
+scrub scratch:
+	-rm -f auto/config.status auto/config.cache config.log auto/config.log
+	-rm -f auto/config.h auto/link.log auto/link.sed auto/config.mk
+	touch auto/config.h
+	cp config.mk.dist auto/config.mk
+
+distclean: clean scratch
+	-rm -f tags
+
+dist: distclean
+	@echo
+	@echo Making the distribution has to be done in the top directory
+
+mdepend:
+	-@rm -f Makefile~
+	cp Makefile Makefile~
+	sed -e '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@for i in $(ALL_SRC) ; do \
+	  echo "$$i" ; \
+	  echo `echo "$$i" | sed -e 's/[^ ]*\.c$$/objects\/\1.o/'`": $$i" `\
+	    $(CPP) $$i |\
+	    grep '^# .*"\./.*\.h"' |\
+	    sort -t'"' -u +1 -2 |\
+	    sed -e 's/.*"\.\/\(.*\)".*/\1/'\
+	    ` >> tmp_make ; \
+	done
+	mv tmp_make Makefile
+
+depend:
+	-@rm -f Makefile~
+	cp Makefile Makefile~
+	sed -e '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	-for i in $(ALL_SRC); do echo $$i; \
+		$(CPP_DEPEND) $$i | \
+		sed -e 's+^\([^ ]*\.o\)+objects/\1+' >> tmp_make; done
+	mv tmp_make Makefile
+
+# Run lint.  Clean up the *.ln files that are sometimes left behind.
+lint:
+	$(LINT) $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
+	-rm -f *.ln
+
+# Check dosinst.c with lint.
+lintinstall:
+	$(LINT) $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
+	-rm -f dosinst.ln
+
+###########################################################################
+
+.c.o:
+	$(CCC) $<
+
+auto/if_perl.c: if_perl.xs
+	$(PERL) -e 'unless ( $$] >= 5.005 ) { for (qw(na defgv errgv)) { print "#define PL_$$_ $$_\n" }}' > $@
+	$(PERL) $(PERL_XSUBPP) -prototypes -typemap \
+	    $(PERLLIB)/ExtUtils/typemap if_perl.xs >> $@
+
+auto/osdef.h: auto/config.h osdef.sh osdef1.h.in osdef2.h.in
+	CC="$(CC) $(OSDEF_CFLAGS)" srcdir=$(srcdir) sh $(srcdir)/osdef.sh
+
+auto/pathdef.c: Makefile auto/config.mk
+	-@echo creating $@
+	-@echo '/* pathdef.c */' > $@
+	-@echo '/* This file is automatically created by Makefile' >> $@
+	-@echo ' * DO NOT EDIT!  Change Makefile only. */' >> $@
+	-@echo '#include "vim.h"' >> $@
+	-@echo 'char_u *default_vim_dir = (char_u *)"$(VIMRCLOC)";' | $(QUOTESED) >> $@
+	-@echo 'char_u *default_vimruntime_dir = (char_u *)"$(VIMRUNTIMEDIR)";' | $(QUOTESED) >> $@
+	-@echo 'char_u *all_cflags = (char_u *)"$(CC) -c -I$(srcdir) $(ALL_CFLAGS)";' | $(QUOTESED) >>  $@
+	-@echo 'char_u *all_lflags = (char_u *)"$(CC) $(ALL_LIB_DIRS) $(LDFLAGS) -o $(VIMTARGET) $(ALL_LIBS) ";' | $(QUOTESED) >>  $@
+	-@echo 'char_u *compiled_user = (char_u *)"' | tr -d $(NL) >> $@
+	-@if test -n "$(COMPILEDBY)"; then \
+		echo "$(COMPILEDBY)" | tr -d $(NL) >> $@; \
+		else ((logname) 2>/dev/null || whoami) | tr -d $(NL) >> $@; fi
+	-@echo '";' >> $@
+	-@echo 'char_u *compiled_sys = (char_u *)"' | tr -d $(NL) >> $@
+	-@if test -z "$(COMPILEDBY)"; then hostname | tr -d $(NL) >> $@; fi
+	-@echo '";' >> $@
+	-@sh $(srcdir)/pathdef.sh
+
+GUI_GTK_RES_INPUTS = \
+	../pixmaps/stock_vim_build_tags.png \
+	../pixmaps/stock_vim_find_help.png \
+	../pixmaps/stock_vim_save_all.png \
+	../pixmaps/stock_vim_session_load.png \
+	../pixmaps/stock_vim_session_new.png \
+	../pixmaps/stock_vim_session_save.png \
+	../pixmaps/stock_vim_shell.png \
+	../pixmaps/stock_vim_window_maximize.png \
+	../pixmaps/stock_vim_window_maximize_width.png \
+	../pixmaps/stock_vim_window_minimize.png \
+	../pixmaps/stock_vim_window_minimize_width.png \
+	../pixmaps/stock_vim_window_split.png \
+	../pixmaps/stock_vim_window_split_vertical.png
+
+auto/gui_gtk_gresources.c: gui_gtk_res.xml $(GUI_GTK_RES_INPUTS)
+	$(GLIB_COMPILE_RESOURCES) --target=$@ --sourcedir=../pixmaps --generate --c-name=gui_gtk --manual-register gui_gtk_res.xml
+auto/gui_gtk_gresources.h: gui_gtk_res.xml $(GUI_GTK_RES_INPUTS)
+	if test -z "$(GLIB_COMPILE_RESOURCES)"; then touch $@; else \
+		$(GLIB_COMPILE_RESOURCES) --target=$@ --sourcedir=../pixmaps --generate --c-name=gui_gtk --manual-register gui_gtk_res.xml; \
+	fi
+
+# All the object files are put in the "objects" directory.  Since not all make
+# commands understand putting object files in another directory, it must be
+# specified for each file separately.
+
+objects: objects/.dirstamp
+
+objects/.dirstamp:
+	$(MKDIR_P) objects
+	touch objects/.dirstamp
+
+# All object files depend on the objects directory, so that parallel make
+# works.  Can't depend on the directory itself, its timestamp changes all the
+# time.
+$(ALL_OBJ): objects/.dirstamp
+
+objects/arabic.o: arabic.c
+	$(CCC) -o $@ arabic.c
+
+objects/blowfish.o: blowfish.c
+	$(CCC) -o $@ blowfish.c
+
+objects/buffer.o: buffer.c
+	$(CCC) -o $@ buffer.c
+
+objects/charset.o: charset.c
+	$(CCC) -o $@ charset.c
+
+objects/crypt.o: crypt.c
+	$(CCC) -o $@ crypt.c
+
+objects/crypt_zip.o: crypt_zip.c
+	$(CCC) -o $@ crypt_zip.c
+
+objects/dict.o: dict.c
+	$(CCC) -o $@ dict.c
+
+objects/diff.o: diff.c
+	$(CCC) -o $@ diff.c
+
+objects/digraph.o: digraph.c
+	$(CCC) -o $@ digraph.c
+
+objects/edit.o: edit.c
+	$(CCC) -o $@ edit.c
+
+objects/eval.o: eval.c
+	$(CCC) -o $@ eval.c
+
+objects/evalfunc.o: evalfunc.c
+	$(CCC) -o $@ evalfunc.c
+
+objects/ex_cmds.o: ex_cmds.c
+	$(CCC) -o $@ ex_cmds.c
+
+objects/ex_cmds2.o: ex_cmds2.c
+	$(CCC) -o $@ ex_cmds2.c
+
+objects/ex_docmd.o: ex_docmd.c
+	$(CCC) -o $@ ex_docmd.c
+
+objects/ex_eval.o: ex_eval.c
+	$(CCC) -o $@ ex_eval.c
+
+objects/ex_getln.o: ex_getln.c
+	$(CCC) -o $@ ex_getln.c
+
+objects/farsi.o: farsi.c
+	$(CCC) -o $@ farsi.c
+
+objects/fileio.o: fileio.c
+	$(CCC) -o $@ fileio.c
+
+objects/fold.o: fold.c
+	$(CCC) -o $@ fold.c
+
+objects/getchar.o: getchar.c
+	$(CCC) -o $@ getchar.c
+
+objects/hardcopy.o: hardcopy.c
+	$(CCC) -o $@ hardcopy.c
+
+objects/hashtab.o: hashtab.c
+	$(CCC) -o $@ hashtab.c
+
+objects/gui.o: gui.c
+	$(CCC) -o $@ gui.c
+
+objects/gui_at_fs.o: gui_at_fs.c
+	$(CCC) -o $@ gui_at_fs.c
+
+objects/gui_at_sb.o: gui_at_sb.c
+	$(CCC) -o $@ gui_at_sb.c
+
+objects/gui_athena.o: gui_athena.c
+	$(CCC) -o $@ gui_athena.c
+
+objects/beval.o: beval.c
+	$(CCC) -o $@ beval.c
+
+objects/gui_beval.o: gui_beval.c
+	$(CCC) -o $@ gui_beval.c
+
+objects/gui_gtk.o: gui_gtk.c
+	$(CCC) -o $@ gui_gtk.c
+
+objects/gui_gtk_f.o: gui_gtk_f.c
+	$(CCC) -o $@ gui_gtk_f.c
+
+objects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c
+	$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/gui_gtk_gresources.c
+
+objects/gui_gtk_x11.o: gui_gtk_x11.c
+	$(CCC) -o $@ gui_gtk_x11.c
+
+objects/gui_motif.o: gui_motif.c
+	$(CCC) -o $@ gui_motif.c
+
+objects/gui_xmdlg.o: gui_xmdlg.c
+	$(CCC) -o $@ gui_xmdlg.c
+
+objects/gui_xmebw.o: gui_xmebw.c
+	$(CCC) -o $@ gui_xmebw.c
+
+objects/gui_x11.o: gui_x11.c
+	$(CCC) -o $@ gui_x11.c
+
+objects/gui_photon.o: gui_photon.c
+	$(CCC) -o $@ gui_photon.c
+
+objects/gui_mac.o: gui_mac.c
+	$(CCC) -o $@ gui_mac.c
+
+objects/hangulin.o: hangulin.c
+	$(CCC) -o $@ hangulin.c
+
+objects/if_cscope.o: if_cscope.c
+	$(CCC) -o $@ if_cscope.c
+
+objects/if_xcmdsrv.o: if_xcmdsrv.c
+	$(CCC) -o $@ if_xcmdsrv.c
+
+objects/if_lua.o: if_lua.c
+	$(CCC_NF) $(LUA_CFLAGS) $(ALL_CFLAGS) -o $@ if_lua.c
+
+objects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)
+	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
+
+mzscheme_base.c:
+	$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base
+
+objects/if_perl.o: auto/if_perl.c
+	$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/if_perl.c
+
+objects/if_perlsfio.o: if_perlsfio.c
+	$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ if_perlsfio.c
+
+objects/if_python.o: if_python.c if_py_both.h
+	$(CCC_NF) $(PYTHON_CFLAGS) $(PYTHON_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python.c
+
+objects/if_python3.o: if_python3.c if_py_both.h
+	$(CCC_NF) $(PYTHON3_CFLAGS) $(PYTHON3_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python3.c
+
+objects/if_ruby.o: if_ruby.c
+	$(CCC_NF) $(RUBY_CFLAGS) $(ALL_CFLAGS) -o $@ if_ruby.c
+
+objects/if_tcl.o: if_tcl.c
+	$(CCC_NF) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ if_tcl.c
+
+objects/integration.o: integration.c
+	$(CCC) -o $@ integration.c
+
+objects/json.o: json.c
+	$(CCC) -o $@ json.c
+
+objects/json_test.o: json_test.c
+	$(CCC) -o $@ json_test.c
+
+objects/kword_test.o: kword_test.c
+	$(CCC) -o $@ kword_test.c
+
+objects/list.o: list.c
+	$(CCC) -o $@ list.c
+
+objects/main.o: main.c
+	$(CCC) -o $@ main.c
+
+objects/mark.o: mark.c
+	$(CCC) -o $@ mark.c
+
+objects/memfile.o: memfile.c
+	$(CCC) -o $@ memfile.c
+
+objects/memfile_test.o: memfile_test.c
+	$(CCC) -o $@ memfile_test.c
+
+objects/memline.o: memline.c
+	$(CCC) -o $@ memline.c
+
+objects/menu.o: menu.c
+	$(CCC) -o $@ menu.c
+
+objects/message.o: message.c
+	$(CCC) -o $@ message.c
+
+objects/message_test.o: message_test.c
+	$(CCC) -o $@ message_test.c
+
+objects/misc1.o: misc1.c
+	$(CCC) -o $@ misc1.c
+
+objects/misc2.o: misc2.c
+	$(CCC) -o $@ misc2.c
+
+objects/move.o: move.c
+	$(CCC) -o $@ move.c
+
+objects/mbyte.o: mbyte.c
+	$(CCC) -o $@ mbyte.c
+
+objects/normal.o: normal.c
+	$(CCC) -o $@ normal.c
+
+objects/ops.o: ops.c
+	$(CCC) -o $@ ops.c
+
+objects/option.o: option.c
+	$(CCC_NF) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(RUBY_CFLAGS) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ option.c
+
+objects/os_beos.o: os_beos.c
+	$(CCC) -o $@ os_beos.c
+
+objects/os_qnx.o: os_qnx.c
+	$(CCC) -o $@ os_qnx.c
+
+objects/os_macosx.o: os_macosx.m
+	$(CCC) -o $@ os_macosx.m
+
+objects/os_mac_conv.o: os_mac_conv.c
+	$(CCC) -o $@ os_mac_conv.c
+
+objects/os_unix.o: os_unix.c
+	$(CCC) -o $@ os_unix.c
+
+objects/os_mswin.o: os_mswin.c
+	$(CCC) -o $@ os_mswin.c
+
+objects/winclip.o: winclip.c
+	$(CCC) -o $@ winclip.c
+
+objects/pathdef.o: auto/pathdef.c
+	$(CCC) -o $@ auto/pathdef.c
+
+objects/popupmnu.o: popupmnu.c
+	$(CCC) -o $@ popupmnu.c
+
+objects/pty.o: pty.c
+	$(CCC) -o $@ pty.c
+
+objects/quickfix.o: quickfix.c
+	$(CCC) -o $@ quickfix.c
+
+objects/regexp.o: regexp.c regexp_nfa.c
+	$(CCC) -o $@ regexp.c
+
+objects/screen.o: screen.c
+	$(CCC) -o $@ screen.c
+
+objects/search.o: search.c
+	$(CCC) -o $@ search.c
+
+objects/sha256.o: sha256.c
+	$(CCC) -o $@ sha256.c
+
+objects/spell.o: spell.c
+	$(CCC) -o $@ spell.c
+
+objects/spellfile.o: spellfile.c
+	$(CCC) -o $@ spellfile.c
+
+objects/syntax.o: syntax.c
+	$(CCC) -o $@ syntax.c
+
+objects/tag.o: tag.c
+	$(CCC) -o $@ tag.c
+
+objects/term.o: term.c
+	$(CCC) -o $@ term.c
+
+objects/terminal.o: terminal.c $(TERM_DEPS)
+	$(CCC) -o $@ terminal.c
+
+objects/ui.o: ui.c
+	$(CCC) -o $@ ui.c
+
+objects/undo.o: undo.c
+	$(CCC) -o $@ undo.c
+
+objects/userfunc.o: userfunc.c
+	$(CCC) -o $@ userfunc.c
+
+objects/window.o: window.c
+	$(CCC) -o $@ window.c
+
+objects/workshop.o: workshop.c
+	$(CCC) -o $@ workshop.c
+
+objects/wsdebug.o: wsdebug.c
+	$(CCC) -o $@ wsdebug.c
+
+objects/netbeans.o: netbeans.c
+	$(CCC) -o $@ netbeans.c
+
+objects/channel.o: channel.c
+	$(CCC) -o $@ channel.c
+
+Makefile:
+	@echo The name of the makefile MUST be "Makefile" (with capital M)!!!!
+
+CCCTERM = $(CCC_NF) -Ilibvterm/include $(ALL_CFLAGS) -DINLINE="" \
+	  -DVSNPRINTF=vim_vsnprintf \
+	  -DIS_COMBINING_FUNCTION=utf_iscomposing_uint \
+	  -DWCWIDTH_FUNCTION=utf_uint2cells
+
+objects/term_encoding.o: libvterm/src/encoding.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/encoding.c
+
+objects/term_keyboard.o: libvterm/src/keyboard.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/keyboard.c
+
+objects/term_mouse.o: libvterm/src/mouse.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/mouse.c
+
+objects/term_parser.o: libvterm/src/parser.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/parser.c
+
+objects/term_pen.o: libvterm/src/pen.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/pen.c
+
+objects/term_screen.o: libvterm/src/screen.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/screen.c
+
+objects/term_state.o: libvterm/src/state.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/state.c
+
+objects/term_unicode.o: libvterm/src/unicode.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/unicode.c
+
+objects/term_vterm.o: libvterm/src/vterm.c $(TERM_DEPS)
+	$(CCCTERM) -o $@ libvterm/src/vterm.c
+
+###############################################################################
+### MacOS X installation
+###
+### This installs a runnable Vim.app in $(prefix)
+
+REZ    = /Developer/Tools/Rez
+RESDIR = $(APPDIR)/Contents/Resources
+VERSION = $(VIMMAJOR).$(VIMMINOR)
+
+### Common flags
+M4FLAGSX = $(M4FLAGS) -DAPP_EXE=$(VIMNAME) -DAPP_NAME=$(VIMNAME) \
+		-DAPP_VER=$(VERSION)
+
+install_macosx: gui_bundle
+# Remove the link to the runtime dir, don't want to copy all of that.
+	-rm $(RESDIR)/vim/runtime
+	$(INSTALL_DATA_R) $(APPDIR) $(DESTDIR)$(prefix)
+# Generate the help tags file now, it won't work with "make installruntime".
+	-@srcdir=`pwd`; cd $(HELPSOURCE); $(MAKE) VIMEXE=$$srcdir/$(VIMTARGET) vimtags
+# Install the runtime files.  Recursive!
+	$(MKDIR_P) $(DESTDIR)$(prefix)/$(RESDIR)/vim/runtime
+	srcdir=`pwd`; $(MAKE) -f Makefile installruntime \
+		VIMEXE=$$srcdir/$(VIMTARGET) \
+		prefix=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR) \
+		exec_prefix=$(DESTDIR)$(prefix)/$(APPDIR)/Contents \
+		BINDIR=$(DESTDIR)$(prefix)/$(APPDIR)/Contents/MacOS \
+		VIMLOC=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR) \
+		VIMRTLOC=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR)/runtime
+# Put the link back.
+	ln -s `pwd`/../runtime $(RESDIR)/vim
+# Copy rgb.txt, Mac doesn't always have X11
+	$(INSTALL_DATA) $(SCRIPTSOURCE)/rgb.txt $(DESTDIR)$(prefix)/$(RESDIR)/vim/runtime
+# TODO: Create the vimtutor and/or gvimtutor application.
+
+gui_bundle: $(RESDIR) bundle-dir bundle-executable bundle-info bundle-resource \
+	bundle-language
+
+$(RESDIR):
+	$(MKDIR_P) $@
+
+bundle-dir: $(APPDIR)/Contents $(VIMTARGET)
+# Make a link to the runtime directory, so that we can try out the executable
+# without installing it.
+	$(MKDIR_P) $(RESDIR)/vim
+	-ln -s `pwd`/../runtime $(RESDIR)/vim
+
+bundle-executable: $(VIMTARGET)
+	$(MKDIR_P) $(APPDIR)/Contents/MacOS
+	cp $(VIMTARGET) $(APPDIR)/Contents/MacOS/$(VIMTARGET)
+
+bundle-info:  bundle-dir
+	@echo "Creating PkgInfo"
+	@echo -n "APPLVIM!" > $(APPDIR)/Contents/PkgInfo
+	@echo "Creating Info.plist"
+	m4 $(M4FLAGSX) infplist.xml > $(APPDIR)/Contents/Info.plist
+
+bundle-resource: bundle-dir bundle-rsrc
+	cp -f $(RSRC_DIR)/*.icns $(RESDIR)
+
+### Classic resources
+# Resource fork (in the form of a .rsrc file) for Classic Vim (Mac OS 9)
+# This file is also required for OS X Vim.
+bundle-rsrc: os_mac.rsr.hqx
+	@echo "Creating resource fork"
+	python dehqx.py $<
+	rm -f gui_mac.rsrc
+	mv gui_mac.rsrc.rsrcfork $(RESDIR)/$(VIMNAME).rsrc
+
+# po/Make_osx.pl says something about generating a Mac message file
+# for Ukrainian.  Would somebody using Mac OS X in Ukrainian
+# *really* be upset that Carbon Vim was not localised in
+# Ukrainian?
+#
+#bundle-language: bundle-dir po/Make_osx.pl
+#	cd po && perl Make_osx.pl --outdir ../$(RESDIR) $(MULTILANG)
+bundle-language: bundle-dir
+
+$(APPDIR)/Contents:
+	$(MKDIR_P) $(APPDIR)/Contents/MacOS
+	$(MKDIR_P) $(RESDIR)/English.lproj
+
+
+###############################################################################
+### (automatically generated by 'make depend')
+### Dependencies:
+objects/arabic.o: arabic.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/beval.o: beval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/blowfish.o: blowfish.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/buffer.o: buffer.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h version.h
+objects/charset.o: charset.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/crypt.o: crypt.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/crypt_zip.o: crypt_zip.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/dict.o: dict.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/diff.o: diff.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/digraph.o: digraph.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/edit.o: edit.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/eval.o: eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h version.h
+objects/evalfunc.o: evalfunc.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h version.h
+objects/ex_cmds.o: ex_cmds.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h version.h
+objects/ex_cmds2.o: ex_cmds2.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h version.h
+objects/ex_docmd.o: ex_docmd.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h ex_cmdidxs.h
+objects/ex_eval.o: ex_eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/ex_getln.o: ex_getln.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/farsi.o: farsi.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/fileio.o: fileio.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/fold.o: fold.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/getchar.o: getchar.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/hardcopy.o: hardcopy.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h version.h
+objects/hashtab.o: hashtab.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/if_cscope.o: if_cscope.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h if_cscope.h
+objects/if_xcmdsrv.o: if_xcmdsrv.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h version.h
+objects/json.o: json.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/list.o: list.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/main.o: main.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/mark.o: mark.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/memfile.o: memfile.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/memline.o: memline.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/menu.o: menu.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/message.o: message.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/misc1.o: misc1.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h version.h
+objects/misc2.o: misc2.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/move.o: move.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/mbyte.o: mbyte.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/normal.o: normal.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/ops.o: ops.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
+ keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
+ regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
+ arabic.h
+objects/option.o: option.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/os_unix.o: os_unix.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h if_mzsch.h os_unixx.h
+objects/pathdef.o: auto/pathdef.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/popupmnu.o: popupmnu.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/pty.o: pty.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
+ keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
+ regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
+ arabic.h
+objects/quickfix.o: quickfix.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/regexp.o: regexp.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h regexp_nfa.c
+objects/screen.o: screen.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/search.o: search.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/sha256.o: sha256.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/spell.o: spell.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/spellfile.o: spellfile.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/syntax.o: syntax.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/tag.o: tag.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
+ keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
+ regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
+ arabic.h
+objects/term.o: term.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h libvterm/include/vterm.h \
+ libvterm/include/vterm_keycodes.h
+objects/terminal.o: terminal.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h libvterm/include/vterm.h \
+ libvterm/include/vterm_keycodes.h
+objects/ui.o: ui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
+ keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
+ regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
+ arabic.h
+objects/undo.o: undo.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/userfunc.o: userfunc.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/version.o: version.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h version.h
+objects/window.o: window.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/gui.o: gui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
+ keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
+ regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
+ arabic.h
+objects/gui_gtk.o: gui_gtk.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h gui_gtk_f.h
+objects/gui_gtk_f.o: gui_gtk_f.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h gui_gtk_f.h
+objects/gui_motif.o: gui_motif.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h gui_xmebw.h ../pixmaps/alert.xpm \
+ ../pixmaps/error.xpm ../pixmaps/generic.xpm ../pixmaps/info.xpm \
+ ../pixmaps/quest.xpm gui_x11_pm.h ../pixmaps/tb_new.xpm \
+ ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm ../pixmaps/tb_save.xpm \
+ ../pixmaps/tb_print.xpm ../pixmaps/tb_cut.xpm ../pixmaps/tb_copy.xpm \
+ ../pixmaps/tb_paste.xpm ../pixmaps/tb_find.xpm \
+ ../pixmaps/tb_find_next.xpm ../pixmaps/tb_find_prev.xpm \
+ ../pixmaps/tb_find_help.xpm ../pixmaps/tb_exit.xpm \
+ ../pixmaps/tb_undo.xpm ../pixmaps/tb_redo.xpm ../pixmaps/tb_help.xpm \
+ ../pixmaps/tb_macro.xpm ../pixmaps/tb_make.xpm \
+ ../pixmaps/tb_save_all.xpm ../pixmaps/tb_jump.xpm \
+ ../pixmaps/tb_ctags.xpm ../pixmaps/tb_load_session.xpm \
+ ../pixmaps/tb_save_session.xpm ../pixmaps/tb_new_session.xpm \
+ ../pixmaps/tb_blank.xpm ../pixmaps/tb_maximize.xpm \
+ ../pixmaps/tb_split.xpm ../pixmaps/tb_minimize.xpm \
+ ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \
+ ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \
+ ../pixmaps/tb_minwidth.xpm
+objects/gui_xmdlg.o: gui_xmdlg.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/gui_xmebw.o: gui_xmebw.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h gui_xmebwp.h gui_xmebw.h
+objects/gui_athena.o: gui_athena.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h gui_at_sb.h gui_x11_pm.h \
+ ../pixmaps/tb_new.xpm ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm \
+ ../pixmaps/tb_save.xpm ../pixmaps/tb_print.xpm ../pixmaps/tb_cut.xpm \
+ ../pixmaps/tb_copy.xpm ../pixmaps/tb_paste.xpm ../pixmaps/tb_find.xpm \
+ ../pixmaps/tb_find_next.xpm ../pixmaps/tb_find_prev.xpm \
+ ../pixmaps/tb_find_help.xpm ../pixmaps/tb_exit.xpm \
+ ../pixmaps/tb_undo.xpm ../pixmaps/tb_redo.xpm ../pixmaps/tb_help.xpm \
+ ../pixmaps/tb_macro.xpm ../pixmaps/tb_make.xpm \
+ ../pixmaps/tb_save_all.xpm ../pixmaps/tb_jump.xpm \
+ ../pixmaps/tb_ctags.xpm ../pixmaps/tb_load_session.xpm \
+ ../pixmaps/tb_save_session.xpm ../pixmaps/tb_new_session.xpm \
+ ../pixmaps/tb_blank.xpm ../pixmaps/tb_maximize.xpm \
+ ../pixmaps/tb_split.xpm ../pixmaps/tb_minimize.xpm \
+ ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \
+ ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \
+ ../pixmaps/tb_minwidth.xpm
+objects/gui_gtk_x11.o: gui_gtk_x11.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h auto/gui_gtk_gresources.h gui_gtk_f.h \
+ ../runtime/vim32x32.xpm ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm
+objects/gui_x11.o: gui_x11.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h ../runtime/vim32x32.xpm ../runtime/vim16x16.xpm \
+ ../runtime/vim48x48.xpm
+objects/gui_at_sb.o: gui_at_sb.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h gui_at_sb.h
+objects/gui_at_fs.o: gui_at_fs.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h gui_at_sb.h
+objects/json_test.o: json_test.c main.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h json.c
+objects/kword_test.o: kword_test.c main.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h charset.c
+objects/memfile_test.o: memfile_test.c main.c vim.h auto/config.h feature.h \
+ os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h memfile.c
+objects/message_test.o: message_test.c main.c vim.h auto/config.h feature.h \
+ os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h message.c
+objects/hangulin.o: hangulin.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/if_lua.o: if_lua.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/if_mzsch.o: if_mzsch.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h if_mzsch.h mzscheme_base.c
+objects/if_perl.o: auto/if_perl.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/if_perlsfio.o: if_perlsfio.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/if_python.o: if_python.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h if_py_both.h
+objects/if_python3.o: if_python3.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h if_py_both.h
+objects/if_tcl.o: if_tcl.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/if_ruby.o: if_ruby.c auto/config.h vim.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h version.h
+objects/gui_beval.o: gui_beval.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h
+objects/workshop.o: workshop.c auto/config.h integration.h vim.h feature.h \
+ os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h version.h workshop.h
+objects/wsdebug.o: wsdebug.c
+objects/integration.o: integration.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h integration.h
+objects/netbeans.o: netbeans.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+ proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+ proto.h globals.h farsi.h arabic.h version.h
+objects/channel.o: channel.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
+ structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
+ farsi.h arabic.h
+objects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c
diff --git a/src/configure.ac b/src/configure.ac
index 8994f3c..3dac6cc 100644
--- a/src/configure.ac
+++ b/src/configure.ac
@@ -154,6 +154,12 @@ case `uname` in
     *)		BEOS=no; AC_MSG_RESULT(no);;
 esac
 
+AC_MSG_CHECKING(for Haiku)
+case `uname` in
+    Haiku)	HAIKU=yes; AC_MSG_RESULT(yes);;
+    *)		HAIKU=no; AC_MSG_RESULT(no);;
+esac
+
 dnl If QNX is found, assume we don't want to use Xphoton
 dnl unless it was specifically asked for (--with-x)
 AC_MSG_CHECKING(for QNX)
@@ -2043,7 +2049,11 @@ fi
 
 if test "$enable_channel" = "yes"; then
   dnl On Solaris we need the socket and nsl library.
-  AC_CHECK_LIB(socket, socket)
+  if test "x$HAIKU" = "xyes"; then
+    AC_CHECK_LIB(network, socket)
+  else
+    AC_CHECK_LIB(socket, socket)
+  fi
   AC_CHECK_LIB(nsl, gethostbyname)
   AC_MSG_CHECKING(whether compiling with process communication is possible)
   AC_TRY_LINK([
@@ -2294,11 +2304,11 @@ if test "x$with_x" = xno -a "x$with_x_arg" = xyes; then
     AC_MSG_ERROR([could not configure X])
 fi
 
-test "x$with_x" = xno -a "x$MACOS_X" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
+test "x$with_x" = xno -a "x$HAIKU" != "xyes" -a "x$MACOS_X" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
 
 AC_MSG_CHECKING(--enable-gui argument)
 AC_ARG_ENABLE(gui,
- [  --enable-gui[=OPTS]       X11 GUI. [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
+ [  --enable-gui[=OPTS]       X11 GUI. [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/haiku/photon/carbon]], , enable_gui="auto")
 
 dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
 dnl Do not use character classes for portability with old tools.
@@ -2313,10 +2323,23 @@ SKIP_MOTIF=YES
 SKIP_ATHENA=YES
 SKIP_NEXTAW=YES
 SKIP_PHOTON=YES
+SKIP_HAIKU=YES
 SKIP_CARBON=YES
 GUITYPE=NONE
 
-if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
+if test "x$HAIKU" = "xyes"; then
+  SKIP_HAIKU=
+  case "$enable_gui_canon" in
+    no)		AC_MSG_RESULT(no GUI support)
+		SKIP_HAIKU=YES ;;
+    yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
+    auto)	AC_MSG_RESULT(auto - automatic GUI support) ;;
+    haiku)	AC_MSG_RESULT(Haiku GUI support) ;;
+    *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
+		SKIP_HAIKU=YES ;;
+  esac
+
+elif test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
   SKIP_PHOTON=
   case "$enable_gui_canon" in
     no)		AC_MSG_RESULT(no GUI support)
@@ -2480,6 +2503,7 @@ if test "x$MACOS_X" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
   SKIP_ATHENA=YES;
   SKIP_NEXTAW=YES;
   SKIP_PHOTON=YES;
+  SKIP_HAIKU=YES;
   SKIP_CARBON=YES
 fi
 
@@ -3095,6 +3119,11 @@ if test "x$GUITYPE:$enable_fontset" = "xGTK:yes"; then
   enable_fontset="no"
 fi
 
+dnl There is no test for the Haiku GUI, if it's selected it's used
+if test -z "$SKIP_HAIKU"; then
+  GUITYPE=HAIKUGUI
+fi
+
 if test -z "$SKIP_PHOTON"; then
   GUITYPE=PHOTONGUI
 fi
diff --git a/b/src/configure.ac.orig b/src/configure.ac.orig
new file mode 100644
index 0000000..8994f3c
--- /dev/null
+++ b/src/configure.ac.orig
@@ -0,0 +1,4466 @@
+dnl configure.ac: autoconf script for Vim
+
+dnl Process this file with autoconf 2.12 or 2.13 to produce "configure".
+dnl Should also work with autoconf 2.54 and later.
+
+AC_INIT(vim.h)
+AC_CONFIG_HEADER(auto/config.h:config.h.in)
+
+dnl Being able to run configure means the system is Unix (compatible).
+AC_DEFINE(UNIX)
+AC_PROG_MAKE_SET
+
+dnl Checks for programs.
+AC_PROG_CC_C99		dnl required by almost everything
+AC_PROG_CPP		dnl required by header file checks
+AC_PROGRAM_EGREP	dnl required by AC_EGREP_CPP
+AC_PROG_FGREP		dnl finds working grep -F
+AC_ISC_POSIX		dnl required by AC_C_CROSS
+AC_PROG_AWK		dnl required for "make html" in ../doc
+
+dnl Don't strip if we don't have it
+AC_CHECK_PROG(STRIP, strip, strip, :)
+
+dnl Check for extension of executables
+AC_EXEEXT
+
+dnl Check for standard headers.  We don't use this in Vim but other stuff
+dnl in autoconf needs it, where it uses STDC_HEADERS.
+AC_HEADER_STDC
+AC_HEADER_SYS_WAIT
+
+dnl Check that the C99 features that Vim uses are supported:
+if test x"$ac_cv_prog_cc_c99" != xno; then
+  dnl If the compiler doesn't explicitly support C99, then check
+  dnl for the specific features Vim uses
+
+  AC_TYPE_LONG_LONG_INT
+  if test "$ac_cv_type_long_long_int" = no; then
+    AC_MSG_FAILURE([Compiler does not support long long int])
+  fi
+
+  AC_MSG_CHECKING([if the compiler supports trailing commas])
+  trailing_commas=no
+  AC_TRY_COMPILE([], [
+    enum {
+      one,
+    };],
+    [AC_MSG_RESULT(yes); trailing_commas=yes],
+    [AC_MSG_RESULT(no)])
+  if test "$trailing_commas" = no; then
+    AC_MSG_FAILURE([Compiler does not support trailing comma in enum])
+  fi
+
+  AC_MSG_CHECKING([if the compiler supports C++ comments])
+  slash_comments=no
+  AC_TRY_COMPILE([],
+    [// C++ comments?],
+    [AC_MSG_RESULT(yes); slash_comments=yes],
+    [AC_MSG_RESULT(no)])
+  if test "$slash_comments" = no; then
+    AC_MSG_FAILURE([Compiler does not support C++ comments])
+  fi
+fi
+
+dnl Check for the flag that fails if stuff are missing.
+
+AC_MSG_CHECKING(--enable-fail-if-missing argument)
+AC_ARG_ENABLE(fail_if_missing,
+	[  --enable-fail-if-missing    Fail if dependencies on additional features
+     specified on the command line are missing.], 
+	[fail_if_missing="yes"],
+	[fail_if_missing="no"])
+AC_MSG_RESULT($fail_if_missing)
+
+dnl Keep original value to check later.
+with_x_arg="$with_x"
+
+dnl Set default value for CFLAGS if none is defined or it's empty
+if test -z "$CFLAGS"; then
+  CFLAGS="-O"
+  test "$GCC" = yes && CFLAGS="-O2 -fno-strength-reduce -Wall"
+fi
+if test "$GCC" = yes; then
+  dnl method that should work for nearly all versions
+  gccversion=`$CC -dumpversion`
+  if test "x$gccversion" = "x"; then
+    dnl old method; fall-back for when -dumpversion doesn't work
+    gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\([[0-9]]\.[[0-9.]]*\).*$/\1/g'`
+  fi
+  dnl version 4.0.1 was reported to cause trouble on Macintosh by Marcin Dalecki
+  if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
+    echo 'GCC [[34]].0.[[12]] has a bug in the optimizer, disabling "-O#"'
+    CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-O/'`
+  else
+    if test "$gccversion" = "3.1" -o "$gccversion" = "3.2" -o "$gccversion" = "3.2.1" && `echo "$CFLAGS" | grep -v fno-strength-reduce >/dev/null`; then
+      echo 'GCC 3.1 and 3.2 have a bug in the optimizer, adding "-fno-strength-reduce"'
+      CFLAGS="$CFLAGS -fno-strength-reduce"
+    fi
+  fi
+fi
+
+dnl clang-500.2.75 or around has abandoned -f[no-]strength-reduce and issues a
+dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
+dnl the version number of the clang in use.
+dnl Note that this does not work to get the version of clang 3.1 or 3.2.
+AC_MSG_CHECKING(for clang version)
+CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang[[^0-9]]*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
+if test x"$CLANG_VERSION_STRING" != x"" ; then
+  CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
+  CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
+  CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)/\1/p'`
+  CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
+  AC_MSG_RESULT($CLANG_VERSION)
+  dnl If you find the same issue with versions earlier than 500.2.75,
+  dnl change the constant 500002075 below appropriately.  To get the
+  dnl integer corresponding to a version number, refer to the
+  dnl definition of CLANG_VERSION above.
+  AC_MSG_CHECKING(if clang supports -fno-strength-reduce)
+  if test "$CLANG_VERSION" -ge 500002075 ; then
+    AC_MSG_RESULT(no)
+    CFLAGS=`echo "$CFLAGS" | sed -e 's/-fno-strength-reduce/ /'`
+  else
+    AC_MSG_RESULT(yes)
+  fi
+else
+  AC_MSG_RESULT(N/A)
+fi
+
+dnl If configure thinks we are cross compiling, there might be something
+dnl wrong with the CC or CFLAGS settings, give a useful warning message
+CROSS_COMPILING=
+if test "$cross_compiling" = yes; then
+  AC_MSG_RESULT([cannot compile a simple program; if not cross compiling check CC and CFLAGS])
+  CROSS_COMPILING=1
+fi
+AC_SUBST(CROSS_COMPILING)
+
+dnl gcc-cpp has the wonderful -MM option to produce nicer dependencies.
+dnl But gcc 3.1 changed the meaning!  See near the end.
+test "$GCC" = yes && CPP_MM=M; AC_SUBST(CPP_MM)
+
+if test -f ./toolcheck; then
+  AC_CHECKING(for buggy tools)
+  sh ./toolcheck 1>&AC_FD_MSG
+fi
+
+OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
+
+dnl Check for BeOS, which needs an extra source file
+AC_MSG_CHECKING(for BeOS)
+case `uname` in
+    BeOS)	OS_EXTRA_SRC=os_beos.c; OS_EXTRA_OBJ=objects/os_beos.o
+		BEOS=yes; AC_MSG_RESULT(yes);;
+    *)		BEOS=no; AC_MSG_RESULT(no);;
+esac
+
+dnl If QNX is found, assume we don't want to use Xphoton
+dnl unless it was specifically asked for (--with-x)
+AC_MSG_CHECKING(for QNX)
+case `uname` in
+    QNX)	OS_EXTRA_SRC=os_qnx.c; OS_EXTRA_OBJ=objects/os_qnx.o
+		test -z "$with_x" && with_x=no
+		QNX=yes; AC_MSG_RESULT(yes);;
+    *)		QNX=no; AC_MSG_RESULT(no);;
+esac
+
+dnl Check for Darwin and MacOS X
+dnl We do a check for MacOS X in the very beginning because there
+dnl are a lot of other things we need to change besides GUI stuff
+AC_MSG_CHECKING([for Darwin (Mac OS X)])
+if test "`(uname) 2>/dev/null`" = Darwin; then
+  AC_MSG_RESULT(yes)
+  MACOS_X=yes
+  CPPFLAGS="$CPPFLAGS -DMACOS_X"
+
+  AC_MSG_CHECKING(--disable-darwin argument)
+  AC_ARG_ENABLE(darwin,
+	  [  --disable-darwin        Disable Darwin (Mac OS X) support.],
+	  , [enable_darwin="yes"])
+  if test "$enable_darwin" = "yes"; then
+    AC_MSG_RESULT(no)
+    AC_MSG_CHECKING(if Darwin files are there)
+    if test -f os_macosx.m; then
+      AC_MSG_RESULT(yes)
+    else
+      AC_MSG_RESULT([no, Darwin support disabled])
+      enable_darwin=no
+    fi
+  else
+    AC_MSG_RESULT([yes, Darwin support excluded])
+  fi
+
+  AC_MSG_CHECKING(--with-mac-arch argument)
+  AC_ARG_WITH(mac-arch, [  --with-mac-arch=ARCH    current, intel, ppc or both],
+	MACARCH="$withval"; AC_MSG_RESULT($MACARCH),
+	MACARCH="current"; AC_MSG_RESULT(defaulting to $MACARCH))
+
+  AC_MSG_CHECKING(--with-developer-dir argument)
+  AC_ARG_WITH(developer-dir, [  --with-developer-dir=PATH    use PATH as location for Xcode developer tools],
+	DEVELOPER_DIR="$withval"; AC_MSG_RESULT($DEVELOPER_DIR),
+        AC_MSG_RESULT(not present))
+  
+  if test "x$DEVELOPER_DIR" = "x"; then
+    AC_PATH_PROG(XCODE_SELECT, xcode-select)
+    if test "x$XCODE_SELECT" != "x"; then
+      AC_MSG_CHECKING(for developer dir using xcode-select)
+      DEVELOPER_DIR=`$XCODE_SELECT -print-path`
+      AC_MSG_RESULT([$DEVELOPER_DIR])
+    else
+      DEVELOPER_DIR=/Developer
+    fi
+  fi
+
+  if test "x$MACARCH" = "xboth"; then
+    AC_MSG_CHECKING(for 10.4 universal SDK)
+    dnl There is a terrible inconsistency (but we appear to get away with it):
+    dnl $CFLAGS uses the 10.4u SDK library for the headers, while $CPPFLAGS
+    dnl doesn't, because "gcc -E" doesn't grok it.  That means the configure
+    dnl tests using the preprocessor are actually done with the wrong header
+    dnl files. $LDFLAGS is set at the end, because configure uses it together
+    dnl with $CFLAGS and we can only have one -sysroot argument.
+    save_cppflags="$CPPFLAGS"
+    save_cflags="$CFLAGS"
+    save_ldflags="$LDFLAGS"
+    CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+    AC_TRY_LINK([ ], [ ],
+	AC_MSG_RESULT(found, will make universal binary),
+
+	AC_MSG_RESULT(not found)
+	CFLAGS="$save_cflags"
+	AC_MSG_CHECKING(if Intel architecture is supported)
+	CPPFLAGS="$CPPFLAGS -arch i386"
+	LDFLAGS="$save_ldflags -arch i386"
+	AC_TRY_LINK([ ], [ ],
+	    AC_MSG_RESULT(yes); MACARCH="intel",
+	    AC_MSG_RESULT(no, using PowerPC)
+		MACARCH="ppc"
+		CPPFLAGS="$save_cppflags -arch ppc"
+		LDFLAGS="$save_ldflags -arch ppc"))
+  elif test "x$MACARCH" = "xintel"; then
+    CPPFLAGS="$CPPFLAGS -arch intel"
+    LDFLAGS="$LDFLAGS -arch intel"
+  elif test "x$MACARCH" = "xppc"; then
+    CPPFLAGS="$CPPFLAGS -arch ppc"
+    LDFLAGS="$LDFLAGS -arch ppc"
+  fi
+
+  if test "$enable_darwin" = "yes"; then
+    MACOS_X_DARWIN=yes
+    OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
+    OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
+    dnl TODO: use -arch i386 on Intel machines
+    dnl Removed -no-cpp-precomp, only for very old compilers.
+    CPPFLAGS="$CPPFLAGS -DMACOS_X_DARWIN"
+
+    dnl If Carbon is found, assume we don't want X11
+    dnl unless it was specifically asked for (--with-x)
+    dnl or Motif, Athena or GTK GUI is used.
+    AC_CHECK_HEADER(Carbon/Carbon.h, CARBON=yes)
+    if test "x$CARBON" = "xyes"; then
+      if test -z "$with_x" -a "X$enable_gui" != Xmotif -a "X$enable_gui" != Xathena -a "X$enable_gui" != Xgtk2 -a "X$enable_gui" != Xgtk3; then
+	with_x=no
+      fi
+    fi
+  fi
+
+  dnl Avoid a bug with -O2 with gcc 4.0.1.  Symptom: malloc() reports double
+  dnl free.  This happens in expand_filename(), because the optimizer swaps
+  dnl two blocks of code, both using "repl", that can't be swapped.
+  if test "$MACARCH" = "intel" -o "$MACARCH" = "both"; then
+    CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-Oz/'`
+  fi
+
+else
+  AC_MSG_RESULT(no)
+fi
+
+dnl Mac OS X 10.9+ no longer include AvailabilityMacros.h in Carbon
+dnl so we need to include it to have access to version macros.
+AC_CHECK_HEADERS(AvailabilityMacros.h)
+
+AC_SUBST(OS_EXTRA_SRC)
+AC_SUBST(OS_EXTRA_OBJ)
+
+dnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.
+dnl Only when the directory exists and it wasn't there yet.
+dnl For gcc don't do this when it is already in the default search path.
+dnl Skip all of this when cross-compiling.
+if test "$cross_compiling" = no; then
+  AC_MSG_CHECKING(--with-local-dir argument)
+  have_local_include=''
+  have_local_lib=''
+  AC_ARG_WITH([local-dir], [  --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.
+  --without-local-dir     do not search /usr/local for local libraries.], [
+    local_dir="$withval"
+    case "$withval" in
+    */*) ;;
+    no)
+      # avoid adding local dir to LDFLAGS and CPPFLAGS
+      have_local_include=yes
+      have_local_lib=yes
+      ;;
+    *) AC_MSG_ERROR(must pass path argument to --with-local-dir) ;;
+    esac
+	AC_MSG_RESULT($local_dir)
+  ], [
+    local_dir=/usr/local
+    AC_MSG_RESULT(Defaulting to $local_dir)
+  ])
+  if test "$GCC" = yes -a "$local_dir" != no; then
+    echo 'void f(){}' > conftest.c
+    dnl Removed -no-cpp-precomp, only needed for OS X 10.2 (Ben Fowler)
+    have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
+    have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
+    rm -f conftest.c conftest.o
+  fi
+  if test -z "$have_local_lib" -a -d "${local_dir}/lib"; then
+    tt=`echo "$LDFLAGS" | sed -e "s+-L${local_dir}/lib ++g" -e "s+-L${local_dir}/lib$++g"`
+    if test "$tt" = "$LDFLAGS"; then
+      LDFLAGS="$LDFLAGS -L${local_dir}/lib"
+    fi
+  fi
+  if test -z "$have_local_include" -a -d "${local_dir}/include"; then
+    tt=`echo "$CPPFLAGS" | sed -e "s+-I${local_dir}/include ++g" -e "s+-I${local_dir}/include$++g"`
+    if test "$tt" = "$CPPFLAGS"; then
+      CPPFLAGS="$CPPFLAGS -I${local_dir}/include"
+    fi
+  fi
+fi
+
+AC_MSG_CHECKING(--with-vim-name argument)
+AC_ARG_WITH(vim-name, [  --with-vim-name=NAME    what to call the Vim executable],
+	VIMNAME="$withval"; AC_MSG_RESULT($VIMNAME),
+	VIMNAME="vim"; AC_MSG_RESULT(Defaulting to $VIMNAME))
+AC_SUBST(VIMNAME)
+AC_MSG_CHECKING(--with-ex-name argument)
+AC_ARG_WITH(ex-name, [  --with-ex-name=NAME     what to call the Ex executable],
+	EXNAME="$withval"; AC_MSG_RESULT($EXNAME),
+	EXNAME="ex"; AC_MSG_RESULT(Defaulting to ex))
+AC_SUBST(EXNAME)
+AC_MSG_CHECKING(--with-view-name argument)
+AC_ARG_WITH(view-name, [  --with-view-name=NAME   what to call the View executable],
+	VIEWNAME="$withval"; AC_MSG_RESULT($VIEWNAME),
+	VIEWNAME="view"; AC_MSG_RESULT(Defaulting to view))
+AC_SUBST(VIEWNAME)
+
+AC_MSG_CHECKING(--with-global-runtime argument)
+AC_ARG_WITH(global-runtime, [  --with-global-runtime=DIR    global runtime directory in 'runtimepath'],
+	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(RUNTIME_GLOBAL, "$withval"),
+	AC_MSG_RESULT(no))
+
+AC_MSG_CHECKING(--with-modified-by argument)
+AC_ARG_WITH(modified-by, [  --with-modified-by=NAME       name of who modified a release version],
+	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(MODIFIED_BY, "$withval"),
+	AC_MSG_RESULT(no))
+
+dnl Check for EBCDIC stolen from the LYNX port to z/OS Unix
+AC_MSG_CHECKING(if character set is EBCDIC)
+AC_TRY_COMPILE([ ],
+[ /* TryCompile function for CharSet.
+   Treat any failure as ASCII for compatibility with existing art.
+   Use compile-time rather than run-time tests for cross-compiler
+   tolerance.  */
+#if '0'!=240
+make an error "Character set is not EBCDIC"
+#endif ],
+[ # TryCompile action if true
+cf_cv_ebcdic=yes ],
+[ # TryCompile action if false
+cf_cv_ebcdic=no])
+# end of TryCompile ])
+# end of CacheVal CvEbcdic
+AC_MSG_RESULT($cf_cv_ebcdic)
+case "$cf_cv_ebcdic" in  #(vi
+    yes)	AC_DEFINE(EBCDIC)
+		line_break='"\\n"'
+		;;
+    *)		line_break='"\\012"';;
+esac
+AC_SUBST(line_break)
+
+if test "$cf_cv_ebcdic" = "yes"; then
+dnl If we have EBCDIC we most likely have z/OS Unix, let's test it!
+AC_MSG_CHECKING(for z/OS Unix)
+case `uname` in
+    OS/390)	zOSUnix="yes";
+		dnl If using cc the environment variable _CC_CCMODE must be
+		dnl set to "1", so that some compiler extensions are enabled.
+		dnl If using c89 the environment variable is named _CC_C89MODE.
+		dnl Note: compile with c89 never tested.
+		if test "$CC" = "cc"; then
+		  ccm="$_CC_CCMODE"
+		  ccn="CC"
+		else
+		  if test "$CC" = "c89"; then
+		    ccm="$_CC_C89MODE"
+		    ccn="C89"
+		  else
+		    ccm=1
+		  fi
+		fi
+		if test "$ccm" != "1"; then
+		  echo ""
+		  echo "------------------------------------------"
+		  echo " On z/OS Unix, the environment variable"
+		  echo " _CC_${ccn}MODE must be set to \"1\"!"
+		  echo " Do:"
+		  echo "    export _CC_${ccn}MODE=1"
+		  echo " and then call configure again."
+		  echo "------------------------------------------"
+		  exit 1
+		fi
+		# Set CFLAGS for configure process.
+		# This will be reset later for config.mk.
+		# Use haltonmsg to force error for missing H files.
+		CFLAGS="$CFLAGS -D_ALL_SOURCE -Wc,float(ieee),haltonmsg(3296)";
+		LDFLAGS="$LDFLAGS -Wl,EDIT=NO"
+		AC_MSG_RESULT(yes)
+		;;
+    *)		zOSUnix="no";
+		AC_MSG_RESULT(no)
+		;;
+esac
+fi
+
+dnl Set QUOTESED. Needs additional backslashes on zOS
+if test "$zOSUnix" = "yes"; then
+    QUOTESED="sed -e 's/[[\\\\\"]]/\\\\\\\\&/g' -e 's/\\\\\\\\\"/\"/' -e 's/\\\\\\\\\";\$\$/\";/'"
+else
+    QUOTESED="sed -e 's/[[\\\\\"]]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";\$\$/\";/'"
+fi
+AC_SUBST(QUOTESED)
+
+
+dnl Link with -lsmack for Smack stuff; if not found
+AC_MSG_CHECKING(--disable-smack argument)
+AC_ARG_ENABLE(smack,
+	[  --disable-smack	  Do not check for Smack support.],
+	, enable_smack="yes")
+if test "$enable_smack" = "yes"; then
+  AC_MSG_RESULT(no)
+  AC_CHECK_HEADER([linux/xattr.h], true, enable_smack="no")
+else
+  AC_MSG_RESULT(yes)
+fi
+if test "$enable_smack" = "yes"; then
+  AC_CHECK_HEADER([attr/xattr.h], true, enable_smack="no")
+fi
+if test "$enable_smack" = "yes"; then
+  AC_MSG_CHECKING(for XATTR_NAME_SMACKEXEC in linux/xattr.h)
+  AC_EGREP_CPP(XATTR_NAME_SMACKEXEC, [#include <linux/xattr.h>],
+	       AC_MSG_RESULT(yes),
+	       AC_MSG_RESULT(no); enable_smack="no")
+fi
+if test "$enable_smack" = "yes"; then
+  AC_CHECK_LIB(attr, setxattr,
+	  [LIBS="$LIBS -lattr"
+	   found_smack="yes"
+	   AC_DEFINE(HAVE_SMACK)])
+fi
+
+dnl When smack was found don't search for SELinux
+if test "x$found_smack" = "x"; then
+  dnl Link with -lselinux for SELinux stuff; if not found
+  AC_MSG_CHECKING(--disable-selinux argument)
+  AC_ARG_ENABLE(selinux,
+	  [  --disable-selinux	  Do not check for SELinux support.],
+	  , enable_selinux="yes")
+  if test "$enable_selinux" = "yes"; then
+    AC_MSG_RESULT(no)
+    AC_CHECK_LIB(selinux, is_selinux_enabled,
+	[AC_CHECK_HEADER(selinux/selinux.h,
+	    [LIBS="$LIBS -lselinux"
+	    AC_DEFINE(HAVE_SELINUX)])])
+  else
+     AC_MSG_RESULT(yes)
+  fi
+fi
+
+dnl Check user requested features.
+
+AC_MSG_CHECKING(--with-features argument)
+AC_ARG_WITH(features, [  --with-features=TYPE    tiny, small, normal, big or huge (default: huge)],
+	features="$withval"; AC_MSG_RESULT($features),
+	features="huge"; AC_MSG_RESULT(Defaulting to huge))
+
+dovimdiff=""
+dogvimdiff=""
+case "$features" in
+  tiny)		AC_DEFINE(FEAT_TINY) ;;
+  small)	AC_DEFINE(FEAT_SMALL) ;;
+  normal)	AC_DEFINE(FEAT_NORMAL) dovimdiff="installvimdiff";
+			dogvimdiff="installgvimdiff" ;;
+  big)		AC_DEFINE(FEAT_BIG) dovimdiff="installvimdiff";
+			dogvimdiff="installgvimdiff" ;;
+  huge)		AC_DEFINE(FEAT_HUGE) dovimdiff="installvimdiff";
+			dogvimdiff="installgvimdiff" ;;
+  *)		AC_MSG_RESULT([Sorry, $features is not supported]) ;;
+esac
+
+AC_SUBST(dovimdiff)
+AC_SUBST(dogvimdiff)
+
+AC_MSG_CHECKING(--with-compiledby argument)
+AC_ARG_WITH(compiledby, [  --with-compiledby=NAME  name to show in :version message],
+	compiledby="$withval"; AC_MSG_RESULT($withval),
+	compiledby=""; AC_MSG_RESULT(no))
+AC_SUBST(compiledby)
+
+AC_MSG_CHECKING(--disable-xsmp argument)
+AC_ARG_ENABLE(xsmp,
+	[  --disable-xsmp          Disable XSMP session management],
+	, enable_xsmp="yes")
+
+if test "$enable_xsmp" = "yes"; then
+  AC_MSG_RESULT(no)
+  AC_MSG_CHECKING(--disable-xsmp-interact argument)
+  AC_ARG_ENABLE(xsmp-interact,
+	  [  --disable-xsmp-interact Disable XSMP interaction],
+	  , enable_xsmp_interact="yes")
+  if test "$enable_xsmp_interact" = "yes"; then
+    AC_MSG_RESULT(no)
+    AC_DEFINE(USE_XSMP_INTERACT)
+  else
+    AC_MSG_RESULT(yes)
+  fi
+else
+  AC_MSG_RESULT(yes)
+fi
+
+dnl Check for Lua feature.
+AC_MSG_CHECKING(--enable-luainterp argument)
+AC_ARG_ENABLE(luainterp,
+	[  --enable-luainterp[=OPTS]      Include Lua interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+	[enable_luainterp="no"])
+AC_MSG_RESULT($enable_luainterp)
+
+if test "$enable_luainterp" = "yes" -o "$enable_luainterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_ERROR([cannot use Lua with tiny or small features])
+  fi
+
+  dnl -- find the lua executable
+  AC_SUBST(vi_cv_path_lua)
+
+  AC_MSG_CHECKING(--with-lua-prefix argument)
+  AC_ARG_WITH(lua_prefix,
+	[  --with-lua-prefix=PFX   Prefix where Lua is installed.],
+	with_lua_prefix="$withval"; AC_MSG_RESULT($with_lua_prefix),
+	with_lua_prefix="";AC_MSG_RESULT(no))
+
+  if test "X$with_lua_prefix" != "X"; then
+       vi_cv_path_lua_pfx="$with_lua_prefix"
+  else
+    AC_MSG_CHECKING(LUA_PREFIX environment var)
+    if test "X$LUA_PREFIX" != "X"; then
+	AC_MSG_RESULT("$LUA_PREFIX")
+	vi_cv_path_lua_pfx="$LUA_PREFIX"
+    else
+	AC_MSG_RESULT([not set, default to /usr])
+	vi_cv_path_lua_pfx="/usr"
+    fi
+  fi
+
+  AC_MSG_CHECKING(--with-luajit)
+  AC_ARG_WITH(luajit,
+	[  --with-luajit           Link with LuaJIT instead of Lua.],
+	[vi_cv_with_luajit="$withval"],
+	[vi_cv_with_luajit="no"])
+  AC_MSG_RESULT($vi_cv_with_luajit)
+
+  LUA_INC=
+  if test "X$vi_cv_path_lua_pfx" != "X"; then
+    if test "x$vi_cv_with_luajit" != "xno"; then
+      dnl -- try to find LuaJIT executable
+      AC_PATH_PROG(vi_cv_path_luajit, luajit)
+      if test "X$vi_cv_path_luajit" != "X"; then
+	dnl -- find LuaJIT version
+	AC_CACHE_CHECK(LuaJIT version, vi_cv_version_luajit,
+	[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([[0-9.]]*\)\.[[0-9]]\(-[[a-z0-9]]*\)* .*/\1/'` ])
+	AC_CACHE_CHECK(Lua version of LuaJIT, vi_cv_version_lua_luajit,
+	[ vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'` ])
+	vi_cv_path_lua="$vi_cv_path_luajit"
+	vi_cv_version_lua="$vi_cv_version_lua_luajit"
+      fi
+    else
+      dnl -- try to find Lua executable
+      AC_PATH_PROG(vi_cv_path_plain_lua, lua)
+      if test "X$vi_cv_path_plain_lua" != "X"; then
+	dnl -- find Lua version
+	AC_CACHE_CHECK(Lua version, vi_cv_version_plain_lua,
+	[ vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e "print(_VERSION)" | sed 's/.* //'` ])
+      fi
+      vi_cv_path_lua="$vi_cv_path_plain_lua"
+      vi_cv_version_lua="$vi_cv_version_plain_lua"
+    fi
+    if test "x$vi_cv_with_luajit" != "xno" && test "X$vi_cv_version_luajit" != "X"; then
+      AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit)
+      if test -f "$vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit/lua.h"; then
+	AC_MSG_RESULT(yes)
+	LUA_INC=/luajit-$vi_cv_version_luajit
+      fi
+    fi
+    if test "X$LUA_INC" = "X"; then
+      AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include)
+      if test -f "$vi_cv_path_lua_pfx/include/lua.h"; then
+	AC_MSG_RESULT(yes)
+      else
+	AC_MSG_RESULT(no)
+	AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua)
+	if test -f "$vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua/lua.h"; then
+	  AC_MSG_RESULT(yes)
+	  LUA_INC=/lua$vi_cv_version_lua
+	else
+	  AC_MSG_RESULT(no)
+	  vi_cv_path_lua_pfx=
+	fi
+      fi
+    fi
+  fi
+
+  if test "X$vi_cv_path_lua_pfx" != "X"; then
+    if test "x$vi_cv_with_luajit" != "xno"; then
+      multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+      if test "X$multiarch" != "X"; then
+	lib_multiarch="lib/${multiarch}"
+      else
+	lib_multiarch="lib"
+      fi
+      if test "X$vi_cv_version_lua" = "X"; then
+	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit"
+      else
+	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit-$vi_cv_version_lua"
+      fi
+    else
+      if test "X$LUA_INC" != "X"; then
+	dnl Test alternate location using version
+	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua$vi_cv_version_lua"
+      else
+	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua"
+      fi
+    fi
+    if test "$enable_luainterp" = "dynamic"; then
+      lua_ok="yes"
+    else
+      AC_MSG_CHECKING([if link with ${LUA_LIBS} is sane])
+      libs_save=$LIBS
+      LIBS="$LIBS $LUA_LIBS"
+      AC_TRY_LINK(,[ ],
+	AC_MSG_RESULT(yes); lua_ok="yes",
+	AC_MSG_RESULT(no); lua_ok="no"; LUA_LIBS="")
+      LIBS=$libs_save
+    fi
+    if test "x$lua_ok" = "xyes"; then
+      LUA_CFLAGS="-I${vi_cv_path_lua_pfx}/include${LUA_INC}"
+      LUA_SRC="if_lua.c"
+      LUA_OBJ="objects/if_lua.o"
+      LUA_PRO="if_lua.pro"
+      AC_DEFINE(FEAT_LUA)
+    fi
+    if test "$enable_luainterp" = "dynamic"; then
+      if test "x$vi_cv_with_luajit" != "xno"; then
+	luajit="jit"
+      fi
+      if test -f "${vi_cv_path_lua_pfx}/bin/cyglua-${vi_cv_version_lua}.dll"; then
+	vi_cv_dll_name_lua="cyglua-${vi_cv_version_lua}.dll"
+      else
+	if test "x$MACOS_X" = "xyes"; then
+	  ext="dylib"
+	  indexes=""
+	else
+	  ext="so"
+	  indexes=".0 .1 .2 .3 .4 .5 .6 .7 .8 .9"
+	  multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+	  if test "X$multiarch" != "X"; then
+	    lib_multiarch="lib/${multiarch}"
+	  fi
+	fi
+	dnl Determine the sover for the current version, but fallback to
+	dnl liblua${vi_cv_version_lua}.so if no sover-versioned file is found.
+	AC_MSG_CHECKING(if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx)
+	for subdir in "${lib_multiarch}" lib64 lib; do
+	  if test -z "$subdir"; then
+	    continue
+	  fi
+	  for sover in "${vi_cv_version_lua}.${ext}" "-${vi_cv_version_lua}.${ext}" \
+	    ".${vi_cv_version_lua}.${ext}" ".${ext}.${vi_cv_version_lua}"; do
+	    for i in $indexes ""; do
+	      if test -f "${vi_cv_path_lua_pfx}/${subdir}/liblua${luajit}${sover}$i"; then
+		sover2="$i"
+		break 3
+	      fi
+	    done
+	  done
+	  sover=""
+	done
+	if test "X$sover" = "X"; then
+	  AC_MSG_RESULT(no)
+	  lua_ok="no"
+	  vi_cv_dll_name_lua="liblua${luajit}.${ext}"
+	else
+	  AC_MSG_RESULT(yes)
+	  lua_ok="yes"
+	  vi_cv_dll_name_lua="liblua${luajit}${sover}$sover2"
+	fi
+      fi
+      AC_DEFINE(DYNAMIC_LUA)
+      LUA_LIBS=""
+      LUA_CFLAGS="-DDYNAMIC_LUA_DLL=\\\"${vi_cv_dll_name_lua}\\\" $LUA_CFLAGS"
+    fi
+    if test "X$LUA_CFLAGS$LUA_LIBS" != "X" && \
+       test "x$MACOS_X" = "xyes" && test "x$vi_cv_with_luajit" != "xno" && \
+       test "`(uname -m) 2>/dev/null`" = "x86_64"; then
+      dnl OSX/x64 requires these flags. See http://luajit.org/install.html
+      LUA_LIBS="-pagezero_size 10000 -image_base 100000000 $LUA_LIBS"
+    fi
+  fi
+  if test "$fail_if_missing" = "yes" -a "$lua_ok" != "yes"; then
+    AC_MSG_ERROR([could not configure lua])
+  fi
+  AC_SUBST(LUA_SRC)
+  AC_SUBST(LUA_OBJ)
+  AC_SUBST(LUA_PRO)
+  AC_SUBST(LUA_LIBS)
+  AC_SUBST(LUA_CFLAGS)
+fi
+
+
+dnl Check for MzScheme feature.
+AC_MSG_CHECKING(--enable-mzschemeinterp argument)
+AC_ARG_ENABLE(mzschemeinterp,
+	[  --enable-mzschemeinterp      Include MzScheme interpreter.], ,
+	[enable_mzschemeinterp="no"])
+AC_MSG_RESULT($enable_mzschemeinterp)
+
+if test "$enable_mzschemeinterp" = "yes"; then
+  dnl -- find the mzscheme executable
+  AC_SUBST(vi_cv_path_mzscheme)
+
+  AC_MSG_CHECKING(--with-plthome argument)
+  AC_ARG_WITH(plthome,
+	[  --with-plthome=PLTHOME   Use PLTHOME.],
+	with_plthome="$withval"; AC_MSG_RESULT($with_plthome),
+	with_plthome="";AC_MSG_RESULT("no"))
+
+  if test "X$with_plthome" != "X"; then
+       vi_cv_path_mzscheme_pfx="$with_plthome"
+       vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+  else
+    AC_MSG_CHECKING(PLTHOME environment var)
+    if test "X$PLTHOME" != "X"; then
+	AC_MSG_RESULT("$PLTHOME")
+	vi_cv_path_mzscheme_pfx="$PLTHOME"
+	vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+    else
+	AC_MSG_RESULT(not set)
+	dnl -- try to find MzScheme executable
+	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
+
+	dnl resolve symbolic link, the executable is often elsewhere and there
+	dnl are no links for the include files.
+	if test "X$vi_cv_path_mzscheme" != "X"; then
+	  lsout=`ls -l $vi_cv_path_mzscheme`
+	  if echo "$lsout" | grep -e '->' >/dev/null 2>/dev/null; then
+	    vi_cv_path_mzscheme=`echo "$lsout" | sed 's/.*-> \(.*\)/\1/'`
+	  fi
+	fi
+
+	if test "X$vi_cv_path_mzscheme" != "X"; then
+	    dnl -- find where MzScheme thinks it was installed
+	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
+	    dnl different versions of MzScheme differ in command line processing
+	    dnl use universal approach
+	    echo "(display (simplify-path		\
+	       (build-path (call-with-values	\
+		(lambda () (split-path (find-system-path (quote exec-file)))) \
+		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+	    dnl Remove a trailing slash
+	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+		sed -e 's+/$++'` ])
+	    rm -f mzdirs.scm
+	fi
+    fi
+  fi
+
+  if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+    AC_MSG_CHECKING(for racket include directory)
+    SCHEME_INC=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-include-dir))) (when (path? p) (display p)))'`
+    if test "X$SCHEME_INC" != "X"; then
+      AC_MSG_RESULT(${SCHEME_INC})
+    else
+      AC_MSG_RESULT(not found)
+      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
+      if test -f "$vi_cv_path_mzscheme_pfx/include/scheme.h"; then
+	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+	AC_MSG_RESULT(yes)
+      else
+	AC_MSG_RESULT(no)
+	AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
+	if test -f "$vi_cv_path_mzscheme_pfx/include/plt/scheme.h"; then
+	  AC_MSG_RESULT(yes)
+	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
+	else
+	  AC_MSG_RESULT(no)
+	  AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)
+	  if test -f "$vi_cv_path_mzscheme_pfx/include/racket/scheme.h"; then
+	    AC_MSG_RESULT(yes)
+	    SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
+	  else
+	    AC_MSG_RESULT(no)
+	    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
+	    if test -f /usr/include/plt/scheme.h; then
+	      AC_MSG_RESULT(yes)
+	      SCHEME_INC=/usr/include/plt
+	    else
+	      AC_MSG_RESULT(no)
+	      AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)
+	      if test -f /usr/include/racket/scheme.h; then
+		AC_MSG_RESULT(yes)
+		SCHEME_INC=/usr/include/racket
+	      else
+		AC_MSG_RESULT(no)
+		vi_cv_path_mzscheme_pfx=
+	      fi
+	    fi
+	  fi
+	fi
+      fi
+    fi
+  fi
+
+  if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+
+    AC_MSG_CHECKING(for racket lib directory)
+    SCHEME_LIB=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-lib-dir))) (when (path? p) (display p)))'`
+    if test "X$SCHEME_LIB" != "X"; then
+      AC_MSG_RESULT(${SCHEME_LIB})
+    else
+      AC_MSG_RESULT(not found)
+    fi
+
+    for path in "${vi_cv_path_mzscheme_pfx}/lib" "${SCHEME_LIB}"; do
+      if test "X$path" != "X"; then
+	if test "x$MACOS_X" = "xyes"; then
+	  MZSCHEME_LIBS="-framework Racket"
+	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	elif test -f "${path}/libmzscheme3m.a"; then
+	  MZSCHEME_LIBS="${path}/libmzscheme3m.a"
+	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	elif test -f "${path}/libracket3m.a"; then
+	  MZSCHEME_LIBS="${path}/libracket3m.a"
+	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	elif test -f "${path}/libracket.a"; then
+	  MZSCHEME_LIBS="${path}/libracket.a ${path}/libmzgc.a"
+	elif test -f "${path}/libmzscheme.a"; then
+	  MZSCHEME_LIBS="${path}/libmzscheme.a ${path}/libmzgc.a"
+	else
+	  dnl Using shared objects
+	  if test -f "${path}/libmzscheme3m.so"; then
+	    MZSCHEME_LIBS="-L${path} -lmzscheme3m"
+	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	  elif test -f "${path}/libracket3m.so"; then
+	    MZSCHEME_LIBS="-L${path} -lracket3m"
+	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	  elif test -f "${path}/libracket.so"; then
+	    MZSCHEME_LIBS="-L${path} -lracket -lmzgc"
+	  else
+	    dnl try next until last
+	    if test "$path" != "$SCHEME_LIB"; then
+	      continue
+	    fi
+	    MZSCHEME_LIBS="-L${path} -lmzscheme -lmzgc"
+	  fi
+	  if test "$GCC" = yes; then
+	    dnl Make Vim remember the path to the library.  For when it's not in
+	    dnl $LD_LIBRARY_PATH.
+	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${path}"
+	  elif test "`(uname) 2>/dev/null`" = SunOS &&
+				   uname -r | grep '^5' >/dev/null; then
+	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${path}"
+	  fi
+	fi
+      fi
+      if test "X$MZSCHEME_LIBS" != "X"; then
+	break
+      fi
+    done
+
+    AC_MSG_CHECKING([if racket requires -pthread])
+    if test "X$SCHEME_LIB" != "X" && $FGREP -e -pthread "$SCHEME_LIB/buildinfo" >/dev/null ; then
+      AC_MSG_RESULT(yes)
+      MZSCHEME_LIBS="${MZSCHEME_LIBS} -pthread"
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -pthread"
+    else
+      AC_MSG_RESULT(no)
+    fi
+
+    AC_MSG_CHECKING(for racket config directory)
+    SCHEME_CONFIGDIR=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-config-dir))) (when (path? p) (display p)))'`
+    if test "X$SCHEME_CONFIGDIR" != "X"; then
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DMZSCHEME_CONFIGDIR='\"${SCHEME_CONFIGDIR}\"'"
+      AC_MSG_RESULT(${SCHEME_CONFIGDIR})
+    else
+      AC_MSG_RESULT(not found)
+    fi
+
+    AC_MSG_CHECKING(for racket collects directory)
+    SCHEME_COLLECTS=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-collects-dir))) (when (path? p) (let-values (((base _1 _2) (split-path p))) (display base))))'`
+    if test "X$SCHEME_COLLECTS" = "X"; then
+      if test -d "$vi_cv_path_mzscheme_pfx/lib/plt/collects"; then
+	SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/plt/
+      else
+	if test -d "$vi_cv_path_mzscheme_pfx/lib/racket/collects"; then
+	  SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/racket/
+	else
+	  if test -d "$vi_cv_path_mzscheme_pfx/share/racket/collects"; then
+	    SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/share/racket/
+	  else
+	    if test -d "$vi_cv_path_mzscheme_pfx/collects"; then
+	      SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/
+	    fi
+	  fi
+	fi
+      fi
+    fi
+    if test "X$SCHEME_COLLECTS" != "X" ; then
+      AC_MSG_RESULT(${SCHEME_COLLECTS})
+    else
+      AC_MSG_RESULT(not found)
+    fi
+
+    AC_MSG_CHECKING(for mzscheme_base.c)
+    if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+      MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+      MZSCHEME_MOD="++lib scheme/base"
+    else
+      if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+	MZSCHEME_EXTRA="mzscheme_base.c"
+	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+	MZSCHEME_MOD="++lib scheme/base"
+      else
+	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
+	  MZSCHEME_EXTRA="mzscheme_base.c"
+	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
+	  MZSCHEME_MOD=""
+	fi
+      fi
+    fi
+    if test "X$MZSCHEME_EXTRA" != "X" ; then
+      dnl need to generate bytecode for MzScheme base
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      AC_MSG_RESULT(needed)
+    else
+      AC_MSG_RESULT(not needed)
+    fi
+
+    dnl On Ubuntu this fixes "undefined reference to symbol 'ffi_type_void'".
+    AC_CHECK_LIB(ffi, ffi_type_void, [MZSCHEME_LIBS="$MZSCHEME_LIBS -lffi"])
+
+    MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
+      -DMZSCHEME_COLLECTS='\"${SCHEME_COLLECTS}collects\"'"
+
+    dnl Test that we can compile a simple program with these CFLAGS and LIBS.
+    AC_MSG_CHECKING([if compile and link flags for MzScheme are sane])
+    cflags_save=$CFLAGS
+    libs_save=$LIBS
+    CFLAGS="$CFLAGS $MZSCHEME_CFLAGS"
+    LIBS="$LIBS $MZSCHEME_LIBS"
+    AC_TRY_LINK(,[ ],
+	   AC_MSG_RESULT(yes); mzs_ok=yes,
+	   AC_MSG_RESULT(no: MZSCHEME DISABLED); mzs_ok=no)
+    CFLAGS=$cflags_save
+    LIBS=$libs_save
+    if test $mzs_ok = yes; then
+      MZSCHEME_SRC="if_mzsch.c"
+      MZSCHEME_OBJ="objects/if_mzsch.o"
+      MZSCHEME_PRO="if_mzsch.pro"
+      AC_DEFINE(FEAT_MZSCHEME)
+    else
+      MZSCHEME_CFLAGS=
+      MZSCHEME_LIBS=
+      MZSCHEME_EXTRA=
+      MZSCHEME_MZC=
+    fi
+  fi
+  AC_SUBST(MZSCHEME_SRC)
+  AC_SUBST(MZSCHEME_OBJ)
+  AC_SUBST(MZSCHEME_PRO)
+  AC_SUBST(MZSCHEME_LIBS)
+  AC_SUBST(MZSCHEME_CFLAGS)
+  AC_SUBST(MZSCHEME_EXTRA)
+  AC_SUBST(MZSCHEME_MZC)
+fi
+
+
+AC_MSG_CHECKING(--enable-perlinterp argument)
+AC_ARG_ENABLE(perlinterp,
+	[  --enable-perlinterp[=OPTS]     Include Perl interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+	[enable_perlinterp="no"])
+AC_MSG_RESULT($enable_perlinterp)
+if test "$enable_perlinterp" = "yes" -o "$enable_perlinterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_ERROR([cannot use Perl with tiny or small features])
+  fi
+  AC_SUBST(vi_cv_path_perl)
+  AC_PATH_PROG(vi_cv_path_perl, perl)
+  if test "X$vi_cv_path_perl" != "X"; then
+    AC_MSG_CHECKING(Perl version)
+    if $vi_cv_path_perl -e 'require 5.003_01' >/dev/null 2>/dev/null; then
+     eval `$vi_cv_path_perl -V:usethreads`
+     eval `$vi_cv_path_perl -V:libperl`
+     if test "X$usethreads" = "XUNKNOWN" -o "X$usethreads" = "Xundef"; then
+       badthreads=no
+     else
+       if $vi_cv_path_perl -e 'require 5.6.0' >/dev/null 2>/dev/null; then
+	 eval `$vi_cv_path_perl -V:use5005threads`
+	 if test "X$use5005threads" = "XUNKNOWN" -o "X$use5005threads" = "Xundef"; then
+	   badthreads=no
+	 else
+	   badthreads=yes
+	   AC_MSG_RESULT(>>> Perl > 5.6 with 5.5 threads cannot be used <<<)
+	 fi
+       else
+	 badthreads=yes
+	 AC_MSG_RESULT(>>> Perl 5.5 with threads cannot be used <<<)
+       fi
+     fi
+     if test $badthreads = no; then
+      AC_MSG_RESULT(OK)
+      eval `$vi_cv_path_perl -V:shrpenv`
+      if test "X$shrpenv" = "XUNKNOWN"; then # pre 5.003_04
+	shrpenv=""
+      fi
+      vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
+      AC_SUBST(vi_cv_perllib)
+      vi_cv_perl_extutils=unknown_perl_extutils_path
+      for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
+	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
+	if test -f "$xsubpp_path"; then
+	  vi_cv_perl_xsubpp="$xsubpp_path"
+	fi
+      done
+      AC_SUBST(vi_cv_perl_xsubpp)
+      dnl Remove "-fno-something", it breaks using cproto.
+      dnl Remove "-fdebug-prefix-map", it isn't supported by clang.
+      dnl Remove "FORTIFY_SOURCE", it will be defined twice.
+      dnl remove -pipe and -Wxxx, it confuses cproto
+      perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
+		-e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[[^ ]]*//' \
+		-e 's/-fdebug-prefix-map[[^ ]]*//g' \
+		-e 's/-pipe //' \
+		-e 's/-W[[^ ]]*//g' \
+		-e 's/-D_FORTIFY_SOURCE=.//g'`
+      dnl Remove "-lc", it breaks on FreeBSD when using "-pthread".
+      perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \
+		sed -e '/Warning/d' -e '/Note (probably harmless)/d' \
+			-e 's/-bE:perl.exp//' -e 's/-lc //'`
+      dnl Don't add perl lib to $LIBS: if it's not in LD_LIBRARY_PATH
+      dnl a test in configure may fail because of that.
+      perlldflags=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed \
+		-e 'ccdlflags' | sed -e 's/-bE:perl.exp//'`
+
+      dnl check that compiling a simple program still works with the flags
+      dnl added for Perl.
+      AC_MSG_CHECKING([if compile and link flags for Perl are sane])
+      cflags_save=$CFLAGS
+      libs_save=$LIBS
+      ldflags_save=$LDFLAGS
+      CFLAGS="$CFLAGS $perlcppflags"
+      LIBS="$LIBS $perllibs"
+      perlldflags=`echo "$perlldflags" | sed -e 's/^ *//g'`
+      LDFLAGS="$perlldflags $LDFLAGS"
+      AC_TRY_LINK(,[ ],
+	     AC_MSG_RESULT(yes); perl_ok=yes,
+	     AC_MSG_RESULT(no: PERL DISABLED); perl_ok=no)
+      CFLAGS=$cflags_save
+      LIBS=$libs_save
+      LDFLAGS=$ldflags_save
+      if test $perl_ok = yes; then
+	if test "X$perlcppflags" != "X"; then
+	  PERL_CFLAGS=$perlcppflags
+	fi
+	if test "X$perlldflags" != "X"; then
+	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
+	    LDFLAGS="$perlldflags $LDFLAGS"
+	  fi
+	fi
+	PERL_LIBS=$perllibs
+	PERL_SRC="auto/if_perl.c if_perlsfio.c"
+	PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o"
+	PERL_PRO="if_perl.pro if_perlsfio.pro"
+	AC_DEFINE(FEAT_PERL)
+      fi
+     fi
+    else
+      AC_MSG_RESULT(>>> too old; need Perl version 5.003_01 or later <<<)
+    fi
+  fi
+
+  if test "x$MACOS_X" = "xyes"; then
+    dnl Mac OS X 10.2 or later
+    dir=/System/Library/Perl
+    darwindir=$dir/darwin
+    if test -d $darwindir; then
+      PERL=/usr/bin/perl
+    else
+      dnl Mac OS X 10.3
+      dir=/System/Library/Perl/5.8.1
+      darwindir=$dir/darwin-thread-multi-2level
+      if test -d $darwindir; then
+	PERL=/usr/bin/perl
+      fi
+    fi
+    if test -n "$PERL"; then
+      PERL_DIR="$dir"
+      PERL_CFLAGS="-DFEAT_PERL -I$darwindir/CORE"
+      PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o $darwindir/auto/DynaLoader/DynaLoader.a"
+      PERL_LIBS="-L$darwindir/CORE -lperl"
+    fi
+    dnl Perl on Mac OS X 10.5 adds "-arch" flags but these should only
+    dnl be included if requested by passing --with-mac-arch to
+    dnl configure, so strip these flags first (if present)
+    PERL_LIBS=`echo "$PERL_LIBS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+    PERL_CFLAGS=`echo "$PERL_CFLAGS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+  fi
+  if test "$enable_perlinterp" = "dynamic"; then
+    if test "$perl_ok" = "yes" -a "X$libperl" != "X"; then
+      AC_DEFINE(DYNAMIC_PERL)
+      PERL_CFLAGS="-DDYNAMIC_PERL_DLL=\\\"$libperl\\\" $PERL_CFLAGS"
+    fi
+  fi
+
+  if test "$fail_if_missing" = "yes" -a "$perl_ok" != "yes"; then
+    AC_MSG_ERROR([could not configure perl])
+  fi
+fi
+AC_SUBST(shrpenv)
+AC_SUBST(PERL_SRC)
+AC_SUBST(PERL_OBJ)
+AC_SUBST(PERL_PRO)
+AC_SUBST(PERL_CFLAGS)
+AC_SUBST(PERL_LIBS)
+
+AC_MSG_CHECKING(--enable-pythoninterp argument)
+AC_ARG_ENABLE(pythoninterp,
+	[  --enable-pythoninterp[=OPTS]   Include Python interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+	[enable_pythoninterp="no"])
+AC_MSG_RESULT($enable_pythoninterp)
+if test "$enable_pythoninterp" = "yes" -o "$enable_pythoninterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_ERROR([cannot use Python with tiny or small features])
+  fi
+
+  dnl -- find the python executable
+  AC_MSG_CHECKING(--with-python-command argument)
+  AC_SUBST(vi_cv_path_python)
+  AC_ARG_WITH(python-command, [  --with-python-command=NAME  name of the Python 2 command (default: python2 or python)],
+	vi_cv_path_python="$withval"; AC_MSG_RESULT($vi_cv_path_python),
+	AC_MSG_RESULT(no))
+
+  if test "X$vi_cv_path_python" = "X"; then
+    AC_PATH_PROGS(vi_cv_path_python, python2 python)
+  fi
+  if test "X$vi_cv_path_python" != "X"; then
+
+    dnl -- get its version number
+    AC_CACHE_CHECK(Python version,vi_cv_var_python_version,
+    [[vi_cv_var_python_version=`
+	    ${vi_cv_path_python} -c 'import sys; print sys.version[:3]'`
+    ]])
+
+    dnl -- it must be at least version 2.3
+    AC_MSG_CHECKING(Python is 2.3 or better)
+    if ${vi_cv_path_python} -c \
+	"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"
+    then
+      AC_MSG_RESULT(yep)
+
+      dnl -- find where python thinks it was installed
+      AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python_pfx,
+      [ vi_cv_path_python_pfx=`
+	    ${vi_cv_path_python} -c \
+		"import sys; print sys.prefix"` ])
+
+      dnl -- and where it thinks it runs
+      AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python_epfx,
+      [ vi_cv_path_python_epfx=`
+	    ${vi_cv_path_python} -c \
+		"import sys; print sys.exec_prefix"` ])
+
+      dnl -- python's internal library path
+
+      AC_CACHE_VAL(vi_cv_path_pythonpath,
+      [ vi_cv_path_pythonpath=`
+	    unset PYTHONPATH;
+	    ${vi_cv_path_python} -c \
+		"import sys, string; print string.join(sys.path,':')"` ])
+
+      dnl -- where the Python implementation library archives are
+
+      AC_ARG_WITH(python-config-dir,
+	[  --with-python-config-dir=PATH  Python's config directory (deprecated)],
+	[ vi_cv_path_python_conf="${withval}"; have_python_config_dir=1 ] )
+
+      AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python_conf,
+      [
+	vi_cv_path_python_conf=
+	d=`${vi_cv_path_python} -c "import distutils.sysconfig; print distutils.sysconfig.get_config_var('LIBPL')"`
+	if test -d "$d" && test -f "$d/config.c"; then
+	  vi_cv_path_python_conf="$d"
+	else
+	  for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
+	    for subdir in lib64 lib share; do
+	      d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
+	      if test -d "$d" && test -f "$d/config.c"; then
+		vi_cv_path_python_conf="$d"
+	      fi
+	    done
+	  done
+	fi
+      ])
+
+      PYTHON_CONFDIR="${vi_cv_path_python_conf}"
+
+      if test "X$PYTHON_CONFDIR" = "X"; then
+	AC_MSG_RESULT([can't find it!])
+      else
+
+	dnl -- we need to examine Python's config/Makefile too
+	dnl    see what the interpreter is built from
+	AC_CACHE_VAL(vi_cv_path_python_plibs,
+	[
+	    pwd=`pwd`
+	    tmp_mkf="$pwd/config-PyMake$$"
+	    cat -- "${PYTHON_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+__:
+	@echo "python_BASEMODLIBS='$(BASEMODLIBS)'"
+	@echo "python_LIBS='$(LIBS)'"
+	@echo "python_SYSLIBS='$(SYSLIBS)'"
+	@echo "python_LINKFORSHARED='$(LINKFORSHARED)'"
+	@echo "python_DLLLIBRARY='$(DLLLIBRARY)'"
+	@echo "python_INSTSONAME='$(INSTSONAME)'"
+	@echo "python_PYTHONFRAMEWORK='$(PYTHONFRAMEWORK)'"
+	@echo "python_PYTHONFRAMEWORKPREFIX='$(PYTHONFRAMEWORKPREFIX)'"
+	@echo "python_PYTHONFRAMEWORKINSTALLDIR='$(PYTHONFRAMEWORKINSTALLDIR)'"
+eof
+	    dnl -- delete the lines from make about Entering/Leaving directory
+	    eval "`cd ${PYTHON_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+	    rm -f -- "${tmp_mkf}"
+	    if test "x$MACOS_X" = "xyes" && test -n "${python_PYTHONFRAMEWORK}" && ${vi_cv_path_python} -c \
+		"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"; then
+	      vi_cv_path_python_plibs="-framework Python"
+	      if test "x${vi_cv_path_python}" != "x/usr/bin/python" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+		  vi_cv_path_python_plibs="-F${python_PYTHONFRAMEWORKPREFIX} -framework Python"
+	      fi
+	    else
+	      vi_cv_path_python_plibs="-L${PYTHON_CONFDIR} -lpython${vi_cv_var_python_version}"
+	      dnl -- Check if the path contained in python_LINKFORSHARED is
+	      dnl    usable for vim build. If not, make and try other
+	      dnl    candidates.
+	      if test -n "${python_LINKFORSHARED}" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+	        python_link_symbol=`echo ${python_LINKFORSHARED} | sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]].*/\1/'`
+		python_link_path=`echo ${python_LINKFORSHARED} |   sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]][[ \t]]*\(.*\)/\2/'`
+	        if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+	          dnl -- The path looks relative. Guess the absolute one using
+		  dnl    the prefix and try that.
+	          python_link_path="${python_PYTHONFRAMEWORKPREFIX}/${python_link_path}"
+		  if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+		    dnl -- A last resort.
+		    python_link_path="${python_PYTHONFRAMEWORKINSTALLDIR}/Versions/${vi_cv_var_python_version}/${python_PYTHONFRAMEWORK}"
+	            dnl -- No check is done. The last word is left to the
+	            dnl    "sanity" test on link flags that follows shortly.
+		  fi
+	          python_LINKFORSHARED="${python_link_symbol} ${python_link_path}"
+	        fi
+	      fi
+	      vi_cv_path_python_plibs="${vi_cv_path_python_plibs} ${python_BASEMODLIBS} ${python_LIBS} ${python_SYSLIBS} ${python_LINKFORSHARED}"
+	      dnl remove -ltermcap, it can conflict with an earlier -lncurses
+	      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`
+	    fi
+	])
+	AC_CACHE_CHECK(Python's dll name,vi_cv_dll_name_python,
+	[
+	  if test "X$python_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python="$python_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python="$python_INSTSONAME"
+	  fi
+	])
+
+	PYTHON_LIBS="${vi_cv_path_python_plibs}"
+	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version}"
+	else
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version}"
+	fi
+	if test "X$have_python_config_dir" = "X1" -a "$enable_pythoninterp" = "dynamic"; then
+	  dnl Define PYTHON_HOME if --with-python-config-dir was used
+	  PYTHON_CFLAGS="${PYTHON_CFLAGS} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
+
+	fi
+	PYTHON_SRC="if_python.c"
+	PYTHON_OBJ="objects/if_python.o"
+
+	dnl On FreeBSD linking with "-pthread" is required to use threads.
+	dnl _THREAD_SAFE must be used for compiling then.
+	dnl The "-pthread" is added to $LIBS, so that the following check for
+	dnl sigaltstack() will look in libc_r (it's there in libc!).
+	dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
+	dnl will then define target-specific defines, e.g., -D_REENTRANT.
+	dnl Don't do this for Mac OSX, -pthread will generate a warning.
+	AC_MSG_CHECKING([if -pthread should be used])
+	threadsafe_flag=
+	thread_lib=
+	dnl if test "x$MACOS_X" != "xyes"; then
+        if test "`(uname) 2>/dev/null`" != Darwin; then
+	  test "$GCC" = yes && threadsafe_flag="-pthread"
+	  if test "`(uname) 2>/dev/null`" = FreeBSD; then
+	    threadsafe_flag="-D_THREAD_SAFE"
+	    thread_lib="-pthread"
+	  fi
+	  if test "`(uname) 2>/dev/null`" = SunOS; then
+	    threadsafe_flag="-pthreads"
+	  fi
+	fi
+	libs_save_old=$LIBS
+	if test -n "$threadsafe_flag"; then
+	  cflags_save=$CFLAGS
+	  CFLAGS="$CFLAGS $threadsafe_flag"
+	  LIBS="$LIBS $thread_lib"
+	  AC_TRY_LINK(,[ ],
+	     AC_MSG_RESULT(yes); PYTHON_CFLAGS="$PYTHON_CFLAGS $threadsafe_flag",
+	     AC_MSG_RESULT(no); LIBS=$libs_save_old
+	     )
+	  CFLAGS=$cflags_save
+	else
+	  AC_MSG_RESULT(no)
+	fi
+
+	dnl Check that compiling a simple program still works with the flags
+	dnl added for Python.
+	AC_MSG_CHECKING([if compile and link flags for Python are sane])
+	cflags_save=$CFLAGS
+	libs_save=$LIBS
+	CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+	LIBS="$LIBS $PYTHON_LIBS"
+	AC_TRY_LINK(,[ ],
+	       AC_MSG_RESULT(yes); python_ok=yes,
+	       AC_MSG_RESULT(no: PYTHON DISABLED); python_ok=no)
+	CFLAGS=$cflags_save
+	LIBS=$libs_save
+	if test $python_ok = yes; then
+	  AC_DEFINE(FEAT_PYTHON)
+	else
+	  LIBS=$libs_save_old
+	  PYTHON_SRC=
+	  PYTHON_OBJ=
+	  PYTHON_LIBS=
+	  PYTHON_CFLAGS=
+	fi
+      fi
+    else
+      AC_MSG_RESULT(too old)
+    fi
+  fi
+
+  if test "$fail_if_missing" = "yes" -a "$python_ok" != "yes"; then
+    AC_MSG_ERROR([could not configure python])
+  fi
+fi
+
+AC_SUBST(PYTHON_LIBS)
+AC_SUBST(PYTHON_CFLAGS)
+AC_SUBST(PYTHON_SRC)
+AC_SUBST(PYTHON_OBJ)
+
+
+AC_MSG_CHECKING(--enable-python3interp argument)
+AC_ARG_ENABLE(python3interp,
+	[  --enable-python3interp[=OPTS]  Include Python3 interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+	[enable_python3interp="no"])
+AC_MSG_RESULT($enable_python3interp)
+if test "$enable_python3interp" = "yes" -o "$enable_python3interp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_ERROR([cannot use Python with tiny or small features])
+  fi
+
+  dnl -- find the python3 executable
+  AC_MSG_CHECKING(--with-python3-command argument)
+  AC_SUBST(vi_cv_path_python3)
+  AC_ARG_WITH(python3-command, [  --with-python3-command=NAME  name of the Python 3 command (default: python3 or python)],
+	vi_cv_path_python3="$withval"; AC_MSG_RESULT($vi_cv_path_python3),
+	AC_MSG_RESULT(no))
+
+  if test "X$vi_cv_path_python3" = "X"; then
+    AC_PATH_PROGS(vi_cv_path_python3, python3 python)
+  fi
+  if test "X$vi_cv_path_python3" != "X"; then
+
+    dnl -- get its version number
+    AC_CACHE_CHECK(Python version,vi_cv_var_python3_version,
+    [[vi_cv_var_python3_version=`
+          ${vi_cv_path_python3} -c 'import sys; print(sys.version[:3])'`
+    ]])
+
+    dnl -- it must be at least version 3
+    AC_MSG_CHECKING(Python is 3.0 or better)
+    if ${vi_cv_path_python3} -c \
+      "import sys; sys.exit(${vi_cv_var_python3_version} < 3.0)"
+    then
+      AC_MSG_RESULT(yep)
+
+      dnl -- get abiflags for python 3.2 or higher (PEP 3149)
+      AC_CACHE_CHECK(Python's abiflags,vi_cv_var_python3_abiflags,
+      [
+       vi_cv_var_python3_abiflags=
+       if ${vi_cv_path_python3} -c \
+           "import sys; sys.exit(${vi_cv_var_python3_version} < 3.2)"
+       then
+         vi_cv_var_python3_abiflags=`${vi_cv_path_python3} -c \    
+           "import sys; print(sys.abiflags)"`
+       fi ])
+  
+      dnl -- find where python3 thinks it was installed
+      AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python3_pfx,
+      [ vi_cv_path_python3_pfx=`
+       ${vi_cv_path_python3} -c \
+       "import sys; print(sys.prefix)"` ])
+  
+      dnl -- and where it thinks it runs
+      AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python3_epfx,
+      [ vi_cv_path_python3_epfx=`
+       ${vi_cv_path_python3} -c \
+       "import sys; print(sys.exec_prefix)"` ])
+  
+      dnl -- python3's internal library path
+  
+      AC_CACHE_VAL(vi_cv_path_python3path,
+      [ vi_cv_path_python3path=`
+       unset PYTHONPATH;
+       ${vi_cv_path_python3} -c \
+       "import sys, string; print(':'.join(sys.path))"` ])
+  
+      dnl -- where the Python implementation library archives are
+  
+      AC_ARG_WITH(python3-config-dir,
+       [  --with-python3-config-dir=PATH  Python's config directory (deprecated)],
+       [ vi_cv_path_python3_conf="${withval}"; have_python3_config_dir=1 ] )
+  
+      AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python3_conf,
+      [
+       vi_cv_path_python3_conf=
+       config_dir="config-${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+       d=`${vi_cv_path_python3} -c "import distutils.sysconfig; print(distutils.sysconfig.get_config_var('LIBPL'))"`
+       if test -d "$d" && test -f "$d/config.c"; then
+         vi_cv_path_python3_conf="$d"
+       else
+         for path in "${vi_cv_path_python3_pfx}" "${vi_cv_path_python3_epfx}"; do
+	   for subdir in lib64 lib share; do
+	     d="${path}/${subdir}/python${vi_cv_var_python3_version}/${config_dir}"
+	     if test -d "$d" && test -f "$d/config.c"; then
+	       vi_cv_path_python3_conf="$d"
+	     fi
+	   done
+         done
+       fi
+      ])
+  
+      PYTHON3_CONFDIR="${vi_cv_path_python3_conf}"
+  
+      if test "X$PYTHON3_CONFDIR" = "X"; then
+        AC_MSG_RESULT([can't find it!])
+      else
+  
+        dnl -- we need to examine Python's config/Makefile too
+        dnl    see what the interpreter is built from
+        AC_CACHE_VAL(vi_cv_path_python3_plibs,
+        [
+            pwd=`pwd`
+            tmp_mkf="$pwd/config-PyMake$$"
+            cat -- "${PYTHON3_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+__:
+	@echo "python3_BASEMODLIBS='$(BASEMODLIBS)'"
+	@echo "python3_LIBS='$(LIBS)'"
+	@echo "python3_SYSLIBS='$(SYSLIBS)'"
+	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
+	@echo "python3_INSTSONAME='$(INSTSONAME)'"
+eof
+	    dnl -- delete the lines from make about Entering/Leaving directory
+	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+	    rm -f -- "${tmp_mkf}"
+	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
+	    dnl remove -ltermcap, it can conflict with an earlier -lncurses
+	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
+	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
+	])
+	AC_CACHE_CHECK(Python3's dll name,vi_cv_dll_name_python3,
+	[
+	  if test "X$python3_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python3="$python3_INSTSONAME"
+	  fi
+	])
+
+        PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
+        if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
+          PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+        else
+          PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+        fi
+	if test "X$have_python3_config_dir" = "X1" -a "$enable_python3interp" = "dynamic"; then
+	  dnl Define PYTHON3_HOME if --with-python-config-dir was used
+	  PYTHON3_CFLAGS="${PYTHON3_CFLAGS}  -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
+	fi
+        PYTHON3_SRC="if_python3.c"
+        PYTHON3_OBJ="objects/if_python3.o"
+  
+        dnl On FreeBSD linking with "-pthread" is required to use threads.
+        dnl _THREAD_SAFE must be used for compiling then.
+        dnl The "-pthread" is added to $LIBS, so that the following check for
+        dnl sigaltstack() will look in libc_r (it's there in libc!).
+        dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
+        dnl will then define target-specific defines, e.g., -D_REENTRANT.
+        dnl Don't do this for Mac OSX, -pthread will generate a warning.
+        AC_MSG_CHECKING([if -pthread should be used])
+        threadsafe_flag=
+        thread_lib=
+        dnl if test "x$MACOS_X" != "xyes"; then
+        if test "`(uname) 2>/dev/null`" != Darwin; then
+          test "$GCC" = yes && threadsafe_flag="-pthread"
+          if test "`(uname) 2>/dev/null`" = FreeBSD; then
+            threadsafe_flag="-D_THREAD_SAFE"
+            thread_lib="-pthread"
+          fi
+          if test "`(uname) 2>/dev/null`" = SunOS; then
+            threadsafe_flag="-pthreads"
+          fi
+        fi
+        libs_save_old=$LIBS
+        if test -n "$threadsafe_flag"; then
+          cflags_save=$CFLAGS
+          CFLAGS="$CFLAGS $threadsafe_flag"
+          LIBS="$LIBS $thread_lib"
+          AC_TRY_LINK(,[ ],
+             AC_MSG_RESULT(yes); PYTHON3_CFLAGS="$PYTHON3_CFLAGS $threadsafe_flag",
+             AC_MSG_RESULT(no); LIBS=$libs_save_old
+             )
+          CFLAGS=$cflags_save
+        else
+          AC_MSG_RESULT(no)
+        fi
+  
+        dnl check that compiling a simple program still works with the flags
+        dnl added for Python.
+        AC_MSG_CHECKING([if compile and link flags for Python 3 are sane])
+        cflags_save=$CFLAGS
+        libs_save=$LIBS
+        CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+        LIBS="$LIBS $PYTHON3_LIBS"
+        AC_TRY_LINK(,[ ],
+               AC_MSG_RESULT(yes); python3_ok=yes,
+               AC_MSG_RESULT(no: PYTHON3 DISABLED); python3_ok=no)
+        CFLAGS=$cflags_save
+        LIBS=$libs_save
+        if test "$python3_ok" = yes; then
+          AC_DEFINE(FEAT_PYTHON3)
+        else
+          LIBS=$libs_save_old
+          PYTHON3_SRC=
+          PYTHON3_OBJ=
+          PYTHON3_LIBS=
+          PYTHON3_CFLAGS=
+        fi
+      fi
+    else
+      AC_MSG_RESULT(too old)
+    fi
+  fi
+  if test "$fail_if_missing" = "yes" -a "$python3_ok" != "yes"; then
+    AC_MSG_ERROR([could not configure python3])
+  fi
+fi
+
+AC_SUBST(PYTHON3_LIBS)
+AC_SUBST(PYTHON3_CFLAGS)
+AC_SUBST(PYTHON3_SRC)
+AC_SUBST(PYTHON3_OBJ)
+
+dnl if python2.x and python3.x are enabled one can only link in code
+dnl with dlopen(), dlsym(), dlclose() 
+if test "$python_ok" = yes && test "$python3_ok" = yes; then
+  AC_DEFINE(DYNAMIC_PYTHON)
+  AC_DEFINE(DYNAMIC_PYTHON3)
+  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+  libs_save=$LIBS
+  dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
+  LIBS="-ldl $LIBS"
+  AC_RUN_IFELSE([AC_LANG_SOURCE([
+    #include <dlfcn.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first python version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+      if (pylib != 0)
+      {
+          void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }])],
+    [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+
+  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  libs_save=$LIBS
+  dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
+  LIBS="-ldl $LIBS"
+  AC_RUN_IFELSE([AC_LANG_SOURCE([
+    #include <dlfcn.h>
+    #include <wchar.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first python version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+      if (pylib != 0)
+      {
+          void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }])],
+    [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+
+  PYTHON_SRC="if_python.c"
+  PYTHON_OBJ="objects/if_python.o"
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+  PYTHON_LIBS=
+  PYTHON3_SRC="if_python3.c"
+  PYTHON3_OBJ="objects/if_python3.o"
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+  PYTHON3_LIBS=
+elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
+  AC_DEFINE(DYNAMIC_PYTHON)
+  PYTHON_SRC="if_python.c"
+  PYTHON_OBJ="objects/if_python.o"
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+  PYTHON_LIBS=
+elif test "$python_ok" = yes; then
+  dnl Check that adding -fPIE works.  It may be needed when using a static
+  dnl Python library.
+  AC_MSG_CHECKING([if -fPIE can be added for Python])
+  cflags_save=$CFLAGS
+  libs_save=$LIBS
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS -fPIE"
+  LIBS="$LIBS $PYTHON_LIBS"
+  AC_TRY_LINK(,[ ],
+	 AC_MSG_RESULT(yes); fpie_ok=yes,
+	 AC_MSG_RESULT(no); fpie_ok=no)
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+  if test $fpie_ok = yes; then
+    PYTHON_CFLAGS="$PYTHON_CFLAGS -fPIE"
+  fi
+elif test "$python3_ok" = yes && test "$enable_python3interp" = "dynamic"; then
+  AC_DEFINE(DYNAMIC_PYTHON3)
+  PYTHON3_SRC="if_python3.c"
+  PYTHON3_OBJ="objects/if_python3.o"
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+  PYTHON3_LIBS=
+elif test "$python3_ok" = yes; then
+  dnl Check that adding -fPIE works.  It may be needed when using a static
+  dnl Python library.
+  AC_MSG_CHECKING([if -fPIE can be added for Python3])
+  cflags_save=$CFLAGS
+  libs_save=$LIBS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS -fPIE"
+  LIBS="$LIBS $PYTHON3_LIBS"
+  AC_TRY_LINK(,[ ],
+	 AC_MSG_RESULT(yes); fpie_ok=yes,
+	 AC_MSG_RESULT(no); fpie_ok=no)
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+  if test $fpie_ok = yes; then
+    PYTHON3_CFLAGS="$PYTHON3_CFLAGS -fPIE"
+  fi
+fi
+
+AC_MSG_CHECKING(--enable-tclinterp argument)
+AC_ARG_ENABLE(tclinterp,
+	[  --enable-tclinterp[=OPTS]      Include Tcl interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+	[enable_tclinterp="no"])
+AC_MSG_RESULT($enable_tclinterp)
+
+if test "$enable_tclinterp" = "yes" -o "$enable_tclinterp" = "dynamic"; then
+
+  dnl on FreeBSD tclsh is a silly script, look for tclsh8.[5420]
+  AC_MSG_CHECKING(--with-tclsh argument)
+  AC_ARG_WITH(tclsh, [  --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)],
+	tclsh_name="$withval"; AC_MSG_RESULT($tclsh_name),
+	tclsh_name="tclsh8.5"; AC_MSG_RESULT(no))
+  AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+  AC_SUBST(vi_cv_path_tcl)
+
+  dnl when no specific version specified, also try 8.4, 8.2 and 8.0
+  if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.5"; then
+    tclsh_name="tclsh8.4"
+    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+  fi
+  if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.4"; then
+    tclsh_name="tclsh8.2"
+    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+  fi
+  if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.2"; then
+    tclsh_name="tclsh8.0"
+    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+  fi
+  dnl still didn't find it, try without version number
+  if test "X$vi_cv_path_tcl" = "X"; then
+    tclsh_name="tclsh"
+    AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+  fi
+  if test "X$vi_cv_path_tcl" != "X"; then
+    AC_MSG_CHECKING(Tcl version)
+    if echo 'exit [[expr [info tclversion] < 8.0]]' | "$vi_cv_path_tcl" - ; then
+      tclver=`echo 'puts [[info tclversion]]' | $vi_cv_path_tcl -`
+      AC_MSG_RESULT($tclver - OK);
+      tclloc=`echo 'set l [[info library]];set i [[string last lib $l]];incr i -2;puts [[string range $l 0 $i]]' | $vi_cv_path_tcl -`
+      tcldll=`echo 'puts libtcl[[info tclversion]][[info sharedlibextension]]' | $vi_cv_path_tcl -`
+
+      AC_MSG_CHECKING(for location of Tcl include)
+      if test "x$MACOS_X" != "xyes"; then
+	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver"
+      else
+	dnl For Mac OS X 10.3, use the OS-provided framework location
+	tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
+      fi
+      TCL_INC=
+      for try in $tclinc; do
+	if test -f "$try/tcl.h"; then
+	  AC_MSG_RESULT($try/tcl.h)
+	  TCL_INC=$try
+	  break
+	fi
+      done
+      if test -z "$TCL_INC"; then
+	AC_MSG_RESULT(<not found>)
+	SKIP_TCL=YES
+      fi
+      if test -z "$SKIP_TCL"; then
+	AC_MSG_CHECKING(for location of tclConfig.sh script)
+	if test "x$MACOS_X" != "xyes"; then
+	  tclcnf=`echo $tclinc | sed s/include/lib/g`
+	  tclcnf="$tclcnf `echo $tclinc | sed s/include/lib64/g`"
+	else
+	  dnl For Mac OS X 10.3, use the OS-provided framework location
+	  tclcnf="/System/Library/Frameworks/Tcl.framework"
+	fi
+	for try in $tclcnf; do
+	  if test -f "$try/tclConfig.sh"; then
+	    AC_MSG_RESULT($try/tclConfig.sh)
+	    . "$try/tclConfig.sh"
+	    dnl use eval, because tcl 8.2 includes ${TCL_DBGX}
+	    if test "$enable_tclinterp" = "dynamic"; then
+	      TCL_LIBS=`eval echo "$TCL_STUB_LIB_SPEC $TCL_LIBS"`
+	    else
+	      TCL_LIBS=`eval echo "$TCL_LIB_SPEC $TCL_LIBS"`
+	    fi
+	    dnl Use $TCL_DEFS for -D_THREAD_SAFE et al.  But only use the
+	    dnl "-D_ABC" items.  Watch out for -DFOO=long\ long.
+	    TCL_DEFS=`echo $TCL_DEFS | sed -e 's/\\\\ /\\\\X/g' | tr ' ' '\012' | sed -e '/^[[^-]]/d' -e '/^-[[^D]]/d' -e '/-D[[^_]]/d' -e 's/-D_/ -D_/' | tr '\012' ' ' | sed -e 's/\\\\X/\\\\ /g'`
+	    break
+	  fi
+	done
+	if test -z "$TCL_LIBS"; then
+	  AC_MSG_RESULT(<not found>)
+	  AC_MSG_CHECKING(for Tcl library by myself)
+	  tcllib=`echo $tclinc | sed s/include/lib/g`
+	  tcllib="$tcllib `echo $tclinc | sed s/include/lib64/g`"
+	  for ext in .so .a ; do
+	    for ver in "" $tclver ; do
+	      for try in $tcllib ; do
+		trylib=tcl$ver$ext
+		if test -f "$try/lib$trylib" ; then
+		  AC_MSG_RESULT($try/lib$trylib)
+		  TCL_LIBS="-L\"$try\" -ltcl$ver -ldl -lm"
+		  if test "`(uname) 2>/dev/null`" = SunOS &&
+					 uname -r | grep '^5' >/dev/null; then
+		    TCL_LIBS="$TCL_LIBS -R $try"
+		  fi
+		  break 3
+		fi
+	      done
+	    done
+	  done
+	  if test -z "$TCL_LIBS"; then
+	    AC_MSG_RESULT(<not found>)
+	    SKIP_TCL=YES
+	  fi
+	fi
+	if test -z "$SKIP_TCL"; then
+	  AC_DEFINE(FEAT_TCL)
+	  TCL_SRC=if_tcl.c
+	  TCL_OBJ=objects/if_tcl.o
+	  TCL_PRO=if_tcl.pro
+	  TCL_CFLAGS="-I$TCL_INC $TCL_DEFS"
+	fi
+      fi
+    else
+      AC_MSG_RESULT(too old; need Tcl version 8.0 or later)
+    fi
+  fi
+  if test "$enable_tclinterp" = "dynamic"; then
+    if test "X$TCL_SRC" != "X" -a "X$tcldll" != "X"; then
+      AC_DEFINE(DYNAMIC_TCL)
+      TCL_CFLAGS="-DDYNAMIC_TCL_DLL=\\\"$tcldll\\\" -DDYNAMIC_TCL_VER=\\\"$tclver\\\" $TCL_CFLAGS"
+    fi
+  fi
+  if test "$fail_if_missing" = "yes" -a -z "$TCL_SRC"; then
+    AC_MSG_ERROR([could not configure Tcl])
+  fi
+fi
+AC_SUBST(TCL_SRC)
+AC_SUBST(TCL_OBJ)
+AC_SUBST(TCL_PRO)
+AC_SUBST(TCL_CFLAGS)
+AC_SUBST(TCL_LIBS)
+
+AC_MSG_CHECKING(--enable-rubyinterp argument)
+AC_ARG_ENABLE(rubyinterp,
+	[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+	[enable_rubyinterp="no"])
+AC_MSG_RESULT($enable_rubyinterp)
+if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_ERROR([cannot use Ruby with tiny or small features])
+  fi
+
+  AC_MSG_CHECKING(--with-ruby-command argument)
+  AC_SUBST(vi_cv_path_ruby)
+  AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
+	RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; AC_MSG_RESULT($RUBY_CMD),
+	RUBY_CMD="ruby"; AC_MSG_RESULT(defaulting to $RUBY_CMD))
+  AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)
+  if test "X$vi_cv_path_ruby" != "X"; then
+    AC_MSG_CHECKING(Ruby version)
+    if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
+      AC_MSG_RESULT(OK)
+      AC_MSG_CHECKING(Ruby rbconfig)
+      ruby_rbconfig="RbConfig"
+      if ! $vi_cv_path_ruby -r rbconfig -e 'RbConfig' >/dev/null 2>/dev/null; then
+	ruby_rbconfig="Config"
+      fi
+      AC_MSG_RESULT($ruby_rbconfig)
+      AC_MSG_CHECKING(Ruby header files)
+      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e "print $ruby_rbconfig::CONFIG[['rubyhdrdir']] || $ruby_rbconfig::CONFIG[['archdir']] || \\$hdrdir" 2>/dev/null`
+      if test "X$rubyhdrdir" != "X"; then
+	AC_MSG_RESULT($rubyhdrdir)
+	RUBY_CFLAGS="-I$rubyhdrdir"
+        rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG[['rubyarchhdrdir']] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG[['arch']]"`
+        if test -d "$rubyarchdir"; then
+          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
+        fi
+        rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['ruby_version']].gsub(/\./, '')[[0,2]]"`
+	if test "X$rubyversion" = "X"; then
+	  rubyversion=`$vi_cv_path_ruby -e "print ((VERSION rescue RUBY_VERSION)).gsub(/\./, '')[[0,2]]"`
+	fi
+        RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
+	rubylibs=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LIBS']]"`
+	if test "X$rubylibs" != "X"; then
+	  RUBY_LIBS="$rubylibs"
+	fi
+	librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBYARG']])"`
+	librubya=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBY_A']])"`
+	rubylibdir=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['libdir']])"`
+	if test -f "$rubylibdir/$librubya"; then
+	  librubyarg="$librubyarg"
+	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+	elif test "$librubyarg" = "libruby.a"; then
+	  dnl required on Mac OS 10.3 where libruby.a doesn't exist
+	  librubyarg="-lruby"
+	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+	fi
+
+	if test "X$librubyarg" != "X"; then
+	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
+	fi
+	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LDFLAGS']]"`
+	if test "X$rubyldflags" != "X"; then
+	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
+	  dnl be included if requested by passing --with-mac-arch to
+	  dnl configure, so strip these flags first (if present)
+	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+	  if test "X$rubyldflags" != "X"; then
+	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
+	      LDFLAGS="$rubyldflags $LDFLAGS"
+	    fi
+	  fi
+	fi
+	RUBY_SRC="if_ruby.c"
+	RUBY_OBJ="objects/if_ruby.o"
+	RUBY_PRO="if_ruby.pro"
+	AC_DEFINE(FEAT_RUBY)
+	if test "$enable_rubyinterp" = "dynamic"; then
+	  libruby_soname=`$vi_cv_path_ruby -r rbconfig -e "puts $ruby_rbconfig::CONFIG[['LIBRUBY_ALIASES']].split[[0]]"`
+	  if test -z "$libruby_soname"; then
+	    libruby_soname=`$vi_cv_path_ruby -r rbconfig -e "puts $ruby_rbconfig::CONFIG[['LIBRUBY_SO']]"`
+	  fi
+	  AC_DEFINE(DYNAMIC_RUBY)
+	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby_soname\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+	  RUBY_LIBS=
+	fi
+      else
+	AC_MSG_RESULT(not found; disabling Ruby)
+      fi
+    else
+      AC_MSG_RESULT(too old; need Ruby version 1.6.0 or later)
+    fi
+  fi
+
+  if test "$fail_if_missing" = "yes" -a -z "$RUBY_OBJ"; then
+    AC_MSG_ERROR([could not configure Ruby])
+  fi
+fi
+AC_SUBST(RUBY_SRC)
+AC_SUBST(RUBY_OBJ)
+AC_SUBST(RUBY_PRO)
+AC_SUBST(RUBY_CFLAGS)
+AC_SUBST(RUBY_LIBS)
+
+AC_MSG_CHECKING(--enable-cscope argument)
+AC_ARG_ENABLE(cscope,
+	[  --enable-cscope         Include cscope interface.], ,
+	[enable_cscope="no"])
+AC_MSG_RESULT($enable_cscope)
+if test "$enable_cscope" = "yes"; then
+  AC_DEFINE(FEAT_CSCOPE)
+fi
+
+AC_MSG_CHECKING(--enable-workshop argument)
+AC_ARG_ENABLE(workshop,
+	[  --enable-workshop       Include Sun Visual Workshop support.], ,
+	[enable_workshop="no"])
+AC_MSG_RESULT($enable_workshop)
+if test "$enable_workshop" = "yes"; then
+  AC_DEFINE(FEAT_SUN_WORKSHOP)
+  WORKSHOP_SRC="workshop.c integration.c"
+  AC_SUBST(WORKSHOP_SRC)
+  WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
+  AC_SUBST(WORKSHOP_OBJ)
+  if test "${enable_gui-xxx}" = xxx; then
+    enable_gui=motif
+  fi
+fi
+
+AC_MSG_CHECKING(--disable-netbeans argument)
+AC_ARG_ENABLE(netbeans,
+	[  --disable-netbeans      Disable NetBeans integration support.],
+	, [enable_netbeans="yes"])
+if test "$enable_netbeans" = "yes"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_RESULT([cannot use NetBeans with tiny or small features])
+    enable_netbeans="no"
+  else
+    AC_MSG_RESULT(no)
+  fi
+else
+  AC_MSG_RESULT(yes)
+fi
+
+AC_MSG_CHECKING(--disable-channel argument)
+AC_ARG_ENABLE(channel,
+	[  --disable-channel       Disable process communication support.],
+	, [enable_channel="yes"])
+if test "$enable_channel" = "yes"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_RESULT([cannot use channels with tiny or small features])
+    enable_channel="no"
+  else
+    AC_MSG_RESULT(no)
+  fi
+else
+  if test "$enable_netbeans" = "yes"; then
+    AC_MSG_RESULT([yes, netbeans also disabled])
+    enable_netbeans="no"
+  else
+    AC_MSG_RESULT(yes)
+  fi
+fi
+
+if test "$enable_channel" = "yes"; then
+  dnl On Solaris we need the socket and nsl library.
+  AC_CHECK_LIB(socket, socket)
+  AC_CHECK_LIB(nsl, gethostbyname)
+  AC_MSG_CHECKING(whether compiling with process communication is possible)
+  AC_TRY_LINK([
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+	/* Check bitfields */
+	struct nbbuf {
+	unsigned int  initDone:1;
+	unsigned short signmaplen;
+	};
+	    ], [
+		/* Check creating a socket. */
+		struct sockaddr_in server;
+		(void)socket(AF_INET, SOCK_STREAM, 0);
+		(void)htons(100);
+		(void)gethostbyname("microsoft.com");
+		if (errno == ECONNREFUSED)
+		  (void)connect(1, (struct sockaddr *)&server, sizeof(server));
+	    ],
+	AC_MSG_RESULT(yes),
+	AC_MSG_RESULT(no); enable_netbeans="no"; enable_channel="no")
+fi
+if test "$enable_netbeans" = "yes"; then
+  AC_DEFINE(FEAT_NETBEANS_INTG)
+  NETBEANS_SRC="netbeans.c"
+  AC_SUBST(NETBEANS_SRC)
+  NETBEANS_OBJ="objects/netbeans.o"
+  AC_SUBST(NETBEANS_OBJ)
+fi
+if test "$enable_channel" = "yes"; then
+  AC_DEFINE(FEAT_JOB_CHANNEL)
+  CHANNEL_SRC="channel.c"
+  AC_SUBST(CHANNEL_SRC)
+  CHANNEL_OBJ="objects/channel.o"
+  AC_SUBST(CHANNEL_OBJ)
+fi
+
+AC_MSG_CHECKING(--enable-terminal argument)
+AC_ARG_ENABLE(terminal,
+	[  --enable-terminal       Enable terminal emulation support.],
+	, [enable_terminal="auto"])
+if test "$enable_terminal" = "yes" || test "$enable_terminal" = "auto" -a "x$features" = "xhuge" ; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    AC_MSG_RESULT([cannot use terminal emulator with tiny or small features])
+    enable_terminal="no"
+  else
+    if test "$enable_terminal" = "auto"; then
+      enable_terminal="yes"
+      AC_MSG_RESULT(defaulting to yes)
+    else
+      AC_MSG_RESULT(yes)
+    fi
+  fi
+else
+  if test "$enable_terminal" = "auto"; then
+    enable_terminal="no"
+    AC_MSG_RESULT(defaulting to no)
+  else
+    AC_MSG_RESULT(no)
+  fi
+fi
+if test "$enable_terminal" = "yes" -a "$enable_channel" = "yes"; then
+  AC_DEFINE(FEAT_TERMINAL)
+  TERM_SRC="libvterm/src/encoding.c libvterm/src/keyboard.c libvterm/src/mouse.c libvterm/src/parser.c libvterm/src/pen.c libvterm/src/screen.c libvterm/src/state.c libvterm/src/unicode.c libvterm/src/vterm.c"
+  AC_SUBST(TERM_SRC)
+  TERM_OBJ="objects/term_encoding.o objects/term_keyboard.o objects/term_mouse.o objects/term_parser.o objects/term_pen.o objects/term_screen.o objects/term_state.o objects/term_unicode.o objects/term_vterm.o"
+  AC_SUBST(TERM_OBJ)
+fi
+
+AC_MSG_CHECKING(--enable-autoservername argument)
+AC_ARG_ENABLE(autoservername,
+	[  --enable-autoservername Automatically define servername at vim startup.], ,
+	[enable_autoservername="no"])
+AC_MSG_RESULT($enable_autoservername)
+if test "$enable_autoservername" = "yes"; then
+  AC_DEFINE(FEAT_AUTOSERVERNAME)
+fi
+
+AC_MSG_CHECKING(--enable-multibyte argument)
+AC_ARG_ENABLE(multibyte,
+	[  --enable-multibyte      Include multibyte editing support.], ,
+	[enable_multibyte="no"])
+AC_MSG_RESULT($enable_multibyte)
+if test "$enable_multibyte" = "yes"; then
+  AC_DEFINE(FEAT_MBYTE)
+fi
+
+AC_MSG_CHECKING(--enable-hangulinput argument)
+AC_ARG_ENABLE(hangulinput,
+	[  --enable-hangulinput    Include Hangul input support.], ,
+	[enable_hangulinput="no"])
+AC_MSG_RESULT($enable_hangulinput)
+
+AC_MSG_CHECKING(--enable-xim argument)
+AC_ARG_ENABLE(xim,
+	[  --enable-xim            Include XIM input support.],
+	AC_MSG_RESULT($enable_xim),
+	[enable_xim="auto"; AC_MSG_RESULT(defaulting to auto)])
+
+AC_MSG_CHECKING(--enable-fontset argument)
+AC_ARG_ENABLE(fontset,
+	[  --enable-fontset        Include X fontset output support.], ,
+	[enable_fontset="no"])
+AC_MSG_RESULT($enable_fontset)
+dnl defining FEAT_XFONTSET is delayed, so that it can be disabled for no GUI
+
+test -z "$with_x" && with_x=yes
+test "${enable_gui-yes}" != no -a "x$MACOS_X" != "xyes" -a "x$QNX" != "xyes" && with_x=yes
+if test "$with_x" = no; then
+  AC_MSG_RESULT(defaulting to: don't HAVE_X11)
+else
+  dnl Do this check early, so that its failure can override user requests.
+
+  AC_PATH_PROG(xmkmfpath, xmkmf)
+
+  AC_PATH_XTRA
+
+  dnl On z/OS Unix the X libraries are DLLs. To use them the code must
+  dnl be compiled with a special option.
+  dnl Also add SM, ICE and Xmu to X_EXTRA_LIBS.
+  if test "$zOSUnix" = "yes"; then
+    CFLAGS="$CFLAGS -W c,dll"
+    LDFLAGS="$LDFLAGS -W l,dll"
+    X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE -lXmu"
+  fi
+
+  dnl On my HPUX system the X include dir is found, but the lib dir not.
+  dnl This is a desparate try to fix this.
+
+  if test -d "$x_includes" && test ! -d "$x_libraries"; then
+    x_libraries=`echo "$x_includes" | sed s/include/lib/`
+    AC_MSG_RESULT(Corrected X libraries to $x_libraries)
+    X_LIBS="$X_LIBS -L$x_libraries"
+    if test "`(uname) 2>/dev/null`" = SunOS &&
+					 uname -r | grep '^5' >/dev/null; then
+      X_LIBS="$X_LIBS -R $x_libraries"
+    fi
+  fi
+
+  if test -d "$x_libraries" && test ! -d "$x_includes"; then
+    x_includes=`echo "$x_libraries" | sed s/lib/include/`
+    AC_MSG_RESULT(Corrected X includes to $x_includes)
+    X_CFLAGS="$X_CFLAGS -I$x_includes"
+  fi
+
+  dnl Remove "-I/usr/include " from X_CFLAGS, should not be needed.
+  X_CFLAGS="`echo $X_CFLAGS\  | sed 's%-I/usr/include %%'`"
+  dnl Remove "-L/usr/lib " from X_LIBS, should not be needed.
+  X_LIBS="`echo $X_LIBS\  | sed 's%-L/usr/lib %%'`"
+  dnl Same for "-R/usr/lib ".
+  X_LIBS="`echo $X_LIBS\  | sed -e 's%-R/usr/lib %%' -e 's%-R /usr/lib %%'`"
+
+
+  dnl Check if the X11 header files are correctly installed. On some systems
+  dnl Xlib.h includes files that don't exist.  On some systems X11/Intrinsic.h
+  dnl is missing.
+  AC_MSG_CHECKING(if X11 header files can be found)
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $X_CFLAGS"
+  AC_TRY_COMPILE([#include <X11/Xlib.h>
+#include <X11/Intrinsic.h>], ,
+	AC_MSG_RESULT(yes),
+	AC_MSG_RESULT(no); no_x=yes)
+  CFLAGS=$cflags_save
+
+  if test "${no_x-no}" = yes; then
+    with_x=no
+  else
+    AC_DEFINE(HAVE_X11)
+    X_LIB="-lXt -lX11";
+    AC_SUBST(X_LIB)
+
+    ac_save_LDFLAGS="$LDFLAGS"
+    LDFLAGS="-L$x_libraries $LDFLAGS"
+
+    dnl Check for -lXdmcp (needed on SunOS 4.1.4)
+    dnl For HP-UX 10.20 it must be before -lSM -lICE
+    AC_CHECK_LIB(Xdmcp, _XdmcpAuthDoIt, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"],,
+		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS -lXdmcp])
+
+    dnl Some systems need -lnsl -lsocket when testing for ICE.
+    dnl The check above doesn't do this, try here (again).  Also needed to get
+    dnl them after Xdmcp.  link.sh will remove them when not needed.
+    dnl Check for other function than above to avoid the cached value
+    AC_CHECK_LIB(ICE, IceOpenConnection,
+		  [X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"],, [$X_EXTRA_LIBS])
+
+    dnl Check for -lXpm (needed for some versions of Motif)
+    LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
+    AC_CHECK_LIB(Xpm, XpmCreatePixmapFromData, [X_PRE_LIBS="$X_PRE_LIBS -lXpm"],,
+		[-lXt $X_PRE_LIBS -lXpm -lX11 $X_EXTRA_LIBS])
+
+    dnl Check that the X11 header files don't use implicit declarations
+    AC_MSG_CHECKING(if X11 header files implicitly declare return values)
+    cflags_save=$CFLAGS
+    dnl -Werror is GCC only, others like Solaris Studio might not like it
+    if test "$GCC" = yes; then
+      CFLAGS="$CFLAGS $X_CFLAGS -Werror"
+    else
+      CFLAGS="$CFLAGS $X_CFLAGS"
+    fi
+    AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
+	AC_MSG_RESULT(no),
+	CFLAGS="$CFLAGS -Wno-implicit-int"
+	AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
+	    AC_MSG_RESULT(yes); cflags_save="$cflags_save -Wno-implicit-int",
+	    AC_MSG_RESULT(test failed)
+	)
+    )
+    CFLAGS=$cflags_save
+
+    LDFLAGS="$ac_save_LDFLAGS"
+
+    AC_MSG_CHECKING(size of wchar_t is 2 bytes)
+    AC_CACHE_VAL(ac_cv_small_wchar_t,
+	[AC_TRY_RUN([
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}],
+		ac_cv_small_wchar_t="no",
+		ac_cv_small_wchar_t="yes",
+		AC_MSG_ERROR(failed to compile test program))])
+    AC_MSG_RESULT($ac_cv_small_wchar_t)
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      AC_DEFINE(SMALL_WCHAR_T)
+    fi
+
+  fi
+fi
+
+dnl Check if --with-x was given but it doesn't work.
+if test "x$with_x" = xno -a "x$with_x_arg" = xyes; then
+    AC_MSG_ERROR([could not configure X])
+fi
+
+test "x$with_x" = xno -a "x$MACOS_X" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
+
+AC_MSG_CHECKING(--enable-gui argument)
+AC_ARG_ENABLE(gui,
+ [  --enable-gui[=OPTS]       X11 GUI. [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
+
+dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
+dnl Do not use character classes for portability with old tools.
+enable_gui_canon=`echo "_$enable_gui" | \
+	sed 's/[[ _+-]]//g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+
+dnl Skip everything by default.
+SKIP_GTK2=YES
+SKIP_GTK3=YES
+SKIP_GNOME=YES
+SKIP_MOTIF=YES
+SKIP_ATHENA=YES
+SKIP_NEXTAW=YES
+SKIP_PHOTON=YES
+SKIP_CARBON=YES
+GUITYPE=NONE
+
+if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
+  SKIP_PHOTON=
+  case "$enable_gui_canon" in
+    no)		AC_MSG_RESULT(no GUI support)
+		SKIP_PHOTON=YES ;;
+    yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
+    auto)	AC_MSG_RESULT(auto - automatic GUI support) ;;
+    photon)	AC_MSG_RESULT(Photon GUI support) ;;
+    *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
+		SKIP_PHOTON=YES ;;
+  esac
+
+elif test "x$MACOS_X" = "xyes" -a "x$with_x" = "xno" ; then
+  SKIP_CARBON=
+  case "$enable_gui_canon" in
+    no)		AC_MSG_RESULT(no GUI support)
+		SKIP_CARBON=YES ;;
+    yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
+    auto)	AC_MSG_RESULT(auto - Carbon GUI is outdated - disable GUI support)
+		SKIP_CARBON=YES ;;
+    carbon)	AC_MSG_RESULT(Carbon GUI support) ;;
+    *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
+		SKIP_CARBON=YES ;;
+  esac
+
+else
+
+  case "$enable_gui_canon" in
+    no|none)	AC_MSG_RESULT(no GUI support) ;;
+    yes|""|auto)	AC_MSG_RESULT(yes/auto - automatic GUI support)
+		SKIP_GTK2=
+		SKIP_GNOME=
+		SKIP_MOTIF=
+		SKIP_ATHENA=
+		SKIP_NEXTAW=
+		SKIP_CARBON=;;
+    gtk2)	AC_MSG_RESULT(GTK+ 2.x GUI support)
+		SKIP_GTK2=;;
+    gnome2)	AC_MSG_RESULT(GNOME 2.x GUI support)
+		SKIP_GNOME=
+		SKIP_GTK2=;;
+    gtk3)	AC_MSG_RESULT(GTK+ 3.x GUI support)
+		SKIP_GTK3=;;
+    motif)	AC_MSG_RESULT(Motif GUI support)
+		SKIP_MOTIF=;;
+    athena)	AC_MSG_RESULT(Athena GUI support)
+		SKIP_ATHENA=;;
+    nextaw)	AC_MSG_RESULT(neXtaw GUI support)
+		SKIP_NEXTAW=;;
+    *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;
+  esac
+
+fi
+
+if test "x$SKIP_GTK2" != "xYES" -a "$enable_gui_canon" != "gtk2" \
+				-a "$enable_gui_canon" != "gnome2"; then
+  AC_MSG_CHECKING(whether or not to look for GTK+ 2)
+  AC_ARG_ENABLE(gtk2-check,
+	[  --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 [default=yes]],
+	, enable_gtk2_check="yes")
+  AC_MSG_RESULT($enable_gtk2_check)
+  if test "x$enable_gtk2_check" = "xno"; then
+    SKIP_GTK2=YES
+    SKIP_GNOME=YES
+  fi
+fi
+
+if test "x$SKIP_GNOME" != "xYES" -a "$enable_gui_canon" != "gnome2"; then
+  AC_MSG_CHECKING(whether or not to look for GNOME)
+  AC_ARG_ENABLE(gnome-check,
+	[  --enable-gnome-check    If GTK GUI, check for GNOME [default=no]],
+	, enable_gnome_check="no")
+  AC_MSG_RESULT($enable_gnome_check)
+  if test "x$enable_gnome_check" = "xno"; then
+    SKIP_GNOME=YES
+  fi
+fi
+
+if test "x$SKIP_GTK3" != "xYES" -a "$enable_gui_canon" != "gtk3"; then
+  AC_MSG_CHECKING(whether or not to look for GTK+ 3)
+  AC_ARG_ENABLE(gtk3-check,
+	[  --enable-gtk3-check     If auto-select GUI, check for GTK+ 3 [default=yes]],
+	, enable_gtk3_check="yes")
+  AC_MSG_RESULT($enable_gtk3_check)
+  if test "x$enable_gtk3_check" = "xno"; then
+    SKIP_GTK3=YES
+  fi
+fi
+
+if test "x$SKIP_MOTIF" != "xYES" -a "$enable_gui_canon" != "motif"; then
+  AC_MSG_CHECKING(whether or not to look for Motif)
+  AC_ARG_ENABLE(motif-check,
+	[  --enable-motif-check    If auto-select GUI, check for Motif [default=yes]],
+	, enable_motif_check="yes")
+  AC_MSG_RESULT($enable_motif_check)
+  if test "x$enable_motif_check" = "xno"; then
+    SKIP_MOTIF=YES
+  fi
+fi
+
+if test "x$SKIP_ATHENA" != "xYES" -a "$enable_gui_canon" != "athena"; then
+  AC_MSG_CHECKING(whether or not to look for Athena)
+  AC_ARG_ENABLE(athena-check,
+	[  --enable-athena-check   If auto-select GUI, check for Athena [default=yes]],
+	, enable_athena_check="yes")
+  AC_MSG_RESULT($enable_athena_check)
+  if test "x$enable_athena_check" = "xno"; then
+    SKIP_ATHENA=YES
+  fi
+fi
+
+if test "x$SKIP_NEXTAW" != "xYES" -a "$enable_gui_canon" != "nextaw"; then
+  AC_MSG_CHECKING(whether or not to look for neXtaw)
+  AC_ARG_ENABLE(nextaw-check,
+	[  --enable-nextaw-check   If auto-select GUI, check for neXtaw [default=yes]],
+	, enable_nextaw_check="yes")
+  AC_MSG_RESULT($enable_nextaw_check);
+  if test "x$enable_nextaw_check" = "xno"; then
+    SKIP_NEXTAW=YES
+  fi
+fi
+
+if test "x$SKIP_CARBON" != "xYES" -a "$enable_gui_canon" != "carbon"; then
+  AC_MSG_CHECKING(whether or not to look for Carbon)
+  AC_ARG_ENABLE(carbon-check,
+	[  --enable-carbon-check   If auto-select GUI, check for Carbon [default=yes]],
+	, enable_carbon_check="yes")
+  AC_MSG_RESULT($enable_carbon_check);
+  if test "x$enable_carbon_check" = "xno"; then
+    SKIP_CARBON=YES
+  fi
+fi
+
+
+if test "x$MACOS_X" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
+  AC_MSG_CHECKING(for Carbon GUI)
+  dnl already did the check, just give the message
+  AC_MSG_RESULT(yes);
+  GUITYPE=CARBONGUI
+  if test "$VIMNAME" = "vim"; then
+    VIMNAME=Vim
+  fi
+
+  if test "x$MACARCH" = "xboth"; then
+    CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
+  else
+    CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
+  fi
+
+  dnl Default install directory is not /usr/local
+  if test x$prefix = xNONE; then
+    prefix=/Applications
+  fi
+
+  dnl Sorry for the hard coded default
+  datadir='${prefix}/Vim.app/Contents/Resources'
+
+  dnl skip everything else
+  SKIP_GTK2=YES;
+  SKIP_GNOME=YES;
+  SKIP_MOTIF=YES;
+  SKIP_ATHENA=YES;
+  SKIP_NEXTAW=YES;
+  SKIP_PHOTON=YES;
+  SKIP_CARBON=YES
+fi
+
+dnl define an autoconf function to check for a specified version of GTK, and
+dnl try to compile/link a GTK program.
+dnl
+dnl AM_PATH_GTK([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+dnl Test for GTK, and define GTK_CFLAGS, GTK_LIBDIR and GTK_LIBS
+dnl
+AC_DEFUN(AM_PATH_GTK,
+[
+  if test "X$GTK_CONFIG" != "Xno" -o "X$PKG_CONFIG" != "Xno"; then
+  {
+    no_gtk=""
+    if (test "X$SKIP_GTK2" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+	  && $PKG_CONFIG --exists gtk+-2.0; then
+    {
+      min_gtk_version=ifelse([$1], ,2.2.0,$1)
+      AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
+      dnl We should be using PKG_CHECK_MODULES() instead of this hack.
+      dnl But I guess the dependency on pkgconfig.m4 is not wanted or
+      dnl something like that.
+      GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`
+      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`
+      GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`
+      gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
+      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
+      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
+    }
+    elif (test "X$SKIP_GTK3" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+	  && $PKG_CONFIG --exists gtk+-3.0; then
+    {
+      min_gtk_version=ifelse([$1], ,3.0.0,$1)
+      AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
+
+      GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`
+      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`
+      GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`
+      gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
+      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
+      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
+    }
+    else
+      no_gtk=yes
+    fi
+
+    if test "x$enable_gtktest" = "xyes" -a "x$no_gtk" = "x"; then
+    {
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $GTK_CFLAGS"
+      LIBS="$LIBS $GTK_LIBS"
+
+      dnl
+      dnl Now check if the installed GTK is sufficiently new.
+      dnl
+      rm -f conf.gtktest
+      AC_TRY_RUN([
+#include <gtk/gtk.h>
+#include <stdio.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+
+int
+main ()
+{
+int major, minor, micro;
+char *tmp_version;
+
+system ("touch conf.gtktest");
+
+/* HP/UX 9 (%@#!) writes to sscanf strings */
+tmp_version = g_strdup("$min_gtk_version");
+if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+   printf("%s, bad version string\n", "$min_gtk_version");
+   exit(1);
+ }
+
+if ((gtk_major_version > major) ||
+    ((gtk_major_version == major) && (gtk_minor_version > minor)) ||
+    ((gtk_major_version == major) && (gtk_minor_version == minor) &&
+				     (gtk_micro_version >= micro)))
+{
+    return 0;
+}
+return 1;
+}
+],, no_gtk=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+      CFLAGS="$ac_save_CFLAGS"
+      LIBS="$ac_save_LIBS"
+    }
+    fi
+    if test "x$no_gtk" = x ; then
+      if test "x$enable_gtktest" = "xyes"; then
+	AC_MSG_RESULT(yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
+      else
+	AC_MSG_RESULT(found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
+      fi
+      ifelse([$2], , :, [$2])
+    else
+    {
+      AC_MSG_RESULT(no)
+      GTK_CFLAGS=""
+      GTK_LIBS=""
+      ifelse([$3], , :, [$3])
+    }
+    fi
+  }
+  else
+    GTK_CFLAGS=""
+    GTK_LIBS=""
+    ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(GTK_CFLAGS)
+  AC_SUBST(GTK_LIBS)
+  rm -f conf.gtktest
+])
+
+dnl ---------------------------------------------------------------------------
+dnl gnome
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([GNOME_INIT_HOOK],
+[
+  AC_SUBST(GNOME_LIBS)
+  AC_SUBST(GNOME_LIBDIR)
+  AC_SUBST(GNOME_INCLUDEDIR)
+
+  AC_ARG_WITH(gnome-includes,
+    [  --with-gnome-includes=DIR Specify location of GNOME headers],
+    [CFLAGS="$CFLAGS -I$withval"]
+  )
+
+  AC_ARG_WITH(gnome-libs,
+    [  --with-gnome-libs=DIR   Specify location of GNOME libs],
+    [LDFLAGS="$LDFLAGS -L$withval" gnome_prefix=$withval]
+  )
+
+  AC_ARG_WITH(gnome,
+    [  --with-gnome            Specify prefix for GNOME files],
+    if test x$withval = xyes; then
+      want_gnome=yes
+      ifelse([$1], [], :, [$1])
+    else
+      if test "x$withval" = xno; then
+	want_gnome=no
+      else
+	want_gnome=yes
+	LDFLAGS="$LDFLAGS -L$withval/lib"
+	CFLAGS="$CFLAGS -I$withval/include"
+	gnome_prefix=$withval/lib
+      fi
+    fi,
+    want_gnome=yes)
+
+  if test "x$want_gnome" = xyes; then
+  {
+    AC_MSG_CHECKING(for libgnomeui-2.0)
+    if $PKG_CONFIG --exists libgnomeui-2.0; then
+      AC_MSG_RESULT(yes)
+      GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`
+      GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`
+      GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`
+
+      dnl On FreeBSD we need -pthread but pkg-config doesn't include it.
+      dnl This might not be the right way but it works for me...
+      AC_MSG_CHECKING(for FreeBSD)
+      if test "`(uname) 2>/dev/null`" = FreeBSD; then
+	AC_MSG_RESULT(yes, adding -pthread)
+	GNOME_INCLUDEDIR="$GNOME_INCLUDEDIR -D_THREAD_SAFE"
+	GNOME_LIBS="$GNOME_LIBS -pthread"
+      else
+	AC_MSG_RESULT(no)
+      fi
+      $1
+    else
+      AC_MSG_RESULT(not found)
+      if test "x$2" = xfail; then
+	AC_MSG_ERROR(Could not find libgnomeui-2.0 via pkg-config)
+      fi
+    fi
+  }
+  fi
+])
+
+AC_DEFUN([GNOME_INIT],[
+	GNOME_INIT_HOOK([],fail)
+])
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check for GTK2.  If it fails, then continue on for Motif as before...
+dnl ---------------------------------------------------------------------------
+if test -z "$SKIP_GTK2"; then
+
+  AC_MSG_CHECKING(--disable-gtktest argument)
+  AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
+	, enable_gtktest=yes)
+  if test "x$enable_gtktest" = "xyes" ; then
+    AC_MSG_RESULT(gtk test enabled)
+  else
+    AC_MSG_RESULT(gtk test disabled)
+  fi
+
+  if test "X$PKG_CONFIG" = "X"; then
+    AC_PATH_TOOL(PKG_CONFIG, pkg-config, no)
+  fi
+
+  if test "x$PKG_CONFIG" != "xno"; then
+    dnl First try finding version 2.2.0 or later.  The 2.0.x series has
+    dnl problems (bold fonts, --remote doesn't work).
+    AM_PATH_GTK(2.2.0,
+		[GUI_LIB_LOC="$GTK_LIBDIR"
+		 GTK_LIBNAME="$GTK_LIBS"
+		GUI_INC_LOC="$GTK_CFLAGS"], )
+    if test "x$GTK_CFLAGS" != "x"; then
+      SKIP_GTK3=YES
+      SKIP_ATHENA=YES
+      SKIP_NEXTAW=YES
+      SKIP_MOTIF=YES
+      GUITYPE=GTK
+      AC_SUBST(GTK_LIBNAME)
+    fi
+  fi
+  if test "x$GUITYPE" = "xGTK"; then
+    dnl
+    dnl if GTK exists, then check for GNOME.
+    dnl
+    if test -z "$SKIP_GNOME"; then
+    {
+      GNOME_INIT_HOOK([have_gnome=yes])
+      if test "x$have_gnome" = xyes ; then
+	AC_DEFINE(FEAT_GUI_GNOME)
+	GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
+	GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
+      fi
+    }
+    fi
+  fi
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl Check for GTK3.
+dnl ---------------------------------------------------------------------------
+if test -z "$SKIP_GTK3"; then
+
+  AC_MSG_CHECKING(--disable-gtktest argument)
+  AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
+	, enable_gtktest=yes)
+  if test "x$enable_gtktest" = "xyes" ; then
+    AC_MSG_RESULT(gtk test enabled)
+  else
+    AC_MSG_RESULT(gtk test disabled)
+  fi
+
+  if test "X$PKG_CONFIG" = "X"; then
+    AC_PATH_TOOL(PKG_CONFIG, pkg-config, no)
+  fi
+
+  if test "x$PKG_CONFIG" != "xno"; then
+    AM_PATH_GTK(3.0.0,
+		[GUI_LIB_LOC="$GTK_LIBDIR"
+		 GTK_LIBNAME="$GTK_LIBS"
+		GUI_INC_LOC="$GTK_CFLAGS"], )
+    if test "x$GTK_CFLAGS" != "x"; then
+      SKIP_GTK2=YES
+      SKIP_GNOME=YES
+      SKIP_ATHENA=YES
+      SKIP_NEXTAW=YES
+      SKIP_MOTIF=YES
+      GUITYPE=GTK
+      AC_SUBST(GTK_LIBNAME)
+      AC_DEFINE(USE_GTK3)
+    fi
+  fi
+fi
+
+dnl Check the version of Gdk-Pixbuf.  If the version is 2.31 or later and
+dnl glib-compile-resources is found in PATH, use GResource.
+if test "x$GUITYPE" = "xGTK"; then
+  AC_MSG_CHECKING([version of Gdk-Pixbuf])
+  gdk_pixbuf_version=`$PKG_CONFIG --modversion gdk-pixbuf-2.0`
+  if test "x$gdk_pixbuf_version" != x ; then
+    gdk_pixbuf_version_minor=`echo $gdk_pixbuf_version | \
+      sed -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/'`
+    if test "x$gdk_pixbuf_version_minor" != x -a \
+	$gdk_pixbuf_version_minor -ge 31 ; then
+      AC_MSG_RESULT([OK.])
+      AC_PATH_PROG(GLIB_COMPILE_RESOURCES,[glib-compile-resources],no)
+      AC_MSG_CHECKING([glib-compile-resources])
+      if test "x$GLIB_COMPILE_RESOURCES" = xno ; then
+	GLIB_COMPILE_RESOURCES=""
+	AC_MSG_RESULT([cannot be found in PATH.])
+      else
+	AC_MSG_RESULT([usable.])
+	AC_DEFINE(USE_GRESOURCE)
+	GRESOURCE_SRC="auto/gui_gtk_gresources.c"
+	GRESOURCE_OBJ="objects/gui_gtk_gresources.o"
+      fi
+    else
+      AC_MSG_RESULT([not usable.])
+    fi
+  else
+    AC_MSG_RESULT([cannot obtain from pkg_config.])
+  fi
+
+  AC_MSG_CHECKING([--disable-icon-cache-update argument])
+  AC_ARG_ENABLE(icon_cache_update,
+          [  --disable-icon-cache-update        update disabled],
+          [],
+          [enable_icon_cache_update="yes"])
+  if test "$enable_icon_cache_update" = "yes"; then
+    AC_MSG_RESULT([not set])
+    AC_PATH_PROG(GTK_UPDATE_ICON_CACHE,[gtk-update-icon-cache],no)
+    if test "x$GTK_UPDATE_ICON_CACHE" = "xno" ; then
+      AC_MSG_RESULT([not found in PATH.])
+    fi
+  else
+    AC_MSG_RESULT([update disabled])
+  fi
+
+  AC_MSG_CHECKING([--disable-desktop-database-update argument])
+  AC_ARG_ENABLE(desktop_database_update,
+          [  --disable-desktop-database-update  update disabled],
+          [],
+          [enable_desktop_database_update="yes"])
+  if test "$enable_desktop_database_update" = "yes"; then
+    AC_MSG_RESULT([not set])
+    AC_PATH_PROG(UPDATE_DESKTOP_DATABASE,[update-desktop-database],no)
+    if test "x$UPDATE_DESKTOP_DATABASE" = "xno" ; then
+      AC_MSG_RESULT([not found in PATH.])
+    fi
+  else
+    AC_MSG_RESULT([update disabled])
+  fi
+fi
+AC_SUBST(GLIB_COMPILE_RESOURCES)
+AC_SUBST(GRESOURCE_SRC)
+AC_SUBST(GRESOURCE_OBJ)
+AC_SUBST(GTK_UPDATE_ICON_CACHE)
+AC_SUBST(UPDATE_DESKTOP_DATABASE)
+
+dnl Check for Motif include files location.
+dnl The LAST one found is used, this makes the highest version to be used,
+dnl e.g. when Motif1.2 and Motif2.0 are both present.
+
+if test -z "$SKIP_MOTIF"; then
+  gui_XXX="/usr/XXX/Motif* /usr/Motif*/XXX /usr/XXX /usr/shlib /usr/X11*/XXX /usr/XXX/X11* /usr/dt/XXX /local/Motif*/XXX /local/XXX/Motif* /usr/local/Motif*/XXX /usr/local/XXX/Motif* /usr/local/XXX /usr/local/X11*/XXX /usr/local/LessTif/Motif*/XXX $MOTIFHOME/XXX"
+  dnl Remove "-I" from before $GUI_INC_LOC if it's there
+  GUI_INC_LOC="`echo $GUI_INC_LOC|sed 's%-I%%g'`"
+
+  AC_MSG_CHECKING(for location of Motif GUI includes)
+  gui_includes="`echo $x_includes|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/include/g` $GUI_INC_LOC"
+  GUI_INC_LOC=
+  for try in $gui_includes; do
+    if test -f "$try/Xm/Xm.h"; then
+      GUI_INC_LOC=$try
+    fi
+  done
+  if test -n "$GUI_INC_LOC"; then
+    if test "$GUI_INC_LOC" = /usr/include; then
+      GUI_INC_LOC=
+      AC_MSG_RESULT(in default path)
+    else
+      AC_MSG_RESULT($GUI_INC_LOC)
+    fi
+  else
+    AC_MSG_RESULT(<not found>)
+    SKIP_MOTIF=YES
+  fi
+fi
+
+dnl Check for Motif library files location.  In the same order as the include
+dnl files, to avoid a mixup if several versions are present
+
+if test -z "$SKIP_MOTIF"; then
+  AC_MSG_CHECKING(--with-motif-lib argument)
+  AC_ARG_WITH(motif-lib,
+  [  --with-motif-lib=STRING Library for Motif ],
+  [ MOTIF_LIBNAME="${withval}" ] )
+
+  if test -n "$MOTIF_LIBNAME"; then
+    AC_MSG_RESULT($MOTIF_LIBNAME)
+    GUI_LIB_LOC=
+  else
+    AC_MSG_RESULT(no)
+
+    dnl Remove "-L" from before $GUI_LIB_LOC if it's there
+    GUI_LIB_LOC="`echo $GUI_LIB_LOC|sed 's%-L%%g'`"
+
+    dnl Ubuntu has libXm.so in /usr/lib/i386-linux-gnu and elsewhere.  The
+    dnl linker will figure out which one to use, we only check if one exists.
+    AC_MSG_CHECKING(for location of Motif GUI libs)
+    gui_libs="`echo $x_libraries|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/lib/g` /usr/lib/i386-linux-gnu /usr/lib/x86_64-linux-gnu `echo "$GUI_INC_LOC" | sed s/include/lib/` $GUI_LIB_LOC"
+    GUI_LIB_LOC=
+    for try in $gui_libs; do
+      for libtry in "$try"/libXm.a "$try"/libXm.so* "$try"/libXm.sl "$try"/libXm.dylib; do
+	if test -f "$libtry"; then
+	  GUI_LIB_LOC=$try
+	fi
+      done
+    done
+    if test -n "$GUI_LIB_LOC"; then
+      dnl Remove /usr/lib, it causes trouble on some systems
+      if test "$GUI_LIB_LOC" = /usr/lib \
+	   -o "$GUI_LIB_LOC" = /usr/lib/i386-linux-gnu \
+	   -o "$GUI_LIB_LOC" = /usr/lib/x86_64-linux-gnu; then
+	GUI_LIB_LOC=
+	AC_MSG_RESULT(in default path)
+      else
+	if test -n "$GUI_LIB_LOC"; then
+	  AC_MSG_RESULT($GUI_LIB_LOC)
+	  if test "`(uname) 2>/dev/null`" = SunOS &&
+					 uname -r | grep '^5' >/dev/null; then
+	    GUI_LIB_LOC="$GUI_LIB_LOC -R $GUI_LIB_LOC"
+	  fi
+	fi
+      fi
+      MOTIF_LIBNAME=-lXm
+    else
+      AC_MSG_RESULT(<not found>)
+      SKIP_MOTIF=YES
+    fi
+  fi
+fi
+
+if test -z "$SKIP_MOTIF"; then
+  SKIP_ATHENA=YES
+  SKIP_NEXTAW=YES
+  GUITYPE=MOTIF
+  AC_SUBST(MOTIF_LIBNAME)
+fi
+
+dnl Check if the Athena files can be found
+
+GUI_X_LIBS=
+
+if test -z "$SKIP_ATHENA"; then
+  AC_MSG_CHECKING(if Athena header files can be found)
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $X_CFLAGS"
+  AC_TRY_COMPILE([
+#include <X11/Intrinsic.h>
+#include <X11/Xaw/Paned.h>], ,
+	AC_MSG_RESULT(yes),
+	AC_MSG_RESULT(no); SKIP_ATHENA=YES )
+  CFLAGS=$cflags_save
+fi
+
+if test -z "$SKIP_ATHENA"; then
+  GUITYPE=ATHENA
+fi
+
+if test -z "$SKIP_NEXTAW"; then
+  AC_MSG_CHECKING(if neXtaw header files can be found)
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $X_CFLAGS"
+  AC_TRY_COMPILE([
+#include <X11/Intrinsic.h>
+#include <X11/neXtaw/Paned.h>], ,
+	AC_MSG_RESULT(yes),
+	AC_MSG_RESULT(no); SKIP_NEXTAW=YES )
+  CFLAGS=$cflags_save
+fi
+
+if test -z "$SKIP_NEXTAW"; then
+  GUITYPE=NEXTAW
+fi
+
+if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+  dnl Prepend -I and -L to $GUI_INC_LOC and $GUI_LIB_LOC if not empty
+  dnl Avoid adding it when it twice
+  if test -n "$GUI_INC_LOC"; then
+    GUI_INC_LOC=-I"`echo $GUI_INC_LOC|sed 's%-I%%'`"
+  fi
+  if test -n "$GUI_LIB_LOC"; then
+    GUI_LIB_LOC=-L"`echo $GUI_LIB_LOC|sed 's%-L%%'`"
+  fi
+
+  dnl Check for -lXext and then for -lXmu
+  ldflags_save=$LDFLAGS
+  LDFLAGS="$X_LIBS $LDFLAGS"
+  AC_CHECK_LIB(Xext, XShapeQueryExtension, [GUI_X_LIBS="-lXext"],,
+		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+  dnl For Solaris we need -lw and -ldl before linking with -lXmu works.
+  AC_CHECK_LIB(w, wslen, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"],,
+		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+  AC_CHECK_LIB(dl, dlsym, [X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"],,
+		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+  AC_CHECK_LIB(Xmu, XmuCreateStippledPixmap, [GUI_X_LIBS="-lXmu $GUI_X_LIBS"],,
+		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+  if test -z "$SKIP_MOTIF"; then
+    AC_CHECK_LIB(Xp, XpEndJob, [GUI_X_LIBS="-lXp $GUI_X_LIBS"],,
+		[$GUI_X_LIBS -lXm -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+  fi
+  LDFLAGS=$ldflags_save
+
+  dnl Execute xmkmf to figure out if -DNARROWPROTO is needed.
+  AC_MSG_CHECKING(for extra X11 defines)
+  NARROW_PROTO=
+  rm -fr conftestdir
+  if mkdir conftestdir; then
+    cd conftestdir
+    cat > Imakefile <<'EOF'
+acfindx:
+	@echo 'NARROW_PROTO="${PROTO_DEFINES}"'
+EOF
+    if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
+      eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
+    fi
+    cd ..
+    rm -fr conftestdir
+  fi
+  if test -z "$NARROW_PROTO"; then
+    AC_MSG_RESULT(no)
+  else
+    AC_MSG_RESULT($NARROW_PROTO)
+  fi
+  AC_SUBST(NARROW_PROTO)
+fi
+
+dnl Look for XSMP support - but don't necessarily restrict it to X11 GUIs
+dnl use the X11 include path
+if test "$enable_xsmp" = "yes"; then
+  cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  AC_CHECK_HEADERS(X11/SM/SMlib.h)
+  CPPFLAGS=$cppflags_save
+fi
+
+
+if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2" -o -z "$SKIP_GTK3"; then
+  dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path
+  cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  AC_CHECK_HEADERS(X11/xpm.h X11/Sunkeysym.h)
+
+  dnl automatically disable XIM when XIMtext isn't in X11/Xlib.h
+  if test ! "$enable_xim" = "no"; then
+    AC_MSG_CHECKING(for XIMText in X11/Xlib.h)
+    AC_EGREP_CPP(XIMText, [#include <X11/Xlib.h>],
+		  AC_MSG_RESULT(yes),
+		  AC_MSG_RESULT(no; xim has been disabled); enable_xim="no")
+  fi
+  CPPFLAGS=$cppflags_save
+
+  dnl automatically enable XIM when hangul input isn't enabled
+  if test "$enable_xim" = "auto" -a "$enable_hangulinput" != "yes" \
+		-a "x$GUITYPE" != "xNONE" ; then
+    AC_MSG_RESULT(X GUI selected; xim has been enabled)
+    enable_xim="yes"
+  fi
+fi
+
+if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+  cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+dnl Xmu/Editres.h may exist but can only be used after including Intrinsic.h
+  AC_MSG_CHECKING([for X11/Xmu/Editres.h])
+  AC_TRY_COMPILE([
+#include <X11/Intrinsic.h>
+#include <X11/Xmu/Editres.h>],
+		      [int i; i = 0;],
+	      AC_MSG_RESULT(yes)
+		      AC_DEFINE(HAVE_X11_XMU_EDITRES_H),
+	      AC_MSG_RESULT(no))
+  CPPFLAGS=$cppflags_save
+fi
+
+dnl Only use the Xm directory when compiling Motif, don't use it for Athena
+if test -z "$SKIP_MOTIF"; then
+  cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  if test "$zOSUnix" = "yes"; then
+	xmheader="Xm/Xm.h"
+  else
+	xmheader="Xm/Xm.h Xm/XpmP.h Xm/JoinSideT.h Xm/TraitP.h Xm/Manager.h
+	   Xm/UnhighlightT.h Xm/Notebook.h"  
+  fi    
+  AC_CHECK_HEADERS($xmheader)
+
+  if test "x$ac_cv_header_Xm_XpmP_h" = "xyes"; then
+    dnl Solaris uses XpmAttributes_21, very annoying.
+    AC_MSG_CHECKING([for XpmAttributes_21 in Xm/XpmP.h])
+    AC_TRY_COMPILE([#include <Xm/XpmP.h>], [XpmAttributes_21 attr;],
+	AC_MSG_RESULT(yes); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes_21),
+	AC_MSG_RESULT(no); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
+	)
+  else
+    AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
+  fi
+  CPPFLAGS=$cppflags_save
+fi
+
+if test "x$GUITYPE" = "xNONE" -a "$enable_xim" = "yes"; then
+  AC_MSG_RESULT(no GUI selected; xim has been disabled)
+  enable_xim="no"
+fi
+if test "x$GUITYPE" = "xNONE" -a "$enable_fontset" = "yes"; then
+  AC_MSG_RESULT(no GUI selected; fontset has been disabled)
+  enable_fontset="no"
+fi
+if test "x$GUITYPE:$enable_fontset" = "xGTK:yes"; then
+  AC_MSG_RESULT(GTK+ 2 GUI selected; fontset has been disabled)
+  enable_fontset="no"
+fi
+
+if test -z "$SKIP_PHOTON"; then
+  GUITYPE=PHOTONGUI
+fi
+
+AC_SUBST(GUI_INC_LOC)
+AC_SUBST(GUI_LIB_LOC)
+AC_SUBST(GUITYPE)
+AC_SUBST(GUI_X_LIBS)
+
+if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
+  AC_MSG_ERROR([cannot use workshop without Motif])
+fi
+
+dnl defining FEAT_XIM and FEAT_XFONTSET is delayed, so that they can be disabled
+if test "$enable_xim" = "yes"; then
+  AC_DEFINE(FEAT_XIM)
+fi
+if test "$enable_fontset" = "yes"; then
+  AC_DEFINE(FEAT_XFONTSET)
+fi
+
+
+dnl ---------------------------------------------------------------------------
+dnl end of GUI-checking
+dnl ---------------------------------------------------------------------------
+
+AC_MSG_CHECKING([for /proc link to executable])
+if test -L "/proc/self/exe"; then
+  dnl Linux
+  AC_MSG_RESULT([/proc/self/exe])
+  AC_DEFINE(PROC_EXE_LINK, "/proc/self/exe")
+elif test -L "/proc/self/path/a.out"; then
+  dnl Solaris
+  AC_MSG_RESULT([/proc/self/path/a.out])
+  AC_DEFINE(PROC_EXE_LINK, "/proc/self/path/a.out")
+elif test -L "/proc/curproc/file"; then
+  dnl FreeBSD
+  AC_MSG_RESULT([/proc/curproc/file])
+  AC_DEFINE(PROC_EXE_LINK, "/proc/curproc/file")
+else
+  AC_MSG_RESULT(no)
+fi
+
+dnl Check for Cygwin, which needs an extra source file if not using X11
+AC_MSG_CHECKING(for CYGWIN or MSYS environment)
+case `uname` in
+    CYGWIN*|MSYS*)    CYGWIN=yes; AC_MSG_RESULT(yes)
+                AC_MSG_CHECKING(for CYGWIN clipboard support)
+                if test "x$with_x" = "xno" ; then
+                  OS_EXTRA_SRC=winclip.c; OS_EXTRA_OBJ=objects/winclip.o
+                  AC_MSG_RESULT(yes)
+                  AC_DEFINE(FEAT_CYGWIN_WIN32_CLIPBOARD)
+                else
+                  AC_MSG_RESULT(no - using X11)
+                fi ;;
+
+    *)          CYGWIN=no; AC_MSG_RESULT(no);;
+esac
+
+dnl Only really enable hangul input when GUI and XFONTSET are available
+if test "$enable_hangulinput" = "yes"; then
+  if test "x$GUITYPE" = "xNONE"; then
+    AC_MSG_RESULT(no GUI selected; hangul input has been disabled)
+    enable_hangulinput=no
+  else
+    AC_DEFINE(FEAT_HANGULIN)
+    HANGULIN_SRC=hangulin.c
+    AC_SUBST(HANGULIN_SRC)
+    HANGULIN_OBJ=objects/hangulin.o
+    AC_SUBST(HANGULIN_OBJ)
+  fi
+fi
+
+dnl Checks for libraries and include files.
+
+AC_CACHE_CHECK([whether toupper is broken], [vim_cv_toupper_broken],
+  [
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include "confdefs.h"
+#include <ctype.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }
+  ]])],[
+    vim_cv_toupper_broken=yes
+  ],[
+    vim_cv_toupper_broken=no
+  ],[
+    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_toupper_broken')
+  ])])
+
+if test "x$vim_cv_toupper_broken" = "xyes" ; then
+  AC_DEFINE(BROKEN_TOUPPER)
+fi
+
+AC_MSG_CHECKING(whether __DATE__ and __TIME__ work)
+AC_TRY_COMPILE([#include <stdio.h>], [printf("(" __DATE__ " " __TIME__ ")");],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
+	AC_MSG_RESULT(no))
+
+AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
+AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
+	AC_MSG_RESULT(no))
+
+dnl Checks for header files.
+AC_CHECK_HEADER(elf.h, HAS_ELF=1)
+dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
+if test "$HAS_ELF" = 1; then
+  AC_CHECK_LIB(elf, main)
+fi
+
+AC_HEADER_DIRENT
+
+dnl If sys/wait.h is not found it might still exist but not be POSIX
+dnl compliant. In that case we define HAVE_UNION_WAIT (for NeXT)
+if test $ac_cv_header_sys_wait_h = no; then
+  AC_MSG_CHECKING([for sys/wait.h that defines union wait])
+  AC_TRY_COMPILE([#include <sys/wait.h>],
+			[union wait xx, yy; xx = yy],
+		AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_SYS_WAIT_H)
+			AC_DEFINE(HAVE_UNION_WAIT),
+		AC_MSG_RESULT(no))
+fi
+
+AC_CHECK_HEADERS(stdint.h stdlib.h string.h \
+	sys/select.h sys/utsname.h termcap.h fcntl.h \
+	sgtty.h sys/ioctl.h sys/time.h sys/types.h \
+	termio.h iconv.h inttypes.h langinfo.h math.h \
+	unistd.h stropts.h errno.h sys/resource.h \
+	sys/systeminfo.h locale.h sys/stream.h termios.h \
+	libc.h sys/statfs.h poll.h sys/poll.h pwd.h \
+	utime.h sys/param.h libintl.h libgen.h \
+	util/debug.h util/msg18n.h frame.h sys/acl.h \
+	sys/access.h sys/sysinfo.h wchar.h wctype.h)
+
+dnl sys/ptem.h depends on sys/stream.h on Solaris
+AC_CHECK_HEADERS(sys/ptem.h, [], [],
+[#if defined HAVE_SYS_STREAM_H
+#  include <sys/stream.h>
+#endif])
+
+dnl sys/sysctl.h depends on sys/param.h on OpenBSD
+AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+[#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+#endif])
+
+
+dnl pthread_np.h may exist but can only be used after including pthread.h
+AC_MSG_CHECKING([for pthread_np.h])
+AC_TRY_COMPILE([
+#include <pthread.h>
+#include <pthread_np.h>],
+		      [int i; i = 0;],
+	      AC_MSG_RESULT(yes)
+		      AC_DEFINE(HAVE_PTHREAD_NP_H),
+	      AC_MSG_RESULT(no))
+
+AC_CHECK_HEADERS(strings.h)
+if test "x$MACOS_X" = "xyes"; then
+  dnl The strings.h file on OS/X contains a warning and nothing useful.
+  AC_DEFINE(NO_STRINGS_WITH_STRING_H)
+else
+
+dnl Check if strings.h and string.h can both be included when defined.
+AC_MSG_CHECKING([if strings.h can be included after string.h])
+cppflags_save=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+AC_TRY_COMPILE([
+#if defined(_AIX) && !defined(_AIX51) && !defined(_NO_PROTO)
+# define _NO_PROTO	/* like in os_unix.h, causes conflict for AIX (Winn) */
+			/* but don't do it on AIX 5.1 (Uribarri) */
+#endif
+#ifdef HAVE_XM_XM_H
+# include <Xm/Xm.h>	/* This breaks it for HP-UX 11 (Squassabia) */
+#endif
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#if defined(HAVE_STRINGS_H)
+# include <strings.h>
+#endif
+		], [int i; i = 0;],
+		AC_MSG_RESULT(yes),
+		AC_DEFINE(NO_STRINGS_WITH_STRING_H)
+		AC_MSG_RESULT(no))
+CPPFLAGS=$cppflags_save
+fi
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_PROG_GCC_TRADITIONAL
+AC_C_CONST
+AC_C_VOLATILE
+AC_TYPE_MODE_T
+AC_TYPE_OFF_T
+AC_TYPE_PID_T
+AC_TYPE_SIZE_T
+AC_TYPE_UID_T
+AC_TYPE_UINT32_T
+
+AC_HEADER_TIME
+AC_CHECK_TYPE(ino_t, long)
+AC_CHECK_TYPE(dev_t, unsigned)
+AC_C_BIGENDIAN(,,,)
+AC_C_INLINE
+
+AC_MSG_CHECKING(for rlim_t)
+if eval "test \"`echo '$''{'ac_cv_type_rlim_t'+set}'`\" = set"; then
+  AC_MSG_RESULT([(cached) $ac_cv_type_rlim_t])
+else
+  AC_EGREP_CPP(dnl
+changequote(<<,>>)dnl
+<<(^|[^a-zA-Z_0-9])rlim_t[^a-zA-Z_0-9]>>dnl
+changequote([,]),
+  [
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
+	  ], ac_cv_type_rlim_t=yes, ac_cv_type_rlim_t=no)
+	  AC_MSG_RESULT($ac_cv_type_rlim_t)
+fi
+if test $ac_cv_type_rlim_t = no; then
+  cat >> confdefs.h <<\EOF
+#define rlim_t unsigned long
+EOF
+fi
+
+AC_MSG_CHECKING(for stack_t)
+if eval "test \"`echo '$''{'ac_cv_type_stack_t'+set}'`\" = set"; then
+  AC_MSG_RESULT([(cached) $ac_cv_type_stack_t])
+else
+  AC_EGREP_CPP(stack_t,
+  [
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#include <signal.h>
+	  ], ac_cv_type_stack_t=yes, ac_cv_type_stack_t=no)
+	  AC_MSG_RESULT($ac_cv_type_stack_t)
+fi
+if test $ac_cv_type_stack_t = no; then
+  cat >> confdefs.h <<\EOF
+#define stack_t struct sigaltstack
+EOF
+fi
+
+dnl BSDI uses ss_base while others use ss_sp for the stack pointer.
+AC_MSG_CHECKING(whether stack_t has an ss_base field)
+AC_TRY_COMPILE([
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#include <signal.h>
+#include "confdefs.h"
+			], [stack_t sigstk; sigstk.ss_base = 0; ],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SS_BASE),
+	AC_MSG_RESULT(no))
+
+olibs="$LIBS"
+AC_MSG_CHECKING(--with-tlib argument)
+AC_ARG_WITH(tlib, [  --with-tlib=library     terminal library to be used ],)
+if test -n "$with_tlib"; then
+  AC_MSG_RESULT($with_tlib)
+  LIBS="$LIBS -l$with_tlib"
+  AC_MSG_CHECKING(for linking with $with_tlib library)
+  AC_TRY_LINK([], [], AC_MSG_RESULT(OK), AC_MSG_ERROR(FAILED))
+  dnl Need to check for tgetent() below.
+  olibs="$LIBS"
+else
+  AC_MSG_RESULT([empty: automatic terminal library selection])
+  dnl  On HP-UX 10.10 termcap or termlib should be used instead of
+  dnl  curses, because curses is much slower.
+  dnl  Newer versions of ncurses are preferred over anything, except
+  dnl  when tinfo has been split off, it contains all we need.
+  dnl  Older versions of ncurses have bugs, get a new one!
+  dnl  Digital Unix (OSF1) should use curses (Ronald Schild).
+  dnl  On SCO Openserver should prefer termlib (Roger Cornelius).
+  case "`uname -s 2>/dev/null`" in
+	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
+	*)	tlibs="tinfo ncurses termlib termcap curses";;
+  esac
+  for libname in $tlibs; do
+    AC_CHECK_LIB(${libname}, tgetent,,)
+    if test "x$olibs" != "x$LIBS"; then
+      dnl It's possible that a library is found but it doesn't work
+      dnl e.g., shared library that cannot be found
+      dnl compile and run a test program to be sure
+      AC_TRY_RUN([
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main() {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(0); }],
+			  res="OK", res="FAIL", res="FAIL")
+      if test "$res" = "OK"; then
+	break
+      fi
+      AC_MSG_RESULT($libname library is not usable)
+      LIBS="$olibs"
+    fi
+  done
+  if test "x$olibs" = "x$LIBS"; then
+    AC_MSG_RESULT(no terminal library found)
+  fi
+fi
+
+if test "x$olibs" = "x$LIBS"; then
+  AC_MSG_CHECKING([for tgetent()])
+  AC_TRY_LINK([],
+      [char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist");],
+	AC_MSG_RESULT(yes),
+	AC_MSG_ERROR([NOT FOUND!
+      You need to install a terminal library; for example ncurses.
+      Or specify the name of the library with --with-tlib.]))
+fi
+
+AC_CACHE_CHECK([whether we talk terminfo], [vim_cv_terminfo],
+  [
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include "confdefs.h"
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main()
+{char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(!strcmp(s==0 ? "" : s, "1")); }
+    ]])],[
+      vim_cv_terminfo=no
+    ],[
+      vim_cv_terminfo=yes
+    ],[
+      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_terminfo')
+    ])
+  ])
+
+if test "x$vim_cv_terminfo" = "xyes" ; then
+  AC_DEFINE(TERMINFO)
+fi
+
+AC_CACHE_CHECK([what tgetent() returns for an unknown terminal], [vim_cv_tgetent],
+  [
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include "confdefs.h"
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main()
+{char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist"); exit(res != 0); }
+    ]])],[
+      vim_cv_tgetent=zero
+    ],[
+      vim_cv_tgetent=non-zero
+    ],[
+      AC_MSG_ERROR(failed to compile test program.)
+    ])
+  ])
+
+if test "x$vim_cv_tgetent" = "xzero" ; then
+  AC_DEFINE(TGETENT_ZERO_ERR, 0)
+fi
+
+AC_MSG_CHECKING(whether termcap.h contains ospeed)
+AC_TRY_LINK([
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+			], [ospeed = 20000],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OSPEED),
+	[AC_MSG_RESULT(no)
+	AC_MSG_CHECKING(whether ospeed can be extern)
+	AC_TRY_LINK([
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+extern short ospeed;
+			], [ospeed = 20000],
+		AC_MSG_RESULT(yes); AC_DEFINE(OSPEED_EXTERN),
+		AC_MSG_RESULT(no))]
+	)
+
+AC_MSG_CHECKING([whether termcap.h contains UP, BC and PC])
+AC_TRY_LINK([
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+			], [if (UP == 0 && BC == 0) PC = 1],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_UP_BC_PC),
+	[AC_MSG_RESULT(no)
+	AC_MSG_CHECKING([whether UP, BC and PC can be extern])
+	AC_TRY_LINK([
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+extern char *UP, *BC, PC;
+			], [if (UP == 0 && BC == 0) PC = 1],
+		AC_MSG_RESULT(yes); AC_DEFINE(UP_BC_PC_EXTERN),
+		AC_MSG_RESULT(no))]
+	)
+
+AC_MSG_CHECKING(whether tputs() uses outfuntype)
+AC_TRY_COMPILE([
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+			], [extern int xx(); tputs("test", 1, (outfuntype)xx)],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OUTFUNTYPE),
+	AC_MSG_RESULT(no))
+
+dnl On some SCO machines sys/select redefines struct timeval
+AC_MSG_CHECKING([whether sys/select.h and sys/time.h may both be included])
+AC_TRY_COMPILE([
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/select.h>], ,
+	  AC_MSG_RESULT(yes)
+			AC_DEFINE(SYS_SELECT_WITH_SYS_TIME),
+	  AC_MSG_RESULT(no))
+
+dnl AC_DECL_SYS_SIGLIST
+
+dnl Checks for pty.c (copied from screen) ==========================
+AC_MSG_CHECKING(for /dev/ptc)
+if test -r /dev/ptc; then
+  AC_DEFINE(HAVE_DEV_PTC)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+
+AC_MSG_CHECKING(for SVR4 ptys)
+if test -c /dev/ptmx ; then
+  AC_TRY_LINK([], [ptsname(0);grantpt(0);unlockpt(0);],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SVR4_PTYS),
+	AC_MSG_RESULT(no))
+else
+  AC_MSG_RESULT(no)
+fi
+
+AC_MSG_CHECKING(for ptyranges)
+if test -d /dev/ptym ; then
+  pdir='/dev/ptym'
+else
+  pdir='/dev'
+fi
+dnl SCO uses ptyp%d
+AC_EGREP_CPP(yes,
+[#ifdef M_UNIX
+   yes;
+#endif
+	], ptys=`echo /dev/ptyp??`, ptys=`echo $pdir/pty??`)
+dnl if test -c /dev/ptyp19; then
+dnl ptys=`echo /dev/ptyp??`
+dnl else
+dnl ptys=`echo $pdir/pty??`
+dnl fi
+if test "$ptys" != "$pdir/pty??" ; then
+  p0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | sort -u | tr -d '\012'`
+  p1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g'  | sort -u | tr -d '\012'`
+  AC_DEFINE_UNQUOTED(PTYRANGE0,"$p0")
+  AC_DEFINE_UNQUOTED(PTYRANGE1,"$p1")
+  AC_MSG_RESULT([$p0 / $p1])
+else
+  AC_MSG_RESULT([don't know])
+fi
+
+dnl    ****  pty mode/group handling ****
+dnl
+dnl support provided by Luke Mewburn <lm@rmit.edu.au>, 931222
+rm -f conftest_grp
+AC_CACHE_CHECK([default tty permissions/group], [vim_cv_tty_group],
+  [
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <sys/stat.h>
+#include <stdio.h>
+main()
+{
+  struct stat sb;
+  char *x,*ttyname();
+  int om, m;
+  FILE *fp;
+
+  if (!(x = ttyname(0))) exit(1);
+  if (stat(x, &sb)) exit(1);
+  om = sb.st_mode;
+  if (om & 002) exit(0);
+  m = system("mesg y");
+  if (m == -1 || m == 127) exit(1);
+  if (stat(x, &sb)) exit(1);
+  m = sb.st_mode;
+  if (chmod(x, om)) exit(1);
+  if (m & 002) exit(0);
+  if (sb.st_gid == getgid()) exit(1);
+  if (!(fp=fopen("conftest_grp", "w")))
+    exit(1);
+  fprintf(fp, "%d\n", sb.st_gid);
+  fclose(fp);
+  exit(0);
+}
+    ]])],[
+      if test -f conftest_grp; then
+	vim_cv_tty_group=`cat conftest_grp`
+	if test "x$vim_cv_tty_mode" = "x" ; then
+	  vim_cv_tty_mode=0620
+	fi
+	AC_MSG_RESULT([pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group])
+      else
+	vim_cv_tty_group=world
+	AC_MSG_RESULT([ptys are world accessible])
+      fi
+    ],[
+      vim_cv_tty_group=world
+      AC_MSG_RESULT([can't determine - assume ptys are world accessible])
+    ],[
+      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode')
+    ])
+  ])
+rm -f conftest_grp
+
+if test "x$vim_cv_tty_group" != "xworld" ; then
+  AC_DEFINE_UNQUOTED(PTYGROUP,$vim_cv_tty_group)
+  if test "x$vim_cv_tty_mode" = "x" ; then
+    AC_MSG_ERROR([It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)])
+  else
+    AC_DEFINE(PTYMODE, 0620)
+  fi
+fi
+
+dnl Checks for library functions. ===================================
+
+AC_TYPE_SIGNAL
+
+dnl find out what to use at the end of a signal function
+if test $ac_cv_type_signal = void; then
+  AC_DEFINE(SIGRETURN, [return])
+else
+  AC_DEFINE(SIGRETURN, [return 0])
+fi
+
+dnl check if struct sigcontext is defined (used for SGI only)
+AC_MSG_CHECKING(for struct sigcontext)
+AC_TRY_COMPILE([
+#include <signal.h>
+test_sig()
+{
+    struct sigcontext *scont;
+    scont = (struct sigcontext *)0;
+    return 1;
+} ], ,
+	  AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_SIGCONTEXT),
+	  AC_MSG_RESULT(no))
+
+dnl tricky stuff: try to find out if getcwd() is implemented with
+dnl system("sh -c pwd")
+AC_CACHE_CHECK([getcwd implementation is broken], [vim_cv_getcwd_broken],
+  [
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include "confdefs.h"
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+char *dagger[] = { "IFS=pwd", 0 };
+main()
+{
+  char buffer[500];
+  extern char **environ;
+  environ = dagger;
+  return getcwd(buffer, 500) ? 0 : 1;
+}
+    ]])],[
+      vim_cv_getcwd_broken=no
+    ],[
+      vim_cv_getcwd_broken=yes
+    ],[
+      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_getcwd_broken')
+    ])
+  ])
+
+if test "x$vim_cv_getcwd_broken" = "xyes" ; then
+  AC_DEFINE(BAD_GETCWD)
+fi
+
+dnl Check for functions in one big call, to reduce the size of configure.
+dnl Can only be used for functions that do not require any include.
+AC_CHECK_FUNCS(fchdir fchown fchmod fsync getcwd getpseudotty \
+	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \
+	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
+	getpgid setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
+	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
+	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
+	usleep utime utimes mblen ftruncate unsetenv)
+AC_FUNC_FSEEKO
+
+dnl define _LARGE_FILES, _FILE_OFFSET_BITS and _LARGEFILE_SOURCE when
+dnl appropriate, so that off_t is 64 bits when needed.
+AC_SYS_LARGEFILE
+
+dnl fstatfs() can take 2 to 4 arguments, try to use st_blksize if possible
+AC_MSG_CHECKING(for st_blksize)
+AC_TRY_COMPILE(
+[#include <sys/types.h>
+#include <sys/stat.h>],
+[	struct stat st;
+	int n;
+
+	stat("/", &st);
+	n = (int)st.st_blksize;],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ST_BLKSIZE),
+	AC_MSG_RESULT(no))
+
+AC_CACHE_CHECK([whether stat() ignores a trailing slash], [vim_cv_stat_ignores_slash],
+  [
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include "confdefs.h"
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#include <sys/types.h>
+#include <sys/stat.h>
+main() {struct stat st;  exit(stat("configure/", &st) != 0); }
+    ]])],[
+      vim_cv_stat_ignores_slash=yes
+    ],[
+      vim_cv_stat_ignores_slash=no
+    ],[
+      AC_MSG_ERROR(cross-compiling: please set 'vim_cv_stat_ignores_slash')
+    ])
+  ])
+
+if test "x$vim_cv_stat_ignores_slash" = "xyes" ; then
+  AC_DEFINE(STAT_IGNORES_SLASH)
+fi
+  
+dnl Link with iconv for charset translation, if not found without library.
+dnl check for iconv() requires including iconv.h
+dnl Add "-liconv" when possible; Solaris has iconv but use GNU iconv when it
+dnl has been installed.
+AC_MSG_CHECKING(for iconv_open())
+save_LIBS="$LIBS"
+LIBS="$LIBS -liconv"
+AC_TRY_LINK([
+#ifdef HAVE_ICONV_H
+# include <iconv.h>
+#endif
+    ], [iconv_open("fr", "to");],
+    AC_MSG_RESULT(yes; with -liconv); AC_DEFINE(HAVE_ICONV),
+    LIBS="$save_LIBS"
+    AC_TRY_LINK([
+#ifdef HAVE_ICONV_H
+# include <iconv.h>
+#endif
+	], [iconv_open("fr", "to");],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ICONV),
+	AC_MSG_RESULT(no)))
+
+
+AC_MSG_CHECKING(for nl_langinfo(CODESET))
+AC_TRY_LINK([
+#ifdef HAVE_LANGINFO_H
+# include <langinfo.h>
+#endif
+], [char *cs = nl_langinfo(CODESET);],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_NL_LANGINFO_CODESET),
+	AC_MSG_RESULT(no))
+
+dnl Need various functions for floating point support.  Only enable
+dnl floating point when they are all present.
+AC_CHECK_LIB(m, strtod)
+AC_MSG_CHECKING([for strtod() and other floating point functions])
+AC_TRY_LINK([
+#ifdef HAVE_MATH_H
+# include <math.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+], [char *s; double d;
+    d = strtod("1.1", &s);
+    d = fabs(1.11);
+    d = ceil(1.11);
+    d = floor(1.11);
+    d = log10(1.11);
+    d = pow(1.11, 2.22);
+    d = sqrt(1.11);
+    d = sin(1.11);
+    d = cos(1.11);
+    d = atan(1.11);
+    ],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FLOAT_FUNCS),
+	AC_MSG_RESULT(no))
+
+dnl isinf() and isnan() need to include header files and may need -lm.
+AC_MSG_CHECKING([for isinf()])
+AC_TRY_LINK([
+#ifdef HAVE_MATH_H
+# include <math.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+], [int r = isinf(1.11); ],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISINF),
+	AC_MSG_RESULT(no))
+
+AC_MSG_CHECKING([for isnan()])
+AC_TRY_LINK([
+#ifdef HAVE_MATH_H
+# include <math.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+], [int r = isnan(1.11); ],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISNAN),
+	AC_MSG_RESULT(no))
+
+dnl Link with -lposix1e for ACL stuff; if not found, try -lacl for SGI
+dnl when -lacl works, also try to use -lattr (required for Debian).
+dnl On Solaris, use the acl_get/set functions in libsec, if present.
+AC_MSG_CHECKING(--disable-acl argument)
+AC_ARG_ENABLE(acl,
+	[  --disable-acl           No check for ACL support.],
+	, [enable_acl="yes"])
+if test "$enable_acl" = "yes"; then
+  AC_MSG_RESULT(no)
+  AC_CHECK_LIB(posix1e, acl_get_file, [LIBS="$LIBS -lposix1e"],
+	AC_CHECK_LIB(acl, acl_get_file, [LIBS="$LIBS -lacl"
+		  AC_CHECK_LIB(attr, fgetxattr, LIBS="$LIBS -lattr",,)],,),)
+
+  AC_MSG_CHECKING(for POSIX ACL support)
+  AC_TRY_LINK([
+#include <sys/types.h>
+#ifdef HAVE_SYS_ACL_H
+# include <sys/acl.h>
+#endif
+acl_t acl;], [acl = acl_get_file("foo", ACL_TYPE_ACCESS);
+	acl_set_file("foo", ACL_TYPE_ACCESS, acl);
+	acl_free(acl);],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_POSIX_ACL),
+	AC_MSG_RESULT(no))
+
+  AC_CHECK_LIB(sec, acl_get, [LIBS="$LIBS -lsec"; AC_DEFINE(HAVE_SOLARIS_ZFS_ACL)],
+  AC_MSG_CHECKING(for Solaris ACL support)
+  AC_TRY_LINK([
+#ifdef HAVE_SYS_ACL_H
+# include <sys/acl.h>
+#endif], [acl("foo", GETACLCNT, 0, NULL);
+	],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SOLARIS_ACL),
+	AC_MSG_RESULT(no)))
+
+  AC_MSG_CHECKING(for AIX ACL support)
+  AC_TRY_LINK([
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#ifdef HAVE_SYS_ACL_H
+# include <sys/acl.h>
+#endif
+#ifdef HAVE_SYS_ACCESS_H
+# include <sys/access.h>
+#endif
+#define _ALL_SOURCE
+
+#include <sys/stat.h>
+
+int aclsize;
+struct acl *aclent;], [aclsize = sizeof(struct acl);
+	aclent = (void *)malloc(aclsize);
+	statacl("foo", STX_NORMAL, aclent, aclsize);
+	],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_AIX_ACL),
+	AC_MSG_RESULT(no))
+else
+  AC_MSG_RESULT(yes)
+fi
+
+if test "x$GTK_CFLAGS" != "x"; then
+  dnl pango_shape_full() is new, fall back to pango_shape().
+  AC_MSG_CHECKING(for pango_shape_full)
+  ac_save_CFLAGS="$CFLAGS"
+  ac_save_LIBS="$LIBS"
+  CFLAGS="$CFLAGS $GTK_CFLAGS"
+  LIBS="$LIBS $GTK_LIBS"
+  AC_TRY_LINK(
+  [#include <gtk/gtk.h>],
+  [ pango_shape_full(NULL, 0, NULL, 0, NULL, NULL); ],
+	  AC_MSG_RESULT(yes); AC_DEFINE(HAVE_PANGO_SHAPE_FULL),
+	  AC_MSG_RESULT(no))
+  CFLAGS="$ac_save_CFLAGS"
+  LIBS="$ac_save_LIBS"
+fi
+
+AC_MSG_CHECKING(--disable-gpm argument)
+AC_ARG_ENABLE(gpm,
+	[  --disable-gpm           Don't use gpm (Linux mouse daemon).], ,
+	[enable_gpm="yes"])
+
+if test "$enable_gpm" = "yes"; then
+  AC_MSG_RESULT(no)
+  dnl Checking if gpm support can be compiled
+  AC_CACHE_CHECK([for gpm], vi_cv_have_gpm,
+	[olibs="$LIBS" ; LIBS="-lgpm"]
+	AC_TRY_LINK(
+	    [#include <gpm.h>
+	    #include <linux/keyboard.h>],
+	    [Gpm_GetLibVersion(NULL);],
+	    dnl Configure defines HAVE_GPM, if it is defined feature.h defines
+	    dnl FEAT_MOUSE_GPM if mouse support is included
+	    [vi_cv_have_gpm=yes],
+	    [vi_cv_have_gpm=no])
+	[LIBS="$olibs"]
+    )
+  if test $vi_cv_have_gpm = yes; then
+    LIBS="$LIBS -lgpm"
+    AC_DEFINE(HAVE_GPM)
+  fi
+else
+  AC_MSG_RESULT(yes)
+fi
+
+AC_MSG_CHECKING(--disable-sysmouse argument)
+AC_ARG_ENABLE(sysmouse,
+	[  --disable-sysmouse      Don't use sysmouse (mouse in *BSD console).], ,
+	[enable_sysmouse="yes"])
+
+if test "$enable_sysmouse" = "yes"; then
+  AC_MSG_RESULT(no)
+  dnl Checking if sysmouse support can be compiled
+  dnl Configure defines HAVE_SYSMOUSE, if it is defined feature.h
+  dnl defines FEAT_SYSMOUSE if mouse support is included
+  AC_CACHE_CHECK([for sysmouse], vi_cv_have_sysmouse,
+	AC_TRY_LINK(
+	    [#include <sys/consio.h>
+	     #include <signal.h>
+	     #include <sys/fbio.h>],
+	    [struct mouse_info   mouse;
+	     mouse.operation = MOUSE_MODE;
+	     mouse.operation = MOUSE_SHOW;
+	     mouse.u.mode.mode = 0;
+	     mouse.u.mode.signal = SIGUSR2;],
+	    [vi_cv_have_sysmouse=yes],
+	    [vi_cv_have_sysmouse=no])
+    )
+  if test $vi_cv_have_sysmouse = yes; then
+    AC_DEFINE(HAVE_SYSMOUSE)
+  fi
+else
+  AC_MSG_RESULT(yes)
+fi
+
+dnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known
+AC_MSG_CHECKING(for FD_CLOEXEC)
+AC_TRY_COMPILE(
+[#if HAVE_FCNTL_H
+# include <fcntl.h>
+#endif],
+[	int flag = FD_CLOEXEC;],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),
+	AC_MSG_RESULT(not usable))
+
+dnl rename needs to be checked separately to work on Nextstep with cc
+AC_MSG_CHECKING(for rename)
+AC_TRY_LINK([#include <stdio.h>], [rename("this", "that")],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_RENAME),
+	AC_MSG_RESULT(no))
+
+dnl sysctl() may exist but not the arguments we use
+AC_MSG_CHECKING(for sysctl)
+AC_TRY_COMPILE(
+[#include <sys/types.h>
+#include <sys/sysctl.h>],
+[	int mib[2], r;
+	size_t len;
+
+	mib[0] = CTL_HW;
+	mib[1] = HW_USERMEM;
+	len = sizeof(r);
+	(void)sysctl(mib, 2, &r, &len, (void *)0, (size_t)0);
+	],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCTL),
+	AC_MSG_RESULT(not usable))
+
+dnl sysinfo() may exist but not be Linux compatible
+AC_MSG_CHECKING(for sysinfo)
+AC_TRY_COMPILE(
+[#include <sys/types.h>
+#include <sys/sysinfo.h>],
+[	struct sysinfo sinfo;
+	int t;
+
+	(void)sysinfo(&sinfo);
+	t = sinfo.totalram;
+	],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO),
+	AC_MSG_RESULT(not usable))
+
+dnl struct sysinfo may have the mem_unit field or not
+AC_MSG_CHECKING(for sysinfo.mem_unit)
+AC_TRY_COMPILE(
+[#include <sys/types.h>
+#include <sys/sysinfo.h>],
+[	struct sysinfo sinfo;
+	sinfo.mem_unit = 1;
+	],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO_MEM_UNIT),
+	AC_MSG_RESULT(no))
+
+dnl sysconf() may exist but not support what we want to use
+AC_MSG_CHECKING(for sysconf)
+AC_TRY_COMPILE(
+[#include <unistd.h>],
+[	(void)sysconf(_SC_PAGESIZE);
+	(void)sysconf(_SC_PHYS_PAGES);
+	],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCONF),
+	AC_MSG_RESULT(not usable))
+
+AC_CHECK_SIZEOF([int])
+AC_CHECK_SIZEOF([long])
+AC_CHECK_SIZEOF([time_t])
+AC_CHECK_SIZEOF([off_t])
+
+dnl Use different names to avoid clashing with other header files.
+AC_DEFINE_UNQUOTED(VIM_SIZEOF_INT, [$ac_cv_sizeof_int])
+AC_DEFINE_UNQUOTED(VIM_SIZEOF_LONG, [$ac_cv_sizeof_long])
+
+dnl Make sure that uint32_t is really 32 bits unsigned.
+AC_MSG_CHECKING([uint32_t is 32 bits])
+AC_TRY_RUN([
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+main() {
+  uint32_t nr1 = (uint32_t)-1;
+  uint32_t nr2 = (uint32_t)0xffffffffUL;
+  if (sizeof(uint32_t) != 4 || nr1 != 0xffffffffUL || nr2 + 1 != 0) exit(1);
+  exit(0);
+}],
+AC_MSG_RESULT(ok),
+AC_MSG_ERROR([WRONG!  uint32_t not defined correctly.]),
+AC_MSG_WARN([cannot check uint32_t when cross-compiling.]))
+
+dnl Check for memmove() before bcopy(), makes memmove() be used when both are
+dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
+
+[bcopy_test_prog='
+#include "confdefs.h"
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main() {
+  char buf[10];
+  strcpy(buf, "abcdefghi");
+  mch_memmove(buf, buf + 2, 3);
+  if (strncmp(buf, "ababcf", 6))
+    exit(1);
+  strcpy(buf, "abcdefghi");
+  mch_memmove(buf + 2, buf, 3);
+  if (strncmp(buf, "cdedef", 6))
+    exit(1);
+  exit(0); /* libc version works properly.  */
+}']
+
+AC_CACHE_CHECK([whether memmove handles overlaps],[vim_cv_memmove_handles_overlap],
+  [
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]])],
+      [
+	vim_cv_memmove_handles_overlap=yes
+      ],[
+	vim_cv_memmove_handles_overlap=no
+      ],[
+	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memmove_handles_overlap')
+      ])
+  ])
+
+if test "x$vim_cv_memmove_handles_overlap" = "xyes" ; then
+  AC_DEFINE(USEMEMMOVE)
+else
+  AC_CACHE_CHECK([whether bcopy handles overlaps],[vim_cv_bcopy_handles_overlap],
+    [
+      AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]])],
+      [
+	vim_cv_bcopy_handles_overlap=yes
+      ],[
+	vim_cv_bcopy_handles_overlap=no
+      ],[
+	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_bcopy_handles_overlap')
+      ])
+    ])
+
+  if test "x$vim_cv_bcopy_handles_overlap" = "xyes" ; then
+    AC_DEFINE(USEBCOPY)
+  else
+    AC_CACHE_CHECK([whether memcpy handles overlaps],[vim_cv_memcpy_handles_overlap],
+      [
+	AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]])],
+	  [
+	    vim_cv_memcpy_handles_overlap=yes
+	  ],[
+	    vim_cv_memcpy_handles_overlap=no
+	  ],[
+	    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memcpy_handles_overlap')
+	  ])
+      ])
+
+    if test "x$vim_cv_memcpy_handles_overlap" = "xyes" ; then
+      AC_DEFINE(USEMEMCPY)
+    fi
+  fi
+fi
+
+
+dnl Check for multibyte locale functions
+dnl Find out if _Xsetlocale() is supported by libX11.
+dnl Check if X_LOCALE should be defined.
+if test "x$with_x" = "xyes"; then
+  cflags_save=$CFLAGS
+  libs_save=$LIBS
+  LIBS="$LIBS $X_LIBS $GUI_LIB_LOC $GUI_X_LIBS $X_PRE_LIBS $X_LIB $X_EXTRA_LIBS"
+  CFLAGS="$CFLAGS $X_CFLAGS"
+
+  AC_MSG_CHECKING(whether X_LOCALE needed)
+  AC_TRY_COMPILE([#include <X11/Xlocale.h>],,
+      AC_TRY_LINK_FUNC([_Xsetlocale], [AC_MSG_RESULT(yes)
+	      AC_DEFINE(X_LOCALE)], AC_MSG_RESULT(no)),
+      AC_MSG_RESULT(no))
+
+  AC_MSG_CHECKING(whether Xutf8SetWMProperties() can be used)
+  AC_TRY_LINK_FUNC([Xutf8SetWMProperties], [AC_MSG_RESULT(yes)
+	      AC_DEFINE(HAVE_XUTF8SETWMPROPERTIES)], AC_MSG_RESULT(no))
+
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+fi
+
+dnl Link with xpg4, it is said to make Korean locale working
+AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
+
+dnl Check how we can run ctags.  Default to "ctags" when nothing works.
+dnl Use --version to detect Exuberant ctags (preferred)
+dnl       Add --fields=+S to get function signatures for omni completion.
+dnl -t for typedefs (many ctags have this)
+dnl -s for static functions (Elvis ctags only?)
+dnl -v for variables. Dangerous, most ctags take this for 'vgrind style'.
+dnl -i+m to test for older Exuberant ctags
+AC_MSG_CHECKING(how to create tags)
+test -f tags && mv tags tags.save
+if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+  TAGPRG="ctags -I INIT+ --fields=+S"
+elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+  TAGPRG="exctags -I INIT+ --fields=+S"
+elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+  TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
+else
+  TAGPRG="ctags"
+  (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
+  (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
+  (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
+  (eval ctags -t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -t"
+  (eval ctags -ts  /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -ts"
+  (eval ctags -tvs /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -tvs"
+  (eval ctags -i+m /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -i+m"
+fi
+test -f tags.save && mv tags.save tags
+AC_MSG_RESULT($TAGPRG) AC_SUBST(TAGPRG)
+
+dnl Check how we can run man with a section number
+AC_MSG_CHECKING(how to run man with a section nr)
+MANDEF="man"
+(eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF="man -s"
+AC_MSG_RESULT($MANDEF)
+if test "$MANDEF" = "man -s"; then
+  AC_DEFINE(USEMAN_S)
+fi
+
+dnl Check if gettext() is working and if it needs -lintl
+dnl We take care to base this on an empty LIBS: on some systems libelf would be
+dnl in LIBS and implicitly take along libintl. The final LIBS would then not
+dnl contain libintl, and the link step would fail due to -Wl,--as-needed.
+AC_MSG_CHECKING(--disable-nls argument)
+AC_ARG_ENABLE(nls,
+	[  --disable-nls           Don't support NLS (gettext()).], ,
+	[enable_nls="yes"])
+
+if test "$enable_nls" = "yes"; then
+  AC_MSG_RESULT(no)
+
+  INSTALL_LANGS=install-languages
+  AC_SUBST(INSTALL_LANGS)
+  INSTALL_TOOL_LANGS=install-tool-languages
+  AC_SUBST(INSTALL_TOOL_LANGS)
+
+  AC_CHECK_PROG(MSGFMT, msgfmt, msgfmt, )
+  AC_MSG_CHECKING([for NLS])
+  if test -f po/Makefile; then
+    have_gettext="no"
+    if test -n "$MSGFMT"; then
+      olibs=$LIBS
+      LIBS=""
+      AC_TRY_LINK(
+	[#include <libintl.h>],
+	[gettext("Test");],
+	AC_MSG_RESULT([gettext() works]); have_gettext="yes"; LIBS=$olibs,
+	  LIBS="-lintl"
+	  AC_TRY_LINK(
+	      [#include <libintl.h>],
+	      [gettext("Test");],
+	      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext="yes";
+	      LIBS="$olibs -lintl",
+	      AC_MSG_RESULT([gettext() doesn't work]);
+	      LIBS=$olibs))
+    else
+      AC_MSG_RESULT([msgfmt not found - disabled]);
+    fi
+    if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
+      AC_DEFINE(HAVE_GETTEXT)
+      MAKEMO=yes
+      AC_SUBST(MAKEMO)
+      dnl this was added in GNU gettext 0.10.36
+      AC_CHECK_FUNCS(bind_textdomain_codeset)
+      dnl _nl_msg_cat_cntr is required for GNU gettext
+      AC_MSG_CHECKING([for _nl_msg_cat_cntr])
+      AC_TRY_LINK(
+		[#include <libintl.h>
+		extern int _nl_msg_cat_cntr;],
+		[++_nl_msg_cat_cntr;],
+		AC_MSG_RESULT([yes]); AC_DEFINE(HAVE_NL_MSG_CAT_CNTR),
+		AC_MSG_RESULT([no]))
+    fi
+  else
+    AC_MSG_RESULT([no "po/Makefile" - disabled]);
+  fi
+else
+  AC_MSG_RESULT(yes)
+fi
+
+dnl Check for dynamic linking loader
+AC_CHECK_HEADER(dlfcn.h, DLL=dlfcn.h, [AC_CHECK_HEADER(dl.h, DLL=dl.h)])
+if test x${DLL} = xdlfcn.h; then
+  AC_DEFINE(HAVE_DLFCN_H, 1, [ Define if we have dlfcn.h. ])
+  AC_MSG_CHECKING([for dlopen()])
+  AC_TRY_LINK(,[
+		extern void* dlopen();
+		dlopen();
+      ],
+      AC_MSG_RESULT(yes);
+	      AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
+      AC_MSG_RESULT(no);
+	      AC_MSG_CHECKING([for dlopen() in -ldl])
+	      olibs=$LIBS
+	      LIBS="$LIBS -ldl"
+	      AC_TRY_LINK(,[
+				extern void* dlopen();
+				dlopen();
+		 ],
+		 AC_MSG_RESULT(yes);
+			  AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
+		 AC_MSG_RESULT(no);
+			  LIBS=$olibs))
+  dnl ReliantUNIX has dlopen() in libc but everything else in libdl
+  dnl ick :-)
+  AC_MSG_CHECKING([for dlsym()])
+  AC_TRY_LINK(,[
+		extern void* dlsym();
+		dlsym();
+      ],
+      AC_MSG_RESULT(yes);
+	      AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
+      AC_MSG_RESULT(no);
+	      AC_MSG_CHECKING([for dlsym() in -ldl])
+	      olibs=$LIBS
+	      LIBS="$LIBS -ldl"
+	      AC_TRY_LINK(,[
+				extern void* dlsym();
+				dlsym();
+		 ],
+		 AC_MSG_RESULT(yes);
+			  AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
+		 AC_MSG_RESULT(no);
+			  LIBS=$olibs))
+elif test x${DLL} = xdl.h; then
+  AC_DEFINE(HAVE_DL_H, 1, [ Define if we have dl.h. ])
+  AC_MSG_CHECKING([for shl_load()])
+  AC_TRY_LINK(,[
+		extern void* shl_load();
+		shl_load();
+     ],
+     AC_MSG_RESULT(yes);
+	  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
+     AC_MSG_RESULT(no);
+	  AC_MSG_CHECKING([for shl_load() in -ldld])
+	  olibs=$LIBS
+	  LIBS="$LIBS -ldld"
+	  AC_TRY_LINK(,[
+			extern void* shl_load();
+			shl_load();
+	     ],
+	     AC_MSG_RESULT(yes);
+		  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
+	     AC_MSG_RESULT(no);
+		  LIBS=$olibs))
+fi
+AC_CHECK_HEADERS(setjmp.h)
+
+if test "x$MACOS_X" = "xyes" -a -n "$PERL"; then
+  dnl -ldl must come after DynaLoader.a
+  if echo $LIBS | grep -e '-ldl' >/dev/null; then
+    LIBS=`echo $LIBS | sed s/-ldl//`
+    PERL_LIBS="$PERL_LIBS -ldl"
+  fi
+fi
+
+if test "$MACOS_X" = "yes"; then
+  AC_MSG_CHECKING([whether we need macOS frameworks])
+  if test "$GUITYPE" = "CARBONGUI"; then
+    AC_MSG_RESULT([yes, we need Carbon])
+    LIBS="$LIBS -framework Carbon"
+  elif test "$MACOS_X_DARWIN" = "yes"; then
+    if test "$features" = "tiny"; then
+      dnl Since no FEAT_CLIPBOARD, no longer need for os_macosx.m.
+      OS_EXTRA_SRC=`echo "$OS_EXTRA_SRC" | sed -e 's+os_macosx.m++'`
+      OS_EXTRA_OBJ=`echo "$OS_EXTRA_OBJ" | sed -e 's+objects/os_macosx.o++'`
+      if test "$enable_multibyte" = "yes"; then
+        AC_MSG_RESULT([yes, we need CoreServices])
+        LIBS="$LIBS -framework CoreServices"
+      else
+        dnl Since no FEAT_MBYTE, no longer need for os_mac_conv.c.
+        AC_MSG_RESULT([no])
+        OS_EXTRA_SRC=`echo "$OS_EXTRA_SRC" | sed -e 's+os_mac_conv.c++'`
+        OS_EXTRA_OBJ=`echo "$OS_EXTRA_OBJ" | sed -e 's+objects/os_mac_conv.o++'`
+        CPPFLAGS=`echo "$CPPFLAGS" | sed -e 's+-DMACOS_X_DARWIN++'`
+      fi
+    else
+      AC_MSG_RESULT([yes, we need AppKit])
+      LIBS="$LIBS -framework AppKit"
+      if test "$features" = "small" -a "$enable_multibyte" = "no"; then
+        dnl Since FEAT_CLIPBOARD is to be defined in vim.h for FEAT_SMALL, define
+        dnl FEAT_MBYTE in order not to compromise the interoperability of the
+        dnl clipboard.
+        AC_MSG_NOTICE([+multi_byte will be set in favor of +clipboard])
+        enable_multibyte=yes
+        AC_DEFINE(FEAT_MBYTE)
+      fi
+    fi
+  else
+    AC_MSG_RESULT([no])
+  fi
+fi
+if test "x$MACARCH" = "xboth" && test "x$GUITYPE" = "xCARBONGUI"; then
+  LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+fi
+
+dnl gcc 3.1 changed the meaning of -MM.  The only solution appears to be to
+dnl use "-isystem" instead of "-I" for all non-Vim include dirs.
+dnl But only when making dependencies, cproto and lint don't take "-isystem".
+dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
+dnl the number before the version number.
+DEPEND_CFLAGS_FILTER=
+if test "$GCC" = yes; then
+  AC_MSG_CHECKING(for GCC 3 or later)
+  gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
+  if test "$gccmajor" -gt "2"; then
+    DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
+  fi
+  dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
+  dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
+  dnl Also remove duplicate _FORTIFY_SOURCE arguments.
+  dnl And undefine it first to avoid a warning.
+  AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS=`echo "$CFLAGS" | sed -e 's/ *-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/ *-D_FORTIFY_SOURCE=.//g' -e 's/ *-U_FORTIFY_SOURCE//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
+  fi
+fi
+AC_SUBST(DEPEND_CFLAGS_FILTER)
+
+dnl On some systems AC_SYS_LARGEFILE determines that -D_FILE_OFFSET_BITS=64
+dnl isn't required, but the CFLAGS for some of the libraries we're using
+dnl include the define.  Since the define changes the size of some datatypes
+dnl (e.g. ino_t and off_t), all of Vim's modules must be compiled with a
+dnl consistent value.  It's therefore safest to force the use of the define
+dnl if it's present in any of the *_CFLAGS variables.
+AC_MSG_CHECKING(whether we need to force -D_FILE_OFFSET_BITS=64)
+if echo "$CFLAGS $LUA_CFLAGS $MZSCHEME_CFLAGS $PERL_CFLAGS $PYTHON_CFLAGS $PYTHON3_CFLAGS $TCL_CFLAGS $RUBY_CFLAGS $GTK_CFLAGS" | grep -q D_FILE_OFFSET_BITS 2>/dev/null; then
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(_FILE_OFFSET_BITS, 64)
+else
+  AC_MSG_RESULT(no)
+fi
+
+dnl link.sh tries to avoid overlinking in a hackish way.
+dnl At least GNU ld supports --as-needed which provides the same functionality
+dnl at linker level. Let's use it.
+AC_MSG_CHECKING(linker --as-needed support)
+LINK_AS_NEEDED=
+# Check if linker supports --as-needed and --no-as-needed options
+if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+  LDFLAGS=`echo "$LDFLAGS" | sed -e 's/ *-Wl,--as-needed//g' | sed -e 's/$/ -Wl,--as-needed/'`
+  LINK_AS_NEEDED=yes
+fi
+if test "$LINK_AS_NEEDED" = yes; then
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST(LINK_AS_NEEDED)
+
+# IBM z/OS reset CFLAGS for config.mk
+if test "$zOSUnix" = "yes"; then
+	CFLAGS="-D_ALL_SOURCE -Wc,float\(ieee\),dll"
+fi
+
+dnl write output files
+AC_OUTPUT(auto/config.mk:config.mk.in)
+
+dnl vim: set sw=2 tw=78 fo+=l:
diff --git a/src/evalfunc.c b/src/evalfunc.c
index 8a1fcef..ce7cba5 100644
--- a/src/evalfunc.c
+++ b/src/evalfunc.c
@@ -5969,6 +5969,9 @@ f_has(typval_T *argvars, typval_T *rettv)
 #ifdef __BEOS__
 	"beos",
 #endif
+#ifdef __HAIKU__
+       "haiku",
+#endif
 #ifdef MACOS_X
 	"mac",		/* Mac OS X (and, once, Mac OS Classic) */
 	"osx",		/* Mac OS X */
@@ -6150,6 +6153,9 @@ f_has(typval_T *argvars, typval_T *rettv)
 #ifdef FEAT_GUI_GNOME
 	"gui_gnome",
 #endif
+#ifdef FEAT_GUI_HAIKU
+	"gui_haiku",
+#endif
 #ifdef FEAT_GUI_MAC
 	"gui_mac",
 #endif
diff --git a/b/src/evalfunc.c.orig b/src/evalfunc.c.orig
new file mode 100644
index 0000000..8a1fcef
--- /dev/null
+++ b/src/evalfunc.c.orig
@@ -0,0 +1,14027 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * evalfunc.c: Builtin functions
+ */
+#define USING_FLOAT_STUFF
+
+#include "vim.h"
+
+#if defined(FEAT_EVAL) || defined(PROTO)
+
+#ifdef AMIGA
+# include <time.h>	/* for strftime() */
+#endif
+
+#ifdef VMS
+# include <float.h>
+#endif
+
+#ifdef MACOS_X
+# include <time.h>	/* for time_t */
+#endif
+
+static char *e_listarg = N_("E686: Argument of %s must be a List");
+#ifdef FEAT_QUICKFIX
+static char *e_stringreq = N_("E928: String required");
+#endif
+
+#ifdef FEAT_FLOAT
+static void f_abs(typval_T *argvars, typval_T *rettv);
+static void f_acos(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_add(typval_T *argvars, typval_T *rettv);
+static void f_and(typval_T *argvars, typval_T *rettv);
+static void f_append(typval_T *argvars, typval_T *rettv);
+static void f_appendbufline(typval_T *argvars, typval_T *rettv);
+static void f_argc(typval_T *argvars, typval_T *rettv);
+static void f_argidx(typval_T *argvars, typval_T *rettv);
+static void f_arglistid(typval_T *argvars, typval_T *rettv);
+static void f_argv(typval_T *argvars, typval_T *rettv);
+static void f_assert_beeps(typval_T *argvars, typval_T *rettv);
+static void f_assert_equal(typval_T *argvars, typval_T *rettv);
+static void f_assert_equalfile(typval_T *argvars, typval_T *rettv);
+static void f_assert_exception(typval_T *argvars, typval_T *rettv);
+static void f_assert_fails(typval_T *argvars, typval_T *rettv);
+static void f_assert_false(typval_T *argvars, typval_T *rettv);
+static void f_assert_inrange(typval_T *argvars, typval_T *rettv);
+static void f_assert_match(typval_T *argvars, typval_T *rettv);
+static void f_assert_notequal(typval_T *argvars, typval_T *rettv);
+static void f_assert_notmatch(typval_T *argvars, typval_T *rettv);
+static void f_assert_report(typval_T *argvars, typval_T *rettv);
+static void f_assert_true(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_asin(typval_T *argvars, typval_T *rettv);
+static void f_atan(typval_T *argvars, typval_T *rettv);
+static void f_atan2(typval_T *argvars, typval_T *rettv);
+#endif
+#ifdef FEAT_BEVAL
+static void f_balloon_show(typval_T *argvars, typval_T *rettv);
+# if defined(FEAT_BEVAL_TERM)
+static void f_balloon_split(typval_T *argvars, typval_T *rettv);
+# endif
+#endif
+static void f_browse(typval_T *argvars, typval_T *rettv);
+static void f_browsedir(typval_T *argvars, typval_T *rettv);
+static void f_bufexists(typval_T *argvars, typval_T *rettv);
+static void f_buflisted(typval_T *argvars, typval_T *rettv);
+static void f_bufloaded(typval_T *argvars, typval_T *rettv);
+static void f_bufname(typval_T *argvars, typval_T *rettv);
+static void f_bufnr(typval_T *argvars, typval_T *rettv);
+static void f_bufwinid(typval_T *argvars, typval_T *rettv);
+static void f_bufwinnr(typval_T *argvars, typval_T *rettv);
+static void f_byte2line(typval_T *argvars, typval_T *rettv);
+static void byteidx(typval_T *argvars, typval_T *rettv, int comp);
+static void f_byteidx(typval_T *argvars, typval_T *rettv);
+static void f_byteidxcomp(typval_T *argvars, typval_T *rettv);
+static void f_call(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_ceil(typval_T *argvars, typval_T *rettv);
+#endif
+#ifdef FEAT_JOB_CHANNEL
+static void f_ch_canread(typval_T *argvars, typval_T *rettv);
+static void f_ch_close(typval_T *argvars, typval_T *rettv);
+static void f_ch_close_in(typval_T *argvars, typval_T *rettv);
+static void f_ch_evalexpr(typval_T *argvars, typval_T *rettv);
+static void f_ch_evalraw(typval_T *argvars, typval_T *rettv);
+static void f_ch_getbufnr(typval_T *argvars, typval_T *rettv);
+static void f_ch_getjob(typval_T *argvars, typval_T *rettv);
+static void f_ch_info(typval_T *argvars, typval_T *rettv);
+static void f_ch_log(typval_T *argvars, typval_T *rettv);
+static void f_ch_logfile(typval_T *argvars, typval_T *rettv);
+static void f_ch_open(typval_T *argvars, typval_T *rettv);
+static void f_ch_read(typval_T *argvars, typval_T *rettv);
+static void f_ch_readraw(typval_T *argvars, typval_T *rettv);
+static void f_ch_sendexpr(typval_T *argvars, typval_T *rettv);
+static void f_ch_sendraw(typval_T *argvars, typval_T *rettv);
+static void f_ch_setoptions(typval_T *argvars, typval_T *rettv);
+static void f_ch_status(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_changenr(typval_T *argvars, typval_T *rettv);
+static void f_char2nr(typval_T *argvars, typval_T *rettv);
+static void f_cindent(typval_T *argvars, typval_T *rettv);
+static void f_clearmatches(typval_T *argvars, typval_T *rettv);
+static void f_col(typval_T *argvars, typval_T *rettv);
+#if defined(FEAT_INS_EXPAND)
+static void f_complete(typval_T *argvars, typval_T *rettv);
+static void f_complete_add(typval_T *argvars, typval_T *rettv);
+static void f_complete_check(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_confirm(typval_T *argvars, typval_T *rettv);
+static void f_copy(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_cos(typval_T *argvars, typval_T *rettv);
+static void f_cosh(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_count(typval_T *argvars, typval_T *rettv);
+static void f_cscope_connection(typval_T *argvars, typval_T *rettv);
+static void f_cursor(typval_T *argsvars, typval_T *rettv);
+#ifdef WIN3264
+static void f_debugbreak(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_deepcopy(typval_T *argvars, typval_T *rettv);
+static void f_delete(typval_T *argvars, typval_T *rettv);
+static void f_deletebufline(typval_T *argvars, typval_T *rettv);
+static void f_did_filetype(typval_T *argvars, typval_T *rettv);
+static void f_diff_filler(typval_T *argvars, typval_T *rettv);
+static void f_diff_hlID(typval_T *argvars, typval_T *rettv);
+static void f_empty(typval_T *argvars, typval_T *rettv);
+static void f_escape(typval_T *argvars, typval_T *rettv);
+static void f_eval(typval_T *argvars, typval_T *rettv);
+static void f_eventhandler(typval_T *argvars, typval_T *rettv);
+static void f_executable(typval_T *argvars, typval_T *rettv);
+static void f_execute(typval_T *argvars, typval_T *rettv);
+static void f_exepath(typval_T *argvars, typval_T *rettv);
+static void f_exists(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_exp(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_expand(typval_T *argvars, typval_T *rettv);
+static void f_extend(typval_T *argvars, typval_T *rettv);
+static void f_feedkeys(typval_T *argvars, typval_T *rettv);
+static void f_filereadable(typval_T *argvars, typval_T *rettv);
+static void f_filewritable(typval_T *argvars, typval_T *rettv);
+static void f_filter(typval_T *argvars, typval_T *rettv);
+static void f_finddir(typval_T *argvars, typval_T *rettv);
+static void f_findfile(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_float2nr(typval_T *argvars, typval_T *rettv);
+static void f_floor(typval_T *argvars, typval_T *rettv);
+static void f_fmod(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_fnameescape(typval_T *argvars, typval_T *rettv);
+static void f_fnamemodify(typval_T *argvars, typval_T *rettv);
+static void f_foldclosed(typval_T *argvars, typval_T *rettv);
+static void f_foldclosedend(typval_T *argvars, typval_T *rettv);
+static void f_foldlevel(typval_T *argvars, typval_T *rettv);
+static void f_foldtext(typval_T *argvars, typval_T *rettv);
+static void f_foldtextresult(typval_T *argvars, typval_T *rettv);
+static void f_foreground(typval_T *argvars, typval_T *rettv);
+static void f_funcref(typval_T *argvars, typval_T *rettv);
+static void f_function(typval_T *argvars, typval_T *rettv);
+static void f_garbagecollect(typval_T *argvars, typval_T *rettv);
+static void f_get(typval_T *argvars, typval_T *rettv);
+static void f_getbufinfo(typval_T *argvars, typval_T *rettv);
+static void f_getbufline(typval_T *argvars, typval_T *rettv);
+static void f_getbufvar(typval_T *argvars, typval_T *rettv);
+static void f_getchangelist(typval_T *argvars, typval_T *rettv);
+static void f_getchar(typval_T *argvars, typval_T *rettv);
+static void f_getcharmod(typval_T *argvars, typval_T *rettv);
+static void f_getcharsearch(typval_T *argvars, typval_T *rettv);
+static void f_getcmdline(typval_T *argvars, typval_T *rettv);
+#if defined(FEAT_CMDL_COMPL)
+static void f_getcompletion(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_getcmdpos(typval_T *argvars, typval_T *rettv);
+static void f_getcmdtype(typval_T *argvars, typval_T *rettv);
+static void f_getcmdwintype(typval_T *argvars, typval_T *rettv);
+static void f_getcwd(typval_T *argvars, typval_T *rettv);
+static void f_getfontname(typval_T *argvars, typval_T *rettv);
+static void f_getfperm(typval_T *argvars, typval_T *rettv);
+static void f_getfsize(typval_T *argvars, typval_T *rettv);
+static void f_getftime(typval_T *argvars, typval_T *rettv);
+static void f_getftype(typval_T *argvars, typval_T *rettv);
+static void f_getjumplist(typval_T *argvars, typval_T *rettv);
+static void f_getline(typval_T *argvars, typval_T *rettv);
+static void f_getloclist(typval_T *argvars UNUSED, typval_T *rettv UNUSED);
+static void f_getmatches(typval_T *argvars, typval_T *rettv);
+static void f_getpid(typval_T *argvars, typval_T *rettv);
+static void f_getcurpos(typval_T *argvars, typval_T *rettv);
+static void f_getpos(typval_T *argvars, typval_T *rettv);
+static void f_getqflist(typval_T *argvars, typval_T *rettv);
+static void f_getreg(typval_T *argvars, typval_T *rettv);
+static void f_getregtype(typval_T *argvars, typval_T *rettv);
+static void f_gettabinfo(typval_T *argvars, typval_T *rettv);
+static void f_gettabvar(typval_T *argvars, typval_T *rettv);
+static void f_gettabwinvar(typval_T *argvars, typval_T *rettv);
+static void f_getwininfo(typval_T *argvars, typval_T *rettv);
+static void f_getwinpos(typval_T *argvars, typval_T *rettv);
+static void f_getwinposx(typval_T *argvars, typval_T *rettv);
+static void f_getwinposy(typval_T *argvars, typval_T *rettv);
+static void f_getwinvar(typval_T *argvars, typval_T *rettv);
+static void f_glob(typval_T *argvars, typval_T *rettv);
+static void f_globpath(typval_T *argvars, typval_T *rettv);
+static void f_glob2regpat(typval_T *argvars, typval_T *rettv);
+static void f_has(typval_T *argvars, typval_T *rettv);
+static void f_has_key(typval_T *argvars, typval_T *rettv);
+static void f_haslocaldir(typval_T *argvars, typval_T *rettv);
+static void f_hasmapto(typval_T *argvars, typval_T *rettv);
+static void f_histadd(typval_T *argvars, typval_T *rettv);
+static void f_histdel(typval_T *argvars, typval_T *rettv);
+static void f_histget(typval_T *argvars, typval_T *rettv);
+static void f_histnr(typval_T *argvars, typval_T *rettv);
+static void f_hlID(typval_T *argvars, typval_T *rettv);
+static void f_hlexists(typval_T *argvars, typval_T *rettv);
+static void f_hostname(typval_T *argvars, typval_T *rettv);
+static void f_iconv(typval_T *argvars, typval_T *rettv);
+static void f_indent(typval_T *argvars, typval_T *rettv);
+static void f_index(typval_T *argvars, typval_T *rettv);
+static void f_input(typval_T *argvars, typval_T *rettv);
+static void f_inputdialog(typval_T *argvars, typval_T *rettv);
+static void f_inputlist(typval_T *argvars, typval_T *rettv);
+static void f_inputrestore(typval_T *argvars, typval_T *rettv);
+static void f_inputsave(typval_T *argvars, typval_T *rettv);
+static void f_inputsecret(typval_T *argvars, typval_T *rettv);
+static void f_insert(typval_T *argvars, typval_T *rettv);
+static void f_invert(typval_T *argvars, typval_T *rettv);
+static void f_isdirectory(typval_T *argvars, typval_T *rettv);
+static void f_islocked(typval_T *argvars, typval_T *rettv);
+#if defined(FEAT_FLOAT) && defined(HAVE_MATH_H)
+static void f_isnan(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_items(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_JOB_CHANNEL
+static void f_job_getchannel(typval_T *argvars, typval_T *rettv);
+static void f_job_info(typval_T *argvars, typval_T *rettv);
+static void f_job_setoptions(typval_T *argvars, typval_T *rettv);
+static void f_job_start(typval_T *argvars, typval_T *rettv);
+static void f_job_stop(typval_T *argvars, typval_T *rettv);
+static void f_job_status(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_join(typval_T *argvars, typval_T *rettv);
+static void f_js_decode(typval_T *argvars, typval_T *rettv);
+static void f_js_encode(typval_T *argvars, typval_T *rettv);
+static void f_json_decode(typval_T *argvars, typval_T *rettv);
+static void f_json_encode(typval_T *argvars, typval_T *rettv);
+static void f_keys(typval_T *argvars, typval_T *rettv);
+static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv);
+static void f_len(typval_T *argvars, typval_T *rettv);
+static void f_libcall(typval_T *argvars, typval_T *rettv);
+static void f_libcallnr(typval_T *argvars, typval_T *rettv);
+static void f_line(typval_T *argvars, typval_T *rettv);
+static void f_line2byte(typval_T *argvars, typval_T *rettv);
+static void f_lispindent(typval_T *argvars, typval_T *rettv);
+static void f_localtime(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_log(typval_T *argvars, typval_T *rettv);
+static void f_log10(typval_T *argvars, typval_T *rettv);
+#endif
+#ifdef FEAT_LUA
+static void f_luaeval(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_map(typval_T *argvars, typval_T *rettv);
+static void f_maparg(typval_T *argvars, typval_T *rettv);
+static void f_mapcheck(typval_T *argvars, typval_T *rettv);
+static void f_match(typval_T *argvars, typval_T *rettv);
+static void f_matchadd(typval_T *argvars, typval_T *rettv);
+static void f_matchaddpos(typval_T *argvars, typval_T *rettv);
+static void f_matcharg(typval_T *argvars, typval_T *rettv);
+static void f_matchdelete(typval_T *argvars, typval_T *rettv);
+static void f_matchend(typval_T *argvars, typval_T *rettv);
+static void f_matchlist(typval_T *argvars, typval_T *rettv);
+static void f_matchstr(typval_T *argvars, typval_T *rettv);
+static void f_matchstrpos(typval_T *argvars, typval_T *rettv);
+static void f_max(typval_T *argvars, typval_T *rettv);
+static void f_min(typval_T *argvars, typval_T *rettv);
+#ifdef vim_mkdir
+static void f_mkdir(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_mode(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_MZSCHEME
+static void f_mzeval(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_nextnonblank(typval_T *argvars, typval_T *rettv);
+static void f_nr2char(typval_T *argvars, typval_T *rettv);
+static void f_or(typval_T *argvars, typval_T *rettv);
+static void f_pathshorten(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_PERL
+static void f_perleval(typval_T *argvars, typval_T *rettv);
+#endif
+#ifdef FEAT_FLOAT
+static void f_pow(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_prevnonblank(typval_T *argvars, typval_T *rettv);
+static void f_printf(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_JOB_CHANNEL
+static void f_prompt_setcallback(typval_T *argvars, typval_T *rettv);
+static void f_prompt_setinterrupt(typval_T *argvars, typval_T *rettv);
+static void f_prompt_setprompt(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_pumvisible(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_PYTHON3
+static void f_py3eval(typval_T *argvars, typval_T *rettv);
+#endif
+#ifdef FEAT_PYTHON
+static void f_pyeval(typval_T *argvars, typval_T *rettv);
+#endif
+#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+static void f_pyxeval(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_range(typval_T *argvars, typval_T *rettv);
+static void f_readfile(typval_T *argvars, typval_T *rettv);
+static void f_reg_executing(typval_T *argvars, typval_T *rettv);
+static void f_reg_recording(typval_T *argvars, typval_T *rettv);
+static void f_reltime(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_reltimefloat(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_reltimestr(typval_T *argvars, typval_T *rettv);
+static void f_remote_expr(typval_T *argvars, typval_T *rettv);
+static void f_remote_foreground(typval_T *argvars, typval_T *rettv);
+static void f_remote_peek(typval_T *argvars, typval_T *rettv);
+static void f_remote_read(typval_T *argvars, typval_T *rettv);
+static void f_remote_send(typval_T *argvars, typval_T *rettv);
+static void f_remote_startserver(typval_T *argvars, typval_T *rettv);
+static void f_remove(typval_T *argvars, typval_T *rettv);
+static void f_rename(typval_T *argvars, typval_T *rettv);
+static void f_repeat(typval_T *argvars, typval_T *rettv);
+static void f_resolve(typval_T *argvars, typval_T *rettv);
+static void f_reverse(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_round(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_screenattr(typval_T *argvars, typval_T *rettv);
+static void f_screenchar(typval_T *argvars, typval_T *rettv);
+static void f_screencol(typval_T *argvars, typval_T *rettv);
+static void f_screenrow(typval_T *argvars, typval_T *rettv);
+static void f_search(typval_T *argvars, typval_T *rettv);
+static void f_searchdecl(typval_T *argvars, typval_T *rettv);
+static void f_searchpair(typval_T *argvars, typval_T *rettv);
+static void f_searchpairpos(typval_T *argvars, typval_T *rettv);
+static void f_searchpos(typval_T *argvars, typval_T *rettv);
+static void f_server2client(typval_T *argvars, typval_T *rettv);
+static void f_serverlist(typval_T *argvars, typval_T *rettv);
+static void f_setbufline(typval_T *argvars, typval_T *rettv);
+static void f_setbufvar(typval_T *argvars, typval_T *rettv);
+static void f_setcharsearch(typval_T *argvars, typval_T *rettv);
+static void f_setcmdpos(typval_T *argvars, typval_T *rettv);
+static void f_setfperm(typval_T *argvars, typval_T *rettv);
+static void f_setline(typval_T *argvars, typval_T *rettv);
+static void f_setloclist(typval_T *argvars, typval_T *rettv);
+static void f_setmatches(typval_T *argvars, typval_T *rettv);
+static void f_setpos(typval_T *argvars, typval_T *rettv);
+static void f_setqflist(typval_T *argvars, typval_T *rettv);
+static void f_setreg(typval_T *argvars, typval_T *rettv);
+static void f_settabvar(typval_T *argvars, typval_T *rettv);
+static void f_settabwinvar(typval_T *argvars, typval_T *rettv);
+static void f_setwinvar(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_CRYPT
+static void f_sha256(typval_T *argvars, typval_T *rettv);
+#endif /* FEAT_CRYPT */
+static void f_shellescape(typval_T *argvars, typval_T *rettv);
+static void f_shiftwidth(typval_T *argvars, typval_T *rettv);
+static void f_simplify(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_sin(typval_T *argvars, typval_T *rettv);
+static void f_sinh(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_sort(typval_T *argvars, typval_T *rettv);
+static void f_soundfold(typval_T *argvars, typval_T *rettv);
+static void f_spellbadword(typval_T *argvars, typval_T *rettv);
+static void f_spellsuggest(typval_T *argvars, typval_T *rettv);
+static void f_split(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_sqrt(typval_T *argvars, typval_T *rettv);
+static void f_str2float(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_str2nr(typval_T *argvars, typval_T *rettv);
+static void f_strchars(typval_T *argvars, typval_T *rettv);
+#ifdef HAVE_STRFTIME
+static void f_strftime(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_strgetchar(typval_T *argvars, typval_T *rettv);
+static void f_stridx(typval_T *argvars, typval_T *rettv);
+static void f_string(typval_T *argvars, typval_T *rettv);
+static void f_strlen(typval_T *argvars, typval_T *rettv);
+static void f_strcharpart(typval_T *argvars, typval_T *rettv);
+static void f_strpart(typval_T *argvars, typval_T *rettv);
+static void f_strridx(typval_T *argvars, typval_T *rettv);
+static void f_strtrans(typval_T *argvars, typval_T *rettv);
+static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv);
+static void f_strwidth(typval_T *argvars, typval_T *rettv);
+static void f_submatch(typval_T *argvars, typval_T *rettv);
+static void f_substitute(typval_T *argvars, typval_T *rettv);
+static void f_swapinfo(typval_T *argvars, typval_T *rettv);
+static void f_synID(typval_T *argvars, typval_T *rettv);
+static void f_synIDattr(typval_T *argvars, typval_T *rettv);
+static void f_synIDtrans(typval_T *argvars, typval_T *rettv);
+static void f_synstack(typval_T *argvars, typval_T *rettv);
+static void f_synconcealed(typval_T *argvars, typval_T *rettv);
+static void f_system(typval_T *argvars, typval_T *rettv);
+static void f_systemlist(typval_T *argvars, typval_T *rettv);
+static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv);
+static void f_tabpagenr(typval_T *argvars, typval_T *rettv);
+static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv);
+static void f_taglist(typval_T *argvars, typval_T *rettv);
+static void f_tagfiles(typval_T *argvars, typval_T *rettv);
+static void f_tempname(typval_T *argvars, typval_T *rettv);
+static void f_test_alloc_fail(typval_T *argvars, typval_T *rettv);
+static void f_test_autochdir(typval_T *argvars, typval_T *rettv);
+static void f_test_feedinput(typval_T *argvars, typval_T *rettv);
+static void f_test_override(typval_T *argvars, typval_T *rettv);
+static void f_test_garbagecollect_now(typval_T *argvars, typval_T *rettv);
+static void f_test_ignore_error(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_JOB_CHANNEL
+static void f_test_null_channel(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_test_null_dict(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_JOB_CHANNEL
+static void f_test_null_job(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_test_null_list(typval_T *argvars, typval_T *rettv);
+static void f_test_null_partial(typval_T *argvars, typval_T *rettv);
+static void f_test_null_string(typval_T *argvars, typval_T *rettv);
+static void f_test_settime(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_tan(typval_T *argvars, typval_T *rettv);
+static void f_tanh(typval_T *argvars, typval_T *rettv);
+#endif
+#ifdef FEAT_TIMERS
+static void f_timer_info(typval_T *argvars, typval_T *rettv);
+static void f_timer_pause(typval_T *argvars, typval_T *rettv);
+static void f_timer_start(typval_T *argvars, typval_T *rettv);
+static void f_timer_stop(typval_T *argvars, typval_T *rettv);
+static void f_timer_stopall(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_tolower(typval_T *argvars, typval_T *rettv);
+static void f_toupper(typval_T *argvars, typval_T *rettv);
+static void f_tr(typval_T *argvars, typval_T *rettv);
+static void f_trim(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_FLOAT
+static void f_trunc(typval_T *argvars, typval_T *rettv);
+#endif
+static void f_type(typval_T *argvars, typval_T *rettv);
+static void f_undofile(typval_T *argvars, typval_T *rettv);
+static void f_undotree(typval_T *argvars, typval_T *rettv);
+static void f_uniq(typval_T *argvars, typval_T *rettv);
+static void f_values(typval_T *argvars, typval_T *rettv);
+static void f_virtcol(typval_T *argvars, typval_T *rettv);
+static void f_visualmode(typval_T *argvars, typval_T *rettv);
+static void f_wildmenumode(typval_T *argvars, typval_T *rettv);
+static void f_win_findbuf(typval_T *argvars, typval_T *rettv);
+static void f_win_getid(typval_T *argvars, typval_T *rettv);
+static void f_win_gotoid(typval_T *argvars, typval_T *rettv);
+static void f_win_id2tabwin(typval_T *argvars, typval_T *rettv);
+static void f_win_id2win(typval_T *argvars, typval_T *rettv);
+static void f_win_screenpos(typval_T *argvars, typval_T *rettv);
+static void f_winbufnr(typval_T *argvars, typval_T *rettv);
+static void f_wincol(typval_T *argvars, typval_T *rettv);
+static void f_winheight(typval_T *argvars, typval_T *rettv);
+static void f_winlayout(typval_T *argvars, typval_T *rettv);
+static void f_winline(typval_T *argvars, typval_T *rettv);
+static void f_winnr(typval_T *argvars, typval_T *rettv);
+static void f_winrestcmd(typval_T *argvars, typval_T *rettv);
+static void f_winrestview(typval_T *argvars, typval_T *rettv);
+static void f_winsaveview(typval_T *argvars, typval_T *rettv);
+static void f_winwidth(typval_T *argvars, typval_T *rettv);
+static void f_writefile(typval_T *argvars, typval_T *rettv);
+static void f_wordcount(typval_T *argvars, typval_T *rettv);
+static void f_xor(typval_T *argvars, typval_T *rettv);
+
+/*
+ * Array with names and number of arguments of all internal functions
+ * MUST BE KEPT SORTED IN strcmp() ORDER FOR BINARY SEARCH!
+ */
+static struct fst
+{
+    char	*f_name;	/* function name */
+    char	f_min_argc;	/* minimal number of arguments */
+    char	f_max_argc;	/* maximal number of arguments */
+    void	(*f_func)(typval_T *args, typval_T *rvar);
+				/* implementation of function */
+} functions[] =
+{
+#ifdef FEAT_FLOAT
+    {"abs",		1, 1, f_abs},
+    {"acos",		1, 1, f_acos},	/* WJMc */
+#endif
+    {"add",		2, 2, f_add},
+    {"and",		2, 2, f_and},
+    {"append",		2, 2, f_append},
+    {"appendbufline",	3, 3, f_appendbufline},
+    {"argc",		0, 0, f_argc},
+    {"argidx",		0, 0, f_argidx},
+    {"arglistid",	0, 2, f_arglistid},
+    {"argv",		0, 1, f_argv},
+#ifdef FEAT_FLOAT
+    {"asin",		1, 1, f_asin},	/* WJMc */
+#endif
+    {"assert_beeps",	1, 2, f_assert_beeps},
+    {"assert_equal",	2, 3, f_assert_equal},
+    {"assert_equalfile", 2, 2, f_assert_equalfile},
+    {"assert_exception", 1, 2, f_assert_exception},
+    {"assert_fails",	1, 2, f_assert_fails},
+    {"assert_false",	1, 2, f_assert_false},
+    {"assert_inrange",	3, 4, f_assert_inrange},
+    {"assert_match",	2, 3, f_assert_match},
+    {"assert_notequal",	2, 3, f_assert_notequal},
+    {"assert_notmatch",	2, 3, f_assert_notmatch},
+    {"assert_report",	1, 1, f_assert_report},
+    {"assert_true",	1, 2, f_assert_true},
+#ifdef FEAT_FLOAT
+    {"atan",		1, 1, f_atan},
+    {"atan2",		2, 2, f_atan2},
+#endif
+#ifdef FEAT_BEVAL
+    {"balloon_show",	1, 1, f_balloon_show},
+# if defined(FEAT_BEVAL_TERM)
+    {"balloon_split",	1, 1, f_balloon_split},
+# endif
+#endif
+    {"browse",		4, 4, f_browse},
+    {"browsedir",	2, 2, f_browsedir},
+    {"bufexists",	1, 1, f_bufexists},
+    {"buffer_exists",	1, 1, f_bufexists},	/* obsolete */
+    {"buffer_name",	1, 1, f_bufname},	/* obsolete */
+    {"buffer_number",	1, 1, f_bufnr},		/* obsolete */
+    {"buflisted",	1, 1, f_buflisted},
+    {"bufloaded",	1, 1, f_bufloaded},
+    {"bufname",		1, 1, f_bufname},
+    {"bufnr",		1, 2, f_bufnr},
+    {"bufwinid",	1, 1, f_bufwinid},
+    {"bufwinnr",	1, 1, f_bufwinnr},
+    {"byte2line",	1, 1, f_byte2line},
+    {"byteidx",		2, 2, f_byteidx},
+    {"byteidxcomp",	2, 2, f_byteidxcomp},
+    {"call",		2, 3, f_call},
+#ifdef FEAT_FLOAT
+    {"ceil",		1, 1, f_ceil},
+#endif
+#ifdef FEAT_JOB_CHANNEL
+    {"ch_canread",	1, 1, f_ch_canread},
+    {"ch_close",	1, 1, f_ch_close},
+    {"ch_close_in",	1, 1, f_ch_close_in},
+    {"ch_evalexpr",	2, 3, f_ch_evalexpr},
+    {"ch_evalraw",	2, 3, f_ch_evalraw},
+    {"ch_getbufnr",	2, 2, f_ch_getbufnr},
+    {"ch_getjob",	1, 1, f_ch_getjob},
+    {"ch_info",		1, 1, f_ch_info},
+    {"ch_log",		1, 2, f_ch_log},
+    {"ch_logfile",	1, 2, f_ch_logfile},
+    {"ch_open",		1, 2, f_ch_open},
+    {"ch_read",		1, 2, f_ch_read},
+    {"ch_readraw",	1, 2, f_ch_readraw},
+    {"ch_sendexpr",	2, 3, f_ch_sendexpr},
+    {"ch_sendraw",	2, 3, f_ch_sendraw},
+    {"ch_setoptions",	2, 2, f_ch_setoptions},
+    {"ch_status",	1, 2, f_ch_status},
+#endif
+    {"changenr",	0, 0, f_changenr},
+    {"char2nr",		1, 2, f_char2nr},
+    {"cindent",		1, 1, f_cindent},
+    {"clearmatches",	0, 0, f_clearmatches},
+    {"col",		1, 1, f_col},
+#if defined(FEAT_INS_EXPAND)
+    {"complete",	2, 2, f_complete},
+    {"complete_add",	1, 1, f_complete_add},
+    {"complete_check",	0, 0, f_complete_check},
+#endif
+    {"confirm",		1, 4, f_confirm},
+    {"copy",		1, 1, f_copy},
+#ifdef FEAT_FLOAT
+    {"cos",		1, 1, f_cos},
+    {"cosh",		1, 1, f_cosh},
+#endif
+    {"count",		2, 4, f_count},
+    {"cscope_connection",0,3, f_cscope_connection},
+    {"cursor",		1, 3, f_cursor},
+#ifdef WIN3264
+    {"debugbreak",	1, 1, f_debugbreak},
+#endif
+    {"deepcopy",	1, 2, f_deepcopy},
+    {"delete",		1, 2, f_delete},
+    {"deletebufline",	2, 3, f_deletebufline},
+    {"did_filetype",	0, 0, f_did_filetype},
+    {"diff_filler",	1, 1, f_diff_filler},
+    {"diff_hlID",	2, 2, f_diff_hlID},
+    {"empty",		1, 1, f_empty},
+    {"escape",		2, 2, f_escape},
+    {"eval",		1, 1, f_eval},
+    {"eventhandler",	0, 0, f_eventhandler},
+    {"executable",	1, 1, f_executable},
+    {"execute",		1, 2, f_execute},
+    {"exepath",		1, 1, f_exepath},
+    {"exists",		1, 1, f_exists},
+#ifdef FEAT_FLOAT
+    {"exp",		1, 1, f_exp},
+#endif
+    {"expand",		1, 3, f_expand},
+    {"extend",		2, 3, f_extend},
+    {"feedkeys",	1, 2, f_feedkeys},
+    {"file_readable",	1, 1, f_filereadable},	/* obsolete */
+    {"filereadable",	1, 1, f_filereadable},
+    {"filewritable",	1, 1, f_filewritable},
+    {"filter",		2, 2, f_filter},
+    {"finddir",		1, 3, f_finddir},
+    {"findfile",	1, 3, f_findfile},
+#ifdef FEAT_FLOAT
+    {"float2nr",	1, 1, f_float2nr},
+    {"floor",		1, 1, f_floor},
+    {"fmod",		2, 2, f_fmod},
+#endif
+    {"fnameescape",	1, 1, f_fnameescape},
+    {"fnamemodify",	2, 2, f_fnamemodify},
+    {"foldclosed",	1, 1, f_foldclosed},
+    {"foldclosedend",	1, 1, f_foldclosedend},
+    {"foldlevel",	1, 1, f_foldlevel},
+    {"foldtext",	0, 0, f_foldtext},
+    {"foldtextresult",	1, 1, f_foldtextresult},
+    {"foreground",	0, 0, f_foreground},
+    {"funcref",		1, 3, f_funcref},
+    {"function",	1, 3, f_function},
+    {"garbagecollect",	0, 1, f_garbagecollect},
+    {"get",		2, 3, f_get},
+    {"getbufinfo",	0, 1, f_getbufinfo},
+    {"getbufline",	2, 3, f_getbufline},
+    {"getbufvar",	2, 3, f_getbufvar},
+    {"getchangelist",	1, 1, f_getchangelist},
+    {"getchar",		0, 1, f_getchar},
+    {"getcharmod",	0, 0, f_getcharmod},
+    {"getcharsearch",	0, 0, f_getcharsearch},
+    {"getcmdline",	0, 0, f_getcmdline},
+    {"getcmdpos",	0, 0, f_getcmdpos},
+    {"getcmdtype",	0, 0, f_getcmdtype},
+    {"getcmdwintype",	0, 0, f_getcmdwintype},
+#if defined(FEAT_CMDL_COMPL)
+    {"getcompletion",	2, 3, f_getcompletion},
+#endif
+    {"getcurpos",	0, 0, f_getcurpos},
+    {"getcwd",		0, 2, f_getcwd},
+    {"getfontname",	0, 1, f_getfontname},
+    {"getfperm",	1, 1, f_getfperm},
+    {"getfsize",	1, 1, f_getfsize},
+    {"getftime",	1, 1, f_getftime},
+    {"getftype",	1, 1, f_getftype},
+    {"getjumplist",	0, 2, f_getjumplist},
+    {"getline",		1, 2, f_getline},
+    {"getloclist",	1, 2, f_getloclist},
+    {"getmatches",	0, 0, f_getmatches},
+    {"getpid",		0, 0, f_getpid},
+    {"getpos",		1, 1, f_getpos},
+    {"getqflist",	0, 1, f_getqflist},
+    {"getreg",		0, 3, f_getreg},
+    {"getregtype",	0, 1, f_getregtype},
+    {"gettabinfo",	0, 1, f_gettabinfo},
+    {"gettabvar",	2, 3, f_gettabvar},
+    {"gettabwinvar",	3, 4, f_gettabwinvar},
+    {"getwininfo",	0, 1, f_getwininfo},
+    {"getwinpos",	0, 1, f_getwinpos},
+    {"getwinposx",	0, 0, f_getwinposx},
+    {"getwinposy",	0, 0, f_getwinposy},
+    {"getwinvar",	2, 3, f_getwinvar},
+    {"glob",		1, 4, f_glob},
+    {"glob2regpat",	1, 1, f_glob2regpat},
+    {"globpath",	2, 5, f_globpath},
+    {"has",		1, 1, f_has},
+    {"has_key",		2, 2, f_has_key},
+    {"haslocaldir",	0, 2, f_haslocaldir},
+    {"hasmapto",	1, 3, f_hasmapto},
+    {"highlightID",	1, 1, f_hlID},		/* obsolete */
+    {"highlight_exists",1, 1, f_hlexists},	/* obsolete */
+    {"histadd",		2, 2, f_histadd},
+    {"histdel",		1, 2, f_histdel},
+    {"histget",		1, 2, f_histget},
+    {"histnr",		1, 1, f_histnr},
+    {"hlID",		1, 1, f_hlID},
+    {"hlexists",	1, 1, f_hlexists},
+    {"hostname",	0, 0, f_hostname},
+    {"iconv",		3, 3, f_iconv},
+    {"indent",		1, 1, f_indent},
+    {"index",		2, 4, f_index},
+    {"input",		1, 3, f_input},
+    {"inputdialog",	1, 3, f_inputdialog},
+    {"inputlist",	1, 1, f_inputlist},
+    {"inputrestore",	0, 0, f_inputrestore},
+    {"inputsave",	0, 0, f_inputsave},
+    {"inputsecret",	1, 2, f_inputsecret},
+    {"insert",		2, 3, f_insert},
+    {"invert",		1, 1, f_invert},
+    {"isdirectory",	1, 1, f_isdirectory},
+    {"islocked",	1, 1, f_islocked},
+#if defined(FEAT_FLOAT) && defined(HAVE_MATH_H)
+    {"isnan",		1, 1, f_isnan},
+#endif
+    {"items",		1, 1, f_items},
+#ifdef FEAT_JOB_CHANNEL
+    {"job_getchannel",	1, 1, f_job_getchannel},
+    {"job_info",	0, 1, f_job_info},
+    {"job_setoptions",	2, 2, f_job_setoptions},
+    {"job_start",	1, 2, f_job_start},
+    {"job_status",	1, 1, f_job_status},
+    {"job_stop",	1, 2, f_job_stop},
+#endif
+    {"join",		1, 2, f_join},
+    {"js_decode",	1, 1, f_js_decode},
+    {"js_encode",	1, 1, f_js_encode},
+    {"json_decode",	1, 1, f_json_decode},
+    {"json_encode",	1, 1, f_json_encode},
+    {"keys",		1, 1, f_keys},
+    {"last_buffer_nr",	0, 0, f_last_buffer_nr},/* obsolete */
+    {"len",		1, 1, f_len},
+    {"libcall",		3, 3, f_libcall},
+    {"libcallnr",	3, 3, f_libcallnr},
+    {"line",		1, 1, f_line},
+    {"line2byte",	1, 1, f_line2byte},
+    {"lispindent",	1, 1, f_lispindent},
+    {"localtime",	0, 0, f_localtime},
+#ifdef FEAT_FLOAT
+    {"log",		1, 1, f_log},
+    {"log10",		1, 1, f_log10},
+#endif
+#ifdef FEAT_LUA
+    {"luaeval",		1, 2, f_luaeval},
+#endif
+    {"map",		2, 2, f_map},
+    {"maparg",		1, 4, f_maparg},
+    {"mapcheck",	1, 3, f_mapcheck},
+    {"match",		2, 4, f_match},
+    {"matchadd",	2, 5, f_matchadd},
+    {"matchaddpos",	2, 5, f_matchaddpos},
+    {"matcharg",	1, 1, f_matcharg},
+    {"matchdelete",	1, 1, f_matchdelete},
+    {"matchend",	2, 4, f_matchend},
+    {"matchlist",	2, 4, f_matchlist},
+    {"matchstr",	2, 4, f_matchstr},
+    {"matchstrpos",	2, 4, f_matchstrpos},
+    {"max",		1, 1, f_max},
+    {"min",		1, 1, f_min},
+#ifdef vim_mkdir
+    {"mkdir",		1, 3, f_mkdir},
+#endif
+    {"mode",		0, 1, f_mode},
+#ifdef FEAT_MZSCHEME
+    {"mzeval",		1, 1, f_mzeval},
+#endif
+    {"nextnonblank",	1, 1, f_nextnonblank},
+    {"nr2char",		1, 2, f_nr2char},
+    {"or",		2, 2, f_or},
+    {"pathshorten",	1, 1, f_pathshorten},
+#ifdef FEAT_PERL
+    {"perleval",	1, 1, f_perleval},
+#endif
+#ifdef FEAT_FLOAT
+    {"pow",		2, 2, f_pow},
+#endif
+    {"prevnonblank",	1, 1, f_prevnonblank},
+    {"printf",		1, 19, f_printf},
+#ifdef FEAT_JOB_CHANNEL
+    {"prompt_setcallback", 2, 2, f_prompt_setcallback},
+    {"prompt_setinterrupt", 2, 2, f_prompt_setinterrupt},
+    {"prompt_setprompt", 2, 2, f_prompt_setprompt},
+#endif
+    {"pumvisible",	0, 0, f_pumvisible},
+#ifdef FEAT_PYTHON3
+    {"py3eval",		1, 1, f_py3eval},
+#endif
+#ifdef FEAT_PYTHON
+    {"pyeval",		1, 1, f_pyeval},
+#endif
+#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+    {"pyxeval",		1, 1, f_pyxeval},
+#endif
+    {"range",		1, 3, f_range},
+    {"readfile",	1, 3, f_readfile},
+    {"reg_executing",	0, 0, f_reg_executing},
+    {"reg_recording",	0, 0, f_reg_recording},
+    {"reltime",		0, 2, f_reltime},
+#ifdef FEAT_FLOAT
+    {"reltimefloat",	1, 1, f_reltimefloat},
+#endif
+    {"reltimestr",	1, 1, f_reltimestr},
+    {"remote_expr",	2, 4, f_remote_expr},
+    {"remote_foreground", 1, 1, f_remote_foreground},
+    {"remote_peek",	1, 2, f_remote_peek},
+    {"remote_read",	1, 2, f_remote_read},
+    {"remote_send",	2, 3, f_remote_send},
+    {"remote_startserver", 1, 1, f_remote_startserver},
+    {"remove",		2, 3, f_remove},
+    {"rename",		2, 2, f_rename},
+    {"repeat",		2, 2, f_repeat},
+    {"resolve",		1, 1, f_resolve},
+    {"reverse",		1, 1, f_reverse},
+#ifdef FEAT_FLOAT
+    {"round",		1, 1, f_round},
+#endif
+    {"screenattr",	2, 2, f_screenattr},
+    {"screenchar",	2, 2, f_screenchar},
+    {"screencol",	0, 0, f_screencol},
+    {"screenrow",	0, 0, f_screenrow},
+    {"search",		1, 4, f_search},
+    {"searchdecl",	1, 3, f_searchdecl},
+    {"searchpair",	3, 7, f_searchpair},
+    {"searchpairpos",	3, 7, f_searchpairpos},
+    {"searchpos",	1, 4, f_searchpos},
+    {"server2client",	2, 2, f_server2client},
+    {"serverlist",	0, 0, f_serverlist},
+    {"setbufline",	3, 3, f_setbufline},
+    {"setbufvar",	3, 3, f_setbufvar},
+    {"setcharsearch",	1, 1, f_setcharsearch},
+    {"setcmdpos",	1, 1, f_setcmdpos},
+    {"setfperm",	2, 2, f_setfperm},
+    {"setline",		2, 2, f_setline},
+    {"setloclist",	2, 4, f_setloclist},
+    {"setmatches",	1, 1, f_setmatches},
+    {"setpos",		2, 2, f_setpos},
+    {"setqflist",	1, 3, f_setqflist},
+    {"setreg",		2, 3, f_setreg},
+    {"settabvar",	3, 3, f_settabvar},
+    {"settabwinvar",	4, 4, f_settabwinvar},
+    {"setwinvar",	3, 3, f_setwinvar},
+#ifdef FEAT_CRYPT
+    {"sha256",		1, 1, f_sha256},
+#endif
+    {"shellescape",	1, 2, f_shellescape},
+    {"shiftwidth",	0, 0, f_shiftwidth},
+    {"simplify",	1, 1, f_simplify},
+#ifdef FEAT_FLOAT
+    {"sin",		1, 1, f_sin},
+    {"sinh",		1, 1, f_sinh},
+#endif
+    {"sort",		1, 3, f_sort},
+    {"soundfold",	1, 1, f_soundfold},
+    {"spellbadword",	0, 1, f_spellbadword},
+    {"spellsuggest",	1, 3, f_spellsuggest},
+    {"split",		1, 3, f_split},
+#ifdef FEAT_FLOAT
+    {"sqrt",		1, 1, f_sqrt},
+    {"str2float",	1, 1, f_str2float},
+#endif
+    {"str2nr",		1, 2, f_str2nr},
+    {"strcharpart",	2, 3, f_strcharpart},
+    {"strchars",	1, 2, f_strchars},
+    {"strdisplaywidth",	1, 2, f_strdisplaywidth},
+#ifdef HAVE_STRFTIME
+    {"strftime",	1, 2, f_strftime},
+#endif
+    {"strgetchar",	2, 2, f_strgetchar},
+    {"stridx",		2, 3, f_stridx},
+    {"string",		1, 1, f_string},
+    {"strlen",		1, 1, f_strlen},
+    {"strpart",		2, 3, f_strpart},
+    {"strridx",		2, 3, f_strridx},
+    {"strtrans",	1, 1, f_strtrans},
+    {"strwidth",	1, 1, f_strwidth},
+    {"submatch",	1, 2, f_submatch},
+    {"substitute",	4, 4, f_substitute},
+    {"swapinfo",	1, 1, f_swapinfo},
+    {"synID",		3, 3, f_synID},
+    {"synIDattr",	2, 3, f_synIDattr},
+    {"synIDtrans",	1, 1, f_synIDtrans},
+    {"synconcealed",	2, 2, f_synconcealed},
+    {"synstack",	2, 2, f_synstack},
+    {"system",		1, 2, f_system},
+    {"systemlist",	1, 2, f_systemlist},
+    {"tabpagebuflist",	0, 1, f_tabpagebuflist},
+    {"tabpagenr",	0, 1, f_tabpagenr},
+    {"tabpagewinnr",	1, 2, f_tabpagewinnr},
+    {"tagfiles",	0, 0, f_tagfiles},
+    {"taglist",		1, 2, f_taglist},
+#ifdef FEAT_FLOAT
+    {"tan",		1, 1, f_tan},
+    {"tanh",		1, 1, f_tanh},
+#endif
+    {"tempname",	0, 0, f_tempname},
+#ifdef FEAT_TERMINAL
+    {"term_dumpdiff",	2, 3, f_term_dumpdiff},
+    {"term_dumpload",	1, 2, f_term_dumpload},
+    {"term_dumpwrite",	2, 3, f_term_dumpwrite},
+    {"term_getaltscreen", 1, 1, f_term_getaltscreen},
+# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)
+    {"term_getansicolors", 1, 1, f_term_getansicolors},
+# endif
+    {"term_getattr",	2, 2, f_term_getattr},
+    {"term_getcursor",	1, 1, f_term_getcursor},
+    {"term_getjob",	1, 1, f_term_getjob},
+    {"term_getline",	2, 2, f_term_getline},
+    {"term_getscrolled", 1, 1, f_term_getscrolled},
+    {"term_getsize",	1, 1, f_term_getsize},
+    {"term_getstatus",	1, 1, f_term_getstatus},
+    {"term_gettitle",	1, 1, f_term_gettitle},
+    {"term_gettty",	1, 2, f_term_gettty},
+    {"term_list",	0, 0, f_term_list},
+    {"term_scrape",	2, 2, f_term_scrape},
+    {"term_sendkeys",	2, 2, f_term_sendkeys},
+# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)
+    {"term_setansicolors", 2, 2, f_term_setansicolors},
+# endif
+    {"term_setkill",	2, 2, f_term_setkill},
+    {"term_setrestore",	2, 2, f_term_setrestore},
+    {"term_setsize",	3, 3, f_term_setsize},
+    {"term_start",	1, 2, f_term_start},
+    {"term_wait",	1, 2, f_term_wait},
+#endif
+    {"test_alloc_fail",	3, 3, f_test_alloc_fail},
+    {"test_autochdir",	0, 0, f_test_autochdir},
+    {"test_feedinput",	1, 1, f_test_feedinput},
+    {"test_garbagecollect_now",	0, 0, f_test_garbagecollect_now},
+    {"test_ignore_error",	1, 1, f_test_ignore_error},
+#ifdef FEAT_JOB_CHANNEL
+    {"test_null_channel", 0, 0, f_test_null_channel},
+#endif
+    {"test_null_dict",	0, 0, f_test_null_dict},
+#ifdef FEAT_JOB_CHANNEL
+    {"test_null_job",	0, 0, f_test_null_job},
+#endif
+    {"test_null_list",	0, 0, f_test_null_list},
+    {"test_null_partial", 0, 0, f_test_null_partial},
+    {"test_null_string", 0, 0, f_test_null_string},
+    {"test_override",    2, 2, f_test_override},
+    {"test_settime",	1, 1, f_test_settime},
+#ifdef FEAT_TIMERS
+    {"timer_info",	0, 1, f_timer_info},
+    {"timer_pause",	2, 2, f_timer_pause},
+    {"timer_start",	2, 3, f_timer_start},
+    {"timer_stop",	1, 1, f_timer_stop},
+    {"timer_stopall",	0, 0, f_timer_stopall},
+#endif
+    {"tolower",		1, 1, f_tolower},
+    {"toupper",		1, 1, f_toupper},
+    {"tr",		3, 3, f_tr},
+    {"trim",		1, 2, f_trim},
+#ifdef FEAT_FLOAT
+    {"trunc",		1, 1, f_trunc},
+#endif
+    {"type",		1, 1, f_type},
+    {"undofile",	1, 1, f_undofile},
+    {"undotree",	0, 0, f_undotree},
+    {"uniq",		1, 3, f_uniq},
+    {"values",		1, 1, f_values},
+    {"virtcol",		1, 1, f_virtcol},
+    {"visualmode",	0, 1, f_visualmode},
+    {"wildmenumode",	0, 0, f_wildmenumode},
+    {"win_findbuf",	1, 1, f_win_findbuf},
+    {"win_getid",	0, 2, f_win_getid},
+    {"win_gotoid",	1, 1, f_win_gotoid},
+    {"win_id2tabwin",	1, 1, f_win_id2tabwin},
+    {"win_id2win",	1, 1, f_win_id2win},
+    {"win_screenpos",	1, 1, f_win_screenpos},
+    {"winbufnr",	1, 1, f_winbufnr},
+    {"wincol",		0, 0, f_wincol},
+    {"winheight",	1, 1, f_winheight},
+    {"winlayout",	0, 1, f_winlayout},
+    {"winline",		0, 0, f_winline},
+    {"winnr",		0, 1, f_winnr},
+    {"winrestcmd",	0, 0, f_winrestcmd},
+    {"winrestview",	1, 1, f_winrestview},
+    {"winsaveview",	0, 0, f_winsaveview},
+    {"winwidth",	1, 1, f_winwidth},
+    {"wordcount",	0, 0, f_wordcount},
+    {"writefile",	2, 3, f_writefile},
+    {"xor",		2, 2, f_xor},
+};
+
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+
+/*
+ * Function given to ExpandGeneric() to obtain the list of internal
+ * or user defined function names.
+ */
+    char_u *
+get_function_name(expand_T *xp, int idx)
+{
+    static int	intidx = -1;
+    char_u	*name;
+
+    if (idx == 0)
+	intidx = -1;
+    if (intidx < 0)
+    {
+	name = get_user_func_name(xp, idx);
+	if (name != NULL)
+	    return name;
+    }
+    if (++intidx < (int)(sizeof(functions) / sizeof(struct fst)))
+    {
+	STRCPY(IObuff, functions[intidx].f_name);
+	STRCAT(IObuff, "(");
+	if (functions[intidx].f_max_argc == 0)
+	    STRCAT(IObuff, ")");
+	return IObuff;
+    }
+
+    return NULL;
+}
+
+/*
+ * Function given to ExpandGeneric() to obtain the list of internal or
+ * user defined variable or function names.
+ */
+    char_u *
+get_expr_name(expand_T *xp, int idx)
+{
+    static int	intidx = -1;
+    char_u	*name;
+
+    if (idx == 0)
+	intidx = -1;
+    if (intidx < 0)
+    {
+	name = get_function_name(xp, idx);
+	if (name != NULL)
+	    return name;
+    }
+    return get_user_var_name(xp, ++intidx);
+}
+
+#endif /* FEAT_CMDL_COMPL */
+
+/*
+ * Find internal function in table above.
+ * Return index, or -1 if not found
+ */
+    int
+find_internal_func(
+    char_u	*name)		/* name of the function */
+{
+    int		first = 0;
+    int		last = (int)(sizeof(functions) / sizeof(struct fst)) - 1;
+    int		cmp;
+    int		x;
+
+    /*
+     * Find the function name in the table. Binary search.
+     */
+    while (first <= last)
+    {
+	x = first + ((unsigned)(last - first) >> 1);
+	cmp = STRCMP(name, functions[x].f_name);
+	if (cmp < 0)
+	    last = x - 1;
+	else if (cmp > 0)
+	    first = x + 1;
+	else
+	    return x;
+    }
+    return -1;
+}
+
+    int
+call_internal_func(
+	char_u	    *name,
+	int	    argcount,
+	typval_T    *argvars,
+	typval_T    *rettv)
+{
+    int i;
+
+    i = find_internal_func(name);
+    if (i < 0)
+	return ERROR_UNKNOWN;
+    if (argcount < functions[i].f_min_argc)
+	return ERROR_TOOFEW;
+    if (argcount > functions[i].f_max_argc)
+	return ERROR_TOOMANY;
+    argvars[argcount].v_type = VAR_UNKNOWN;
+    functions[i].f_func(argvars, rettv);
+    return ERROR_NONE;
+}
+
+/*
+ * Return TRUE for a non-zero Number and a non-empty String.
+ */
+    static int
+non_zero_arg(typval_T *argvars)
+{
+    return ((argvars[0].v_type == VAR_NUMBER
+		&& argvars[0].vval.v_number != 0)
+	    || (argvars[0].v_type == VAR_SPECIAL
+		&& argvars[0].vval.v_number == VVAL_TRUE)
+	    || (argvars[0].v_type == VAR_STRING
+		&& argvars[0].vval.v_string != NULL
+		&& *argvars[0].vval.v_string != NUL));
+}
+
+/*
+ * Get the lnum from the first argument.
+ * Also accepts ".", "$", etc., but that only works for the current buffer.
+ * Returns -1 on error.
+ */
+    static linenr_T
+get_tv_lnum(typval_T *argvars)
+{
+    typval_T	rettv;
+    linenr_T	lnum;
+
+    lnum = (linenr_T)get_tv_number_chk(&argvars[0], NULL);
+    if (lnum == 0)  /* no valid number, try using line() */
+    {
+	rettv.v_type = VAR_NUMBER;
+	f_line(argvars, &rettv);
+	lnum = (linenr_T)rettv.vval.v_number;
+	clear_tv(&rettv);
+    }
+    return lnum;
+}
+
+#ifdef FEAT_FLOAT
+static int get_float_arg(typval_T *argvars, float_T *f);
+
+/*
+ * Get the float value of "argvars[0]" into "f".
+ * Returns FAIL when the argument is not a Number or Float.
+ */
+    static int
+get_float_arg(typval_T *argvars, float_T *f)
+{
+    if (argvars[0].v_type == VAR_FLOAT)
+    {
+	*f = argvars[0].vval.v_float;
+	return OK;
+    }
+    if (argvars[0].v_type == VAR_NUMBER)
+    {
+	*f = (float_T)argvars[0].vval.v_number;
+	return OK;
+    }
+    EMSG(_("E808: Number or Float required"));
+    return FAIL;
+}
+
+/*
+ * "abs(expr)" function
+ */
+    static void
+f_abs(typval_T *argvars, typval_T *rettv)
+{
+    if (argvars[0].v_type == VAR_FLOAT)
+    {
+	rettv->v_type = VAR_FLOAT;
+	rettv->vval.v_float = fabs(argvars[0].vval.v_float);
+    }
+    else
+    {
+	varnumber_T	n;
+	int		error = FALSE;
+
+	n = get_tv_number_chk(&argvars[0], &error);
+	if (error)
+	    rettv->vval.v_number = -1;
+	else if (n > 0)
+	    rettv->vval.v_number = n;
+	else
+	    rettv->vval.v_number = -n;
+    }
+}
+
+/*
+ * "acos()" function
+ */
+    static void
+f_acos(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = acos(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "add(list, item)" function
+ */
+    static void
+f_add(typval_T *argvars, typval_T *rettv)
+{
+    list_T	*l;
+
+    rettv->vval.v_number = 1; /* Default: Failed */
+    if (argvars[0].v_type == VAR_LIST)
+    {
+	if ((l = argvars[0].vval.v_list) != NULL
+		&& !tv_check_lock(l->lv_lock,
+					 (char_u *)N_("add() argument"), TRUE)
+		&& list_append_tv(l, &argvars[1]) == OK)
+	    copy_tv(&argvars[0], rettv);
+    }
+    else
+	EMSG(_(e_listreq));
+}
+
+/*
+ * "and(expr, expr)" function
+ */
+    static void
+f_and(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
+					& get_tv_number_chk(&argvars[1], NULL);
+}
+
+/*
+ * Get the lnum from the first argument.
+ * Also accepts "$", then "buf" is used.
+ * Returns 0 on error.
+ */
+    static linenr_T
+get_tv_lnum_buf(typval_T *argvars, buf_T *buf)
+{
+    if (argvars[0].v_type == VAR_STRING
+	    && argvars[0].vval.v_string != NULL
+	    && argvars[0].vval.v_string[0] == '$'
+	    && buf != NULL)
+	return buf->b_ml.ml_line_count;
+    return (linenr_T)get_tv_number_chk(&argvars[0], NULL);
+}
+
+/*
+ * If there is a window for "curbuf", make it the current window.
+ */
+    static void
+find_win_for_curbuf(void)
+{
+    wininfo_T *wip;
+
+    for (wip = curbuf->b_wininfo; wip != NULL; wip = wip->wi_next)
+    {
+	if (wip->wi_win != NULL)
+	{
+	    curwin = wip->wi_win;
+	    break;
+	}
+    }
+}
+
+/*
+ * Set line or list of lines in buffer "buf".
+ */
+    static void
+set_buffer_lines(
+	buf_T	    *buf,
+	linenr_T    lnum_arg,
+	int	    append,
+	typval_T    *lines,
+	typval_T    *rettv)
+{
+    linenr_T    lnum = lnum_arg + (append ? 1 : 0);
+    char_u	*line = NULL;
+    list_T	*l = NULL;
+    listitem_T	*li = NULL;
+    long	added = 0;
+    linenr_T	append_lnum;
+    buf_T	*curbuf_save = NULL;
+    win_T	*curwin_save = NULL;
+    int		is_curbuf = buf == curbuf;
+
+    /* When using the current buffer ml_mfp will be set if needed.  Useful when
+     * setline() is used on startup.  For other buffers the buffer must be
+     * loaded. */
+    if (buf == NULL || (!is_curbuf && buf->b_ml.ml_mfp == NULL) || lnum < 1)
+    {
+	rettv->vval.v_number = 1;	/* FAIL */
+	return;
+    }
+
+    if (!is_curbuf)
+    {
+	curbuf_save = curbuf;
+	curwin_save = curwin;
+	curbuf = buf;
+	find_win_for_curbuf();
+    }
+
+    if (append)
+	// appendbufline() uses the line number below which we insert
+	append_lnum = lnum - 1;
+    else
+	// setbufline() uses the line number above which we insert, we only
+	// append if it's below the last line
+	append_lnum = curbuf->b_ml.ml_line_count;
+
+    if (lines->v_type == VAR_LIST)
+    {
+	l = lines->vval.v_list;
+	li = l->lv_first;
+    }
+    else
+	line = get_tv_string_chk(lines);
+
+    /* default result is zero == OK */
+    for (;;)
+    {
+	if (l != NULL)
+	{
+	    /* list argument, get next string */
+	    if (li == NULL)
+		break;
+	    line = get_tv_string_chk(&li->li_tv);
+	    li = li->li_next;
+	}
+
+	rettv->vval.v_number = 1;	/* FAIL */
+	if (line == NULL || lnum > curbuf->b_ml.ml_line_count + 1)
+	    break;
+
+	/* When coming here from Insert mode, sync undo, so that this can be
+	 * undone separately from what was previously inserted. */
+	if (u_sync_once == 2)
+	{
+	    u_sync_once = 1; /* notify that u_sync() was called */
+	    u_sync(TRUE);
+	}
+
+	if (!append && lnum <= curbuf->b_ml.ml_line_count)
+	{
+	    /* existing line, replace it */
+	    if (u_savesub(lnum) == OK && ml_replace(lnum, line, TRUE) == OK)
+	    {
+		changed_bytes(lnum, 0);
+		if (is_curbuf && lnum == curwin->w_cursor.lnum)
+		    check_cursor_col();
+		rettv->vval.v_number = 0;	/* OK */
+	    }
+	}
+	else if (added > 0 || u_save(lnum - 1, lnum) == OK)
+	{
+	    /* append the line */
+	    ++added;
+	    if (ml_append(lnum - 1, line, (colnr_T)0, FALSE) == OK)
+		rettv->vval.v_number = 0;	/* OK */
+	}
+
+	if (l == NULL)			/* only one string argument */
+	    break;
+	++lnum;
+    }
+
+    if (added > 0)
+    {
+	win_T	    *wp;
+	tabpage_T   *tp;
+
+	appended_lines_mark(append_lnum, added);
+	FOR_ALL_TAB_WINDOWS(tp, wp)
+	    if (wp->w_buffer == buf && wp->w_cursor.lnum > append_lnum)
+		wp->w_cursor.lnum += added;
+	check_cursor_col();
+
+#ifdef FEAT_JOB_CHANNEL
+	if (bt_prompt(curbuf) && (State & INSERT))
+	    // show the line with the prompt
+	    update_topline();
+#endif
+    }
+
+    if (!is_curbuf)
+    {
+	curbuf = curbuf_save;
+	curwin = curwin_save;
+    }
+}
+
+/*
+ * "append(lnum, string/list)" function
+ */
+    static void
+f_append(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum = get_tv_lnum(&argvars[0]);
+
+    set_buffer_lines(curbuf, lnum, TRUE, &argvars[1], rettv);
+}
+
+/*
+ * "appendbufline(buf, lnum, string/list)" function
+ */
+    static void
+f_appendbufline(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum;
+    buf_T	*buf;
+
+    buf = get_buf_tv(&argvars[0], FALSE);
+    if (buf == NULL)
+	rettv->vval.v_number = 1; /* FAIL */
+    else
+    {
+	lnum = get_tv_lnum_buf(&argvars[1], buf);
+	set_buffer_lines(buf, lnum, TRUE, &argvars[2], rettv);
+    }
+}
+
+/*
+ * "argc()" function
+ */
+    static void
+f_argc(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = ARGCOUNT;
+}
+
+/*
+ * "argidx()" function
+ */
+    static void
+f_argidx(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = curwin->w_arg_idx;
+}
+
+/*
+ * "arglistid()" function
+ */
+    static void
+f_arglistid(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*wp;
+
+    rettv->vval.v_number = -1;
+    wp = find_tabwin(&argvars[0], &argvars[1]);
+    if (wp != NULL)
+	rettv->vval.v_number = wp->w_alist->id;
+}
+
+/*
+ * "argv(nr)" function
+ */
+    static void
+f_argv(typval_T *argvars, typval_T *rettv)
+{
+    int		idx;
+
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	idx = (int)get_tv_number_chk(&argvars[0], NULL);
+	if (idx >= 0 && idx < ARGCOUNT)
+	    rettv->vval.v_string = vim_strsave(alist_name(&ARGLIST[idx]));
+	else
+	    rettv->vval.v_string = NULL;
+	rettv->v_type = VAR_STRING;
+    }
+    else if (rettv_list_alloc(rettv) == OK)
+	for (idx = 0; idx < ARGCOUNT; ++idx)
+	    list_append_string(rettv->vval.v_list,
+					       alist_name(&ARGLIST[idx]), -1);
+}
+
+/*
+ * "assert_beeps(cmd [, error])" function
+ */
+    static void
+f_assert_beeps(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_beeps(argvars);
+}
+
+/*
+ * "assert_equal(expected, actual[, msg])" function
+ */
+    static void
+f_assert_equal(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);
+}
+
+/*
+ * "assert_equalfile(fname-one, fname-two)" function
+ */
+    static void
+f_assert_equalfile(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_equalfile(argvars);
+}
+
+/*
+ * "assert_notequal(expected, actual[, msg])" function
+ */
+    static void
+f_assert_notequal(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);
+}
+
+/*
+ * "assert_exception(string[, msg])" function
+ */
+    static void
+f_assert_exception(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_exception(argvars);
+}
+
+/*
+ * "assert_fails(cmd [, error])" function
+ */
+    static void
+f_assert_fails(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_fails(argvars);
+}
+
+/*
+ * "assert_false(actual[, msg])" function
+ */
+    static void
+f_assert_false(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_bool(argvars, FALSE);
+}
+
+/*
+ * "assert_inrange(lower, upper[, msg])" function
+ */
+    static void
+f_assert_inrange(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_inrange(argvars);
+}
+
+/*
+ * "assert_match(pattern, actual[, msg])" function
+ */
+    static void
+f_assert_match(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_match_common(argvars, ASSERT_MATCH);
+}
+
+/*
+ * "assert_notmatch(pattern, actual[, msg])" function
+ */
+    static void
+f_assert_notmatch(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);
+}
+
+/*
+ * "assert_report(msg)" function
+ */
+    static void
+f_assert_report(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_report(argvars);
+}
+
+/*
+ * "assert_true(actual[, msg])" function
+ */
+    static void
+f_assert_true(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = assert_bool(argvars, TRUE);
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "asin()" function
+ */
+    static void
+f_asin(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = asin(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "atan()" function
+ */
+    static void
+f_atan(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = atan(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "atan2()" function
+ */
+    static void
+f_atan2(typval_T *argvars, typval_T *rettv)
+{
+    float_T	fx = 0.0, fy = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &fx) == OK
+				     && get_float_arg(&argvars[1], &fy) == OK)
+	rettv->vval.v_float = atan2(fx, fy);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "balloon_show()" function
+ */
+#ifdef FEAT_BEVAL
+    static void
+f_balloon_show(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    if (balloonEval != NULL)
+    {
+	if (argvars[0].v_type == VAR_LIST
+# ifdef FEAT_GUI
+		&& !gui.in_use
+# endif
+	   )
+	    post_balloon(balloonEval, NULL, argvars[0].vval.v_list);
+	else
+	    post_balloon(balloonEval, get_tv_string_chk(&argvars[0]), NULL);
+    }
+}
+
+# if defined(FEAT_BEVAL_TERM)
+    static void
+f_balloon_split(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    if (rettv_list_alloc(rettv) == OK)
+    {
+	char_u *msg = get_tv_string_chk(&argvars[0]);
+
+	if (msg != NULL)
+	{
+	    pumitem_T	*array;
+	    int		size = split_message(msg, &array);
+	    int		i;
+
+	    /* Skip the first and last item, they are always empty. */
+	    for (i = 1; i < size - 1; ++i)
+		list_append_string(rettv->vval.v_list, array[i].pum_text, -1);
+	    while (size > 0)
+		vim_free(array[--size].pum_text);
+	    vim_free(array);
+	}
+    }
+}
+# endif
+#endif
+
+/*
+ * "browse(save, title, initdir, default)" function
+ */
+    static void
+f_browse(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_BROWSE
+    int		save;
+    char_u	*title;
+    char_u	*initdir;
+    char_u	*defname;
+    char_u	buf[NUMBUFLEN];
+    char_u	buf2[NUMBUFLEN];
+    int		error = FALSE;
+
+    save = (int)get_tv_number_chk(&argvars[0], &error);
+    title = get_tv_string_chk(&argvars[1]);
+    initdir = get_tv_string_buf_chk(&argvars[2], buf);
+    defname = get_tv_string_buf_chk(&argvars[3], buf2);
+
+    if (error || title == NULL || initdir == NULL || defname == NULL)
+	rettv->vval.v_string = NULL;
+    else
+	rettv->vval.v_string =
+		 do_browse(save ? BROWSE_SAVE : 0,
+				 title, defname, NULL, initdir, NULL, curbuf);
+#else
+    rettv->vval.v_string = NULL;
+#endif
+    rettv->v_type = VAR_STRING;
+}
+
+/*
+ * "browsedir(title, initdir)" function
+ */
+    static void
+f_browsedir(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_BROWSE
+    char_u	*title;
+    char_u	*initdir;
+    char_u	buf[NUMBUFLEN];
+
+    title = get_tv_string_chk(&argvars[0]);
+    initdir = get_tv_string_buf_chk(&argvars[1], buf);
+
+    if (title == NULL || initdir == NULL)
+	rettv->vval.v_string = NULL;
+    else
+	rettv->vval.v_string = do_browse(BROWSE_DIR,
+				    title, NULL, NULL, initdir, NULL, curbuf);
+#else
+    rettv->vval.v_string = NULL;
+#endif
+    rettv->v_type = VAR_STRING;
+}
+
+static buf_T *find_buffer(typval_T *avar);
+
+/*
+ * Find a buffer by number or exact name.
+ */
+    static buf_T *
+find_buffer(typval_T *avar)
+{
+    buf_T	*buf = NULL;
+
+    if (avar->v_type == VAR_NUMBER)
+	buf = buflist_findnr((int)avar->vval.v_number);
+    else if (avar->v_type == VAR_STRING && avar->vval.v_string != NULL)
+    {
+	buf = buflist_findname_exp(avar->vval.v_string);
+	if (buf == NULL)
+	{
+	    /* No full path name match, try a match with a URL or a "nofile"
+	     * buffer, these don't use the full path. */
+	    FOR_ALL_BUFFERS(buf)
+		if (buf->b_fname != NULL
+			&& (path_with_url(buf->b_fname)
+#ifdef FEAT_QUICKFIX
+			    || bt_nofile(buf)
+#endif
+			   )
+			&& STRCMP(buf->b_fname, avar->vval.v_string) == 0)
+		    break;
+	}
+    }
+    return buf;
+}
+
+/*
+ * "bufexists(expr)" function
+ */
+    static void
+f_bufexists(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = (find_buffer(&argvars[0]) != NULL);
+}
+
+/*
+ * "buflisted(expr)" function
+ */
+    static void
+f_buflisted(typval_T *argvars, typval_T *rettv)
+{
+    buf_T	*buf;
+
+    buf = find_buffer(&argvars[0]);
+    rettv->vval.v_number = (buf != NULL && buf->b_p_bl);
+}
+
+/*
+ * "bufloaded(expr)" function
+ */
+    static void
+f_bufloaded(typval_T *argvars, typval_T *rettv)
+{
+    buf_T	*buf;
+
+    buf = find_buffer(&argvars[0]);
+    rettv->vval.v_number = (buf != NULL && buf->b_ml.ml_mfp != NULL);
+}
+
+    buf_T *
+buflist_find_by_name(char_u *name, int curtab_only)
+{
+    int		save_magic;
+    char_u	*save_cpo;
+    buf_T	*buf;
+
+    /* Ignore 'magic' and 'cpoptions' here to make scripts portable */
+    save_magic = p_magic;
+    p_magic = TRUE;
+    save_cpo = p_cpo;
+    p_cpo = (char_u *)"";
+
+    buf = buflist_findnr(buflist_findpat(name, name + STRLEN(name),
+						    TRUE, FALSE, curtab_only));
+
+    p_magic = save_magic;
+    p_cpo = save_cpo;
+    return buf;
+}
+
+/*
+ * Get buffer by number or pattern.
+ */
+    buf_T *
+get_buf_tv(typval_T *tv, int curtab_only)
+{
+    char_u	*name = tv->vval.v_string;
+    buf_T	*buf;
+
+    if (tv->v_type == VAR_NUMBER)
+	return buflist_findnr((int)tv->vval.v_number);
+    if (tv->v_type != VAR_STRING)
+	return NULL;
+    if (name == NULL || *name == NUL)
+	return curbuf;
+    if (name[0] == '$' && name[1] == NUL)
+	return lastbuf;
+
+    buf = buflist_find_by_name(name, curtab_only);
+
+    /* If not found, try expanding the name, like done for bufexists(). */
+    if (buf == NULL)
+	buf = find_buffer(tv);
+
+    return buf;
+}
+
+/*
+ * "bufname(expr)" function
+ */
+    static void
+f_bufname(typval_T *argvars, typval_T *rettv)
+{
+    buf_T	*buf;
+
+    (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
+    ++emsg_off;
+    buf = get_buf_tv(&argvars[0], FALSE);
+    rettv->v_type = VAR_STRING;
+    if (buf != NULL && buf->b_fname != NULL)
+	rettv->vval.v_string = vim_strsave(buf->b_fname);
+    else
+	rettv->vval.v_string = NULL;
+    --emsg_off;
+}
+
+/*
+ * "bufnr(expr)" function
+ */
+    static void
+f_bufnr(typval_T *argvars, typval_T *rettv)
+{
+    buf_T	*buf;
+    int		error = FALSE;
+    char_u	*name;
+
+    (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
+    ++emsg_off;
+    buf = get_buf_tv(&argvars[0], FALSE);
+    --emsg_off;
+
+    /* If the buffer isn't found and the second argument is not zero create a
+     * new buffer. */
+    if (buf == NULL
+	    && argvars[1].v_type != VAR_UNKNOWN
+	    && get_tv_number_chk(&argvars[1], &error) != 0
+	    && !error
+	    && (name = get_tv_string_chk(&argvars[0])) != NULL
+	    && !error)
+	buf = buflist_new(name, NULL, (linenr_T)1, 0);
+
+    if (buf != NULL)
+	rettv->vval.v_number = buf->b_fnum;
+    else
+	rettv->vval.v_number = -1;
+}
+
+    static void
+buf_win_common(typval_T *argvars, typval_T *rettv, int get_nr)
+{
+    win_T	*wp;
+    int		winnr = 0;
+    buf_T	*buf;
+
+    (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
+    ++emsg_off;
+    buf = get_buf_tv(&argvars[0], TRUE);
+    FOR_ALL_WINDOWS(wp)
+    {
+	++winnr;
+	if (wp->w_buffer == buf)
+	    break;
+    }
+    rettv->vval.v_number = (wp != NULL ? (get_nr ? winnr : wp->w_id) : -1);
+    --emsg_off;
+}
+
+/*
+ * "bufwinid(nr)" function
+ */
+    static void
+f_bufwinid(typval_T *argvars, typval_T *rettv)
+{
+    buf_win_common(argvars, rettv, FALSE);
+}
+
+/*
+ * "bufwinnr(nr)" function
+ */
+    static void
+f_bufwinnr(typval_T *argvars, typval_T *rettv)
+{
+    buf_win_common(argvars, rettv, TRUE);
+}
+
+/*
+ * "byte2line(byte)" function
+ */
+    static void
+f_byte2line(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifndef FEAT_BYTEOFF
+    rettv->vval.v_number = -1;
+#else
+    long	boff = 0;
+
+    boff = get_tv_number(&argvars[0]) - 1;  /* boff gets -1 on type error */
+    if (boff < 0)
+	rettv->vval.v_number = -1;
+    else
+	rettv->vval.v_number = ml_find_line_or_offset(curbuf,
+							  (linenr_T)0, &boff);
+#endif
+}
+
+    static void
+byteidx(typval_T *argvars, typval_T *rettv, int comp UNUSED)
+{
+#ifdef FEAT_MBYTE
+    char_u	*t;
+#endif
+    char_u	*str;
+    varnumber_T	idx;
+
+    str = get_tv_string_chk(&argvars[0]);
+    idx = get_tv_number_chk(&argvars[1], NULL);
+    rettv->vval.v_number = -1;
+    if (str == NULL || idx < 0)
+	return;
+
+#ifdef FEAT_MBYTE
+    t = str;
+    for ( ; idx > 0; idx--)
+    {
+	if (*t == NUL)		/* EOL reached */
+	    return;
+	if (enc_utf8 && comp)
+	    t += utf_ptr2len(t);
+	else
+	    t += (*mb_ptr2len)(t);
+    }
+    rettv->vval.v_number = (varnumber_T)(t - str);
+#else
+    if ((size_t)idx <= STRLEN(str))
+	rettv->vval.v_number = idx;
+#endif
+}
+
+/*
+ * "byteidx()" function
+ */
+    static void
+f_byteidx(typval_T *argvars, typval_T *rettv)
+{
+    byteidx(argvars, rettv, FALSE);
+}
+
+/*
+ * "byteidxcomp()" function
+ */
+    static void
+f_byteidxcomp(typval_T *argvars, typval_T *rettv)
+{
+    byteidx(argvars, rettv, TRUE);
+}
+
+/*
+ * "call(func, arglist [, dict])" function
+ */
+    static void
+f_call(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*func;
+    partial_T   *partial = NULL;
+    dict_T	*selfdict = NULL;
+
+    if (argvars[1].v_type != VAR_LIST)
+    {
+	EMSG(_(e_listreq));
+	return;
+    }
+    if (argvars[1].vval.v_list == NULL)
+	return;
+
+    if (argvars[0].v_type == VAR_FUNC)
+	func = argvars[0].vval.v_string;
+    else if (argvars[0].v_type == VAR_PARTIAL)
+    {
+	partial = argvars[0].vval.v_partial;
+	func = partial_name(partial);
+    }
+    else
+	func = get_tv_string(&argvars[0]);
+    if (*func == NUL)
+	return;		/* type error or empty name */
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	if (argvars[2].v_type != VAR_DICT)
+	{
+	    EMSG(_(e_dictreq));
+	    return;
+	}
+	selfdict = argvars[2].vval.v_dict;
+    }
+
+    (void)func_call(func, &argvars[1], partial, selfdict, rettv);
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "ceil({float})" function
+ */
+    static void
+f_ceil(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = ceil(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+#ifdef FEAT_JOB_CHANNEL
+/*
+ * "ch_canread()" function
+ */
+    static void
+f_ch_canread(typval_T *argvars, typval_T *rettv)
+{
+    channel_T *channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
+
+    rettv->vval.v_number = 0;
+    if (channel != NULL)
+	rettv->vval.v_number = channel_has_readahead(channel, PART_SOCK)
+			    || channel_has_readahead(channel, PART_OUT)
+			    || channel_has_readahead(channel, PART_ERR);
+}
+
+/*
+ * "ch_close()" function
+ */
+    static void
+f_ch_close(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    channel_T *channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
+
+    if (channel != NULL)
+    {
+	channel_close(channel, FALSE);
+	channel_clear(channel);
+    }
+}
+
+/*
+ * "ch_close()" function
+ */
+    static void
+f_ch_close_in(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    channel_T *channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
+
+    if (channel != NULL)
+	channel_close_in(channel);
+}
+
+/*
+ * "ch_getbufnr()" function
+ */
+    static void
+f_ch_getbufnr(typval_T *argvars, typval_T *rettv)
+{
+    channel_T *channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
+
+    rettv->vval.v_number = -1;
+    if (channel != NULL)
+    {
+	char_u	*what = get_tv_string(&argvars[1]);
+	int	part;
+
+	if (STRCMP(what, "err") == 0)
+	    part = PART_ERR;
+	else if (STRCMP(what, "out") == 0)
+	    part = PART_OUT;
+	else if (STRCMP(what, "in") == 0)
+	    part = PART_IN;
+	else
+	    part = PART_SOCK;
+	if (channel->ch_part[part].ch_bufref.br_buf != NULL)
+	    rettv->vval.v_number =
+			      channel->ch_part[part].ch_bufref.br_buf->b_fnum;
+    }
+}
+
+/*
+ * "ch_getjob()" function
+ */
+    static void
+f_ch_getjob(typval_T *argvars, typval_T *rettv)
+{
+    channel_T *channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
+
+    if (channel != NULL)
+    {
+	rettv->v_type = VAR_JOB;
+	rettv->vval.v_job = channel->ch_job;
+	if (channel->ch_job != NULL)
+	    ++channel->ch_job->jv_refcount;
+    }
+}
+
+/*
+ * "ch_info()" function
+ */
+    static void
+f_ch_info(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    channel_T *channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
+
+    if (channel != NULL && rettv_dict_alloc(rettv) != FAIL)
+	channel_info(channel, rettv->vval.v_dict);
+}
+
+/*
+ * "ch_log()" function
+ */
+    static void
+f_ch_log(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    char_u	*msg = get_tv_string(&argvars[0]);
+    channel_T	*channel = NULL;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	channel = get_channel_arg(&argvars[1], FALSE, FALSE, 0);
+
+    ch_log(channel, "%s", msg);
+}
+
+/*
+ * "ch_logfile()" function
+ */
+    static void
+f_ch_logfile(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    char_u *fname;
+    char_u *opt = (char_u *)"";
+    char_u buf[NUMBUFLEN];
+
+    /* Don't open a file in restricted mode. */
+    if (check_restricted() || check_secure())
+	return;
+    fname = get_tv_string(&argvars[0]);
+    if (argvars[1].v_type == VAR_STRING)
+	opt = get_tv_string_buf(&argvars[1], buf);
+    ch_logfile(fname, opt);
+}
+
+/*
+ * "ch_open()" function
+ */
+    static void
+f_ch_open(typval_T *argvars, typval_T *rettv)
+{
+    rettv->v_type = VAR_CHANNEL;
+    if (check_restricted() || check_secure())
+	return;
+    rettv->vval.v_channel = channel_open_func(argvars);
+}
+
+/*
+ * "ch_read()" function
+ */
+    static void
+f_ch_read(typval_T *argvars, typval_T *rettv)
+{
+    common_channel_read(argvars, rettv, FALSE);
+}
+
+/*
+ * "ch_readraw()" function
+ */
+    static void
+f_ch_readraw(typval_T *argvars, typval_T *rettv)
+{
+    common_channel_read(argvars, rettv, TRUE);
+}
+
+/*
+ * "ch_evalexpr()" function
+ */
+    static void
+f_ch_evalexpr(typval_T *argvars, typval_T *rettv)
+{
+    ch_expr_common(argvars, rettv, TRUE);
+}
+
+/*
+ * "ch_sendexpr()" function
+ */
+    static void
+f_ch_sendexpr(typval_T *argvars, typval_T *rettv)
+{
+    ch_expr_common(argvars, rettv, FALSE);
+}
+
+/*
+ * "ch_evalraw()" function
+ */
+    static void
+f_ch_evalraw(typval_T *argvars, typval_T *rettv)
+{
+    ch_raw_common(argvars, rettv, TRUE);
+}
+
+/*
+ * "ch_sendraw()" function
+ */
+    static void
+f_ch_sendraw(typval_T *argvars, typval_T *rettv)
+{
+    ch_raw_common(argvars, rettv, FALSE);
+}
+
+/*
+ * "ch_setoptions()" function
+ */
+    static void
+f_ch_setoptions(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    channel_T	*channel;
+    jobopt_T	opt;
+
+    channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
+    if (channel == NULL)
+	return;
+    clear_job_options(&opt);
+    if (get_job_options(&argvars[1], &opt,
+			    JO_CB_ALL + JO_TIMEOUT_ALL + JO_MODE_ALL, 0) == OK)
+	channel_set_options(channel, &opt);
+    free_job_options(&opt);
+}
+
+/*
+ * "ch_status()" function
+ */
+    static void
+f_ch_status(typval_T *argvars, typval_T *rettv)
+{
+    channel_T	*channel;
+    jobopt_T	opt;
+    int		part = -1;
+
+    /* return an empty string by default */
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+
+    channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	clear_job_options(&opt);
+	if (get_job_options(&argvars[1], &opt, JO_PART, 0) == OK
+						     && (opt.jo_set & JO_PART))
+	    part = opt.jo_part;
+    }
+
+    rettv->vval.v_string = vim_strsave((char_u *)channel_status(channel, part));
+}
+#endif
+
+/*
+ * "changenr()" function
+ */
+    static void
+f_changenr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = curbuf->b_u_seq_cur;
+}
+
+/*
+ * "char2nr(string)" function
+ */
+    static void
+f_char2nr(typval_T *argvars, typval_T *rettv)
+{
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+    {
+	int	utf8 = 0;
+
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	    utf8 = (int)get_tv_number_chk(&argvars[1], NULL);
+
+	if (utf8)
+	    rettv->vval.v_number = (*utf_ptr2char)(get_tv_string(&argvars[0]));
+	else
+	    rettv->vval.v_number = (*mb_ptr2char)(get_tv_string(&argvars[0]));
+    }
+    else
+#endif
+    rettv->vval.v_number = get_tv_string(&argvars[0])[0];
+}
+
+/*
+ * "cindent(lnum)" function
+ */
+    static void
+f_cindent(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_CINDENT
+    pos_T	pos;
+    linenr_T	lnum;
+
+    pos = curwin->w_cursor;
+    lnum = get_tv_lnum(argvars);
+    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
+    {
+	curwin->w_cursor.lnum = lnum;
+	rettv->vval.v_number = get_c_indent();
+	curwin->w_cursor = pos;
+    }
+    else
+#endif
+	rettv->vval.v_number = -1;
+}
+
+/*
+ * "clearmatches()" function
+ */
+    static void
+f_clearmatches(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_SEARCH_EXTRA
+    clear_matches(curwin);
+#endif
+}
+
+/*
+ * "col(string)" function
+ */
+    static void
+f_col(typval_T *argvars, typval_T *rettv)
+{
+    colnr_T	col = 0;
+    pos_T	*fp;
+    int		fnum = curbuf->b_fnum;
+
+    fp = var2fpos(&argvars[0], FALSE, &fnum);
+    if (fp != NULL && fnum == curbuf->b_fnum)
+    {
+	if (fp->col == MAXCOL)
+	{
+	    /* '> can be MAXCOL, get the length of the line then */
+	    if (fp->lnum <= curbuf->b_ml.ml_line_count)
+		col = (colnr_T)STRLEN(ml_get(fp->lnum)) + 1;
+	    else
+		col = MAXCOL;
+	}
+	else
+	{
+	    col = fp->col + 1;
+#ifdef FEAT_VIRTUALEDIT
+	    /* col(".") when the cursor is on the NUL at the end of the line
+	     * because of "coladd" can be seen as an extra column. */
+	    if (virtual_active() && fp == &curwin->w_cursor)
+	    {
+		char_u	*p = ml_get_cursor();
+
+		if (curwin->w_cursor.coladd >= (colnr_T)chartabsize(p,
+				 curwin->w_virtcol - curwin->w_cursor.coladd))
+		{
+# ifdef FEAT_MBYTE
+		    int		l;
+
+		    if (*p != NUL && p[(l = (*mb_ptr2len)(p))] == NUL)
+			col += l;
+# else
+		    if (*p != NUL && p[1] == NUL)
+			++col;
+# endif
+		}
+	    }
+#endif
+	}
+    }
+    rettv->vval.v_number = col;
+}
+
+#if defined(FEAT_INS_EXPAND)
+/*
+ * "complete()" function
+ */
+    static void
+f_complete(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    int	    startcol;
+
+    if ((State & INSERT) == 0)
+    {
+	EMSG(_("E785: complete() can only be used in Insert mode"));
+	return;
+    }
+
+    /* Check for undo allowed here, because if something was already inserted
+     * the line was already saved for undo and this check isn't done. */
+    if (!undo_allowed())
+	return;
+
+    if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)
+    {
+	EMSG(_(e_invarg));
+	return;
+    }
+
+    startcol = (int)get_tv_number_chk(&argvars[0], NULL);
+    if (startcol <= 0)
+	return;
+
+    set_completion(startcol - 1, argvars[1].vval.v_list);
+}
+
+/*
+ * "complete_add()" function
+ */
+    static void
+f_complete_add(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = ins_compl_add_tv(&argvars[0], 0);
+}
+
+/*
+ * "complete_check()" function
+ */
+    static void
+f_complete_check(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		saved = RedrawingDisabled;
+
+    RedrawingDisabled = 0;
+    ins_compl_check_keys(0, TRUE);
+    rettv->vval.v_number = compl_interrupted;
+    RedrawingDisabled = saved;
+}
+#endif
+
+/*
+ * "confirm(message, buttons[, default [, type]])" function
+ */
+    static void
+f_confirm(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+    char_u	*message;
+    char_u	*buttons = NULL;
+    char_u	buf[NUMBUFLEN];
+    char_u	buf2[NUMBUFLEN];
+    int		def = 1;
+    int		type = VIM_GENERIC;
+    char_u	*typestr;
+    int		error = FALSE;
+
+    message = get_tv_string_chk(&argvars[0]);
+    if (message == NULL)
+	error = TRUE;
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	buttons = get_tv_string_buf_chk(&argvars[1], buf);
+	if (buttons == NULL)
+	    error = TRUE;
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
+	    def = (int)get_tv_number_chk(&argvars[2], &error);
+	    if (argvars[3].v_type != VAR_UNKNOWN)
+	    {
+		typestr = get_tv_string_buf_chk(&argvars[3], buf2);
+		if (typestr == NULL)
+		    error = TRUE;
+		else
+		{
+		    switch (TOUPPER_ASC(*typestr))
+		    {
+			case 'E': type = VIM_ERROR; break;
+			case 'Q': type = VIM_QUESTION; break;
+			case 'I': type = VIM_INFO; break;
+			case 'W': type = VIM_WARNING; break;
+			case 'G': type = VIM_GENERIC; break;
+		    }
+		}
+	    }
+	}
+    }
+
+    if (buttons == NULL || *buttons == NUL)
+	buttons = (char_u *)_("&Ok");
+
+    if (!error)
+	rettv->vval.v_number = do_dialog(type, NULL, message, buttons,
+							    def, NULL, FALSE);
+#endif
+}
+
+/*
+ * "copy()" function
+ */
+    static void
+f_copy(typval_T *argvars, typval_T *rettv)
+{
+    item_copy(&argvars[0], rettv, FALSE, 0);
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "cos()" function
+ */
+    static void
+f_cos(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = cos(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "cosh()" function
+ */
+    static void
+f_cosh(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = cosh(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "count()" function
+ */
+    static void
+f_count(typval_T *argvars, typval_T *rettv)
+{
+    long	n = 0;
+    int		ic = FALSE;
+    int		error = FALSE;
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+	ic = (int)get_tv_number_chk(&argvars[2], &error);
+
+    if (argvars[0].v_type == VAR_STRING)
+    {
+	char_u *expr = get_tv_string_chk(&argvars[1]);
+	char_u *p = argvars[0].vval.v_string;
+	char_u *next;
+
+	if (!error && expr != NULL && *expr != NUL && p != NULL)
+	{
+	    if (ic)
+	    {
+		size_t len = STRLEN(expr);
+
+		while (*p != NUL)
+		{
+		    if (MB_STRNICMP(p, expr, len) == 0)
+		    {
+			++n;
+			p += len;
+		    }
+		    else
+			MB_PTR_ADV(p);
+		}
+	    }
+	    else
+		while ((next = (char_u *)strstr((char *)p, (char *)expr))
+								       != NULL)
+		{
+		    ++n;
+		    p = next + STRLEN(expr);
+		}
+	}
+
+    }
+    else if (argvars[0].v_type == VAR_LIST)
+    {
+	listitem_T	*li;
+	list_T		*l;
+	long		idx;
+
+	if ((l = argvars[0].vval.v_list) != NULL)
+	{
+	    li = l->lv_first;
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    {
+		if (argvars[3].v_type != VAR_UNKNOWN)
+		{
+		    idx = (long)get_tv_number_chk(&argvars[3], &error);
+		    if (!error)
+		    {
+			li = list_find(l, idx);
+			if (li == NULL)
+			    EMSGN(_(e_listidx), idx);
+		    }
+		}
+		if (error)
+		    li = NULL;
+	    }
+
+	    for ( ; li != NULL; li = li->li_next)
+		if (tv_equal(&li->li_tv, &argvars[1], ic, FALSE))
+		    ++n;
+	}
+    }
+    else if (argvars[0].v_type == VAR_DICT)
+    {
+	int		todo;
+	dict_T		*d;
+	hashitem_T	*hi;
+
+	if ((d = argvars[0].vval.v_dict) != NULL)
+	{
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    {
+		if (argvars[3].v_type != VAR_UNKNOWN)
+		    EMSG(_(e_invarg));
+	    }
+
+	    todo = error ? 0 : (int)d->dv_hashtab.ht_used;
+	    for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi)
+	    {
+		if (!HASHITEM_EMPTY(hi))
+		{
+		    --todo;
+		    if (tv_equal(&HI2DI(hi)->di_tv, &argvars[1], ic, FALSE))
+			++n;
+		}
+	    }
+	}
+    }
+    else
+	EMSG2(_(e_listdictarg), "count()");
+    rettv->vval.v_number = n;
+}
+
+/*
+ * "cscope_connection([{num} , {dbpath} [, {prepend}]])" function
+ *
+ * Checks the existence of a cscope connection.
+ */
+    static void
+f_cscope_connection(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_CSCOPE
+    int		num = 0;
+    char_u	*dbpath = NULL;
+    char_u	*prepend = NULL;
+    char_u	buf[NUMBUFLEN];
+
+    if (argvars[0].v_type != VAR_UNKNOWN
+	    && argvars[1].v_type != VAR_UNKNOWN)
+    {
+	num = (int)get_tv_number(&argvars[0]);
+	dbpath = get_tv_string(&argvars[1]);
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    prepend = get_tv_string_buf(&argvars[2], buf);
+    }
+
+    rettv->vval.v_number = cs_connection(num, dbpath, prepend);
+#endif
+}
+
+/*
+ * "cursor(lnum, col)" function, or
+ * "cursor(list)"
+ *
+ * Moves the cursor to the specified line and column.
+ * Returns 0 when the position could be set, -1 otherwise.
+ */
+    static void
+f_cursor(typval_T *argvars, typval_T *rettv)
+{
+    long	line, col;
+#ifdef FEAT_VIRTUALEDIT
+    long	coladd = 0;
+#endif
+    int		set_curswant = TRUE;
+
+    rettv->vval.v_number = -1;
+    if (argvars[1].v_type == VAR_UNKNOWN)
+    {
+	pos_T	    pos;
+	colnr_T	    curswant = -1;
+
+	if (list2fpos(argvars, &pos, NULL, &curswant) == FAIL)
+	{
+	    EMSG(_(e_invarg));
+	    return;
+	}
+	line = pos.lnum;
+	col = pos.col;
+#ifdef FEAT_VIRTUALEDIT
+	coladd = pos.coladd;
+#endif
+	if (curswant >= 0)
+	{
+	    curwin->w_curswant = curswant - 1;
+	    set_curswant = FALSE;
+	}
+    }
+    else
+    {
+	line = get_tv_lnum(argvars);
+	col = (long)get_tv_number_chk(&argvars[1], NULL);
+#ifdef FEAT_VIRTUALEDIT
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    coladd = (long)get_tv_number_chk(&argvars[2], NULL);
+#endif
+    }
+    if (line < 0 || col < 0
+#ifdef FEAT_VIRTUALEDIT
+			    || coladd < 0
+#endif
+	    )
+	return;		/* type error; errmsg already given */
+    if (line > 0)
+	curwin->w_cursor.lnum = line;
+    if (col > 0)
+	curwin->w_cursor.col = col - 1;
+#ifdef FEAT_VIRTUALEDIT
+    curwin->w_cursor.coladd = coladd;
+#endif
+
+    /* Make sure the cursor is in a valid position. */
+    check_cursor();
+#ifdef FEAT_MBYTE
+    /* Correct cursor for multi-byte character. */
+    if (has_mbyte)
+	mb_adjust_cursor();
+#endif
+
+    curwin->w_set_curswant = set_curswant;
+    rettv->vval.v_number = 0;
+}
+
+#ifdef WIN3264
+/*
+ * "debugbreak()" function
+ */
+    static void
+f_debugbreak(typval_T *argvars, typval_T *rettv)
+{
+    int		pid;
+
+    rettv->vval.v_number = FAIL;
+    pid = (int)get_tv_number(&argvars[0]);
+    if (pid == 0)
+	EMSG(_(e_invarg));
+    else
+    {
+	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
+
+	if (hProcess != NULL)
+	{
+	    DebugBreakProcess(hProcess);
+	    CloseHandle(hProcess);
+	    rettv->vval.v_number = OK;
+	}
+    }
+}
+#endif
+
+/*
+ * "deepcopy()" function
+ */
+    static void
+f_deepcopy(typval_T *argvars, typval_T *rettv)
+{
+    int		noref = 0;
+    int		copyID;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	noref = (int)get_tv_number_chk(&argvars[1], NULL);
+    if (noref < 0 || noref > 1)
+	EMSG(_(e_invarg));
+    else
+    {
+	copyID = get_copyID();
+	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? copyID : 0);
+    }
+}
+
+/*
+ * "delete()" function
+ */
+    static void
+f_delete(typval_T *argvars, typval_T *rettv)
+{
+    char_u	nbuf[NUMBUFLEN];
+    char_u	*name;
+    char_u	*flags;
+
+    rettv->vval.v_number = -1;
+    if (check_restricted() || check_secure())
+	return;
+
+    name = get_tv_string(&argvars[0]);
+    if (name == NULL || *name == NUL)
+    {
+	EMSG(_(e_invarg));
+	return;
+    }
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	flags = get_tv_string_buf(&argvars[1], nbuf);
+    else
+	flags = (char_u *)"";
+
+    if (*flags == NUL)
+	/* delete a file */
+	rettv->vval.v_number = mch_remove(name) == 0 ? 0 : -1;
+    else if (STRCMP(flags, "d") == 0)
+	/* delete an empty directory */
+	rettv->vval.v_number = mch_rmdir(name) == 0 ? 0 : -1;
+    else if (STRCMP(flags, "rf") == 0)
+	/* delete a directory recursively */
+	rettv->vval.v_number = delete_recursive(name);
+    else
+	EMSG2(_(e_invexpr2), flags);
+}
+
+/*
+ * "deletebufline()" function
+ */
+    static void
+f_deletebufline(typval_T *argvars, typval_T *rettv)
+{
+    buf_T	*buf;
+    linenr_T	first, last;
+    linenr_T	lnum;
+    long	count;
+    int		is_curbuf;
+    buf_T	*curbuf_save = NULL;
+    win_T	*curwin_save = NULL;
+    tabpage_T	*tp;
+    win_T	*wp;
+
+    buf = get_buf_tv(&argvars[0], FALSE);
+    if (buf == NULL)
+    {
+	rettv->vval.v_number = 1; /* FAIL */
+	return;
+    }
+    is_curbuf = buf == curbuf;
+
+    first = get_tv_lnum_buf(&argvars[1], buf);
+    if (argvars[2].v_type != VAR_UNKNOWN)
+	last = get_tv_lnum_buf(&argvars[2], buf);
+    else
+	last = first;
+
+    if (buf->b_ml.ml_mfp == NULL || first < 1
+			   || first > buf->b_ml.ml_line_count || last < first)
+    {
+	rettv->vval.v_number = 1;	/* FAIL */
+	return;
+    }
+
+    if (!is_curbuf)
+    {
+	curbuf_save = curbuf;
+	curwin_save = curwin;
+	curbuf = buf;
+	find_win_for_curbuf();
+    }
+    if (last > curbuf->b_ml.ml_line_count)
+	last = curbuf->b_ml.ml_line_count;
+    count = last - first + 1;
+
+    // When coming here from Insert mode, sync undo, so that this can be
+    // undone separately from what was previously inserted.
+    if (u_sync_once == 2)
+    {
+	u_sync_once = 1; // notify that u_sync() was called
+	u_sync(TRUE);
+    }
+
+    if (u_save(first - 1, last + 1) == FAIL)
+    {
+	rettv->vval.v_number = 1;	/* FAIL */
+	return;
+    }
+
+    for (lnum = first; lnum <= last; ++lnum)
+	ml_delete(first, TRUE);
+
+    FOR_ALL_TAB_WINDOWS(tp, wp)
+	if (wp->w_buffer == buf)
+	{
+	    if (wp->w_cursor.lnum > last)
+		wp->w_cursor.lnum -= count;
+	    else if (wp->w_cursor.lnum> first)
+		wp->w_cursor.lnum = first;
+	    if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)
+		wp->w_cursor.lnum = wp->w_buffer->b_ml.ml_line_count;
+	}
+    check_cursor_col();
+    deleted_lines_mark(first, count);
+
+    if (!is_curbuf)
+    {
+	curbuf = curbuf_save;
+	curwin = curwin_save;
+    }
+}
+
+/*
+ * "did_filetype()" function
+ */
+    static void
+f_did_filetype(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+    rettv->vval.v_number = did_filetype;
+}
+
+/*
+ * "diff_filler()" function
+ */
+    static void
+f_diff_filler(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_DIFF
+    rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
+#endif
+}
+
+/*
+ * "diff_hlID()" function
+ */
+    static void
+f_diff_hlID(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_DIFF
+    linenr_T		lnum = get_tv_lnum(argvars);
+    static linenr_T	prev_lnum = 0;
+    static varnumber_T	changedtick = 0;
+    static int		fnum = 0;
+    static int		change_start = 0;
+    static int		change_end = 0;
+    static hlf_T	hlID = (hlf_T)0;
+    int			filler_lines;
+    int			col;
+
+    if (lnum < 0)	/* ignore type error in {lnum} arg */
+	lnum = 0;
+    if (lnum != prev_lnum
+	    || changedtick != CHANGEDTICK(curbuf)
+	    || fnum != curbuf->b_fnum)
+    {
+	/* New line, buffer, change: need to get the values. */
+	filler_lines = diff_check(curwin, lnum);
+	if (filler_lines < 0)
+	{
+	    if (filler_lines == -1)
+	    {
+		change_start = MAXCOL;
+		change_end = -1;
+		if (diff_find_change(curwin, lnum, &change_start, &change_end))
+		    hlID = HLF_ADD;	/* added line */
+		else
+		    hlID = HLF_CHD;	/* changed line */
+	    }
+	    else
+		hlID = HLF_ADD;	/* added line */
+	}
+	else
+	    hlID = (hlf_T)0;
+	prev_lnum = lnum;
+	changedtick = CHANGEDTICK(curbuf);
+	fnum = curbuf->b_fnum;
+    }
+
+    if (hlID == HLF_CHD || hlID == HLF_TXD)
+    {
+	col = get_tv_number(&argvars[1]) - 1; /* ignore type error in {col} */
+	if (col >= change_start && col <= change_end)
+	    hlID = HLF_TXD;			/* changed text */
+	else
+	    hlID = HLF_CHD;			/* changed line */
+    }
+    rettv->vval.v_number = hlID == (hlf_T)0 ? 0 : (int)hlID;
+#endif
+}
+
+/*
+ * "empty({expr})" function
+ */
+    static void
+f_empty(typval_T *argvars, typval_T *rettv)
+{
+    int		n = FALSE;
+
+    switch (argvars[0].v_type)
+    {
+	case VAR_STRING:
+	case VAR_FUNC:
+	    n = argvars[0].vval.v_string == NULL
+					  || *argvars[0].vval.v_string == NUL;
+	    break;
+	case VAR_PARTIAL:
+	    n = FALSE;
+	    break;
+	case VAR_NUMBER:
+	    n = argvars[0].vval.v_number == 0;
+	    break;
+	case VAR_FLOAT:
+#ifdef FEAT_FLOAT
+	    n = argvars[0].vval.v_float == 0.0;
+	    break;
+#endif
+	case VAR_LIST:
+	    n = argvars[0].vval.v_list == NULL
+				  || argvars[0].vval.v_list->lv_first == NULL;
+	    break;
+	case VAR_DICT:
+	    n = argvars[0].vval.v_dict == NULL
+			|| argvars[0].vval.v_dict->dv_hashtab.ht_used == 0;
+	    break;
+	case VAR_SPECIAL:
+	    n = argvars[0].vval.v_number != VVAL_TRUE;
+	    break;
+
+	case VAR_JOB:
+#ifdef FEAT_JOB_CHANNEL
+	    n = argvars[0].vval.v_job == NULL
+			   || argvars[0].vval.v_job->jv_status != JOB_STARTED;
+	    break;
+#endif
+	case VAR_CHANNEL:
+#ifdef FEAT_JOB_CHANNEL
+	    n = argvars[0].vval.v_channel == NULL
+			       || !channel_is_open(argvars[0].vval.v_channel);
+	    break;
+#endif
+	case VAR_UNKNOWN:
+	    internal_error("f_empty(UNKNOWN)");
+	    n = TRUE;
+	    break;
+    }
+
+    rettv->vval.v_number = n;
+}
+
+/*
+ * "escape({string}, {chars})" function
+ */
+    static void
+f_escape(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf[NUMBUFLEN];
+
+    rettv->vval.v_string = vim_strsave_escaped(get_tv_string(&argvars[0]),
+					 get_tv_string_buf(&argvars[1], buf));
+    rettv->v_type = VAR_STRING;
+}
+
+/*
+ * "eval()" function
+ */
+    static void
+f_eval(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*s, *p;
+
+    s = get_tv_string_chk(&argvars[0]);
+    if (s != NULL)
+	s = skipwhite(s);
+
+    p = s;
+    if (s == NULL || eval1(&s, rettv, TRUE) == FAIL)
+    {
+	if (p != NULL && !aborting())
+	    EMSG2(_(e_invexpr2), p);
+	need_clr_eos = FALSE;
+	rettv->v_type = VAR_NUMBER;
+	rettv->vval.v_number = 0;
+    }
+    else if (*s != NUL)
+	EMSG(_(e_trailing));
+}
+
+/*
+ * "eventhandler()" function
+ */
+    static void
+f_eventhandler(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = vgetc_busy;
+}
+
+/*
+ * "executable()" function
+ */
+    static void
+f_executable(typval_T *argvars, typval_T *rettv)
+{
+    char_u *name = get_tv_string(&argvars[0]);
+
+    /* Check in $PATH and also check directly if there is a directory name. */
+    rettv->vval.v_number = mch_can_exe(name, NULL, TRUE)
+		 || (gettail(name) != name && mch_can_exe(name, NULL, FALSE));
+}
+
+static garray_T	redir_execute_ga;
+
+/*
+ * Append "value[value_len]" to the execute() output.
+ */
+    void
+execute_redir_str(char_u *value, int value_len)
+{
+    int		len;
+
+    if (value_len == -1)
+	len = (int)STRLEN(value);	/* Append the entire string */
+    else
+	len = value_len;		/* Append only "value_len" characters */
+    if (ga_grow(&redir_execute_ga, len) == OK)
+    {
+	mch_memmove((char *)redir_execute_ga.ga_data
+				       + redir_execute_ga.ga_len, value, len);
+	redir_execute_ga.ga_len += len;
+    }
+}
+
+/*
+ * Get next line from a list.
+ * Called by do_cmdline() to get the next line.
+ * Returns allocated string, or NULL for end of function.
+ */
+
+    static char_u *
+get_list_line(
+    int	    c UNUSED,
+    void    *cookie,
+    int	    indent UNUSED)
+{
+    listitem_T **p = (listitem_T **)cookie;
+    listitem_T *item = *p;
+    char_u	buf[NUMBUFLEN];
+    char_u	*s;
+
+    if (item == NULL)
+	return NULL;
+    s = get_tv_string_buf_chk(&item->li_tv, buf);
+    *p = item->li_next;
+    return s == NULL ? NULL : vim_strsave(s);
+}
+
+/*
+ * "execute()" function
+ */
+    static void
+f_execute(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*cmd = NULL;
+    list_T	*list = NULL;
+    int		save_msg_silent = msg_silent;
+    int		save_emsg_silent = emsg_silent;
+    int		save_emsg_noredir = emsg_noredir;
+    int		save_redir_execute = redir_execute;
+    int		save_redir_off = redir_off;
+    garray_T	save_ga;
+
+    rettv->vval.v_string = NULL;
+    rettv->v_type = VAR_STRING;
+
+    if (argvars[0].v_type == VAR_LIST)
+    {
+	list = argvars[0].vval.v_list;
+	if (list == NULL || list->lv_first == NULL)
+	    /* empty list, no commands, empty output */
+	    return;
+	++list->lv_refcount;
+    }
+    else
+    {
+	cmd = get_tv_string_chk(&argvars[0]);
+	if (cmd == NULL)
+	    return;
+    }
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	char_u	buf[NUMBUFLEN];
+	char_u  *s = get_tv_string_buf_chk(&argvars[1], buf);
+
+	if (s == NULL)
+	    return;
+	if (STRNCMP(s, "silent", 6) == 0)
+	    ++msg_silent;
+	if (STRCMP(s, "silent!") == 0)
+	{
+	    emsg_silent = TRUE;
+	    emsg_noredir = TRUE;
+	}
+    }
+    else
+	++msg_silent;
+
+    if (redir_execute)
+	save_ga = redir_execute_ga;
+    ga_init2(&redir_execute_ga, (int)sizeof(char), 500);
+    redir_execute = TRUE;
+    redir_off = FALSE;
+
+    if (cmd != NULL)
+	do_cmdline_cmd(cmd);
+    else
+    {
+	listitem_T	*item = list->lv_first;
+
+	do_cmdline(NULL, get_list_line, (void *)&item,
+		      DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT|DOCMD_KEYTYPED);
+	--list->lv_refcount;
+    }
+
+    /* Need to append a NUL to the result. */
+    if (ga_grow(&redir_execute_ga, 1) == OK)
+    {
+	((char *)redir_execute_ga.ga_data)[redir_execute_ga.ga_len] = NUL;
+	rettv->vval.v_string = redir_execute_ga.ga_data;
+    }
+    else
+    {
+	ga_clear(&redir_execute_ga);
+	rettv->vval.v_string = NULL;
+    }
+    msg_silent = save_msg_silent;
+    emsg_silent = save_emsg_silent;
+    emsg_noredir = save_emsg_noredir;
+
+    redir_execute = save_redir_execute;
+    if (redir_execute)
+	redir_execute_ga = save_ga;
+    redir_off = save_redir_off;
+
+    /* "silent reg" or "silent echo x" leaves msg_col somewhere in the
+     * line.  Put it back in the first column. */
+    msg_col = 0;
+}
+
+/*
+ * "exepath()" function
+ */
+    static void
+f_exepath(typval_T *argvars, typval_T *rettv)
+{
+    char_u *p = NULL;
+
+    (void)mch_can_exe(get_tv_string(&argvars[0]), &p, TRUE);
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = p;
+}
+
+/*
+ * "exists()" function
+ */
+    static void
+f_exists(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*p;
+    int		n = FALSE;
+
+    p = get_tv_string(&argvars[0]);
+    if (*p == '$')			/* environment variable */
+    {
+	/* first try "normal" environment variables (fast) */
+	if (mch_getenv(p + 1) != NULL)
+	    n = TRUE;
+	else
+	{
+	    /* try expanding things like $VIM and ${HOME} */
+	    p = expand_env_save(p);
+	    if (p != NULL && *p != '$')
+		n = TRUE;
+	    vim_free(p);
+	}
+    }
+    else if (*p == '&' || *p == '+')			/* option */
+    {
+	n = (get_option_tv(&p, NULL, TRUE) == OK);
+	if (*skipwhite(p) != NUL)
+	    n = FALSE;			/* trailing garbage */
+    }
+    else if (*p == '*')			/* internal or user defined function */
+    {
+	n = function_exists(p + 1, FALSE);
+    }
+    else if (*p == ':')
+    {
+	n = cmd_exists(p + 1);
+    }
+    else if (*p == '#')
+    {
+	if (p[1] == '#')
+	    n = autocmd_supported(p + 2);
+	else
+	    n = au_exists(p + 1);
+    }
+    else				/* internal variable */
+    {
+	n = var_exists(p);
+    }
+
+    rettv->vval.v_number = n;
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "exp()" function
+ */
+    static void
+f_exp(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = exp(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "expand()" function
+ */
+    static void
+f_expand(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*s;
+    int		len;
+    char_u	*errormsg;
+    int		options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;
+    expand_T	xpc;
+    int		error = FALSE;
+    char_u	*result;
+
+    rettv->v_type = VAR_STRING;
+    if (argvars[1].v_type != VAR_UNKNOWN
+	    && argvars[2].v_type != VAR_UNKNOWN
+	    && get_tv_number_chk(&argvars[2], &error)
+	    && !error)
+    {
+	rettv_list_set(rettv, NULL);
+    }
+
+    s = get_tv_string(&argvars[0]);
+    if (*s == '%' || *s == '#' || *s == '<')
+    {
+	++emsg_off;
+	result = eval_vars(s, s, &len, NULL, &errormsg, NULL);
+	--emsg_off;
+	if (rettv->v_type == VAR_LIST)
+	{
+	    if (rettv_list_alloc(rettv) != FAIL && result != NULL)
+		list_append_string(rettv->vval.v_list, result, -1);
+	    else
+		vim_free(result);
+	}
+	else
+	    rettv->vval.v_string = result;
+    }
+    else
+    {
+	/* When the optional second argument is non-zero, don't remove matches
+	 * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+	if (argvars[1].v_type != VAR_UNKNOWN
+				    && get_tv_number_chk(&argvars[1], &error))
+	    options |= WILD_KEEP_ALL;
+	if (!error)
+	{
+	    ExpandInit(&xpc);
+	    xpc.xp_context = EXPAND_FILES;
+	    if (p_wic)
+		options += WILD_ICASE;
+	    if (rettv->v_type == VAR_STRING)
+		rettv->vval.v_string = ExpandOne(&xpc, s, NULL,
+							   options, WILD_ALL);
+	    else if (rettv_list_alloc(rettv) != FAIL)
+	    {
+		int i;
+
+		ExpandOne(&xpc, s, NULL, options, WILD_ALL_KEEP);
+		for (i = 0; i < xpc.xp_numfiles; i++)
+		    list_append_string(rettv->vval.v_list, xpc.xp_files[i], -1);
+		ExpandCleanup(&xpc);
+	    }
+	}
+	else
+	    rettv->vval.v_string = NULL;
+    }
+}
+
+/*
+ * "extend(list, list [, idx])" function
+ * "extend(dict, dict [, action])" function
+ */
+    static void
+f_extend(typval_T *argvars, typval_T *rettv)
+{
+    char_u      *arg_errmsg = (char_u *)N_("extend() argument");
+
+    if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_LIST)
+    {
+	list_T		*l1, *l2;
+	listitem_T	*item;
+	long		before;
+	int		error = FALSE;
+
+	l1 = argvars[0].vval.v_list;
+	l2 = argvars[1].vval.v_list;
+	if (l1 != NULL && !tv_check_lock(l1->lv_lock, arg_errmsg, TRUE)
+		&& l2 != NULL)
+	{
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    {
+		before = (long)get_tv_number_chk(&argvars[2], &error);
+		if (error)
+		    return;		/* type error; errmsg already given */
+
+		if (before == l1->lv_len)
+		    item = NULL;
+		else
+		{
+		    item = list_find(l1, before);
+		    if (item == NULL)
+		    {
+			EMSGN(_(e_listidx), before);
+			return;
+		    }
+		}
+	    }
+	    else
+		item = NULL;
+	    list_extend(l1, l2, item);
+
+	    copy_tv(&argvars[0], rettv);
+	}
+    }
+    else if (argvars[0].v_type == VAR_DICT && argvars[1].v_type == VAR_DICT)
+    {
+	dict_T	*d1, *d2;
+	char_u	*action;
+	int	i;
+
+	d1 = argvars[0].vval.v_dict;
+	d2 = argvars[1].vval.v_dict;
+	if (d1 != NULL && !tv_check_lock(d1->dv_lock, arg_errmsg, TRUE)
+		&& d2 != NULL)
+	{
+	    /* Check the third argument. */
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    {
+		static char *(av[]) = {"keep", "force", "error"};
+
+		action = get_tv_string_chk(&argvars[2]);
+		if (action == NULL)
+		    return;		/* type error; errmsg already given */
+		for (i = 0; i < 3; ++i)
+		    if (STRCMP(action, av[i]) == 0)
+			break;
+		if (i == 3)
+		{
+		    EMSG2(_(e_invarg2), action);
+		    return;
+		}
+	    }
+	    else
+		action = (char_u *)"force";
+
+	    dict_extend(d1, d2, action);
+
+	    copy_tv(&argvars[0], rettv);
+	}
+    }
+    else
+	EMSG2(_(e_listdictarg), "extend()");
+}
+
+/*
+ * "feedkeys()" function
+ */
+    static void
+f_feedkeys(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    int		remap = TRUE;
+    int		insert = FALSE;
+    char_u	*keys, *flags;
+    char_u	nbuf[NUMBUFLEN];
+    int		typed = FALSE;
+    int		execute = FALSE;
+    int		dangerous = FALSE;
+    char_u	*keys_esc;
+
+    /* This is not allowed in the sandbox.  If the commands would still be
+     * executed in the sandbox it would be OK, but it probably happens later,
+     * when "sandbox" is no longer set. */
+    if (check_secure())
+	return;
+
+    keys = get_tv_string(&argvars[0]);
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	flags = get_tv_string_buf(&argvars[1], nbuf);
+	for ( ; *flags != NUL; ++flags)
+	{
+	    switch (*flags)
+	    {
+		case 'n': remap = FALSE; break;
+		case 'm': remap = TRUE; break;
+		case 't': typed = TRUE; break;
+		case 'i': insert = TRUE; break;
+		case 'x': execute = TRUE; break;
+		case '!': dangerous = TRUE; break;
+	    }
+	}
+    }
+
+    if (*keys != NUL || execute)
+    {
+	/* Need to escape K_SPECIAL and CSI before putting the string in the
+	 * typeahead buffer. */
+	keys_esc = vim_strsave_escape_csi(keys);
+	if (keys_esc != NULL)
+	{
+	    ins_typebuf(keys_esc, (remap ? REMAP_YES : REMAP_NONE),
+				  insert ? 0 : typebuf.tb_len, !typed, FALSE);
+	    vim_free(keys_esc);
+	    if (vgetc_busy
+#ifdef FEAT_TIMERS
+		    || timer_busy
+#endif
+		    )
+		typebuf_was_filled = TRUE;
+	    if (execute)
+	    {
+		int save_msg_scroll = msg_scroll;
+
+		/* Avoid a 1 second delay when the keys start Insert mode. */
+		msg_scroll = FALSE;
+
+		if (!dangerous)
+		    ++ex_normal_busy;
+		exec_normal(TRUE, TRUE);
+		if (!dangerous)
+		    --ex_normal_busy;
+
+		msg_scroll |= save_msg_scroll;
+	    }
+	}
+    }
+}
+
+/*
+ * "filereadable()" function
+ */
+    static void
+f_filereadable(typval_T *argvars, typval_T *rettv)
+{
+    int		fd;
+    char_u	*p;
+    int		n;
+
+#ifndef O_NONBLOCK
+# define O_NONBLOCK 0
+#endif
+    p = get_tv_string(&argvars[0]);
+    if (*p && !mch_isdir(p) && (fd = mch_open((char *)p,
+					      O_RDONLY | O_NONBLOCK, 0)) >= 0)
+    {
+	n = TRUE;
+	close(fd);
+    }
+    else
+	n = FALSE;
+
+    rettv->vval.v_number = n;
+}
+
+/*
+ * Return 0 for not writable, 1 for writable file, 2 for a dir which we have
+ * rights to write into.
+ */
+    static void
+f_filewritable(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = filewritable(get_tv_string(&argvars[0]));
+}
+
+    static void
+findfilendir(
+    typval_T	*argvars UNUSED,
+    typval_T	*rettv,
+    int		find_what UNUSED)
+{
+#ifdef FEAT_SEARCHPATH
+    char_u	*fname;
+    char_u	*fresult = NULL;
+    char_u	*path = *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path;
+    char_u	*p;
+    char_u	pathbuf[NUMBUFLEN];
+    int		count = 1;
+    int		first = TRUE;
+    int		error = FALSE;
+#endif
+
+    rettv->vval.v_string = NULL;
+    rettv->v_type = VAR_STRING;
+
+#ifdef FEAT_SEARCHPATH
+    fname = get_tv_string(&argvars[0]);
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	p = get_tv_string_buf_chk(&argvars[1], pathbuf);
+	if (p == NULL)
+	    error = TRUE;
+	else
+	{
+	    if (*p != NUL)
+		path = p;
+
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+		count = (int)get_tv_number_chk(&argvars[2], &error);
+	}
+    }
+
+    if (count < 0 && rettv_list_alloc(rettv) == FAIL)
+	error = TRUE;
+
+    if (*fname != NUL && !error)
+    {
+	do
+	{
+	    if (rettv->v_type == VAR_STRING || rettv->v_type == VAR_LIST)
+		vim_free(fresult);
+	    fresult = find_file_in_path_option(first ? fname : NULL,
+					       first ? (int)STRLEN(fname) : 0,
+					0, first, path,
+					find_what,
+					curbuf->b_ffname,
+					find_what == FINDFILE_DIR
+					    ? (char_u *)"" : curbuf->b_p_sua);
+	    first = FALSE;
+
+	    if (fresult != NULL && rettv->v_type == VAR_LIST)
+		list_append_string(rettv->vval.v_list, fresult, -1);
+
+	} while ((rettv->v_type == VAR_LIST || --count > 0) && fresult != NULL);
+    }
+
+    if (rettv->v_type == VAR_STRING)
+	rettv->vval.v_string = fresult;
+#endif
+}
+
+/*
+ * "filter()" function
+ */
+    static void
+f_filter(typval_T *argvars, typval_T *rettv)
+{
+    filter_map(argvars, rettv, FALSE);
+}
+
+/*
+ * "finddir({fname}[, {path}[, {count}]])" function
+ */
+    static void
+f_finddir(typval_T *argvars, typval_T *rettv)
+{
+    findfilendir(argvars, rettv, FINDFILE_DIR);
+}
+
+/*
+ * "findfile({fname}[, {path}[, {count}]])" function
+ */
+    static void
+f_findfile(typval_T *argvars, typval_T *rettv)
+{
+    findfilendir(argvars, rettv, FINDFILE_FILE);
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "float2nr({float})" function
+ */
+    static void
+f_float2nr(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    if (get_float_arg(argvars, &f) == OK)
+    {
+	if (f <= -VARNUM_MAX + DBL_EPSILON)
+	    rettv->vval.v_number = -VARNUM_MAX;
+	else if (f >= VARNUM_MAX - DBL_EPSILON)
+	    rettv->vval.v_number = VARNUM_MAX;
+	else
+	    rettv->vval.v_number = (varnumber_T)f;
+    }
+}
+
+/*
+ * "floor({float})" function
+ */
+    static void
+f_floor(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = floor(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "fmod()" function
+ */
+    static void
+f_fmod(typval_T *argvars, typval_T *rettv)
+{
+    float_T	fx = 0.0, fy = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &fx) == OK
+				     && get_float_arg(&argvars[1], &fy) == OK)
+	rettv->vval.v_float = fmod(fx, fy);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "fnameescape({string})" function
+ */
+    static void
+f_fnameescape(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_string = vim_strsave_fnameescape(
+					   get_tv_string(&argvars[0]), FALSE);
+    rettv->v_type = VAR_STRING;
+}
+
+/*
+ * "fnamemodify({fname}, {mods})" function
+ */
+    static void
+f_fnamemodify(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*fname;
+    char_u	*mods;
+    int		usedlen = 0;
+    int		len;
+    char_u	*fbuf = NULL;
+    char_u	buf[NUMBUFLEN];
+
+    fname = get_tv_string_chk(&argvars[0]);
+    mods = get_tv_string_buf_chk(&argvars[1], buf);
+    if (fname == NULL || mods == NULL)
+	fname = NULL;
+    else
+    {
+	len = (int)STRLEN(fname);
+	(void)modify_fname(mods, FALSE, &usedlen, &fname, &fbuf, &len);
+    }
+
+    rettv->v_type = VAR_STRING;
+    if (fname == NULL)
+	rettv->vval.v_string = NULL;
+    else
+	rettv->vval.v_string = vim_strnsave(fname, len);
+    vim_free(fbuf);
+}
+
+static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end);
+
+/*
+ * "foldclosed()" function
+ */
+    static void
+foldclosed_both(
+    typval_T	*argvars UNUSED,
+    typval_T	*rettv,
+    int		end UNUSED)
+{
+#ifdef FEAT_FOLDING
+    linenr_T	lnum;
+    linenr_T	first, last;
+
+    lnum = get_tv_lnum(argvars);
+    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
+    {
+	if (hasFoldingWin(curwin, lnum, &first, &last, FALSE, NULL))
+	{
+	    if (end)
+		rettv->vval.v_number = (varnumber_T)last;
+	    else
+		rettv->vval.v_number = (varnumber_T)first;
+	    return;
+	}
+    }
+#endif
+    rettv->vval.v_number = -1;
+}
+
+/*
+ * "foldclosed()" function
+ */
+    static void
+f_foldclosed(typval_T *argvars, typval_T *rettv)
+{
+    foldclosed_both(argvars, rettv, FALSE);
+}
+
+/*
+ * "foldclosedend()" function
+ */
+    static void
+f_foldclosedend(typval_T *argvars, typval_T *rettv)
+{
+    foldclosed_both(argvars, rettv, TRUE);
+}
+
+/*
+ * "foldlevel()" function
+ */
+    static void
+f_foldlevel(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_FOLDING
+    linenr_T	lnum;
+
+    lnum = get_tv_lnum(argvars);
+    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
+	rettv->vval.v_number = foldLevel(lnum);
+#endif
+}
+
+/*
+ * "foldtext()" function
+ */
+    static void
+f_foldtext(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_FOLDING
+    linenr_T	foldstart;
+    linenr_T	foldend;
+    char_u	*dashes;
+    linenr_T	lnum;
+    char_u	*s;
+    char_u	*r;
+    int		len;
+    char	*txt;
+    long	count;
+#endif
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_FOLDING
+    foldstart = (linenr_T)get_vim_var_nr(VV_FOLDSTART);
+    foldend = (linenr_T)get_vim_var_nr(VV_FOLDEND);
+    dashes = get_vim_var_str(VV_FOLDDASHES);
+    if (foldstart > 0 && foldend <= curbuf->b_ml.ml_line_count
+	    && dashes != NULL)
+    {
+	/* Find first non-empty line in the fold. */
+	for (lnum = foldstart; lnum < foldend; ++lnum)
+	    if (!linewhite(lnum))
+		break;
+
+	/* Find interesting text in this line. */
+	s = skipwhite(ml_get(lnum));
+	/* skip C comment-start */
+	if (s[0] == '/' && (s[1] == '*' || s[1] == '/'))
+	{
+	    s = skipwhite(s + 2);
+	    if (*skipwhite(s) == NUL
+			    && lnum + 1 < (linenr_T)get_vim_var_nr(VV_FOLDEND))
+	    {
+		s = skipwhite(ml_get(lnum + 1));
+		if (*s == '*')
+		    s = skipwhite(s + 1);
+	    }
+	}
+	count = (long)(foldend - foldstart + 1);
+	txt = NGETTEXT("+-%s%3ld line: ", "+-%s%3ld lines: ", count);
+	r = alloc((unsigned)(STRLEN(txt)
+		    + STRLEN(dashes)	    /* for %s */
+		    + 20		    /* for %3ld */
+		    + STRLEN(s)));	    /* concatenated */
+	if (r != NULL)
+	{
+	    sprintf((char *)r, txt, dashes, count);
+	    len = (int)STRLEN(r);
+	    STRCAT(r, s);
+	    /* remove 'foldmarker' and 'commentstring' */
+	    foldtext_cleanup(r + len);
+	    rettv->vval.v_string = r;
+	}
+    }
+#endif
+}
+
+/*
+ * "foldtextresult(lnum)" function
+ */
+    static void
+f_foldtextresult(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_FOLDING
+    linenr_T	lnum;
+    char_u	*text;
+    char_u	buf[FOLD_TEXT_LEN];
+    foldinfo_T  foldinfo;
+    int		fold_count;
+    static int	entered = FALSE;
+#endif
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_FOLDING
+    if (entered)
+	return; /* reject recursive use */
+    entered = TRUE;
+
+    lnum = get_tv_lnum(argvars);
+    /* treat illegal types and illegal string values for {lnum} the same */
+    if (lnum < 0)
+	lnum = 0;
+    fold_count = foldedCount(curwin, lnum, &foldinfo);
+    if (fold_count > 0)
+    {
+	text = get_foldtext(curwin, lnum, lnum + fold_count - 1,
+							       &foldinfo, buf);
+	if (text == buf)
+	    text = vim_strsave(text);
+	rettv->vval.v_string = text;
+    }
+
+    entered = FALSE;
+#endif
+}
+
+/*
+ * "foreground()" function
+ */
+    static void
+f_foreground(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_GUI
+    if (gui.in_use)
+	gui_mch_set_foreground();
+#else
+# ifdef WIN32
+    win32_set_foreground();
+# endif
+#endif
+}
+
+    static void
+common_function(typval_T *argvars, typval_T *rettv, int is_funcref)
+{
+    char_u	*s;
+    char_u	*name;
+    int		use_string = FALSE;
+    partial_T   *arg_pt = NULL;
+    char_u	*trans_name = NULL;
+
+    if (argvars[0].v_type == VAR_FUNC)
+    {
+	/* function(MyFunc, [arg], dict) */
+	s = argvars[0].vval.v_string;
+    }
+    else if (argvars[0].v_type == VAR_PARTIAL
+					 && argvars[0].vval.v_partial != NULL)
+    {
+	/* function(dict.MyFunc, [arg]) */
+	arg_pt = argvars[0].vval.v_partial;
+	s = partial_name(arg_pt);
+    }
+    else
+    {
+	/* function('MyFunc', [arg], dict) */
+	s = get_tv_string(&argvars[0]);
+	use_string = TRUE;
+    }
+
+    if ((use_string && vim_strchr(s, AUTOLOAD_CHAR) == NULL) || is_funcref)
+    {
+	name = s;
+	trans_name = trans_function_name(&name, FALSE,
+	     TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD | TFN_NO_DEREF, NULL, NULL);
+	if (*name != NUL)
+	    s = NULL;
+    }
+
+    if (s == NULL || *s == NUL || (use_string && VIM_ISDIGIT(*s))
+					 || (is_funcref && trans_name == NULL))
+	EMSG2(_(e_invarg2), use_string ? get_tv_string(&argvars[0]) : s);
+    /* Don't check an autoload name for existence here. */
+    else if (trans_name != NULL && (is_funcref
+				? find_func(trans_name) == NULL
+				: !translated_function_exists(trans_name)))
+	EMSG2(_("E700: Unknown function: %s"), s);
+    else
+    {
+	int	dict_idx = 0;
+	int	arg_idx = 0;
+	list_T	*list = NULL;
+
+	if (STRNCMP(s, "s:", 2) == 0 || STRNCMP(s, "<SID>", 5) == 0)
+	{
+	    char	sid_buf[25];
+	    int		off = *s == 's' ? 2 : 5;
+
+	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
+	     * also be called from another script. Using trans_function_name()
+	     * would also work, but some plugins depend on the name being
+	     * printable text. */
+	    sprintf(sid_buf, "<SNR>%ld_", (long)current_SID);
+	    name = alloc((int)(STRLEN(sid_buf) + STRLEN(s + off) + 1));
+	    if (name != NULL)
+	    {
+		STRCPY(name, sid_buf);
+		STRCAT(name, s + off);
+	    }
+	}
+	else
+	    name = vim_strsave(s);
+
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	{
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    {
+		/* function(name, [args], dict) */
+		arg_idx = 1;
+		dict_idx = 2;
+	    }
+	    else if (argvars[1].v_type == VAR_DICT)
+		/* function(name, dict) */
+		dict_idx = 1;
+	    else
+		/* function(name, [args]) */
+		arg_idx = 1;
+	    if (dict_idx > 0)
+	    {
+		if (argvars[dict_idx].v_type != VAR_DICT)
+		{
+		    EMSG(_("E922: expected a dict"));
+		    vim_free(name);
+		    goto theend;
+		}
+		if (argvars[dict_idx].vval.v_dict == NULL)
+		    dict_idx = 0;
+	    }
+	    if (arg_idx > 0)
+	    {
+		if (argvars[arg_idx].v_type != VAR_LIST)
+		{
+		    EMSG(_("E923: Second argument of function() must be a list or a dict"));
+		    vim_free(name);
+		    goto theend;
+		}
+		list = argvars[arg_idx].vval.v_list;
+		if (list == NULL || list->lv_len == 0)
+		    arg_idx = 0;
+	    }
+	}
+	if (dict_idx > 0 || arg_idx > 0 || arg_pt != NULL || is_funcref)
+	{
+	    partial_T	*pt = (partial_T *)alloc_clear(sizeof(partial_T));
+
+	    /* result is a VAR_PARTIAL */
+	    if (pt == NULL)
+		vim_free(name);
+	    else
+	    {
+		if (arg_idx > 0 || (arg_pt != NULL && arg_pt->pt_argc > 0))
+		{
+		    listitem_T	*li;
+		    int		i = 0;
+		    int		arg_len = 0;
+		    int		lv_len = 0;
+
+		    if (arg_pt != NULL)
+			arg_len = arg_pt->pt_argc;
+		    if (list != NULL)
+			lv_len = list->lv_len;
+		    pt->pt_argc = arg_len + lv_len;
+		    pt->pt_argv = (typval_T *)alloc(
+					      sizeof(typval_T) * pt->pt_argc);
+		    if (pt->pt_argv == NULL)
+		    {
+			vim_free(pt);
+			vim_free(name);
+			goto theend;
+		    }
+		    for (i = 0; i < arg_len; i++)
+			copy_tv(&arg_pt->pt_argv[i], &pt->pt_argv[i]);
+		    if (lv_len > 0)
+			for (li = list->lv_first; li != NULL;
+							 li = li->li_next)
+			    copy_tv(&li->li_tv, &pt->pt_argv[i++]);
+		}
+
+		/* For "function(dict.func, [], dict)" and "func" is a partial
+		 * use "dict".  That is backwards compatible. */
+		if (dict_idx > 0)
+		{
+		    /* The dict is bound explicitly, pt_auto is FALSE. */
+		    pt->pt_dict = argvars[dict_idx].vval.v_dict;
+		    ++pt->pt_dict->dv_refcount;
+		}
+		else if (arg_pt != NULL)
+		{
+		    /* If the dict was bound automatically the result is also
+		     * bound automatically. */
+		    pt->pt_dict = arg_pt->pt_dict;
+		    pt->pt_auto = arg_pt->pt_auto;
+		    if (pt->pt_dict != NULL)
+			++pt->pt_dict->dv_refcount;
+		}
+
+		pt->pt_refcount = 1;
+		if (arg_pt != NULL && arg_pt->pt_func != NULL)
+		{
+		    pt->pt_func = arg_pt->pt_func;
+		    func_ptr_ref(pt->pt_func);
+		    vim_free(name);
+		}
+		else if (is_funcref)
+		{
+		    pt->pt_func = find_func(trans_name);
+		    func_ptr_ref(pt->pt_func);
+		    vim_free(name);
+		}
+		else
+		{
+		    pt->pt_name = name;
+		    func_ref(name);
+		}
+	    }
+	    rettv->v_type = VAR_PARTIAL;
+	    rettv->vval.v_partial = pt;
+	}
+	else
+	{
+	    /* result is a VAR_FUNC */
+	    rettv->v_type = VAR_FUNC;
+	    rettv->vval.v_string = name;
+	    func_ref(name);
+	}
+    }
+theend:
+    vim_free(trans_name);
+}
+
+/*
+ * "funcref()" function
+ */
+    static void
+f_funcref(typval_T *argvars, typval_T *rettv)
+{
+    common_function(argvars, rettv, TRUE);
+}
+
+/*
+ * "function()" function
+ */
+    static void
+f_function(typval_T *argvars, typval_T *rettv)
+{
+    common_function(argvars, rettv, FALSE);
+}
+
+/*
+ * "garbagecollect()" function
+ */
+    static void
+f_garbagecollect(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    /* This is postponed until we are back at the toplevel, because we may be
+     * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
+    want_garbage_collect = TRUE;
+
+    if (argvars[0].v_type != VAR_UNKNOWN && get_tv_number(&argvars[0]) == 1)
+	garbage_collect_at_exit = TRUE;
+}
+
+/*
+ * "get()" function
+ */
+    static void
+f_get(typval_T *argvars, typval_T *rettv)
+{
+    listitem_T	*li;
+    list_T	*l;
+    dictitem_T	*di;
+    dict_T	*d;
+    typval_T	*tv = NULL;
+
+    if (argvars[0].v_type == VAR_LIST)
+    {
+	if ((l = argvars[0].vval.v_list) != NULL)
+	{
+	    int		error = FALSE;
+
+	    li = list_find(l, (long)get_tv_number_chk(&argvars[1], &error));
+	    if (!error && li != NULL)
+		tv = &li->li_tv;
+	}
+    }
+    else if (argvars[0].v_type == VAR_DICT)
+    {
+	if ((d = argvars[0].vval.v_dict) != NULL)
+	{
+	    di = dict_find(d, get_tv_string(&argvars[1]), -1);
+	    if (di != NULL)
+		tv = &di->di_tv;
+	}
+    }
+    else if (argvars[0].v_type == VAR_PARTIAL || argvars[0].v_type == VAR_FUNC)
+    {
+	partial_T	*pt;
+	partial_T	fref_pt;
+
+	if (argvars[0].v_type == VAR_PARTIAL)
+	    pt = argvars[0].vval.v_partial;
+	else
+	{
+	    vim_memset(&fref_pt, 0, sizeof(fref_pt));
+	    fref_pt.pt_name = argvars[0].vval.v_string;
+	    pt = &fref_pt;
+	}
+
+	if (pt != NULL)
+	{
+	    char_u *what = get_tv_string(&argvars[1]);
+	    char_u *n;
+
+	    if (STRCMP(what, "func") == 0 || STRCMP(what, "name") == 0)
+	    {
+		rettv->v_type = (*what == 'f' ? VAR_FUNC : VAR_STRING);
+		n = partial_name(pt);
+		if (n == NULL)
+		    rettv->vval.v_string = NULL;
+		else
+		{
+		    rettv->vval.v_string = vim_strsave(n);
+		    if (rettv->v_type == VAR_FUNC)
+			func_ref(rettv->vval.v_string);
+		}
+	    }
+	    else if (STRCMP(what, "dict") == 0)
+		rettv_dict_set(rettv, pt->pt_dict);
+	    else if (STRCMP(what, "args") == 0)
+	    {
+		rettv->v_type = VAR_LIST;
+		if (rettv_list_alloc(rettv) == OK)
+		{
+		    int i;
+
+		    for (i = 0; i < pt->pt_argc; ++i)
+			list_append_tv(rettv->vval.v_list, &pt->pt_argv[i]);
+		}
+	    }
+	    else
+		EMSG2(_(e_invarg2), what);
+	    return;
+	}
+    }
+    else
+	EMSG2(_(e_listdictarg), "get()");
+
+    if (tv == NULL)
+    {
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    copy_tv(&argvars[2], rettv);
+    }
+    else
+	copy_tv(tv, rettv);
+}
+
+#ifdef FEAT_SIGNS
+/*
+ * Returns information about signs placed in a buffer as list of dicts.
+ */
+    static void
+get_buffer_signs(buf_T *buf, list_T *l)
+{
+    signlist_T	*sign;
+
+    for (sign = buf->b_signlist; sign; sign = sign->next)
+    {
+	dict_T *d = dict_alloc();
+
+	if (d != NULL)
+	{
+	    dict_add_number(d, "id", sign->id);
+	    dict_add_number(d, "lnum", sign->lnum);
+	    dict_add_string(d, "name", sign_typenr2name(sign->typenr));
+
+	    list_append_dict(l, d);
+	}
+    }
+}
+#endif
+
+/*
+ * Returns buffer options, variables and other attributes in a dictionary.
+ */
+    static dict_T *
+get_buffer_info(buf_T *buf)
+{
+    dict_T	*dict;
+    tabpage_T	*tp;
+    win_T	*wp;
+    list_T	*windows;
+
+    dict = dict_alloc();
+    if (dict == NULL)
+	return NULL;
+
+    dict_add_number(dict, "bufnr", buf->b_fnum);
+    dict_add_string(dict, "name", buf->b_ffname);
+    dict_add_number(dict, "lnum", buf == curbuf ? curwin->w_cursor.lnum
+						     : buflist_findlnum(buf));
+    dict_add_number(dict, "loaded", buf->b_ml.ml_mfp != NULL);
+    dict_add_number(dict, "listed", buf->b_p_bl);
+    dict_add_number(dict, "changed", bufIsChanged(buf));
+    dict_add_number(dict, "changedtick", CHANGEDTICK(buf));
+    dict_add_number(dict, "hidden",
+			    buf->b_ml.ml_mfp != NULL && buf->b_nwindows == 0);
+
+    /* Get a reference to buffer variables */
+    dict_add_dict(dict, "variables", buf->b_vars);
+
+    /* List of windows displaying this buffer */
+    windows = list_alloc();
+    if (windows != NULL)
+    {
+	FOR_ALL_TAB_WINDOWS(tp, wp)
+	    if (wp->w_buffer == buf)
+		list_append_number(windows, (varnumber_T)wp->w_id);
+	dict_add_list(dict, "windows", windows);
+    }
+
+#ifdef FEAT_SIGNS
+    if (buf->b_signlist != NULL)
+    {
+	/* List of signs placed in this buffer */
+	list_T	*signs = list_alloc();
+	if (signs != NULL)
+	{
+	    get_buffer_signs(buf, signs);
+	    dict_add_list(dict, "signs", signs);
+	}
+    }
+#endif
+
+    return dict;
+}
+
+/*
+ * "getbufinfo()" function
+ */
+    static void
+f_getbufinfo(typval_T *argvars, typval_T *rettv)
+{
+    buf_T	*buf = NULL;
+    buf_T	*argbuf = NULL;
+    dict_T	*d;
+    int		filtered = FALSE;
+    int		sel_buflisted = FALSE;
+    int		sel_bufloaded = FALSE;
+    int		sel_bufmodified = FALSE;
+
+    if (rettv_list_alloc(rettv) != OK)
+	return;
+
+    /* List of all the buffers or selected buffers */
+    if (argvars[0].v_type == VAR_DICT)
+    {
+	dict_T	*sel_d = argvars[0].vval.v_dict;
+
+	if (sel_d != NULL)
+	{
+	    dictitem_T	*di;
+
+	    filtered = TRUE;
+
+	    di = dict_find(sel_d, (char_u *)"buflisted", -1);
+	    if (di != NULL && get_tv_number(&di->di_tv))
+		sel_buflisted = TRUE;
+
+	    di = dict_find(sel_d, (char_u *)"bufloaded", -1);
+	    if (di != NULL && get_tv_number(&di->di_tv))
+		sel_bufloaded = TRUE;
+
+	    di = dict_find(sel_d, (char_u *)"bufmodified", -1);
+	    if (di != NULL && get_tv_number(&di->di_tv))
+		sel_bufmodified = TRUE;
+	}
+    }
+    else if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	/* Information about one buffer.  Argument specifies the buffer */
+	(void)get_tv_number(&argvars[0]);   /* issue errmsg if type error */
+	++emsg_off;
+	argbuf = get_buf_tv(&argvars[0], FALSE);
+	--emsg_off;
+	if (argbuf == NULL)
+	    return;
+    }
+
+    /* Return information about all the buffers or a specified buffer */
+    FOR_ALL_BUFFERS(buf)
+    {
+	if (argbuf != NULL && argbuf != buf)
+	    continue;
+	if (filtered && ((sel_bufloaded && buf->b_ml.ml_mfp == NULL)
+			|| (sel_buflisted && !buf->b_p_bl)
+			|| (sel_bufmodified && !buf->b_changed)))
+	    continue;
+
+	d = get_buffer_info(buf);
+	if (d != NULL)
+	    list_append_dict(rettv->vval.v_list, d);
+	if (argbuf != NULL)
+	    return;
+    }
+}
+
+static void get_buffer_lines(buf_T *buf, linenr_T start, linenr_T end, int retlist, typval_T *rettv);
+
+/*
+ * Get line or list of lines from buffer "buf" into "rettv".
+ * Return a range (from start to end) of lines in rettv from the specified
+ * buffer.
+ * If 'retlist' is TRUE, then the lines are returned as a Vim List.
+ */
+    static void
+get_buffer_lines(
+    buf_T	*buf,
+    linenr_T	start,
+    linenr_T	end,
+    int		retlist,
+    typval_T	*rettv)
+{
+    char_u	*p;
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+    if (retlist && rettv_list_alloc(rettv) == FAIL)
+	return;
+
+    if (buf == NULL || buf->b_ml.ml_mfp == NULL || start < 0)
+	return;
+
+    if (!retlist)
+    {
+	if (start >= 1 && start <= buf->b_ml.ml_line_count)
+	    p = ml_get_buf(buf, start, FALSE);
+	else
+	    p = (char_u *)"";
+	rettv->vval.v_string = vim_strsave(p);
+    }
+    else
+    {
+	if (end < start)
+	    return;
+
+	if (start < 1)
+	    start = 1;
+	if (end > buf->b_ml.ml_line_count)
+	    end = buf->b_ml.ml_line_count;
+	while (start <= end)
+	    if (list_append_string(rettv->vval.v_list,
+				 ml_get_buf(buf, start++, FALSE), -1) == FAIL)
+		break;
+    }
+}
+
+/*
+ * "getbufline()" function
+ */
+    static void
+f_getbufline(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum;
+    linenr_T	end;
+    buf_T	*buf;
+
+    (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
+    ++emsg_off;
+    buf = get_buf_tv(&argvars[0], FALSE);
+    --emsg_off;
+
+    lnum = get_tv_lnum_buf(&argvars[1], buf);
+    if (argvars[2].v_type == VAR_UNKNOWN)
+	end = lnum;
+    else
+	end = get_tv_lnum_buf(&argvars[2], buf);
+
+    get_buffer_lines(buf, lnum, end, TRUE, rettv);
+}
+
+/*
+ * "getbufvar()" function
+ */
+    static void
+f_getbufvar(typval_T *argvars, typval_T *rettv)
+{
+    buf_T	*buf;
+    buf_T	*save_curbuf;
+    char_u	*varname;
+    dictitem_T	*v;
+    int		done = FALSE;
+
+    (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
+    varname = get_tv_string_chk(&argvars[1]);
+    ++emsg_off;
+    buf = get_buf_tv(&argvars[0], FALSE);
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+
+    if (buf != NULL && varname != NULL)
+    {
+	/* set curbuf to be our buf, temporarily */
+	save_curbuf = curbuf;
+	curbuf = buf;
+
+	if (*varname == '&')
+	{
+	    if (varname[1] == NUL)
+	    {
+		/* get all buffer-local options in a dict */
+		dict_T	*opts = get_winbuf_options(TRUE);
+
+		if (opts != NULL)
+		{
+		    rettv_dict_set(rettv, opts);
+		    done = TRUE;
+		}
+	    }
+	    else if (get_option_tv(&varname, rettv, TRUE) == OK)
+		/* buffer-local-option */
+		done = TRUE;
+	}
+	else
+	{
+	    /* Look up the variable. */
+	    /* Let getbufvar({nr}, "") return the "b:" dictionary. */
+	    v = find_var_in_ht(&curbuf->b_vars->dv_hashtab,
+							 'b', varname, FALSE);
+	    if (v != NULL)
+	    {
+		copy_tv(&v->di_tv, rettv);
+		done = TRUE;
+	    }
+	}
+
+	/* restore previous notion of curbuf */
+	curbuf = save_curbuf;
+    }
+
+    if (!done && argvars[2].v_type != VAR_UNKNOWN)
+	/* use the default value */
+	copy_tv(&argvars[2], rettv);
+
+    --emsg_off;
+}
+
+/*
+ * "getchangelist()" function
+ */
+    static void
+f_getchangelist(typval_T *argvars, typval_T *rettv)
+{
+#ifdef FEAT_JUMPLIST
+    buf_T	*buf;
+    int		i;
+    list_T	*l;
+    dict_T	*d;
+#endif
+
+    if (rettv_list_alloc(rettv) != OK)
+	return;
+
+#ifdef FEAT_JUMPLIST
+    (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
+    ++emsg_off;
+    buf = get_buf_tv(&argvars[0], FALSE);
+    --emsg_off;
+    if (buf == NULL)
+	return;
+
+    l = list_alloc();
+    if (l == NULL)
+	return;
+
+    if (list_append_list(rettv->vval.v_list, l) == FAIL)
+	return;
+    /*
+     * The current window change list index tracks only the position in the
+     * current buffer change list. For other buffers, use the change list
+     * length as the current index.
+     */
+    list_append_number(rettv->vval.v_list,
+	    (varnumber_T)((buf == curwin->w_buffer)
+		? curwin->w_changelistidx : buf->b_changelistlen));
+
+    for (i = 0; i < buf->b_changelistlen; ++i)
+    {
+	if (buf->b_changelist[i].lnum == 0)
+	    continue;
+	if ((d = dict_alloc()) == NULL)
+	    return;
+	if (list_append_dict(l, d) == FAIL)
+	    return;
+	dict_add_number(d, "lnum", (long)buf->b_changelist[i].lnum);
+	dict_add_number(d, "col", (long)buf->b_changelist[i].col);
+# ifdef FEAT_VIRTUALEDIT
+	dict_add_number(d, "coladd", (long)buf->b_changelist[i].coladd);
+# endif
+    }
+#endif
+}
+/*
+ * "getchar()" function
+ */
+    static void
+f_getchar(typval_T *argvars, typval_T *rettv)
+{
+    varnumber_T		n;
+    int			error = FALSE;
+
+    /* Position the cursor.  Needed after a message that ends in a space. */
+    windgoto(msg_row, msg_col);
+
+    ++no_mapping;
+    ++allow_keys;
+    for (;;)
+    {
+	if (argvars[0].v_type == VAR_UNKNOWN)
+	    /* getchar(): blocking wait. */
+	    n = plain_vgetc();
+	else if (get_tv_number_chk(&argvars[0], &error) == 1)
+	    /* getchar(1): only check if char avail */
+	    n = vpeekc_any();
+	else if (error || vpeekc_any() == NUL)
+	    /* illegal argument or getchar(0) and no char avail: return zero */
+	    n = 0;
+	else
+	    /* getchar(0) and char avail: return char */
+	    n = plain_vgetc();
+
+	if (n == K_IGNORE)
+	    continue;
+	break;
+    }
+    --no_mapping;
+    --allow_keys;
+
+    set_vim_var_nr(VV_MOUSE_WIN, 0);
+    set_vim_var_nr(VV_MOUSE_WINID, 0);
+    set_vim_var_nr(VV_MOUSE_LNUM, 0);
+    set_vim_var_nr(VV_MOUSE_COL, 0);
+
+    rettv->vval.v_number = n;
+    if (IS_SPECIAL(n) || mod_mask != 0)
+    {
+	char_u		temp[10];   /* modifier: 3, mbyte-char: 6, NUL: 1 */
+	int		i = 0;
+
+	/* Turn a special key into three bytes, plus modifier. */
+	if (mod_mask != 0)
+	{
+	    temp[i++] = K_SPECIAL;
+	    temp[i++] = KS_MODIFIER;
+	    temp[i++] = mod_mask;
+	}
+	if (IS_SPECIAL(n))
+	{
+	    temp[i++] = K_SPECIAL;
+	    temp[i++] = K_SECOND(n);
+	    temp[i++] = K_THIRD(n);
+	}
+#ifdef FEAT_MBYTE
+	else if (has_mbyte)
+	    i += (*mb_char2bytes)(n, temp + i);
+#endif
+	else
+	    temp[i++] = n;
+	temp[i++] = NUL;
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = vim_strsave(temp);
+
+#ifdef FEAT_MOUSE
+	if (is_mouse_key(n))
+	{
+	    int		row = mouse_row;
+	    int		col = mouse_col;
+	    win_T	*win;
+	    linenr_T	lnum;
+	    win_T	*wp;
+	    int		winnr = 1;
+
+	    if (row >= 0 && col >= 0)
+	    {
+		/* Find the window at the mouse coordinates and compute the
+		 * text position. */
+		win = mouse_find_win(&row, &col);
+		if (win == NULL)
+		    return;
+		(void)mouse_comp_pos(win, &row, &col, &lnum);
+		for (wp = firstwin; wp != win; wp = wp->w_next)
+		    ++winnr;
+		set_vim_var_nr(VV_MOUSE_WIN, winnr);
+		set_vim_var_nr(VV_MOUSE_WINID, win->w_id);
+		set_vim_var_nr(VV_MOUSE_LNUM, lnum);
+		set_vim_var_nr(VV_MOUSE_COL, col + 1);
+	    }
+	}
+#endif
+    }
+}
+
+/*
+ * "getcharmod()" function
+ */
+    static void
+f_getcharmod(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = mod_mask;
+}
+
+/*
+ * "getcharsearch()" function
+ */
+    static void
+f_getcharsearch(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    if (rettv_dict_alloc(rettv) != FAIL)
+    {
+	dict_T *dict = rettv->vval.v_dict;
+
+	dict_add_string(dict, "char", last_csearch());
+	dict_add_number(dict, "forward", last_csearch_forward());
+	dict_add_number(dict, "until", last_csearch_until());
+    }
+}
+
+/*
+ * "getcmdline()" function
+ */
+    static void
+f_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = get_cmdline_str();
+}
+
+/*
+ * "getcmdpos()" function
+ */
+    static void
+f_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = get_cmdline_pos() + 1;
+}
+
+/*
+ * "getcmdtype()" function
+ */
+    static void
+f_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = alloc(2);
+    if (rettv->vval.v_string != NULL)
+    {
+	rettv->vval.v_string[0] = get_cmdline_type();
+	rettv->vval.v_string[1] = NUL;
+    }
+}
+
+/*
+ * "getcmdwintype()" function
+ */
+    static void
+f_getcmdwintype(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_CMDWIN
+    rettv->vval.v_string = alloc(2);
+    if (rettv->vval.v_string != NULL)
+    {
+	rettv->vval.v_string[0] = cmdwin_type;
+	rettv->vval.v_string[1] = NUL;
+    }
+#endif
+}
+
+#if defined(FEAT_CMDL_COMPL)
+/*
+ * "getcompletion()" function
+ */
+    static void
+f_getcompletion(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*pat;
+    expand_T	xpc;
+    int		filtered = FALSE;
+    int		options = WILD_SILENT | WILD_USE_NL | WILD_ADD_SLASH
+					| WILD_NO_BEEP;
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+	filtered = get_tv_number_chk(&argvars[2], NULL);
+
+    if (p_wic)
+	options |= WILD_ICASE;
+
+    /* For filtered results, 'wildignore' is used */
+    if (!filtered)
+	options |= WILD_KEEP_ALL;
+
+    ExpandInit(&xpc);
+    xpc.xp_pattern = get_tv_string(&argvars[0]);
+    xpc.xp_pattern_len = (int)STRLEN(xpc.xp_pattern);
+    xpc.xp_context = cmdcomplete_str_to_type(get_tv_string(&argvars[1]));
+    if (xpc.xp_context == EXPAND_NOTHING)
+    {
+	if (argvars[1].v_type == VAR_STRING)
+	    EMSG2(_(e_invarg2), argvars[1].vval.v_string);
+	else
+	    EMSG(_(e_invarg));
+	return;
+    }
+
+# if defined(FEAT_MENU)
+    if (xpc.xp_context == EXPAND_MENUS)
+    {
+	set_context_in_menu_cmd(&xpc, (char_u *)"menu", xpc.xp_pattern, FALSE);
+	xpc.xp_pattern_len = (int)STRLEN(xpc.xp_pattern);
+    }
+# endif
+#ifdef FEAT_CSCOPE
+    if (xpc.xp_context == EXPAND_CSCOPE)
+    {
+	set_context_in_cscope_cmd(&xpc, xpc.xp_pattern, CMD_cscope);
+	xpc.xp_pattern_len = (int)STRLEN(xpc.xp_pattern);
+    }
+#endif
+#ifdef FEAT_SIGNS
+    if (xpc.xp_context == EXPAND_SIGN)
+    {
+	set_context_in_sign_cmd(&xpc, xpc.xp_pattern);
+	xpc.xp_pattern_len = (int)STRLEN(xpc.xp_pattern);
+    }
+#endif
+
+    pat = addstar(xpc.xp_pattern, xpc.xp_pattern_len, xpc.xp_context);
+    if ((rettv_list_alloc(rettv) != FAIL) && (pat != NULL))
+    {
+	int	i;
+
+	ExpandOne(&xpc, pat, NULL, options, WILD_ALL_KEEP);
+
+	for (i = 0; i < xpc.xp_numfiles; i++)
+	    list_append_string(rettv->vval.v_list, xpc.xp_files[i], -1);
+    }
+    vim_free(pat);
+    ExpandCleanup(&xpc);
+}
+#endif
+
+/*
+ * "getcwd()" function
+ */
+    static void
+f_getcwd(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*wp = NULL;
+    char_u	*cwd;
+    int		global = FALSE;
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+
+    if (argvars[0].v_type == VAR_NUMBER && argvars[0].vval.v_number == -1)
+	global = TRUE;
+    else
+	wp = find_tabwin(&argvars[0], &argvars[1]);
+
+    if (wp != NULL && wp->w_localdir != NULL)
+	rettv->vval.v_string = vim_strsave(wp->w_localdir);
+    else if (wp != NULL || global)
+    {
+	if (globaldir != NULL)
+	    rettv->vval.v_string = vim_strsave(globaldir);
+	else
+	{
+	    cwd = alloc(MAXPATHL);
+	    if (cwd != NULL)
+	    {
+		if (mch_dirname(cwd, MAXPATHL) != FAIL)
+		    rettv->vval.v_string = vim_strsave(cwd);
+		vim_free(cwd);
+	    }
+	}
+    }
+#ifdef BACKSLASH_IN_FILENAME
+    if (rettv->vval.v_string != NULL)
+	slash_adjust(rettv->vval.v_string);
+#endif
+}
+
+/*
+ * "getfontname()" function
+ */
+    static void
+f_getfontname(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_GUI
+    if (gui.in_use)
+    {
+	GuiFont font;
+	char_u	*name = NULL;
+
+	if (argvars[0].v_type == VAR_UNKNOWN)
+	{
+	    /* Get the "Normal" font.  Either the name saved by
+	     * hl_set_font_name() or from the font ID. */
+	    font = gui.norm_font;
+	    name = hl_get_font_name();
+	}
+	else
+	{
+	    name = get_tv_string(&argvars[0]);
+	    if (STRCMP(name, "*") == 0)	    /* don't use font dialog */
+		return;
+	    font = gui_mch_get_font(name, FALSE);
+	    if (font == NOFONT)
+		return;	    /* Invalid font name, return empty string. */
+	}
+	rettv->vval.v_string = gui_mch_get_fontname(font, name);
+	if (argvars[0].v_type != VAR_UNKNOWN)
+	    gui_mch_free_font(font);
+    }
+#endif
+}
+
+/*
+ * "getfperm({fname})" function
+ */
+    static void
+f_getfperm(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*fname;
+    stat_T	st;
+    char_u	*perm = NULL;
+    char_u	flags[] = "rwx";
+    int		i;
+
+    fname = get_tv_string(&argvars[0]);
+
+    rettv->v_type = VAR_STRING;
+    if (mch_stat((char *)fname, &st) >= 0)
+    {
+	perm = vim_strsave((char_u *)"---------");
+	if (perm != NULL)
+	{
+	    for (i = 0; i < 9; i++)
+	    {
+		if (st.st_mode & (1 << (8 - i)))
+		    perm[i] = flags[i % 3];
+	    }
+	}
+    }
+    rettv->vval.v_string = perm;
+}
+
+/*
+ * "getfsize({fname})" function
+ */
+    static void
+f_getfsize(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*fname;
+    stat_T	st;
+
+    fname = get_tv_string(&argvars[0]);
+
+    rettv->v_type = VAR_NUMBER;
+
+    if (mch_stat((char *)fname, &st) >= 0)
+    {
+	if (mch_isdir(fname))
+	    rettv->vval.v_number = 0;
+	else
+	{
+	    rettv->vval.v_number = (varnumber_T)st.st_size;
+
+	    /* non-perfect check for overflow */
+	    if ((off_T)rettv->vval.v_number != (off_T)st.st_size)
+		rettv->vval.v_number = -2;
+	}
+    }
+    else
+	  rettv->vval.v_number = -1;
+}
+
+/*
+ * "getftime({fname})" function
+ */
+    static void
+f_getftime(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*fname;
+    stat_T	st;
+
+    fname = get_tv_string(&argvars[0]);
+
+    if (mch_stat((char *)fname, &st) >= 0)
+	rettv->vval.v_number = (varnumber_T)st.st_mtime;
+    else
+	rettv->vval.v_number = -1;
+}
+
+/*
+ * "getftype({fname})" function
+ */
+    static void
+f_getftype(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*fname;
+    stat_T	st;
+    char_u	*type = NULL;
+    char	*t;
+
+    fname = get_tv_string(&argvars[0]);
+
+    rettv->v_type = VAR_STRING;
+    if (mch_lstat((char *)fname, &st) >= 0)
+    {
+	if (S_ISREG(st.st_mode))
+	    t = "file";
+	else if (S_ISDIR(st.st_mode))
+	    t = "dir";
+	else if (S_ISLNK(st.st_mode))
+	    t = "link";
+	else if (S_ISBLK(st.st_mode))
+	    t = "bdev";
+	else if (S_ISCHR(st.st_mode))
+	    t = "cdev";
+	else if (S_ISFIFO(st.st_mode))
+	    t = "fifo";
+	else if (S_ISSOCK(st.st_mode))
+	    t = "socket";
+	else
+	    t = "other";
+	type = vim_strsave((char_u *)t);
+    }
+    rettv->vval.v_string = type;
+}
+
+/*
+ * "getjumplist()" function
+ */
+    static void
+f_getjumplist(typval_T *argvars, typval_T *rettv)
+{
+#ifdef FEAT_JUMPLIST
+    win_T	*wp;
+    int		i;
+    list_T	*l;
+    dict_T	*d;
+#endif
+
+    if (rettv_list_alloc(rettv) != OK)
+	return;
+
+#ifdef FEAT_JUMPLIST
+    wp = find_tabwin(&argvars[0], &argvars[1]);
+    if (wp == NULL)
+	return;
+
+    l = list_alloc();
+    if (l == NULL)
+	return;
+
+    if (list_append_list(rettv->vval.v_list, l) == FAIL)
+	return;
+    list_append_number(rettv->vval.v_list, (varnumber_T)wp->w_jumplistidx);
+
+    cleanup_jumplist(wp, TRUE);
+
+    for (i = 0; i < wp->w_jumplistlen; ++i)
+    {
+	if (wp->w_jumplist[i].fmark.mark.lnum == 0)
+	    continue;
+	if ((d = dict_alloc()) == NULL)
+	    return;
+	if (list_append_dict(l, d) == FAIL)
+	    return;
+	dict_add_number(d, "lnum", (long)wp->w_jumplist[i].fmark.mark.lnum);
+	dict_add_number(d, "col", (long)wp->w_jumplist[i].fmark.mark.col);
+# ifdef FEAT_VIRTUALEDIT
+	dict_add_number(d, "coladd", (long)wp->w_jumplist[i].fmark.mark.coladd);
+# endif
+	dict_add_number(d, "bufnr", (long)wp->w_jumplist[i].fmark.fnum);
+	if (wp->w_jumplist[i].fname != NULL)
+	    dict_add_string(d, "filename", wp->w_jumplist[i].fname);
+    }
+#endif
+}
+
+/*
+ * "getline(lnum, [end])" function
+ */
+    static void
+f_getline(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum;
+    linenr_T	end;
+    int		retlist;
+
+    lnum = get_tv_lnum(argvars);
+    if (argvars[1].v_type == VAR_UNKNOWN)
+    {
+	end = 0;
+	retlist = FALSE;
+    }
+    else
+    {
+	end = get_tv_lnum(&argvars[1]);
+	retlist = TRUE;
+    }
+
+    get_buffer_lines(curbuf, lnum, end, retlist, rettv);
+}
+
+#ifdef FEAT_QUICKFIX
+    static void
+get_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv)
+{
+    if (what_arg->v_type == VAR_UNKNOWN)
+    {
+	if (rettv_list_alloc(rettv) == OK)
+	    if (is_qf || wp != NULL)
+		(void)get_errorlist(NULL, wp, -1, rettv->vval.v_list);
+    }
+    else
+    {
+	if (rettv_dict_alloc(rettv) == OK)
+	    if (is_qf || (wp != NULL))
+	    {
+		if (what_arg->v_type == VAR_DICT)
+		{
+		    dict_T	*d = what_arg->vval.v_dict;
+
+		    if (d != NULL)
+			qf_get_properties(wp, d, rettv->vval.v_dict);
+		}
+		else
+		    EMSG(_(e_dictreq));
+	    }
+    }
+}
+#endif
+
+/*
+ * "getloclist()" function
+ */
+    static void
+f_getloclist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_QUICKFIX
+    win_T	*wp;
+
+    wp = find_win_by_nr(&argvars[0], NULL);
+    get_qf_loc_list(FALSE, wp, &argvars[1], rettv);
+#endif
+}
+
+/*
+ * "getmatches()" function
+ */
+    static void
+f_getmatches(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_SEARCH_EXTRA
+    dict_T	*dict;
+    matchitem_T	*cur = curwin->w_match_head;
+    int		i;
+
+    if (rettv_list_alloc(rettv) == OK)
+    {
+	while (cur != NULL)
+	{
+	    dict = dict_alloc();
+	    if (dict == NULL)
+		return;
+	    if (cur->match.regprog == NULL)
+	    {
+		/* match added with matchaddpos() */
+		for (i = 0; i < MAXPOSMATCH; ++i)
+		{
+		    llpos_T	*llpos;
+		    char	buf[6];
+		    list_T	*l;
+
+		    llpos = &cur->pos.pos[i];
+		    if (llpos->lnum == 0)
+			break;
+		    l = list_alloc();
+		    if (l == NULL)
+			break;
+		    list_append_number(l, (varnumber_T)llpos->lnum);
+		    if (llpos->col > 0)
+		    {
+			list_append_number(l, (varnumber_T)llpos->col);
+			list_append_number(l, (varnumber_T)llpos->len);
+		    }
+		    sprintf(buf, "pos%d", i + 1);
+		    dict_add_list(dict, buf, l);
+		}
+	    }
+	    else
+	    {
+		dict_add_string(dict, "pattern", cur->pattern);
+	    }
+	    dict_add_string(dict, "group", syn_id2name(cur->hlg_id));
+	    dict_add_number(dict, "priority", (long)cur->priority);
+	    dict_add_number(dict, "id", (long)cur->id);
+# if defined(FEAT_CONCEAL) && defined(FEAT_MBYTE)
+	    if (cur->conceal_char)
+	    {
+		char_u buf[MB_MAXBYTES + 1];
+
+		buf[(*mb_char2bytes)((int)cur->conceal_char, buf)] = NUL;
+		dict_add_string(dict, "conceal", (char_u *)&buf);
+	    }
+# endif
+	    list_append_dict(rettv->vval.v_list, dict);
+	    cur = cur->next;
+	}
+    }
+#endif
+}
+
+/*
+ * "getpid()" function
+ */
+    static void
+f_getpid(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = mch_get_pid();
+}
+
+    static void
+getpos_both(
+    typval_T	*argvars,
+    typval_T	*rettv,
+    int		getcurpos)
+{
+    pos_T	*fp;
+    list_T	*l;
+    int		fnum = -1;
+
+    if (rettv_list_alloc(rettv) == OK)
+    {
+	l = rettv->vval.v_list;
+	if (getcurpos)
+	    fp = &curwin->w_cursor;
+	else
+	    fp = var2fpos(&argvars[0], TRUE, &fnum);
+	if (fnum != -1)
+	    list_append_number(l, (varnumber_T)fnum);
+	else
+	    list_append_number(l, (varnumber_T)0);
+	list_append_number(l, (fp != NULL) ? (varnumber_T)fp->lnum
+							    : (varnumber_T)0);
+	list_append_number(l, (fp != NULL)
+		     ? (varnumber_T)(fp->col == MAXCOL ? MAXCOL : fp->col + 1)
+							    : (varnumber_T)0);
+	list_append_number(l,
+#ifdef FEAT_VIRTUALEDIT
+				(fp != NULL) ? (varnumber_T)fp->coladd :
+#endif
+							      (varnumber_T)0);
+	if (getcurpos)
+	{
+	    update_curswant();
+	    list_append_number(l, curwin->w_curswant == MAXCOL ?
+		    (varnumber_T)MAXCOL : (varnumber_T)curwin->w_curswant + 1);
+	}
+    }
+    else
+	rettv->vval.v_number = FALSE;
+}
+
+
+/*
+ * "getcurpos()" function
+ */
+    static void
+f_getcurpos(typval_T *argvars, typval_T *rettv)
+{
+    getpos_both(argvars, rettv, TRUE);
+}
+
+/*
+ * "getpos(string)" function
+ */
+    static void
+f_getpos(typval_T *argvars, typval_T *rettv)
+{
+    getpos_both(argvars, rettv, FALSE);
+}
+
+/*
+ * "getqflist()" function
+ */
+    static void
+f_getqflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_QUICKFIX
+    get_qf_loc_list(TRUE, NULL, &argvars[0], rettv);
+#endif
+}
+
+/*
+ * "getreg()" function
+ */
+    static void
+f_getreg(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*strregname;
+    int		regname;
+    int		arg2 = FALSE;
+    int		return_list = FALSE;
+    int		error = FALSE;
+
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	strregname = get_tv_string_chk(&argvars[0]);
+	error = strregname == NULL;
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	{
+	    arg2 = (int)get_tv_number_chk(&argvars[1], &error);
+	    if (!error && argvars[2].v_type != VAR_UNKNOWN)
+		return_list = (int)get_tv_number_chk(&argvars[2], &error);
+	}
+    }
+    else
+	strregname = get_vim_var_str(VV_REG);
+
+    if (error)
+	return;
+
+    regname = (strregname == NULL ? '"' : *strregname);
+    if (regname == 0)
+	regname = '"';
+
+    if (return_list)
+    {
+	rettv->v_type = VAR_LIST;
+	rettv->vval.v_list = (list_T *)get_reg_contents(regname,
+				      (arg2 ? GREG_EXPR_SRC : 0) | GREG_LIST);
+	if (rettv->vval.v_list == NULL)
+	    (void)rettv_list_alloc(rettv);
+	else
+	    ++rettv->vval.v_list->lv_refcount;
+    }
+    else
+    {
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = get_reg_contents(regname,
+						    arg2 ? GREG_EXPR_SRC : 0);
+    }
+}
+
+/*
+ * "getregtype()" function
+ */
+    static void
+f_getregtype(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*strregname;
+    int		regname;
+    char_u	buf[NUMBUFLEN + 2];
+    long	reglen = 0;
+
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	strregname = get_tv_string_chk(&argvars[0]);
+	if (strregname == NULL)	    /* type error; errmsg already given */
+	{
+	    rettv->v_type = VAR_STRING;
+	    rettv->vval.v_string = NULL;
+	    return;
+	}
+    }
+    else
+	/* Default to v:register */
+	strregname = get_vim_var_str(VV_REG);
+
+    regname = (strregname == NULL ? '"' : *strregname);
+    if (regname == 0)
+	regname = '"';
+
+    buf[0] = NUL;
+    buf[1] = NUL;
+    switch (get_reg_type(regname, &reglen))
+    {
+	case MLINE: buf[0] = 'V'; break;
+	case MCHAR: buf[0] = 'v'; break;
+	case MBLOCK:
+		buf[0] = Ctrl_V;
+		sprintf((char *)buf + 1, "%ld", reglen + 1);
+		break;
+    }
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = vim_strsave(buf);
+}
+
+/*
+ * Returns information (variables, options, etc.) about a tab page
+ * as a dictionary.
+ */
+    static dict_T *
+get_tabpage_info(tabpage_T *tp, int tp_idx)
+{
+    win_T	*wp;
+    dict_T	*dict;
+    list_T	*l;
+
+    dict = dict_alloc();
+    if (dict == NULL)
+	return NULL;
+
+    dict_add_number(dict, "tabnr", tp_idx);
+
+    l = list_alloc();
+    if (l != NULL)
+    {
+	for (wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
+		wp; wp = wp->w_next)
+	    list_append_number(l, (varnumber_T)wp->w_id);
+	dict_add_list(dict, "windows", l);
+    }
+
+    /* Make a reference to tabpage variables */
+    dict_add_dict(dict, "variables", tp->tp_vars);
+
+    return dict;
+}
+
+/*
+ * "gettabinfo()" function
+ */
+    static void
+f_gettabinfo(typval_T *argvars, typval_T *rettv)
+{
+    tabpage_T	*tp, *tparg = NULL;
+    dict_T	*d;
+    int		tpnr = 0;
+
+    if (rettv_list_alloc(rettv) != OK)
+	return;
+
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	/* Information about one tab page */
+	tparg = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
+	if (tparg == NULL)
+	    return;
+    }
+
+    /* Get information about a specific tab page or all tab pages */
+    FOR_ALL_TABPAGES(tp)
+    {
+	tpnr++;
+	if (tparg != NULL && tp != tparg)
+	    continue;
+	d = get_tabpage_info(tp, tpnr);
+	if (d != NULL)
+	    list_append_dict(rettv->vval.v_list, d);
+	if (tparg != NULL)
+	    return;
+    }
+}
+
+/*
+ * "gettabvar()" function
+ */
+    static void
+f_gettabvar(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*oldcurwin;
+    tabpage_T	*tp, *oldtabpage;
+    dictitem_T	*v;
+    char_u	*varname;
+    int		done = FALSE;
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+
+    varname = get_tv_string_chk(&argvars[1]);
+    tp = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
+    if (tp != NULL && varname != NULL)
+    {
+	/* Set tp to be our tabpage, temporarily.  Also set the window to the
+	 * first window in the tabpage, otherwise the window is not valid. */
+	if (switch_win(&oldcurwin, &oldtabpage,
+		tp == curtab || tp->tp_firstwin == NULL ? firstwin
+					    : tp->tp_firstwin, tp, TRUE) == OK)
+	{
+	    /* look up the variable */
+	    /* Let gettabvar({nr}, "") return the "t:" dictionary. */
+	    v = find_var_in_ht(&tp->tp_vars->dv_hashtab, 't', varname, FALSE);
+	    if (v != NULL)
+	    {
+		copy_tv(&v->di_tv, rettv);
+		done = TRUE;
+	    }
+	}
+
+	/* restore previous notion of curwin */
+	restore_win(oldcurwin, oldtabpage, TRUE);
+    }
+
+    if (!done && argvars[2].v_type != VAR_UNKNOWN)
+	copy_tv(&argvars[2], rettv);
+}
+
+/*
+ * "gettabwinvar()" function
+ */
+    static void
+f_gettabwinvar(typval_T *argvars, typval_T *rettv)
+{
+    getwinvar(argvars, rettv, 1);
+}
+
+/*
+ * Returns information about a window as a dictionary.
+ */
+    static dict_T *
+get_win_info(win_T *wp, short tpnr, short winnr)
+{
+    dict_T	*dict;
+
+    dict = dict_alloc();
+    if (dict == NULL)
+	return NULL;
+
+    dict_add_number(dict, "tabnr", tpnr);
+    dict_add_number(dict, "winnr", winnr);
+    dict_add_number(dict, "winid", wp->w_id);
+    dict_add_number(dict, "height", wp->w_height);
+    dict_add_number(dict, "winrow", wp->w_winrow + 1);
+#ifdef FEAT_MENU
+    dict_add_number(dict, "winbar", wp->w_winbar_height);
+#endif
+    dict_add_number(dict, "width", wp->w_width);
+    dict_add_number(dict, "wincol", wp->w_wincol + 1);
+    dict_add_number(dict, "bufnr", wp->w_buffer->b_fnum);
+
+#ifdef FEAT_TERMINAL
+    dict_add_number(dict, "terminal", bt_terminal(wp->w_buffer));
+#endif
+#ifdef FEAT_QUICKFIX
+    dict_add_number(dict, "quickfix", bt_quickfix(wp->w_buffer));
+    dict_add_number(dict, "loclist",
+		      (bt_quickfix(wp->w_buffer) && wp->w_llist_ref != NULL));
+#endif
+
+    /* Add a reference to window variables */
+    dict_add_dict(dict, "variables", wp->w_vars);
+
+    return dict;
+}
+
+/*
+ * "getwininfo()" function
+ */
+    static void
+f_getwininfo(typval_T *argvars, typval_T *rettv)
+{
+    tabpage_T	*tp;
+    win_T	*wp = NULL, *wparg = NULL;
+    dict_T	*d;
+    short	tabnr = 0, winnr;
+
+    if (rettv_list_alloc(rettv) != OK)
+	return;
+
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	wparg = win_id2wp(argvars);
+	if (wparg == NULL)
+	    return;
+    }
+
+    /* Collect information about either all the windows across all the tab
+     * pages or one particular window.
+     */
+    FOR_ALL_TABPAGES(tp)
+    {
+	tabnr++;
+	winnr = 0;
+	FOR_ALL_WINDOWS_IN_TAB(tp, wp)
+	{
+	    winnr++;
+	    if (wparg != NULL && wp != wparg)
+		continue;
+	    d = get_win_info(wp, tabnr, winnr);
+	    if (d != NULL)
+		list_append_dict(rettv->vval.v_list, d);
+	    if (wparg != NULL)
+		/* found information about a specific window */
+		return;
+	}
+    }
+}
+
+/*
+ * "win_findbuf()" function
+ */
+    static void
+f_win_findbuf(typval_T *argvars, typval_T *rettv)
+{
+    if (rettv_list_alloc(rettv) != FAIL)
+	win_findbuf(argvars, rettv->vval.v_list);
+}
+
+/*
+ * "win_getid()" function
+ */
+    static void
+f_win_getid(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = win_getid(argvars);
+}
+
+/*
+ * "win_gotoid()" function
+ */
+    static void
+f_win_gotoid(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = win_gotoid(argvars);
+}
+
+/*
+ * "win_id2tabwin()" function
+ */
+    static void
+f_win_id2tabwin(typval_T *argvars, typval_T *rettv)
+{
+    if (rettv_list_alloc(rettv) != FAIL)
+	win_id2tabwin(argvars, rettv->vval.v_list);
+}
+
+/*
+ * "win_id2win()" function
+ */
+    static void
+f_win_id2win(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = win_id2win(argvars);
+}
+
+/*
+ * "win_screenpos()" function
+ */
+    static void
+f_win_screenpos(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*wp;
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+
+    wp = find_win_by_nr(&argvars[0], NULL);
+    list_append_number(rettv->vval.v_list, wp == NULL ? 0 : wp->w_winrow + 1);
+    list_append_number(rettv->vval.v_list, wp == NULL ? 0 : wp->w_wincol + 1);
+}
+
+/*
+ * "getwinpos({timeout})" function
+ */
+    static void
+f_getwinpos(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int x = -1;
+    int y = -1;
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+#ifdef FEAT_GUI
+    if (gui.in_use)
+	(void)gui_mch_get_winpos(&x, &y);
+# if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
+    else
+# endif
+#endif
+#if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
+    {
+	varnumber_T timeout = 100;
+
+	if (argvars[0].v_type != VAR_UNKNOWN)
+	    timeout = get_tv_number(&argvars[0]);
+	term_get_winpos(&x, &y, timeout);
+    }
+#endif
+    list_append_number(rettv->vval.v_list, (varnumber_T)x);
+    list_append_number(rettv->vval.v_list, (varnumber_T)y);
+}
+
+
+/*
+ * "getwinposx()" function
+ */
+    static void
+f_getwinposx(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = -1;
+#ifdef FEAT_GUI
+    if (gui.in_use)
+    {
+	int	    x, y;
+
+	if (gui_mch_get_winpos(&x, &y) == OK)
+	    rettv->vval.v_number = x;
+	return;
+    }
+#endif
+#if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
+    {
+	int	    x, y;
+
+	if (term_get_winpos(&x, &y, (varnumber_T)100) == OK)
+	    rettv->vval.v_number = x;
+    }
+#endif
+}
+
+/*
+ * "getwinposy()" function
+ */
+    static void
+f_getwinposy(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = -1;
+#ifdef FEAT_GUI
+    if (gui.in_use)
+    {
+	int	    x, y;
+
+	if (gui_mch_get_winpos(&x, &y) == OK)
+	    rettv->vval.v_number = y;
+	return;
+    }
+#endif
+#if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
+    {
+	int	    x, y;
+
+	if (term_get_winpos(&x, &y, (varnumber_T)100) == OK)
+	    rettv->vval.v_number = y;
+    }
+#endif
+}
+
+/*
+ * "getwinvar()" function
+ */
+    static void
+f_getwinvar(typval_T *argvars, typval_T *rettv)
+{
+    getwinvar(argvars, rettv, 0);
+}
+
+/*
+ * "glob()" function
+ */
+    static void
+f_glob(typval_T *argvars, typval_T *rettv)
+{
+    int		options = WILD_SILENT|WILD_USE_NL;
+    expand_T	xpc;
+    int		error = FALSE;
+
+    /* When the optional second argument is non-zero, don't remove matches
+     * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    rettv->v_type = VAR_STRING;
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	if (get_tv_number_chk(&argvars[1], &error))
+	    options |= WILD_KEEP_ALL;
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
+	    if (get_tv_number_chk(&argvars[2], &error))
+	    {
+		rettv_list_set(rettv, NULL);
+	    }
+	    if (argvars[3].v_type != VAR_UNKNOWN
+				    && get_tv_number_chk(&argvars[3], &error))
+		options |= WILD_ALLLINKS;
+	}
+    }
+    if (!error)
+    {
+	ExpandInit(&xpc);
+	xpc.xp_context = EXPAND_FILES;
+	if (p_wic)
+	    options += WILD_ICASE;
+	if (rettv->v_type == VAR_STRING)
+	    rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
+						     NULL, options, WILD_ALL);
+	else if (rettv_list_alloc(rettv) != FAIL)
+	{
+	  int i;
+
+	  ExpandOne(&xpc, get_tv_string(&argvars[0]),
+						NULL, options, WILD_ALL_KEEP);
+	  for (i = 0; i < xpc.xp_numfiles; i++)
+	      list_append_string(rettv->vval.v_list, xpc.xp_files[i], -1);
+
+	  ExpandCleanup(&xpc);
+	}
+    }
+    else
+	rettv->vval.v_string = NULL;
+}
+
+/*
+ * "globpath()" function
+ */
+    static void
+f_globpath(typval_T *argvars, typval_T *rettv)
+{
+    int		flags = 0;
+    char_u	buf1[NUMBUFLEN];
+    char_u	*file = get_tv_string_buf_chk(&argvars[1], buf1);
+    int		error = FALSE;
+    garray_T	ga;
+    int		i;
+
+    /* When the optional second argument is non-zero, don't remove matches
+    * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    rettv->v_type = VAR_STRING;
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	if (get_tv_number_chk(&argvars[2], &error))
+	    flags |= WILD_KEEP_ALL;
+	if (argvars[3].v_type != VAR_UNKNOWN)
+	{
+	    if (get_tv_number_chk(&argvars[3], &error))
+	    {
+		rettv_list_set(rettv, NULL);
+	    }
+	    if (argvars[4].v_type != VAR_UNKNOWN
+				    && get_tv_number_chk(&argvars[4], &error))
+		flags |= WILD_ALLLINKS;
+	}
+    }
+    if (file != NULL && !error)
+    {
+	ga_init2(&ga, (int)sizeof(char_u *), 10);
+	globpath(get_tv_string(&argvars[0]), file, &ga, flags);
+	if (rettv->v_type == VAR_STRING)
+	    rettv->vval.v_string = ga_concat_strings(&ga, "\n");
+	else if (rettv_list_alloc(rettv) != FAIL)
+	    for (i = 0; i < ga.ga_len; ++i)
+		list_append_string(rettv->vval.v_list,
+					    ((char_u **)(ga.ga_data))[i], -1);
+	ga_clear_strings(&ga);
+    }
+    else
+	rettv->vval.v_string = NULL;
+}
+
+/*
+ * "glob2regpat()" function
+ */
+    static void
+f_glob2regpat(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*pat = get_tv_string_chk(&argvars[0]);
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = (pat == NULL)
+			 ? NULL : file_pat_to_reg_pat(pat, NULL, NULL, FALSE);
+}
+
+/* for VIM_VERSION_ defines */
+#include "version.h"
+
+/*
+ * "has()" function
+ */
+    static void
+f_has(typval_T *argvars, typval_T *rettv)
+{
+    int		i;
+    char_u	*name;
+    int		n = FALSE;
+    static char	*(has_list[]) =
+    {
+#ifdef AMIGA
+	"amiga",
+# ifdef FEAT_ARP
+	"arp",
+# endif
+#endif
+#ifdef __BEOS__
+	"beos",
+#endif
+#ifdef MACOS_X
+	"mac",		/* Mac OS X (and, once, Mac OS Classic) */
+	"osx",		/* Mac OS X */
+# ifdef MACOS_X_DARWIN
+	"macunix",	/* Mac OS X, with the darwin feature */
+	"osxdarwin",	/* synonym for macunix */
+# endif
+#endif
+#ifdef __QNX__
+	"qnx",
+#endif
+#ifdef UNIX
+	"unix",
+#endif
+#ifdef VMS
+	"vms",
+#endif
+#ifdef WIN32
+	"win32",
+#endif
+#if defined(UNIX) && (defined(__CYGWIN32__) || defined(__CYGWIN__))
+	"win32unix",
+#endif
+#if defined(WIN64) || defined(_WIN64)
+	"win64",
+#endif
+#ifdef EBCDIC
+	"ebcdic",
+#endif
+#ifndef CASE_INSENSITIVE_FILENAME
+	"fname_case",
+#endif
+#ifdef HAVE_ACL
+	"acl",
+#endif
+#ifdef FEAT_ARABIC
+	"arabic",
+#endif
+	"autocmd",
+#ifdef FEAT_AUTOCHDIR
+       "autochdir",
+#endif
+#ifdef FEAT_AUTOSERVERNAME
+	"autoservername",
+#endif
+#ifdef FEAT_BEVAL_GUI
+	"balloon_eval",
+# ifndef FEAT_GUI_W32 /* other GUIs always have multiline balloons */
+	"balloon_multiline",
+# endif
+#endif
+#ifdef FEAT_BEVAL_TERM
+	"balloon_eval_term",
+#endif
+#if defined(SOME_BUILTIN_TCAPS) || defined(ALL_BUILTIN_TCAPS)
+	"builtin_terms",
+# ifdef ALL_BUILTIN_TCAPS
+	"all_builtin_terms",
+# endif
+#endif
+#if defined(FEAT_BROWSE) && (defined(USE_FILE_CHOOSER) \
+	|| defined(FEAT_GUI_W32) \
+	|| defined(FEAT_GUI_MOTIF))
+	"browsefilter",
+#endif
+#ifdef FEAT_BYTEOFF
+	"byte_offset",
+#endif
+#ifdef FEAT_JOB_CHANNEL
+	"channel",
+#endif
+#ifdef FEAT_CINDENT
+	"cindent",
+#endif
+#ifdef FEAT_CLIENTSERVER
+	"clientserver",
+#endif
+#ifdef FEAT_CLIPBOARD
+	"clipboard",
+#endif
+#ifdef FEAT_CMDL_COMPL
+	"cmdline_compl",
+#endif
+#ifdef FEAT_CMDHIST
+	"cmdline_hist",
+#endif
+#ifdef FEAT_COMMENTS
+	"comments",
+#endif
+#ifdef FEAT_CONCEAL
+	"conceal",
+#endif
+#ifdef FEAT_CRYPT
+	"cryptv",
+	"crypt-blowfish",
+	"crypt-blowfish2",
+#endif
+#ifdef FEAT_CSCOPE
+	"cscope",
+#endif
+	"cursorbind",
+#ifdef CURSOR_SHAPE
+	"cursorshape",
+#endif
+#ifdef DEBUG
+	"debug",
+#endif
+#ifdef FEAT_CON_DIALOG
+	"dialog_con",
+#endif
+#ifdef FEAT_GUI_DIALOG
+	"dialog_gui",
+#endif
+#ifdef FEAT_DIFF
+	"diff",
+#endif
+#ifdef FEAT_DIGRAPHS
+	"digraphs",
+#endif
+#ifdef FEAT_DIRECTX
+	"directx",
+#endif
+#ifdef FEAT_DND
+	"dnd",
+#endif
+#ifdef FEAT_EMACS_TAGS
+	"emacs_tags",
+#endif
+	"eval",	    /* always present, of course! */
+	"ex_extra", /* graduated feature */
+#ifdef FEAT_SEARCH_EXTRA
+	"extra_search",
+#endif
+#ifdef FEAT_FKMAP
+	"farsi",
+#endif
+#ifdef FEAT_SEARCHPATH
+	"file_in_path",
+#endif
+#ifdef FEAT_FILTERPIPE
+	"filterpipe",
+#endif
+#ifdef FEAT_FIND_ID
+	"find_in_path",
+#endif
+#ifdef FEAT_FLOAT
+	"float",
+#endif
+#ifdef FEAT_FOLDING
+	"folding",
+#endif
+#ifdef FEAT_FOOTER
+	"footer",
+#endif
+#if !defined(USE_SYSTEM) && defined(UNIX)
+	"fork",
+#endif
+#ifdef FEAT_GETTEXT
+	"gettext",
+#endif
+#ifdef FEAT_GUI
+	"gui",
+#endif
+#ifdef FEAT_GUI_ATHENA
+# ifdef FEAT_GUI_NEXTAW
+	"gui_neXtaw",
+# else
+	"gui_athena",
+# endif
+#endif
+#ifdef FEAT_GUI_GTK
+	"gui_gtk",
+# ifdef USE_GTK3
+	"gui_gtk3",
+# else
+	"gui_gtk2",
+# endif
+#endif
+#ifdef FEAT_GUI_GNOME
+	"gui_gnome",
+#endif
+#ifdef FEAT_GUI_MAC
+	"gui_mac",
+#endif
+#ifdef FEAT_GUI_MOTIF
+	"gui_motif",
+#endif
+#ifdef FEAT_GUI_PHOTON
+	"gui_photon",
+#endif
+#ifdef FEAT_GUI_W32
+	"gui_win32",
+#endif
+#ifdef FEAT_HANGULIN
+	"hangul_input",
+#endif
+#if defined(HAVE_ICONV_H) && defined(USE_ICONV)
+	"iconv",
+#endif
+#ifdef FEAT_INS_EXPAND
+	"insert_expand",
+#endif
+#ifdef FEAT_JOB_CHANNEL
+	"job",
+#endif
+#ifdef FEAT_JUMPLIST
+	"jumplist",
+#endif
+#ifdef FEAT_KEYMAP
+	"keymap",
+#endif
+	"lambda", /* always with FEAT_EVAL, since 7.4.2120 with closure */
+#ifdef FEAT_LANGMAP
+	"langmap",
+#endif
+#ifdef FEAT_LIBCALL
+	"libcall",
+#endif
+#ifdef FEAT_LINEBREAK
+	"linebreak",
+#endif
+#ifdef FEAT_LISP
+	"lispindent",
+#endif
+	"listcmds",
+#ifdef FEAT_LOCALMAP
+	"localmap",
+#endif
+#ifdef FEAT_LUA
+# ifndef DYNAMIC_LUA
+	"lua",
+# endif
+#endif
+#ifdef FEAT_MENU
+	"menu",
+#endif
+#ifdef FEAT_SESSION
+	"mksession",
+#endif
+#ifdef FEAT_MODIFY_FNAME
+	"modify_fname",
+#endif
+#ifdef FEAT_MOUSE
+	"mouse",
+#endif
+#ifdef FEAT_MOUSESHAPE
+	"mouseshape",
+#endif
+#if defined(UNIX) || defined(VMS)
+# ifdef FEAT_MOUSE_DEC
+	"mouse_dec",
+# endif
+# ifdef FEAT_MOUSE_GPM
+	"mouse_gpm",
+# endif
+# ifdef FEAT_MOUSE_JSB
+	"mouse_jsbterm",
+# endif
+# ifdef FEAT_MOUSE_NET
+	"mouse_netterm",
+# endif
+# ifdef FEAT_MOUSE_PTERM
+	"mouse_pterm",
+# endif
+# ifdef FEAT_MOUSE_SGR
+	"mouse_sgr",
+# endif
+# ifdef FEAT_SYSMOUSE
+	"mouse_sysmouse",
+# endif
+# ifdef FEAT_MOUSE_URXVT
+	"mouse_urxvt",
+# endif
+# ifdef FEAT_MOUSE_XTERM
+	"mouse_xterm",
+# endif
+#endif
+#ifdef FEAT_MBYTE
+	"multi_byte",
+#endif
+#ifdef FEAT_MBYTE_IME
+	"multi_byte_ime",
+#endif
+#ifdef FEAT_MULTI_LANG
+	"multi_lang",
+#endif
+#ifdef FEAT_MZSCHEME
+#ifndef DYNAMIC_MZSCHEME
+	"mzscheme",
+#endif
+#endif
+#ifdef FEAT_NUM64
+	"num64",
+#endif
+#ifdef FEAT_OLE
+	"ole",
+#endif
+#ifdef FEAT_EVAL
+	"packages",
+#endif
+#ifdef FEAT_PATH_EXTRA
+	"path_extra",
+#endif
+#ifdef FEAT_PERL
+#ifndef DYNAMIC_PERL
+	"perl",
+#endif
+#endif
+#ifdef FEAT_PERSISTENT_UNDO
+	"persistent_undo",
+#endif
+#if defined(FEAT_PYTHON)
+	"python_compiled",
+# if defined(DYNAMIC_PYTHON)
+	"python_dynamic",
+# else
+	"python",
+	"pythonx",
+# endif
+#endif
+#if defined(FEAT_PYTHON3)
+	"python3_compiled",
+# if defined(DYNAMIC_PYTHON3)
+	"python3_dynamic",
+# else
+	"python3",
+	"pythonx",
+# endif
+#endif
+#ifdef FEAT_POSTSCRIPT
+	"postscript",
+#endif
+#ifdef FEAT_PRINTER
+	"printer",
+#endif
+#ifdef FEAT_PROFILE
+	"profile",
+#endif
+#ifdef FEAT_RELTIME
+	"reltime",
+#endif
+#ifdef FEAT_QUICKFIX
+	"quickfix",
+#endif
+#ifdef FEAT_RIGHTLEFT
+	"rightleft",
+#endif
+#if defined(FEAT_RUBY) && !defined(DYNAMIC_RUBY)
+	"ruby",
+#endif
+	"scrollbind",
+#ifdef FEAT_CMDL_INFO
+	"showcmd",
+	"cmdline_info",
+#endif
+#ifdef FEAT_SIGNS
+	"signs",
+#endif
+#ifdef FEAT_SMARTINDENT
+	"smartindent",
+#endif
+#ifdef STARTUPTIME
+	"startuptime",
+#endif
+#ifdef FEAT_STL_OPT
+	"statusline",
+#endif
+#ifdef FEAT_SUN_WORKSHOP
+	"sun_workshop",
+#endif
+#ifdef FEAT_NETBEANS_INTG
+	"netbeans_intg",
+#endif
+#ifdef FEAT_SPELL
+	"spell",
+#endif
+#ifdef FEAT_SYN_HL
+	"syntax",
+#endif
+#if defined(USE_SYSTEM) || !defined(UNIX)
+	"system",
+#endif
+#ifdef FEAT_TAG_BINS
+	"tag_binary",
+#endif
+#ifdef FEAT_TAG_OLDSTATIC
+	"tag_old_static",
+#endif
+#ifdef FEAT_TAG_ANYWHITE
+	"tag_any_white",
+#endif
+#ifdef FEAT_TCL
+# ifndef DYNAMIC_TCL
+	"tcl",
+# endif
+#endif
+#ifdef FEAT_TERMGUICOLORS
+	"termguicolors",
+#endif
+#if defined(FEAT_TERMINAL) && !defined(WIN3264)
+	"terminal",
+#endif
+#ifdef TERMINFO
+	"terminfo",
+#endif
+#ifdef FEAT_TERMRESPONSE
+	"termresponse",
+#endif
+#ifdef FEAT_TEXTOBJ
+	"textobjects",
+#endif
+#ifdef HAVE_TGETENT
+	"tgetent",
+#endif
+#ifdef FEAT_TIMERS
+	"timers",
+#endif
+#ifdef FEAT_TITLE
+	"title",
+#endif
+#ifdef FEAT_TOOLBAR
+	"toolbar",
+#endif
+#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+	"unnamedplus",
+#endif
+#ifdef FEAT_USR_CMDS
+	"user-commands",    /* was accidentally included in 5.4 */
+	"user_commands",
+#endif
+#ifdef FEAT_VARTABS
+	"vartabs",
+#endif
+#ifdef FEAT_VIMINFO
+	"viminfo",
+#endif
+	"vertsplit",
+#ifdef FEAT_VIRTUALEDIT
+	"virtualedit",
+#endif
+	"visual",
+#ifdef FEAT_VISUALEXTRA
+	"visualextra",
+#endif
+	"vreplace",
+#ifdef FEAT_VTP
+	"vtp",
+#endif
+#ifdef FEAT_WILDIGN
+	"wildignore",
+#endif
+#ifdef FEAT_WILDMENU
+	"wildmenu",
+#endif
+	"windows",
+#ifdef FEAT_WAK
+	"winaltkeys",
+#endif
+#ifdef FEAT_WRITEBACKUP
+	"writebackup",
+#endif
+#ifdef FEAT_XIM
+	"xim",
+#endif
+#ifdef FEAT_XFONTSET
+	"xfontset",
+#endif
+#ifdef FEAT_XPM_W32
+	"xpm",
+	"xpm_w32",	/* for backward compatibility */
+#else
+# if defined(HAVE_XPM)
+	"xpm",
+# endif
+#endif
+#ifdef USE_XSMP
+	"xsmp",
+#endif
+#ifdef USE_XSMP_INTERACT
+	"xsmp_interact",
+#endif
+#ifdef FEAT_XCLIPBOARD
+	"xterm_clipboard",
+#endif
+#ifdef FEAT_XTERM_SAVE
+	"xterm_save",
+#endif
+#if defined(UNIX) && defined(FEAT_X11)
+	"X11",
+#endif
+	NULL
+    };
+
+    name = get_tv_string(&argvars[0]);
+    for (i = 0; has_list[i] != NULL; ++i)
+	if (STRICMP(name, has_list[i]) == 0)
+	{
+	    n = TRUE;
+	    break;
+	}
+
+    if (n == FALSE)
+    {
+	if (STRNICMP(name, "patch", 5) == 0)
+	{
+	    if (name[5] == '-'
+		    && STRLEN(name) >= 11
+		    && vim_isdigit(name[6])
+		    && vim_isdigit(name[8])
+		    && vim_isdigit(name[10]))
+	    {
+		int major = atoi((char *)name + 6);
+		int minor = atoi((char *)name + 8);
+
+		/* Expect "patch-9.9.01234". */
+		n = (major < VIM_VERSION_MAJOR
+		     || (major == VIM_VERSION_MAJOR
+			 && (minor < VIM_VERSION_MINOR
+			     || (minor == VIM_VERSION_MINOR
+				 && has_patch(atoi((char *)name + 10))))));
+	    }
+	    else
+		n = has_patch(atoi((char *)name + 5));
+	}
+	else if (STRICMP(name, "vim_starting") == 0)
+	    n = (starting != 0);
+	else if (STRICMP(name, "ttyin") == 0)
+	    n = mch_input_isatty();
+	else if (STRICMP(name, "ttyout") == 0)
+	    n = stdout_isatty;
+#ifdef FEAT_MBYTE
+	else if (STRICMP(name, "multi_byte_encoding") == 0)
+	    n = has_mbyte;
+#endif
+#if defined(FEAT_BEVAL) && defined(FEAT_GUI_W32)
+	else if (STRICMP(name, "balloon_multiline") == 0)
+	    n = multiline_balloon_available();
+#endif
+#ifdef DYNAMIC_TCL
+	else if (STRICMP(name, "tcl") == 0)
+	    n = tcl_enabled(FALSE);
+#endif
+#if defined(USE_ICONV) && defined(DYNAMIC_ICONV)
+	else if (STRICMP(name, "iconv") == 0)
+	    n = iconv_enabled(FALSE);
+#endif
+#ifdef DYNAMIC_LUA
+	else if (STRICMP(name, "lua") == 0)
+	    n = lua_enabled(FALSE);
+#endif
+#ifdef DYNAMIC_MZSCHEME
+	else if (STRICMP(name, "mzscheme") == 0)
+	    n = mzscheme_enabled(FALSE);
+#endif
+#ifdef DYNAMIC_RUBY
+	else if (STRICMP(name, "ruby") == 0)
+	    n = ruby_enabled(FALSE);
+#endif
+#ifdef DYNAMIC_PYTHON
+	else if (STRICMP(name, "python") == 0)
+	    n = python_enabled(FALSE);
+#endif
+#ifdef DYNAMIC_PYTHON3
+	else if (STRICMP(name, "python3") == 0)
+	    n = python3_enabled(FALSE);
+#endif
+#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)
+	else if (STRICMP(name, "pythonx") == 0)
+	{
+# if defined(DYNAMIC_PYTHON) && defined(DYNAMIC_PYTHON3)
+	    if (p_pyx == 0)
+		n = python3_enabled(FALSE) || python_enabled(FALSE);
+	    else if (p_pyx == 3)
+		n = python3_enabled(FALSE);
+	    else if (p_pyx == 2)
+		n = python_enabled(FALSE);
+# elif defined(DYNAMIC_PYTHON)
+	    n = python_enabled(FALSE);
+# elif defined(DYNAMIC_PYTHON3)
+	    n = python3_enabled(FALSE);
+# endif
+	}
+#endif
+#ifdef DYNAMIC_PERL
+	else if (STRICMP(name, "perl") == 0)
+	    n = perl_enabled(FALSE);
+#endif
+#ifdef FEAT_GUI
+	else if (STRICMP(name, "gui_running") == 0)
+	    n = (gui.in_use || gui.starting);
+# ifdef FEAT_BROWSE
+	else if (STRICMP(name, "browse") == 0)
+	    n = gui.in_use;	/* gui_mch_browse() works when GUI is running */
+# endif
+#endif
+#ifdef FEAT_SYN_HL
+	else if (STRICMP(name, "syntax_items") == 0)
+	    n = syntax_present(curwin);
+#endif
+#ifdef FEAT_VTP
+	else if (STRICMP(name, "vcon") == 0)
+	    n = is_term_win32() && has_vtp_working();
+#endif
+#ifdef FEAT_NETBEANS_INTG
+	else if (STRICMP(name, "netbeans_enabled") == 0)
+	    n = netbeans_active();
+#endif
+#if defined(FEAT_TERMINAL) && defined(WIN3264)
+	else if (STRICMP(name, "terminal") == 0)
+	    n = terminal_enabled();
+#endif
+    }
+
+    rettv->vval.v_number = n;
+}
+
+/*
+ * "has_key()" function
+ */
+    static void
+f_has_key(typval_T *argvars, typval_T *rettv)
+{
+    if (argvars[0].v_type != VAR_DICT)
+    {
+	EMSG(_(e_dictreq));
+	return;
+    }
+    if (argvars[0].vval.v_dict == NULL)
+	return;
+
+    rettv->vval.v_number = dict_find(argvars[0].vval.v_dict,
+				      get_tv_string(&argvars[1]), -1) != NULL;
+}
+
+/*
+ * "haslocaldir()" function
+ */
+    static void
+f_haslocaldir(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*wp = NULL;
+
+    wp = find_tabwin(&argvars[0], &argvars[1]);
+    rettv->vval.v_number = (wp != NULL && wp->w_localdir != NULL);
+}
+
+/*
+ * "hasmapto()" function
+ */
+    static void
+f_hasmapto(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*name;
+    char_u	*mode;
+    char_u	buf[NUMBUFLEN];
+    int		abbr = FALSE;
+
+    name = get_tv_string(&argvars[0]);
+    if (argvars[1].v_type == VAR_UNKNOWN)
+	mode = (char_u *)"nvo";
+    else
+    {
+	mode = get_tv_string_buf(&argvars[1], buf);
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    abbr = (int)get_tv_number(&argvars[2]);
+    }
+
+    if (map_to_exists(name, mode, abbr))
+	rettv->vval.v_number = TRUE;
+    else
+	rettv->vval.v_number = FALSE;
+}
+
+/*
+ * "histadd()" function
+ */
+    static void
+f_histadd(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_CMDHIST
+    int		histype;
+    char_u	*str;
+    char_u	buf[NUMBUFLEN];
+#endif
+
+    rettv->vval.v_number = FALSE;
+    if (check_restricted() || check_secure())
+	return;
+#ifdef FEAT_CMDHIST
+    str = get_tv_string_chk(&argvars[0]);	/* NULL on type error */
+    histype = str != NULL ? get_histtype(str) : -1;
+    if (histype >= 0)
+    {
+	str = get_tv_string_buf(&argvars[1], buf);
+	if (*str != NUL)
+	{
+	    init_history();
+	    add_to_history(histype, str, FALSE, NUL);
+	    rettv->vval.v_number = TRUE;
+	    return;
+	}
+    }
+#endif
+}
+
+/*
+ * "histdel()" function
+ */
+    static void
+f_histdel(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_CMDHIST
+    int		n;
+    char_u	buf[NUMBUFLEN];
+    char_u	*str;
+
+    str = get_tv_string_chk(&argvars[0]);	/* NULL on type error */
+    if (str == NULL)
+	n = 0;
+    else if (argvars[1].v_type == VAR_UNKNOWN)
+	/* only one argument: clear entire history */
+	n = clr_history(get_histtype(str));
+    else if (argvars[1].v_type == VAR_NUMBER)
+	/* index given: remove that entry */
+	n = del_history_idx(get_histtype(str),
+					  (int)get_tv_number(&argvars[1]));
+    else
+	/* string given: remove all matching entries */
+	n = del_history_entry(get_histtype(str),
+				      get_tv_string_buf(&argvars[1], buf));
+    rettv->vval.v_number = n;
+#endif
+}
+
+/*
+ * "histget()" function
+ */
+    static void
+f_histget(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_CMDHIST
+    int		type;
+    int		idx;
+    char_u	*str;
+
+    str = get_tv_string_chk(&argvars[0]);	/* NULL on type error */
+    if (str == NULL)
+	rettv->vval.v_string = NULL;
+    else
+    {
+	type = get_histtype(str);
+	if (argvars[1].v_type == VAR_UNKNOWN)
+	    idx = get_history_idx(type);
+	else
+	    idx = (int)get_tv_number_chk(&argvars[1], NULL);
+						    /* -1 on type error */
+	rettv->vval.v_string = vim_strsave(get_history_entry(type, idx));
+    }
+#else
+    rettv->vval.v_string = NULL;
+#endif
+    rettv->v_type = VAR_STRING;
+}
+
+/*
+ * "histnr()" function
+ */
+    static void
+f_histnr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		i;
+
+#ifdef FEAT_CMDHIST
+    char_u	*history = get_tv_string_chk(&argvars[0]);
+
+    i = history == NULL ? HIST_CMD - 1 : get_histtype(history);
+    if (i >= HIST_CMD && i < HIST_COUNT)
+	i = get_history_idx(i);
+    else
+#endif
+	i = -1;
+    rettv->vval.v_number = i;
+}
+
+/*
+ * "highlightID(name)" function
+ */
+    static void
+f_hlID(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = syn_name2id(get_tv_string(&argvars[0]));
+}
+
+/*
+ * "highlight_exists()" function
+ */
+    static void
+f_hlexists(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = highlight_exists(get_tv_string(&argvars[0]));
+}
+
+/*
+ * "hostname()" function
+ */
+    static void
+f_hostname(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    char_u hostname[256];
+
+    mch_get_host_name(hostname, 256);
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = vim_strsave(hostname);
+}
+
+/*
+ * iconv() function
+ */
+    static void
+f_iconv(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_MBYTE
+    char_u	buf1[NUMBUFLEN];
+    char_u	buf2[NUMBUFLEN];
+    char_u	*from, *to, *str;
+    vimconv_T	vimconv;
+#endif
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+
+#ifdef FEAT_MBYTE
+    str = get_tv_string(&argvars[0]);
+    from = enc_canonize(enc_skip(get_tv_string_buf(&argvars[1], buf1)));
+    to = enc_canonize(enc_skip(get_tv_string_buf(&argvars[2], buf2)));
+    vimconv.vc_type = CONV_NONE;
+    convert_setup(&vimconv, from, to);
+
+    /* If the encodings are equal, no conversion needed. */
+    if (vimconv.vc_type == CONV_NONE)
+	rettv->vval.v_string = vim_strsave(str);
+    else
+	rettv->vval.v_string = string_convert(&vimconv, str, NULL);
+
+    convert_setup(&vimconv, NULL, NULL);
+    vim_free(from);
+    vim_free(to);
+#endif
+}
+
+/*
+ * "indent()" function
+ */
+    static void
+f_indent(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum;
+
+    lnum = get_tv_lnum(argvars);
+    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
+	rettv->vval.v_number = get_indent_lnum(lnum);
+    else
+	rettv->vval.v_number = -1;
+}
+
+/*
+ * "index()" function
+ */
+    static void
+f_index(typval_T *argvars, typval_T *rettv)
+{
+    list_T	*l;
+    listitem_T	*item;
+    long	idx = 0;
+    int		ic = FALSE;
+
+    rettv->vval.v_number = -1;
+    if (argvars[0].v_type != VAR_LIST)
+    {
+	EMSG(_(e_listreq));
+	return;
+    }
+    l = argvars[0].vval.v_list;
+    if (l != NULL)
+    {
+	item = l->lv_first;
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
+	    int		error = FALSE;
+
+	    /* Start at specified item.  Use the cached index that list_find()
+	     * sets, so that a negative number also works. */
+	    item = list_find(l, (long)get_tv_number_chk(&argvars[2], &error));
+	    idx = l->lv_idx;
+	    if (argvars[3].v_type != VAR_UNKNOWN)
+		ic = (int)get_tv_number_chk(&argvars[3], &error);
+	    if (error)
+		item = NULL;
+	}
+
+	for ( ; item != NULL; item = item->li_next, ++idx)
+	    if (tv_equal(&item->li_tv, &argvars[1], ic, FALSE))
+	    {
+		rettv->vval.v_number = idx;
+		break;
+	    }
+    }
+}
+
+static int inputsecret_flag = 0;
+
+/*
+ * "input()" function
+ *     Also handles inputsecret() when inputsecret is set.
+ */
+    static void
+f_input(typval_T *argvars, typval_T *rettv)
+{
+    get_user_input(argvars, rettv, FALSE, inputsecret_flag);
+}
+
+/*
+ * "inputdialog()" function
+ */
+    static void
+f_inputdialog(typval_T *argvars, typval_T *rettv)
+{
+#if defined(FEAT_GUI_TEXTDIALOG)
+    /* Use a GUI dialog if the GUI is running and 'c' is not in 'guioptions' */
+    if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)
+    {
+	char_u	*message;
+	char_u	buf[NUMBUFLEN];
+	char_u	*defstr = (char_u *)"";
+
+	message = get_tv_string_chk(&argvars[0]);
+	if (argvars[1].v_type != VAR_UNKNOWN
+		&& (defstr = get_tv_string_buf_chk(&argvars[1], buf)) != NULL)
+	    vim_strncpy(IObuff, defstr, IOSIZE - 1);
+	else
+	    IObuff[0] = NUL;
+	if (message != NULL && defstr != NULL
+		&& do_dialog(VIM_QUESTION, NULL, message,
+			  (char_u *)_("&OK\n&Cancel"), 1, IObuff, FALSE) == 1)
+	    rettv->vval.v_string = vim_strsave(IObuff);
+	else
+	{
+	    if (message != NULL && defstr != NULL
+					&& argvars[1].v_type != VAR_UNKNOWN
+					&& argvars[2].v_type != VAR_UNKNOWN)
+		rettv->vval.v_string = vim_strsave(
+				      get_tv_string_buf(&argvars[2], buf));
+	    else
+		rettv->vval.v_string = NULL;
+	}
+	rettv->v_type = VAR_STRING;
+    }
+    else
+#endif
+	get_user_input(argvars, rettv, TRUE, inputsecret_flag);
+}
+
+/*
+ * "inputlist()" function
+ */
+    static void
+f_inputlist(typval_T *argvars, typval_T *rettv)
+{
+    listitem_T	*li;
+    int		selected;
+    int		mouse_used;
+
+#ifdef NO_CONSOLE_INPUT
+    /* While starting up, there is no place to enter text. When running tests
+     * with --not-a-term we assume feedkeys() will be used. */
+    if (no_console_input() && !is_not_a_term())
+	return;
+#endif
+    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)
+    {
+	EMSG2(_(e_listarg), "inputlist()");
+	return;
+    }
+
+    msg_start();
+    msg_row = Rows - 1;	/* for when 'cmdheight' > 1 */
+    lines_left = Rows;	/* avoid more prompt */
+    msg_scroll = TRUE;
+    msg_clr_eos();
+
+    for (li = argvars[0].vval.v_list->lv_first; li != NULL; li = li->li_next)
+    {
+	msg_puts(get_tv_string(&li->li_tv));
+	msg_putchar('\n');
+    }
+
+    /* Ask for choice. */
+    selected = prompt_for_number(&mouse_used);
+    if (mouse_used)
+	selected -= lines_left;
+
+    rettv->vval.v_number = selected;
+}
+
+
+static garray_T	    ga_userinput = {0, 0, sizeof(tasave_T), 4, NULL};
+
+/*
+ * "inputrestore()" function
+ */
+    static void
+f_inputrestore(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    if (ga_userinput.ga_len > 0)
+    {
+	--ga_userinput.ga_len;
+	restore_typeahead((tasave_T *)(ga_userinput.ga_data)
+						       + ga_userinput.ga_len);
+	/* default return is zero == OK */
+    }
+    else if (p_verbose > 1)
+    {
+	verb_msg((char_u *)_("called inputrestore() more often than inputsave()"));
+	rettv->vval.v_number = 1; /* Failed */
+    }
+}
+
+/*
+ * "inputsave()" function
+ */
+    static void
+f_inputsave(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    /* Add an entry to the stack of typeahead storage. */
+    if (ga_grow(&ga_userinput, 1) == OK)
+    {
+	save_typeahead((tasave_T *)(ga_userinput.ga_data)
+						       + ga_userinput.ga_len);
+	++ga_userinput.ga_len;
+	/* default return is zero == OK */
+    }
+    else
+	rettv->vval.v_number = 1; /* Failed */
+}
+
+/*
+ * "inputsecret()" function
+ */
+    static void
+f_inputsecret(typval_T *argvars, typval_T *rettv)
+{
+    ++cmdline_star;
+    ++inputsecret_flag;
+    f_input(argvars, rettv);
+    --cmdline_star;
+    --inputsecret_flag;
+}
+
+/*
+ * "insert()" function
+ */
+    static void
+f_insert(typval_T *argvars, typval_T *rettv)
+{
+    long	before = 0;
+    listitem_T	*item;
+    list_T	*l;
+    int		error = FALSE;
+
+    if (argvars[0].v_type != VAR_LIST)
+	EMSG2(_(e_listarg), "insert()");
+    else if ((l = argvars[0].vval.v_list) != NULL
+	    && !tv_check_lock(l->lv_lock, (char_u *)N_("insert() argument"), TRUE))
+    {
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    before = (long)get_tv_number_chk(&argvars[2], &error);
+	if (error)
+	    return;		/* type error; errmsg already given */
+
+	if (before == l->lv_len)
+	    item = NULL;
+	else
+	{
+	    item = list_find(l, before);
+	    if (item == NULL)
+	    {
+		EMSGN(_(e_listidx), before);
+		l = NULL;
+	    }
+	}
+	if (l != NULL)
+	{
+	    list_insert_tv(l, &argvars[1], item);
+	    copy_tv(&argvars[0], rettv);
+	}
+    }
+}
+
+/*
+ * "invert(expr)" function
+ */
+    static void
+f_invert(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = ~get_tv_number_chk(&argvars[0], NULL);
+}
+
+/*
+ * "isdirectory()" function
+ */
+    static void
+f_isdirectory(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = mch_isdir(get_tv_string(&argvars[0]));
+}
+
+/*
+ * Return TRUE if typeval "tv" is locked: Either that value is locked itself
+ * or it refers to a List or Dictionary that is locked.
+ */
+    static int
+tv_islocked(typval_T *tv)
+{
+    return (tv->v_lock & VAR_LOCKED)
+	|| (tv->v_type == VAR_LIST
+		&& tv->vval.v_list != NULL
+		&& (tv->vval.v_list->lv_lock & VAR_LOCKED))
+	|| (tv->v_type == VAR_DICT
+		&& tv->vval.v_dict != NULL
+		&& (tv->vval.v_dict->dv_lock & VAR_LOCKED));
+}
+
+/*
+ * "islocked()" function
+ */
+    static void
+f_islocked(typval_T *argvars, typval_T *rettv)
+{
+    lval_T	lv;
+    char_u	*end;
+    dictitem_T	*di;
+
+    rettv->vval.v_number = -1;
+    end = get_lval(get_tv_string(&argvars[0]), NULL, &lv, FALSE, FALSE,
+			     GLV_NO_AUTOLOAD | GLV_READ_ONLY, FNE_CHECK_START);
+    if (end != NULL && lv.ll_name != NULL)
+    {
+	if (*end != NUL)
+	    EMSG(_(e_trailing));
+	else
+	{
+	    if (lv.ll_tv == NULL)
+	    {
+		di = find_var(lv.ll_name, NULL, TRUE);
+		if (di != NULL)
+		{
+		    /* Consider a variable locked when:
+		     * 1. the variable itself is locked
+		     * 2. the value of the variable is locked.
+		     * 3. the List or Dict value is locked.
+		     */
+		    rettv->vval.v_number = ((di->di_flags & DI_FLAGS_LOCK)
+						   || tv_islocked(&di->di_tv));
+		}
+	    }
+	    else if (lv.ll_range)
+		EMSG(_("E786: Range not allowed"));
+	    else if (lv.ll_newkey != NULL)
+		EMSG2(_(e_dictkey), lv.ll_newkey);
+	    else if (lv.ll_list != NULL)
+		/* List item. */
+		rettv->vval.v_number = tv_islocked(&lv.ll_li->li_tv);
+	    else
+		/* Dictionary item. */
+		rettv->vval.v_number = tv_islocked(&lv.ll_di->di_tv);
+	}
+    }
+
+    clear_lval(&lv);
+}
+
+#if defined(FEAT_FLOAT) && defined(HAVE_MATH_H)
+/*
+ * "isnan()" function
+ */
+    static void
+f_isnan(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = argvars[0].v_type == VAR_FLOAT
+					    && isnan(argvars[0].vval.v_float);
+}
+#endif
+
+/*
+ * "items(dict)" function
+ */
+    static void
+f_items(typval_T *argvars, typval_T *rettv)
+{
+    dict_list(argvars, rettv, 2);
+}
+
+#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)
+/*
+ * Get the job from the argument.
+ * Returns NULL if the job is invalid.
+ */
+    static job_T *
+get_job_arg(typval_T *tv)
+{
+    job_T *job;
+
+    if (tv->v_type != VAR_JOB)
+    {
+	EMSG2(_(e_invarg2), get_tv_string(tv));
+	return NULL;
+    }
+    job = tv->vval.v_job;
+
+    if (job == NULL)
+	EMSG(_("E916: not a valid job"));
+    return job;
+}
+
+/*
+ * "job_getchannel()" function
+ */
+    static void
+f_job_getchannel(typval_T *argvars, typval_T *rettv)
+{
+    job_T	*job = get_job_arg(&argvars[0]);
+
+    if (job != NULL)
+    {
+	rettv->v_type = VAR_CHANNEL;
+	rettv->vval.v_channel = job->jv_channel;
+	if (job->jv_channel != NULL)
+	    ++job->jv_channel->ch_refcount;
+    }
+}
+
+/*
+ * "job_info()" function
+ */
+    static void
+f_job_info(typval_T *argvars, typval_T *rettv)
+{
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	job_T	*job = get_job_arg(&argvars[0]);
+
+	if (job != NULL && rettv_dict_alloc(rettv) != FAIL)
+	    job_info(job, rettv->vval.v_dict);
+    }
+    else if (rettv_list_alloc(rettv) == OK)
+	job_info_all(rettv->vval.v_list);
+}
+
+/*
+ * "job_setoptions()" function
+ */
+    static void
+f_job_setoptions(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    job_T	*job = get_job_arg(&argvars[0]);
+    jobopt_T	opt;
+
+    if (job == NULL)
+	return;
+    clear_job_options(&opt);
+    if (get_job_options(&argvars[1], &opt, JO_STOPONEXIT + JO_EXIT_CB, 0) == OK)
+	job_set_options(job, &opt);
+    free_job_options(&opt);
+}
+
+/*
+ * "job_start()" function
+ */
+    static void
+f_job_start(typval_T *argvars, typval_T *rettv)
+{
+    rettv->v_type = VAR_JOB;
+    if (check_restricted() || check_secure())
+	return;
+    rettv->vval.v_job = job_start(argvars, NULL, NULL, FALSE);
+}
+
+/*
+ * "job_status()" function
+ */
+    static void
+f_job_status(typval_T *argvars, typval_T *rettv)
+{
+    job_T	*job = get_job_arg(&argvars[0]);
+
+    if (job != NULL)
+    {
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = vim_strsave((char_u *)job_status(job));
+    }
+}
+
+/*
+ * "job_stop()" function
+ */
+    static void
+f_job_stop(typval_T *argvars, typval_T *rettv)
+{
+    job_T	*job = get_job_arg(&argvars[0]);
+
+    if (job != NULL)
+	rettv->vval.v_number = job_stop(job, argvars, NULL);
+}
+#endif
+
+/*
+ * "join()" function
+ */
+    static void
+f_join(typval_T *argvars, typval_T *rettv)
+{
+    garray_T	ga;
+    char_u	*sep;
+
+    if (argvars[0].v_type != VAR_LIST)
+    {
+	EMSG(_(e_listreq));
+	return;
+    }
+    if (argvars[0].vval.v_list == NULL)
+	return;
+    if (argvars[1].v_type == VAR_UNKNOWN)
+	sep = (char_u *)" ";
+    else
+	sep = get_tv_string_chk(&argvars[1]);
+
+    rettv->v_type = VAR_STRING;
+
+    if (sep != NULL)
+    {
+	ga_init2(&ga, (int)sizeof(char), 80);
+	list_join(&ga, argvars[0].vval.v_list, sep, TRUE, FALSE, 0);
+	ga_append(&ga, NUL);
+	rettv->vval.v_string = (char_u *)ga.ga_data;
+    }
+    else
+	rettv->vval.v_string = NULL;
+}
+
+/*
+ * "js_decode()" function
+ */
+    static void
+f_js_decode(typval_T *argvars, typval_T *rettv)
+{
+    js_read_T	reader;
+
+    reader.js_buf = get_tv_string(&argvars[0]);
+    reader.js_fill = NULL;
+    reader.js_used = 0;
+    if (json_decode_all(&reader, rettv, JSON_JS) != OK)
+	EMSG(_(e_invarg));
+}
+
+/*
+ * "js_encode()" function
+ */
+    static void
+f_js_encode(typval_T *argvars, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = json_encode(&argvars[0], JSON_JS);
+}
+
+/*
+ * "json_decode()" function
+ */
+    static void
+f_json_decode(typval_T *argvars, typval_T *rettv)
+{
+    js_read_T	reader;
+
+    reader.js_buf = get_tv_string(&argvars[0]);
+    reader.js_fill = NULL;
+    reader.js_used = 0;
+    json_decode_all(&reader, rettv, 0);
+}
+
+/*
+ * "json_encode()" function
+ */
+    static void
+f_json_encode(typval_T *argvars, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = json_encode(&argvars[0], 0);
+}
+
+/*
+ * "keys()" function
+ */
+    static void
+f_keys(typval_T *argvars, typval_T *rettv)
+{
+    dict_list(argvars, rettv, 0);
+}
+
+/*
+ * "last_buffer_nr()" function.
+ */
+    static void
+f_last_buffer_nr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		n = 0;
+    buf_T	*buf;
+
+    FOR_ALL_BUFFERS(buf)
+	if (n < buf->b_fnum)
+	    n = buf->b_fnum;
+
+    rettv->vval.v_number = n;
+}
+
+/*
+ * "len()" function
+ */
+    static void
+f_len(typval_T *argvars, typval_T *rettv)
+{
+    switch (argvars[0].v_type)
+    {
+	case VAR_STRING:
+	case VAR_NUMBER:
+	    rettv->vval.v_number = (varnumber_T)STRLEN(
+					       get_tv_string(&argvars[0]));
+	    break;
+	case VAR_LIST:
+	    rettv->vval.v_number = list_len(argvars[0].vval.v_list);
+	    break;
+	case VAR_DICT:
+	    rettv->vval.v_number = dict_len(argvars[0].vval.v_dict);
+	    break;
+	case VAR_UNKNOWN:
+	case VAR_SPECIAL:
+	case VAR_FLOAT:
+	case VAR_FUNC:
+	case VAR_PARTIAL:
+	case VAR_JOB:
+	case VAR_CHANNEL:
+	    EMSG(_("E701: Invalid type for len()"));
+	    break;
+    }
+}
+
+    static void
+libcall_common(typval_T *argvars UNUSED, typval_T *rettv, int type)
+{
+#ifdef FEAT_LIBCALL
+    char_u		*string_in;
+    char_u		**string_result;
+    int			nr_result;
+#endif
+
+    rettv->v_type = type;
+    if (type != VAR_NUMBER)
+	rettv->vval.v_string = NULL;
+
+    if (check_restricted() || check_secure())
+	return;
+
+#ifdef FEAT_LIBCALL
+    /* The first two args must be strings, otherwise it's meaningless */
+    if (argvars[0].v_type == VAR_STRING && argvars[1].v_type == VAR_STRING)
+    {
+	string_in = NULL;
+	if (argvars[2].v_type == VAR_STRING)
+	    string_in = argvars[2].vval.v_string;
+	if (type == VAR_NUMBER)
+	    string_result = NULL;
+	else
+	    string_result = &rettv->vval.v_string;
+	if (mch_libcall(argvars[0].vval.v_string,
+			     argvars[1].vval.v_string,
+			     string_in,
+			     argvars[2].vval.v_number,
+			     string_result,
+			     &nr_result) == OK
+		&& type == VAR_NUMBER)
+	    rettv->vval.v_number = nr_result;
+    }
+#endif
+}
+
+/*
+ * "libcall()" function
+ */
+    static void
+f_libcall(typval_T *argvars, typval_T *rettv)
+{
+    libcall_common(argvars, rettv, VAR_STRING);
+}
+
+/*
+ * "libcallnr()" function
+ */
+    static void
+f_libcallnr(typval_T *argvars, typval_T *rettv)
+{
+    libcall_common(argvars, rettv, VAR_NUMBER);
+}
+
+/*
+ * "line(string)" function
+ */
+    static void
+f_line(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum = 0;
+    pos_T	*fp;
+    int		fnum;
+
+    fp = var2fpos(&argvars[0], TRUE, &fnum);
+    if (fp != NULL)
+	lnum = fp->lnum;
+    rettv->vval.v_number = lnum;
+}
+
+/*
+ * "line2byte(lnum)" function
+ */
+    static void
+f_line2byte(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifndef FEAT_BYTEOFF
+    rettv->vval.v_number = -1;
+#else
+    linenr_T	lnum;
+
+    lnum = get_tv_lnum(argvars);
+    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count + 1)
+	rettv->vval.v_number = -1;
+    else
+	rettv->vval.v_number = ml_find_line_or_offset(curbuf, lnum, NULL);
+    if (rettv->vval.v_number >= 0)
+	++rettv->vval.v_number;
+#endif
+}
+
+/*
+ * "lispindent(lnum)" function
+ */
+    static void
+f_lispindent(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_LISP
+    pos_T	pos;
+    linenr_T	lnum;
+
+    pos = curwin->w_cursor;
+    lnum = get_tv_lnum(argvars);
+    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
+    {
+	curwin->w_cursor.lnum = lnum;
+	rettv->vval.v_number = get_lisp_indent();
+	curwin->w_cursor = pos;
+    }
+    else
+#endif
+	rettv->vval.v_number = -1;
+}
+
+/*
+ * "localtime()" function
+ */
+    static void
+f_localtime(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = (varnumber_T)time(NULL);
+}
+
+static void get_maparg(typval_T *argvars, typval_T *rettv, int exact);
+
+    static void
+get_maparg(typval_T *argvars, typval_T *rettv, int exact)
+{
+    char_u	*keys;
+    char_u	*which;
+    char_u	buf[NUMBUFLEN];
+    char_u	*keys_buf = NULL;
+    char_u	*rhs;
+    int		mode;
+    int		abbr = FALSE;
+    int		get_dict = FALSE;
+    mapblock_T	*mp;
+    int		buffer_local;
+
+    /* return empty string for failure */
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+
+    keys = get_tv_string(&argvars[0]);
+    if (*keys == NUL)
+	return;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	which = get_tv_string_buf_chk(&argvars[1], buf);
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
+	    abbr = (int)get_tv_number(&argvars[2]);
+	    if (argvars[3].v_type != VAR_UNKNOWN)
+		get_dict = (int)get_tv_number(&argvars[3]);
+	}
+    }
+    else
+	which = (char_u *)"";
+    if (which == NULL)
+	return;
+
+    mode = get_map_mode(&which, 0);
+
+    keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, FALSE);
+    rhs = check_map(keys, mode, exact, FALSE, abbr, &mp, &buffer_local);
+    vim_free(keys_buf);
+
+    if (!get_dict)
+    {
+	/* Return a string. */
+	if (rhs != NULL)
+	{
+	    if (*rhs == NUL)
+		rettv->vval.v_string = vim_strsave((char_u *)"<Nop>");
+	    else
+		rettv->vval.v_string = str2special_save(rhs, FALSE);
+	}
+
+    }
+    else if (rettv_dict_alloc(rettv) != FAIL && rhs != NULL)
+    {
+	/* Return a dictionary. */
+	char_u	    *lhs = str2special_save(mp->m_keys, TRUE);
+	char_u	    *mapmode = map_mode_to_chars(mp->m_mode);
+	dict_T	    *dict = rettv->vval.v_dict;
+
+	dict_add_string(dict, "lhs", lhs);
+	dict_add_string(dict, "rhs", mp->m_orig_str);
+	dict_add_number(dict, "noremap", mp->m_noremap ? 1L : 0L);
+	dict_add_number(dict, "expr", mp->m_expr ? 1L : 0L);
+	dict_add_number(dict, "silent", mp->m_silent ? 1L : 0L);
+	dict_add_number(dict, "sid", (long)mp->m_script_ID);
+	dict_add_number(dict, "buffer", (long)buffer_local);
+	dict_add_number(dict, "nowait", mp->m_nowait ? 1L : 0L);
+	dict_add_string(dict, "mode", mapmode);
+
+	vim_free(lhs);
+	vim_free(mapmode);
+    }
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "log()" function
+ */
+    static void
+f_log(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = log(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "log10()" function
+ */
+    static void
+f_log10(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = log10(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+#ifdef FEAT_LUA
+/*
+ * "luaeval()" function
+ */
+    static void
+f_luaeval(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*str;
+    char_u	buf[NUMBUFLEN];
+
+    str = get_tv_string_buf(&argvars[0], buf);
+    do_luaeval(str, argvars + 1, rettv);
+}
+#endif
+
+/*
+ * "map()" function
+ */
+    static void
+f_map(typval_T *argvars, typval_T *rettv)
+{
+    filter_map(argvars, rettv, TRUE);
+}
+
+/*
+ * "maparg()" function
+ */
+    static void
+f_maparg(typval_T *argvars, typval_T *rettv)
+{
+    get_maparg(argvars, rettv, TRUE);
+}
+
+/*
+ * "mapcheck()" function
+ */
+    static void
+f_mapcheck(typval_T *argvars, typval_T *rettv)
+{
+    get_maparg(argvars, rettv, FALSE);
+}
+
+typedef enum
+{
+    MATCH_END,	    /* matchend() */
+    MATCH_MATCH,    /* match() */
+    MATCH_STR,	    /* matchstr() */
+    MATCH_LIST,	    /* matchlist() */
+    MATCH_POS	    /* matchstrpos() */
+} matchtype_T;
+
+    static void
+find_some_match(typval_T *argvars, typval_T *rettv, matchtype_T type)
+{
+    char_u	*str = NULL;
+    long	len = 0;
+    char_u	*expr = NULL;
+    char_u	*pat;
+    regmatch_T	regmatch;
+    char_u	patbuf[NUMBUFLEN];
+    char_u	strbuf[NUMBUFLEN];
+    char_u	*save_cpo;
+    long	start = 0;
+    long	nth = 1;
+    colnr_T	startcol = 0;
+    int		match = 0;
+    list_T	*l = NULL;
+    listitem_T	*li = NULL;
+    long	idx = 0;
+    char_u	*tofree = NULL;
+
+    /* Make 'cpoptions' empty, the 'l' flag should not be used here. */
+    save_cpo = p_cpo;
+    p_cpo = (char_u *)"";
+
+    rettv->vval.v_number = -1;
+    if (type == MATCH_LIST || type == MATCH_POS)
+    {
+	/* type MATCH_LIST: return empty list when there are no matches.
+	 * type MATCH_POS: return ["", -1, -1, -1] */
+	if (rettv_list_alloc(rettv) == FAIL)
+	    goto theend;
+	if (type == MATCH_POS
+		&& (list_append_string(rettv->vval.v_list,
+					    (char_u *)"", 0) == FAIL
+		    || list_append_number(rettv->vval.v_list,
+					    (varnumber_T)-1) == FAIL
+		    || list_append_number(rettv->vval.v_list,
+					    (varnumber_T)-1) == FAIL
+		    || list_append_number(rettv->vval.v_list,
+					    (varnumber_T)-1) == FAIL))
+	{
+		list_free(rettv->vval.v_list);
+		rettv->vval.v_list = NULL;
+		goto theend;
+	}
+    }
+    else if (type == MATCH_STR)
+    {
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = NULL;
+    }
+
+    if (argvars[0].v_type == VAR_LIST)
+    {
+	if ((l = argvars[0].vval.v_list) == NULL)
+	    goto theend;
+	li = l->lv_first;
+    }
+    else
+    {
+	expr = str = get_tv_string(&argvars[0]);
+	len = (long)STRLEN(str);
+    }
+
+    pat = get_tv_string_buf_chk(&argvars[1], patbuf);
+    if (pat == NULL)
+	goto theend;
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	int	    error = FALSE;
+
+	start = (long)get_tv_number_chk(&argvars[2], &error);
+	if (error)
+	    goto theend;
+	if (l != NULL)
+	{
+	    li = list_find(l, start);
+	    if (li == NULL)
+		goto theend;
+	    idx = l->lv_idx;	/* use the cached index */
+	}
+	else
+	{
+	    if (start < 0)
+		start = 0;
+	    if (start > len)
+		goto theend;
+	    /* When "count" argument is there ignore matches before "start",
+	     * otherwise skip part of the string.  Differs when pattern is "^"
+	     * or "\<". */
+	    if (argvars[3].v_type != VAR_UNKNOWN)
+		startcol = start;
+	    else
+	    {
+		str += start;
+		len -= start;
+	    }
+	}
+
+	if (argvars[3].v_type != VAR_UNKNOWN)
+	    nth = (long)get_tv_number_chk(&argvars[3], &error);
+	if (error)
+	    goto theend;
+    }
+
+    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);
+    if (regmatch.regprog != NULL)
+    {
+	regmatch.rm_ic = p_ic;
+
+	for (;;)
+	{
+	    if (l != NULL)
+	    {
+		if (li == NULL)
+		{
+		    match = FALSE;
+		    break;
+		}
+		vim_free(tofree);
+		expr = str = echo_string(&li->li_tv, &tofree, strbuf, 0);
+		if (str == NULL)
+		    break;
+	    }
+
+	    match = vim_regexec_nl(&regmatch, str, (colnr_T)startcol);
+
+	    if (match && --nth <= 0)
+		break;
+	    if (l == NULL && !match)
+		break;
+
+	    /* Advance to just after the match. */
+	    if (l != NULL)
+	    {
+		li = li->li_next;
+		++idx;
+	    }
+	    else
+	    {
+#ifdef FEAT_MBYTE
+		startcol = (colnr_T)(regmatch.startp[0]
+				    + (*mb_ptr2len)(regmatch.startp[0]) - str);
+#else
+		startcol = (colnr_T)(regmatch.startp[0] + 1 - str);
+#endif
+		if (startcol > (colnr_T)len
+				      || str + startcol <= regmatch.startp[0])
+		{
+		    match = FALSE;
+		    break;
+		}
+	    }
+	}
+
+	if (match)
+	{
+	    if (type == MATCH_POS)
+	    {
+		listitem_T *li1 = rettv->vval.v_list->lv_first;
+		listitem_T *li2 = li1->li_next;
+		listitem_T *li3 = li2->li_next;
+		listitem_T *li4 = li3->li_next;
+
+		vim_free(li1->li_tv.vval.v_string);
+		li1->li_tv.vval.v_string = vim_strnsave(regmatch.startp[0],
+				(int)(regmatch.endp[0] - regmatch.startp[0]));
+		li3->li_tv.vval.v_number =
+				      (varnumber_T)(regmatch.startp[0] - expr);
+		li4->li_tv.vval.v_number =
+					(varnumber_T)(regmatch.endp[0] - expr);
+		if (l != NULL)
+		    li2->li_tv.vval.v_number = (varnumber_T)idx;
+	    }
+	    else if (type == MATCH_LIST)
+	    {
+		int i;
+
+		/* return list with matched string and submatches */
+		for (i = 0; i < NSUBEXP; ++i)
+		{
+		    if (regmatch.endp[i] == NULL)
+		    {
+			if (list_append_string(rettv->vval.v_list,
+						     (char_u *)"", 0) == FAIL)
+			    break;
+		    }
+		    else if (list_append_string(rettv->vval.v_list,
+				regmatch.startp[i],
+				(int)(regmatch.endp[i] - regmatch.startp[i]))
+			    == FAIL)
+			break;
+		}
+	    }
+	    else if (type == MATCH_STR)
+	    {
+		/* return matched string */
+		if (l != NULL)
+		    copy_tv(&li->li_tv, rettv);
+		else
+		    rettv->vval.v_string = vim_strnsave(regmatch.startp[0],
+				(int)(regmatch.endp[0] - regmatch.startp[0]));
+	    }
+	    else if (l != NULL)
+		rettv->vval.v_number = idx;
+	    else
+	    {
+		if (type != MATCH_END)
+		    rettv->vval.v_number =
+				      (varnumber_T)(regmatch.startp[0] - str);
+		else
+		    rettv->vval.v_number =
+					(varnumber_T)(regmatch.endp[0] - str);
+		rettv->vval.v_number += (varnumber_T)(str - expr);
+	    }
+	}
+	vim_regfree(regmatch.regprog);
+    }
+
+theend:
+    if (type == MATCH_POS && l == NULL && rettv->vval.v_list != NULL)
+	/* matchstrpos() without a list: drop the second item. */
+	listitem_remove(rettv->vval.v_list,
+				       rettv->vval.v_list->lv_first->li_next);
+    vim_free(tofree);
+    p_cpo = save_cpo;
+}
+
+/*
+ * "match()" function
+ */
+    static void
+f_match(typval_T *argvars, typval_T *rettv)
+{
+    find_some_match(argvars, rettv, MATCH_MATCH);
+}
+
+#ifdef FEAT_SEARCH_EXTRA
+    static int
+matchadd_dict_arg(typval_T *tv, char_u **conceal_char, win_T **win)
+{
+    dictitem_T *di;
+
+    if (tv->v_type != VAR_DICT)
+    {
+	EMSG(_(e_dictreq));
+	return FAIL;
+    }
+
+    if (dict_find(tv->vval.v_dict, (char_u *)"conceal", -1) != NULL)
+	*conceal_char = get_dict_string(tv->vval.v_dict,
+						   (char_u *)"conceal", FALSE);
+
+    if ((di = dict_find(tv->vval.v_dict, (char_u *)"window", -1)) != NULL)
+    {
+	*win = find_win_by_nr(&di->di_tv, NULL);
+	if (*win == NULL)
+	{
+	    EMSG(_("E957: Invalid window number"));
+	    return FAIL;
+	}
+    }
+
+    return OK;
+}
+#endif
+
+/*
+ * "matchadd()" function
+ */
+    static void
+f_matchadd(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_SEARCH_EXTRA
+    char_u	buf[NUMBUFLEN];
+    char_u	*grp = get_tv_string_buf_chk(&argvars[0], buf);	/* group */
+    char_u	*pat = get_tv_string_buf_chk(&argvars[1], buf);	/* pattern */
+    int		prio = 10;	/* default priority */
+    int		id = -1;
+    int		error = FALSE;
+    char_u	*conceal_char = NULL;
+    win_T	*win = curwin;
+
+    rettv->vval.v_number = -1;
+
+    if (grp == NULL || pat == NULL)
+	return;
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	prio = (int)get_tv_number_chk(&argvars[2], &error);
+	if (argvars[3].v_type != VAR_UNKNOWN)
+	{
+	    id = (int)get_tv_number_chk(&argvars[3], &error);
+	    if (argvars[4].v_type != VAR_UNKNOWN
+		&& matchadd_dict_arg(&argvars[4], &conceal_char, &win) == FAIL)
+		return;
+	}
+    }
+    if (error == TRUE)
+	return;
+    if (id >= 1 && id <= 3)
+    {
+	EMSGN(_("E798: ID is reserved for \":match\": %ld"), id);
+	return;
+    }
+
+    rettv->vval.v_number = match_add(win, grp, pat, prio, id, NULL,
+								conceal_char);
+#endif
+}
+
+/*
+ * "matchaddpos()" function
+ */
+    static void
+f_matchaddpos(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_SEARCH_EXTRA
+    char_u	buf[NUMBUFLEN];
+    char_u	*group;
+    int		prio = 10;
+    int		id = -1;
+    int		error = FALSE;
+    list_T	*l;
+    char_u	*conceal_char = NULL;
+    win_T	*win = curwin;
+
+    rettv->vval.v_number = -1;
+
+    group = get_tv_string_buf_chk(&argvars[0], buf);
+    if (group == NULL)
+	return;
+
+    if (argvars[1].v_type != VAR_LIST)
+    {
+	EMSG2(_(e_listarg), "matchaddpos()");
+	return;
+    }
+    l = argvars[1].vval.v_list;
+    if (l == NULL)
+	return;
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	prio = (int)get_tv_number_chk(&argvars[2], &error);
+	if (argvars[3].v_type != VAR_UNKNOWN)
+	{
+	    id = (int)get_tv_number_chk(&argvars[3], &error);
+
+	    if (argvars[4].v_type != VAR_UNKNOWN
+		&& matchadd_dict_arg(&argvars[4], &conceal_char, &win) == FAIL)
+		return;
+	}
+    }
+    if (error == TRUE)
+	return;
+
+    /* id == 3 is ok because matchaddpos() is supposed to substitute :3match */
+    if (id == 1 || id == 2)
+    {
+	EMSGN(_("E798: ID is reserved for \":match\": %ld"), id);
+	return;
+    }
+
+    rettv->vval.v_number = match_add(win, group, NULL, prio, id, l,
+								conceal_char);
+#endif
+}
+
+/*
+ * "matcharg()" function
+ */
+    static void
+f_matcharg(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    if (rettv_list_alloc(rettv) == OK)
+    {
+#ifdef FEAT_SEARCH_EXTRA
+	int	    id = (int)get_tv_number(&argvars[0]);
+	matchitem_T *m;
+
+	if (id >= 1 && id <= 3)
+	{
+	    if ((m = (matchitem_T *)get_match(curwin, id)) != NULL)
+	    {
+		list_append_string(rettv->vval.v_list,
+						syn_id2name(m->hlg_id), -1);
+		list_append_string(rettv->vval.v_list, m->pattern, -1);
+	    }
+	    else
+	    {
+		list_append_string(rettv->vval.v_list, NULL, -1);
+		list_append_string(rettv->vval.v_list, NULL, -1);
+	    }
+	}
+#endif
+    }
+}
+
+/*
+ * "matchdelete()" function
+ */
+    static void
+f_matchdelete(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_SEARCH_EXTRA
+    rettv->vval.v_number = match_delete(curwin,
+				       (int)get_tv_number(&argvars[0]), TRUE);
+#endif
+}
+
+/*
+ * "matchend()" function
+ */
+    static void
+f_matchend(typval_T *argvars, typval_T *rettv)
+{
+    find_some_match(argvars, rettv, MATCH_END);
+}
+
+/*
+ * "matchlist()" function
+ */
+    static void
+f_matchlist(typval_T *argvars, typval_T *rettv)
+{
+    find_some_match(argvars, rettv, MATCH_LIST);
+}
+
+/*
+ * "matchstr()" function
+ */
+    static void
+f_matchstr(typval_T *argvars, typval_T *rettv)
+{
+    find_some_match(argvars, rettv, MATCH_STR);
+}
+
+/*
+ * "matchstrpos()" function
+ */
+    static void
+f_matchstrpos(typval_T *argvars, typval_T *rettv)
+{
+    find_some_match(argvars, rettv, MATCH_POS);
+}
+
+static void max_min(typval_T *argvars, typval_T *rettv, int domax);
+
+    static void
+max_min(typval_T *argvars, typval_T *rettv, int domax)
+{
+    varnumber_T	n = 0;
+    varnumber_T	i;
+    int		error = FALSE;
+
+    if (argvars[0].v_type == VAR_LIST)
+    {
+	list_T		*l;
+	listitem_T	*li;
+
+	l = argvars[0].vval.v_list;
+	if (l != NULL)
+	{
+	    li = l->lv_first;
+	    if (li != NULL)
+	    {
+		n = get_tv_number_chk(&li->li_tv, &error);
+		for (;;)
+		{
+		    li = li->li_next;
+		    if (li == NULL)
+			break;
+		    i = get_tv_number_chk(&li->li_tv, &error);
+		    if (domax ? i > n : i < n)
+			n = i;
+		}
+	    }
+	}
+    }
+    else if (argvars[0].v_type == VAR_DICT)
+    {
+	dict_T		*d;
+	int		first = TRUE;
+	hashitem_T	*hi;
+	int		todo;
+
+	d = argvars[0].vval.v_dict;
+	if (d != NULL)
+	{
+	    todo = (int)d->dv_hashtab.ht_used;
+	    for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi)
+	    {
+		if (!HASHITEM_EMPTY(hi))
+		{
+		    --todo;
+		    i = get_tv_number_chk(&HI2DI(hi)->di_tv, &error);
+		    if (first)
+		    {
+			n = i;
+			first = FALSE;
+		    }
+		    else if (domax ? i > n : i < n)
+			n = i;
+		}
+	    }
+	}
+    }
+    else
+	EMSG2(_(e_listdictarg), domax ? "max()" : "min()");
+    rettv->vval.v_number = error ? 0 : n;
+}
+
+/*
+ * "max()" function
+ */
+    static void
+f_max(typval_T *argvars, typval_T *rettv)
+{
+    max_min(argvars, rettv, TRUE);
+}
+
+/*
+ * "min()" function
+ */
+    static void
+f_min(typval_T *argvars, typval_T *rettv)
+{
+    max_min(argvars, rettv, FALSE);
+}
+
+static int mkdir_recurse(char_u *dir, int prot);
+
+/*
+ * Create the directory in which "dir" is located, and higher levels when
+ * needed.
+ * Return OK or FAIL.
+ */
+    static int
+mkdir_recurse(char_u *dir, int prot)
+{
+    char_u	*p;
+    char_u	*updir;
+    int		r = FAIL;
+
+    /* Get end of directory name in "dir".
+     * We're done when it's "/" or "c:/". */
+    p = gettail_sep(dir);
+    if (p <= get_past_head(dir))
+	return OK;
+
+    /* If the directory exists we're done.  Otherwise: create it.*/
+    updir = vim_strnsave(dir, (int)(p - dir));
+    if (updir == NULL)
+	return FAIL;
+    if (mch_isdir(updir))
+	r = OK;
+    else if (mkdir_recurse(updir, prot) == OK)
+	r = vim_mkdir_emsg(updir, prot);
+    vim_free(updir);
+    return r;
+}
+
+#ifdef vim_mkdir
+/*
+ * "mkdir()" function
+ */
+    static void
+f_mkdir(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*dir;
+    char_u	buf[NUMBUFLEN];
+    int		prot = 0755;
+
+    rettv->vval.v_number = FAIL;
+    if (check_restricted() || check_secure())
+	return;
+
+    dir = get_tv_string_buf(&argvars[0], buf);
+    if (*dir == NUL)
+	return;
+
+    if (*gettail(dir) == NUL)
+	/* remove trailing slashes */
+	*gettail_sep(dir) = NUL;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
+	    prot = (int)get_tv_number_chk(&argvars[2], NULL);
+	    if (prot == -1)
+		return;
+	}
+	if (STRCMP(get_tv_string(&argvars[1]), "p") == 0)
+	{
+	    if (mch_isdir(dir))
+	    {
+		/* With the "p" flag it's OK if the dir already exists. */
+		rettv->vval.v_number = OK;
+		return;
+	    }
+	    mkdir_recurse(dir, prot);
+	}
+    }
+    rettv->vval.v_number = vim_mkdir_emsg(dir, prot);
+}
+#endif
+
+/*
+ * "mode()" function
+ */
+    static void
+f_mode(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf[4];
+
+    vim_memset(buf, 0, sizeof(buf));
+
+    if (time_for_testing == 93784)
+    {
+	/* Testing the two-character code. */
+	buf[0] = 'x';
+	buf[1] = '!';
+    }
+#ifdef FEAT_TERMINAL
+    else if (term_use_loop())
+	buf[0] = 't';
+#endif
+    else if (VIsual_active)
+    {
+	if (VIsual_select)
+	    buf[0] = VIsual_mode + 's' - 'v';
+	else
+	    buf[0] = VIsual_mode;
+    }
+    else if (State == HITRETURN || State == ASKMORE || State == SETWSIZE
+		|| State == CONFIRM)
+    {
+	buf[0] = 'r';
+	if (State == ASKMORE)
+	    buf[1] = 'm';
+	else if (State == CONFIRM)
+	    buf[1] = '?';
+    }
+    else if (State == EXTERNCMD)
+	buf[0] = '!';
+    else if (State & INSERT)
+    {
+	if (State & VREPLACE_FLAG)
+	{
+	    buf[0] = 'R';
+	    buf[1] = 'v';
+	}
+	else
+	{
+	    if (State & REPLACE_FLAG)
+		buf[0] = 'R';
+	    else
+		buf[0] = 'i';
+#ifdef FEAT_INS_EXPAND
+	    if (ins_compl_active())
+		buf[1] = 'c';
+	    else if (ctrl_x_mode_not_defined_yet())
+		buf[1] = 'x';
+#endif
+	}
+    }
+    else if ((State & CMDLINE) || exmode_active)
+    {
+	buf[0] = 'c';
+	if (exmode_active == EXMODE_VIM)
+	    buf[1] = 'v';
+	else if (exmode_active == EXMODE_NORMAL)
+	    buf[1] = 'e';
+    }
+    else
+    {
+	buf[0] = 'n';
+	if (finish_op)
+	    buf[1] = 'o';
+	else if (restart_edit == 'I' || restart_edit == 'R'
+							|| restart_edit == 'V')
+	{
+	    buf[1] = 'i';
+	    buf[2] = restart_edit;
+	}
+    }
+
+    /* Clear out the minor mode when the argument is not a non-zero number or
+     * non-empty string.  */
+    if (!non_zero_arg(&argvars[0]))
+	buf[1] = NUL;
+
+    rettv->vval.v_string = vim_strsave(buf);
+    rettv->v_type = VAR_STRING;
+}
+
+#if defined(FEAT_MZSCHEME) || defined(PROTO)
+/*
+ * "mzeval()" function
+ */
+    static void
+f_mzeval(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*str;
+    char_u	buf[NUMBUFLEN];
+
+    str = get_tv_string_buf(&argvars[0], buf);
+    do_mzeval(str, rettv);
+}
+
+    void
+mzscheme_call_vim(char_u *name, typval_T *args, typval_T *rettv)
+{
+    typval_T argvars[3];
+
+    argvars[0].v_type = VAR_STRING;
+    argvars[0].vval.v_string = name;
+    copy_tv(args, &argvars[1]);
+    argvars[2].v_type = VAR_UNKNOWN;
+    f_call(argvars, rettv);
+    clear_tv(&argvars[1]);
+}
+#endif
+
+/*
+ * "nextnonblank()" function
+ */
+    static void
+f_nextnonblank(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum;
+
+    for (lnum = get_tv_lnum(argvars); ; ++lnum)
+    {
+	if (lnum < 0 || lnum > curbuf->b_ml.ml_line_count)
+	{
+	    lnum = 0;
+	    break;
+	}
+	if (*skipwhite(ml_get(lnum)) != NUL)
+	    break;
+    }
+    rettv->vval.v_number = lnum;
+}
+
+/*
+ * "nr2char()" function
+ */
+    static void
+f_nr2char(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf[NUMBUFLEN];
+
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+    {
+	int	utf8 = 0;
+
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	    utf8 = (int)get_tv_number_chk(&argvars[1], NULL);
+	if (utf8)
+	    buf[(*utf_char2bytes)((int)get_tv_number(&argvars[0]), buf)] = NUL;
+	else
+	    buf[(*mb_char2bytes)((int)get_tv_number(&argvars[0]), buf)] = NUL;
+    }
+    else
+#endif
+    {
+	buf[0] = (char_u)get_tv_number(&argvars[0]);
+	buf[1] = NUL;
+    }
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = vim_strsave(buf);
+}
+
+/*
+ * "or(expr, expr)" function
+ */
+    static void
+f_or(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
+					| get_tv_number_chk(&argvars[1], NULL);
+}
+
+/*
+ * "pathshorten()" function
+ */
+    static void
+f_pathshorten(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*p;
+
+    rettv->v_type = VAR_STRING;
+    p = get_tv_string_chk(&argvars[0]);
+    if (p == NULL)
+	rettv->vval.v_string = NULL;
+    else
+    {
+	p = vim_strsave(p);
+	rettv->vval.v_string = p;
+	if (p != NULL)
+	    shorten_dir(p);
+    }
+}
+
+#ifdef FEAT_PERL
+/*
+ * "perleval()" function
+ */
+    static void
+f_perleval(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*str;
+    char_u	buf[NUMBUFLEN];
+
+    str = get_tv_string_buf(&argvars[0], buf);
+    do_perleval(str, rettv);
+}
+#endif
+
+#ifdef FEAT_FLOAT
+/*
+ * "pow()" function
+ */
+    static void
+f_pow(typval_T *argvars, typval_T *rettv)
+{
+    float_T	fx = 0.0, fy = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &fx) == OK
+				     && get_float_arg(&argvars[1], &fy) == OK)
+	rettv->vval.v_float = pow(fx, fy);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "prevnonblank()" function
+ */
+    static void
+f_prevnonblank(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum;
+
+    lnum = get_tv_lnum(argvars);
+    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)
+	lnum = 0;
+    else
+	while (lnum >= 1 && *skipwhite(ml_get(lnum)) == NUL)
+	    --lnum;
+    rettv->vval.v_number = lnum;
+}
+
+/* This dummy va_list is here because:
+ * - passing a NULL pointer doesn't work when va_list isn't a pointer
+ * - locally in the function results in a "used before set" warning
+ * - using va_start() to initialize it gives "function with fixed args" error */
+static va_list	ap;
+
+/*
+ * "printf()" function
+ */
+    static void
+f_printf(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf[NUMBUFLEN];
+    int		len;
+    char_u	*s;
+    int		saved_did_emsg = did_emsg;
+    char	*fmt;
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+
+    /* Get the required length, allocate the buffer and do it for real. */
+    did_emsg = FALSE;
+    fmt = (char *)get_tv_string_buf(&argvars[0], buf);
+    len = vim_vsnprintf_typval(NULL, 0, fmt, ap, argvars + 1);
+    if (!did_emsg)
+    {
+	s = alloc(len + 1);
+	if (s != NULL)
+	{
+	    rettv->vval.v_string = s;
+	    (void)vim_vsnprintf_typval((char *)s, len + 1, fmt,
+							      ap, argvars + 1);
+	}
+    }
+    did_emsg |= saved_did_emsg;
+}
+
+#ifdef FEAT_JOB_CHANNEL
+/*
+ * "prompt_setcallback({buffer}, {callback})" function
+ */
+    static void
+f_prompt_setcallback(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    buf_T	*buf;
+    char_u	*callback;
+    partial_T	*partial;
+
+    if (check_secure())
+	return;
+    buf = get_buf_tv(&argvars[0], FALSE);
+    if (buf == NULL)
+	return;
+
+    callback = get_callback(&argvars[1], &partial);
+    if (callback == NULL)
+	return;
+
+    free_callback(buf->b_prompt_callback, buf->b_prompt_partial);
+    if (partial == NULL)
+	buf->b_prompt_callback = vim_strsave(callback);
+    else
+	/* pointer into the partial */
+	buf->b_prompt_callback = callback;
+    buf->b_prompt_partial = partial;
+}
+
+/*
+ * "prompt_setinterrupt({buffer}, {callback})" function
+ */
+    static void
+f_prompt_setinterrupt(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    buf_T	*buf;
+    char_u	*callback;
+    partial_T	*partial;
+
+    if (check_secure())
+	return;
+    buf = get_buf_tv(&argvars[0], FALSE);
+    if (buf == NULL)
+	return;
+
+    callback = get_callback(&argvars[1], &partial);
+    if (callback == NULL)
+	return;
+
+    free_callback(buf->b_prompt_interrupt, buf->b_prompt_int_partial);
+    if (partial == NULL)
+	buf->b_prompt_interrupt = vim_strsave(callback);
+    else
+	/* pointer into the partial */
+	buf->b_prompt_interrupt = callback;
+    buf->b_prompt_int_partial = partial;
+}
+
+/*
+ * "prompt_setprompt({buffer}, {text})" function
+ */
+    static void
+f_prompt_setprompt(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    buf_T	*buf;
+    char_u	*text;
+
+    if (check_secure())
+	return;
+    buf = get_buf_tv(&argvars[0], FALSE);
+    if (buf == NULL)
+	return;
+
+    text = get_tv_string(&argvars[1]);
+    vim_free(buf->b_prompt_text);
+    buf->b_prompt_text = vim_strsave(text);
+}
+#endif
+
+/*
+ * "pumvisible()" function
+ */
+    static void
+f_pumvisible(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_INS_EXPAND
+    if (pum_visible())
+	rettv->vval.v_number = 1;
+#endif
+}
+
+#ifdef FEAT_PYTHON3
+/*
+ * "py3eval()" function
+ */
+    static void
+f_py3eval(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*str;
+    char_u	buf[NUMBUFLEN];
+
+    if (p_pyx == 0)
+	p_pyx = 3;
+
+    str = get_tv_string_buf(&argvars[0], buf);
+    do_py3eval(str, rettv);
+}
+#endif
+
+#ifdef FEAT_PYTHON
+/*
+ * "pyeval()" function
+ */
+    static void
+f_pyeval(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*str;
+    char_u	buf[NUMBUFLEN];
+
+    if (p_pyx == 0)
+	p_pyx = 2;
+
+    str = get_tv_string_buf(&argvars[0], buf);
+    do_pyeval(str, rettv);
+}
+#endif
+
+#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+/*
+ * "pyxeval()" function
+ */
+    static void
+f_pyxeval(typval_T *argvars, typval_T *rettv)
+{
+# if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
+    init_pyxversion();
+    if (p_pyx == 2)
+	f_pyeval(argvars, rettv);
+    else
+	f_py3eval(argvars, rettv);
+# elif defined(FEAT_PYTHON)
+    f_pyeval(argvars, rettv);
+# elif defined(FEAT_PYTHON3)
+    f_py3eval(argvars, rettv);
+# endif
+}
+#endif
+
+/*
+ * "range()" function
+ */
+    static void
+f_range(typval_T *argvars, typval_T *rettv)
+{
+    varnumber_T	start;
+    varnumber_T	end;
+    varnumber_T	stride = 1;
+    varnumber_T	i;
+    int		error = FALSE;
+
+    start = get_tv_number_chk(&argvars[0], &error);
+    if (argvars[1].v_type == VAR_UNKNOWN)
+    {
+	end = start - 1;
+	start = 0;
+    }
+    else
+    {
+	end = get_tv_number_chk(&argvars[1], &error);
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    stride = get_tv_number_chk(&argvars[2], &error);
+    }
+
+    if (error)
+	return;		/* type error; errmsg already given */
+    if (stride == 0)
+	EMSG(_("E726: Stride is zero"));
+    else if (stride > 0 ? end + 1 < start : end - 1 > start)
+	EMSG(_("E727: Start past end"));
+    else
+    {
+	if (rettv_list_alloc(rettv) == OK)
+	    for (i = start; stride > 0 ? i <= end : i >= end; i += stride)
+		if (list_append_number(rettv->vval.v_list,
+						      (varnumber_T)i) == FAIL)
+		    break;
+    }
+}
+
+/*
+ * "readfile()" function
+ */
+    static void
+f_readfile(typval_T *argvars, typval_T *rettv)
+{
+    int		binary = FALSE;
+    int		failed = FALSE;
+    char_u	*fname;
+    FILE	*fd;
+    char_u	buf[(IOSIZE/256)*256];	/* rounded to avoid odd + 1 */
+    int		io_size = sizeof(buf);
+    int		readlen;		/* size of last fread() */
+    char_u	*prev	 = NULL;	/* previously read bytes, if any */
+    long	prevlen  = 0;		/* length of data in prev */
+    long	prevsize = 0;		/* size of prev buffer */
+    long	maxline  = MAXLNUM;
+    long	cnt	 = 0;
+    char_u	*p;			/* position in buf */
+    char_u	*start;			/* start of current line */
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	if (STRCMP(get_tv_string(&argvars[1]), "b") == 0)
+	    binary = TRUE;
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    maxline = (long)get_tv_number(&argvars[2]);
+    }
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+
+    /* Always open the file in binary mode, library functions have a mind of
+     * their own about CR-LF conversion. */
+    fname = get_tv_string(&argvars[0]);
+    if (*fname == NUL || (fd = mch_fopen((char *)fname, READBIN)) == NULL)
+    {
+	EMSG2(_(e_notopen), *fname == NUL ? (char_u *)_("<empty>") : fname);
+	return;
+    }
+
+    while (cnt < maxline || maxline < 0)
+    {
+	readlen = (int)fread(buf, 1, io_size, fd);
+
+	/* This for loop processes what was read, but is also entered at end
+	 * of file so that either:
+	 * - an incomplete line gets written
+	 * - a "binary" file gets an empty line at the end if it ends in a
+	 *   newline.  */
+	for (p = buf, start = buf;
+		p < buf + readlen || (readlen <= 0 && (prevlen > 0 || binary));
+		++p)
+	{
+	    if (*p == '\n' || readlen <= 0)
+	    {
+		listitem_T  *li;
+		char_u	    *s	= NULL;
+		long_u	    len = p - start;
+
+		/* Finished a line.  Remove CRs before NL. */
+		if (readlen > 0 && !binary)
+		{
+		    while (len > 0 && start[len - 1] == '\r')
+			--len;
+		    /* removal may cross back to the "prev" string */
+		    if (len == 0)
+			while (prevlen > 0 && prev[prevlen - 1] == '\r')
+			    --prevlen;
+		}
+		if (prevlen == 0)
+		    s = vim_strnsave(start, (int)len);
+		else
+		{
+		    /* Change "prev" buffer to be the right size.  This way
+		     * the bytes are only copied once, and very long lines are
+		     * allocated only once.  */
+		    if ((s = vim_realloc(prev, prevlen + len + 1)) != NULL)
+		    {
+			mch_memmove(s + prevlen, start, len);
+			s[prevlen + len] = NUL;
+			prev = NULL; /* the list will own the string */
+			prevlen = prevsize = 0;
+		    }
+		}
+		if (s == NULL)
+		{
+		    do_outofmem_msg((long_u) prevlen + len + 1);
+		    failed = TRUE;
+		    break;
+		}
+
+		if ((li = listitem_alloc()) == NULL)
+		{
+		    vim_free(s);
+		    failed = TRUE;
+		    break;
+		}
+		li->li_tv.v_type = VAR_STRING;
+		li->li_tv.v_lock = 0;
+		li->li_tv.vval.v_string = s;
+		list_append(rettv->vval.v_list, li);
+
+		start = p + 1; /* step over newline */
+		if ((++cnt >= maxline && maxline >= 0) || readlen <= 0)
+		    break;
+	    }
+	    else if (*p == NUL)
+		*p = '\n';
+#ifdef FEAT_MBYTE
+	    /* Check for utf8 "bom"; U+FEFF is encoded as EF BB BF.  Do this
+	     * when finding the BF and check the previous two bytes. */
+	    else if (*p == 0xbf && enc_utf8 && !binary)
+	    {
+		/* Find the two bytes before the 0xbf.	If p is at buf, or buf
+		 * + 1, these may be in the "prev" string. */
+		char_u back1 = p >= buf + 1 ? p[-1]
+				     : prevlen >= 1 ? prev[prevlen - 1] : NUL;
+		char_u back2 = p >= buf + 2 ? p[-2]
+			  : p == buf + 1 && prevlen >= 1 ? prev[prevlen - 1]
+			  : prevlen >= 2 ? prev[prevlen - 2] : NUL;
+
+		if (back2 == 0xef && back1 == 0xbb)
+		{
+		    char_u *dest = p - 2;
+
+		    /* Usually a BOM is at the beginning of a file, and so at
+		     * the beginning of a line; then we can just step over it.
+		     */
+		    if (start == dest)
+			start = p + 1;
+		    else
+		    {
+			/* have to shuffle buf to close gap */
+			int adjust_prevlen = 0;
+
+			if (dest < buf)
+			{
+			    adjust_prevlen = (int)(buf - dest); /* must be 1 or 2 */
+			    dest = buf;
+			}
+			if (readlen > p - buf + 1)
+			    mch_memmove(dest, p + 1, readlen - (p - buf) - 1);
+			readlen -= 3 - adjust_prevlen;
+			prevlen -= adjust_prevlen;
+			p = dest - 1;
+		    }
+		}
+	    }
+#endif
+	} /* for */
+
+	if (failed || (cnt >= maxline && maxline >= 0) || readlen <= 0)
+	    break;
+	if (start < p)
+	{
+	    /* There's part of a line in buf, store it in "prev". */
+	    if (p - start + prevlen >= prevsize)
+	    {
+		/* need bigger "prev" buffer */
+		char_u *newprev;
+
+		/* A common use case is ordinary text files and "prev" gets a
+		 * fragment of a line, so the first allocation is made
+		 * small, to avoid repeatedly 'allocing' large and
+		 * 'reallocing' small. */
+		if (prevsize == 0)
+		    prevsize = (long)(p - start);
+		else
+		{
+		    long grow50pc = (prevsize * 3) / 2;
+		    long growmin  = (long)((p - start) * 2 + prevlen);
+		    prevsize = grow50pc > growmin ? grow50pc : growmin;
+		}
+		newprev = prev == NULL ? alloc(prevsize)
+						: vim_realloc(prev, prevsize);
+		if (newprev == NULL)
+		{
+		    do_outofmem_msg((long_u)prevsize);
+		    failed = TRUE;
+		    break;
+		}
+		prev = newprev;
+	    }
+	    /* Add the line part to end of "prev". */
+	    mch_memmove(prev + prevlen, start, p - start);
+	    prevlen += (long)(p - start);
+	}
+    } /* while */
+
+    /*
+     * For a negative line count use only the lines at the end of the file,
+     * free the rest.
+     */
+    if (!failed && maxline < 0)
+	while (cnt > -maxline)
+	{
+	    listitem_remove(rettv->vval.v_list, rettv->vval.v_list->lv_first);
+	    --cnt;
+	}
+
+    if (failed)
+    {
+	list_free(rettv->vval.v_list);
+	/* readfile doc says an empty list is returned on error */
+	rettv->vval.v_list = list_alloc();
+    }
+
+    vim_free(prev);
+    fclose(fd);
+}
+
+    static void
+return_register(int regname, typval_T *rettv)
+{
+    char_u buf[2] = {0, 0};
+
+    buf[0] = (char_u)regname;
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = vim_strsave(buf);
+}
+
+/*
+ * "reg_executing()" function
+ */
+    static void
+f_reg_executing(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    return_register(reg_executing, rettv);
+}
+
+/*
+ * "reg_recording()" function
+ */
+    static void
+f_reg_recording(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    return_register(reg_recording, rettv);
+}
+
+#if defined(FEAT_RELTIME)
+static int list2proftime(typval_T *arg, proftime_T *tm);
+
+/*
+ * Convert a List to proftime_T.
+ * Return FAIL when there is something wrong.
+ */
+    static int
+list2proftime(typval_T *arg, proftime_T *tm)
+{
+    long	n1, n2;
+    int	error = FALSE;
+
+    if (arg->v_type != VAR_LIST || arg->vval.v_list == NULL
+					     || arg->vval.v_list->lv_len != 2)
+	return FAIL;
+    n1 = list_find_nr(arg->vval.v_list, 0L, &error);
+    n2 = list_find_nr(arg->vval.v_list, 1L, &error);
+# ifdef WIN3264
+    tm->HighPart = n1;
+    tm->LowPart = n2;
+# else
+    tm->tv_sec = n1;
+    tm->tv_usec = n2;
+# endif
+    return error ? FAIL : OK;
+}
+#endif /* FEAT_RELTIME */
+
+/*
+ * "reltime()" function
+ */
+    static void
+f_reltime(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_RELTIME
+    proftime_T	res;
+    proftime_T	start;
+
+    if (argvars[0].v_type == VAR_UNKNOWN)
+    {
+	/* No arguments: get current time. */
+	profile_start(&res);
+    }
+    else if (argvars[1].v_type == VAR_UNKNOWN)
+    {
+	if (list2proftime(&argvars[0], &res) == FAIL)
+	    return;
+	profile_end(&res);
+    }
+    else
+    {
+	/* Two arguments: compute the difference. */
+	if (list2proftime(&argvars[0], &start) == FAIL
+		|| list2proftime(&argvars[1], &res) == FAIL)
+	    return;
+	profile_sub(&res, &start);
+    }
+
+    if (rettv_list_alloc(rettv) == OK)
+    {
+	long	n1, n2;
+
+# ifdef WIN3264
+	n1 = res.HighPart;
+	n2 = res.LowPart;
+# else
+	n1 = res.tv_sec;
+	n2 = res.tv_usec;
+# endif
+	list_append_number(rettv->vval.v_list, (varnumber_T)n1);
+	list_append_number(rettv->vval.v_list, (varnumber_T)n2);
+    }
+#endif
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "reltimefloat()" function
+ */
+    static void
+f_reltimefloat(typval_T *argvars UNUSED, typval_T *rettv)
+{
+# ifdef FEAT_RELTIME
+    proftime_T	tm;
+# endif
+
+    rettv->v_type = VAR_FLOAT;
+    rettv->vval.v_float = 0;
+# ifdef FEAT_RELTIME
+    if (list2proftime(&argvars[0], &tm) == OK)
+	rettv->vval.v_float = profile_float(&tm);
+# endif
+}
+#endif
+
+/*
+ * "reltimestr()" function
+ */
+    static void
+f_reltimestr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_RELTIME
+    proftime_T	tm;
+#endif
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_RELTIME
+    if (list2proftime(&argvars[0], &tm) == OK)
+	rettv->vval.v_string = vim_strsave((char_u *)profile_msg(&tm));
+#endif
+}
+
+#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)
+static void make_connection(void);
+static int check_connection(void);
+
+    static void
+make_connection(void)
+{
+    if (X_DISPLAY == NULL
+# ifdef FEAT_GUI
+	    && !gui.in_use
+# endif
+	    )
+    {
+	x_force_connect = TRUE;
+	setup_term_clip();
+	x_force_connect = FALSE;
+    }
+}
+
+    static int
+check_connection(void)
+{
+    make_connection();
+    if (X_DISPLAY == NULL)
+    {
+	EMSG(_("E240: No connection to the X server"));
+	return FAIL;
+    }
+    return OK;
+}
+#endif
+
+#ifdef FEAT_CLIENTSERVER
+    static void
+remote_common(typval_T *argvars, typval_T *rettv, int expr)
+{
+    char_u	*server_name;
+    char_u	*keys;
+    char_u	*r = NULL;
+    char_u	buf[NUMBUFLEN];
+    int		timeout = 0;
+# ifdef WIN32
+    HWND	w;
+# else
+    Window	w;
+# endif
+
+    if (check_restricted() || check_secure())
+	return;
+
+# ifdef FEAT_X11
+    if (check_connection() == FAIL)
+	return;
+# endif
+    if (argvars[2].v_type != VAR_UNKNOWN
+	    && argvars[3].v_type != VAR_UNKNOWN)
+	timeout = get_tv_number(&argvars[3]);
+
+    server_name = get_tv_string_chk(&argvars[0]);
+    if (server_name == NULL)
+	return;		/* type error; errmsg already given */
+    keys = get_tv_string_buf(&argvars[1], buf);
+# ifdef WIN32
+    if (serverSendToVim(server_name, keys, &r, &w, expr, timeout, TRUE) < 0)
+# else
+    if (serverSendToVim(X_DISPLAY, server_name, keys, &r, &w, expr, timeout,
+								  0, TRUE) < 0)
+# endif
+    {
+	if (r != NULL)
+	{
+	    EMSG(r);		/* sending worked but evaluation failed */
+	    vim_free(r);
+	}
+	else
+	    EMSG2(_("E241: Unable to send to %s"), server_name);
+	return;
+    }
+
+    rettv->vval.v_string = r;
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	dictitem_T	v;
+	char_u		str[30];
+	char_u		*idvar;
+
+	idvar = get_tv_string_chk(&argvars[2]);
+	if (idvar != NULL && *idvar != NUL)
+	{
+	    sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
+	    v.di_tv.v_type = VAR_STRING;
+	    v.di_tv.vval.v_string = vim_strsave(str);
+	    set_var(idvar, &v.di_tv, FALSE);
+	    vim_free(v.di_tv.vval.v_string);
+	}
+    }
+}
+#endif
+
+/*
+ * "remote_expr()" function
+ */
+    static void
+f_remote_expr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_CLIENTSERVER
+    remote_common(argvars, rettv, TRUE);
+#endif
+}
+
+/*
+ * "remote_foreground()" function
+ */
+    static void
+f_remote_foreground(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_CLIENTSERVER
+# ifdef WIN32
+    /* On Win32 it's done in this application. */
+    {
+	char_u	*server_name = get_tv_string_chk(&argvars[0]);
+
+	if (server_name != NULL)
+	    serverForeground(server_name);
+    }
+# else
+    /* Send a foreground() expression to the server. */
+    argvars[1].v_type = VAR_STRING;
+    argvars[1].vval.v_string = vim_strsave((char_u *)"foreground()");
+    argvars[2].v_type = VAR_UNKNOWN;
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+    remote_common(argvars, rettv, TRUE);
+    vim_free(argvars[1].vval.v_string);
+# endif
+#endif
+}
+
+    static void
+f_remote_peek(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_CLIENTSERVER
+    dictitem_T	v;
+    char_u	*s = NULL;
+# ifdef WIN32
+    long_u	n = 0;
+# endif
+    char_u	*serverid;
+
+    if (check_restricted() || check_secure())
+    {
+	rettv->vval.v_number = -1;
+	return;
+    }
+    serverid = get_tv_string_chk(&argvars[0]);
+    if (serverid == NULL)
+    {
+	rettv->vval.v_number = -1;
+	return;		/* type error; errmsg already given */
+    }
+# ifdef WIN32
+    sscanf((const char *)serverid, SCANF_HEX_LONG_U, &n);
+    if (n == 0)
+	rettv->vval.v_number = -1;
+    else
+    {
+	s = serverGetReply((HWND)n, FALSE, FALSE, FALSE, 0);
+	rettv->vval.v_number = (s != NULL);
+    }
+# else
+    if (check_connection() == FAIL)
+	return;
+
+    rettv->vval.v_number = serverPeekReply(X_DISPLAY,
+						serverStrToWin(serverid), &s);
+# endif
+
+    if (argvars[1].v_type != VAR_UNKNOWN && rettv->vval.v_number > 0)
+    {
+	char_u		*retvar;
+
+	v.di_tv.v_type = VAR_STRING;
+	v.di_tv.vval.v_string = vim_strsave(s);
+	retvar = get_tv_string_chk(&argvars[1]);
+	if (retvar != NULL)
+	    set_var(retvar, &v.di_tv, FALSE);
+	vim_free(v.di_tv.vval.v_string);
+    }
+#else
+    rettv->vval.v_number = -1;
+#endif
+}
+
+    static void
+f_remote_read(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    char_u	*r = NULL;
+
+#ifdef FEAT_CLIENTSERVER
+    char_u	*serverid = get_tv_string_chk(&argvars[0]);
+
+    if (serverid != NULL && !check_restricted() && !check_secure())
+    {
+	int timeout = 0;
+# ifdef WIN32
+	/* The server's HWND is encoded in the 'id' parameter */
+	long_u		n = 0;
+# endif
+
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	    timeout = get_tv_number(&argvars[1]);
+
+# ifdef WIN32
+	sscanf((char *)serverid, SCANF_HEX_LONG_U, &n);
+	if (n != 0)
+	    r = serverGetReply((HWND)n, FALSE, TRUE, TRUE, timeout);
+	if (r == NULL)
+# else
+	if (check_connection() == FAIL
+		|| serverReadReply(X_DISPLAY, serverStrToWin(serverid),
+						       &r, FALSE, timeout) < 0)
+# endif
+	    EMSG(_("E277: Unable to read a server reply"));
+    }
+#endif
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = r;
+}
+
+/*
+ * "remote_send()" function
+ */
+    static void
+f_remote_send(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_CLIENTSERVER
+    remote_common(argvars, rettv, FALSE);
+#endif
+}
+
+/*
+ * "remote_startserver()" function
+ */
+    static void
+f_remote_startserver(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_CLIENTSERVER
+    char_u	*server = get_tv_string_chk(&argvars[0]);
+
+    if (server == NULL)
+	return;		/* type error; errmsg already given */
+    if (serverName != NULL)
+	EMSG(_("E941: already started a server"));
+    else
+    {
+# ifdef FEAT_X11
+	if (check_connection() == OK)
+	    serverRegisterName(X_DISPLAY, server);
+# else
+	serverSetName(server);
+# endif
+    }
+#else
+    EMSG(_("E942: +clientserver feature not available"));
+#endif
+}
+
+/*
+ * "remove()" function
+ */
+    static void
+f_remove(typval_T *argvars, typval_T *rettv)
+{
+    list_T	*l;
+    listitem_T	*item, *item2;
+    listitem_T	*li;
+    long	idx;
+    long	end;
+    char_u	*key;
+    dict_T	*d;
+    dictitem_T	*di;
+    char_u	*arg_errmsg = (char_u *)N_("remove() argument");
+
+    if (argvars[0].v_type == VAR_DICT)
+    {
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    EMSG2(_(e_toomanyarg), "remove()");
+	else if ((d = argvars[0].vval.v_dict) != NULL
+		&& !tv_check_lock(d->dv_lock, arg_errmsg, TRUE))
+	{
+	    key = get_tv_string_chk(&argvars[1]);
+	    if (key != NULL)
+	    {
+		di = dict_find(d, key, -1);
+		if (di == NULL)
+		    EMSG2(_(e_dictkey), key);
+		else if (!var_check_fixed(di->di_flags, arg_errmsg, TRUE)
+			    && !var_check_ro(di->di_flags, arg_errmsg, TRUE))
+		{
+		    *rettv = di->di_tv;
+		    init_tv(&di->di_tv);
+		    dictitem_remove(d, di);
+		}
+	    }
+	}
+    }
+    else if (argvars[0].v_type != VAR_LIST)
+	EMSG2(_(e_listdictarg), "remove()");
+    else if ((l = argvars[0].vval.v_list) != NULL
+	    && !tv_check_lock(l->lv_lock, arg_errmsg, TRUE))
+    {
+	int	    error = FALSE;
+
+	idx = (long)get_tv_number_chk(&argvars[1], &error);
+	if (error)
+	    ;		/* type error: do nothing, errmsg already given */
+	else if ((item = list_find(l, idx)) == NULL)
+	    EMSGN(_(e_listidx), idx);
+	else
+	{
+	    if (argvars[2].v_type == VAR_UNKNOWN)
+	    {
+		/* Remove one item, return its value. */
+		vimlist_remove(l, item, item);
+		*rettv = item->li_tv;
+		vim_free(item);
+	    }
+	    else
+	    {
+		/* Remove range of items, return list with values. */
+		end = (long)get_tv_number_chk(&argvars[2], &error);
+		if (error)
+		    ;		/* type error: do nothing */
+		else if ((item2 = list_find(l, end)) == NULL)
+		    EMSGN(_(e_listidx), end);
+		else
+		{
+		    int	    cnt = 0;
+
+		    for (li = item; li != NULL; li = li->li_next)
+		    {
+			++cnt;
+			if (li == item2)
+			    break;
+		    }
+		    if (li == NULL)  /* didn't find "item2" after "item" */
+			EMSG(_(e_invrange));
+		    else
+		    {
+			vimlist_remove(l, item, item2);
+			if (rettv_list_alloc(rettv) == OK)
+			{
+			    l = rettv->vval.v_list;
+			    l->lv_first = item;
+			    l->lv_last = item2;
+			    item->li_prev = NULL;
+			    item2->li_next = NULL;
+			    l->lv_len = cnt;
+			}
+		    }
+		}
+	    }
+	}
+    }
+}
+
+/*
+ * "rename({from}, {to})" function
+ */
+    static void
+f_rename(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf[NUMBUFLEN];
+
+    if (check_restricted() || check_secure())
+	rettv->vval.v_number = -1;
+    else
+	rettv->vval.v_number = vim_rename(get_tv_string(&argvars[0]),
+				      get_tv_string_buf(&argvars[1], buf));
+}
+
+/*
+ * "repeat()" function
+ */
+    static void
+f_repeat(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*p;
+    int		n;
+    int		slen;
+    int		len;
+    char_u	*r;
+    int		i;
+
+    n = (int)get_tv_number(&argvars[1]);
+    if (argvars[0].v_type == VAR_LIST)
+    {
+	if (rettv_list_alloc(rettv) == OK && argvars[0].vval.v_list != NULL)
+	    while (n-- > 0)
+		if (list_extend(rettv->vval.v_list,
+					argvars[0].vval.v_list, NULL) == FAIL)
+		    break;
+    }
+    else
+    {
+	p = get_tv_string(&argvars[0]);
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = NULL;
+
+	slen = (int)STRLEN(p);
+	len = slen * n;
+	if (len <= 0)
+	    return;
+
+	r = alloc(len + 1);
+	if (r != NULL)
+	{
+	    for (i = 0; i < n; i++)
+		mch_memmove(r + i * slen, p, (size_t)slen);
+	    r[len] = NUL;
+	}
+
+	rettv->vval.v_string = r;
+    }
+}
+
+/*
+ * "resolve()" function
+ */
+    static void
+f_resolve(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*p;
+#ifdef HAVE_READLINK
+    char_u	*buf = NULL;
+#endif
+
+    p = get_tv_string(&argvars[0]);
+#ifdef FEAT_SHORTCUT
+    {
+	char_u	*v = NULL;
+
+	v = mch_resolve_shortcut(p);
+	if (v != NULL)
+	    rettv->vval.v_string = v;
+	else
+	    rettv->vval.v_string = vim_strsave(p);
+    }
+#else
+# ifdef HAVE_READLINK
+    {
+	char_u	*cpy;
+	int	len;
+	char_u	*remain = NULL;
+	char_u	*q;
+	int	is_relative_to_current = FALSE;
+	int	has_trailing_pathsep = FALSE;
+	int	limit = 100;
+
+	p = vim_strsave(p);
+
+	if (p[0] == '.' && (vim_ispathsep(p[1])
+				   || (p[1] == '.' && (vim_ispathsep(p[2])))))
+	    is_relative_to_current = TRUE;
+
+	len = STRLEN(p);
+	if (len > 0 && after_pathsep(p, p + len))
+	{
+	    has_trailing_pathsep = TRUE;
+	    p[len - 1] = NUL; /* the trailing slash breaks readlink() */
+	}
+
+	q = getnextcomp(p);
+	if (*q != NUL)
+	{
+	    /* Separate the first path component in "p", and keep the
+	     * remainder (beginning with the path separator). */
+	    remain = vim_strsave(q - 1);
+	    q[-1] = NUL;
+	}
+
+	buf = alloc(MAXPATHL + 1);
+	if (buf == NULL)
+	    goto fail;
+
+	for (;;)
+	{
+	    for (;;)
+	    {
+		len = readlink((char *)p, (char *)buf, MAXPATHL);
+		if (len <= 0)
+		    break;
+		buf[len] = NUL;
+
+		if (limit-- == 0)
+		{
+		    vim_free(p);
+		    vim_free(remain);
+		    EMSG(_("E655: Too many symbolic links (cycle?)"));
+		    rettv->vval.v_string = NULL;
+		    goto fail;
+		}
+
+		/* Ensure that the result will have a trailing path separator
+		 * if the argument has one. */
+		if (remain == NULL && has_trailing_pathsep)
+		    add_pathsep(buf);
+
+		/* Separate the first path component in the link value and
+		 * concatenate the remainders. */
+		q = getnextcomp(vim_ispathsep(*buf) ? buf + 1 : buf);
+		if (*q != NUL)
+		{
+		    if (remain == NULL)
+			remain = vim_strsave(q - 1);
+		    else
+		    {
+			cpy = concat_str(q - 1, remain);
+			if (cpy != NULL)
+			{
+			    vim_free(remain);
+			    remain = cpy;
+			}
+		    }
+		    q[-1] = NUL;
+		}
+
+		q = gettail(p);
+		if (q > p && *q == NUL)
+		{
+		    /* Ignore trailing path separator. */
+		    q[-1] = NUL;
+		    q = gettail(p);
+		}
+		if (q > p && !mch_isFullName(buf))
+		{
+		    /* symlink is relative to directory of argument */
+		    cpy = alloc((unsigned)(STRLEN(p) + STRLEN(buf) + 1));
+		    if (cpy != NULL)
+		    {
+			STRCPY(cpy, p);
+			STRCPY(gettail(cpy), buf);
+			vim_free(p);
+			p = cpy;
+		    }
+		}
+		else
+		{
+		    vim_free(p);
+		    p = vim_strsave(buf);
+		}
+	    }
+
+	    if (remain == NULL)
+		break;
+
+	    /* Append the first path component of "remain" to "p". */
+	    q = getnextcomp(remain + 1);
+	    len = q - remain - (*q != NUL);
+	    cpy = vim_strnsave(p, STRLEN(p) + len);
+	    if (cpy != NULL)
+	    {
+		STRNCAT(cpy, remain, len);
+		vim_free(p);
+		p = cpy;
+	    }
+	    /* Shorten "remain". */
+	    if (*q != NUL)
+		STRMOVE(remain, q - 1);
+	    else
+		VIM_CLEAR(remain);
+	}
+
+	/* If the result is a relative path name, make it explicitly relative to
+	 * the current directory if and only if the argument had this form. */
+	if (!vim_ispathsep(*p))
+	{
+	    if (is_relative_to_current
+		    && *p != NUL
+		    && !(p[0] == '.'
+			&& (p[1] == NUL
+			    || vim_ispathsep(p[1])
+			    || (p[1] == '.'
+				&& (p[2] == NUL
+				    || vim_ispathsep(p[2]))))))
+	    {
+		/* Prepend "./". */
+		cpy = concat_str((char_u *)"./", p);
+		if (cpy != NULL)
+		{
+		    vim_free(p);
+		    p = cpy;
+		}
+	    }
+	    else if (!is_relative_to_current)
+	    {
+		/* Strip leading "./". */
+		q = p;
+		while (q[0] == '.' && vim_ispathsep(q[1]))
+		    q += 2;
+		if (q > p)
+		    STRMOVE(p, p + 2);
+	    }
+	}
+
+	/* Ensure that the result will have no trailing path separator
+	 * if the argument had none.  But keep "/" or "//". */
+	if (!has_trailing_pathsep)
+	{
+	    q = p + STRLEN(p);
+	    if (after_pathsep(p, q))
+		*gettail_sep(p) = NUL;
+	}
+
+	rettv->vval.v_string = p;
+    }
+# else
+    rettv->vval.v_string = vim_strsave(p);
+# endif
+#endif
+
+    simplify_filename(rettv->vval.v_string);
+
+#ifdef HAVE_READLINK
+fail:
+    vim_free(buf);
+#endif
+    rettv->v_type = VAR_STRING;
+}
+
+/*
+ * "reverse({list})" function
+ */
+    static void
+f_reverse(typval_T *argvars, typval_T *rettv)
+{
+    list_T	*l;
+    listitem_T	*li, *ni;
+
+    if (argvars[0].v_type != VAR_LIST)
+	EMSG2(_(e_listarg), "reverse()");
+    else if ((l = argvars[0].vval.v_list) != NULL
+	    && !tv_check_lock(l->lv_lock,
+				    (char_u *)N_("reverse() argument"), TRUE))
+    {
+	li = l->lv_last;
+	l->lv_first = l->lv_last = NULL;
+	l->lv_len = 0;
+	while (li != NULL)
+	{
+	    ni = li->li_prev;
+	    list_append(l, li);
+	    li = ni;
+	}
+	rettv_list_set(rettv, l);
+	l->lv_idx = l->lv_len - l->lv_idx - 1;
+    }
+}
+
+#define SP_NOMOVE	0x01	    /* don't move cursor */
+#define SP_REPEAT	0x02	    /* repeat to find outer pair */
+#define SP_RETCOUNT	0x04	    /* return matchcount */
+#define SP_SETPCMARK	0x08	    /* set previous context mark */
+#define SP_START	0x10	    /* accept match at start position */
+#define SP_SUBPAT	0x20	    /* return nr of matching sub-pattern */
+#define SP_END		0x40	    /* leave cursor at end of match */
+#define SP_COLUMN	0x80	    /* start at cursor column */
+
+static int get_search_arg(typval_T *varp, int *flagsp);
+
+/*
+ * Get flags for a search function.
+ * Possibly sets "p_ws".
+ * Returns BACKWARD, FORWARD or zero (for an error).
+ */
+    static int
+get_search_arg(typval_T *varp, int *flagsp)
+{
+    int		dir = FORWARD;
+    char_u	*flags;
+    char_u	nbuf[NUMBUFLEN];
+    int		mask;
+
+    if (varp->v_type != VAR_UNKNOWN)
+    {
+	flags = get_tv_string_buf_chk(varp, nbuf);
+	if (flags == NULL)
+	    return 0;		/* type error; errmsg already given */
+	while (*flags != NUL)
+	{
+	    switch (*flags)
+	    {
+		case 'b': dir = BACKWARD; break;
+		case 'w': p_ws = TRUE; break;
+		case 'W': p_ws = FALSE; break;
+		default:  mask = 0;
+			  if (flagsp != NULL)
+			     switch (*flags)
+			     {
+				 case 'c': mask = SP_START; break;
+				 case 'e': mask = SP_END; break;
+				 case 'm': mask = SP_RETCOUNT; break;
+				 case 'n': mask = SP_NOMOVE; break;
+				 case 'p': mask = SP_SUBPAT; break;
+				 case 'r': mask = SP_REPEAT; break;
+				 case 's': mask = SP_SETPCMARK; break;
+				 case 'z': mask = SP_COLUMN; break;
+			     }
+			  if (mask == 0)
+			  {
+			      EMSG2(_(e_invarg2), flags);
+			      dir = 0;
+			  }
+			  else
+			      *flagsp |= mask;
+	    }
+	    if (dir == 0)
+		break;
+	    ++flags;
+	}
+    }
+    return dir;
+}
+
+/*
+ * Shared by search() and searchpos() functions.
+ */
+    static int
+search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)
+{
+    int		flags;
+    char_u	*pat;
+    pos_T	pos;
+    pos_T	save_cursor;
+    int		save_p_ws = p_ws;
+    int		dir;
+    int		retval = 0;	/* default: FAIL */
+    long	lnum_stop = 0;
+    proftime_T	tm;
+#ifdef FEAT_RELTIME
+    long	time_limit = 0;
+#endif
+    int		options = SEARCH_KEEP;
+    int		subpatnum;
+
+    pat = get_tv_string(&argvars[0]);
+    dir = get_search_arg(&argvars[1], flagsp);	/* may set p_ws */
+    if (dir == 0)
+	goto theend;
+    flags = *flagsp;
+    if (flags & SP_START)
+	options |= SEARCH_START;
+    if (flags & SP_END)
+	options |= SEARCH_END;
+    if (flags & SP_COLUMN)
+	options |= SEARCH_COL;
+
+    /* Optional arguments: line number to stop searching and timeout. */
+    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN)
+    {
+	lnum_stop = (long)get_tv_number_chk(&argvars[2], NULL);
+	if (lnum_stop < 0)
+	    goto theend;
+#ifdef FEAT_RELTIME
+	if (argvars[3].v_type != VAR_UNKNOWN)
+	{
+	    time_limit = (long)get_tv_number_chk(&argvars[3], NULL);
+	    if (time_limit < 0)
+		goto theend;
+	}
+#endif
+    }
+
+#ifdef FEAT_RELTIME
+    /* Set the time limit, if there is one. */
+    profile_setlimit(time_limit, &tm);
+#endif
+
+    /*
+     * This function does not accept SP_REPEAT and SP_RETCOUNT flags.
+     * Check to make sure only those flags are set.
+     * Also, Only the SP_NOMOVE or the SP_SETPCMARK flag can be set. Both
+     * flags cannot be set. Check for that condition also.
+     */
+    if (((flags & (SP_REPEAT | SP_RETCOUNT)) != 0)
+	    || ((flags & SP_NOMOVE) && (flags & SP_SETPCMARK)))
+    {
+	EMSG2(_(e_invarg2), get_tv_string(&argvars[1]));
+	goto theend;
+    }
+
+    pos = save_cursor = curwin->w_cursor;
+    subpatnum = searchit(curwin, curbuf, &pos, dir, pat, 1L,
+			   options, RE_SEARCH, (linenr_T)lnum_stop, &tm, NULL);
+    if (subpatnum != FAIL)
+    {
+	if (flags & SP_SUBPAT)
+	    retval = subpatnum;
+	else
+	    retval = pos.lnum;
+	if (flags & SP_SETPCMARK)
+	    setpcmark();
+	curwin->w_cursor = pos;
+	if (match_pos != NULL)
+	{
+	    /* Store the match cursor position */
+	    match_pos->lnum = pos.lnum;
+	    match_pos->col = pos.col + 1;
+	}
+	/* "/$" will put the cursor after the end of the line, may need to
+	 * correct that here */
+	check_cursor();
+    }
+
+    /* If 'n' flag is used: restore cursor position. */
+    if (flags & SP_NOMOVE)
+	curwin->w_cursor = save_cursor;
+    else
+	curwin->w_set_curswant = TRUE;
+theend:
+    p_ws = save_p_ws;
+
+    return retval;
+}
+
+#ifdef FEAT_FLOAT
+
+/*
+ * round() is not in C90, use ceil() or floor() instead.
+ */
+    float_T
+vim_round(float_T f)
+{
+    return f > 0 ? floor(f + 0.5) : ceil(f - 0.5);
+}
+
+/*
+ * "round({float})" function
+ */
+    static void
+f_round(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = vim_round(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "screenattr()" function
+ */
+    static void
+f_screenattr(typval_T *argvars, typval_T *rettv)
+{
+    int		row;
+    int		col;
+    int		c;
+
+    row = (int)get_tv_number_chk(&argvars[0], NULL) - 1;
+    col = (int)get_tv_number_chk(&argvars[1], NULL) - 1;
+    if (row < 0 || row >= screen_Rows
+	    || col < 0 || col >= screen_Columns)
+	c = -1;
+    else
+	c = ScreenAttrs[LineOffset[row] + col];
+    rettv->vval.v_number = c;
+}
+
+/*
+ * "screenchar()" function
+ */
+    static void
+f_screenchar(typval_T *argvars, typval_T *rettv)
+{
+    int		row;
+    int		col;
+    int		off;
+    int		c;
+
+    row = (int)get_tv_number_chk(&argvars[0], NULL) - 1;
+    col = (int)get_tv_number_chk(&argvars[1], NULL) - 1;
+    if (row < 0 || row >= screen_Rows
+	    || col < 0 || col >= screen_Columns)
+	c = -1;
+    else
+    {
+	off = LineOffset[row] + col;
+#ifdef FEAT_MBYTE
+	if (enc_utf8 && ScreenLinesUC[off] != 0)
+	    c = ScreenLinesUC[off];
+	else
+#endif
+	    c = ScreenLines[off];
+    }
+    rettv->vval.v_number = c;
+}
+
+/*
+ * "screencol()" function
+ *
+ * First column is 1 to be consistent with virtcol().
+ */
+    static void
+f_screencol(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = screen_screencol() + 1;
+}
+
+/*
+ * "screenrow()" function
+ */
+    static void
+f_screenrow(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = screen_screenrow() + 1;
+}
+
+/*
+ * "search()" function
+ */
+    static void
+f_search(typval_T *argvars, typval_T *rettv)
+{
+    int		flags = 0;
+
+    rettv->vval.v_number = search_cmn(argvars, NULL, &flags);
+}
+
+/*
+ * "searchdecl()" function
+ */
+    static void
+f_searchdecl(typval_T *argvars, typval_T *rettv)
+{
+    int		locally = 1;
+    int		thisblock = 0;
+    int		error = FALSE;
+    char_u	*name;
+
+    rettv->vval.v_number = 1;	/* default: FAIL */
+
+    name = get_tv_string_chk(&argvars[0]);
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	locally = (int)get_tv_number_chk(&argvars[1], &error) == 0;
+	if (!error && argvars[2].v_type != VAR_UNKNOWN)
+	    thisblock = (int)get_tv_number_chk(&argvars[2], &error) != 0;
+    }
+    if (!error && name != NULL)
+	rettv->vval.v_number = find_decl(name, (int)STRLEN(name),
+				     locally, thisblock, SEARCH_KEEP) == FAIL;
+}
+
+/*
+ * Used by searchpair() and searchpairpos()
+ */
+    static int
+searchpair_cmn(typval_T *argvars, pos_T *match_pos)
+{
+    char_u	*spat, *mpat, *epat;
+    typval_T	*skip;
+    int		save_p_ws = p_ws;
+    int		dir;
+    int		flags = 0;
+    char_u	nbuf1[NUMBUFLEN];
+    char_u	nbuf2[NUMBUFLEN];
+    int		retval = 0;		/* default: FAIL */
+    long	lnum_stop = 0;
+    long	time_limit = 0;
+
+    /* Get the three pattern arguments: start, middle, end. Will result in an
+     * error if not a valid argument. */
+    spat = get_tv_string_chk(&argvars[0]);
+    mpat = get_tv_string_buf_chk(&argvars[1], nbuf1);
+    epat = get_tv_string_buf_chk(&argvars[2], nbuf2);
+    if (spat == NULL || mpat == NULL || epat == NULL)
+	goto theend;	    /* type error */
+
+    /* Handle the optional fourth argument: flags */
+    dir = get_search_arg(&argvars[3], &flags); /* may set p_ws */
+    if (dir == 0)
+	goto theend;
+
+    /* Don't accept SP_END or SP_SUBPAT.
+     * Only one of the SP_NOMOVE or SP_SETPCMARK flags can be set.
+     */
+    if ((flags & (SP_END | SP_SUBPAT)) != 0
+	    || ((flags & SP_NOMOVE) && (flags & SP_SETPCMARK)))
+    {
+	EMSG2(_(e_invarg2), get_tv_string(&argvars[3]));
+	goto theend;
+    }
+
+    /* Using 'r' implies 'W', otherwise it doesn't work. */
+    if (flags & SP_REPEAT)
+	p_ws = FALSE;
+
+    /* Optional fifth argument: skip expression */
+    if (argvars[3].v_type == VAR_UNKNOWN
+	    || argvars[4].v_type == VAR_UNKNOWN)
+	skip = NULL;
+    else
+    {
+	skip = &argvars[4];
+	if (skip->v_type != VAR_FUNC && skip->v_type != VAR_PARTIAL
+	    && skip->v_type != VAR_STRING)
+	{
+	    /* Type error */
+	    EMSG2(_(e_invarg2), get_tv_string(&argvars[4]));
+	    goto theend;
+	}
+	if (argvars[5].v_type != VAR_UNKNOWN)
+	{
+	    lnum_stop = (long)get_tv_number_chk(&argvars[5], NULL);
+	    if (lnum_stop < 0)
+	    {
+		EMSG2(_(e_invarg2), get_tv_string(&argvars[5]));
+		goto theend;
+	    }
+#ifdef FEAT_RELTIME
+	    if (argvars[6].v_type != VAR_UNKNOWN)
+	    {
+		time_limit = (long)get_tv_number_chk(&argvars[6], NULL);
+		if (time_limit < 0)
+		{
+		    EMSG2(_(e_invarg2), get_tv_string(&argvars[6]));
+		    goto theend;
+		}
+	    }
+#endif
+	}
+    }
+
+    retval = do_searchpair(spat, mpat, epat, dir, skip, flags,
+					    match_pos, lnum_stop, time_limit);
+
+theend:
+    p_ws = save_p_ws;
+
+    return retval;
+}
+
+/*
+ * "searchpair()" function
+ */
+    static void
+f_searchpair(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = searchpair_cmn(argvars, NULL);
+}
+
+/*
+ * "searchpairpos()" function
+ */
+    static void
+f_searchpairpos(typval_T *argvars, typval_T *rettv)
+{
+    pos_T	match_pos;
+    int		lnum = 0;
+    int		col = 0;
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+
+    if (searchpair_cmn(argvars, &match_pos) > 0)
+    {
+	lnum = match_pos.lnum;
+	col = match_pos.col;
+    }
+
+    list_append_number(rettv->vval.v_list, (varnumber_T)lnum);
+    list_append_number(rettv->vval.v_list, (varnumber_T)col);
+}
+
+/*
+ * Search for a start/middle/end thing.
+ * Used by searchpair(), see its documentation for the details.
+ * Returns 0 or -1 for no match,
+ */
+    long
+do_searchpair(
+    char_u	*spat,	    /* start pattern */
+    char_u	*mpat,	    /* middle pattern */
+    char_u	*epat,	    /* end pattern */
+    int		dir,	    /* BACKWARD or FORWARD */
+    typval_T	*skip,	    /* skip expression */
+    int		flags,	    /* SP_SETPCMARK and other SP_ values */
+    pos_T	*match_pos,
+    linenr_T	lnum_stop,  /* stop at this line if not zero */
+    long	time_limit UNUSED) /* stop after this many msec */
+{
+    char_u	*save_cpo;
+    char_u	*pat, *pat2 = NULL, *pat3 = NULL;
+    long	retval = 0;
+    pos_T	pos;
+    pos_T	firstpos;
+    pos_T	foundpos;
+    pos_T	save_cursor;
+    pos_T	save_pos;
+    int		n;
+    int		r;
+    int		nest = 1;
+    int		use_skip = FALSE;
+    int		err;
+    int		options = SEARCH_KEEP;
+    proftime_T	tm;
+
+    /* Make 'cpoptions' empty, the 'l' flag should not be used here. */
+    save_cpo = p_cpo;
+    p_cpo = empty_option;
+
+#ifdef FEAT_RELTIME
+    /* Set the time limit, if there is one. */
+    profile_setlimit(time_limit, &tm);
+#endif
+
+    /* Make two search patterns: start/end (pat2, for in nested pairs) and
+     * start/middle/end (pat3, for the top pair). */
+    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
+    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
+    if (pat2 == NULL || pat3 == NULL)
+	goto theend;
+    sprintf((char *)pat2, "\\m\\(%s\\m\\)\\|\\(%s\\m\\)", spat, epat);
+    if (*mpat == NUL)
+	STRCPY(pat3, pat2);
+    else
+	sprintf((char *)pat3, "\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)",
+							    spat, epat, mpat);
+    if (flags & SP_START)
+	options |= SEARCH_START;
+
+    if (skip != NULL)
+    {
+	/* Empty string means to not use the skip expression. */
+	if (skip->v_type == VAR_STRING || skip->v_type == VAR_FUNC)
+	    use_skip = skip->vval.v_string != NULL
+						&& *skip->vval.v_string != NUL;
+    }
+
+    save_cursor = curwin->w_cursor;
+    pos = curwin->w_cursor;
+    CLEAR_POS(&firstpos);
+    CLEAR_POS(&foundpos);
+    pat = pat3;
+    for (;;)
+    {
+	n = searchit(curwin, curbuf, &pos, dir, pat, 1L,
+				     options, RE_SEARCH, lnum_stop, &tm, NULL);
+	if (n == FAIL || (firstpos.lnum != 0 && EQUAL_POS(pos, firstpos)))
+	    /* didn't find it or found the first match again: FAIL */
+	    break;
+
+	if (firstpos.lnum == 0)
+	    firstpos = pos;
+	if (EQUAL_POS(pos, foundpos))
+	{
+	    /* Found the same position again.  Can happen with a pattern that
+	     * has "\zs" at the end and searching backwards.  Advance one
+	     * character and try again. */
+	    if (dir == BACKWARD)
+		decl(&pos);
+	    else
+		incl(&pos);
+	}
+	foundpos = pos;
+
+	/* clear the start flag to avoid getting stuck here */
+	options &= ~SEARCH_START;
+
+	/* If the skip pattern matches, ignore this match. */
+	if (use_skip)
+	{
+	    save_pos = curwin->w_cursor;
+	    curwin->w_cursor = pos;
+	    err = FALSE;
+	    r = eval_expr_to_bool(skip, &err);
+	    curwin->w_cursor = save_pos;
+	    if (err)
+	    {
+		/* Evaluating {skip} caused an error, break here. */
+		curwin->w_cursor = save_cursor;
+		retval = -1;
+		break;
+	    }
+	    if (r)
+		continue;
+	}
+
+	if ((dir == BACKWARD && n == 3) || (dir == FORWARD && n == 2))
+	{
+	    /* Found end when searching backwards or start when searching
+	     * forward: nested pair. */
+	    ++nest;
+	    pat = pat2;		/* nested, don't search for middle */
+	}
+	else
+	{
+	    /* Found end when searching forward or start when searching
+	     * backward: end of (nested) pair; or found middle in outer pair. */
+	    if (--nest == 1)
+		pat = pat3;	/* outer level, search for middle */
+	}
+
+	if (nest == 0)
+	{
+	    /* Found the match: return matchcount or line number. */
+	    if (flags & SP_RETCOUNT)
+		++retval;
+	    else
+		retval = pos.lnum;
+	    if (flags & SP_SETPCMARK)
+		setpcmark();
+	    curwin->w_cursor = pos;
+	    if (!(flags & SP_REPEAT))
+		break;
+	    nest = 1;	    /* search for next unmatched */
+	}
+    }
+
+    if (match_pos != NULL)
+    {
+	/* Store the match cursor position */
+	match_pos->lnum = curwin->w_cursor.lnum;
+	match_pos->col = curwin->w_cursor.col + 1;
+    }
+
+    /* If 'n' flag is used or search failed: restore cursor position. */
+    if ((flags & SP_NOMOVE) || retval == 0)
+	curwin->w_cursor = save_cursor;
+
+theend:
+    vim_free(pat2);
+    vim_free(pat3);
+    if (p_cpo == empty_option)
+	p_cpo = save_cpo;
+    else
+	/* Darn, evaluating the {skip} expression changed the value. */
+	free_string_option(save_cpo);
+
+    return retval;
+}
+
+/*
+ * "searchpos()" function
+ */
+    static void
+f_searchpos(typval_T *argvars, typval_T *rettv)
+{
+    pos_T	match_pos;
+    int		lnum = 0;
+    int		col = 0;
+    int		n;
+    int		flags = 0;
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+
+    n = search_cmn(argvars, &match_pos, &flags);
+    if (n > 0)
+    {
+	lnum = match_pos.lnum;
+	col = match_pos.col;
+    }
+
+    list_append_number(rettv->vval.v_list, (varnumber_T)lnum);
+    list_append_number(rettv->vval.v_list, (varnumber_T)col);
+    if (flags & SP_SUBPAT)
+	list_append_number(rettv->vval.v_list, (varnumber_T)n);
+}
+
+    static void
+f_server2client(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_CLIENTSERVER
+    char_u	buf[NUMBUFLEN];
+    char_u	*server = get_tv_string_chk(&argvars[0]);
+    char_u	*reply = get_tv_string_buf_chk(&argvars[1], buf);
+
+    rettv->vval.v_number = -1;
+    if (server == NULL || reply == NULL)
+	return;
+    if (check_restricted() || check_secure())
+	return;
+# ifdef FEAT_X11
+    if (check_connection() == FAIL)
+	return;
+# endif
+
+    if (serverSendReply(server, reply) < 0)
+    {
+	EMSG(_("E258: Unable to send to client"));
+	return;
+    }
+    rettv->vval.v_number = 0;
+#else
+    rettv->vval.v_number = -1;
+#endif
+}
+
+    static void
+f_serverlist(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    char_u	*r = NULL;
+
+#ifdef FEAT_CLIENTSERVER
+# ifdef WIN32
+    r = serverGetVimNames();
+# else
+    make_connection();
+    if (X_DISPLAY != NULL)
+	r = serverGetVimNames(X_DISPLAY);
+# endif
+#endif
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = r;
+}
+
+/*
+ * "setbufline()" function
+ */
+    static void
+f_setbufline(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum;
+    buf_T	*buf;
+
+    buf = get_buf_tv(&argvars[0], FALSE);
+    if (buf == NULL)
+	rettv->vval.v_number = 1; /* FAIL */
+    else
+    {
+	lnum = get_tv_lnum_buf(&argvars[1], buf);
+	set_buffer_lines(buf, lnum, FALSE, &argvars[2], rettv);
+    }
+}
+
+/*
+ * "setbufvar()" function
+ */
+    static void
+f_setbufvar(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    buf_T	*buf;
+    char_u	*varname, *bufvarname;
+    typval_T	*varp;
+    char_u	nbuf[NUMBUFLEN];
+
+    if (check_restricted() || check_secure())
+	return;
+    (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
+    varname = get_tv_string_chk(&argvars[1]);
+    buf = get_buf_tv(&argvars[0], FALSE);
+    varp = &argvars[2];
+
+    if (buf != NULL && varname != NULL && varp != NULL)
+    {
+	if (*varname == '&')
+	{
+	    long	numval;
+	    char_u	*strval;
+	    int		error = FALSE;
+	    aco_save_T	aco;
+
+	    /* set curbuf to be our buf, temporarily */
+	    aucmd_prepbuf(&aco, buf);
+
+	    ++varname;
+	    numval = (long)get_tv_number_chk(varp, &error);
+	    strval = get_tv_string_buf_chk(varp, nbuf);
+	    if (!error && strval != NULL)
+		set_option_value(varname, numval, strval, OPT_LOCAL);
+
+	    /* reset notion of buffer */
+	    aucmd_restbuf(&aco);
+	}
+	else
+	{
+	    buf_T *save_curbuf = curbuf;
+
+	    bufvarname = alloc((unsigned)STRLEN(varname) + 3);
+	    if (bufvarname != NULL)
+	    {
+		curbuf = buf;
+		STRCPY(bufvarname, "b:");
+		STRCPY(bufvarname + 2, varname);
+		set_var(bufvarname, varp, TRUE);
+		vim_free(bufvarname);
+		curbuf = save_curbuf;
+	    }
+	}
+    }
+}
+
+    static void
+f_setcharsearch(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    dict_T	*d;
+    dictitem_T	*di;
+    char_u	*csearch;
+
+    if (argvars[0].v_type != VAR_DICT)
+    {
+	EMSG(_(e_dictreq));
+	return;
+    }
+
+    if ((d = argvars[0].vval.v_dict) != NULL)
+    {
+	csearch = get_dict_string(d, (char_u *)"char", FALSE);
+	if (csearch != NULL)
+	{
+#ifdef FEAT_MBYTE
+	    if (enc_utf8)
+	    {
+		int pcc[MAX_MCO];
+		int c = utfc_ptr2char(csearch, pcc);
+
+		set_last_csearch(c, csearch, utfc_ptr2len(csearch));
+	    }
+	    else
+#endif
+		set_last_csearch(PTR2CHAR(csearch),
+						csearch, MB_PTR2LEN(csearch));
+	}
+
+	di = dict_find(d, (char_u *)"forward", -1);
+	if (di != NULL)
+	    set_csearch_direction((int)get_tv_number(&di->di_tv)
+							? FORWARD : BACKWARD);
+
+	di = dict_find(d, (char_u *)"until", -1);
+	if (di != NULL)
+	    set_csearch_until(!!get_tv_number(&di->di_tv));
+    }
+}
+
+/*
+ * "setcmdpos()" function
+ */
+    static void
+f_setcmdpos(typval_T *argvars, typval_T *rettv)
+{
+    int		pos = (int)get_tv_number(&argvars[0]) - 1;
+
+    if (pos >= 0)
+	rettv->vval.v_number = set_cmdline_pos(pos);
+}
+
+/*
+ * "setfperm({fname}, {mode})" function
+ */
+    static void
+f_setfperm(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*fname;
+    char_u	modebuf[NUMBUFLEN];
+    char_u	*mode_str;
+    int		i;
+    int		mask;
+    int		mode = 0;
+
+    rettv->vval.v_number = 0;
+    fname = get_tv_string_chk(&argvars[0]);
+    if (fname == NULL)
+	return;
+    mode_str = get_tv_string_buf_chk(&argvars[1], modebuf);
+    if (mode_str == NULL)
+	return;
+    if (STRLEN(mode_str) != 9)
+    {
+	EMSG2(_(e_invarg2), mode_str);
+	return;
+    }
+
+    mask = 1;
+    for (i = 8; i >= 0; --i)
+    {
+	if (mode_str[i] != '-')
+	    mode |= mask;
+	mask = mask << 1;
+    }
+    rettv->vval.v_number = mch_setperm(fname, mode) == OK;
+}
+
+/*
+ * "setline()" function
+ */
+    static void
+f_setline(typval_T *argvars, typval_T *rettv)
+{
+    linenr_T	lnum = get_tv_lnum(&argvars[0]);
+
+    set_buffer_lines(curbuf, lnum, FALSE, &argvars[1], rettv);
+}
+
+static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *what_arg, typval_T *rettv);
+
+/*
+ * Used by "setqflist()" and "setloclist()" functions
+ */
+    static void
+set_qf_ll_list(
+    win_T	*wp UNUSED,
+    typval_T	*list_arg UNUSED,
+    typval_T	*action_arg UNUSED,
+    typval_T	*what_arg UNUSED,
+    typval_T	*rettv)
+{
+#ifdef FEAT_QUICKFIX
+    static char *e_invact = N_("E927: Invalid action: '%s'");
+    char_u	*act;
+    int		action = 0;
+    static int	recursive = 0;
+#endif
+
+    rettv->vval.v_number = -1;
+
+#ifdef FEAT_QUICKFIX
+    if (list_arg->v_type != VAR_LIST)
+	EMSG(_(e_listreq));
+    else if (recursive != 0)
+	EMSG(_(e_au_recursive));
+    else
+    {
+	list_T  *l = list_arg->vval.v_list;
+	dict_T	*d = NULL;
+	int	valid_dict = TRUE;
+
+	if (action_arg->v_type == VAR_STRING)
+	{
+	    act = get_tv_string_chk(action_arg);
+	    if (act == NULL)
+		return;		/* type error; errmsg already given */
+	    if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f') &&
+		    act[1] == NUL)
+		action = *act;
+	    else
+		EMSG2(_(e_invact), act);
+	}
+	else if (action_arg->v_type == VAR_UNKNOWN)
+	    action = ' ';
+	else
+	    EMSG(_(e_stringreq));
+
+	if (action_arg->v_type != VAR_UNKNOWN
+		&& what_arg->v_type != VAR_UNKNOWN)
+	{
+	    if (what_arg->v_type == VAR_DICT)
+		d = what_arg->vval.v_dict;
+	    else
+	    {
+		EMSG(_(e_dictreq));
+		valid_dict = FALSE;
+	    }
+	}
+
+	++recursive;
+	if (l != NULL && action && valid_dict && set_errorlist(wp, l, action,
+		     (char_u *)(wp == NULL ? ":setqflist()" : ":setloclist()"),
+		     d) == OK)
+	    rettv->vval.v_number = 0;
+	--recursive;
+    }
+#endif
+}
+
+/*
+ * "setloclist()" function
+ */
+    static void
+f_setloclist(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*win;
+
+    rettv->vval.v_number = -1;
+
+    win = find_win_by_nr(&argvars[0], NULL);
+    if (win != NULL)
+	set_qf_ll_list(win, &argvars[1], &argvars[2], &argvars[3], rettv);
+}
+
+/*
+ * "setmatches()" function
+ */
+    static void
+f_setmatches(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_SEARCH_EXTRA
+    list_T	*l;
+    listitem_T	*li;
+    dict_T	*d;
+    list_T	*s = NULL;
+
+    rettv->vval.v_number = -1;
+    if (argvars[0].v_type != VAR_LIST)
+    {
+	EMSG(_(e_listreq));
+	return;
+    }
+    if ((l = argvars[0].vval.v_list) != NULL)
+    {
+
+	/* To some extent make sure that we are dealing with a list from
+	 * "getmatches()". */
+	li = l->lv_first;
+	while (li != NULL)
+	{
+	    if (li->li_tv.v_type != VAR_DICT
+		    || (d = li->li_tv.vval.v_dict) == NULL)
+	    {
+		EMSG(_(e_invarg));
+		return;
+	    }
+	    if (!(dict_find(d, (char_u *)"group", -1) != NULL
+			&& (dict_find(d, (char_u *)"pattern", -1) != NULL
+			    || dict_find(d, (char_u *)"pos1", -1) != NULL)
+			&& dict_find(d, (char_u *)"priority", -1) != NULL
+			&& dict_find(d, (char_u *)"id", -1) != NULL))
+	    {
+		EMSG(_(e_invarg));
+		return;
+	    }
+	    li = li->li_next;
+	}
+
+	clear_matches(curwin);
+	li = l->lv_first;
+	while (li != NULL)
+	{
+	    int		i = 0;
+	    char_u	buf[5];
+	    dictitem_T  *di;
+	    char_u	*group;
+	    int		priority;
+	    int		id;
+	    char_u	*conceal;
+
+	    d = li->li_tv.vval.v_dict;
+	    if (dict_find(d, (char_u *)"pattern", -1) == NULL)
+	    {
+		if (s == NULL)
+		{
+		    s = list_alloc();
+		    if (s == NULL)
+			return;
+		}
+
+		/* match from matchaddpos() */
+		for (i = 1; i < 9; i++)
+		{
+		    sprintf((char *)buf, (char *)"pos%d", i);
+		    if ((di = dict_find(d, (char_u *)buf, -1)) != NULL)
+		    {
+			if (di->di_tv.v_type != VAR_LIST)
+			    return;
+
+			list_append_tv(s, &di->di_tv);
+			s->lv_refcount++;
+		    }
+		    else
+			break;
+		}
+	    }
+
+	    group = get_dict_string(d, (char_u *)"group", TRUE);
+	    priority = (int)get_dict_number(d, (char_u *)"priority");
+	    id = (int)get_dict_number(d, (char_u *)"id");
+	    conceal = dict_find(d, (char_u *)"conceal", -1) != NULL
+			      ? get_dict_string(d, (char_u *)"conceal", TRUE)
+			      : NULL;
+	    if (i == 0)
+	    {
+		match_add(curwin, group,
+		    get_dict_string(d, (char_u *)"pattern", FALSE),
+		    priority, id, NULL, conceal);
+	    }
+	    else
+	    {
+		match_add(curwin, group, NULL, priority, id, s, conceal);
+		list_unref(s);
+		s = NULL;
+	    }
+	    vim_free(group);
+	    vim_free(conceal);
+
+	    li = li->li_next;
+	}
+	rettv->vval.v_number = 0;
+    }
+#endif
+}
+
+/*
+ * "setpos()" function
+ */
+    static void
+f_setpos(typval_T *argvars, typval_T *rettv)
+{
+    pos_T	pos;
+    int		fnum;
+    char_u	*name;
+    colnr_T	curswant = -1;
+
+    rettv->vval.v_number = -1;
+    name = get_tv_string_chk(argvars);
+    if (name != NULL)
+    {
+	if (list2fpos(&argvars[1], &pos, &fnum, &curswant) == OK)
+	{
+	    if (--pos.col < 0)
+		pos.col = 0;
+	    if (name[0] == '.' && name[1] == NUL)
+	    {
+		/* set cursor; "fnum" is ignored */
+		curwin->w_cursor = pos;
+		if (curswant >= 0)
+		{
+		    curwin->w_curswant = curswant - 1;
+		    curwin->w_set_curswant = FALSE;
+		}
+		check_cursor();
+		rettv->vval.v_number = 0;
+	    }
+	    else if (name[0] == '\'' && name[1] != NUL && name[2] == NUL)
+	    {
+		/* set mark */
+		if (setmark_pos(name[1], &pos, fnum) == OK)
+		    rettv->vval.v_number = 0;
+	    }
+	    else
+		EMSG(_(e_invarg));
+	}
+    }
+}
+
+/*
+ * "setqflist()" function
+ */
+    static void
+f_setqflist(typval_T *argvars, typval_T *rettv)
+{
+    set_qf_ll_list(NULL, &argvars[0], &argvars[1], &argvars[2], rettv);
+}
+
+/*
+ * "setreg()" function
+ */
+    static void
+f_setreg(typval_T *argvars, typval_T *rettv)
+{
+    int		regname;
+    char_u	*strregname;
+    char_u	*stropt;
+    char_u	*strval;
+    int		append;
+    char_u	yank_type;
+    long	block_len;
+
+    block_len = -1;
+    yank_type = MAUTO;
+    append = FALSE;
+
+    strregname = get_tv_string_chk(argvars);
+    rettv->vval.v_number = 1;		/* FAIL is default */
+
+    if (strregname == NULL)
+	return;		/* type error; errmsg already given */
+    regname = *strregname;
+    if (regname == 0 || regname == '@')
+	regname = '"';
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	stropt = get_tv_string_chk(&argvars[2]);
+	if (stropt == NULL)
+	    return;		/* type error */
+	for (; *stropt != NUL; ++stropt)
+	    switch (*stropt)
+	    {
+		case 'a': case 'A':	/* append */
+		    append = TRUE;
+		    break;
+		case 'v': case 'c':	/* character-wise selection */
+		    yank_type = MCHAR;
+		    break;
+		case 'V': case 'l':	/* line-wise selection */
+		    yank_type = MLINE;
+		    break;
+		case 'b': case Ctrl_V:	/* block-wise selection */
+		    yank_type = MBLOCK;
+		    if (VIM_ISDIGIT(stropt[1]))
+		    {
+			++stropt;
+			block_len = getdigits(&stropt) - 1;
+			--stropt;
+		    }
+		    break;
+	    }
+    }
+
+    if (argvars[1].v_type == VAR_LIST)
+    {
+	char_u		**lstval;
+	char_u		**allocval;
+	char_u		buf[NUMBUFLEN];
+	char_u		**curval;
+	char_u		**curallocval;
+	list_T		*ll = argvars[1].vval.v_list;
+	listitem_T	*li;
+	int		len;
+
+	/* If the list is NULL handle like an empty list. */
+	len = ll == NULL ? 0 : ll->lv_len;
+
+	/* First half: use for pointers to result lines; second half: use for
+	 * pointers to allocated copies. */
+	lstval = (char_u **)alloc(sizeof(char_u *) * ((len + 1) * 2));
+	if (lstval == NULL)
+	    return;
+	curval = lstval;
+	allocval = lstval + len + 2;
+	curallocval = allocval;
+
+	for (li = ll == NULL ? NULL : ll->lv_first; li != NULL;
+							     li = li->li_next)
+	{
+	    strval = get_tv_string_buf_chk(&li->li_tv, buf);
+	    if (strval == NULL)
+		goto free_lstval;
+	    if (strval == buf)
+	    {
+		/* Need to make a copy, next get_tv_string_buf_chk() will
+		 * overwrite the string. */
+		strval = vim_strsave(buf);
+		if (strval == NULL)
+		    goto free_lstval;
+		*curallocval++ = strval;
+	    }
+	    *curval++ = strval;
+	}
+	*curval++ = NULL;
+
+	write_reg_contents_lst(regname, lstval, -1,
+						append, yank_type, block_len);
+free_lstval:
+	while (curallocval > allocval)
+	    vim_free(*--curallocval);
+	vim_free(lstval);
+    }
+    else
+    {
+	strval = get_tv_string_chk(&argvars[1]);
+	if (strval == NULL)
+	    return;
+	write_reg_contents_ex(regname, strval, -1,
+						append, yank_type, block_len);
+    }
+    rettv->vval.v_number = 0;
+}
+
+/*
+ * "settabvar()" function
+ */
+    static void
+f_settabvar(typval_T *argvars, typval_T *rettv)
+{
+    tabpage_T	*save_curtab;
+    tabpage_T	*tp;
+    char_u	*varname, *tabvarname;
+    typval_T	*varp;
+
+    rettv->vval.v_number = 0;
+
+    if (check_restricted() || check_secure())
+	return;
+
+    tp = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
+    varname = get_tv_string_chk(&argvars[1]);
+    varp = &argvars[2];
+
+    if (varname != NULL && varp != NULL && tp != NULL)
+    {
+	save_curtab = curtab;
+	goto_tabpage_tp(tp, FALSE, FALSE);
+
+	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
+	if (tabvarname != NULL)
+	{
+	    STRCPY(tabvarname, "t:");
+	    STRCPY(tabvarname + 2, varname);
+	    set_var(tabvarname, varp, TRUE);
+	    vim_free(tabvarname);
+	}
+
+	/* Restore current tabpage */
+	if (valid_tabpage(save_curtab))
+	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
+    }
+}
+
+/*
+ * "settabwinvar()" function
+ */
+    static void
+f_settabwinvar(typval_T *argvars, typval_T *rettv)
+{
+    setwinvar(argvars, rettv, 1);
+}
+
+/*
+ * "setwinvar()" function
+ */
+    static void
+f_setwinvar(typval_T *argvars, typval_T *rettv)
+{
+    setwinvar(argvars, rettv, 0);
+}
+
+#ifdef FEAT_CRYPT
+/*
+ * "sha256({string})" function
+ */
+    static void
+f_sha256(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*p;
+
+    p = get_tv_string(&argvars[0]);
+    rettv->vval.v_string = vim_strsave(
+				    sha256_bytes(p, (int)STRLEN(p), NULL, 0));
+    rettv->v_type = VAR_STRING;
+}
+#endif /* FEAT_CRYPT */
+
+/*
+ * "shellescape({string})" function
+ */
+    static void
+f_shellescape(typval_T *argvars, typval_T *rettv)
+{
+    int do_special = non_zero_arg(&argvars[1]);
+
+    rettv->vval.v_string = vim_strsave_shellescape(
+			   get_tv_string(&argvars[0]), do_special, do_special);
+    rettv->v_type = VAR_STRING;
+}
+
+/*
+ * shiftwidth() function
+ */
+    static void
+f_shiftwidth(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->vval.v_number = get_sw_value(curbuf);
+}
+
+/*
+ * "simplify()" function
+ */
+    static void
+f_simplify(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*p;
+
+    p = get_tv_string(&argvars[0]);
+    rettv->vval.v_string = vim_strsave(p);
+    simplify_filename(rettv->vval.v_string);	/* simplify in place */
+    rettv->v_type = VAR_STRING;
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "sin()" function
+ */
+    static void
+f_sin(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = sin(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "sinh()" function
+ */
+    static void
+f_sinh(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = sinh(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+static int
+#ifdef __BORLANDC__
+    _RTLENTRYF
+#endif
+	item_compare(const void *s1, const void *s2);
+static int
+#ifdef __BORLANDC__
+    _RTLENTRYF
+#endif
+	item_compare2(const void *s1, const void *s2);
+
+/* struct used in the array that's given to qsort() */
+typedef struct
+{
+    listitem_T	*item;
+    int		idx;
+} sortItem_T;
+
+/* struct storing information about current sort */
+typedef struct
+{
+    int		item_compare_ic;
+    int		item_compare_numeric;
+    int		item_compare_numbers;
+#ifdef FEAT_FLOAT
+    int		item_compare_float;
+#endif
+    char_u	*item_compare_func;
+    partial_T	*item_compare_partial;
+    dict_T	*item_compare_selfdict;
+    int		item_compare_func_err;
+    int		item_compare_keep_zero;
+} sortinfo_T;
+static sortinfo_T	*sortinfo = NULL;
+static void	do_sort_uniq(typval_T *argvars, typval_T *rettv, int sort);
+#define ITEM_COMPARE_FAIL 999
+
+/*
+ * Compare functions for f_sort() and f_uniq() below.
+ */
+    static int
+#ifdef __BORLANDC__
+_RTLENTRYF
+#endif
+item_compare(const void *s1, const void *s2)
+{
+    sortItem_T  *si1, *si2;
+    typval_T	*tv1, *tv2;
+    char_u	*p1, *p2;
+    char_u	*tofree1 = NULL, *tofree2 = NULL;
+    int		res;
+    char_u	numbuf1[NUMBUFLEN];
+    char_u	numbuf2[NUMBUFLEN];
+
+    si1 = (sortItem_T *)s1;
+    si2 = (sortItem_T *)s2;
+    tv1 = &si1->item->li_tv;
+    tv2 = &si2->item->li_tv;
+
+    if (sortinfo->item_compare_numbers)
+    {
+	varnumber_T	v1 = get_tv_number(tv1);
+	varnumber_T	v2 = get_tv_number(tv2);
+
+	return v1 == v2 ? 0 : v1 > v2 ? 1 : -1;
+    }
+
+#ifdef FEAT_FLOAT
+    if (sortinfo->item_compare_float)
+    {
+	float_T	v1 = get_tv_float(tv1);
+	float_T	v2 = get_tv_float(tv2);
+
+	return v1 == v2 ? 0 : v1 > v2 ? 1 : -1;
+    }
+#endif
+
+    /* tv2string() puts quotes around a string and allocates memory.  Don't do
+     * that for string variables. Use a single quote when comparing with a
+     * non-string to do what the docs promise. */
+    if (tv1->v_type == VAR_STRING)
+    {
+	if (tv2->v_type != VAR_STRING || sortinfo->item_compare_numeric)
+	    p1 = (char_u *)"'";
+	else
+	    p1 = tv1->vval.v_string;
+    }
+    else
+	p1 = tv2string(tv1, &tofree1, numbuf1, 0);
+    if (tv2->v_type == VAR_STRING)
+    {
+	if (tv1->v_type != VAR_STRING || sortinfo->item_compare_numeric)
+	    p2 = (char_u *)"'";
+	else
+	    p2 = tv2->vval.v_string;
+    }
+    else
+	p2 = tv2string(tv2, &tofree2, numbuf2, 0);
+    if (p1 == NULL)
+	p1 = (char_u *)"";
+    if (p2 == NULL)
+	p2 = (char_u *)"";
+    if (!sortinfo->item_compare_numeric)
+    {
+	if (sortinfo->item_compare_ic)
+	    res = STRICMP(p1, p2);
+	else
+	    res = STRCMP(p1, p2);
+    }
+    else
+    {
+	double n1, n2;
+	n1 = strtod((char *)p1, (char **)&p1);
+	n2 = strtod((char *)p2, (char **)&p2);
+	res = n1 == n2 ? 0 : n1 > n2 ? 1 : -1;
+    }
+
+    /* When the result would be zero, compare the item indexes.  Makes the
+     * sort stable. */
+    if (res == 0 && !sortinfo->item_compare_keep_zero)
+	res = si1->idx > si2->idx ? 1 : -1;
+
+    vim_free(tofree1);
+    vim_free(tofree2);
+    return res;
+}
+
+    static int
+#ifdef __BORLANDC__
+_RTLENTRYF
+#endif
+item_compare2(const void *s1, const void *s2)
+{
+    sortItem_T  *si1, *si2;
+    int		res;
+    typval_T	rettv;
+    typval_T	argv[3];
+    int		dummy;
+    char_u	*func_name;
+    partial_T	*partial = sortinfo->item_compare_partial;
+
+    /* shortcut after failure in previous call; compare all items equal */
+    if (sortinfo->item_compare_func_err)
+	return 0;
+
+    si1 = (sortItem_T *)s1;
+    si2 = (sortItem_T *)s2;
+
+    if (partial == NULL)
+	func_name = sortinfo->item_compare_func;
+    else
+	func_name = partial_name(partial);
+
+    /* Copy the values.  This is needed to be able to set v_lock to VAR_FIXED
+     * in the copy without changing the original list items. */
+    copy_tv(&si1->item->li_tv, &argv[0]);
+    copy_tv(&si2->item->li_tv, &argv[1]);
+
+    rettv.v_type = VAR_UNKNOWN;		/* clear_tv() uses this */
+    res = call_func(func_name, (int)STRLEN(func_name),
+				 &rettv, 2, argv, NULL, 0L, 0L, &dummy, TRUE,
+				 partial, sortinfo->item_compare_selfdict);
+    clear_tv(&argv[0]);
+    clear_tv(&argv[1]);
+
+    if (res == FAIL)
+	res = ITEM_COMPARE_FAIL;
+    else
+	res = (int)get_tv_number_chk(&rettv, &sortinfo->item_compare_func_err);
+    if (sortinfo->item_compare_func_err)
+	res = ITEM_COMPARE_FAIL;  /* return value has wrong type */
+    clear_tv(&rettv);
+
+    /* When the result would be zero, compare the pointers themselves.  Makes
+     * the sort stable. */
+    if (res == 0 && !sortinfo->item_compare_keep_zero)
+	res = si1->idx > si2->idx ? 1 : -1;
+
+    return res;
+}
+
+/*
+ * "sort({list})" function
+ */
+    static void
+do_sort_uniq(typval_T *argvars, typval_T *rettv, int sort)
+{
+    list_T	*l;
+    listitem_T	*li;
+    sortItem_T	*ptrs;
+    sortinfo_T	*old_sortinfo;
+    sortinfo_T	info;
+    long	len;
+    long	i;
+
+    /* Pointer to current info struct used in compare function. Save and
+     * restore the current one for nested calls. */
+    old_sortinfo = sortinfo;
+    sortinfo = &info;
+
+    if (argvars[0].v_type != VAR_LIST)
+	EMSG2(_(e_listarg), sort ? "sort()" : "uniq()");
+    else
+    {
+	l = argvars[0].vval.v_list;
+	if (l == NULL || tv_check_lock(l->lv_lock,
+	     (char_u *)(sort ? N_("sort() argument") : N_("uniq() argument")),
+									TRUE))
+	    goto theend;
+	rettv_list_set(rettv, l);
+
+	len = list_len(l);
+	if (len <= 1)
+	    goto theend;	/* short list sorts pretty quickly */
+
+	info.item_compare_ic = FALSE;
+	info.item_compare_numeric = FALSE;
+	info.item_compare_numbers = FALSE;
+#ifdef FEAT_FLOAT
+	info.item_compare_float = FALSE;
+#endif
+	info.item_compare_func = NULL;
+	info.item_compare_partial = NULL;
+	info.item_compare_selfdict = NULL;
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	{
+	    /* optional second argument: {func} */
+	    if (argvars[1].v_type == VAR_FUNC)
+		info.item_compare_func = argvars[1].vval.v_string;
+	    else if (argvars[1].v_type == VAR_PARTIAL)
+		info.item_compare_partial = argvars[1].vval.v_partial;
+	    else
+	    {
+		int	    error = FALSE;
+
+		i = (long)get_tv_number_chk(&argvars[1], &error);
+		if (error)
+		    goto theend;	/* type error; errmsg already given */
+		if (i == 1)
+		    info.item_compare_ic = TRUE;
+		else if (argvars[1].v_type != VAR_NUMBER)
+		    info.item_compare_func = get_tv_string(&argvars[1]);
+		else if (i != 0)
+		{
+		    EMSG(_(e_invarg));
+		    goto theend;
+		}
+		if (info.item_compare_func != NULL)
+		{
+		    if (*info.item_compare_func == NUL)
+		    {
+			/* empty string means default sort */
+			info.item_compare_func = NULL;
+		    }
+		    else if (STRCMP(info.item_compare_func, "n") == 0)
+		    {
+			info.item_compare_func = NULL;
+			info.item_compare_numeric = TRUE;
+		    }
+		    else if (STRCMP(info.item_compare_func, "N") == 0)
+		    {
+			info.item_compare_func = NULL;
+			info.item_compare_numbers = TRUE;
+		    }
+#ifdef FEAT_FLOAT
+		    else if (STRCMP(info.item_compare_func, "f") == 0)
+		    {
+			info.item_compare_func = NULL;
+			info.item_compare_float = TRUE;
+		    }
+#endif
+		    else if (STRCMP(info.item_compare_func, "i") == 0)
+		    {
+			info.item_compare_func = NULL;
+			info.item_compare_ic = TRUE;
+		    }
+		}
+	    }
+
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    {
+		/* optional third argument: {dict} */
+		if (argvars[2].v_type != VAR_DICT)
+		{
+		    EMSG(_(e_dictreq));
+		    goto theend;
+		}
+		info.item_compare_selfdict = argvars[2].vval.v_dict;
+	    }
+	}
+
+	/* Make an array with each entry pointing to an item in the List. */
+	ptrs = (sortItem_T *)alloc((int)(len * sizeof(sortItem_T)));
+	if (ptrs == NULL)
+	    goto theend;
+
+	i = 0;
+	if (sort)
+	{
+	    /* sort(): ptrs will be the list to sort */
+	    for (li = l->lv_first; li != NULL; li = li->li_next)
+	    {
+		ptrs[i].item = li;
+		ptrs[i].idx = i;
+		++i;
+	    }
+
+	    info.item_compare_func_err = FALSE;
+	    info.item_compare_keep_zero = FALSE;
+	    /* test the compare function */
+	    if ((info.item_compare_func != NULL
+					 || info.item_compare_partial != NULL)
+		    && item_compare2((void *)&ptrs[0], (void *)&ptrs[1])
+							 == ITEM_COMPARE_FAIL)
+		EMSG(_("E702: Sort compare function failed"));
+	    else
+	    {
+		/* Sort the array with item pointers. */
+		qsort((void *)ptrs, (size_t)len, sizeof(sortItem_T),
+		    info.item_compare_func == NULL
+					  && info.item_compare_partial == NULL
+					       ? item_compare : item_compare2);
+
+		if (!info.item_compare_func_err)
+		{
+		    /* Clear the List and append the items in sorted order. */
+		    l->lv_first = l->lv_last = l->lv_idx_item = NULL;
+		    l->lv_len = 0;
+		    for (i = 0; i < len; ++i)
+			list_append(l, ptrs[i].item);
+		}
+	    }
+	}
+	else
+	{
+	    int	(*item_compare_func_ptr)(const void *, const void *);
+
+	    /* f_uniq(): ptrs will be a stack of items to remove */
+	    info.item_compare_func_err = FALSE;
+	    info.item_compare_keep_zero = TRUE;
+	    item_compare_func_ptr = info.item_compare_func != NULL
+					  || info.item_compare_partial != NULL
+					       ? item_compare2 : item_compare;
+
+	    for (li = l->lv_first; li != NULL && li->li_next != NULL;
+							     li = li->li_next)
+	    {
+		if (item_compare_func_ptr((void *)&li, (void *)&li->li_next)
+									 == 0)
+		    ptrs[i++].item = li;
+		if (info.item_compare_func_err)
+		{
+		    EMSG(_("E882: Uniq compare function failed"));
+		    break;
+		}
+	    }
+
+	    if (!info.item_compare_func_err)
+	    {
+		while (--i >= 0)
+		{
+		    li = ptrs[i].item->li_next;
+		    ptrs[i].item->li_next = li->li_next;
+		    if (li->li_next != NULL)
+			li->li_next->li_prev = ptrs[i].item;
+		    else
+			l->lv_last = ptrs[i].item;
+		    list_fix_watch(l, li);
+		    listitem_free(li);
+		    l->lv_len--;
+		}
+	    }
+	}
+
+	vim_free(ptrs);
+    }
+theend:
+    sortinfo = old_sortinfo;
+}
+
+/*
+ * "sort({list})" function
+ */
+    static void
+f_sort(typval_T *argvars, typval_T *rettv)
+{
+    do_sort_uniq(argvars, rettv, TRUE);
+}
+
+/*
+ * "uniq({list})" function
+ */
+    static void
+f_uniq(typval_T *argvars, typval_T *rettv)
+{
+    do_sort_uniq(argvars, rettv, FALSE);
+}
+
+/*
+ * "soundfold({word})" function
+ */
+    static void
+f_soundfold(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*s;
+
+    rettv->v_type = VAR_STRING;
+    s = get_tv_string(&argvars[0]);
+#ifdef FEAT_SPELL
+    rettv->vval.v_string = eval_soundfold(s);
+#else
+    rettv->vval.v_string = vim_strsave(s);
+#endif
+}
+
+/*
+ * "spellbadword()" function
+ */
+    static void
+f_spellbadword(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    char_u	*word = (char_u *)"";
+    hlf_T	attr = HLF_COUNT;
+    int		len = 0;
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+
+#ifdef FEAT_SPELL
+    if (argvars[0].v_type == VAR_UNKNOWN)
+    {
+	/* Find the start and length of the badly spelled word. */
+	len = spell_move_to(curwin, FORWARD, TRUE, TRUE, &attr);
+	if (len != 0)
+	{
+	    word = ml_get_cursor();
+	    curwin->w_set_curswant = TRUE;
+	}
+    }
+    else if (curwin->w_p_spell && *curbuf->b_s.b_p_spl != NUL)
+    {
+	char_u	*str = get_tv_string_chk(&argvars[0]);
+	int	capcol = -1;
+
+	if (str != NULL)
+	{
+	    /* Check the argument for spelling. */
+	    while (*str != NUL)
+	    {
+		len = spell_check(curwin, str, &attr, &capcol, FALSE);
+		if (attr != HLF_COUNT)
+		{
+		    word = str;
+		    break;
+		}
+		str += len;
+		capcol -= len;
+	    }
+	}
+    }
+#endif
+
+    list_append_string(rettv->vval.v_list, word, len);
+    list_append_string(rettv->vval.v_list, (char_u *)(
+			attr == HLF_SPB ? "bad" :
+			attr == HLF_SPR ? "rare" :
+			attr == HLF_SPL ? "local" :
+			attr == HLF_SPC ? "caps" :
+			""), -1);
+}
+
+/*
+ * "spellsuggest()" function
+ */
+    static void
+f_spellsuggest(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_SPELL
+    char_u	*str;
+    int		typeerr = FALSE;
+    int		maxcount;
+    garray_T	ga;
+    int		i;
+    listitem_T	*li;
+    int		need_capital = FALSE;
+#endif
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+
+#ifdef FEAT_SPELL
+    if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)
+    {
+	str = get_tv_string(&argvars[0]);
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	{
+	    maxcount = (int)get_tv_number_chk(&argvars[1], &typeerr);
+	    if (maxcount <= 0)
+		return;
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    {
+		need_capital = (int)get_tv_number_chk(&argvars[2], &typeerr);
+		if (typeerr)
+		    return;
+	    }
+	}
+	else
+	    maxcount = 25;
+
+	spell_suggest_list(&ga, str, maxcount, need_capital, FALSE);
+
+	for (i = 0; i < ga.ga_len; ++i)
+	{
+	    str = ((char_u **)ga.ga_data)[i];
+
+	    li = listitem_alloc();
+	    if (li == NULL)
+		vim_free(str);
+	    else
+	    {
+		li->li_tv.v_type = VAR_STRING;
+		li->li_tv.v_lock = 0;
+		li->li_tv.vval.v_string = str;
+		list_append(rettv->vval.v_list, li);
+	    }
+	}
+	ga_clear(&ga);
+    }
+#endif
+}
+
+    static void
+f_split(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*str;
+    char_u	*end;
+    char_u	*pat = NULL;
+    regmatch_T	regmatch;
+    char_u	patbuf[NUMBUFLEN];
+    char_u	*save_cpo;
+    int		match;
+    colnr_T	col = 0;
+    int		keepempty = FALSE;
+    int		typeerr = FALSE;
+
+    /* Make 'cpoptions' empty, the 'l' flag should not be used here. */
+    save_cpo = p_cpo;
+    p_cpo = (char_u *)"";
+
+    str = get_tv_string(&argvars[0]);
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	pat = get_tv_string_buf_chk(&argvars[1], patbuf);
+	if (pat == NULL)
+	    typeerr = TRUE;
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	    keepempty = (int)get_tv_number_chk(&argvars[2], &typeerr);
+    }
+    if (pat == NULL || *pat == NUL)
+	pat = (char_u *)"[\\x01- ]\\+";
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+    if (typeerr)
+	return;
+
+    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);
+    if (regmatch.regprog != NULL)
+    {
+	regmatch.rm_ic = FALSE;
+	while (*str != NUL || keepempty)
+	{
+	    if (*str == NUL)
+		match = FALSE;	/* empty item at the end */
+	    else
+		match = vim_regexec_nl(&regmatch, str, col);
+	    if (match)
+		end = regmatch.startp[0];
+	    else
+		end = str + STRLEN(str);
+	    if (keepempty || end > str || (rettv->vval.v_list->lv_len > 0
+			   && *str != NUL && match && end < regmatch.endp[0]))
+	    {
+		if (list_append_string(rettv->vval.v_list, str,
+						    (int)(end - str)) == FAIL)
+		    break;
+	    }
+	    if (!match)
+		break;
+	    /* Advance to just after the match. */
+	    if (regmatch.endp[0] > str)
+		col = 0;
+	    else
+	    {
+		/* Don't get stuck at the same match. */
+#ifdef FEAT_MBYTE
+		col = (*mb_ptr2len)(regmatch.endp[0]);
+#else
+		col = 1;
+#endif
+	    }
+	    str = regmatch.endp[0];
+	}
+
+	vim_regfree(regmatch.regprog);
+    }
+
+    p_cpo = save_cpo;
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "sqrt()" function
+ */
+    static void
+f_sqrt(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = sqrt(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "str2float()" function
+ */
+    static void
+f_str2float(typval_T *argvars, typval_T *rettv)
+{
+    char_u *p = skipwhite(get_tv_string(&argvars[0]));
+    int     isneg = (*p == '-');
+
+    if (*p == '+' || *p == '-')
+	p = skipwhite(p + 1);
+    (void)string2float(p, &rettv->vval.v_float);
+    if (isneg)
+	rettv->vval.v_float *= -1;
+    rettv->v_type = VAR_FLOAT;
+}
+#endif
+
+/*
+ * "str2nr()" function
+ */
+    static void
+f_str2nr(typval_T *argvars, typval_T *rettv)
+{
+    int		base = 10;
+    char_u	*p;
+    varnumber_T	n;
+    int		what;
+    int		isneg;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	base = (int)get_tv_number(&argvars[1]);
+	if (base != 2 && base != 8 && base != 10 && base != 16)
+	{
+	    EMSG(_(e_invarg));
+	    return;
+	}
+    }
+
+    p = skipwhite(get_tv_string(&argvars[0]));
+    isneg = (*p == '-');
+    if (*p == '+' || *p == '-')
+	p = skipwhite(p + 1);
+    switch (base)
+    {
+	case 2: what = STR2NR_BIN + STR2NR_FORCE; break;
+	case 8: what = STR2NR_OCT + STR2NR_FORCE; break;
+	case 16: what = STR2NR_HEX + STR2NR_FORCE; break;
+	default: what = 0;
+    }
+    vim_str2nr(p, NULL, NULL, what, &n, NULL, 0);
+    if (isneg)
+	rettv->vval.v_number = -n;
+    else
+	rettv->vval.v_number = n;
+
+}
+
+#ifdef HAVE_STRFTIME
+/*
+ * "strftime({format}[, {time}])" function
+ */
+    static void
+f_strftime(typval_T *argvars, typval_T *rettv)
+{
+    char_u	result_buf[256];
+    struct tm	*curtime;
+    time_t	seconds;
+    char_u	*p;
+
+    rettv->v_type = VAR_STRING;
+
+    p = get_tv_string(&argvars[0]);
+    if (argvars[1].v_type == VAR_UNKNOWN)
+	seconds = time(NULL);
+    else
+	seconds = (time_t)get_tv_number(&argvars[1]);
+    curtime = localtime(&seconds);
+    /* MSVC returns NULL for an invalid value of seconds. */
+    if (curtime == NULL)
+	rettv->vval.v_string = vim_strsave((char_u *)_("(Invalid)"));
+    else
+    {
+# ifdef FEAT_MBYTE
+	vimconv_T   conv;
+	char_u	    *enc;
+
+	conv.vc_type = CONV_NONE;
+	enc = enc_locale();
+	convert_setup(&conv, p_enc, enc);
+	if (conv.vc_type != CONV_NONE)
+	    p = string_convert(&conv, p, NULL);
+# endif
+	if (p != NULL)
+	    (void)strftime((char *)result_buf, sizeof(result_buf),
+							  (char *)p, curtime);
+	else
+	    result_buf[0] = NUL;
+
+# ifdef FEAT_MBYTE
+	if (conv.vc_type != CONV_NONE)
+	    vim_free(p);
+	convert_setup(&conv, enc, p_enc);
+	if (conv.vc_type != CONV_NONE)
+	    rettv->vval.v_string = string_convert(&conv, result_buf, NULL);
+	else
+# endif
+	    rettv->vval.v_string = vim_strsave(result_buf);
+
+# ifdef FEAT_MBYTE
+	/* Release conversion descriptors */
+	convert_setup(&conv, NULL, NULL);
+	vim_free(enc);
+# endif
+    }
+}
+#endif
+
+/*
+ * "strgetchar()" function
+ */
+    static void
+f_strgetchar(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*str;
+    int		len;
+    int		error = FALSE;
+    int		charidx;
+
+    rettv->vval.v_number = -1;
+    str = get_tv_string_chk(&argvars[0]);
+    if (str == NULL)
+	return;
+    len = (int)STRLEN(str);
+    charidx = (int)get_tv_number_chk(&argvars[1], &error);
+    if (error)
+	return;
+#ifdef FEAT_MBYTE
+    {
+	int	byteidx = 0;
+
+	while (charidx >= 0 && byteidx < len)
+	{
+	    if (charidx == 0)
+	    {
+		rettv->vval.v_number = mb_ptr2char(str + byteidx);
+		break;
+	    }
+	    --charidx;
+	    byteidx += MB_CPTR2LEN(str + byteidx);
+	}
+    }
+#else
+    if (charidx < len)
+	rettv->vval.v_number = str[charidx];
+#endif
+}
+
+/*
+ * "stridx()" function
+ */
+    static void
+f_stridx(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf[NUMBUFLEN];
+    char_u	*needle;
+    char_u	*haystack;
+    char_u	*save_haystack;
+    char_u	*pos;
+    int		start_idx;
+
+    needle = get_tv_string_chk(&argvars[1]);
+    save_haystack = haystack = get_tv_string_buf_chk(&argvars[0], buf);
+    rettv->vval.v_number = -1;
+    if (needle == NULL || haystack == NULL)
+	return;		/* type error; errmsg already given */
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	int	    error = FALSE;
+
+	start_idx = (int)get_tv_number_chk(&argvars[2], &error);
+	if (error || start_idx >= (int)STRLEN(haystack))
+	    return;
+	if (start_idx >= 0)
+	    haystack += start_idx;
+    }
+
+    pos	= (char_u *)strstr((char *)haystack, (char *)needle);
+    if (pos != NULL)
+	rettv->vval.v_number = (varnumber_T)(pos - save_haystack);
+}
+
+/*
+ * "string()" function
+ */
+    static void
+f_string(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*tofree;
+    char_u	numbuf[NUMBUFLEN];
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = tv2string(&argvars[0], &tofree, numbuf,
+								get_copyID());
+    /* Make a copy if we have a value but it's not in allocated memory. */
+    if (rettv->vval.v_string != NULL && tofree == NULL)
+	rettv->vval.v_string = vim_strsave(rettv->vval.v_string);
+}
+
+/*
+ * "strlen()" function
+ */
+    static void
+f_strlen(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = (varnumber_T)(STRLEN(
+					      get_tv_string(&argvars[0])));
+}
+
+/*
+ * "strchars()" function
+ */
+    static void
+f_strchars(typval_T *argvars, typval_T *rettv)
+{
+    char_u		*s = get_tv_string(&argvars[0]);
+    int			skipcc = 0;
+#ifdef FEAT_MBYTE
+    varnumber_T		len = 0;
+    int			(*func_mb_ptr2char_adv)(char_u **pp);
+#endif
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	skipcc = (int)get_tv_number_chk(&argvars[1], NULL);
+    if (skipcc < 0 || skipcc > 1)
+	EMSG(_(e_invarg));
+    else
+    {
+#ifdef FEAT_MBYTE
+	func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;
+	while (*s != NUL)
+	{
+	    func_mb_ptr2char_adv(&s);
+	    ++len;
+	}
+	rettv->vval.v_number = len;
+#else
+	rettv->vval.v_number = (varnumber_T)(STRLEN(s));
+#endif
+    }
+}
+
+/*
+ * "strdisplaywidth()" function
+ */
+    static void
+f_strdisplaywidth(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*s = get_tv_string(&argvars[0]);
+    int		col = 0;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	col = (int)get_tv_number(&argvars[1]);
+
+    rettv->vval.v_number = (varnumber_T)(linetabsize_col(col, s) - col);
+}
+
+/*
+ * "strwidth()" function
+ */
+    static void
+f_strwidth(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*s = get_tv_string(&argvars[0]);
+
+    rettv->vval.v_number = (varnumber_T)(
+#ifdef FEAT_MBYTE
+	    mb_string2cells(s, -1)
+#else
+	    STRLEN(s)
+#endif
+	    );
+}
+
+/*
+ * "strcharpart()" function
+ */
+    static void
+f_strcharpart(typval_T *argvars, typval_T *rettv)
+{
+#ifdef FEAT_MBYTE
+    char_u	*p;
+    int		nchar;
+    int		nbyte = 0;
+    int		charlen;
+    int		len = 0;
+    int		slen;
+    int		error = FALSE;
+
+    p = get_tv_string(&argvars[0]);
+    slen = (int)STRLEN(p);
+
+    nchar = (int)get_tv_number_chk(&argvars[1], &error);
+    if (!error)
+    {
+	if (nchar > 0)
+	    while (nchar > 0 && nbyte < slen)
+	    {
+		nbyte += MB_CPTR2LEN(p + nbyte);
+		--nchar;
+	    }
+	else
+	    nbyte = nchar;
+	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
+	    charlen = (int)get_tv_number(&argvars[2]);
+	    while (charlen > 0 && nbyte + len < slen)
+	    {
+		int off = nbyte + len;
+
+		if (off < 0)
+		    len += 1;
+		else
+		    len += MB_CPTR2LEN(p + off);
+		--charlen;
+	    }
+	}
+	else
+	    len = slen - nbyte;    /* default: all bytes that are available. */
+    }
+
+    /*
+     * Only return the overlap between the specified part and the actual
+     * string.
+     */
+    if (nbyte < 0)
+    {
+	len += nbyte;
+	nbyte = 0;
+    }
+    else if (nbyte > slen)
+	nbyte = slen;
+    if (len < 0)
+	len = 0;
+    else if (nbyte + len > slen)
+	len = slen - nbyte;
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = vim_strnsave(p + nbyte, len);
+#else
+    f_strpart(argvars, rettv);
+#endif
+}
+
+/*
+ * "strpart()" function
+ */
+    static void
+f_strpart(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*p;
+    int		n;
+    int		len;
+    int		slen;
+    int		error = FALSE;
+
+    p = get_tv_string(&argvars[0]);
+    slen = (int)STRLEN(p);
+
+    n = (int)get_tv_number_chk(&argvars[1], &error);
+    if (error)
+	len = 0;
+    else if (argvars[2].v_type != VAR_UNKNOWN)
+	len = (int)get_tv_number(&argvars[2]);
+    else
+	len = slen - n;	    /* default len: all bytes that are available. */
+
+    /*
+     * Only return the overlap between the specified part and the actual
+     * string.
+     */
+    if (n < 0)
+    {
+	len += n;
+	n = 0;
+    }
+    else if (n > slen)
+	n = slen;
+    if (len < 0)
+	len = 0;
+    else if (n + len > slen)
+	len = slen - n;
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = vim_strnsave(p + n, len);
+}
+
+/*
+ * "strridx()" function
+ */
+    static void
+f_strridx(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf[NUMBUFLEN];
+    char_u	*needle;
+    char_u	*haystack;
+    char_u	*rest;
+    char_u	*lastmatch = NULL;
+    int		haystack_len, end_idx;
+
+    needle = get_tv_string_chk(&argvars[1]);
+    haystack = get_tv_string_buf_chk(&argvars[0], buf);
+
+    rettv->vval.v_number = -1;
+    if (needle == NULL || haystack == NULL)
+	return;		/* type error; errmsg already given */
+
+    haystack_len = (int)STRLEN(haystack);
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	/* Third argument: upper limit for index */
+	end_idx = (int)get_tv_number_chk(&argvars[2], NULL);
+	if (end_idx < 0)
+	    return;	/* can never find a match */
+    }
+    else
+	end_idx = haystack_len;
+
+    if (*needle == NUL)
+    {
+	/* Empty string matches past the end. */
+	lastmatch = haystack + end_idx;
+    }
+    else
+    {
+	for (rest = haystack; *rest != '\0'; ++rest)
+	{
+	    rest = (char_u *)strstr((char *)rest, (char *)needle);
+	    if (rest == NULL || rest > haystack + end_idx)
+		break;
+	    lastmatch = rest;
+	}
+    }
+
+    if (lastmatch == NULL)
+	rettv->vval.v_number = -1;
+    else
+	rettv->vval.v_number = (varnumber_T)(lastmatch - haystack);
+}
+
+/*
+ * "strtrans()" function
+ */
+    static void
+f_strtrans(typval_T *argvars, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = transstr(get_tv_string(&argvars[0]));
+}
+
+/*
+ * "submatch()" function
+ */
+    static void
+f_submatch(typval_T *argvars, typval_T *rettv)
+{
+    int		error = FALSE;
+    int		no;
+    int		retList = 0;
+
+    no = (int)get_tv_number_chk(&argvars[0], &error);
+    if (error)
+	return;
+    if (no < 0 || no >= NSUBEXP)
+    {
+	EMSGN(_("E935: invalid submatch number: %d"), no);
+	return;
+    }
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	retList = (int)get_tv_number_chk(&argvars[1], &error);
+    if (error)
+	return;
+
+    if (retList == 0)
+    {
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = reg_submatch(no);
+    }
+    else
+    {
+	rettv->v_type = VAR_LIST;
+	rettv->vval.v_list = reg_submatch_list(no);
+    }
+}
+
+/*
+ * "substitute()" function
+ */
+    static void
+f_substitute(typval_T *argvars, typval_T *rettv)
+{
+    char_u	patbuf[NUMBUFLEN];
+    char_u	subbuf[NUMBUFLEN];
+    char_u	flagsbuf[NUMBUFLEN];
+
+    char_u	*str = get_tv_string_chk(&argvars[0]);
+    char_u	*pat = get_tv_string_buf_chk(&argvars[1], patbuf);
+    char_u	*sub = NULL;
+    typval_T	*expr = NULL;
+    char_u	*flg = get_tv_string_buf_chk(&argvars[3], flagsbuf);
+
+    if (argvars[2].v_type == VAR_FUNC || argvars[2].v_type == VAR_PARTIAL)
+	expr = &argvars[2];
+    else
+	sub = get_tv_string_buf_chk(&argvars[2], subbuf);
+
+    rettv->v_type = VAR_STRING;
+    if (str == NULL || pat == NULL || (sub == NULL && expr == NULL)
+								|| flg == NULL)
+	rettv->vval.v_string = NULL;
+    else
+	rettv->vval.v_string = do_string_sub(str, pat, sub, expr, flg);
+}
+
+/*
+ * "swapinfo(swap_filename)" function
+ */
+    static void
+f_swapinfo(typval_T *argvars, typval_T *rettv)
+{
+    if (rettv_dict_alloc(rettv) == OK)
+	get_b0_dict(get_tv_string(argvars), rettv->vval.v_dict);
+}
+
+/*
+ * "synID(lnum, col, trans)" function
+ */
+    static void
+f_synID(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		id = 0;
+#ifdef FEAT_SYN_HL
+    linenr_T	lnum;
+    colnr_T	col;
+    int		trans;
+    int		transerr = FALSE;
+
+    lnum = get_tv_lnum(argvars);		/* -1 on type error */
+    col = (linenr_T)get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
+    trans = (int)get_tv_number_chk(&argvars[2], &transerr);
+
+    if (!transerr && lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
+	    && col >= 0 && col < (long)STRLEN(ml_get(lnum)))
+	id = syn_get_id(curwin, lnum, (colnr_T)col, trans, NULL, FALSE);
+#endif
+
+    rettv->vval.v_number = id;
+}
+
+/*
+ * "synIDattr(id, what [, mode])" function
+ */
+    static void
+f_synIDattr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    char_u	*p = NULL;
+#ifdef FEAT_SYN_HL
+    int		id;
+    char_u	*what;
+    char_u	*mode;
+    char_u	modebuf[NUMBUFLEN];
+    int		modec;
+
+    id = (int)get_tv_number(&argvars[0]);
+    what = get_tv_string(&argvars[1]);
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	mode = get_tv_string_buf(&argvars[2], modebuf);
+	modec = TOLOWER_ASC(mode[0]);
+	if (modec != 't' && modec != 'c' && modec != 'g')
+	    modec = 0;	/* replace invalid with current */
+    }
+    else
+    {
+#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)
+	if (USE_24BIT)
+	    modec = 'g';
+	else
+#endif
+	    if (t_colors > 1)
+	    modec = 'c';
+	else
+	    modec = 't';
+    }
+
+
+    switch (TOLOWER_ASC(what[0]))
+    {
+	case 'b':
+		if (TOLOWER_ASC(what[1]) == 'g')	/* bg[#] */
+		    p = highlight_color(id, what, modec);
+		else					/* bold */
+		    p = highlight_has_attr(id, HL_BOLD, modec);
+		break;
+
+	case 'f':					/* fg[#] or font */
+		p = highlight_color(id, what, modec);
+		break;
+
+	case 'i':
+		if (TOLOWER_ASC(what[1]) == 'n')	/* inverse */
+		    p = highlight_has_attr(id, HL_INVERSE, modec);
+		else					/* italic */
+		    p = highlight_has_attr(id, HL_ITALIC, modec);
+		break;
+
+	case 'n':					/* name */
+		p = get_highlight_name_ext(NULL, id - 1, FALSE);
+		break;
+
+	case 'r':					/* reverse */
+		p = highlight_has_attr(id, HL_INVERSE, modec);
+		break;
+
+	case 's':
+		if (TOLOWER_ASC(what[1]) == 'p')	/* sp[#] */
+		    p = highlight_color(id, what, modec);
+							/* strikeout */
+		else if (TOLOWER_ASC(what[1]) == 't' &&
+			TOLOWER_ASC(what[2]) == 'r')
+		    p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);
+		else					/* standout */
+		    p = highlight_has_attr(id, HL_STANDOUT, modec);
+		break;
+
+	case 'u':
+		if (STRLEN(what) <= 5 || TOLOWER_ASC(what[5]) != 'c')
+							/* underline */
+		    p = highlight_has_attr(id, HL_UNDERLINE, modec);
+		else
+							/* undercurl */
+		    p = highlight_has_attr(id, HL_UNDERCURL, modec);
+		break;
+    }
+
+    if (p != NULL)
+	p = vim_strsave(p);
+#endif
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = p;
+}
+
+/*
+ * "synIDtrans(id)" function
+ */
+    static void
+f_synIDtrans(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		id;
+
+#ifdef FEAT_SYN_HL
+    id = (int)get_tv_number(&argvars[0]);
+
+    if (id > 0)
+	id = syn_get_final_id(id);
+    else
+#endif
+	id = 0;
+
+    rettv->vval.v_number = id;
+}
+
+/*
+ * "synconcealed(lnum, col)" function
+ */
+    static void
+f_synconcealed(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#if defined(FEAT_SYN_HL) && defined(FEAT_CONCEAL)
+    linenr_T	lnum;
+    colnr_T	col;
+    int		syntax_flags = 0;
+    int		cchar;
+    int		matchid = 0;
+    char_u	str[NUMBUFLEN];
+#endif
+
+    rettv_list_set(rettv, NULL);
+
+#if defined(FEAT_SYN_HL) && defined(FEAT_CONCEAL)
+    lnum = get_tv_lnum(argvars);		/* -1 on type error */
+    col = (colnr_T)get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
+
+    vim_memset(str, NUL, sizeof(str));
+
+    if (rettv_list_alloc(rettv) != FAIL)
+    {
+	if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
+	    && col >= 0 && col <= (long)STRLEN(ml_get(lnum))
+	    && curwin->w_p_cole > 0)
+	{
+	    (void)syn_get_id(curwin, lnum, col, FALSE, NULL, FALSE);
+	    syntax_flags = get_syntax_info(&matchid);
+
+	    /* get the conceal character */
+	    if ((syntax_flags & HL_CONCEAL) && curwin->w_p_cole < 3)
+	    {
+		cchar = syn_get_sub_char();
+		if (cchar == NUL && curwin->w_p_cole == 1)
+		    cchar = (lcs_conceal == NUL) ? ' ' : lcs_conceal;
+		if (cchar != NUL)
+		{
+# ifdef FEAT_MBYTE
+		    if (has_mbyte)
+			(*mb_char2bytes)(cchar, str);
+		    else
+# endif
+			str[0] = cchar;
+		}
+	    }
+	}
+
+	list_append_number(rettv->vval.v_list,
+					    (syntax_flags & HL_CONCEAL) != 0);
+	/* -1 to auto-determine strlen */
+	list_append_string(rettv->vval.v_list, str, -1);
+	list_append_number(rettv->vval.v_list, matchid);
+    }
+#endif
+}
+
+/*
+ * "synstack(lnum, col)" function
+ */
+    static void
+f_synstack(typval_T *argvars UNUSED, typval_T *rettv)
+{
+#ifdef FEAT_SYN_HL
+    linenr_T	lnum;
+    colnr_T	col;
+    int		i;
+    int		id;
+#endif
+
+    rettv_list_set(rettv, NULL);
+
+#ifdef FEAT_SYN_HL
+    lnum = get_tv_lnum(argvars);		/* -1 on type error */
+    col = (colnr_T)get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
+
+    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
+	    && col >= 0 && col <= (long)STRLEN(ml_get(lnum))
+	    && rettv_list_alloc(rettv) != FAIL)
+    {
+	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);
+	for (i = 0; ; ++i)
+	{
+	    id = syn_get_stack_item(i);
+	    if (id < 0)
+		break;
+	    if (list_append_number(rettv->vval.v_list, id) == FAIL)
+		break;
+	}
+    }
+#endif
+}
+
+    static void
+get_cmd_output_as_rettv(
+    typval_T	*argvars,
+    typval_T	*rettv,
+    int		retlist)
+{
+    char_u	*res = NULL;
+    char_u	*p;
+    char_u	*infile = NULL;
+    int		err = FALSE;
+    FILE	*fd;
+    list_T	*list = NULL;
+    int		flags = SHELL_SILENT;
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+    if (check_restricted() || check_secure())
+	goto errret;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+    {
+	/*
+	 * Write the text to a temp file, to be used for input of the shell
+	 * command.
+	 */
+	if ((infile = vim_tempname('i', TRUE)) == NULL)
+	{
+	    EMSG(_(e_notmp));
+	    goto errret;
+	}
+
+	fd = mch_fopen((char *)infile, WRITEBIN);
+	if (fd == NULL)
+	{
+	    EMSG2(_(e_notopen), infile);
+	    goto errret;
+	}
+	if (argvars[1].v_type == VAR_NUMBER)
+	{
+	    linenr_T	lnum;
+	    buf_T	*buf;
+
+	    buf = buflist_findnr(argvars[1].vval.v_number);
+	    if (buf == NULL)
+	    {
+		EMSGN(_(e_nobufnr), argvars[1].vval.v_number);
+		fclose(fd);
+		goto errret;
+	    }
+
+	    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; lnum++)
+	    {
+		for (p = ml_get_buf(buf, lnum, FALSE); *p != NUL; ++p)
+		    if (putc(*p == '\n' ? NUL : *p, fd) == EOF)
+		    {
+			err = TRUE;
+			break;
+		    }
+		if (putc(NL, fd) == EOF)
+		{
+		    err = TRUE;
+		    break;
+		}
+	    }
+	}
+	else if (argvars[1].v_type == VAR_LIST)
+	{
+	    if (write_list(fd, argvars[1].vval.v_list, TRUE) == FAIL)
+		err = TRUE;
+	}
+	else
+	{
+	    size_t	len;
+	    char_u	buf[NUMBUFLEN];
+
+	    p = get_tv_string_buf_chk(&argvars[1], buf);
+	    if (p == NULL)
+	    {
+		fclose(fd);
+		goto errret;		/* type error; errmsg already given */
+	    }
+	    len = STRLEN(p);
+	    if (len > 0 && fwrite(p, len, 1, fd) != 1)
+		err = TRUE;
+	}
+	if (fclose(fd) != 0)
+	    err = TRUE;
+	if (err)
+	{
+	    EMSG(_("E677: Error writing temp file"));
+	    goto errret;
+	}
+    }
+
+    /* Omit SHELL_COOKED when invoked with ":silent".  Avoids that the shell
+     * echoes typeahead, that messes up the display. */
+    if (!msg_silent)
+	flags += SHELL_COOKED;
+
+    if (retlist)
+    {
+	int		len;
+	listitem_T	*li;
+	char_u		*s = NULL;
+	char_u		*start;
+	char_u		*end;
+	int		i;
+
+	res = get_cmd_output(get_tv_string(&argvars[0]), infile, flags, &len);
+	if (res == NULL)
+	    goto errret;
+
+	list = list_alloc();
+	if (list == NULL)
+	    goto errret;
+
+	for (i = 0; i < len; ++i)
+	{
+	    start = res + i;
+	    while (i < len && res[i] != NL)
+		++i;
+	    end = res + i;
+
+	    s = alloc((unsigned)(end - start + 1));
+	    if (s == NULL)
+		goto errret;
+
+	    for (p = s; start < end; ++p, ++start)
+		*p = *start == NUL ? NL : *start;
+	    *p = NUL;
+
+	    li = listitem_alloc();
+	    if (li == NULL)
+	    {
+		vim_free(s);
+		goto errret;
+	    }
+	    li->li_tv.v_type = VAR_STRING;
+	    li->li_tv.v_lock = 0;
+	    li->li_tv.vval.v_string = s;
+	    list_append(list, li);
+	}
+
+	rettv_list_set(rettv, list);
+	list = NULL;
+    }
+    else
+    {
+	res = get_cmd_output(get_tv_string(&argvars[0]), infile, flags, NULL);
+#ifdef USE_CR
+	/* translate <CR> into <NL> */
+	if (res != NULL)
+	{
+	    char_u	*s;
+
+	    for (s = res; *s; ++s)
+	    {
+		if (*s == CAR)
+		    *s = NL;
+	    }
+	}
+#else
+# ifdef USE_CRNL
+	/* translate <CR><NL> into <NL> */
+	if (res != NULL)
+	{
+	    char_u	*s, *d;
+
+	    d = res;
+	    for (s = res; *s; ++s)
+	    {
+		if (s[0] == CAR && s[1] == NL)
+		    ++s;
+		*d++ = *s;
+	    }
+	    *d = NUL;
+	}
+# endif
+#endif
+	rettv->vval.v_string = res;
+	res = NULL;
+    }
+
+errret:
+    if (infile != NULL)
+    {
+	mch_remove(infile);
+	vim_free(infile);
+    }
+    if (res != NULL)
+	vim_free(res);
+    if (list != NULL)
+	list_free(list);
+}
+
+/*
+ * "system()" function
+ */
+    static void
+f_system(typval_T *argvars, typval_T *rettv)
+{
+    get_cmd_output_as_rettv(argvars, rettv, FALSE);
+}
+
+/*
+ * "systemlist()" function
+ */
+    static void
+f_systemlist(typval_T *argvars, typval_T *rettv)
+{
+    get_cmd_output_as_rettv(argvars, rettv, TRUE);
+}
+
+/*
+ * "tabpagebuflist()" function
+ */
+    static void
+f_tabpagebuflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+    tabpage_T	*tp;
+    win_T	*wp = NULL;
+
+    if (argvars[0].v_type == VAR_UNKNOWN)
+	wp = firstwin;
+    else
+    {
+	tp = find_tabpage((int)get_tv_number(&argvars[0]));
+	if (tp != NULL)
+	    wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
+    }
+    if (wp != NULL && rettv_list_alloc(rettv) != FAIL)
+    {
+	for (; wp != NULL; wp = wp->w_next)
+	    if (list_append_number(rettv->vval.v_list,
+						wp->w_buffer->b_fnum) == FAIL)
+		break;
+    }
+}
+
+
+/*
+ * "tabpagenr()" function
+ */
+    static void
+f_tabpagenr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		nr = 1;
+    char_u	*arg;
+
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	arg = get_tv_string_chk(&argvars[0]);
+	nr = 0;
+	if (arg != NULL)
+	{
+	    if (STRCMP(arg, "$") == 0)
+		nr = tabpage_index(NULL) - 1;
+	    else
+		EMSG2(_(e_invexpr2), arg);
+	}
+    }
+    else
+	nr = tabpage_index(curtab);
+    rettv->vval.v_number = nr;
+}
+
+
+static int get_winnr(tabpage_T *tp, typval_T *argvar);
+
+/*
+ * Common code for tabpagewinnr() and winnr().
+ */
+    static int
+get_winnr(tabpage_T *tp, typval_T *argvar)
+{
+    win_T	*twin;
+    int		nr = 1;
+    win_T	*wp;
+    char_u	*arg;
+
+    twin = (tp == curtab) ? curwin : tp->tp_curwin;
+    if (argvar->v_type != VAR_UNKNOWN)
+    {
+	arg = get_tv_string_chk(argvar);
+	if (arg == NULL)
+	    nr = 0;		/* type error; errmsg already given */
+	else if (STRCMP(arg, "$") == 0)
+	    twin = (tp == curtab) ? lastwin : tp->tp_lastwin;
+	else if (STRCMP(arg, "#") == 0)
+	{
+	    twin = (tp == curtab) ? prevwin : tp->tp_prevwin;
+	    if (twin == NULL)
+		nr = 0;
+	}
+	else
+	{
+	    EMSG2(_(e_invexpr2), arg);
+	    nr = 0;
+	}
+    }
+
+    if (nr > 0)
+	for (wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
+					      wp != twin; wp = wp->w_next)
+	{
+	    if (wp == NULL)
+	    {
+		/* didn't find it in this tabpage */
+		nr = 0;
+		break;
+	    }
+	    ++nr;
+	}
+    return nr;
+}
+
+/*
+ * "tabpagewinnr()" function
+ */
+    static void
+f_tabpagewinnr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		nr = 1;
+    tabpage_T	*tp;
+
+    tp = find_tabpage((int)get_tv_number(&argvars[0]));
+    if (tp == NULL)
+	nr = 0;
+    else
+	nr = get_winnr(tp, &argvars[1]);
+    rettv->vval.v_number = nr;
+}
+
+
+/*
+ * "tagfiles()" function
+ */
+    static void
+f_tagfiles(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    char_u	*fname;
+    tagname_T	tn;
+    int		first;
+
+    if (rettv_list_alloc(rettv) == FAIL)
+	return;
+    fname = alloc(MAXPATHL);
+    if (fname == NULL)
+	return;
+
+    for (first = TRUE; ; first = FALSE)
+	if (get_tagfname(&tn, first, fname) == FAIL
+		|| list_append_string(rettv->vval.v_list, fname, -1) == FAIL)
+	    break;
+    tagname_free(&tn);
+    vim_free(fname);
+}
+
+/*
+ * "taglist()" function
+ */
+    static void
+f_taglist(typval_T *argvars, typval_T *rettv)
+{
+    char_u  *fname = NULL;
+    char_u  *tag_pattern;
+
+    tag_pattern = get_tv_string(&argvars[0]);
+
+    rettv->vval.v_number = FALSE;
+    if (*tag_pattern == NUL)
+	return;
+
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	fname = get_tv_string(&argvars[1]);
+    if (rettv_list_alloc(rettv) == OK)
+	(void)get_tags(rettv->vval.v_list, tag_pattern, fname);
+}
+
+/*
+ * "tempname()" function
+ */
+    static void
+f_tempname(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    static int	x = 'A';
+
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = vim_tempname(x, FALSE);
+
+    /* Advance 'x' to use A-Z and 0-9, so that there are at least 34 different
+     * names.  Skip 'I' and 'O', they are used for shell redirection. */
+    do
+    {
+	if (x == 'Z')
+	    x = '0';
+	else if (x == '9')
+	    x = 'A';
+	else
+	{
+#ifdef EBCDIC
+	    if (x == 'I')
+		x = 'J';
+	    else if (x == 'R')
+		x = 'S';
+	    else
+#endif
+		++x;
+	}
+    } while (x == 'I' || x == 'O');
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "tan()" function
+ */
+    static void
+f_tan(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = tan(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+
+/*
+ * "tanh()" function
+ */
+    static void
+f_tanh(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	rettv->vval.v_float = tanh(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "test_alloc_fail(id, countdown, repeat)" function
+ */
+    static void
+f_test_alloc_fail(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    if (argvars[0].v_type != VAR_NUMBER
+	    || argvars[0].vval.v_number <= 0
+	    || argvars[1].v_type != VAR_NUMBER
+	    || argvars[1].vval.v_number < 0
+	    || argvars[2].v_type != VAR_NUMBER)
+	EMSG(_(e_invarg));
+    else
+    {
+	alloc_fail_id = argvars[0].vval.v_number;
+	if (alloc_fail_id >= aid_last)
+	    EMSG(_(e_invarg));
+	alloc_fail_countdown = argvars[1].vval.v_number;
+	alloc_fail_repeat = argvars[2].vval.v_number;
+	did_outofmem_msg = FALSE;
+    }
+}
+
+/*
+ * "test_autochdir()"
+ */
+    static void
+f_test_autochdir(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#if defined(FEAT_AUTOCHDIR)
+    test_autochdir = TRUE;
+#endif
+}
+
+/*
+ * "test_feedinput()"
+ */
+    static void
+f_test_feedinput(typval_T *argvars, typval_T *rettv UNUSED)
+{
+#ifdef USE_INPUT_BUF
+    char_u	*val = get_tv_string_chk(&argvars[0]);
+
+    if (val != NULL)
+    {
+	trash_input_buf();
+	add_to_input_buf_csi(val, (int)STRLEN(val));
+    }
+#endif
+}
+
+/*
+ * "test_disable({name}, {val})" function
+ */
+    static void
+f_test_override(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    char_u *name = (char_u *)"";
+    int     val;
+    static int save_starting = -1;
+
+    if (argvars[0].v_type != VAR_STRING
+	    || (argvars[1].v_type) != VAR_NUMBER)
+	EMSG(_(e_invarg));
+    else
+    {
+	name = get_tv_string_chk(&argvars[0]);
+	val = (int)get_tv_number(&argvars[1]);
+
+	if (STRCMP(name, (char_u *)"redraw") == 0)
+	    disable_redraw_for_testing = val;
+	else if (STRCMP(name, (char_u *)"char_avail") == 0)
+	    disable_char_avail_for_testing = val;
+	else if (STRCMP(name, (char_u *)"starting") == 0)
+	{
+	    if (val)
+	    {
+		if (save_starting < 0)
+		    save_starting = starting;
+		starting = 0;
+	    }
+	    else
+	    {
+		starting = save_starting;
+		save_starting = -1;
+	    }
+	}
+	else if (STRCMP(name, (char_u *)"nfa_fail") == 0)
+	    nfa_fail_for_testing = val;
+	else if (STRCMP(name, (char_u *)"ALL") == 0)
+	{
+	    disable_char_avail_for_testing = FALSE;
+	    disable_redraw_for_testing = FALSE;
+	    nfa_fail_for_testing = FALSE;
+	    if (save_starting >= 0)
+	    {
+		starting = save_starting;
+		save_starting = -1;
+	    }
+	}
+	else
+	    EMSG2(_(e_invarg2), name);
+    }
+}
+
+/*
+ * "test_garbagecollect_now()" function
+ */
+    static void
+f_test_garbagecollect_now(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+    /* This is dangerous, any Lists and Dicts used internally may be freed
+     * while still in use. */
+    garbage_collect(TRUE);
+}
+
+/*
+ * "test_ignore_error()" function
+ */
+    static void
+f_test_ignore_error(typval_T *argvars, typval_T *rettv UNUSED)
+{
+     ignore_error_for_testing(get_tv_string(&argvars[0]));
+}
+
+#ifdef FEAT_JOB_CHANNEL
+    static void
+f_test_null_channel(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_CHANNEL;
+    rettv->vval.v_channel = NULL;
+}
+#endif
+
+    static void
+f_test_null_dict(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv_dict_set(rettv, NULL);
+}
+
+#ifdef FEAT_JOB_CHANNEL
+    static void
+f_test_null_job(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_JOB;
+    rettv->vval.v_job = NULL;
+}
+#endif
+
+    static void
+f_test_null_list(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv_list_set(rettv, NULL);
+}
+
+    static void
+f_test_null_partial(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_PARTIAL;
+    rettv->vval.v_partial = NULL;
+}
+
+    static void
+f_test_null_string(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+}
+
+    static void
+f_test_settime(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    time_for_testing = (time_t)get_tv_number(&argvars[0]);
+}
+
+#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_TIMERS) || defined(PROTO)
+/*
+ * Get a callback from "arg".  It can be a Funcref or a function name.
+ * When "arg" is zero return an empty string.
+ * Return NULL for an invalid argument.
+ */
+    char_u *
+get_callback(typval_T *arg, partial_T **pp)
+{
+    if (arg->v_type == VAR_PARTIAL && arg->vval.v_partial != NULL)
+    {
+	*pp = arg->vval.v_partial;
+	++(*pp)->pt_refcount;
+	return partial_name(*pp);
+    }
+    *pp = NULL;
+    if (arg->v_type == VAR_FUNC || arg->v_type == VAR_STRING)
+    {
+	func_ref(arg->vval.v_string);
+	return arg->vval.v_string;
+    }
+    if (arg->v_type == VAR_NUMBER && arg->vval.v_number == 0)
+	return (char_u *)"";
+    EMSG(_("E921: Invalid callback argument"));
+    return NULL;
+}
+
+/*
+ * Unref/free "callback" and "partial" returned by get_callback().
+ */
+    void
+free_callback(char_u *callback, partial_T *partial)
+{
+    if (partial != NULL)
+	partial_unref(partial);
+    else if (callback != NULL)
+    {
+	func_unref(callback);
+	vim_free(callback);
+    }
+}
+#endif
+
+#ifdef FEAT_TIMERS
+/*
+ * "timer_info([timer])" function
+ */
+    static void
+f_timer_info(typval_T *argvars, typval_T *rettv)
+{
+    timer_T *timer = NULL;
+
+    if (rettv_list_alloc(rettv) != OK)
+	return;
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	if (argvars[0].v_type != VAR_NUMBER)
+	    EMSG(_(e_number_exp));
+	else
+	{
+	    timer = find_timer((int)get_tv_number(&argvars[0]));
+	    if (timer != NULL)
+		add_timer_info(rettv, timer);
+	}
+    }
+    else
+	add_timer_info_all(rettv);
+}
+
+/*
+ * "timer_pause(timer, paused)" function
+ */
+    static void
+f_timer_pause(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    timer_T	*timer = NULL;
+    int		paused = (int)get_tv_number(&argvars[1]);
+
+    if (argvars[0].v_type != VAR_NUMBER)
+	EMSG(_(e_number_exp));
+    else
+    {
+	timer = find_timer((int)get_tv_number(&argvars[0]));
+	if (timer != NULL)
+	    timer->tr_paused = paused;
+    }
+}
+
+/*
+ * "timer_start(time, callback [, options])" function
+ */
+    static void
+f_timer_start(typval_T *argvars, typval_T *rettv)
+{
+    long	msec = (long)get_tv_number(&argvars[0]);
+    timer_T	*timer;
+    int		repeat = 0;
+    char_u	*callback;
+    dict_T	*dict;
+    partial_T	*partial;
+
+    rettv->vval.v_number = -1;
+    if (check_secure())
+	return;
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	if (argvars[2].v_type != VAR_DICT
+				   || (dict = argvars[2].vval.v_dict) == NULL)
+	{
+	    EMSG2(_(e_invarg2), get_tv_string(&argvars[2]));
+	    return;
+	}
+	if (dict_find(dict, (char_u *)"repeat", -1) != NULL)
+	    repeat = get_dict_number(dict, (char_u *)"repeat");
+    }
+
+    callback = get_callback(&argvars[1], &partial);
+    if (callback == NULL)
+	return;
+
+    timer = create_timer(msec, repeat);
+    if (timer == NULL)
+	free_callback(callback, partial);
+    else
+    {
+	if (partial == NULL)
+	    timer->tr_callback = vim_strsave(callback);
+	else
+	    /* pointer into the partial */
+	    timer->tr_callback = callback;
+	timer->tr_partial = partial;
+	rettv->vval.v_number = (varnumber_T)timer->tr_id;
+    }
+}
+
+/*
+ * "timer_stop(timer)" function
+ */
+    static void
+f_timer_stop(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    timer_T *timer;
+
+    if (argvars[0].v_type != VAR_NUMBER)
+    {
+	EMSG(_(e_number_exp));
+	return;
+    }
+    timer = find_timer((int)get_tv_number(&argvars[0]));
+    if (timer != NULL)
+	stop_timer(timer);
+}
+
+/*
+ * "timer_stopall()" function
+ */
+    static void
+f_timer_stopall(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+    stop_all_timers();
+}
+#endif
+
+/*
+ * "tolower(string)" function
+ */
+    static void
+f_tolower(typval_T *argvars, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = strlow_save(get_tv_string(&argvars[0]));
+}
+
+/*
+ * "toupper(string)" function
+ */
+    static void
+f_toupper(typval_T *argvars, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = strup_save(get_tv_string(&argvars[0]));
+}
+
+/*
+ * "tr(string, fromstr, tostr)" function
+ */
+    static void
+f_tr(typval_T *argvars, typval_T *rettv)
+{
+    char_u	*in_str;
+    char_u	*fromstr;
+    char_u	*tostr;
+    char_u	*p;
+#ifdef FEAT_MBYTE
+    int		inlen;
+    int		fromlen;
+    int		tolen;
+    int		idx;
+    char_u	*cpstr;
+    int		cplen;
+    int		first = TRUE;
+#endif
+    char_u	buf[NUMBUFLEN];
+    char_u	buf2[NUMBUFLEN];
+    garray_T	ga;
+
+    in_str = get_tv_string(&argvars[0]);
+    fromstr = get_tv_string_buf_chk(&argvars[1], buf);
+    tostr = get_tv_string_buf_chk(&argvars[2], buf2);
+
+    /* Default return value: empty string. */
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+    if (fromstr == NULL || tostr == NULL)
+	    return;		/* type error; errmsg already given */
+    ga_init2(&ga, (int)sizeof(char), 80);
+
+#ifdef FEAT_MBYTE
+    if (!has_mbyte)
+#endif
+	/* not multi-byte: fromstr and tostr must be the same length */
+	if (STRLEN(fromstr) != STRLEN(tostr))
+	{
+#ifdef FEAT_MBYTE
+error:
+#endif
+	    EMSG2(_(e_invarg2), fromstr);
+	    ga_clear(&ga);
+	    return;
+	}
+
+    /* fromstr and tostr have to contain the same number of chars */
+    while (*in_str != NUL)
+    {
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    inlen = (*mb_ptr2len)(in_str);
+	    cpstr = in_str;
+	    cplen = inlen;
+	    idx = 0;
+	    for (p = fromstr; *p != NUL; p += fromlen)
+	    {
+		fromlen = (*mb_ptr2len)(p);
+		if (fromlen == inlen && STRNCMP(in_str, p, inlen) == 0)
+		{
+		    for (p = tostr; *p != NUL; p += tolen)
+		    {
+			tolen = (*mb_ptr2len)(p);
+			if (idx-- == 0)
+			{
+			    cplen = tolen;
+			    cpstr = p;
+			    break;
+			}
+		    }
+		    if (*p == NUL)	/* tostr is shorter than fromstr */
+			goto error;
+		    break;
+		}
+		++idx;
+	    }
+
+	    if (first && cpstr == in_str)
+	    {
+		/* Check that fromstr and tostr have the same number of
+		 * (multi-byte) characters.  Done only once when a character
+		 * of in_str doesn't appear in fromstr. */
+		first = FALSE;
+		for (p = tostr; *p != NUL; p += tolen)
+		{
+		    tolen = (*mb_ptr2len)(p);
+		    --idx;
+		}
+		if (idx != 0)
+		    goto error;
+	    }
+
+	    (void)ga_grow(&ga, cplen);
+	    mch_memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);
+	    ga.ga_len += cplen;
+
+	    in_str += inlen;
+	}
+	else
+#endif
+	{
+	    /* When not using multi-byte chars we can do it faster. */
+	    p = vim_strchr(fromstr, *in_str);
+	    if (p != NULL)
+		ga_append(&ga, tostr[p - fromstr]);
+	    else
+		ga_append(&ga, *in_str);
+	    ++in_str;
+	}
+    }
+
+    /* add a terminating NUL */
+    (void)ga_grow(&ga, 1);
+    ga_append(&ga, NUL);
+
+    rettv->vval.v_string = ga.ga_data;
+}
+
+/*
+ * "trim({expr})" function
+ */
+    static void
+f_trim(typval_T *argvars, typval_T *rettv)
+{
+    char_u	buf1[NUMBUFLEN];
+    char_u	buf2[NUMBUFLEN];
+    char_u	*head = get_tv_string_buf_chk(&argvars[0], buf1);
+    char_u	*mask = NULL;
+    char_u	*tail;
+    char_u	*prev;
+    char_u	*p;
+    int		c1;
+
+    rettv->v_type = VAR_STRING;
+    if (head == NULL)
+    {
+	rettv->vval.v_string = NULL;
+	return;
+    }
+
+    if (argvars[1].v_type == VAR_STRING)
+	mask = get_tv_string_buf_chk(&argvars[1], buf2);
+
+    while (*head != NUL)
+    {
+	c1 = PTR2CHAR(head);
+	if (mask == NULL)
+	{
+	    if (c1 > ' ' && c1 != 0xa0)
+		break;
+	}
+	else
+	{
+	    for (p = mask; *p != NUL; MB_PTR_ADV(p))
+		if (c1 == PTR2CHAR(p))
+		    break;
+	    if (*p == NUL)
+		break;
+	}
+	MB_PTR_ADV(head);
+    }
+
+    for (tail = head + STRLEN(head); tail > head; tail = prev)
+    {
+	prev = tail;
+	MB_PTR_BACK(head, prev);
+	c1 = PTR2CHAR(prev);
+	if (mask == NULL)
+	{
+	    if (c1 > ' ' && c1 != 0xa0)
+		break;
+	}
+	else
+	{
+	    for (p = mask; *p != NUL; MB_PTR_ADV(p))
+		if (c1 == PTR2CHAR(p))
+		    break;
+	    if (*p == NUL)
+		break;
+	}
+    }
+    rettv->vval.v_string = vim_strnsave(head, (int)(tail - head));
+}
+
+#ifdef FEAT_FLOAT
+/*
+ * "trunc({float})" function
+ */
+    static void
+f_trunc(typval_T *argvars, typval_T *rettv)
+{
+    float_T	f = 0.0;
+
+    rettv->v_type = VAR_FLOAT;
+    if (get_float_arg(argvars, &f) == OK)
+	/* trunc() is not in C90, use floor() or ceil() instead. */
+	rettv->vval.v_float = f > 0 ? floor(f) : ceil(f);
+    else
+	rettv->vval.v_float = 0.0;
+}
+#endif
+
+/*
+ * "type(expr)" function
+ */
+    static void
+f_type(typval_T *argvars, typval_T *rettv)
+{
+    int n = -1;
+
+    switch (argvars[0].v_type)
+    {
+	case VAR_NUMBER: n = VAR_TYPE_NUMBER; break;
+	case VAR_STRING: n = VAR_TYPE_STRING; break;
+	case VAR_PARTIAL:
+	case VAR_FUNC:   n = VAR_TYPE_FUNC; break;
+	case VAR_LIST:   n = VAR_TYPE_LIST; break;
+	case VAR_DICT:   n = VAR_TYPE_DICT; break;
+	case VAR_FLOAT:  n = VAR_TYPE_FLOAT; break;
+	case VAR_SPECIAL:
+	     if (argvars[0].vval.v_number == VVAL_FALSE
+		     || argvars[0].vval.v_number == VVAL_TRUE)
+		 n = VAR_TYPE_BOOL;
+	     else
+		 n = VAR_TYPE_NONE;
+	     break;
+	case VAR_JOB:     n = VAR_TYPE_JOB; break;
+	case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;
+	case VAR_UNKNOWN:
+	     internal_error("f_type(UNKNOWN)");
+	     n = -1;
+	     break;
+    }
+    rettv->vval.v_number = n;
+}
+
+/*
+ * "undofile(name)" function
+ */
+    static void
+f_undofile(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    rettv->v_type = VAR_STRING;
+#ifdef FEAT_PERSISTENT_UNDO
+    {
+	char_u *fname = get_tv_string(&argvars[0]);
+
+	if (*fname == NUL)
+	{
+	    /* If there is no file name there will be no undo file. */
+	    rettv->vval.v_string = NULL;
+	}
+	else
+	{
+	    char_u *ffname = FullName_save(fname, FALSE);
+
+	    if (ffname != NULL)
+		rettv->vval.v_string = u_get_undo_file_name(ffname, FALSE);
+	    vim_free(ffname);
+	}
+    }
+#else
+    rettv->vval.v_string = NULL;
+#endif
+}
+
+/*
+ * "undotree()" function
+ */
+    static void
+f_undotree(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    if (rettv_dict_alloc(rettv) == OK)
+    {
+	dict_T *dict = rettv->vval.v_dict;
+	list_T *list;
+
+	dict_add_number(dict, "synced", (long)curbuf->b_u_synced);
+	dict_add_number(dict, "seq_last", curbuf->b_u_seq_last);
+	dict_add_number(dict, "save_last", (long)curbuf->b_u_save_nr_last);
+	dict_add_number(dict, "seq_cur", curbuf->b_u_seq_cur);
+	dict_add_number(dict, "time_cur", (long)curbuf->b_u_time_cur);
+	dict_add_number(dict, "save_cur", (long)curbuf->b_u_save_nr_cur);
+
+	list = list_alloc();
+	if (list != NULL)
+	{
+	    u_eval_tree(curbuf->b_u_oldhead, list);
+	    dict_add_list(dict, "entries", list);
+	}
+    }
+}
+
+/*
+ * "values(dict)" function
+ */
+    static void
+f_values(typval_T *argvars, typval_T *rettv)
+{
+    dict_list(argvars, rettv, 1);
+}
+
+/*
+ * "virtcol(string)" function
+ */
+    static void
+f_virtcol(typval_T *argvars, typval_T *rettv)
+{
+    colnr_T	vcol = 0;
+    pos_T	*fp;
+    int		fnum = curbuf->b_fnum;
+
+    fp = var2fpos(&argvars[0], FALSE, &fnum);
+    if (fp != NULL && fp->lnum <= curbuf->b_ml.ml_line_count
+						    && fnum == curbuf->b_fnum)
+    {
+	getvvcol(curwin, fp, NULL, NULL, &vcol);
+	++vcol;
+    }
+
+    rettv->vval.v_number = vcol;
+}
+
+/*
+ * "visualmode()" function
+ */
+    static void
+f_visualmode(typval_T *argvars, typval_T *rettv)
+{
+    char_u	str[2];
+
+    rettv->v_type = VAR_STRING;
+    str[0] = curbuf->b_visual_mode_eval;
+    str[1] = NUL;
+    rettv->vval.v_string = vim_strsave(str);
+
+    /* A non-zero number or non-empty string argument: reset mode. */
+    if (non_zero_arg(&argvars[0]))
+	curbuf->b_visual_mode_eval = NUL;
+}
+
+/*
+ * "wildmenumode()" function
+ */
+    static void
+f_wildmenumode(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+{
+#ifdef FEAT_WILDMENU
+    if (wild_menu_showing)
+	rettv->vval.v_number = 1;
+#endif
+}
+
+/*
+ * "winbufnr(nr)" function
+ */
+    static void
+f_winbufnr(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*wp;
+
+    wp = find_win_by_nr(&argvars[0], NULL);
+    if (wp == NULL)
+	rettv->vval.v_number = -1;
+    else
+	rettv->vval.v_number = wp->w_buffer->b_fnum;
+}
+
+/*
+ * "wincol()" function
+ */
+    static void
+f_wincol(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    validate_cursor();
+    rettv->vval.v_number = curwin->w_wcol + 1;
+}
+
+/*
+ * "winheight(nr)" function
+ */
+    static void
+f_winheight(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*wp;
+
+    wp = find_win_by_nr(&argvars[0], NULL);
+    if (wp == NULL)
+	rettv->vval.v_number = -1;
+    else
+	rettv->vval.v_number = wp->w_height;
+}
+
+/*
+ * "winlayout()" function
+ */
+    static void
+f_winlayout(typval_T *argvars, typval_T *rettv)
+{
+    tabpage_T	*tp;
+
+    if (rettv_list_alloc(rettv) != OK)
+	return;
+
+    if (argvars[0].v_type == VAR_UNKNOWN)
+	tp = curtab;
+    else
+    {
+	tp = find_tabpage((int)get_tv_number(&argvars[0]));
+	if (tp == NULL)
+	    return;
+    }
+
+    get_framelayout(tp->tp_topframe, rettv->vval.v_list, TRUE);
+}
+
+/*
+ * "winline()" function
+ */
+    static void
+f_winline(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    validate_cursor();
+    rettv->vval.v_number = curwin->w_wrow + 1;
+}
+
+/*
+ * "winnr()" function
+ */
+    static void
+f_winnr(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    int		nr = 1;
+
+    nr = get_winnr(curtab, &argvars[0]);
+    rettv->vval.v_number = nr;
+}
+
+/*
+ * "winrestcmd()" function
+ */
+    static void
+f_winrestcmd(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    win_T	*wp;
+    int		winnr = 1;
+    garray_T	ga;
+    char_u	buf[50];
+
+    ga_init2(&ga, (int)sizeof(char), 70);
+    FOR_ALL_WINDOWS(wp)
+    {
+	sprintf((char *)buf, "%dresize %d|", winnr, wp->w_height);
+	ga_concat(&ga, buf);
+	sprintf((char *)buf, "vert %dresize %d|", winnr, wp->w_width);
+	ga_concat(&ga, buf);
+	++winnr;
+    }
+    ga_append(&ga, NUL);
+
+    rettv->vval.v_string = ga.ga_data;
+    rettv->v_type = VAR_STRING;
+}
+
+/*
+ * "winrestview()" function
+ */
+    static void
+f_winrestview(typval_T *argvars, typval_T *rettv UNUSED)
+{
+    dict_T	*dict;
+
+    if (argvars[0].v_type != VAR_DICT
+	    || (dict = argvars[0].vval.v_dict) == NULL)
+	EMSG(_(e_invarg));
+    else
+    {
+	if (dict_find(dict, (char_u *)"lnum", -1) != NULL)
+	    curwin->w_cursor.lnum = (linenr_T)get_dict_number(dict, (char_u *)"lnum");
+	if (dict_find(dict, (char_u *)"col", -1) != NULL)
+	    curwin->w_cursor.col = (colnr_T)get_dict_number(dict, (char_u *)"col");
+#ifdef FEAT_VIRTUALEDIT
+	if (dict_find(dict, (char_u *)"coladd", -1) != NULL)
+	    curwin->w_cursor.coladd = (colnr_T)get_dict_number(dict, (char_u *)"coladd");
+#endif
+	if (dict_find(dict, (char_u *)"curswant", -1) != NULL)
+	{
+	    curwin->w_curswant = (colnr_T)get_dict_number(dict, (char_u *)"curswant");
+	    curwin->w_set_curswant = FALSE;
+	}
+
+	if (dict_find(dict, (char_u *)"topline", -1) != NULL)
+	    set_topline(curwin, (linenr_T)get_dict_number(dict, (char_u *)"topline"));
+#ifdef FEAT_DIFF
+	if (dict_find(dict, (char_u *)"topfill", -1) != NULL)
+	    curwin->w_topfill = (int)get_dict_number(dict, (char_u *)"topfill");
+#endif
+	if (dict_find(dict, (char_u *)"leftcol", -1) != NULL)
+	    curwin->w_leftcol = (colnr_T)get_dict_number(dict, (char_u *)"leftcol");
+	if (dict_find(dict, (char_u *)"skipcol", -1) != NULL)
+	    curwin->w_skipcol = (colnr_T)get_dict_number(dict, (char_u *)"skipcol");
+
+	check_cursor();
+	win_new_height(curwin, curwin->w_height);
+	win_new_width(curwin, curwin->w_width);
+	changed_window_setting();
+
+	if (curwin->w_topline <= 0)
+	    curwin->w_topline = 1;
+	if (curwin->w_topline > curbuf->b_ml.ml_line_count)
+	    curwin->w_topline = curbuf->b_ml.ml_line_count;
+#ifdef FEAT_DIFF
+	check_topfill(curwin, TRUE);
+#endif
+    }
+}
+
+/*
+ * "winsaveview()" function
+ */
+    static void
+f_winsaveview(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    dict_T	*dict;
+
+    if (rettv_dict_alloc(rettv) == FAIL)
+	return;
+    dict = rettv->vval.v_dict;
+
+    dict_add_number(dict, "lnum", (long)curwin->w_cursor.lnum);
+    dict_add_number(dict, "col", (long)curwin->w_cursor.col);
+#ifdef FEAT_VIRTUALEDIT
+    dict_add_number(dict, "coladd", (long)curwin->w_cursor.coladd);
+#endif
+    update_curswant();
+    dict_add_number(dict, "curswant", (long)curwin->w_curswant);
+
+    dict_add_number(dict, "topline", (long)curwin->w_topline);
+#ifdef FEAT_DIFF
+    dict_add_number(dict, "topfill", (long)curwin->w_topfill);
+#endif
+    dict_add_number(dict, "leftcol", (long)curwin->w_leftcol);
+    dict_add_number(dict, "skipcol", (long)curwin->w_skipcol);
+}
+
+/*
+ * "winwidth(nr)" function
+ */
+    static void
+f_winwidth(typval_T *argvars, typval_T *rettv)
+{
+    win_T	*wp;
+
+    wp = find_win_by_nr(&argvars[0], NULL);
+    if (wp == NULL)
+	rettv->vval.v_number = -1;
+    else
+	rettv->vval.v_number = wp->w_width;
+}
+
+/*
+ * "wordcount()" function
+ */
+    static void
+f_wordcount(typval_T *argvars UNUSED, typval_T *rettv)
+{
+    if (rettv_dict_alloc(rettv) == FAIL)
+	return;
+    cursor_pos_info(rettv->vval.v_dict);
+}
+
+/*
+ * "writefile()" function
+ */
+    static void
+f_writefile(typval_T *argvars, typval_T *rettv)
+{
+    int		binary = FALSE;
+    int		append = FALSE;
+#ifdef HAVE_FSYNC
+    int		do_fsync = p_fs;
+#endif
+    char_u	*fname;
+    FILE	*fd;
+    int		ret = 0;
+    listitem_T	*li;
+    list_T	*list;
+
+    rettv->vval.v_number = -1;
+    if (check_restricted() || check_secure())
+	return;
+
+    if (argvars[0].v_type != VAR_LIST)
+    {
+	EMSG2(_(e_listarg), "writefile()");
+	return;
+    }
+    list = argvars[0].vval.v_list;
+    if (list == NULL)
+	return;
+    for (li = list->lv_first; li != NULL; li = li->li_next)
+	if (get_tv_string_chk(&li->li_tv) == NULL)
+	    return;
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	char_u *arg2 = get_tv_string_chk(&argvars[2]);
+
+	if (arg2 == NULL)
+	    return;
+	if (vim_strchr(arg2, 'b') != NULL)
+	    binary = TRUE;
+	if (vim_strchr(arg2, 'a') != NULL)
+	    append = TRUE;
+#ifdef HAVE_FSYNC
+	if (vim_strchr(arg2, 's') != NULL)
+	    do_fsync = TRUE;
+	else if (vim_strchr(arg2, 'S') != NULL)
+	    do_fsync = FALSE;
+#endif
+    }
+
+    fname = get_tv_string_chk(&argvars[1]);
+    if (fname == NULL)
+	return;
+
+    /* Always open the file in binary mode, library functions have a mind of
+     * their own about CR-LF conversion. */
+    if (*fname == NUL || (fd = mch_fopen((char *)fname,
+				      append ? APPENDBIN : WRITEBIN)) == NULL)
+    {
+	EMSG2(_(e_notcreate), *fname == NUL ? (char_u *)_("<empty>") : fname);
+	ret = -1;
+    }
+    else
+    {
+	if (write_list(fd, list, binary) == FAIL)
+	    ret = -1;
+#ifdef HAVE_FSYNC
+	else if (do_fsync)
+	    /* Ignore the error, the user wouldn't know what to do about it.
+	     * May happen for a device. */
+	    ignored = fsync(fileno(fd));
+#endif
+	fclose(fd);
+    }
+
+    rettv->vval.v_number = ret;
+}
+
+/*
+ * "xor(expr, expr)" function
+ */
+    static void
+f_xor(typval_T *argvars, typval_T *rettv)
+{
+    rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
+					^ get_tv_number_chk(&argvars[1], NULL);
+}
+
+
+#endif /* FEAT_EVAL */
diff --git a/src/ex_cmds.c b/src/ex_cmds.c
index 6e713c4..0d7f4d3 100644
--- a/src/ex_cmds.c
+++ b/src/ex_cmds.c
@@ -14,6 +14,9 @@
 #include "vim.h"
 #include "version.h"
 
+#include <sys/stat.h>
+#include <string.h>
+
 #ifdef FEAT_FLOAT
 # include <float.h>
 #endif
@@ -1913,6 +1916,8 @@ write_viminfo(char_u *file, int forceit)
     int		hidden = FALSE;
 #endif
 
+char* filenameSeparatorPos;
+
     if (no_viminfo())
 	return;
 
@@ -1920,6 +1925,19 @@ write_viminfo(char_u *file, int forceit)
     if (fname == NULL)
 	return;
 
+	/* Ensure that configuration folder(for viminfo) exist */
+	filenameSeparatorPos = strrchr(fname, '/');
+	if(filenameSeparatorPos != NULL &&
+		filenameSeparatorPos - (char*)fname > 1) {
+		// > 1 because root directory always exists anyway
+		*filenameSeparatorPos = '\0';
+			//<fname, filenameSparatorPos) is directory path
+		mkdir(fname, S_IRWXU);
+
+		*filenameSeparatorPos = '/';
+			//restore original filename
+	}
+
     fp_in = mch_fopen((char *)fname, READBIN);
     if (fp_in == NULL)
     {
diff --git a/b/src/ex_cmds.c.orig b/src/ex_cmds.c.orig
new file mode 100644
index 0000000..6e713c4
--- /dev/null
+++ b/src/ex_cmds.c.orig
@@ -0,0 +1,8584 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * ex_cmds.c: some functions for command line commands
+ */
+
+#include "vim.h"
+#include "version.h"
+
+#ifdef FEAT_FLOAT
+# include <float.h>
+#endif
+
+static int linelen(int *has_tab);
+static void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out);
+#ifdef FEAT_VIMINFO
+static char_u *viminfo_filename(char_u	*);
+static void do_viminfo(FILE *fp_in, FILE *fp_out, int flags);
+static int viminfo_encoding(vir_T *virp);
+static int read_viminfo_up_to_marks(vir_T *virp, int forceit, int writing);
+#endif
+
+static int check_readonly(int *forceit, buf_T *buf);
+static void delbuf_msg(char_u *name);
+static int
+#ifdef __BORLANDC__
+    _RTLENTRYF
+#endif
+	help_compare(const void *s1, const void *s2);
+static void prepare_help_buffer(void);
+
+/*
+ * ":ascii" and "ga".
+ */
+    void
+do_ascii(exarg_T *eap UNUSED)
+{
+    int		c;
+    int		cval;
+    char	buf1[20];
+    char	buf2[20];
+    char_u	buf3[7];
+#ifdef FEAT_DIGRAPHS
+    char_u      *dig;
+#endif
+#ifdef FEAT_MBYTE
+    int		cc[MAX_MCO];
+    int		ci = 0;
+    int		len;
+
+    if (enc_utf8)
+	c = utfc_ptr2char(ml_get_cursor(), cc);
+    else
+#endif
+	c = gchar_cursor();
+    if (c == NUL)
+    {
+	MSG("NUL");
+	return;
+    }
+
+#ifdef FEAT_MBYTE
+    IObuff[0] = NUL;
+    if (!has_mbyte || (enc_dbcs != 0 && c < 0x100) || c < 0x80)
+#endif
+    {
+	if (c == NL)	    /* NUL is stored as NL */
+	    c = NUL;
+	if (c == CAR && get_fileformat(curbuf) == EOL_MAC)
+	    cval = NL;	    /* NL is stored as CR */
+	else
+	    cval = c;
+	if (vim_isprintc_strict(c) && (c < ' '
+#ifndef EBCDIC
+		    || c > '~'
+#endif
+			       ))
+	{
+	    transchar_nonprint(buf3, c);
+	    vim_snprintf(buf1, sizeof(buf1), "  <%s>", (char *)buf3);
+	}
+	else
+	    buf1[0] = NUL;
+#ifndef EBCDIC
+	if (c >= 0x80)
+	    vim_snprintf(buf2, sizeof(buf2), "  <M-%s>",
+						 (char *)transchar(c & 0x7f));
+	else
+#endif
+	    buf2[0] = NUL;
+#ifdef FEAT_DIGRAPHS
+	dig = get_digraph_for_char(cval);
+	if (dig != NULL)
+	    vim_snprintf((char *)IObuff, IOSIZE,
+		_("<%s>%s%s  %d,  Hex %02x,  Oct %03o, Digr %s"),
+			      transchar(c), buf1, buf2, cval, cval, cval, dig);
+	else
+#endif
+	    vim_snprintf((char *)IObuff, IOSIZE,
+		_("<%s>%s%s  %d,  Hex %02x,  Octal %03o"),
+				  transchar(c), buf1, buf2, cval, cval, cval);
+#ifdef FEAT_MBYTE
+	if (enc_utf8)
+	    c = cc[ci++];
+	else
+	    c = 0;
+#endif
+    }
+
+#ifdef FEAT_MBYTE
+    /* Repeat for combining characters. */
+    while (has_mbyte && (c >= 0x100 || (enc_utf8 && c >= 0x80)))
+    {
+	len = (int)STRLEN(IObuff);
+	/* This assumes every multi-byte char is printable... */
+	if (len > 0)
+	    IObuff[len++] = ' ';
+	IObuff[len++] = '<';
+	if (enc_utf8 && utf_iscomposing(c)
+# ifdef USE_GUI
+		&& !gui.in_use
+# endif
+		)
+	    IObuff[len++] = ' '; /* draw composing char on top of a space */
+	len += (*mb_char2bytes)(c, IObuff + len);
+#ifdef FEAT_DIGRAPHS
+	dig = get_digraph_for_char(c);
+	if (dig != NULL)
+	    vim_snprintf((char *)IObuff + len, IOSIZE - len,
+			c < 0x10000 ? _("> %d, Hex %04x, Oct %o, Digr %s")
+				    : _("> %d, Hex %08x, Oct %o, Digr %s"),
+					c, c, c, dig);
+	else
+#endif
+	    vim_snprintf((char *)IObuff + len, IOSIZE - len,
+			 c < 0x10000 ? _("> %d, Hex %04x, Octal %o")
+				     : _("> %d, Hex %08x, Octal %o"),
+				     c, c, c);
+	if (ci == MAX_MCO)
+	    break;
+	if (enc_utf8)
+	    c = cc[ci++];
+	else
+	    c = 0;
+    }
+#endif
+
+    msg(IObuff);
+}
+
+/*
+ * ":left", ":center" and ":right": align text.
+ */
+    void
+ex_align(exarg_T *eap)
+{
+    pos_T	save_curpos;
+    int		len;
+    int		indent = 0;
+    int		new_indent;
+    int		has_tab;
+    int		width;
+
+#ifdef FEAT_RIGHTLEFT
+    if (curwin->w_p_rl)
+    {
+	/* switch left and right aligning */
+	if (eap->cmdidx == CMD_right)
+	    eap->cmdidx = CMD_left;
+	else if (eap->cmdidx == CMD_left)
+	    eap->cmdidx = CMD_right;
+    }
+#endif
+
+    width = atoi((char *)eap->arg);
+    save_curpos = curwin->w_cursor;
+    if (eap->cmdidx == CMD_left)    /* width is used for new indent */
+    {
+	if (width >= 0)
+	    indent = width;
+    }
+    else
+    {
+	/*
+	 * if 'textwidth' set, use it
+	 * else if 'wrapmargin' set, use it
+	 * if invalid value, use 80
+	 */
+	if (width <= 0)
+	    width = curbuf->b_p_tw;
+	if (width == 0 && curbuf->b_p_wm > 0)
+	    width = curwin->w_width - curbuf->b_p_wm;
+	if (width <= 0)
+	    width = 80;
+    }
+
+    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)
+	return;
+
+    for (curwin->w_cursor.lnum = eap->line1;
+		 curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum)
+    {
+	if (eap->cmdidx == CMD_left)		/* left align */
+	    new_indent = indent;
+	else
+	{
+	    has_tab = FALSE;	/* avoid uninit warnings */
+	    len = linelen(eap->cmdidx == CMD_right ? &has_tab
+						   : NULL) - get_indent();
+
+	    if (len <= 0)			/* skip blank lines */
+		continue;
+
+	    if (eap->cmdidx == CMD_center)
+		new_indent = (width - len) / 2;
+	    else
+	    {
+		new_indent = width - len;	/* right align */
+
+		/*
+		 * Make sure that embedded TABs don't make the text go too far
+		 * to the right.
+		 */
+		if (has_tab)
+		    while (new_indent > 0)
+		    {
+			(void)set_indent(new_indent, 0);
+			if (linelen(NULL) <= width)
+			{
+			    /*
+			     * Now try to move the line as much as possible to
+			     * the right.  Stop when it moves too far.
+			     */
+			    do
+				(void)set_indent(++new_indent, 0);
+			    while (linelen(NULL) <= width);
+			    --new_indent;
+			    break;
+			}
+			--new_indent;
+		    }
+	    }
+	}
+	if (new_indent < 0)
+	    new_indent = 0;
+	(void)set_indent(new_indent, 0);		/* set indent */
+    }
+    changed_lines(eap->line1, 0, eap->line2 + 1, 0L);
+    curwin->w_cursor = save_curpos;
+    beginline(BL_WHITE | BL_FIX);
+}
+
+/*
+ * Get the length of the current line, excluding trailing white space.
+ */
+    static int
+linelen(int *has_tab)
+{
+    char_u  *line;
+    char_u  *first;
+    char_u  *last;
+    int	    save;
+    int	    len;
+
+    /* find the first non-blank character */
+    line = ml_get_curline();
+    first = skipwhite(line);
+
+    /* find the character after the last non-blank character */
+    for (last = first + STRLEN(first);
+				last > first && VIM_ISWHITE(last[-1]); --last)
+	;
+    save = *last;
+    *last = NUL;
+    len = linetabsize(line);		/* get line length */
+    if (has_tab != NULL)		/* check for embedded TAB */
+	*has_tab = (vim_strchr(first, TAB) != NULL);
+    *last = save;
+
+    return len;
+}
+
+/* Buffer for two lines used during sorting.  They are allocated to
+ * contain the longest line being sorted. */
+static char_u	*sortbuf1;
+static char_u	*sortbuf2;
+
+static int	sort_ic;	/* ignore case */
+static int	sort_nr;	/* sort on number */
+static int	sort_rx;	/* sort on regex instead of skipping it */
+#ifdef FEAT_FLOAT
+static int	sort_flt;	/* sort on floating number */
+#endif
+
+static int	sort_abort;	/* flag to indicate if sorting has been interrupted */
+
+/* Struct to store info to be sorted. */
+typedef struct
+{
+    linenr_T	lnum;			/* line number */
+    union {
+	struct
+	{
+	    varnumber_T	start_col_nr;		/* starting column number */
+	    varnumber_T	end_col_nr;		/* ending column number */
+	} line;
+	varnumber_T	value;		/* value if sorting by integer */
+#ifdef FEAT_FLOAT
+	float_T value_flt;	/* value if sorting by float */
+#endif
+    } st_u;
+} sorti_T;
+
+static int
+#ifdef __BORLANDC__
+_RTLENTRYF
+#endif
+sort_compare(const void *s1, const void *s2);
+
+    static int
+#ifdef __BORLANDC__
+_RTLENTRYF
+#endif
+sort_compare(const void *s1, const void *s2)
+{
+    sorti_T	l1 = *(sorti_T *)s1;
+    sorti_T	l2 = *(sorti_T *)s2;
+    int		result = 0;
+
+    /* If the user interrupts, there's no way to stop qsort() immediately, but
+     * if we return 0 every time, qsort will assume it's done sorting and
+     * exit. */
+    if (sort_abort)
+	return 0;
+    fast_breakcheck();
+    if (got_int)
+	sort_abort = TRUE;
+
+    /* When sorting numbers "start_col_nr" is the number, not the column
+     * number. */
+    if (sort_nr)
+	result = l1.st_u.value == l2.st_u.value ? 0
+				 : l1.st_u.value > l2.st_u.value ? 1 : -1;
+#ifdef FEAT_FLOAT
+    else if (sort_flt)
+	result = l1.st_u.value_flt == l2.st_u.value_flt ? 0
+			     : l1.st_u.value_flt > l2.st_u.value_flt ? 1 : -1;
+#endif
+    else
+    {
+	/* We need to copy one line into "sortbuf1", because there is no
+	 * guarantee that the first pointer becomes invalid when obtaining the
+	 * second one. */
+	STRNCPY(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,
+		     l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);
+	sortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = 0;
+	STRNCPY(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,
+		     l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);
+	sortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = 0;
+
+	result = sort_ic ? STRICMP(sortbuf1, sortbuf2)
+						 : STRCMP(sortbuf1, sortbuf2);
+    }
+
+    /* If two lines have the same value, preserve the original line order. */
+    if (result == 0)
+	return (int)(l1.lnum - l2.lnum);
+    return result;
+}
+
+/*
+ * ":sort".
+ */
+    void
+ex_sort(exarg_T *eap)
+{
+    regmatch_T	regmatch;
+    int		len;
+    linenr_T	lnum;
+    long	maxlen = 0;
+    sorti_T	*nrs;
+    size_t	count = (size_t)(eap->line2 - eap->line1 + 1);
+    size_t	i;
+    char_u	*p;
+    char_u	*s;
+    char_u	*s2;
+    char_u	c;			/* temporary character storage */
+    int		unique = FALSE;
+    long	deleted;
+    colnr_T	start_col;
+    colnr_T	end_col;
+    int		sort_what = 0;
+    int		format_found = 0;
+    int		change_occurred = FALSE; // Buffer contents changed.
+
+    /* Sorting one line is really quick! */
+    if (count <= 1)
+	return;
+
+    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)
+	return;
+    sortbuf1 = NULL;
+    sortbuf2 = NULL;
+    regmatch.regprog = NULL;
+    nrs = (sorti_T *)lalloc((long_u)(count * sizeof(sorti_T)), TRUE);
+    if (nrs == NULL)
+	goto sortend;
+
+    sort_abort = sort_ic = sort_rx = sort_nr = 0;
+#ifdef FEAT_FLOAT
+    sort_flt = 0;
+#endif
+
+    for (p = eap->arg; *p != NUL; ++p)
+    {
+	if (VIM_ISWHITE(*p))
+	    ;
+	else if (*p == 'i')
+	    sort_ic = TRUE;
+	else if (*p == 'r')
+	    sort_rx = TRUE;
+	else if (*p == 'n')
+	{
+	    sort_nr = 1;
+	    ++format_found;
+	}
+#ifdef FEAT_FLOAT
+	else if (*p == 'f')
+	{
+	    sort_flt = 1;
+	    ++format_found;
+	}
+#endif
+	else if (*p == 'b')
+	{
+	    sort_what = STR2NR_BIN + STR2NR_FORCE;
+	    ++format_found;
+	}
+	else if (*p == 'o')
+	{
+	    sort_what = STR2NR_OCT + STR2NR_FORCE;
+	    ++format_found;
+	}
+	else if (*p == 'x')
+	{
+	    sort_what = STR2NR_HEX + STR2NR_FORCE;
+	    ++format_found;
+	}
+	else if (*p == 'u')
+	    unique = TRUE;
+	else if (*p == '"')	/* comment start */
+	    break;
+	else if (check_nextcmd(p) != NULL)
+	{
+	    eap->nextcmd = check_nextcmd(p);
+	    break;
+	}
+	else if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL)
+	{
+	    s = skip_regexp(p + 1, *p, TRUE, NULL);
+	    if (*s != *p)
+	    {
+		EMSG(_(e_invalpat));
+		goto sortend;
+	    }
+	    *s = NUL;
+	    /* Use last search pattern if sort pattern is empty. */
+	    if (s == p + 1)
+	    {
+		if (last_search_pat() == NULL)
+		{
+		    EMSG(_(e_noprevre));
+		    goto sortend;
+		}
+		regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);
+	    }
+	    else
+		regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);
+	    if (regmatch.regprog == NULL)
+		goto sortend;
+	    p = s;		/* continue after the regexp */
+	    regmatch.rm_ic = p_ic;
+	}
+	else
+	{
+	    EMSG2(_(e_invarg2), p);
+	    goto sortend;
+	}
+    }
+
+    /* Can only have one of 'n', 'b', 'o' and 'x'. */
+    if (format_found > 1)
+    {
+	EMSG(_(e_invarg));
+	goto sortend;
+    }
+
+    /* From here on "sort_nr" is used as a flag for any integer number
+     * sorting. */
+    sort_nr += sort_what;
+
+    /*
+     * Make an array with all line numbers.  This avoids having to copy all
+     * the lines into allocated memory.
+     * When sorting on strings "start_col_nr" is the offset in the line, for
+     * numbers sorting it's the number to sort on.  This means the pattern
+     * matching and number conversion only has to be done once per line.
+     * Also get the longest line length for allocating "sortbuf".
+     */
+    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)
+    {
+	s = ml_get(lnum);
+	len = (int)STRLEN(s);
+	if (maxlen < len)
+	    maxlen = len;
+
+	start_col = 0;
+	end_col = len;
+	if (regmatch.regprog != NULL && vim_regexec(&regmatch, s, 0))
+	{
+	    if (sort_rx)
+	    {
+		start_col = (colnr_T)(regmatch.startp[0] - s);
+		end_col = (colnr_T)(regmatch.endp[0] - s);
+	    }
+	    else
+		start_col = (colnr_T)(regmatch.endp[0] - s);
+	}
+	else
+	    if (regmatch.regprog != NULL)
+		end_col = 0;
+
+	if (sort_nr
+#ifdef FEAT_FLOAT
+		|| sort_flt
+#endif
+		)
+	{
+	    /* Make sure vim_str2nr doesn't read any digits past the end
+	     * of the match, by temporarily terminating the string there */
+	    s2 = s + end_col;
+	    c = *s2;
+	    *s2 = NUL;
+	    /* Sorting on number: Store the number itself. */
+	    p = s + start_col;
+	    if (sort_nr)
+	    {
+		if (sort_what & STR2NR_HEX)
+		    s = skiptohex(p);
+		else if (sort_what & STR2NR_BIN)
+		    s = skiptobin(p);
+		else
+		    s = skiptodigit(p);
+		if (s > p && s[-1] == '-')
+		    --s;  /* include preceding negative sign */
+		if (*s == NUL)
+		    /* empty line should sort before any number */
+		    nrs[lnum - eap->line1].st_u.value = -MAXLNUM;
+		else
+		    vim_str2nr(s, NULL, NULL, sort_what,
+			       &nrs[lnum - eap->line1].st_u.value, NULL, 0);
+	    }
+#ifdef FEAT_FLOAT
+	    else
+	    {
+		s = skipwhite(p);
+		if (*s == '+')
+		    s = skipwhite(s + 1);
+
+		if (*s == NUL)
+		    /* empty line should sort before any number */
+		    nrs[lnum - eap->line1].st_u.value_flt = -DBL_MAX;
+		else
+		    nrs[lnum - eap->line1].st_u.value_flt =
+						      strtod((char *)s, NULL);
+	    }
+#endif
+	    *s2 = c;
+	}
+	else
+	{
+	    /* Store the column to sort at. */
+	    nrs[lnum - eap->line1].st_u.line.start_col_nr = start_col;
+	    nrs[lnum - eap->line1].st_u.line.end_col_nr = end_col;
+	}
+
+	nrs[lnum - eap->line1].lnum = lnum;
+
+	if (regmatch.regprog != NULL)
+	    fast_breakcheck();
+	if (got_int)
+	    goto sortend;
+    }
+
+    /* Allocate a buffer that can hold the longest line. */
+    sortbuf1 = alloc((unsigned)maxlen + 1);
+    if (sortbuf1 == NULL)
+	goto sortend;
+    sortbuf2 = alloc((unsigned)maxlen + 1);
+    if (sortbuf2 == NULL)
+	goto sortend;
+
+    /* Sort the array of line numbers.  Note: can't be interrupted! */
+    qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);
+
+    if (sort_abort)
+	goto sortend;
+
+    /* Insert the lines in the sorted order below the last one. */
+    lnum = eap->line2;
+    for (i = 0; i < count; ++i)
+    {
+	linenr_T get_lnum = nrs[eap->forceit ? count - i - 1 : i].lnum;
+
+	// If the original line number of the line being placed is not the same
+	// as "lnum" (accounting for offset), we know that the buffer changed.
+	if (get_lnum + ((linenr_T)count - 1) != lnum)
+	    change_occurred = TRUE;
+
+	s = ml_get(get_lnum);
+	if (!unique || i == 0
+		|| (sort_ic ? STRICMP(s, sortbuf1) : STRCMP(s, sortbuf1)) != 0)
+	{
+	    // Copy the line into a buffer, it may become invalid in
+	    // ml_append(). And it's needed for "unique".
+	    STRCPY(sortbuf1, s);
+	    if (ml_append(lnum++, sortbuf1, (colnr_T)0, FALSE) == FAIL)
+		break;
+	}
+	fast_breakcheck();
+	if (got_int)
+	    goto sortend;
+    }
+
+    /* delete the original lines if appending worked */
+    if (i == count)
+	for (i = 0; i < count; ++i)
+	    ml_delete(eap->line1, FALSE);
+    else
+	count = 0;
+
+    /* Adjust marks for deleted (or added) lines and prepare for displaying. */
+    deleted = (long)(count - (lnum - eap->line2));
+    if (deleted > 0)
+	mark_adjust(eap->line2 - deleted, eap->line2, (long)MAXLNUM, -deleted);
+    else if (deleted < 0)
+	mark_adjust(eap->line2, MAXLNUM, -deleted, 0L);
+
+    if (change_occurred || deleted != 0)
+	changed_lines(eap->line1, 0, eap->line2 + 1, -deleted);
+
+    curwin->w_cursor.lnum = eap->line1;
+    beginline(BL_WHITE | BL_FIX);
+
+sortend:
+    vim_free(nrs);
+    vim_free(sortbuf1);
+    vim_free(sortbuf2);
+    vim_regfree(regmatch.regprog);
+    if (got_int)
+	EMSG(_(e_interr));
+}
+
+/*
+ * ":retab".
+ */
+    void
+ex_retab(exarg_T *eap)
+{
+    linenr_T	lnum;
+    int		got_tab = FALSE;
+    long	num_spaces = 0;
+    long	num_tabs;
+    long	len;
+    long	col;
+    long	vcol;
+    long	start_col = 0;		/* For start of white-space string */
+    long	start_vcol = 0;		/* For start of white-space string */
+    long	old_len;
+    char_u	*ptr;
+    char_u	*new_line = (char_u *)1;    /* init to non-NULL */
+    int		did_undo;		/* called u_save for current line */
+#ifdef FEAT_VARTABS
+    int		*new_vts_array = NULL;
+    char_u	*new_ts_str;		/* string value of tab argument */
+#else
+    int		temp;
+    int		new_ts;
+#endif
+    int		save_list;
+    linenr_T	first_line = 0;		/* first changed line */
+    linenr_T	last_line = 0;		/* last changed line */
+
+    save_list = curwin->w_p_list;
+    curwin->w_p_list = 0;	    /* don't want list mode here */
+
+#ifdef FEAT_VARTABS
+    new_ts_str = eap->arg;
+    if (!tabstop_set(eap->arg, &new_vts_array))
+	return;
+    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')
+	++(eap->arg);
+
+    // This ensures that either new_vts_array and new_ts_str are freshly
+    // allocated, or new_vts_array points to an existing array and new_ts_str
+    // is null.
+    if (new_vts_array == NULL)
+    {
+	new_vts_array = curbuf->b_p_vts_array;
+	new_ts_str = NULL;
+    }
+    else
+	new_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);
+#else
+    new_ts = getdigits(&(eap->arg));
+    if (new_ts < 0)
+    {
+	EMSG(_(e_positive));
+	return;
+    }
+    if (new_ts == 0)
+	new_ts = curbuf->b_p_ts;
+#endif
+    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)
+    {
+	ptr = ml_get(lnum);
+	col = 0;
+	vcol = 0;
+	did_undo = FALSE;
+	for (;;)
+	{
+	    if (VIM_ISWHITE(ptr[col]))
+	    {
+		if (!got_tab && num_spaces == 0)
+		{
+		    /* First consecutive white-space */
+		    start_vcol = vcol;
+		    start_col = col;
+		}
+		if (ptr[col] == ' ')
+		    num_spaces++;
+		else
+		    got_tab = TRUE;
+	    }
+	    else
+	    {
+		if (got_tab || (eap->forceit && num_spaces > 1))
+		{
+		    /* Retabulate this string of white-space */
+
+		    /* len is virtual length of white string */
+		    len = num_spaces = vcol - start_vcol;
+		    num_tabs = 0;
+		    if (!curbuf->b_p_et)
+		    {
+#ifdef FEAT_VARTABS
+			int t, s;
+
+			tabstop_fromto(start_vcol, vcol,
+					curbuf->b_p_ts, new_vts_array, &t, &s);
+			num_tabs = t;
+			num_spaces = s;
+#else
+			temp = new_ts - (start_vcol % new_ts);
+			if (num_spaces >= temp)
+			{
+			    num_spaces -= temp;
+			    num_tabs++;
+			}
+			num_tabs += num_spaces / new_ts;
+			num_spaces -= (num_spaces / new_ts) * new_ts;
+#endif
+		    }
+		    if (curbuf->b_p_et || got_tab ||
+					(num_spaces + num_tabs < len))
+		    {
+			if (did_undo == FALSE)
+			{
+			    did_undo = TRUE;
+			    if (u_save((linenr_T)(lnum - 1),
+						(linenr_T)(lnum + 1)) == FAIL)
+			    {
+				new_line = NULL;	/* flag out-of-memory */
+				break;
+			    }
+			}
+
+			/* len is actual number of white characters used */
+			len = num_spaces + num_tabs;
+			old_len = (long)STRLEN(ptr);
+			new_line = lalloc(old_len - col + start_col + len + 1,
+									TRUE);
+			if (new_line == NULL)
+			    break;
+			if (start_col > 0)
+			    mch_memmove(new_line, ptr, (size_t)start_col);
+			mch_memmove(new_line + start_col + len,
+				      ptr + col, (size_t)(old_len - col + 1));
+			ptr = new_line + start_col;
+			for (col = 0; col < len; col++)
+			    ptr[col] = (col < num_tabs) ? '\t' : ' ';
+			ml_replace(lnum, new_line, FALSE);
+			if (first_line == 0)
+			    first_line = lnum;
+			last_line = lnum;
+			ptr = new_line;
+			col = start_col + len;
+		    }
+		}
+		got_tab = FALSE;
+		num_spaces = 0;
+	    }
+	    if (ptr[col] == NUL)
+		break;
+	    vcol += chartabsize(ptr + col, (colnr_T)vcol);
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		col += (*mb_ptr2len)(ptr + col);
+	    else
+#endif
+		++col;
+	}
+	if (new_line == NULL)		    /* out of memory */
+	    break;
+	line_breakcheck();
+    }
+    if (got_int)
+	EMSG(_(e_interr));
+
+#ifdef FEAT_VARTABS
+    // If a single value was given then it can be considered equal to
+    // either the value of 'tabstop' or the value of 'vartabstop'.
+    if (tabstop_count(curbuf->b_p_vts_array) == 0
+	&& tabstop_count(new_vts_array) == 1
+	&& curbuf->b_p_ts == tabstop_first(new_vts_array))
+	; /* not changed */
+    else if (tabstop_count(curbuf->b_p_vts_array) > 0
+        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))
+	; /* not changed */
+    else
+	redraw_curbuf_later(NOT_VALID);
+#else
+    if (curbuf->b_p_ts != new_ts)
+	redraw_curbuf_later(NOT_VALID);
+#endif
+    if (first_line != 0)
+	changed_lines(first_line, 0, last_line + 1, 0L);
+
+    curwin->w_p_list = save_list;	/* restore 'list' */
+
+#ifdef FEAT_VARTABS
+    if (new_ts_str != NULL)		/* set the new tabstop */
+    {
+	// If 'vartabstop' is in use or if the value given to retab has more
+	// than one tabstop then update 'vartabstop'.
+	int *old_vts_ary = curbuf->b_p_vts_array;
+
+	if (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)
+	{
+	    set_string_option_direct((char_u *)"vts", -1, new_ts_str,
+							OPT_FREE|OPT_LOCAL, 0);
+	    curbuf->b_p_vts_array = new_vts_array;
+	    vim_free(old_vts_ary);
+	}
+	else
+	{
+	    // 'vartabstop' wasn't in use and a single value was given to
+	    // retab then update 'tabstop'.
+	    curbuf->b_p_ts = tabstop_first(new_vts_array);
+	    vim_free(new_vts_array);
+	}
+	vim_free(new_ts_str);
+    }
+#else
+    curbuf->b_p_ts = new_ts;
+#endif
+    coladvance(curwin->w_curswant);
+
+    u_clearline();
+}
+
+/*
+ * :move command - move lines line1-line2 to line dest
+ *
+ * return FAIL for failure, OK otherwise
+ */
+    int
+do_move(linenr_T line1, linenr_T line2, linenr_T dest)
+{
+    char_u	*str;
+    linenr_T	l;
+    linenr_T	extra;	    /* Num lines added before line1 */
+    linenr_T	num_lines;  /* Num lines moved */
+    linenr_T	last_line;  /* Last line in file after adding new text */
+#ifdef FEAT_FOLDING
+    win_T	*win;
+    tabpage_T	*tp;
+#endif
+
+    if (dest >= line1 && dest < line2)
+    {
+	EMSG(_("E134: Move lines into themselves"));
+	return FAIL;
+    }
+
+    num_lines = line2 - line1 + 1;
+
+    /*
+     * First we copy the old text to its new location -- webb
+     * Also copy the flag that ":global" command uses.
+     */
+    if (u_save(dest, dest + 1) == FAIL)
+	return FAIL;
+    for (extra = 0, l = line1; l <= line2; l++)
+    {
+	str = vim_strsave(ml_get(l + extra));
+	if (str != NULL)
+	{
+	    ml_append(dest + l - line1, str, (colnr_T)0, FALSE);
+	    vim_free(str);
+	    if (dest < line1)
+		extra++;
+	}
+    }
+
+    /*
+     * Now we must be careful adjusting our marks so that we don't overlap our
+     * mark_adjust() calls.
+     *
+     * We adjust the marks within the old text so that they refer to the
+     * last lines of the file (temporarily), because we know no other marks
+     * will be set there since these line numbers did not exist until we added
+     * our new lines.
+     *
+     * Then we adjust the marks on lines between the old and new text positions
+     * (either forwards or backwards).
+     *
+     * And Finally we adjust the marks we put at the end of the file back to
+     * their final destination at the new text position -- webb
+     */
+    last_line = curbuf->b_ml.ml_line_count;
+    mark_adjust_nofold(line1, line2, last_line - line2, 0L);
+    if (dest >= line2)
+    {
+	mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);
+#ifdef FEAT_FOLDING
+	FOR_ALL_TAB_WINDOWS(tp, win) {
+	    if (win->w_buffer == curbuf)
+		foldMoveRange(&win->w_folds, line1, line2, dest);
+	}
+#endif
+	curbuf->b_op_start.lnum = dest - num_lines + 1;
+	curbuf->b_op_end.lnum = dest;
+    }
+    else
+    {
+	mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);
+#ifdef FEAT_FOLDING
+	FOR_ALL_TAB_WINDOWS(tp, win) {
+	    if (win->w_buffer == curbuf)
+		foldMoveRange(&win->w_folds, dest + 1, line1 - 1, line2);
+	}
+#endif
+	curbuf->b_op_start.lnum = dest + 1;
+	curbuf->b_op_end.lnum = dest + num_lines;
+    }
+    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
+    mark_adjust_nofold(last_line - num_lines + 1, last_line,
+					     -(last_line - dest - extra), 0L);
+
+    /*
+     * Now we delete the original text -- webb
+     */
+    if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)
+	return FAIL;
+
+    for (l = line1; l <= line2; l++)
+	ml_delete(line1 + extra, TRUE);
+
+    if (!global_busy && num_lines > p_report)
+	smsg((char_u *)NGETTEXT("%ld line moved", "%ld lines moved", num_lines),
+			(long)num_lines);
+
+    /*
+     * Leave the cursor on the last of the moved lines.
+     */
+    if (dest >= line1)
+	curwin->w_cursor.lnum = dest;
+    else
+	curwin->w_cursor.lnum = dest + (line2 - line1) + 1;
+
+    if (line1 < dest)
+    {
+	dest += num_lines + 1;
+	last_line = curbuf->b_ml.ml_line_count;
+	if (dest > last_line + 1)
+	    dest = last_line + 1;
+	changed_lines(line1, 0, dest, 0L);
+    }
+    else
+	changed_lines(dest + 1, 0, line1 + num_lines, 0L);
+
+    return OK;
+}
+
+/*
+ * ":copy"
+ */
+    void
+ex_copy(linenr_T line1, linenr_T line2, linenr_T n)
+{
+    linenr_T	count;
+    char_u	*p;
+
+    count = line2 - line1 + 1;
+    curbuf->b_op_start.lnum = n + 1;
+    curbuf->b_op_end.lnum = n + count;
+    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
+
+    /*
+     * there are three situations:
+     * 1. destination is above line1
+     * 2. destination is between line1 and line2
+     * 3. destination is below line2
+     *
+     * n = destination (when starting)
+     * curwin->w_cursor.lnum = destination (while copying)
+     * line1 = start of source (while copying)
+     * line2 = end of source (while copying)
+     */
+    if (u_save(n, n + 1) == FAIL)
+	return;
+
+    curwin->w_cursor.lnum = n;
+    while (line1 <= line2)
+    {
+	/* need to use vim_strsave() because the line will be unlocked within
+	 * ml_append() */
+	p = vim_strsave(ml_get(line1));
+	if (p != NULL)
+	{
+	    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);
+	    vim_free(p);
+	}
+	/* situation 2: skip already copied lines */
+	if (line1 == n)
+	    line1 = curwin->w_cursor.lnum;
+	++line1;
+	if (curwin->w_cursor.lnum < line1)
+	    ++line1;
+	if (curwin->w_cursor.lnum < line2)
+	    ++line2;
+	++curwin->w_cursor.lnum;
+    }
+
+    appended_lines_mark(n, count);
+
+    msgmore((long)count);
+}
+
+static char_u	*prevcmd = NULL;	/* the previous command */
+
+#if defined(EXITFREE) || defined(PROTO)
+    void
+free_prev_shellcmd(void)
+{
+    vim_free(prevcmd);
+}
+#endif
+
+/*
+ * Handle the ":!cmd" command.	Also for ":r !cmd" and ":w !cmd"
+ * Bangs in the argument are replaced with the previously entered command.
+ * Remember the argument.
+ */
+    void
+do_bang(
+    int		addr_count,
+    exarg_T	*eap,
+    int		forceit,
+    int		do_in,
+    int		do_out)
+{
+    char_u		*arg = eap->arg;	/* command */
+    linenr_T		line1 = eap->line1;	/* start of range */
+    linenr_T		line2 = eap->line2;	/* end of range */
+    char_u		*newcmd = NULL;		/* the new command */
+    int			free_newcmd = FALSE;    /* need to free() newcmd */
+    int			ins_prevcmd;
+    char_u		*t;
+    char_u		*p;
+    char_u		*trailarg;
+    int			len;
+    int			scroll_save = msg_scroll;
+
+    /*
+     * Disallow shell commands for "rvim".
+     * Disallow shell commands from .exrc and .vimrc in current directory for
+     * security reasons.
+     */
+    if (check_restricted() || check_secure())
+	return;
+
+    if (addr_count == 0)		/* :! */
+    {
+	msg_scroll = FALSE;	    /* don't scroll here */
+	autowrite_all();
+	msg_scroll = scroll_save;
+    }
+
+    /*
+     * Try to find an embedded bang, like in :!<cmd> ! [args]
+     * (:!! is indicated by the 'forceit' variable)
+     */
+    ins_prevcmd = forceit;
+    trailarg = arg;
+    do
+    {
+	len = (int)STRLEN(trailarg) + 1;
+	if (newcmd != NULL)
+	    len += (int)STRLEN(newcmd);
+	if (ins_prevcmd)
+	{
+	    if (prevcmd == NULL)
+	    {
+		EMSG(_(e_noprev));
+		vim_free(newcmd);
+		return;
+	    }
+	    len += (int)STRLEN(prevcmd);
+	}
+	if ((t = alloc((unsigned)len)) == NULL)
+	{
+	    vim_free(newcmd);
+	    return;
+	}
+	*t = NUL;
+	if (newcmd != NULL)
+	    STRCAT(t, newcmd);
+	if (ins_prevcmd)
+	    STRCAT(t, prevcmd);
+	p = t + STRLEN(t);
+	STRCAT(t, trailarg);
+	vim_free(newcmd);
+	newcmd = t;
+
+	/*
+	 * Scan the rest of the argument for '!', which is replaced by the
+	 * previous command.  "\!" is replaced by "!" (this is vi compatible).
+	 */
+	trailarg = NULL;
+	while (*p)
+	{
+	    if (*p == '!')
+	    {
+		if (p > newcmd && p[-1] == '\\')
+		    STRMOVE(p - 1, p);
+		else
+		{
+		    trailarg = p;
+		    *trailarg++ = NUL;
+		    ins_prevcmd = TRUE;
+		    break;
+		}
+	    }
+	    ++p;
+	}
+    } while (trailarg != NULL);
+
+    vim_free(prevcmd);
+    prevcmd = newcmd;
+
+    if (bangredo)	    /* put cmd in redo buffer for ! command */
+    {
+	/* If % or # appears in the command, it must have been escaped.
+	 * Reescape them, so that redoing them does not substitute them by the
+	 * buffername. */
+	char_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)"%#");
+
+	if (cmd != NULL)
+	{
+	    AppendToRedobuffLit(cmd, -1);
+	    vim_free(cmd);
+	}
+	else
+	    AppendToRedobuffLit(prevcmd, -1);
+	AppendToRedobuff((char_u *)"\n");
+	bangredo = FALSE;
+    }
+    /*
+     * Add quotes around the command, for shells that need them.
+     */
+    if (*p_shq != NUL)
+    {
+	newcmd = alloc((unsigned)(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1));
+	if (newcmd == NULL)
+	    return;
+	STRCPY(newcmd, p_shq);
+	STRCAT(newcmd, prevcmd);
+	STRCAT(newcmd, p_shq);
+	free_newcmd = TRUE;
+    }
+    if (addr_count == 0)		/* :! */
+    {
+	/* echo the command */
+	msg_start();
+	msg_putchar(':');
+	msg_putchar('!');
+	msg_outtrans(newcmd);
+	msg_clr_eos();
+	windgoto(msg_row, msg_col);
+
+	do_shell(newcmd, 0);
+    }
+    else				/* :range! */
+    {
+	/* Careful: This may recursively call do_bang() again! (because of
+	 * autocommands) */
+	do_filter(line1, line2, eap, newcmd, do_in, do_out);
+	apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);
+    }
+    if (free_newcmd)
+	vim_free(newcmd);
+}
+
+/*
+ * do_filter: filter lines through a command given by the user
+ *
+ * We mostly use temp files and the call_shell() routine here. This would
+ * normally be done using pipes on a UNIX machine, but this is more portable
+ * to non-unix machines. The call_shell() routine needs to be able
+ * to deal with redirection somehow, and should handle things like looking
+ * at the PATH env. variable, and adding reasonable extensions to the
+ * command name given by the user. All reasonable versions of call_shell()
+ * do this.
+ * Alternatively, if on Unix and redirecting input or output, but not both,
+ * and the 'shelltemp' option isn't set, use pipes.
+ * We use input redirection if do_in is TRUE.
+ * We use output redirection if do_out is TRUE.
+ */
+    static void
+do_filter(
+    linenr_T	line1,
+    linenr_T	line2,
+    exarg_T	*eap,		/* for forced 'ff' and 'fenc' */
+    char_u	*cmd,
+    int		do_in,
+    int		do_out)
+{
+    char_u	*itmp = NULL;
+    char_u	*otmp = NULL;
+    linenr_T	linecount;
+    linenr_T	read_linecount;
+    pos_T	cursor_save;
+    char_u	*cmd_buf;
+    buf_T	*old_curbuf = curbuf;
+    int		shell_flags = 0;
+
+    if (*cmd == NUL)	    /* no filter command */
+	return;
+
+    cursor_save = curwin->w_cursor;
+    linecount = line2 - line1 + 1;
+    curwin->w_cursor.lnum = line1;
+    curwin->w_cursor.col = 0;
+    changed_line_abv_curs();
+    invalidate_botline();
+
+    /*
+     * When using temp files:
+     * 1. * Form temp file names
+     * 2. * Write the lines to a temp file
+     * 3.   Run the filter command on the temp file
+     * 4. * Read the output of the command into the buffer
+     * 5. * Delete the original lines to be filtered
+     * 6. * Remove the temp files
+     *
+     * When writing the input with a pipe or when catching the output with a
+     * pipe only need to do 3.
+     */
+
+    if (do_out)
+	shell_flags |= SHELL_DOOUT;
+
+#ifdef FEAT_FILTERPIPE
+    if (!do_in && do_out && !p_stmp)
+    {
+	/* Use a pipe to fetch stdout of the command, do not use a temp file. */
+	shell_flags |= SHELL_READ;
+	curwin->w_cursor.lnum = line2;
+    }
+    else if (do_in && !do_out && !p_stmp)
+    {
+	/* Use a pipe to write stdin of the command, do not use a temp file. */
+	shell_flags |= SHELL_WRITE;
+	curbuf->b_op_start.lnum = line1;
+	curbuf->b_op_end.lnum = line2;
+    }
+    else if (do_in && do_out && !p_stmp)
+    {
+	/* Use a pipe to write stdin and fetch stdout of the command, do not
+	 * use a temp file. */
+	shell_flags |= SHELL_READ|SHELL_WRITE;
+	curbuf->b_op_start.lnum = line1;
+	curbuf->b_op_end.lnum = line2;
+	curwin->w_cursor.lnum = line2;
+    }
+    else
+#endif
+	if ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)
+		|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))
+	{
+	    EMSG(_(e_notmp));
+	    goto filterend;
+	}
+
+/*
+ * The writing and reading of temp files will not be shown.
+ * Vi also doesn't do this and the messages are not very informative.
+ */
+    ++no_wait_return;		/* don't call wait_return() while busy */
+    if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,
+					   FALSE, FALSE, FALSE, TRUE) == FAIL)
+    {
+	msg_putchar('\n');		/* keep message from buf_write() */
+	--no_wait_return;
+#if defined(FEAT_EVAL)
+	if (!aborting())
+#endif
+	    (void)EMSG2(_(e_notcreate), itmp);	/* will call wait_return */
+	goto filterend;
+    }
+    if (curbuf != old_curbuf)
+	goto filterend;
+
+    if (!do_out)
+	msg_putchar('\n');
+
+    /* Create the shell command in allocated memory. */
+    cmd_buf = make_filter_cmd(cmd, itmp, otmp);
+    if (cmd_buf == NULL)
+	goto filterend;
+
+    windgoto((int)Rows - 1, 0);
+    cursor_on();
+
+    /*
+     * When not redirecting the output the command can write anything to the
+     * screen. If 'shellredir' is equal to ">", screen may be messed up by
+     * stderr output of external command. Clear the screen later.
+     * If do_in is FALSE, this could be something like ":r !cat", which may
+     * also mess up the screen, clear it later.
+     */
+    if (!do_out || STRCMP(p_srr, ">") == 0 || !do_in)
+	redraw_later_clear();
+
+    if (do_out)
+    {
+	if (u_save((linenr_T)(line2), (linenr_T)(line2 + 1)) == FAIL)
+	{
+	    vim_free(cmd_buf);
+	    goto error;
+	}
+	redraw_curbuf_later(VALID);
+    }
+    read_linecount = curbuf->b_ml.ml_line_count;
+
+    /*
+     * When call_shell() fails wait_return() is called to give the user a
+     * chance to read the error messages. Otherwise errors are ignored, so you
+     * can see the error messages from the command that appear on stdout; use
+     * 'u' to fix the text
+     * Switch to cooked mode when not redirecting stdin, avoids that something
+     * like ":r !cat" hangs.
+     * Pass on the SHELL_DOOUT flag when the output is being redirected.
+     */
+    if (call_shell(cmd_buf, SHELL_FILTER | SHELL_COOKED | shell_flags))
+    {
+	redraw_later_clear();
+	wait_return(FALSE);
+    }
+    vim_free(cmd_buf);
+
+    did_check_timestamps = FALSE;
+    need_check_timestamps = TRUE;
+
+    /* When interrupting the shell command, it may still have produced some
+     * useful output.  Reset got_int here, so that readfile() won't cancel
+     * reading. */
+    ui_breakcheck();
+    got_int = FALSE;
+
+    if (do_out)
+    {
+	if (otmp != NULL)
+	{
+	    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,
+						    eap, READ_FILTER) != OK)
+	    {
+#if defined(FEAT_EVAL)
+		if (!aborting())
+#endif
+		{
+		    msg_putchar('\n');
+		    EMSG2(_(e_notread), otmp);
+		}
+		goto error;
+	    }
+	    if (curbuf != old_curbuf)
+		goto filterend;
+	}
+
+	read_linecount = curbuf->b_ml.ml_line_count - read_linecount;
+
+	if (shell_flags & SHELL_READ)
+	{
+	    curbuf->b_op_start.lnum = line2 + 1;
+	    curbuf->b_op_end.lnum = curwin->w_cursor.lnum;
+	    appended_lines_mark(line2, read_linecount);
+	}
+
+	if (do_in)
+	{
+	    if (cmdmod.keepmarks || vim_strchr(p_cpo, CPO_REMMARK) == NULL)
+	    {
+		if (read_linecount >= linecount)
+		    /* move all marks from old lines to new lines */
+		    mark_adjust(line1, line2, linecount, 0L);
+		else
+		{
+		    /* move marks from old lines to new lines, delete marks
+		     * that are in deleted lines */
+		    mark_adjust(line1, line1 + read_linecount - 1,
+								linecount, 0L);
+		    mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L);
+		}
+	    }
+
+	    /*
+	     * Put cursor on first filtered line for ":range!cmd".
+	     * Adjust '[ and '] (set by buf_write()).
+	     */
+	    curwin->w_cursor.lnum = line1;
+	    del_lines(linecount, TRUE);
+	    curbuf->b_op_start.lnum -= linecount;	/* adjust '[ */
+	    curbuf->b_op_end.lnum -= linecount;		/* adjust '] */
+	    write_lnum_adjust(-linecount);		/* adjust last line
+							   for next write */
+#ifdef FEAT_FOLDING
+	    foldUpdate(curwin, curbuf->b_op_start.lnum, curbuf->b_op_end.lnum);
+#endif
+	}
+	else
+	{
+	    /*
+	     * Put cursor on last new line for ":r !cmd".
+	     */
+	    linecount = curbuf->b_op_end.lnum - curbuf->b_op_start.lnum + 1;
+	    curwin->w_cursor.lnum = curbuf->b_op_end.lnum;
+	}
+
+	beginline(BL_WHITE | BL_FIX);	    /* cursor on first non-blank */
+	--no_wait_return;
+
+	if (linecount > p_report)
+	{
+	    if (do_in)
+	    {
+		vim_snprintf((char *)msg_buf, sizeof(msg_buf),
+				    _("%ld lines filtered"), (long)linecount);
+		if (msg(msg_buf) && !msg_scroll)
+		    /* save message to display it after redraw */
+		    set_keep_msg(msg_buf, 0);
+	    }
+	    else
+		msgmore((long)linecount);
+	}
+    }
+    else
+    {
+error:
+	/* put cursor back in same position for ":w !cmd" */
+	curwin->w_cursor = cursor_save;
+	--no_wait_return;
+	wait_return(FALSE);
+    }
+
+filterend:
+
+    if (curbuf != old_curbuf)
+    {
+	--no_wait_return;
+	EMSG(_("E135: *Filter* Autocommands must not change current buffer"));
+    }
+    if (itmp != NULL)
+	mch_remove(itmp);
+    if (otmp != NULL)
+	mch_remove(otmp);
+    vim_free(itmp);
+    vim_free(otmp);
+}
+
+/*
+ * Call a shell to execute a command.
+ * When "cmd" is NULL start an interactive shell.
+ */
+    void
+do_shell(
+    char_u	*cmd,
+    int		flags)	/* may be SHELL_DOOUT when output is redirected */
+{
+    buf_T	*buf;
+#ifndef FEAT_GUI_MSWIN
+    int		save_nwr;
+#endif
+#ifdef MSWIN
+    int		winstart = FALSE;
+#endif
+
+    /*
+     * Disallow shell commands for "rvim".
+     * Disallow shell commands from .exrc and .vimrc in current directory for
+     * security reasons.
+     */
+    if (check_restricted() || check_secure())
+    {
+	msg_end();
+	return;
+    }
+
+#ifdef MSWIN
+    /*
+     * Check if ":!start" is used.
+     */
+    if (cmd != NULL)
+	winstart = (STRNICMP(cmd, "start ", 6) == 0);
+#endif
+
+    /*
+     * For autocommands we want to get the output on the current screen, to
+     * avoid having to type return below.
+     */
+    msg_putchar('\r');			/* put cursor at start of line */
+    if (!autocmd_busy)
+    {
+#ifdef MSWIN
+	if (!winstart)
+#endif
+	    stoptermcap();
+    }
+#ifdef MSWIN
+    if (!winstart)
+#endif
+	msg_putchar('\n');		/* may shift screen one line up */
+
+    /* warning message before calling the shell */
+    if (p_warn && !autocmd_busy && msg_silent == 0)
+	FOR_ALL_BUFFERS(buf)
+	    if (bufIsChangedNotTerm(buf))
+	    {
+#ifdef FEAT_GUI_MSWIN
+		if (!winstart)
+		    starttermcap();	/* don't want a message box here */
+#endif
+		MSG_PUTS(_("[No write since last change]\n"));
+#ifdef FEAT_GUI_MSWIN
+		if (!winstart)
+		    stoptermcap();
+#endif
+		break;
+	    }
+
+    /* This windgoto is required for when the '\n' resulted in a "delete line
+     * 1" command to the terminal. */
+    if (!swapping_screen())
+	windgoto(msg_row, msg_col);
+    cursor_on();
+    (void)call_shell(cmd, SHELL_COOKED | flags);
+    did_check_timestamps = FALSE;
+    need_check_timestamps = TRUE;
+
+    /*
+     * put the message cursor at the end of the screen, avoids wait_return()
+     * to overwrite the text that the external command showed
+     */
+    if (!swapping_screen())
+    {
+	msg_row = Rows - 1;
+	msg_col = 0;
+    }
+
+    if (autocmd_busy)
+    {
+	if (msg_silent == 0)
+	    redraw_later_clear();
+    }
+    else
+    {
+	/*
+	 * For ":sh" there is no need to call wait_return(), just redraw.
+	 * Also for the Win32 GUI (the output is in a console window).
+	 * Otherwise there is probably text on the screen that the user wants
+	 * to read before redrawing, so call wait_return().
+	 */
+#ifndef FEAT_GUI_MSWIN
+	if (cmd == NULL
+# ifdef WIN3264
+		|| (winstart && !need_wait_return)
+# endif
+	   )
+	{
+	    if (msg_silent == 0)
+		redraw_later_clear();
+	    need_wait_return = FALSE;
+	}
+	else
+	{
+	    /*
+	     * If we switch screens when starttermcap() is called, we really
+	     * want to wait for "hit return to continue".
+	     */
+	    save_nwr = no_wait_return;
+	    if (swapping_screen())
+		no_wait_return = FALSE;
+# ifdef AMIGA
+	    wait_return(term_console ? -1 : msg_silent == 0);	/* see below */
+# else
+	    wait_return(msg_silent == 0);
+# endif
+	    no_wait_return = save_nwr;
+	}
+#endif /* FEAT_GUI_W32 */
+
+#ifdef MSWIN
+	if (!winstart) /* if winstart==TRUE, never stopped termcap! */
+#endif
+	    starttermcap();	/* start termcap if not done by wait_return() */
+
+	/*
+	 * In an Amiga window redrawing is caused by asking the window size.
+	 * If we got an interrupt this will not work. The chance that the
+	 * window size is wrong is very small, but we need to redraw the
+	 * screen.  Don't do this if ':' hit in wait_return().	THIS IS UGLY
+	 * but it saves an extra redraw.
+	 */
+#ifdef AMIGA
+	if (skip_redraw)		/* ':' hit in wait_return() */
+	{
+	    if (msg_silent == 0)
+		redraw_later_clear();
+	}
+	else if (term_console)
+	{
+	    OUT_STR(IF_EB("\033[0 q", ESC_STR "[0 q"));	/* get window size */
+	    if (got_int && msg_silent == 0)
+		redraw_later_clear();	/* if got_int is TRUE, redraw needed */
+	    else
+		must_redraw = 0;	/* no extra redraw needed */
+	}
+#endif
+    }
+
+    /* display any error messages now */
+    display_errors();
+
+    apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);
+}
+
+/*
+ * Create a shell command from a command string, input redirection file and
+ * output redirection file.
+ * Returns an allocated string with the shell command, or NULL for failure.
+ */
+    char_u *
+make_filter_cmd(
+    char_u	*cmd,		/* command */
+    char_u	*itmp,		/* NULL or name of input file */
+    char_u	*otmp)		/* NULL or name of output file */
+{
+    char_u	*buf;
+    long_u	len;
+
+#if defined(UNIX)
+    int		is_fish_shell;
+    char_u	*shell_name = get_isolated_shell_name();
+
+    /* Account for fish's different syntax for subshells */
+    is_fish_shell = (fnamecmp(shell_name, "fish") == 0);
+    vim_free(shell_name);
+    if (is_fish_shell)
+	len = (long_u)STRLEN(cmd) + 13;		/* "begin; " + "; end" + NUL */
+    else
+#endif
+	len = (long_u)STRLEN(cmd) + 3;			/* "()" + NUL */
+    if (itmp != NULL)
+	len += (long_u)STRLEN(itmp) + 9;		/* " { < " + " } " */
+    if (otmp != NULL)
+	len += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; /* "  " */
+    buf = lalloc(len, TRUE);
+    if (buf == NULL)
+	return NULL;
+
+#if defined(UNIX)
+    /*
+     * Put braces around the command (for concatenated commands) when
+     * redirecting input and/or output.
+     */
+    if (itmp != NULL || otmp != NULL)
+    {
+	if (is_fish_shell)
+	    vim_snprintf((char *)buf, len, "begin; %s; end", (char *)cmd);
+	else
+	    vim_snprintf((char *)buf, len, "(%s)", (char *)cmd);
+    }
+    else
+	STRCPY(buf, cmd);
+    if (itmp != NULL)
+    {
+	STRCAT(buf, " < ");
+	STRCAT(buf, itmp);
+    }
+#else
+    /*
+     * For shells that don't understand braces around commands, at least allow
+     * the use of commands in a pipe.
+     */
+    STRCPY(buf, cmd);
+    if (itmp != NULL)
+    {
+	char_u	*p;
+
+	/*
+	 * If there is a pipe, we have to put the '<' in front of it.
+	 * Don't do this when 'shellquote' is not empty, otherwise the
+	 * redirection would be inside the quotes.
+	 */
+	if (*p_shq == NUL)
+	{
+	    p = vim_strchr(buf, '|');
+	    if (p != NULL)
+		*p = NUL;
+	}
+	STRCAT(buf, " <");	/* " < " causes problems on Amiga */
+	STRCAT(buf, itmp);
+	if (*p_shq == NUL)
+	{
+	    p = vim_strchr(cmd, '|');
+	    if (p != NULL)
+	    {
+		STRCAT(buf, " ");   /* insert a space before the '|' for DOS */
+		STRCAT(buf, p);
+	    }
+	}
+    }
+#endif
+    if (otmp != NULL)
+	append_redir(buf, (int)len, p_srr, otmp);
+
+    return buf;
+}
+
+/*
+ * Append output redirection for file "fname" to the end of string buffer
+ * "buf[buflen]"
+ * Works with the 'shellredir' and 'shellpipe' options.
+ * The caller should make sure that there is enough room:
+ *	STRLEN(opt) + STRLEN(fname) + 3
+ */
+    void
+append_redir(
+    char_u	*buf,
+    int		buflen,
+    char_u	*opt,
+    char_u	*fname)
+{
+    char_u	*p;
+    char_u	*end;
+
+    end = buf + STRLEN(buf);
+    /* find "%s" */
+    for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)
+    {
+	if (p[1] == 's') /* found %s */
+	    break;
+	if (p[1] == '%') /* skip %% */
+	    ++p;
+    }
+    if (p != NULL)
+    {
+	*end = ' '; /* not really needed? Not with sh, ksh or bash */
+	vim_snprintf((char *)end + 1, (size_t)(buflen - (end + 1 - buf)),
+						  (char *)opt, (char *)fname);
+    }
+    else
+	vim_snprintf((char *)end, (size_t)(buflen - (end - buf)),
+#ifdef FEAT_QUICKFIX
+		" %s %s",
+#else
+		" %s%s",	/* " > %s" causes problems on Amiga */
+#endif
+		(char *)opt, (char *)fname);
+}
+
+#if defined(FEAT_VIMINFO) || defined(PROTO)
+
+static int no_viminfo(void);
+static int read_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing);
+static void write_viminfo_version(FILE *fp_out);
+static void write_viminfo_barlines(vir_T *virp, FILE *fp_out);
+static int  viminfo_errcnt;
+
+    static int
+no_viminfo(void)
+{
+    /* "vim -i NONE" does not read or write a viminfo file */
+    return STRCMP(p_viminfofile, "NONE") == 0;
+}
+
+/*
+ * Report an error for reading a viminfo file.
+ * Count the number of errors.	When there are more than 10, return TRUE.
+ */
+    int
+viminfo_error(char *errnum, char *message, char_u *line)
+{
+    vim_snprintf((char *)IObuff, IOSIZE, _("%sviminfo: %s in line: "),
+							     errnum, message);
+    STRNCAT(IObuff, line, IOSIZE - STRLEN(IObuff) - 1);
+    if (IObuff[STRLEN(IObuff) - 1] == '\n')
+	IObuff[STRLEN(IObuff) - 1] = NUL;
+    emsg(IObuff);
+    if (++viminfo_errcnt >= 10)
+    {
+	EMSG(_("E136: viminfo: Too many errors, skipping rest of file"));
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * read_viminfo() -- Read the viminfo file.  Registers etc. which are already
+ * set are not over-written unless "flags" includes VIF_FORCEIT. -- webb
+ */
+    int
+read_viminfo(
+    char_u	*file,	    /* file name or NULL to use default name */
+    int		flags)	    /* VIF_WANT_INFO et al. */
+{
+    FILE	*fp;
+    char_u	*fname;
+
+    if (no_viminfo())
+	return FAIL;
+
+    fname = viminfo_filename(file);	/* get file name in allocated buffer */
+    if (fname == NULL)
+	return FAIL;
+    fp = mch_fopen((char *)fname, READBIN);
+
+    if (p_verbose > 0)
+    {
+	verbose_enter();
+	smsg((char_u *)_("Reading viminfo file \"%s\"%s%s%s"),
+		fname,
+		(flags & VIF_WANT_INFO) ? _(" info") : "",
+		(flags & VIF_WANT_MARKS) ? _(" marks") : "",
+		(flags & VIF_GET_OLDFILES) ? _(" oldfiles") : "",
+		fp == NULL ? _(" FAILED") : "");
+	verbose_leave();
+    }
+
+    vim_free(fname);
+    if (fp == NULL)
+	return FAIL;
+
+    viminfo_errcnt = 0;
+    do_viminfo(fp, NULL, flags);
+
+    fclose(fp);
+    return OK;
+}
+
+/*
+ * Write the viminfo file.  The old one is read in first so that effectively a
+ * merge of current info and old info is done.  This allows multiple vims to
+ * run simultaneously, without losing any marks etc.
+ * If "forceit" is TRUE, then the old file is not read in, and only internal
+ * info is written to the file.
+ */
+    void
+write_viminfo(char_u *file, int forceit)
+{
+    char_u	*fname;
+    FILE	*fp_in = NULL;	/* input viminfo file, if any */
+    FILE	*fp_out = NULL;	/* output viminfo file */
+    char_u	*tempname = NULL;	/* name of temp viminfo file */
+    stat_T	st_new;		/* mch_stat() of potential new file */
+#if defined(UNIX) || defined(VMS)
+    mode_t	umask_save;
+#endif
+#ifdef UNIX
+    int		shortname = FALSE;	/* use 8.3 file name */
+    stat_T	st_old;		/* mch_stat() of existing viminfo file */
+#endif
+#ifdef WIN3264
+    int		hidden = FALSE;
+#endif
+
+    if (no_viminfo())
+	return;
+
+    fname = viminfo_filename(file);	/* may set to default if NULL */
+    if (fname == NULL)
+	return;
+
+    fp_in = mch_fopen((char *)fname, READBIN);
+    if (fp_in == NULL)
+    {
+	int fd;
+
+	/* if it does exist, but we can't read it, don't try writing */
+	if (mch_stat((char *)fname, &st_new) == 0)
+	    goto end;
+
+	/* Create the new .viminfo non-accessible for others, because it may
+	 * contain text from non-accessible documents. It is up to the user to
+	 * widen access (e.g. to a group). This may also fail if there is a
+	 * race condition, then just give up. */
+	fd = mch_open((char *)fname,
+			    O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW, 0600);
+	if (fd < 0)
+	    goto end;
+	fp_out = fdopen(fd, WRITEBIN);
+    }
+    else
+    {
+	/*
+	 * There is an existing viminfo file.  Create a temporary file to
+	 * write the new viminfo into, in the same directory as the
+	 * existing viminfo file, which will be renamed once all writing is
+	 * successful.
+	 */
+#ifdef UNIX
+	/*
+	 * For Unix we check the owner of the file.  It's not very nice to
+	 * overwrite a user's viminfo file after a "su root", with a
+	 * viminfo file that the user can't read.
+	 */
+	st_old.st_dev = (dev_t)0;
+	st_old.st_ino = 0;
+	st_old.st_mode = 0600;
+	if (mch_stat((char *)fname, &st_old) == 0
+		&& getuid() != ROOT_UID
+		&& !(st_old.st_uid == getuid()
+			? (st_old.st_mode & 0200)
+			: (st_old.st_gid == getgid()
+				? (st_old.st_mode & 0020)
+				: (st_old.st_mode & 0002))))
+	{
+	    int	tt = msg_didany;
+
+	    /* avoid a wait_return for this message, it's annoying */
+	    EMSG2(_("E137: Viminfo file is not writable: %s"), fname);
+	    msg_didany = tt;
+	    fclose(fp_in);
+	    goto end;
+	}
+#endif
+#ifdef WIN3264
+	/* Get the file attributes of the existing viminfo file. */
+	hidden = mch_ishidden(fname);
+#endif
+
+	/*
+	 * Make tempname, find one that does not exist yet.
+	 * Beware of a race condition: If someone logs out and all Vim
+	 * instances exit at the same time a temp file might be created between
+	 * stat() and open().  Use mch_open() with O_EXCL to avoid that.
+	 * May try twice: Once normal and once with shortname set, just in
+	 * case somebody puts his viminfo file in an 8.3 filesystem.
+	 */
+	for (;;)
+	{
+	    int		next_char = 'z';
+	    char_u	*wp;
+
+	    tempname = buf_modname(
+#ifdef UNIX
+				    shortname,
+#else
+				    FALSE,
+#endif
+				    fname,
+#ifdef VMS
+				    (char_u *)"-tmp",
+#else
+				    (char_u *)".tmp",
+#endif
+				    FALSE);
+	    if (tempname == NULL)		/* out of memory */
+		break;
+
+	    /*
+	     * Try a series of names.  Change one character, just before
+	     * the extension.  This should also work for an 8.3
+	     * file name, when after adding the extension it still is
+	     * the same file as the original.
+	     */
+	    wp = tempname + STRLEN(tempname) - 5;
+	    if (wp < gettail(tempname))	    /* empty file name? */
+		wp = gettail(tempname);
+	    for (;;)
+	    {
+		/*
+		 * Check if tempfile already exists.  Never overwrite an
+		 * existing file!
+		 */
+		if (mch_stat((char *)tempname, &st_new) == 0)
+		{
+#ifdef UNIX
+		    /*
+		     * Check if tempfile is same as original file.  May happen
+		     * when modname() gave the same file back.  E.g.  silly
+		     * link, or file name-length reached.  Try again with
+		     * shortname set.
+		     */
+		    if (!shortname && st_new.st_dev == st_old.st_dev
+						&& st_new.st_ino == st_old.st_ino)
+		    {
+			VIM_CLEAR(tempname);
+			shortname = TRUE;
+			break;
+		    }
+#endif
+		}
+		else
+		{
+		    /* Try creating the file exclusively.  This may fail if
+		     * another Vim tries to do it at the same time. */
+#ifdef VMS
+		    /* fdopen() fails for some reason */
+		    umask_save = umask(077);
+		    fp_out = mch_fopen((char *)tempname, WRITEBIN);
+		    (void)umask(umask_save);
+#else
+		    int	fd;
+
+		    /* Use mch_open() to be able to use O_NOFOLLOW and set file
+		     * protection:
+		     * Unix: same as original file, but strip s-bit.  Reset
+		     * umask to avoid it getting in the way.
+		     * Others: r&w for user only. */
+# ifdef UNIX
+		    umask_save = umask(0);
+		    fd = mch_open((char *)tempname,
+			    O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW,
+					(int)((st_old.st_mode & 0777) | 0600));
+		    (void)umask(umask_save);
+# else
+		    fd = mch_open((char *)tempname,
+			     O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW, 0600);
+# endif
+		    if (fd < 0)
+		    {
+			fp_out = NULL;
+# ifdef EEXIST
+			/* Avoid trying lots of names while the problem is lack
+			 * of premission, only retry if the file already
+			 * exists. */
+			if (errno != EEXIST)
+			    break;
+# endif
+		    }
+		    else
+			fp_out = fdopen(fd, WRITEBIN);
+#endif /* VMS */
+		    if (fp_out != NULL)
+			break;
+		}
+
+		/* Assume file exists, try again with another name. */
+		if (next_char == 'a' - 1)
+		{
+		    /* They all exist?  Must be something wrong! Don't write
+		     * the viminfo file then. */
+		    EMSG2(_("E929: Too many viminfo temp files, like %s!"),
+								     tempname);
+		    break;
+		}
+		*wp = next_char;
+		--next_char;
+	    }
+
+	    if (tempname != NULL)
+		break;
+	    /* continue if shortname was set */
+	}
+
+#if defined(UNIX) && defined(HAVE_FCHOWN)
+	if (tempname != NULL && fp_out != NULL)
+	{
+		stat_T	tmp_st;
+
+	    /*
+	     * Make sure the original owner can read/write the tempfile and
+	     * otherwise preserve permissions, making sure the group matches.
+	     */
+	    if (mch_stat((char *)tempname, &tmp_st) >= 0)
+	    {
+		if (st_old.st_uid != tmp_st.st_uid)
+		    /* Changing the owner might fail, in which case the
+		     * file will now owned by the current user, oh well. */
+		    ignored = fchown(fileno(fp_out), st_old.st_uid, -1);
+		if (st_old.st_gid != tmp_st.st_gid
+			&& fchown(fileno(fp_out), -1, st_old.st_gid) == -1)
+		    /* can't set the group to what it should be, remove
+		     * group permissions */
+		    (void)mch_setperm(tempname, 0600);
+	    }
+	    else
+		/* can't stat the file, set conservative permissions */
+		(void)mch_setperm(tempname, 0600);
+	}
+#endif
+    }
+
+    /*
+     * Check if the new viminfo file can be written to.
+     */
+    if (fp_out == NULL)
+    {
+	EMSG2(_("E138: Can't write viminfo file %s!"),
+		       (fp_in == NULL || tempname == NULL) ? fname : tempname);
+	if (fp_in != NULL)
+	    fclose(fp_in);
+	goto end;
+    }
+
+    if (p_verbose > 0)
+    {
+	verbose_enter();
+	smsg((char_u *)_("Writing viminfo file \"%s\""), fname);
+	verbose_leave();
+    }
+
+    viminfo_errcnt = 0;
+    do_viminfo(fp_in, fp_out, forceit ? 0 : (VIF_WANT_INFO | VIF_WANT_MARKS));
+
+    if (fclose(fp_out) == EOF)
+	++viminfo_errcnt;
+
+    if (fp_in != NULL)
+    {
+	fclose(fp_in);
+
+	/* In case of an error keep the original viminfo file.  Otherwise
+	 * rename the newly written file.  Give an error if that fails. */
+	if (viminfo_errcnt == 0)
+	{
+	    if (vim_rename(tempname, fname) == -1)
+	    {
+		++viminfo_errcnt;
+		EMSG2(_("E886: Can't rename viminfo file to %s!"), fname);
+	    }
+# ifdef WIN3264
+	    /* If the viminfo file was hidden then also hide the new file. */
+	    else if (hidden)
+		mch_hide(fname);
+# endif
+	}
+	if (viminfo_errcnt > 0)
+	    mch_remove(tempname);
+    }
+
+end:
+    vim_free(fname);
+    vim_free(tempname);
+}
+
+/*
+ * Get the viminfo file name to use.
+ * If "file" is given and not empty, use it (has already been expanded by
+ * cmdline functions).
+ * Otherwise use "-i file_name", value from 'viminfo' or the default, and
+ * expand environment variables.
+ * Returns an allocated string.  NULL when out of memory.
+ */
+    static char_u *
+viminfo_filename(char_u *file)
+{
+    if (file == NULL || *file == NUL)
+    {
+	if (*p_viminfofile != NUL)
+	    file = p_viminfofile;
+	else if ((file = find_viminfo_parameter('n')) == NULL || *file == NUL)
+	{
+#ifdef VIMINFO_FILE2
+# ifdef VMS
+	    if (mch_getenv((char_u *)"SYS$LOGIN") == NULL)
+# else
+#  ifdef MSWIN
+	    /* Use $VIM only if $HOME is the default "C:/". */
+	    if (STRCMP(vim_getenv((char_u *)"HOME", NULL), "C:/") == 0
+		    && mch_getenv((char_u *)"HOME") == NULL)
+#  else
+	    if (mch_getenv((char_u *)"HOME") == NULL)
+#  endif
+# endif
+	    {
+		/* don't use $VIM when not available. */
+		expand_env((char_u *)"$VIM", NameBuff, MAXPATHL);
+		if (STRCMP("$VIM", NameBuff) != 0)  /* $VIM was expanded */
+		    file = (char_u *)VIMINFO_FILE2;
+		else
+		    file = (char_u *)VIMINFO_FILE;
+	    }
+	    else
+#endif
+		file = (char_u *)VIMINFO_FILE;
+	}
+	expand_env(file, NameBuff, MAXPATHL);
+	file = NameBuff;
+    }
+    return vim_strsave(file);
+}
+
+/*
+ * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
+ */
+    static void
+do_viminfo(FILE *fp_in, FILE *fp_out, int flags)
+{
+    int		eof = FALSE;
+    vir_T	vir;
+    int		merge = FALSE;
+    int		do_copy_marks = FALSE;
+    garray_T	buflist;
+
+    if ((vir.vir_line = alloc(LSIZE)) == NULL)
+	return;
+    vir.vir_fd = fp_in;
+#ifdef FEAT_MBYTE
+    vir.vir_conv.vc_type = CONV_NONE;
+#endif
+    ga_init2(&vir.vir_barlines, (int)sizeof(char_u *), 100);
+    vir.vir_version = -1;
+
+    if (fp_in != NULL)
+    {
+	if (flags & VIF_WANT_INFO)
+	{
+	    if (fp_out != NULL)
+	    {
+		/* Registers and marks are read and kept separate from what
+		 * this Vim is using.  They are merged when writing. */
+		prepare_viminfo_registers();
+		prepare_viminfo_marks();
+	    }
+
+	    eof = read_viminfo_up_to_marks(&vir,
+					 flags & VIF_FORCEIT, fp_out != NULL);
+	    merge = TRUE;
+	}
+	else if (flags != 0)
+	    /* Skip info, find start of marks */
+	    while (!(eof = viminfo_readline(&vir))
+		    && vir.vir_line[0] != '>')
+		;
+
+	do_copy_marks = (flags &
+			   (VIF_WANT_MARKS | VIF_GET_OLDFILES | VIF_FORCEIT));
+    }
+
+    if (fp_out != NULL)
+    {
+	/* Write the info: */
+	fprintf(fp_out, _("# This viminfo file was generated by Vim %s.\n"),
+							  VIM_VERSION_MEDIUM);
+	fputs(_("# You may edit it if you're careful!\n\n"), fp_out);
+	write_viminfo_version(fp_out);
+#ifdef FEAT_MBYTE
+	fputs(_("# Value of 'encoding' when this file was written\n"), fp_out);
+	fprintf(fp_out, "*encoding=%s\n\n", p_enc);
+#endif
+	write_viminfo_search_pattern(fp_out);
+	write_viminfo_sub_string(fp_out);
+#ifdef FEAT_CMDHIST
+	write_viminfo_history(fp_out, merge);
+#endif
+	write_viminfo_registers(fp_out);
+	finish_viminfo_registers();
+#ifdef FEAT_EVAL
+	write_viminfo_varlist(fp_out);
+#endif
+	write_viminfo_filemarks(fp_out);
+	finish_viminfo_marks();
+	write_viminfo_bufferlist(fp_out);
+	write_viminfo_barlines(&vir, fp_out);
+
+	if (do_copy_marks)
+	    ga_init2(&buflist, sizeof(buf_T *), 50);
+	write_viminfo_marks(fp_out, do_copy_marks ? &buflist : NULL);
+    }
+
+    if (do_copy_marks)
+    {
+	copy_viminfo_marks(&vir, fp_out, &buflist, eof, flags);
+	if (fp_out != NULL)
+	    ga_clear(&buflist);
+    }
+
+    vim_free(vir.vir_line);
+#ifdef FEAT_MBYTE
+    if (vir.vir_conv.vc_type != CONV_NONE)
+	convert_setup(&vir.vir_conv, NULL, NULL);
+#endif
+    ga_clear_strings(&vir.vir_barlines);
+}
+
+/*
+ * read_viminfo_up_to_marks() -- Only called from do_viminfo().  Reads in the
+ * first part of the viminfo file which contains everything but the marks that
+ * are local to a file.  Returns TRUE when end-of-file is reached. -- webb
+ */
+    static int
+read_viminfo_up_to_marks(
+    vir_T	*virp,
+    int		forceit,
+    int		writing)
+{
+    int		eof;
+    buf_T	*buf;
+    int		got_encoding = FALSE;
+
+#ifdef FEAT_CMDHIST
+    prepare_viminfo_history(forceit ? 9999 : 0, writing);
+#endif
+
+    eof = viminfo_readline(virp);
+    while (!eof && virp->vir_line[0] != '>')
+    {
+	switch (virp->vir_line[0])
+	{
+		/* Characters reserved for future expansion, ignored now */
+	    case '+': /* "+40 /path/dir file", for running vim without args */
+	    case '^': /* to be defined */
+	    case '<': /* long line - ignored */
+		/* A comment or empty line. */
+	    case NUL:
+	    case '\r':
+	    case '\n':
+	    case '#':
+		eof = viminfo_readline(virp);
+		break;
+	    case '|':
+		eof = read_viminfo_barline(virp, got_encoding,
+							    forceit, writing);
+		break;
+	    case '*': /* "*encoding=value" */
+		got_encoding = TRUE;
+		eof = viminfo_encoding(virp);
+		break;
+	    case '!': /* global variable */
+#ifdef FEAT_EVAL
+		eof = read_viminfo_varlist(virp, writing);
+#else
+		eof = viminfo_readline(virp);
+#endif
+		break;
+	    case '%': /* entry for buffer list */
+		eof = read_viminfo_bufferlist(virp, writing);
+		break;
+	    case '"':
+		/* When registers are in bar lines skip the old style register
+		 * lines. */
+		if (virp->vir_version < VIMINFO_VERSION_WITH_REGISTERS)
+		    eof = read_viminfo_register(virp, forceit);
+		else
+		    do {
+			eof = viminfo_readline(virp);
+		    } while (!eof && (virp->vir_line[0] == TAB
+						|| virp->vir_line[0] == '<'));
+		break;
+	    case '/':	    /* Search string */
+	    case '&':	    /* Substitute search string */
+	    case '~':	    /* Last search string, followed by '/' or '&' */
+		eof = read_viminfo_search_pattern(virp, forceit);
+		break;
+	    case '$':
+		eof = read_viminfo_sub_string(virp, forceit);
+		break;
+	    case ':':
+	    case '?':
+	    case '=':
+	    case '@':
+#ifdef FEAT_CMDHIST
+		/* When history is in bar lines skip the old style history
+		 * lines. */
+		if (virp->vir_version < VIMINFO_VERSION_WITH_HISTORY)
+		    eof = read_viminfo_history(virp, writing);
+		else
+#endif
+		    eof = viminfo_readline(virp);
+		break;
+	    case '-':
+	    case '\'':
+		/* When file marks are in bar lines skip the old style lines. */
+		if (virp->vir_version < VIMINFO_VERSION_WITH_MARKS)
+		    eof = read_viminfo_filemark(virp, forceit);
+		else
+		    eof = viminfo_readline(virp);
+		break;
+	    default:
+		if (viminfo_error("E575: ", _("Illegal starting char"),
+			    virp->vir_line))
+		    eof = TRUE;
+		else
+		    eof = viminfo_readline(virp);
+		break;
+	}
+    }
+
+#ifdef FEAT_CMDHIST
+    /* Finish reading history items. */
+    if (!writing)
+	finish_viminfo_history(virp);
+#endif
+
+    /* Change file names to buffer numbers for fmarks. */
+    FOR_ALL_BUFFERS(buf)
+	fmarks_check_names(buf);
+
+    return eof;
+}
+
+/*
+ * Compare the 'encoding' value in the viminfo file with the current value of
+ * 'encoding'.  If different and the 'c' flag is in 'viminfo', setup for
+ * conversion of text with iconv() in viminfo_readstring().
+ */
+    static int
+viminfo_encoding(vir_T *virp)
+{
+#ifdef FEAT_MBYTE
+    char_u	*p;
+    int		i;
+
+    if (get_viminfo_parameter('c') != 0)
+    {
+	p = vim_strchr(virp->vir_line, '=');
+	if (p != NULL)
+	{
+	    /* remove trailing newline */
+	    ++p;
+	    for (i = 0; vim_isprintc(p[i]); ++i)
+		;
+	    p[i] = NUL;
+
+	    convert_setup(&virp->vir_conv, p, p_enc);
+	}
+    }
+#endif
+    return viminfo_readline(virp);
+}
+
+/*
+ * Read a line from the viminfo file.
+ * Returns TRUE for end-of-file;
+ */
+    int
+viminfo_readline(vir_T *virp)
+{
+    return vim_fgets(virp->vir_line, LSIZE, virp->vir_fd);
+}
+
+/*
+ * Check string read from viminfo file.
+ * Remove '\n' at the end of the line.
+ * - replace CTRL-V CTRL-V with CTRL-V
+ * - replace CTRL-V 'n'    with '\n'
+ *
+ * Check for a long line as written by viminfo_writestring().
+ *
+ * Return the string in allocated memory (NULL when out of memory).
+ */
+    char_u *
+viminfo_readstring(
+    vir_T	*virp,
+    int		off,		    /* offset for virp->vir_line */
+    int		convert UNUSED)	    /* convert the string */
+{
+    char_u	*retval;
+    char_u	*s, *d;
+    long	len;
+
+    if (virp->vir_line[off] == Ctrl_V && vim_isdigit(virp->vir_line[off + 1]))
+    {
+	len = atol((char *)virp->vir_line + off + 1);
+	retval = lalloc(len, TRUE);
+	if (retval == NULL)
+	{
+	    /* Line too long?  File messed up?  Skip next line. */
+	    (void)vim_fgets(virp->vir_line, 10, virp->vir_fd);
+	    return NULL;
+	}
+	(void)vim_fgets(retval, (int)len, virp->vir_fd);
+	s = retval + 1;	    /* Skip the leading '<' */
+    }
+    else
+    {
+	retval = vim_strsave(virp->vir_line + off);
+	if (retval == NULL)
+	    return NULL;
+	s = retval;
+    }
+
+    /* Change CTRL-V CTRL-V to CTRL-V and CTRL-V n to \n in-place. */
+    d = retval;
+    while (*s != NUL && *s != '\n')
+    {
+	if (s[0] == Ctrl_V && s[1] != NUL)
+	{
+	    if (s[1] == 'n')
+		*d++ = '\n';
+	    else
+		*d++ = Ctrl_V;
+	    s += 2;
+	}
+	else
+	    *d++ = *s++;
+    }
+    *d = NUL;
+
+#ifdef FEAT_MBYTE
+    if (convert && virp->vir_conv.vc_type != CONV_NONE && *retval != NUL)
+    {
+	d = string_convert(&virp->vir_conv, retval, NULL);
+	if (d != NULL)
+	{
+	    vim_free(retval);
+	    retval = d;
+	}
+    }
+#endif
+
+    return retval;
+}
+
+/*
+ * write string to viminfo file
+ * - replace CTRL-V with CTRL-V CTRL-V
+ * - replace '\n'   with CTRL-V 'n'
+ * - add a '\n' at the end
+ *
+ * For a long line:
+ * - write " CTRL-V <length> \n " in first line
+ * - write " < <string> \n "	  in second line
+ */
+    void
+viminfo_writestring(FILE *fd, char_u *p)
+{
+    int		c;
+    char_u	*s;
+    int		len = 0;
+
+    for (s = p; *s != NUL; ++s)
+    {
+	if (*s == Ctrl_V || *s == '\n')
+	    ++len;
+	++len;
+    }
+
+    /* If the string will be too long, write its length and put it in the next
+     * line.  Take into account that some room is needed for what comes before
+     * the string (e.g., variable name).  Add something to the length for the
+     * '<', NL and trailing NUL. */
+    if (len > LSIZE / 2)
+	fprintf(fd, IF_EB("\026%d\n<", CTRL_V_STR "%d\n<"), len + 3);
+
+    while ((c = *p++) != NUL)
+    {
+	if (c == Ctrl_V || c == '\n')
+	{
+	    putc(Ctrl_V, fd);
+	    if (c == '\n')
+		c = 'n';
+	}
+	putc(c, fd);
+    }
+    putc('\n', fd);
+}
+
+/*
+ * Write a string in quotes that barline_parse() can read back.
+ * Breaks the line in less than LSIZE pieces when needed.
+ * Returns remaining characters in the line.
+ */
+    int
+barline_writestring(FILE *fd, char_u *s, int remaining_start)
+{
+    char_u *p;
+    int	    remaining = remaining_start;
+    int	    len = 2;
+
+    /* Count the number of characters produced, including quotes. */
+    for (p = s; *p != NUL; ++p)
+    {
+	if (*p == NL)
+	    len += 2;
+	else if (*p == '"' || *p == '\\')
+	    len += 2;
+	else
+	    ++len;
+    }
+    if (len > remaining - 2)
+    {
+	fprintf(fd, ">%d\n|<", len);
+	remaining = LSIZE - 20;
+    }
+
+    putc('"', fd);
+    for (p = s; *p != NUL; ++p)
+    {
+	if (*p == NL)
+	{
+	    putc('\\', fd);
+	    putc('n', fd);
+	    --remaining;
+	}
+	else if (*p == '"' || *p == '\\')
+	{
+	    putc('\\', fd);
+	    putc(*p, fd);
+	    --remaining;
+	}
+	else
+	    putc(*p, fd);
+	--remaining;
+
+	if (remaining < 3)
+	{
+	    putc('\n', fd);
+	    putc('|', fd);
+	    putc('<', fd);
+	    /* Leave enough space for another continuation. */
+	    remaining = LSIZE - 20;
+	}
+    }
+    putc('"', fd);
+    return remaining - 2;
+}
+
+/*
+ * Parse a viminfo line starting with '|'.
+ * Add each decoded value to "values".
+ * Returns TRUE if the next line is to be read after using the parsed values.
+ */
+    static int
+barline_parse(vir_T *virp, char_u *text, garray_T *values)
+{
+    char_u  *p = text;
+    char_u  *nextp = NULL;
+    char_u  *buf = NULL;
+    bval_T  *value;
+    int	    i;
+    int	    allocated = FALSE;
+    int	    eof;
+#ifdef FEAT_MBYTE
+    char_u  *sconv;
+    int	    converted;
+#endif
+
+    while (*p == ',')
+    {
+	++p;
+	if (ga_grow(values, 1) == FAIL)
+	    break;
+	value = (bval_T *)(values->ga_data) + values->ga_len;
+
+	if (*p == '>')
+	{
+	    /* Need to read a continuation line.  Put strings in allocated
+	     * memory, because virp->vir_line is overwritten. */
+	    if (!allocated)
+	    {
+		for (i = 0; i < values->ga_len; ++i)
+		{
+		    bval_T  *vp = (bval_T *)(values->ga_data) + i;
+
+		    if (vp->bv_type == BVAL_STRING && !vp->bv_allocated)
+		    {
+			vp->bv_string = vim_strnsave(vp->bv_string, vp->bv_len);
+			vp->bv_allocated = TRUE;
+		    }
+		}
+		allocated = TRUE;
+	    }
+
+	    if (vim_isdigit(p[1]))
+	    {
+		size_t len;
+		size_t todo;
+		size_t n;
+
+		/* String value was split into lines that are each shorter
+		 * than LSIZE:
+		 *     |{bartype},>{length of "{text}{text2}"}
+		 *     |<"{text1}
+		 *     |<{text2}",{value}
+		 * Length includes the quotes.
+		 */
+		++p;
+		len = getdigits(&p);
+		buf = alloc((int)(len + 1));
+		if (buf == NULL)
+		    return TRUE;
+		p = buf;
+		for (todo = len; todo > 0; todo -= n)
+		{
+		    eof = viminfo_readline(virp);
+		    if (eof || virp->vir_line[0] != '|'
+						  || virp->vir_line[1] != '<')
+		    {
+			/* File was truncated or garbled. Read another line if
+			 * this one starts with '|'. */
+			vim_free(buf);
+			return eof || virp->vir_line[0] == '|';
+		    }
+		    /* Get length of text, excluding |< and NL chars. */
+		    n = STRLEN(virp->vir_line);
+		    while (n > 0 && (virp->vir_line[n - 1] == NL
+					     || virp->vir_line[n - 1] == CAR))
+			--n;
+		    n -= 2;
+		    if (n > todo)
+		    {
+			/* more values follow after the string */
+			nextp = virp->vir_line + 2 + todo;
+			n = todo;
+		    }
+		    mch_memmove(p, virp->vir_line + 2, n);
+		    p += n;
+		}
+		*p = NUL;
+		p = buf;
+	    }
+	    else
+	    {
+		/* Line ending in ">" continues in the next line:
+		 *     |{bartype},{lots of values},>
+		 *     |<{value},{value}
+		 */
+		eof = viminfo_readline(virp);
+		if (eof || virp->vir_line[0] != '|'
+					      || virp->vir_line[1] != '<')
+		    /* File was truncated or garbled. Read another line if
+		     * this one starts with '|'. */
+		    return eof || virp->vir_line[0] == '|';
+		p = virp->vir_line + 2;
+	    }
+	}
+
+	if (isdigit(*p))
+	{
+	    value->bv_type = BVAL_NR;
+	    value->bv_nr = getdigits(&p);
+	    ++values->ga_len;
+	}
+	else if (*p == '"')
+	{
+	    int	    len = 0;
+	    char_u  *s = p;
+
+	    /* Unescape special characters in-place. */
+	    ++p;
+	    while (*p != '"')
+	    {
+		if (*p == NL || *p == NUL)
+		    return TRUE;  /* syntax error, drop the value */
+		if (*p == '\\')
+		{
+		    ++p;
+		    if (*p == 'n')
+			s[len++] = '\n';
+		    else
+			s[len++] = *p;
+		    ++p;
+		}
+		else
+		    s[len++] = *p++;
+	    }
+	    ++p;
+	    s[len] = NUL;
+
+#ifdef FEAT_MBYTE
+	    converted = FALSE;
+	    if (virp->vir_conv.vc_type != CONV_NONE && *s != NUL)
+	    {
+		sconv = string_convert(&virp->vir_conv, s, NULL);
+		if (sconv != NULL)
+		{
+		    if (s == buf)
+			vim_free(s);
+		    s = sconv;
+		    buf = s;
+		    converted = TRUE;
+		}
+	    }
+#endif
+	    /* Need to copy in allocated memory if the string wasn't allocated
+	     * above and we did allocate before, thus vir_line may change. */
+	    if (s != buf && allocated)
+		s = vim_strsave(s);
+	    value->bv_string = s;
+	    value->bv_type = BVAL_STRING;
+	    value->bv_len = len;
+	    value->bv_allocated = allocated
+#ifdef FEAT_MBYTE
+					    || converted
+#endif
+						;
+	    ++values->ga_len;
+	    if (nextp != NULL)
+	    {
+		/* values following a long string */
+		p = nextp;
+		nextp = NULL;
+	    }
+	}
+	else if (*p == ',')
+	{
+	    value->bv_type = BVAL_EMPTY;
+	    ++values->ga_len;
+	}
+	else
+	    break;
+    }
+    return TRUE;
+}
+
+    static int
+read_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)
+{
+    char_u	*p = virp->vir_line + 1;
+    int		bartype;
+    garray_T	values;
+    bval_T	*vp;
+    int		i;
+    int		read_next = TRUE;
+
+    /* The format is: |{bartype},{value},...
+     * For a very long string:
+     *     |{bartype},>{length of "{text}{text2}"}
+     *     |<{text1}
+     *     |<{text2},{value}
+     * For a long line not using a string
+     *     |{bartype},{lots of values},>
+     *     |<{value},{value}
+     */
+    if (*p == '<')
+    {
+	/* Continuation line of an unrecognized item. */
+	if (writing)
+	    ga_add_string(&virp->vir_barlines, virp->vir_line);
+    }
+    else
+    {
+	ga_init2(&values, sizeof(bval_T), 20);
+	bartype = getdigits(&p);
+	switch (bartype)
+	{
+	    case BARTYPE_VERSION:
+		/* Only use the version when it comes before the encoding.
+		 * If it comes later it was copied by a Vim version that
+		 * doesn't understand the version. */
+		if (!got_encoding)
+		{
+		    read_next = barline_parse(virp, p, &values);
+		    vp = (bval_T *)values.ga_data;
+		    if (values.ga_len > 0 && vp->bv_type == BVAL_NR)
+			virp->vir_version = vp->bv_nr;
+		}
+		break;
+
+	    case BARTYPE_HISTORY:
+		read_next = barline_parse(virp, p, &values);
+		handle_viminfo_history(&values, writing);
+		break;
+
+	    case BARTYPE_REGISTER:
+		read_next = barline_parse(virp, p, &values);
+		handle_viminfo_register(&values, force);
+		break;
+
+	    case BARTYPE_MARK:
+		read_next = barline_parse(virp, p, &values);
+		handle_viminfo_mark(&values, force);
+		break;
+
+	    default:
+		/* copy unrecognized line (for future use) */
+		if (writing)
+		    ga_add_string(&virp->vir_barlines, virp->vir_line);
+	}
+	for (i = 0; i < values.ga_len; ++i)
+	{
+	    vp = (bval_T *)values.ga_data + i;
+	    if (vp->bv_type == BVAL_STRING && vp->bv_allocated)
+		vim_free(vp->bv_string);
+	}
+	ga_clear(&values);
+    }
+
+    if (read_next)
+	return viminfo_readline(virp);
+    return FALSE;
+}
+
+    static void
+write_viminfo_version(FILE *fp_out)
+{
+    fprintf(fp_out, "# Viminfo version\n|%d,%d\n\n",
+					    BARTYPE_VERSION, VIMINFO_VERSION);
+}
+
+    static void
+write_viminfo_barlines(vir_T *virp, FILE *fp_out)
+{
+    int		i;
+    garray_T	*gap = &virp->vir_barlines;
+    int		seen_useful = FALSE;
+    char	*line;
+
+    if (gap->ga_len > 0)
+    {
+	fputs(_("\n# Bar lines, copied verbatim:\n"), fp_out);
+
+	/* Skip over continuation lines until seeing a useful line. */
+	for (i = 0; i < gap->ga_len; ++i)
+	{
+	    line = ((char **)(gap->ga_data))[i];
+	    if (seen_useful || line[1] != '<')
+	    {
+		fputs(line, fp_out);
+		seen_useful = TRUE;
+	    }
+	}
+    }
+}
+#endif /* FEAT_VIMINFO */
+
+/*
+ * Return the current time in seconds.  Calls time(), unless test_settime()
+ * was used.
+ */
+    time_T
+vim_time(void)
+{
+# ifdef FEAT_EVAL
+    return time_for_testing == 0 ? time(NULL) : time_for_testing;
+# else
+    return time(NULL);
+# endif
+}
+
+/*
+ * Implementation of ":fixdel", also used by get_stty().
+ *  <BS>    resulting <Del>
+ *   ^?		^H
+ * not ^?	^?
+ */
+    void
+do_fixdel(exarg_T *eap UNUSED)
+{
+    char_u  *p;
+
+    p = find_termcode((char_u *)"kb");
+    add_termcode((char_u *)"kD", p != NULL
+	    && *p == DEL ? (char_u *)CTRL_H_STR : DEL_STR, FALSE);
+}
+
+    void
+print_line_no_prefix(
+    linenr_T	lnum,
+    int		use_number,
+    int		list)
+{
+    char_u	numbuf[30];
+
+    if (curwin->w_p_nu || use_number)
+    {
+	vim_snprintf((char *)numbuf, sizeof(numbuf),
+				   "%*ld ", number_width(curwin), (long)lnum);
+	msg_puts_attr(numbuf, HL_ATTR(HLF_N));	/* Highlight line nrs */
+    }
+    msg_prt_line(ml_get(lnum), list);
+}
+
+/*
+ * Print a text line.  Also in silent mode ("ex -s").
+ */
+    void
+print_line(linenr_T lnum, int use_number, int list)
+{
+    int		save_silent = silent_mode;
+
+    /* apply :filter /pat/ */
+    if (message_filtered(ml_get(lnum)))
+	return;
+
+    msg_start();
+    silent_mode = FALSE;
+    info_message = TRUE;	/* use mch_msg(), not mch_errmsg() */
+    print_line_no_prefix(lnum, use_number, list);
+    if (save_silent)
+    {
+	msg_putchar('\n');
+	cursor_on();		/* msg_start() switches it off */
+	out_flush();
+	silent_mode = save_silent;
+    }
+    info_message = FALSE;
+}
+
+    int
+rename_buffer(char_u *new_fname)
+{
+    char_u	*fname, *sfname, *xfname;
+    buf_T	*buf;
+
+    buf = curbuf;
+    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);
+    /* buffer changed, don't change name now */
+    if (buf != curbuf)
+	return FAIL;
+#ifdef FEAT_EVAL
+    if (aborting())	    /* autocmds may abort script processing */
+	return FAIL;
+#endif
+    /*
+     * The name of the current buffer will be changed.
+     * A new (unlisted) buffer entry needs to be made to hold the old file
+     * name, which will become the alternate file name.
+     * But don't set the alternate file name if the buffer didn't have a
+     * name.
+     */
+    fname = curbuf->b_ffname;
+    sfname = curbuf->b_sfname;
+    xfname = curbuf->b_fname;
+    curbuf->b_ffname = NULL;
+    curbuf->b_sfname = NULL;
+    if (setfname(curbuf, new_fname, NULL, TRUE) == FAIL)
+    {
+	curbuf->b_ffname = fname;
+	curbuf->b_sfname = sfname;
+	return FAIL;
+    }
+    curbuf->b_flags |= BF_NOTEDITED;
+    if (xfname != NULL && *xfname != NUL)
+    {
+	buf = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);
+	if (buf != NULL && !cmdmod.keepalt)
+	    curwin->w_alt_fnum = buf->b_fnum;
+    }
+    vim_free(fname);
+    vim_free(sfname);
+    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);
+
+    /* Change directories when the 'acd' option is set. */
+    DO_AUTOCHDIR;
+    return OK;
+}
+
+/*
+ * ":file[!] [fname]".
+ */
+    void
+ex_file(exarg_T *eap)
+{
+    /* ":0file" removes the file name.  Check for illegal uses ":3file",
+     * "0file name", etc. */
+    if (eap->addr_count > 0
+	    && (*eap->arg != NUL
+		|| eap->line2 > 0
+		|| eap->addr_count > 1))
+    {
+	EMSG(_(e_invarg));
+	return;
+    }
+
+    if (*eap->arg != NUL || eap->addr_count == 1)
+    {
+	if (rename_buffer(eap->arg) == FAIL)
+	    return;
+	redraw_tabline = TRUE;
+    }
+
+    // print file name if no argument or 'F' is not in 'shortmess'
+    if (*eap->arg == NUL || !shortmess(SHM_FILEINFO))
+	fileinfo(FALSE, FALSE, eap->forceit);
+}
+
+/*
+ * ":update".
+ */
+    void
+ex_update(exarg_T *eap)
+{
+    if (curbufIsChanged())
+	(void)do_write(eap);
+}
+
+/*
+ * ":write" and ":saveas".
+ */
+    void
+ex_write(exarg_T *eap)
+{
+    if (eap->usefilter)		/* input lines to shell command */
+	do_bang(1, eap, FALSE, TRUE, FALSE);
+    else
+	(void)do_write(eap);
+}
+
+/*
+ * write current buffer to file 'eap->arg'
+ * if 'eap->append' is TRUE, append to the file
+ *
+ * if *eap->arg == NUL write to current file
+ *
+ * return FAIL for failure, OK otherwise
+ */
+    int
+do_write(exarg_T *eap)
+{
+    int		other;
+    char_u	*fname = NULL;		/* init to shut up gcc */
+    char_u	*ffname;
+    int		retval = FAIL;
+    char_u	*free_fname = NULL;
+#ifdef FEAT_BROWSE
+    char_u	*browse_file = NULL;
+#endif
+    buf_T	*alt_buf = NULL;
+    int		name_was_missing;
+
+    if (not_writing())		/* check 'write' option */
+	return FAIL;
+
+    ffname = eap->arg;
+#ifdef FEAT_BROWSE
+    if (cmdmod.browse)
+    {
+	browse_file = do_browse(BROWSE_SAVE, (char_u *)_("Save As"), ffname,
+						    NULL, NULL, NULL, curbuf);
+	if (browse_file == NULL)
+	    goto theend;
+	ffname = browse_file;
+    }
+#endif
+    if (*ffname == NUL)
+    {
+	if (eap->cmdidx == CMD_saveas)
+	{
+	    EMSG(_(e_argreq));
+	    goto theend;
+	}
+	other = FALSE;
+    }
+    else
+    {
+	fname = ffname;
+	free_fname = fix_fname(ffname);
+	/*
+	 * When out-of-memory, keep unexpanded file name, because we MUST be
+	 * able to write the file in this situation.
+	 */
+	if (free_fname != NULL)
+	    ffname = free_fname;
+	other = otherfile(ffname);
+    }
+
+    /*
+     * If we have a new file, put its name in the list of alternate file names.
+     */
+    if (other)
+    {
+	if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL
+						 || eap->cmdidx == CMD_saveas)
+	    alt_buf = setaltfname(ffname, fname, (linenr_T)1);
+	else
+	    alt_buf = buflist_findname(ffname);
+	if (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL)
+	{
+	    /* Overwriting a file that is loaded in another buffer is not a
+	     * good idea. */
+	    EMSG(_(e_bufloaded));
+	    goto theend;
+	}
+    }
+
+    /*
+     * Writing to the current file is not allowed in readonly mode
+     * and a file name is required.
+     * "nofile" and "nowrite" buffers cannot be written implicitly either.
+     */
+    if (!other && (
+#ifdef FEAT_QUICKFIX
+		bt_dontwrite_msg(curbuf) ||
+#endif
+		check_fname() == FAIL || check_readonly(&eap->forceit, curbuf)))
+	goto theend;
+
+    if (!other)
+    {
+	ffname = curbuf->b_ffname;
+	fname = curbuf->b_fname;
+	/*
+	 * Not writing the whole file is only allowed with '!'.
+	 */
+	if (	   (eap->line1 != 1
+		    || eap->line2 != curbuf->b_ml.ml_line_count)
+		&& !eap->forceit
+		&& !eap->append
+		&& !p_wa)
+	{
+#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+	    if (p_confirm || cmdmod.confirm)
+	    {
+		if (vim_dialog_yesno(VIM_QUESTION, NULL,
+			       (char_u *)_("Write partial file?"), 2) != VIM_YES)
+		    goto theend;
+		eap->forceit = TRUE;
+	    }
+	    else
+#endif
+	    {
+		EMSG(_("E140: Use ! to write partial buffer"));
+		goto theend;
+	    }
+	}
+    }
+
+    if (check_overwrite(eap, curbuf, fname, ffname, other) == OK)
+    {
+	if (eap->cmdidx == CMD_saveas && alt_buf != NULL)
+	{
+	    buf_T	*was_curbuf = curbuf;
+
+	    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);
+	    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);
+#ifdef FEAT_EVAL
+	    if (curbuf != was_curbuf || aborting())
+#else
+	    if (curbuf != was_curbuf)
+#endif
+	    {
+		/* buffer changed, don't change name now */
+		retval = FAIL;
+		goto theend;
+	    }
+	    /* Exchange the file names for the current and the alternate
+	     * buffer.  This makes it look like we are now editing the buffer
+	     * under the new name.  Must be done before buf_write(), because
+	     * if there is no file name and 'cpo' contains 'F', it will set
+	     * the file name. */
+	    fname = alt_buf->b_fname;
+	    alt_buf->b_fname = curbuf->b_fname;
+	    curbuf->b_fname = fname;
+	    fname = alt_buf->b_ffname;
+	    alt_buf->b_ffname = curbuf->b_ffname;
+	    curbuf->b_ffname = fname;
+	    fname = alt_buf->b_sfname;
+	    alt_buf->b_sfname = curbuf->b_sfname;
+	    curbuf->b_sfname = fname;
+	    buf_name_changed(curbuf);
+
+	    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);
+	    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);
+	    if (!alt_buf->b_p_bl)
+	    {
+		alt_buf->b_p_bl = TRUE;
+		apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);
+	    }
+#ifdef FEAT_EVAL
+	    if (curbuf != was_curbuf || aborting())
+#else
+	    if (curbuf != was_curbuf)
+#endif
+	    {
+		/* buffer changed, don't write the file */
+		retval = FAIL;
+		goto theend;
+	    }
+
+	    /* If 'filetype' was empty try detecting it now. */
+	    if (*curbuf->b_p_ft == NUL)
+	    {
+		if (au_has_group((char_u *)"filetypedetect"))
+		    (void)do_doautocmd((char_u *)"filetypedetect BufRead",
+								  TRUE, NULL);
+		do_modelines(0);
+	    }
+
+	    /* Autocommands may have changed buffer names, esp. when
+	     * 'autochdir' is set. */
+	    fname = curbuf->b_sfname;
+	}
+
+	name_was_missing = curbuf->b_ffname == NULL;
+
+	retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,
+				 eap, eap->append, eap->forceit, TRUE, FALSE);
+
+	/* After ":saveas fname" reset 'readonly'. */
+	if (eap->cmdidx == CMD_saveas)
+	{
+	    if (retval == OK)
+	    {
+		curbuf->b_p_ro = FALSE;
+		redraw_tabline = TRUE;
+	    }
+	}
+
+	/* Change directories when the 'acd' option is set and the file name
+	 * got changed or set. */
+	if (eap->cmdidx == CMD_saveas || name_was_missing)
+	{
+	    DO_AUTOCHDIR;
+	}
+    }
+
+theend:
+#ifdef FEAT_BROWSE
+    vim_free(browse_file);
+#endif
+    vim_free(free_fname);
+    return retval;
+}
+
+/*
+ * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,
+ * BF_NEW or BF_READERR, check for overwriting current file.
+ * May set eap->forceit if a dialog says it's OK to overwrite.
+ * Return OK if it's OK, FAIL if it is not.
+ */
+    int
+check_overwrite(
+    exarg_T	*eap,
+    buf_T	*buf,
+    char_u	*fname,	    /* file name to be used (can differ from
+			       buf->ffname) */
+    char_u	*ffname,    /* full path version of fname */
+    int		other)	    /* writing under other name */
+{
+    /*
+     * write to other file or b_flags set or not writing the whole file:
+     * overwriting only allowed with '!'
+     */
+    if (       (other
+		|| (buf->b_flags & BF_NOTEDITED)
+		|| ((buf->b_flags & BF_NEW)
+		    && vim_strchr(p_cpo, CPO_OVERNEW) == NULL)
+		|| (buf->b_flags & BF_READERR))
+	    && !p_wa
+#ifdef FEAT_QUICKFIX
+	    && !bt_nofile(buf)
+#endif
+	    && vim_fexists(ffname))
+    {
+	if (!eap->forceit && !eap->append)
+	{
+#ifdef UNIX
+	    /* with UNIX it is possible to open a directory */
+	    if (mch_isdir(ffname))
+	    {
+		EMSG2(_(e_isadir2), ffname);
+		return FAIL;
+	    }
+#endif
+#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+	    if (p_confirm || cmdmod.confirm)
+	    {
+		char_u	buff[DIALOG_MSG_SIZE];
+
+		dialog_msg(buff, _("Overwrite existing file \"%s\"?"), fname);
+		if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)
+		    return FAIL;
+		eap->forceit = TRUE;
+	    }
+	    else
+#endif
+	    {
+		EMSG(_(e_exists));
+		return FAIL;
+	    }
+	}
+
+	/* For ":w! filename" check that no swap file exists for "filename". */
+	if (other && !emsg_silent)
+	{
+	    char_u	*dir;
+	    char_u	*p;
+	    int		r;
+	    char_u	*swapname;
+
+	    /* We only try the first entry in 'directory', without checking if
+	     * it's writable.  If the "." directory is not writable the write
+	     * will probably fail anyway.
+	     * Use 'shortname' of the current buffer, since there is no buffer
+	     * for the written file. */
+	    if (*p_dir == NUL)
+	    {
+		dir = alloc(5);
+		if (dir == NULL)
+		    return FAIL;
+		STRCPY(dir, ".");
+	    }
+	    else
+	    {
+		dir = alloc(MAXPATHL);
+		if (dir == NULL)
+		    return FAIL;
+		p = p_dir;
+		copy_option_part(&p, dir, MAXPATHL, ",");
+	    }
+	    swapname = makeswapname(fname, ffname, curbuf, dir);
+	    vim_free(dir);
+	    r = vim_fexists(swapname);
+	    if (r)
+	    {
+#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+		if (p_confirm || cmdmod.confirm)
+		{
+		    char_u	buff[DIALOG_MSG_SIZE];
+
+		    dialog_msg(buff,
+			    _("Swap file \"%s\" exists, overwrite anyway?"),
+								    swapname);
+		    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)
+								   != VIM_YES)
+		    {
+			vim_free(swapname);
+			return FAIL;
+		    }
+		    eap->forceit = TRUE;
+		}
+		else
+#endif
+		{
+		    EMSG2(_("E768: Swap file exists: %s (:silent! overrides)"),
+								    swapname);
+		    vim_free(swapname);
+		    return FAIL;
+		}
+	    }
+	    vim_free(swapname);
+	}
+    }
+    return OK;
+}
+
+/*
+ * Handle ":wnext", ":wNext" and ":wprevious" commands.
+ */
+    void
+ex_wnext(exarg_T *eap)
+{
+    int		i;
+
+    if (eap->cmd[1] == 'n')
+	i = curwin->w_arg_idx + (int)eap->line2;
+    else
+	i = curwin->w_arg_idx - (int)eap->line2;
+    eap->line1 = 1;
+    eap->line2 = curbuf->b_ml.ml_line_count;
+    if (do_write(eap) != FAIL)
+	do_argfile(eap, i);
+}
+
+/*
+ * ":wall", ":wqall" and ":xall": Write all changed files (and exit).
+ */
+    void
+do_wqall(exarg_T *eap)
+{
+    buf_T	*buf;
+    int		error = 0;
+    int		save_forceit = eap->forceit;
+
+    if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall)
+	exiting = TRUE;
+
+    FOR_ALL_BUFFERS(buf)
+    {
+#ifdef FEAT_TERMINAL
+	if (exiting && term_job_running(buf->b_term))
+	{
+	    no_write_message_nobang(buf);
+	    ++error;
+	}
+	else
+#endif
+	if (bufIsChanged(buf) && !bt_dontwrite(buf))
+	{
+	    /*
+	     * Check if there is a reason the buffer cannot be written:
+	     * 1. if the 'write' option is set
+	     * 2. if there is no file name (even after browsing)
+	     * 3. if the 'readonly' is set (even after a dialog)
+	     * 4. if overwriting is allowed (even after a dialog)
+	     */
+	    if (not_writing())
+	    {
+		++error;
+		break;
+	    }
+#ifdef FEAT_BROWSE
+	    /* ":browse wall": ask for file name if there isn't one */
+	    if (buf->b_ffname == NULL && cmdmod.browse)
+		browse_save_fname(buf);
+#endif
+	    if (buf->b_ffname == NULL)
+	    {
+		EMSGN(_("E141: No file name for buffer %ld"), (long)buf->b_fnum);
+		++error;
+	    }
+	    else if (check_readonly(&eap->forceit, buf)
+		    || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,
+							       FALSE) == FAIL)
+	    {
+		++error;
+	    }
+	    else
+	    {
+		bufref_T bufref;
+
+		set_bufref(&bufref, buf);
+		if (buf_write_all(buf, eap->forceit) == FAIL)
+		    ++error;
+		/* an autocommand may have deleted the buffer */
+		if (!bufref_valid(&bufref))
+		    buf = firstbuf;
+	    }
+	    eap->forceit = save_forceit;    /* check_overwrite() may set it */
+	}
+    }
+    if (exiting)
+    {
+	if (!error)
+	    getout(0);		/* exit Vim */
+	not_exiting();
+    }
+}
+
+/*
+ * Check the 'write' option.
+ * Return TRUE and give a message when it's not st.
+ */
+    int
+not_writing(void)
+{
+    if (p_write)
+	return FALSE;
+    EMSG(_("E142: File not written: Writing is disabled by 'write' option"));
+    return TRUE;
+}
+
+/*
+ * Check if a buffer is read-only (either 'readonly' option is set or file is
+ * read-only). Ask for overruling in a dialog. Return TRUE and give an error
+ * message when the buffer is readonly.
+ */
+    static int
+check_readonly(int *forceit, buf_T *buf)
+{
+    stat_T	st;
+
+    /* Handle a file being readonly when the 'readonly' option is set or when
+     * the file exists and permissions are read-only.
+     * We will send 0777 to check_file_readonly(), as the "perm" variable is
+     * important for device checks but not here. */
+    if (!*forceit && (buf->b_p_ro
+		|| (mch_stat((char *)buf->b_ffname, &st) >= 0
+		    && check_file_readonly(buf->b_ffname, 0777))))
+    {
+#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+	if ((p_confirm || cmdmod.confirm) && buf->b_fname != NULL)
+	{
+	    char_u	buff[DIALOG_MSG_SIZE];
+
+	    if (buf->b_p_ro)
+		dialog_msg(buff, _("'readonly' option is set for \"%s\".\nDo you wish to write anyway?"),
+		    buf->b_fname);
+	    else
+		dialog_msg(buff, _("File permissions of \"%s\" are read-only.\nIt may still be possible to write it.\nDo you wish to try?"),
+		    buf->b_fname);
+
+	    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)
+	    {
+		/* Set forceit, to force the writing of a readonly file */
+		*forceit = TRUE;
+		return FALSE;
+	    }
+	    else
+		return TRUE;
+	}
+	else
+#endif
+	if (buf->b_p_ro)
+	    EMSG(_(e_readonly));
+	else
+	    EMSG2(_("E505: \"%s\" is read-only (add ! to override)"),
+		    buf->b_fname);
+	return TRUE;
+    }
+
+    return FALSE;
+}
+
+/*
+ * Try to abandon current file and edit a new or existing file.
+ * "fnum" is the number of the file, if zero use ffname/sfname.
+ * "lnum" is the line number for the cursor in the new file (if non-zero).
+ *
+ * Return:
+ * GETFILE_ERROR for "normal" error,
+ * GETFILE_NOT_WRITTEN for "not written" error,
+ * GETFILE_SAME_FILE for success
+ * GETFILE_OPEN_OTHER for successfully opening another file.
+ */
+    int
+getfile(
+    int		fnum,
+    char_u	*ffname,
+    char_u	*sfname,
+    int		setpm,
+    linenr_T	lnum,
+    int		forceit)
+{
+    int		other;
+    int		retval;
+    char_u	*free_me = NULL;
+
+    if (text_locked())
+	return GETFILE_ERROR;
+    if (curbuf_locked())
+	return GETFILE_ERROR;
+
+    if (fnum == 0)
+    {
+					/* make ffname full path, set sfname */
+	fname_expand(curbuf, &ffname, &sfname);
+	other = otherfile(ffname);
+	free_me = ffname;		/* has been allocated, free() later */
+    }
+    else
+	other = (fnum != curbuf->b_fnum);
+
+    if (other)
+	++no_wait_return;	    /* don't wait for autowrite message */
+    if (other && !forceit && curbuf->b_nwindows == 1 && !buf_hide(curbuf)
+		   && curbufIsChanged() && autowrite(curbuf, forceit) == FAIL)
+    {
+#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+	if (p_confirm && p_write)
+	    dialog_changed(curbuf, FALSE);
+	if (curbufIsChanged())
+#endif
+	{
+	    if (other)
+		--no_wait_return;
+	    no_write_message();
+	    retval = GETFILE_NOT_WRITTEN;	/* file has been changed */
+	    goto theend;
+	}
+    }
+    if (other)
+	--no_wait_return;
+    if (setpm)
+	setpcmark();
+    if (!other)
+    {
+	if (lnum != 0)
+	    curwin->w_cursor.lnum = lnum;
+	check_cursor_lnum();
+	beginline(BL_SOL | BL_FIX);
+	retval = GETFILE_SAME_FILE;	/* it's in the same file */
+    }
+    else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,
+	     (buf_hide(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),
+		curwin) == OK)
+	retval = GETFILE_OPEN_OTHER;	/* opened another file */
+    else
+	retval = GETFILE_ERROR;		/* error encountered */
+
+theend:
+    vim_free(free_me);
+    return retval;
+}
+
+/*
+ * start editing a new file
+ *
+ *     fnum: file number; if zero use ffname/sfname
+ *   ffname: the file name
+ *		- full path if sfname used,
+ *		- any file name if sfname is NULL
+ *		- empty string to re-edit with the same file name (but may be
+ *		    in a different directory)
+ *		- NULL to start an empty buffer
+ *   sfname: the short file name (or NULL)
+ *	eap: contains the command to be executed after loading the file and
+ *	     forced 'ff' and 'fenc'
+ *  newlnum: if > 0: put cursor on this line number (if possible)
+ *	     if ECMD_LASTL: use last position in loaded file
+ *	     if ECMD_LAST: use last position in all files
+ *	     if ECMD_ONE: use first line
+ *    flags:
+ *	   ECMD_HIDE: if TRUE don't free the current buffer
+ *     ECMD_SET_HELP: set b_help flag of (new) buffer before opening file
+ *	 ECMD_OLDBUF: use existing buffer if it exists
+ *	ECMD_FORCEIT: ! used for Ex command
+ *	 ECMD_ADDBUF: don't edit, just add to buffer list
+ *   oldwin: Should be "curwin" when editing a new buffer in the current
+ *	     window, NULL when splitting the window first.  When not NULL info
+ *	     of the previous buffer for "oldwin" is stored.
+ *
+ * return FAIL for failure, OK otherwise
+ */
+    int
+do_ecmd(
+    int		fnum,
+    char_u	*ffname,
+    char_u	*sfname,
+    exarg_T	*eap,			/* can be NULL! */
+    linenr_T	newlnum,
+    int		flags,
+    win_T	*oldwin)
+{
+    int		other_file;		/* TRUE if editing another file */
+    int		oldbuf;			/* TRUE if using existing buffer */
+    int		auto_buf = FALSE;	/* TRUE if autocommands brought us
+					   into the buffer unexpectedly */
+    char_u	*new_name = NULL;
+#if defined(FEAT_EVAL)
+    int		did_set_swapcommand = FALSE;
+#endif
+    buf_T	*buf;
+    bufref_T	bufref;
+    bufref_T	old_curbuf;
+    char_u	*free_fname = NULL;
+#ifdef FEAT_BROWSE
+    char_u	*browse_file = NULL;
+#endif
+    int		retval = FAIL;
+    long	n;
+    pos_T	orig_pos;
+    linenr_T	topline = 0;
+    int		newcol = -1;
+    int		solcol = -1;
+    pos_T	*pos;
+#ifdef FEAT_SUN_WORKSHOP
+    char_u	*cp;
+#endif
+    char_u	*command = NULL;
+#ifdef FEAT_SPELL
+    int		did_get_winopts = FALSE;
+#endif
+    int		readfile_flags = 0;
+    int		did_inc_redrawing_disabled = FALSE;
+
+    if (eap != NULL)
+	command = eap->do_ecmd_cmd;
+    set_bufref(&old_curbuf, curbuf);
+
+    if (fnum != 0)
+    {
+	if (fnum == curbuf->b_fnum)	/* file is already being edited */
+	    return OK;			/* nothing to do */
+	other_file = TRUE;
+    }
+    else
+    {
+#ifdef FEAT_BROWSE
+	if (cmdmod.browse)
+	{
+	    if (
+# ifdef FEAT_GUI
+		!gui.in_use &&
+# endif
+		    au_has_group((char_u *)"FileExplorer"))
+	    {
+		/* No browsing supported but we do have the file explorer:
+		 * Edit the directory. */
+		if (ffname == NULL || !mch_isdir(ffname))
+		    ffname = (char_u *)".";
+	    }
+	    else
+	    {
+		browse_file = do_browse(0, (char_u *)_("Edit File"), ffname,
+						    NULL, NULL, NULL, curbuf);
+		if (browse_file == NULL)
+		    goto theend;
+		ffname = browse_file;
+	    }
+	}
+#endif
+	/* if no short name given, use ffname for short name */
+	if (sfname == NULL)
+	    sfname = ffname;
+#ifdef USE_FNAME_CASE
+# ifdef USE_LONG_FNAME
+	if (USE_LONG_FNAME)
+# endif
+	    if (sfname != NULL)
+		fname_case(sfname, 0);   /* set correct case for sfname */
+#endif
+
+	if ((flags & ECMD_ADDBUF) && (ffname == NULL || *ffname == NUL))
+	    goto theend;
+
+	if (ffname == NULL)
+	    other_file = TRUE;
+					    /* there is no file name */
+	else if (*ffname == NUL && curbuf->b_ffname == NULL)
+	    other_file = FALSE;
+	else
+	{
+	    if (*ffname == NUL)		    /* re-edit with same file name */
+	    {
+		ffname = curbuf->b_ffname;
+		sfname = curbuf->b_fname;
+	    }
+	    free_fname = fix_fname(ffname); /* may expand to full path name */
+	    if (free_fname != NULL)
+		ffname = free_fname;
+	    other_file = otherfile(ffname);
+#ifdef FEAT_SUN_WORKSHOP
+	    if (usingSunWorkShop && p_acd
+				   && (cp = vim_strrchr(sfname, '/')) != NULL)
+		sfname = ++cp;
+#endif
+	}
+    }
+
+    /*
+     * if the file was changed we may not be allowed to abandon it
+     * - if we are going to re-edit the same file
+     * - or if we are the only window on this file and if ECMD_HIDE is FALSE
+     */
+    if (  ((!other_file && !(flags & ECMD_OLDBUF))
+	    || (curbuf->b_nwindows == 1
+		&& !(flags & (ECMD_HIDE | ECMD_ADDBUF))))
+	&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)
+			       | (other_file ? 0 : CCGD_MULTWIN)
+			       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)
+			       | (eap == NULL ? 0 : CCGD_EXCMD)))
+    {
+	if (fnum == 0 && other_file && ffname != NULL)
+	    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);
+	goto theend;
+    }
+
+    /*
+     * End Visual mode before switching to another buffer, so the text can be
+     * copied into the GUI selection buffer.
+     */
+    reset_VIsual();
+
+#if defined(FEAT_EVAL)
+    if ((command != NULL || newlnum > (linenr_T)0)
+	    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)
+    {
+	int	len;
+	char_u	*p;
+
+	/* Set v:swapcommand for the SwapExists autocommands. */
+	if (command != NULL)
+	    len = (int)STRLEN(command) + 3;
+	else
+	    len = 30;
+	p = alloc((unsigned)len);
+	if (p != NULL)
+	{
+	    if (command != NULL)
+		vim_snprintf((char *)p, len, ":%s\r", command);
+	    else
+		vim_snprintf((char *)p, len, "%ldG", (long)newlnum);
+	    set_vim_var_string(VV_SWAPCOMMAND, p, -1);
+	    did_set_swapcommand = TRUE;
+	    vim_free(p);
+	}
+    }
+#endif
+
+    /*
+     * If we are starting to edit another file, open a (new) buffer.
+     * Otherwise we re-use the current buffer.
+     */
+    if (other_file)
+    {
+	if (!(flags & ECMD_ADDBUF))
+	{
+	    if (!cmdmod.keepalt)
+		curwin->w_alt_fnum = curbuf->b_fnum;
+	    if (oldwin != NULL)
+		buflist_altfpos(oldwin);
+	}
+
+	if (fnum)
+	    buf = buflist_findnr(fnum);
+	else
+	{
+	    if (flags & ECMD_ADDBUF)
+	    {
+		linenr_T	tlnum = 1L;
+
+		if (command != NULL)
+		{
+		    tlnum = atol((char *)command);
+		    if (tlnum <= 0)
+			tlnum = 1L;
+		}
+		(void)buflist_new(ffname, sfname, tlnum, BLN_LISTED);
+		goto theend;
+	    }
+	    buf = buflist_new(ffname, sfname, 0L,
+		    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));
+
+	    /* autocommands may change curwin and curbuf */
+	    if (oldwin != NULL)
+		oldwin = curwin;
+	    set_bufref(&old_curbuf, curbuf);
+	}
+	if (buf == NULL)
+	    goto theend;
+	if (buf->b_ml.ml_mfp == NULL)		/* no memfile yet */
+	{
+	    oldbuf = FALSE;
+	}
+	else					/* existing memfile */
+	{
+	    oldbuf = TRUE;
+	    set_bufref(&bufref, buf);
+	    (void)buf_check_timestamp(buf, FALSE);
+	    /* Check if autocommands made the buffer invalid or changed the
+	     * current buffer. */
+	    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)
+		goto theend;
+#ifdef FEAT_EVAL
+	    if (aborting())	    /* autocmds may abort script processing */
+		goto theend;
+#endif
+	}
+
+	/* May jump to last used line number for a loaded buffer or when asked
+	 * for explicitly */
+	if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)
+	{
+	    pos = buflist_findfpos(buf);
+	    newlnum = pos->lnum;
+	    solcol = pos->col;
+	}
+
+	/*
+	 * Make the (new) buffer the one used by the current window.
+	 * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.
+	 * If the current buffer was empty and has no file name, curbuf
+	 * is returned by buflist_new(), nothing to do here.
+	 */
+	if (buf != curbuf)
+	{
+	    /*
+	     * Be careful: The autocommands may delete any buffer and change
+	     * the current buffer.
+	     * - If the buffer we are going to edit is deleted, give up.
+	     * - If the current buffer is deleted, prefer to load the new
+	     *   buffer when loading a buffer is required.  This avoids
+	     *   loading another buffer which then must be closed again.
+	     * - If we ended up in the new buffer already, need to skip a few
+	     *	 things, set auto_buf.
+	     */
+	    if (buf->b_fname != NULL)
+		new_name = vim_strsave(buf->b_fname);
+	    set_bufref(&au_new_curbuf, buf);
+	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
+	    if (!bufref_valid(&au_new_curbuf))
+	    {
+		/* new buffer has been deleted */
+		delbuf_msg(new_name);	/* frees new_name */
+		goto theend;
+	    }
+#ifdef FEAT_EVAL
+	    if (aborting())	    /* autocmds may abort script processing */
+	    {
+		vim_free(new_name);
+		goto theend;
+	    }
+#endif
+	    if (buf == curbuf)		/* already in new buffer */
+		auto_buf = TRUE;
+	    else
+	    {
+		win_T	    *the_curwin = curwin;
+
+		/* Set the w_closing flag to avoid that autocommands close the
+		 * window.  And set b_locked for the same reason. */
+		the_curwin->w_closing = TRUE;
+		++buf->b_locked;
+
+		if (curbuf == old_curbuf.br_buf)
+		    buf_copy_options(buf, BCO_ENTER);
+
+		/* Close the link to the current buffer. This will set
+		 * oldwin->w_buffer to NULL. */
+		u_sync(FALSE);
+		close_buffer(oldwin, curbuf,
+			       (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE);
+
+		the_curwin->w_closing = FALSE;
+		--buf->b_locked;
+
+#ifdef FEAT_EVAL
+		/* autocmds may abort script processing */
+		if (aborting() && curwin->w_buffer != NULL)
+		{
+		    vim_free(new_name);
+		    goto theend;
+		}
+#endif
+		/* Be careful again, like above. */
+		if (!bufref_valid(&au_new_curbuf))
+		{
+		    /* new buffer has been deleted */
+		    delbuf_msg(new_name);	/* frees new_name */
+		    goto theend;
+		}
+		if (buf == curbuf)		/* already in new buffer */
+		    auto_buf = TRUE;
+		else
+		{
+#ifdef FEAT_SYN_HL
+		    /*
+		     * <VN> We could instead free the synblock
+		     * and re-attach to buffer, perhaps.
+		     */
+		    if (curwin->w_buffer == NULL
+			    || curwin->w_s == &(curwin->w_buffer->b_s))
+			curwin->w_s = &(buf->b_s);
+#endif
+		    curwin->w_buffer = buf;
+		    curbuf = buf;
+		    ++curbuf->b_nwindows;
+
+		    /* Set 'fileformat', 'binary' and 'fenc' when forced. */
+		    if (!oldbuf && eap != NULL)
+		    {
+			set_file_options(TRUE, eap);
+#ifdef FEAT_MBYTE
+			set_forced_fenc(eap);
+#endif
+		    }
+		}
+
+		/* May get the window options from the last time this buffer
+		 * was in this window (or another window).  If not used
+		 * before, reset the local window options to the global
+		 * values.  Also restores old folding stuff. */
+		get_winopts(curbuf);
+#ifdef FEAT_SPELL
+		did_get_winopts = TRUE;
+#endif
+	    }
+	    vim_free(new_name);
+	    au_new_curbuf.br_buf = NULL;
+	    au_new_curbuf.br_buf_free_count = 0;
+	}
+
+	curwin->w_pcmark.lnum = 1;
+	curwin->w_pcmark.col = 0;
+    }
+    else /* !other_file */
+    {
+	if ((flags & ECMD_ADDBUF) || check_fname() == FAIL)
+	    goto theend;
+
+	oldbuf = (flags & ECMD_OLDBUF);
+    }
+
+    /* Don't redraw until the cursor is in the right line, otherwise
+     * autocommands may cause ml_get errors. */
+    ++RedrawingDisabled;
+    did_inc_redrawing_disabled = TRUE;
+
+    buf = curbuf;
+    if ((flags & ECMD_SET_HELP) || keep_help_flag)
+    {
+	prepare_help_buffer();
+    }
+    else
+    {
+	/* Don't make a buffer listed if it's a help buffer.  Useful when
+	 * using CTRL-O to go back to a help file. */
+	if (!curbuf->b_help)
+	    set_buflisted(TRUE);
+    }
+
+    /* If autocommands change buffers under our fingers, forget about
+     * editing the file. */
+    if (buf != curbuf)
+	goto theend;
+#ifdef FEAT_EVAL
+    if (aborting())	    /* autocmds may abort script processing */
+	goto theend;
+#endif
+
+    /* Since we are starting to edit a file, consider the filetype to be
+     * unset.  Helps for when an autocommand changes files and expects syntax
+     * highlighting to work in the other file. */
+    did_filetype = FALSE;
+
+/*
+ * other_file	oldbuf
+ *  FALSE	FALSE	    re-edit same file, buffer is re-used
+ *  FALSE	TRUE	    re-edit same file, nothing changes
+ *  TRUE	FALSE	    start editing new file, new buffer
+ *  TRUE	TRUE	    start editing in existing buffer (nothing to do)
+ */
+    if (!other_file && !oldbuf)		/* re-use the buffer */
+    {
+	set_last_cursor(curwin);	/* may set b_last_cursor */
+	if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)
+	{
+	    newlnum = curwin->w_cursor.lnum;
+	    solcol = curwin->w_cursor.col;
+	}
+	buf = curbuf;
+	if (buf->b_fname != NULL)
+	    new_name = vim_strsave(buf->b_fname);
+	else
+	    new_name = NULL;
+	set_bufref(&bufref, buf);
+
+	if (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur)
+	{
+	    /* Save all the text, so that the reload can be undone.
+	     * Sync first so that this is a separate undo-able action. */
+	    u_sync(FALSE);
+	    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)
+								     == FAIL)
+	    {
+		vim_free(new_name);
+		goto theend;
+	    }
+	    u_unchanged(curbuf);
+	    buf_freeall(curbuf, BFA_KEEP_UNDO);
+
+	    /* tell readfile() not to clear or reload undo info */
+	    readfile_flags = READ_KEEP_UNDO;
+	}
+	else
+	    buf_freeall(curbuf, 0);   /* free all things for buffer */
+
+	/* If autocommands deleted the buffer we were going to re-edit, give
+	 * up and jump to the end. */
+	if (!bufref_valid(&bufref))
+	{
+	    delbuf_msg(new_name);	/* frees new_name */
+	    goto theend;
+	}
+	vim_free(new_name);
+
+	/* If autocommands change buffers under our fingers, forget about
+	 * re-editing the file.  Should do the buf_clear_file(), but perhaps
+	 * the autocommands changed the buffer... */
+	if (buf != curbuf)
+	    goto theend;
+#ifdef FEAT_EVAL
+	if (aborting())	    /* autocmds may abort script processing */
+	    goto theend;
+#endif
+	buf_clear_file(curbuf);
+	curbuf->b_op_start.lnum = 0;	/* clear '[ and '] marks */
+	curbuf->b_op_end.lnum = 0;
+    }
+
+/*
+ * If we get here we are sure to start editing
+ */
+    /* Assume success now */
+    retval = OK;
+
+    /*
+     * Check if we are editing the w_arg_idx file in the argument list.
+     */
+    check_arg_idx(curwin);
+
+    if (!auto_buf)
+    {
+	/*
+	 * Set cursor and init window before reading the file and executing
+	 * autocommands.  This allows for the autocommands to position the
+	 * cursor.
+	 */
+	curwin_init();
+
+#ifdef FEAT_FOLDING
+	/* It's possible that all lines in the buffer changed.  Need to update
+	 * automatic folding for all windows where it's used. */
+	{
+	    win_T	    *win;
+	    tabpage_T	    *tp;
+
+	    FOR_ALL_TAB_WINDOWS(tp, win)
+		if (win->w_buffer == curbuf)
+		    foldUpdateAll(win);
+	}
+#endif
+
+	/* Change directories when the 'acd' option is set. */
+	DO_AUTOCHDIR;
+
+	/*
+	 * Careful: open_buffer() and apply_autocmds() may change the current
+	 * buffer and window.
+	 */
+	orig_pos = curwin->w_cursor;
+	topline = curwin->w_topline;
+	if (!oldbuf)			    /* need to read the file */
+	{
+#if defined(HAS_SWAP_EXISTS_ACTION)
+	    swap_exists_action = SEA_DIALOG;
+#endif
+	    curbuf->b_flags |= BF_CHECK_RO; /* set/reset 'ro' flag */
+
+	    /*
+	     * Open the buffer and read the file.
+	     */
+#if defined(FEAT_EVAL)
+	    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))
+		retval = FAIL;
+#else
+	    (void)open_buffer(FALSE, eap, readfile_flags);
+#endif
+
+#if defined(HAS_SWAP_EXISTS_ACTION)
+	    if (swap_exists_action == SEA_QUIT)
+		retval = FAIL;
+	    handle_swap_exists(&old_curbuf);
+#endif
+	}
+	else
+	{
+	    /* Read the modelines, but only to set window-local options.  Any
+	     * buffer-local options have already been set and may have been
+	     * changed by the user. */
+	    do_modelines(OPT_WINONLY);
+
+	    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,
+								    &retval);
+	    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,
+								    &retval);
+	}
+	check_arg_idx(curwin);
+
+	/* If autocommands change the cursor position or topline, we should
+	 * keep it.  Also when it moves within a line. But not when it moves
+	 * to the first non-blank. */
+	if (!EQUAL_POS(curwin->w_cursor, orig_pos))
+	{
+	    char_u *text = ml_get_curline();
+
+	    if (curwin->w_cursor.lnum != orig_pos.lnum
+		    || curwin->w_cursor.col != (int)(skipwhite(text) - text))
+	    {
+		newlnum = curwin->w_cursor.lnum;
+		newcol = curwin->w_cursor.col;
+	    }
+	}
+	if (curwin->w_topline == topline)
+	    topline = 0;
+
+	/* Even when cursor didn't move we need to recompute topline. */
+	changed_line_abv_curs();
+
+#ifdef FEAT_TITLE
+	maketitle();
+#endif
+    }
+
+#ifdef FEAT_DIFF
+    /* Tell the diff stuff that this buffer is new and/or needs updating.
+     * Also needed when re-editing the same buffer, because unloading will
+     * have removed it as a diff buffer. */
+    if (curwin->w_p_diff)
+    {
+	diff_buf_add(curbuf);
+	diff_invalidate(curbuf);
+    }
+#endif
+
+#ifdef FEAT_SPELL
+    /* If the window options were changed may need to set the spell language.
+     * Can only do this after the buffer has been properly setup. */
+    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)
+	(void)did_set_spelllang(curwin);
+#endif
+
+    if (command == NULL)
+    {
+	if (newcol >= 0)	/* position set by autocommands */
+	{
+	    curwin->w_cursor.lnum = newlnum;
+	    curwin->w_cursor.col = newcol;
+	    check_cursor();
+	}
+	else if (newlnum > 0)	/* line number from caller or old position */
+	{
+	    curwin->w_cursor.lnum = newlnum;
+	    check_cursor_lnum();
+	    if (solcol >= 0 && !p_sol)
+	    {
+		/* 'sol' is off: Use last known column. */
+		curwin->w_cursor.col = solcol;
+		check_cursor_col();
+#ifdef FEAT_VIRTUALEDIT
+		curwin->w_cursor.coladd = 0;
+#endif
+		curwin->w_set_curswant = TRUE;
+	    }
+	    else
+		beginline(BL_SOL | BL_FIX);
+	}
+	else			/* no line number, go to last line in Ex mode */
+	{
+	    if (exmode_active)
+		curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
+	    beginline(BL_WHITE | BL_FIX);
+	}
+    }
+
+    /* Check if cursors in other windows on the same buffer are still valid */
+    check_lnums(FALSE);
+
+    /*
+     * Did not read the file, need to show some info about the file.
+     * Do this after setting the cursor.
+     */
+    if (oldbuf && !auto_buf)
+    {
+	int	msg_scroll_save = msg_scroll;
+
+	/* Obey the 'O' flag in 'cpoptions': overwrite any previous file
+	 * message. */
+	if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)
+	    msg_scroll = FALSE;
+	if (!msg_scroll)	/* wait a bit when overwriting an error msg */
+	    check_for_delay(FALSE);
+	msg_start();
+	msg_scroll = msg_scroll_save;
+	msg_scrolled_ign = TRUE;
+
+	if (!shortmess(SHM_FILEINFO))
+	    fileinfo(FALSE, TRUE, FALSE);
+
+	msg_scrolled_ign = FALSE;
+    }
+
+#ifdef FEAT_VIMINFO
+    curbuf->b_last_used = vim_time();
+#endif
+
+    if (command != NULL)
+	do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);
+
+#ifdef FEAT_KEYMAP
+    if (curbuf->b_kmap_state & KEYMAP_INIT)
+	(void)keymap_init();
+#endif
+
+    --RedrawingDisabled;
+    did_inc_redrawing_disabled = FALSE;
+    if (!skip_redraw)
+    {
+	n = p_so;
+	if (topline == 0 && command == NULL)
+	    p_so = 999;			/* force cursor halfway the window */
+	update_topline();
+	curwin->w_scbind_pos = curwin->w_topline;
+	p_so = n;
+	redraw_curbuf_later(NOT_VALID);	/* redraw this buffer later */
+    }
+
+    if (p_im)
+	need_start_insertmode = TRUE;
+
+#ifdef FEAT_AUTOCHDIR
+    /* Change directories when the 'acd' option is set and we aren't already in
+     * that directory (should already be done above). Expect getcwd() to be
+     * faster than calling shorten_fnames() unnecessarily. */
+    if (p_acd && curbuf->b_ffname != NULL)
+    {
+	char_u	curdir[MAXPATHL];
+	char_u	filedir[MAXPATHL];
+
+	vim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);
+	*gettail_sep(filedir) = NUL;
+	if (mch_dirname(curdir, MAXPATHL) != FAIL
+		&& vim_fnamecmp(curdir, filedir) != 0)
+	    do_autochdir();
+    }
+#endif
+
+#if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG)
+    if (curbuf->b_ffname != NULL)
+    {
+# ifdef FEAT_SUN_WORKSHOP
+	if (gui.in_use && usingSunWorkShop)
+	    workshop_file_opened((char *)curbuf->b_ffname, curbuf->b_p_ro);
+# endif
+# ifdef FEAT_NETBEANS_INTG
+	if ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)
+	    netbeans_file_opened(curbuf);
+# endif
+    }
+#endif
+
+theend:
+    if (did_inc_redrawing_disabled)
+	--RedrawingDisabled;
+#if defined(FEAT_EVAL)
+    if (did_set_swapcommand)
+	set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);
+#endif
+#ifdef FEAT_BROWSE
+    vim_free(browse_file);
+#endif
+    vim_free(free_fname);
+    return retval;
+}
+
+    static void
+delbuf_msg(char_u *name)
+{
+    EMSG2(_("E143: Autocommands unexpectedly deleted new buffer %s"),
+	    name == NULL ? (char_u *)"" : name);
+    vim_free(name);
+    au_new_curbuf.br_buf = NULL;
+    au_new_curbuf.br_buf_free_count = 0;
+}
+
+static int append_indent = 0;	    /* autoindent for first line */
+
+/*
+ * ":insert" and ":append", also used by ":change"
+ */
+    void
+ex_append(exarg_T *eap)
+{
+    char_u	*theline;
+    int		did_undo = FALSE;
+    linenr_T	lnum = eap->line2;
+    int		indent = 0;
+    char_u	*p;
+    int		vcol;
+    int		empty = (curbuf->b_ml.ml_flags & ML_EMPTY);
+
+    /* the ! flag toggles autoindent */
+    if (eap->forceit)
+	curbuf->b_p_ai = !curbuf->b_p_ai;
+
+    /* First autoindent comes from the line we start on */
+    if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)
+	append_indent = get_indent_lnum(lnum);
+
+    if (eap->cmdidx != CMD_append)
+	--lnum;
+
+    /* when the buffer is empty need to delete the dummy line */
+    if (empty && lnum == 1)
+	lnum = 0;
+
+    State = INSERT;		    /* behave like in Insert mode */
+    if (curbuf->b_p_iminsert == B_IMODE_LMAP)
+	State |= LANGMAP;
+
+    for (;;)
+    {
+	msg_scroll = TRUE;
+	need_wait_return = FALSE;
+	if (curbuf->b_p_ai)
+	{
+	    if (append_indent >= 0)
+	    {
+		indent = append_indent;
+		append_indent = -1;
+	    }
+	    else if (lnum > 0)
+		indent = get_indent_lnum(lnum);
+	}
+	ex_keep_indent = FALSE;
+	if (eap->getline == NULL)
+	{
+	    /* No getline() function, use the lines that follow. This ends
+	     * when there is no more. */
+	    if (eap->nextcmd == NULL || *eap->nextcmd == NUL)
+		break;
+	    p = vim_strchr(eap->nextcmd, NL);
+	    if (p == NULL)
+		p = eap->nextcmd + STRLEN(eap->nextcmd);
+	    theline = vim_strnsave(eap->nextcmd, (int)(p - eap->nextcmd));
+	    if (*p != NUL)
+		++p;
+	    eap->nextcmd = p;
+	}
+	else
+	{
+	    int save_State = State;
+
+	    /* Set State to avoid the cursor shape to be set to INSERT mode
+	     * when getline() returns. */
+	    State = CMDLINE;
+	    theline = eap->getline(
+#ifdef FEAT_EVAL
+		    eap->cstack->cs_looplevel > 0 ? -1 :
+#endif
+		    NUL, eap->cookie, indent);
+	    State = save_State;
+	}
+	lines_left = Rows - 1;
+	if (theline == NULL)
+	    break;
+
+	/* Using ^ CTRL-D in getexmodeline() makes us repeat the indent. */
+	if (ex_keep_indent)
+	    append_indent = indent;
+
+	/* Look for the "." after automatic indent. */
+	vcol = 0;
+	for (p = theline; indent > vcol; ++p)
+	{
+	    if (*p == ' ')
+		++vcol;
+	    else if (*p == TAB)
+		vcol += 8 - vcol % 8;
+	    else
+		break;
+	}
+	if ((p[0] == '.' && p[1] == NUL)
+		|| (!did_undo && u_save(lnum, lnum + 1 + (empty ? 1 : 0))
+								     == FAIL))
+	{
+	    vim_free(theline);
+	    break;
+	}
+
+	/* don't use autoindent if nothing was typed. */
+	if (p[0] == NUL)
+	    theline[0] = NUL;
+
+	did_undo = TRUE;
+	ml_append(lnum, theline, (colnr_T)0, FALSE);
+	appended_lines_mark(lnum + (empty ? 1 : 0), 1L);
+
+	vim_free(theline);
+	++lnum;
+
+	if (empty)
+	{
+	    ml_delete(2L, FALSE);
+	    empty = FALSE;
+	}
+    }
+    State = NORMAL;
+
+    if (eap->forceit)
+	curbuf->b_p_ai = !curbuf->b_p_ai;
+
+    /* "start" is set to eap->line2+1 unless that position is invalid (when
+     * eap->line2 pointed to the end of the buffer and nothing was appended)
+     * "end" is set to lnum when something has been appended, otherwise
+     * it is the same than "start"  -- Acevedo */
+    curbuf->b_op_start.lnum = (eap->line2 < curbuf->b_ml.ml_line_count) ?
+	eap->line2 + 1 : curbuf->b_ml.ml_line_count;
+    if (eap->cmdidx != CMD_append)
+	--curbuf->b_op_start.lnum;
+    curbuf->b_op_end.lnum = (eap->line2 < lnum)
+					     ? lnum : curbuf->b_op_start.lnum;
+    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
+    curwin->w_cursor.lnum = lnum;
+    check_cursor_lnum();
+    beginline(BL_SOL | BL_FIX);
+
+    need_wait_return = FALSE;	/* don't use wait_return() now */
+    ex_no_reprint = TRUE;
+}
+
+/*
+ * ":change"
+ */
+    void
+ex_change(exarg_T *eap)
+{
+    linenr_T	lnum;
+
+    if (eap->line2 >= eap->line1
+	    && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)
+	return;
+
+    /* the ! flag toggles autoindent */
+    if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)
+	append_indent = get_indent_lnum(eap->line1);
+
+    for (lnum = eap->line2; lnum >= eap->line1; --lnum)
+    {
+	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
+	    break;
+	ml_delete(eap->line1, FALSE);
+    }
+
+    /* make sure the cursor is not beyond the end of the file now */
+    check_cursor_lnum();
+    deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));
+
+    /* ":append" on the line above the deleted lines. */
+    eap->line2 = eap->line1;
+    ex_append(eap);
+}
+
+    void
+ex_z(exarg_T *eap)
+{
+    char_u	*x;
+    long	bigness;
+    char_u	*kind;
+    int		minus = 0;
+    linenr_T	start, end, curs, i;
+    int		j;
+    linenr_T	lnum = eap->line2;
+
+    /* Vi compatible: ":z!" uses display height, without a count uses
+     * 'scroll' */
+    if (eap->forceit)
+	bigness = curwin->w_height;
+    else if (!ONE_WINDOW)
+	bigness = curwin->w_height - 3;
+    else
+	bigness = curwin->w_p_scr * 2;
+    if (bigness < 1)
+	bigness = 1;
+
+    x = eap->arg;
+    kind = x;
+    if (*kind == '-' || *kind == '+' || *kind == '='
+					      || *kind == '^' || *kind == '.')
+	++x;
+    while (*x == '-' || *x == '+')
+	++x;
+
+    if (*x != 0)
+    {
+	if (!VIM_ISDIGIT(*x))
+	{
+	    EMSG(_("E144: non-numeric argument to :z"));
+	    return;
+	}
+	else
+	{
+	    bigness = atol((char *)x);
+
+	    /* bigness could be < 0 if atol(x) overflows. */
+	    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0)
+		bigness = 2 * curbuf->b_ml.ml_line_count;
+
+	    p_window = bigness;
+	    if (*kind == '=')
+		bigness += 2;
+	}
+    }
+
+    /* the number of '-' and '+' multiplies the distance */
+    if (*kind == '-' || *kind == '+')
+	for (x = kind + 1; *x == *kind; ++x)
+	    ;
+
+    switch (*kind)
+    {
+	case '-':
+	    start = lnum - bigness * (linenr_T)(x - kind) + 1;
+	    end = start + bigness - 1;
+	    curs = end;
+	    break;
+
+	case '=':
+	    start = lnum - (bigness + 1) / 2 + 1;
+	    end = lnum + (bigness + 1) / 2 - 1;
+	    curs = lnum;
+	    minus = 1;
+	    break;
+
+	case '^':
+	    start = lnum - bigness * 2;
+	    end = lnum - bigness;
+	    curs = lnum - bigness;
+	    break;
+
+	case '.':
+	    start = lnum - (bigness + 1) / 2 + 1;
+	    end = lnum + (bigness + 1) / 2 - 1;
+	    curs = end;
+	    break;
+
+	default:  /* '+' */
+	    start = lnum;
+	    if (*kind == '+')
+		start += bigness * (linenr_T)(x - kind - 1) + 1;
+	    else if (eap->addr_count == 0)
+		++start;
+	    end = start + bigness - 1;
+	    curs = end;
+	    break;
+    }
+
+    if (start < 1)
+	start = 1;
+
+    if (end > curbuf->b_ml.ml_line_count)
+	end = curbuf->b_ml.ml_line_count;
+
+    if (curs > curbuf->b_ml.ml_line_count)
+	curs = curbuf->b_ml.ml_line_count;
+    else if (curs < 1)
+	curs = 1;
+
+    for (i = start; i <= end; i++)
+    {
+	if (minus && i == lnum)
+	{
+	    msg_putchar('\n');
+
+	    for (j = 1; j < Columns; j++)
+		msg_putchar('-');
+	}
+
+	print_line(i, eap->flags & EXFLAG_NR, eap->flags & EXFLAG_LIST);
+
+	if (minus && i == lnum)
+	{
+	    msg_putchar('\n');
+
+	    for (j = 1; j < Columns; j++)
+		msg_putchar('-');
+	}
+    }
+
+    if (curwin->w_cursor.lnum != curs)
+    {
+	curwin->w_cursor.lnum = curs;
+	curwin->w_cursor.col = 0;
+    }
+    ex_no_reprint = TRUE;
+}
+
+/*
+ * Check if the restricted flag is set.
+ * If so, give an error message and return TRUE.
+ * Otherwise, return FALSE.
+ */
+    int
+check_restricted(void)
+{
+    if (restricted)
+    {
+	EMSG(_("E145: Shell commands not allowed in rvim"));
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Check if the secure flag is set (.exrc or .vimrc in current directory).
+ * If so, give an error message and return TRUE.
+ * Otherwise, return FALSE.
+ */
+    int
+check_secure(void)
+{
+    if (secure)
+    {
+	secure = 2;
+	EMSG(_(e_curdir));
+	return TRUE;
+    }
+#ifdef HAVE_SANDBOX
+    /*
+     * In the sandbox more things are not allowed, including the things
+     * disallowed in secure mode.
+     */
+    if (sandbox != 0)
+    {
+	EMSG(_(e_sandbox));
+	return TRUE;
+    }
+#endif
+    return FALSE;
+}
+
+static char_u	*old_sub = NULL;	/* previous substitute pattern */
+static int	global_need_beginline;	/* call beginline() after ":g" */
+
+/*
+ * Flags that are kept between calls to :substitute.
+ */
+typedef struct {
+    int	do_all;		/* do multiple substitutions per line */
+    int	do_ask;		/* ask for confirmation */
+    int	do_count;	/* count only */
+    int	do_error;	/* if false, ignore errors */
+    int	do_print;	/* print last line with subs. */
+    int	do_list;	/* list last line with subs. */
+    int	do_number;	/* list last line with line nr*/
+    int	do_ic;		/* ignore case flag */
+} subflags_T;
+
+/* do_sub()
+ *
+ * Perform a substitution from line eap->line1 to line eap->line2 using the
+ * command pointed to by eap->arg which should be of the form:
+ *
+ * /pattern/substitution/{flags}
+ *
+ * The usual escapes are supported as described in the regexp docs.
+ */
+    void
+do_sub(exarg_T *eap)
+{
+    linenr_T	lnum;
+    long	i = 0;
+    regmmatch_T regmatch;
+    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,
+							      FALSE, FALSE, 0};
+#ifdef FEAT_EVAL
+    subflags_T	subflags_save;
+#endif
+    int		save_do_all;		/* remember user specified 'g' flag */
+    int		save_do_ask;		/* remember user specified 'c' flag */
+    char_u	*pat = NULL, *sub = NULL;	/* init for GCC */
+    int		delimiter;
+    int		sublen;
+    int		got_quit = FALSE;
+    int		got_match = FALSE;
+    int		temp;
+    int		which_pat;
+    char_u	*cmd;
+    int		save_State;
+    linenr_T	first_line = 0;		/* first changed line */
+    linenr_T	last_line= 0;		/* below last changed line AFTER the
+					 * change */
+    linenr_T	old_line_count = curbuf->b_ml.ml_line_count;
+    linenr_T	line2;
+    long	nmatch;			/* number of lines in match */
+    char_u	*sub_firstline;		/* allocated copy of first sub line */
+    int		endcolumn = FALSE;	/* cursor in last column when done */
+    pos_T	old_cursor = curwin->w_cursor;
+    int		start_nsubs;
+#ifdef FEAT_EVAL
+    int		save_ma = 0;
+#endif
+
+    cmd = eap->arg;
+    if (!global_busy)
+    {
+	sub_nsubs = 0;
+	sub_nlines = 0;
+    }
+    start_nsubs = sub_nsubs;
+
+    if (eap->cmdidx == CMD_tilde)
+	which_pat = RE_LAST;	/* use last used regexp */
+    else
+	which_pat = RE_SUBST;	/* use last substitute regexp */
+
+				/* new pattern and substitution */
+    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)
+		&& vim_strchr((char_u *)"0123456789cegriIp|\"", *cmd) == NULL)
+    {
+				/* don't accept alphanumeric for separator */
+	if (isalpha(*cmd))
+	{
+	    EMSG(_("E146: Regular expressions can't be delimited by letters"));
+	    return;
+	}
+	/*
+	 * undocumented vi feature:
+	 *  "\/sub/" and "\?sub?" use last used search pattern (almost like
+	 *  //sub/r).  "\&sub&" use last substitute pattern (like //sub/).
+	 */
+	if (*cmd == '\\')
+	{
+	    ++cmd;
+	    if (vim_strchr((char_u *)"/?&", *cmd) == NULL)
+	    {
+		EMSG(_(e_backslash));
+		return;
+	    }
+	    if (*cmd != '&')
+		which_pat = RE_SEARCH;	    /* use last '/' pattern */
+	    pat = (char_u *)"";		    /* empty search pattern */
+	    delimiter = *cmd++;		    /* remember delimiter character */
+	}
+	else		/* find the end of the regexp */
+	{
+#ifdef FEAT_FKMAP	/* reverse the flow of the Farsi characters */
+	    if (p_altkeymap && curwin->w_p_rl)
+		lrF_sub(cmd);
+#endif
+	    which_pat = RE_LAST;	    /* use last used regexp */
+	    delimiter = *cmd++;		    /* remember delimiter character */
+	    pat = cmd;			    /* remember start of search pat */
+	    cmd = skip_regexp(cmd, delimiter, p_magic, &eap->arg);
+	    if (cmd[0] == delimiter)	    /* end delimiter found */
+		*cmd++ = NUL;		    /* replace it with a NUL */
+	}
+
+	/*
+	 * Small incompatibility: vi sees '\n' as end of the command, but in
+	 * Vim we want to use '\n' to find/substitute a NUL.
+	 */
+	sub = cmd;	    /* remember the start of the substitution */
+
+	while (cmd[0])
+	{
+	    if (cmd[0] == delimiter)		/* end delimiter found */
+	    {
+		*cmd++ = NUL;			/* replace it with a NUL */
+		break;
+	    }
+	    if (cmd[0] == '\\' && cmd[1] != 0)	/* skip escaped characters */
+		++cmd;
+	    MB_PTR_ADV(cmd);
+	}
+
+	if (!eap->skip)
+	{
+	    /* In POSIX vi ":s/pat/%/" uses the previous subst. string. */
+	    if (STRCMP(sub, "%") == 0
+				 && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)
+	    {
+		if (old_sub == NULL)	/* there is no previous command */
+		{
+		    EMSG(_(e_nopresub));
+		    return;
+		}
+		sub = old_sub;
+	    }
+	    else
+	    {
+		vim_free(old_sub);
+		old_sub = vim_strsave(sub);
+	    }
+	}
+    }
+    else if (!eap->skip)	/* use previous pattern and substitution */
+    {
+	if (old_sub == NULL)	/* there is no previous command */
+	{
+	    EMSG(_(e_nopresub));
+	    return;
+	}
+	pat = NULL;		/* search_regcomp() will use previous pattern */
+	sub = old_sub;
+
+	/* Vi compatibility quirk: repeating with ":s" keeps the cursor in the
+	 * last column after using "$". */
+	endcolumn = (curwin->w_curswant == MAXCOL);
+    }
+
+    /* Recognize ":%s/\n//" and turn it into a join command, which is much
+     * more efficient.
+     * TODO: find a generic solution to make line-joining operations more
+     * efficient, avoid allocating a string that grows in size.
+     */
+    if (pat != NULL && STRCMP(pat, "\\n") == 0
+	    && *sub == NUL
+	    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'
+					     || *cmd == 'p' || *cmd == '#'))))
+    {
+	linenr_T    joined_lines_count;
+
+	curwin->w_cursor.lnum = eap->line1;
+	if (*cmd == 'l')
+	    eap->flags = EXFLAG_LIST;
+	else if (*cmd == '#')
+	    eap->flags = EXFLAG_NR;
+	else if (*cmd == 'p')
+	    eap->flags = EXFLAG_PRINT;
+
+	/* The number of lines joined is the number of lines in the range plus
+	 * one.  One less when the last line is included. */
+	joined_lines_count = eap->line2 - eap->line1 + 1;
+	if (eap->line2 < curbuf->b_ml.ml_line_count)
+	    ++joined_lines_count;
+	if (joined_lines_count > 1)
+	{
+	    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);
+	    sub_nsubs = joined_lines_count - 1;
+	    sub_nlines = 1;
+	    (void)do_sub_msg(FALSE);
+	    ex_may_print(eap);
+	}
+
+	if (!cmdmod.keeppatterns)
+	    save_re_pat(RE_SUBST, pat, p_magic);
+#ifdef FEAT_CMDHIST
+	/* put pattern in history */
+	add_to_history(HIST_SEARCH, pat, TRUE, NUL);
+#endif
+
+	return;
+    }
+
+    /*
+     * Find trailing options.  When '&' is used, keep old options.
+     */
+    if (*cmd == '&')
+	++cmd;
+    else
+    {
+	if (!p_ed)
+	{
+	    if (p_gd)		/* default is global on */
+		subflags.do_all = TRUE;
+	    else
+		subflags.do_all = FALSE;
+	    subflags.do_ask = FALSE;
+	}
+	subflags.do_error = TRUE;
+	subflags.do_print = FALSE;
+	subflags.do_count = FALSE;
+	subflags.do_number = FALSE;
+	subflags.do_ic = 0;
+    }
+    while (*cmd)
+    {
+	/*
+	 * Note that 'g' and 'c' are always inverted, also when p_ed is off.
+	 * 'r' is never inverted.
+	 */
+	if (*cmd == 'g')
+	    subflags.do_all = !subflags.do_all;
+	else if (*cmd == 'c')
+	    subflags.do_ask = !subflags.do_ask;
+	else if (*cmd == 'n')
+	    subflags.do_count = TRUE;
+	else if (*cmd == 'e')
+	    subflags.do_error = !subflags.do_error;
+	else if (*cmd == 'r')	    /* use last used regexp */
+	    which_pat = RE_LAST;
+	else if (*cmd == 'p')
+	    subflags.do_print = TRUE;
+	else if (*cmd == '#')
+	{
+	    subflags.do_print = TRUE;
+	    subflags.do_number = TRUE;
+	}
+	else if (*cmd == 'l')
+	{
+	    subflags.do_print = TRUE;
+	    subflags.do_list = TRUE;
+	}
+	else if (*cmd == 'i')	    /* ignore case */
+	    subflags.do_ic = 'i';
+	else if (*cmd == 'I')	    /* don't ignore case */
+	    subflags.do_ic = 'I';
+	else
+	    break;
+	++cmd;
+    }
+    if (subflags.do_count)
+	subflags.do_ask = FALSE;
+
+    save_do_all = subflags.do_all;
+    save_do_ask = subflags.do_ask;
+
+    /*
+     * check for a trailing count
+     */
+    cmd = skipwhite(cmd);
+    if (VIM_ISDIGIT(*cmd))
+    {
+	i = getdigits(&cmd);
+	if (i <= 0 && !eap->skip && subflags.do_error)
+	{
+	    EMSG(_(e_zerocount));
+	    return;
+	}
+	eap->line1 = eap->line2;
+	eap->line2 += i - 1;
+	if (eap->line2 > curbuf->b_ml.ml_line_count)
+	    eap->line2 = curbuf->b_ml.ml_line_count;
+    }
+
+    /*
+     * check for trailing command or garbage
+     */
+    cmd = skipwhite(cmd);
+    if (*cmd && *cmd != '"')	    /* if not end-of-line or comment */
+    {
+	eap->nextcmd = check_nextcmd(cmd);
+	if (eap->nextcmd == NULL)
+	{
+	    EMSG(_(e_trailing));
+	    return;
+	}
+    }
+
+    if (eap->skip)	    /* not executing commands, only parsing */
+	return;
+
+    if (!subflags.do_count && !curbuf->b_p_ma)
+    {
+	/* Substitution is not allowed in non-'modifiable' buffer */
+	EMSG(_(e_modifiable));
+	return;
+    }
+
+    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)
+    {
+	if (subflags.do_error)
+	    EMSG(_(e_invcmd));
+	return;
+    }
+
+    /* the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase' */
+    if (subflags.do_ic == 'i')
+	regmatch.rmm_ic = TRUE;
+    else if (subflags.do_ic == 'I')
+	regmatch.rmm_ic = FALSE;
+
+    sub_firstline = NULL;
+
+    /*
+     * ~ in the substitute pattern is replaced with the old pattern.
+     * We do it here once to avoid it to be replaced over and over again.
+     * But don't do it when it starts with "\=", then it's an expression.
+     */
+    if (!(sub[0] == '\\' && sub[1] == '='))
+	sub = regtilde(sub, p_magic);
+
+    /*
+     * Check for a match on each line.
+     */
+    line2 = eap->line2;
+    for (lnum = eap->line1; lnum <= line2 && !(got_quit
+#if defined(FEAT_EVAL)
+		|| aborting()
+#endif
+		); ++lnum)
+    {
+	nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,
+						       (colnr_T)0, NULL, NULL);
+	if (nmatch)
+	{
+	    colnr_T	copycol;
+	    colnr_T	matchcol;
+	    colnr_T	prev_matchcol = MAXCOL;
+	    char_u	*new_end, *new_start = NULL;
+	    unsigned	new_start_len = 0;
+	    char_u	*p1;
+	    int		did_sub = FALSE;
+	    int		lastone;
+	    int		len, copy_len, needed_len;
+	    long	nmatch_tl = 0;	/* nr of lines matched below lnum */
+	    int		do_again;	/* do it again after joining lines */
+	    int		skip_match = FALSE;
+	    linenr_T	sub_firstlnum;	/* nr of first sub line */
+
+	    /*
+	     * The new text is build up step by step, to avoid too much
+	     * copying.  There are these pieces:
+	     * sub_firstline	The old text, unmodified.
+	     * copycol		Column in the old text where we started
+	     *			looking for a match; from here old text still
+	     *			needs to be copied to the new text.
+	     * matchcol		Column number of the old text where to look
+	     *			for the next match.  It's just after the
+	     *			previous match or one further.
+	     * prev_matchcol	Column just after the previous match (if any).
+	     *			Mostly equal to matchcol, except for the first
+	     *			match and after skipping an empty match.
+	     * regmatch.*pos	Where the pattern matched in the old text.
+	     * new_start	The new text, all that has been produced so
+	     *			far.
+	     * new_end		The new text, where to append new text.
+	     *
+	     * lnum		The line number where we found the start of
+	     *			the match.  Can be below the line we searched
+	     *			when there is a \n before a \zs in the
+	     *			pattern.
+	     * sub_firstlnum	The line number in the buffer where to look
+	     *			for a match.  Can be different from "lnum"
+	     *			when the pattern or substitute string contains
+	     *			line breaks.
+	     *
+	     * Special situations:
+	     * - When the substitute string contains a line break, the part up
+	     *   to the line break is inserted in the text, but the copy of
+	     *   the original line is kept.  "sub_firstlnum" is adjusted for
+	     *   the inserted lines.
+	     * - When the matched pattern contains a line break, the old line
+	     *   is taken from the line at the end of the pattern.  The lines
+	     *   in the match are deleted later, "sub_firstlnum" is adjusted
+	     *   accordingly.
+	     *
+	     * The new text is built up in new_start[].  It has some extra
+	     * room to avoid using alloc()/free() too often.  new_start_len is
+	     * the length of the allocated memory at new_start.
+	     *
+	     * Make a copy of the old line, so it won't be taken away when
+	     * updating the screen or handling a multi-line match.  The "old_"
+	     * pointers point into this copy.
+	     */
+	    sub_firstlnum = lnum;
+	    copycol = 0;
+	    matchcol = 0;
+
+	    /* At first match, remember current cursor position. */
+	    if (!got_match)
+	    {
+		setpcmark();
+		got_match = TRUE;
+	    }
+
+	    /*
+	     * Loop until nothing more to replace in this line.
+	     * 1. Handle match with empty string.
+	     * 2. If do_ask is set, ask for confirmation.
+	     * 3. substitute the string.
+	     * 4. if do_all is set, find next match
+	     * 5. break if there isn't another match in this line
+	     */
+	    for (;;)
+	    {
+		/* Advance "lnum" to the line where the match starts.  The
+		 * match does not start in the first line when there is a line
+		 * break before \zs. */
+		if (regmatch.startpos[0].lnum > 0)
+		{
+		    lnum += regmatch.startpos[0].lnum;
+		    sub_firstlnum += regmatch.startpos[0].lnum;
+		    nmatch -= regmatch.startpos[0].lnum;
+		    VIM_CLEAR(sub_firstline);
+		}
+
+		if (sub_firstline == NULL)
+		{
+		    sub_firstline = vim_strsave(ml_get(sub_firstlnum));
+		    if (sub_firstline == NULL)
+		    {
+			vim_free(new_start);
+			goto outofmem;
+		    }
+		}
+
+		/* Save the line number of the last change for the final
+		 * cursor position (just like Vi). */
+		curwin->w_cursor.lnum = lnum;
+		do_again = FALSE;
+
+		/*
+		 * 1. Match empty string does not count, except for first
+		 * match.  This reproduces the strange vi behaviour.
+		 * This also catches endless loops.
+		 */
+		if (matchcol == prev_matchcol
+			&& regmatch.endpos[0].lnum == 0
+			&& matchcol == regmatch.endpos[0].col)
+		{
+		    if (sub_firstline[matchcol] == NUL)
+			/* We already were at the end of the line.  Don't look
+			 * for a match in this line again. */
+			skip_match = TRUE;
+		    else
+		    {
+			 /* search for a match at next column */
+#ifdef FEAT_MBYTE
+			if (has_mbyte)
+			    matchcol += mb_ptr2len(sub_firstline + matchcol);
+			else
+#endif
+			    ++matchcol;
+		    }
+		    goto skip;
+		}
+
+		/* Normally we continue searching for a match just after the
+		 * previous match. */
+		matchcol = regmatch.endpos[0].col;
+		prev_matchcol = matchcol;
+
+		/*
+		 * 2. If do_count is set only increase the counter.
+		 *    If do_ask is set, ask for confirmation.
+		 */
+		if (subflags.do_count)
+		{
+		    /* For a multi-line match, put matchcol at the NUL at
+		     * the end of the line and set nmatch to one, so that
+		     * we continue looking for a match on the next line.
+		     * Avoids that ":s/\nB\@=//gc" get stuck. */
+		    if (nmatch > 1)
+		    {
+			matchcol = (colnr_T)STRLEN(sub_firstline);
+			nmatch = 1;
+			skip_match = TRUE;
+		    }
+		    sub_nsubs++;
+		    did_sub = TRUE;
+#ifdef FEAT_EVAL
+		    /* Skip the substitution, unless an expression is used,
+		     * then it is evaluated in the sandbox. */
+		    if (!(sub[0] == '\\' && sub[1] == '='))
+#endif
+			goto skip;
+		}
+
+		if (subflags.do_ask)
+		{
+		    int typed = 0;
+
+		    /* change State to CONFIRM, so that the mouse works
+		     * properly */
+		    save_State = State;
+		    State = CONFIRM;
+#ifdef FEAT_MOUSE
+		    setmouse();		/* disable mouse in xterm */
+#endif
+		    curwin->w_cursor.col = regmatch.startpos[0].col;
+		    if (curwin->w_p_crb)
+			do_check_cursorbind();
+
+		    /* When 'cpoptions' contains "u" don't sync undo when
+		     * asking for confirmation. */
+		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
+			++no_u_sync;
+
+		    /*
+		     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.
+		     */
+		    while (subflags.do_ask)
+		    {
+			if (exmode_active)
+			{
+			    char_u	*resp;
+			    colnr_T	sc, ec;
+
+			    print_line_no_prefix(lnum,
+					 subflags.do_number, subflags.do_list);
+
+			    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);
+			    curwin->w_cursor.col = regmatch.endpos[0].col - 1;
+			    if (curwin->w_cursor.col < 0)
+				curwin->w_cursor.col = 0;
+			    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);
+			    if (subflags.do_number || curwin->w_p_nu)
+			    {
+				int numw = number_width(curwin) + 1;
+				sc += numw;
+				ec += numw;
+			    }
+			    msg_start();
+			    for (i = 0; i < (long)sc; ++i)
+				msg_putchar(' ');
+			    for ( ; i <= (long)ec; ++i)
+				msg_putchar('^');
+
+			    resp = getexmodeline('?', NULL, 0);
+			    if (resp != NULL)
+			    {
+				typed = *resp;
+				vim_free(resp);
+			    }
+			}
+			else
+			{
+			    char_u *orig_line = NULL;
+			    int    len_change = 0;
+#ifdef FEAT_FOLDING
+			    int save_p_fen = curwin->w_p_fen;
+
+			    curwin->w_p_fen = FALSE;
+#endif
+			    /* Invert the matched string.
+			     * Remove the inversion afterwards. */
+			    temp = RedrawingDisabled;
+			    RedrawingDisabled = 0;
+
+			    if (new_start != NULL)
+			    {
+				/* There already was a substitution, we would
+				 * like to show this to the user.  We cannot
+				 * really update the line, it would change
+				 * what matches.  Temporarily replace the line
+				 * and change it back afterwards. */
+				orig_line = vim_strsave(ml_get(lnum));
+				if (orig_line != NULL)
+				{
+				    char_u *new_line = concat_str(new_start,
+						     sub_firstline + copycol);
+
+				    if (new_line == NULL)
+					VIM_CLEAR(orig_line);
+				    else
+				    {
+					/* Position the cursor relative to the
+					 * end of the line, the previous
+					 * substitute may have inserted or
+					 * deleted characters before the
+					 * cursor. */
+					len_change = (int)STRLEN(new_line)
+						     - (int)STRLEN(orig_line);
+					curwin->w_cursor.col += len_change;
+					ml_replace(lnum, new_line, FALSE);
+				    }
+				}
+			    }
+
+			    search_match_lines = regmatch.endpos[0].lnum
+						  - regmatch.startpos[0].lnum;
+			    search_match_endcol = regmatch.endpos[0].col
+								 + len_change;
+			    highlight_match = TRUE;
+
+			    update_topline();
+			    validate_cursor();
+			    update_screen(SOME_VALID);
+			    highlight_match = FALSE;
+			    redraw_later(SOME_VALID);
+
+#ifdef FEAT_FOLDING
+			    curwin->w_p_fen = save_p_fen;
+#endif
+			    if (msg_row == Rows - 1)
+				msg_didout = FALSE;	/* avoid a scroll-up */
+			    msg_starthere();
+			    i = msg_scroll;
+			    msg_scroll = 0;		/* truncate msg when
+							   needed */
+			    msg_no_more = TRUE;
+			    /* write message same highlighting as for
+			     * wait_return */
+			    smsg_attr(HL_ATTR(HLF_R),
+				    (char_u *)_("replace with %s (y/n/a/q/l/^E/^Y)?"), sub);
+			    msg_no_more = FALSE;
+			    msg_scroll = i;
+			    showruler(TRUE);
+			    windgoto(msg_row, msg_col);
+			    RedrawingDisabled = temp;
+
+#ifdef USE_ON_FLY_SCROLL
+			    dont_scroll = FALSE; /* allow scrolling here */
+#endif
+			    ++no_mapping;	/* don't map this key */
+			    ++allow_keys;	/* allow special keys */
+			    typed = plain_vgetc();
+			    --allow_keys;
+			    --no_mapping;
+
+			    /* clear the question */
+			    msg_didout = FALSE;	/* don't scroll up */
+			    msg_col = 0;
+			    gotocmdline(TRUE);
+
+			    /* restore the line */
+			    if (orig_line != NULL)
+				ml_replace(lnum, orig_line, FALSE);
+			}
+
+			need_wait_return = FALSE; /* no hit-return prompt */
+			if (typed == 'q' || typed == ESC || typed == Ctrl_C
+#ifdef UNIX
+				|| typed == intr_char
+#endif
+				)
+			{
+			    got_quit = TRUE;
+			    break;
+			}
+			if (typed == 'n')
+			    break;
+			if (typed == 'y')
+			    break;
+			if (typed == 'l')
+			{
+			    /* last: replace and then stop */
+			    subflags.do_all = FALSE;
+			    line2 = lnum;
+			    break;
+			}
+			if (typed == 'a')
+			{
+			    subflags.do_ask = FALSE;
+			    break;
+			}
+#ifdef FEAT_INS_EXPAND
+			if (typed == Ctrl_E)
+			    scrollup_clamp();
+			else if (typed == Ctrl_Y)
+			    scrolldown_clamp();
+#endif
+		    }
+		    State = save_State;
+#ifdef FEAT_MOUSE
+		    setmouse();
+#endif
+		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
+			--no_u_sync;
+
+		    if (typed == 'n')
+		    {
+			/* For a multi-line match, put matchcol at the NUL at
+			 * the end of the line and set nmatch to one, so that
+			 * we continue looking for a match on the next line.
+			 * Avoids that ":%s/\nB\@=//gc" and ":%s/\n/,\r/gc"
+			 * get stuck when pressing 'n'. */
+			if (nmatch > 1)
+			{
+			    matchcol = (colnr_T)STRLEN(sub_firstline);
+			    skip_match = TRUE;
+			}
+			goto skip;
+		    }
+		    if (got_quit)
+			goto skip;
+		}
+
+		/* Move the cursor to the start of the match, so that we can
+		 * use "\=col("."). */
+		curwin->w_cursor.col = regmatch.startpos[0].col;
+
+		/*
+		 * 3. substitute the string.
+		 */
+#ifdef FEAT_EVAL
+		if (subflags.do_count)
+		{
+		    /* prevent accidentally changing the buffer by a function */
+		    save_ma = curbuf->b_p_ma;
+		    curbuf->b_p_ma = FALSE;
+		    sandbox++;
+		}
+		/* Save flags for recursion.  They can change for e.g.
+		 * :s/^/\=execute("s#^##gn") */
+		subflags_save = subflags;
+#endif
+		/* get length of substitution part */
+		sublen = vim_regsub_multi(&regmatch,
+				    sub_firstlnum - regmatch.startpos[0].lnum,
+				    sub, sub_firstline, FALSE, p_magic, TRUE);
+#ifdef FEAT_EVAL
+		/* Don't keep flags set by a recursive call. */
+		subflags = subflags_save;
+		if (subflags.do_count)
+		{
+		    curbuf->b_p_ma = save_ma;
+		    if (sandbox > 0)
+			sandbox--;
+		    goto skip;
+		}
+#endif
+
+		/* When the match included the "$" of the last line it may
+		 * go beyond the last line of the buffer. */
+		if (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)
+		{
+		    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;
+		    skip_match = TRUE;
+		}
+
+		/* Need room for:
+		 * - result so far in new_start (not for first sub in line)
+		 * - original text up to match
+		 * - length of substituted part
+		 * - original text after match
+		 */
+		if (nmatch == 1)
+		    p1 = sub_firstline;
+		else
+		{
+		    p1 = ml_get(sub_firstlnum + nmatch - 1);
+		    nmatch_tl += nmatch - 1;
+		}
+		copy_len = regmatch.startpos[0].col - copycol;
+		needed_len = copy_len + ((unsigned)STRLEN(p1)
+				       - regmatch.endpos[0].col) + sublen + 1;
+		if (new_start == NULL)
+		{
+		    /*
+		     * Get some space for a temporary buffer to do the
+		     * substitution into (and some extra space to avoid
+		     * too many calls to alloc()/free()).
+		     */
+		    new_start_len = needed_len + 50;
+		    if ((new_start = alloc_check(new_start_len)) == NULL)
+			goto outofmem;
+		    *new_start = NUL;
+		    new_end = new_start;
+		}
+		else
+		{
+		    /*
+		     * Check if the temporary buffer is long enough to do the
+		     * substitution into.  If not, make it larger (with a bit
+		     * extra to avoid too many calls to alloc()/free()).
+		     */
+		    len = (unsigned)STRLEN(new_start);
+		    needed_len += len;
+		    if (needed_len > (int)new_start_len)
+		    {
+			new_start_len = needed_len + 50;
+			if ((p1 = alloc_check(new_start_len)) == NULL)
+			{
+			    vim_free(new_start);
+			    goto outofmem;
+			}
+			mch_memmove(p1, new_start, (size_t)(len + 1));
+			vim_free(new_start);
+			new_start = p1;
+		    }
+		    new_end = new_start + len;
+		}
+
+		/*
+		 * copy the text up to the part that matched
+		 */
+		mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);
+		new_end += copy_len;
+
+		(void)vim_regsub_multi(&regmatch,
+				    sub_firstlnum - regmatch.startpos[0].lnum,
+					   sub, new_end, TRUE, p_magic, TRUE);
+		sub_nsubs++;
+		did_sub = TRUE;
+
+		/* Move the cursor to the start of the line, to avoid that it
+		 * is beyond the end of the line after the substitution. */
+		curwin->w_cursor.col = 0;
+
+		/* For a multi-line match, make a copy of the last matched
+		 * line and continue in that one. */
+		if (nmatch > 1)
+		{
+		    sub_firstlnum += nmatch - 1;
+		    vim_free(sub_firstline);
+		    sub_firstline = vim_strsave(ml_get(sub_firstlnum));
+		    /* When going beyond the last line, stop substituting. */
+		    if (sub_firstlnum <= line2)
+			do_again = TRUE;
+		    else
+			subflags.do_all = FALSE;
+		}
+
+		/* Remember next character to be copied. */
+		copycol = regmatch.endpos[0].col;
+
+		if (skip_match)
+		{
+		    /* Already hit end of the buffer, sub_firstlnum is one
+		     * less than what it ought to be. */
+		    vim_free(sub_firstline);
+		    sub_firstline = vim_strsave((char_u *)"");
+		    copycol = 0;
+		}
+
+		/*
+		 * Now the trick is to replace CTRL-M chars with a real line
+		 * break.  This would make it impossible to insert a CTRL-M in
+		 * the text.  The line break can be avoided by preceding the
+		 * CTRL-M with a backslash.  To be able to insert a backslash,
+		 * they must be doubled in the string and are halved here.
+		 * That is Vi compatible.
+		 */
+		for (p1 = new_end; *p1; ++p1)
+		{
+		    if (p1[0] == '\\' && p1[1] != NUL)  /* remove backslash */
+			STRMOVE(p1, p1 + 1);
+		    else if (*p1 == CAR)
+		    {
+			if (u_inssub(lnum) == OK)   /* prepare for undo */
+			{
+			    *p1 = NUL;		    /* truncate up to the CR */
+			    ml_append(lnum - 1, new_start,
+					(colnr_T)(p1 - new_start + 1), FALSE);
+			    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);
+			    if (subflags.do_ask)
+				appended_lines(lnum - 1, 1L);
+			    else
+			    {
+				if (first_line == 0)
+				    first_line = lnum;
+				last_line = lnum + 1;
+			    }
+			    /* All line numbers increase. */
+			    ++sub_firstlnum;
+			    ++lnum;
+			    ++line2;
+			    /* move the cursor to the new line, like Vi */
+			    ++curwin->w_cursor.lnum;
+			    /* copy the rest */
+			    STRMOVE(new_start, p1 + 1);
+			    p1 = new_start - 1;
+			}
+		    }
+#ifdef FEAT_MBYTE
+		    else if (has_mbyte)
+			p1 += (*mb_ptr2len)(p1) - 1;
+#endif
+		}
+
+		/*
+		 * 4. If do_all is set, find next match.
+		 * Prevent endless loop with patterns that match empty
+		 * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.
+		 * But ":s/\n/#/" is OK.
+		 */
+skip:
+		/* We already know that we did the last subst when we are at
+		 * the end of the line, except that a pattern like
+		 * "bar\|\nfoo" may match at the NUL.  "lnum" can be below
+		 * "line2" when there is a \zs in the pattern after a line
+		 * break. */
+		lastone = (skip_match
+			|| got_int
+			|| got_quit
+			|| lnum > line2
+			|| !(subflags.do_all || do_again)
+			|| (sub_firstline[matchcol] == NUL && nmatch <= 1
+					 && !re_multiline(regmatch.regprog)));
+		nmatch = -1;
+
+		/*
+		 * Replace the line in the buffer when needed.  This is
+		 * skipped when there are more matches.
+		 * The check for nmatch_tl is needed for when multi-line
+		 * matching must replace the lines before trying to do another
+		 * match, otherwise "\@<=" won't work.
+		 * When the match starts below where we start searching also
+		 * need to replace the line first (using \zs after \n).
+		 */
+		if (lastone
+			|| nmatch_tl > 0
+			|| (nmatch = vim_regexec_multi(&regmatch, curwin,
+							curbuf, sub_firstlnum,
+						    matchcol, NULL, NULL)) == 0
+			|| regmatch.startpos[0].lnum > 0)
+		{
+		    if (new_start != NULL)
+		    {
+			/*
+			 * Copy the rest of the line, that didn't match.
+			 * "matchcol" has to be adjusted, we use the end of
+			 * the line as reference, because the substitute may
+			 * have changed the number of characters.  Same for
+			 * "prev_matchcol".
+			 */
+			STRCAT(new_start, sub_firstline + copycol);
+			matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;
+			prev_matchcol = (colnr_T)STRLEN(sub_firstline)
+							      - prev_matchcol;
+
+			if (u_savesub(lnum) != OK)
+			    break;
+			ml_replace(lnum, new_start, TRUE);
+
+			if (nmatch_tl > 0)
+			{
+			    /*
+			     * Matched lines have now been substituted and are
+			     * useless, delete them.  The part after the match
+			     * has been appended to new_start, we don't need
+			     * it in the buffer.
+			     */
+			    ++lnum;
+			    if (u_savedel(lnum, nmatch_tl) != OK)
+				break;
+			    for (i = 0; i < nmatch_tl; ++i)
+				ml_delete(lnum, (int)FALSE);
+			    mark_adjust(lnum, lnum + nmatch_tl - 1,
+						   (long)MAXLNUM, -nmatch_tl);
+			    if (subflags.do_ask)
+				deleted_lines(lnum, nmatch_tl);
+			    --lnum;
+			    line2 -= nmatch_tl; /* nr of lines decreases */
+			    nmatch_tl = 0;
+			}
+
+			/* When asking, undo is saved each time, must also set
+			 * changed flag each time. */
+			if (subflags.do_ask)
+			    changed_bytes(lnum, 0);
+			else
+			{
+			    if (first_line == 0)
+				first_line = lnum;
+			    last_line = lnum + 1;
+			}
+
+			sub_firstlnum = lnum;
+			vim_free(sub_firstline);    /* free the temp buffer */
+			sub_firstline = new_start;
+			new_start = NULL;
+			matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;
+			prev_matchcol = (colnr_T)STRLEN(sub_firstline)
+							      - prev_matchcol;
+			copycol = 0;
+		    }
+		    if (nmatch == -1 && !lastone)
+			nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,
+					  sub_firstlnum, matchcol, NULL, NULL);
+
+		    /*
+		     * 5. break if there isn't another match in this line
+		     */
+		    if (nmatch <= 0)
+		    {
+			/* If the match found didn't start where we were
+			 * searching, do the next search in the line where we
+			 * found the match. */
+			if (nmatch == -1)
+			    lnum -= regmatch.startpos[0].lnum;
+			break;
+		    }
+		}
+
+		line_breakcheck();
+	    }
+
+	    if (did_sub)
+		++sub_nlines;
+	    vim_free(new_start);	/* for when substitute was cancelled */
+	    VIM_CLEAR(sub_firstline);	/* free the copy of the original line */
+	}
+
+	line_breakcheck();
+    }
+
+    if (first_line != 0)
+    {
+	/* Need to subtract the number of added lines from "last_line" to get
+	 * the line number before the change (same as adding the number of
+	 * deleted lines). */
+	i = curbuf->b_ml.ml_line_count - old_line_count;
+	changed_lines(first_line, 0, last_line - i, i);
+    }
+
+outofmem:
+    vim_free(sub_firstline); /* may have to free allocated copy of the line */
+
+    /* ":s/pat//n" doesn't move the cursor */
+    if (subflags.do_count)
+	curwin->w_cursor = old_cursor;
+
+    if (sub_nsubs > start_nsubs)
+    {
+	/* Set the '[ and '] marks. */
+	curbuf->b_op_start.lnum = eap->line1;
+	curbuf->b_op_end.lnum = line2;
+	curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
+
+	if (!global_busy)
+	{
+	    /* when interactive leave cursor on the match */
+	    if (!subflags.do_ask)
+	    {
+		if (endcolumn)
+		    coladvance((colnr_T)MAXCOL);
+		else
+		    beginline(BL_WHITE | BL_FIX);
+	    }
+	    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)
+		MSG("");
+	}
+	else
+	    global_need_beginline = TRUE;
+	if (subflags.do_print)
+	    print_line(curwin->w_cursor.lnum,
+					 subflags.do_number, subflags.do_list);
+    }
+    else if (!global_busy)
+    {
+	if (got_int)		/* interrupted */
+	    EMSG(_(e_interr));
+	else if (got_match)	/* did find something but nothing substituted */
+	    MSG("");
+	else if (subflags.do_error)	/* nothing found */
+	    EMSG2(_(e_patnotf2), get_search_pat());
+    }
+
+#ifdef FEAT_FOLDING
+    if (subflags.do_ask && hasAnyFolding(curwin))
+	/* Cursor position may require updating */
+	changed_window_setting();
+#endif
+
+    vim_regfree(regmatch.regprog);
+
+    /* Restore the flag values, they can be used for ":&&". */
+    subflags.do_all = save_do_all;
+    subflags.do_ask = save_do_ask;
+}
+
+/*
+ * Give message for number of substitutions.
+ * Can also be used after a ":global" command.
+ * Return TRUE if a message was given.
+ */
+    int
+do_sub_msg(
+    int	    count_only)		/* used 'n' flag for ":s" */
+{
+    /*
+     * Only report substitutions when:
+     * - more than 'report' substitutions
+     * - command was typed by user, or number of changed lines > 'report'
+     * - giving messages is not disabled by 'lazyredraw'
+     */
+    if (((sub_nsubs > p_report && (KeyTyped || sub_nlines > 1 || p_report < 1))
+		|| count_only)
+	    && messaging())
+    {
+	char	*msg_single;
+	char	*msg_plural;
+
+	if (got_int)
+	    STRCPY(msg_buf, _("(Interrupted) "));
+	else
+	    *msg_buf = NUL;
+
+	msg_single = count_only
+		    ? NGETTEXT("%ld match on %ld line",
+					  "%ld matches on %ld line", sub_nsubs)
+		    : NGETTEXT("%ld substitution on %ld line",
+				   "%ld substitutions on %ld line", sub_nsubs);
+	msg_plural = count_only
+		    ? NGETTEXT("%ld match on %ld lines",
+					 "%ld matches on %ld lines", sub_nsubs)
+		    : NGETTEXT("%ld substitution on %ld lines",
+				  "%ld substitutions on %ld lines", sub_nsubs);
+
+	vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),
+				 NGETTEXT(msg_single, msg_plural, sub_nlines),
+				 sub_nsubs, (long)sub_nlines);
+
+	if (msg(msg_buf))
+	    /* save message to display it after redraw */
+	    set_keep_msg(msg_buf, 0);
+	return TRUE;
+    }
+    if (got_int)
+    {
+	EMSG(_(e_interr));
+	return TRUE;
+    }
+    return FALSE;
+}
+
+    static void
+global_exe_one(char_u *cmd, linenr_T lnum)
+{
+    curwin->w_cursor.lnum = lnum;
+    curwin->w_cursor.col = 0;
+    if (*cmd == NUL || *cmd == '\n')
+	do_cmdline((char_u *)"p", NULL, NULL, DOCMD_NOWAIT);
+    else
+	do_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);
+}
+
+/*
+ * Execute a global command of the form:
+ *
+ * g/pattern/X : execute X on all lines where pattern matches
+ * v/pattern/X : execute X on all lines where pattern does not match
+ *
+ * where 'X' is an EX command
+ *
+ * The command character (as well as the trailing slash) is optional, and
+ * is assumed to be 'p' if missing.
+ *
+ * This is implemented in two passes: first we scan the file for the pattern and
+ * set a mark for each line that (not) matches. Secondly we execute the command
+ * for each line that has a mark. This is required because after deleting
+ * lines we do not know where to search for the next match.
+ */
+    void
+ex_global(exarg_T *eap)
+{
+    linenr_T	lnum;		/* line number according to old situation */
+    int		ndone = 0;
+    int		type;		/* first char of cmd: 'v' or 'g' */
+    char_u	*cmd;		/* command argument */
+
+    char_u	delim;		/* delimiter, normally '/' */
+    char_u	*pat;
+    regmmatch_T	regmatch;
+    int		match;
+    int		which_pat;
+
+    /* When nesting the command works on one line.  This allows for
+     * ":g/found/v/notfound/command". */
+    if (global_busy && (eap->line1 != 1
+				  || eap->line2 != curbuf->b_ml.ml_line_count))
+    {
+	/* will increment global_busy to break out of the loop */
+	EMSG(_("E147: Cannot do :global recursive with a range"));
+	return;
+    }
+
+    if (eap->forceit)		    /* ":global!" is like ":vglobal" */
+	type = 'v';
+    else
+	type = *eap->cmd;
+    cmd = eap->arg;
+    which_pat = RE_LAST;	    /* default: use last used regexp */
+
+    /*
+     * undocumented vi feature:
+     *	"\/" and "\?": use previous search pattern.
+     *		 "\&": use previous substitute pattern.
+     */
+    if (*cmd == '\\')
+    {
+	++cmd;
+	if (vim_strchr((char_u *)"/?&", *cmd) == NULL)
+	{
+	    EMSG(_(e_backslash));
+	    return;
+	}
+	if (*cmd == '&')
+	    which_pat = RE_SUBST;	/* use previous substitute pattern */
+	else
+	    which_pat = RE_SEARCH;	/* use previous search pattern */
+	++cmd;
+	pat = (char_u *)"";
+    }
+    else if (*cmd == NUL)
+    {
+	EMSG(_("E148: Regular expression missing from global"));
+	return;
+    }
+    else
+    {
+	delim = *cmd;		/* get the delimiter */
+	if (delim)
+	    ++cmd;		/* skip delimiter if there is one */
+	pat = cmd;		/* remember start of pattern */
+	cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);
+	if (cmd[0] == delim)		    /* end delimiter found */
+	    *cmd++ = NUL;		    /* replace it with a NUL */
+    }
+
+#ifdef FEAT_FKMAP	/* when in Farsi mode, reverse the character flow */
+    if (p_altkeymap && curwin->w_p_rl)
+	lrFswap(pat,0);
+#endif
+
+    if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &regmatch) == FAIL)
+    {
+	EMSG(_(e_invcmd));
+	return;
+    }
+
+    if (global_busy)
+    {
+	lnum = curwin->w_cursor.lnum;
+	match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,
+						       (colnr_T)0, NULL, NULL);
+	if ((type == 'g' && match) || (type == 'v' && !match))
+	    global_exe_one(cmd, lnum);
+    }
+    else
+    {
+	/*
+	 * pass 1: set marks for each (not) matching line
+	 */
+	for (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)
+	{
+	    /* a match on this line? */
+	    match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,
+						       (colnr_T)0, NULL, NULL);
+	    if ((type == 'g' && match) || (type == 'v' && !match))
+	    {
+		ml_setmarked(lnum);
+		ndone++;
+	    }
+	    line_breakcheck();
+	}
+
+	/*
+	 * pass 2: execute the command for each line that has been marked
+	 */
+	if (got_int)
+	    MSG(_(e_interr));
+	else if (ndone == 0)
+	{
+	    if (type == 'v')
+		smsg((char_u *)_("Pattern found in every line: %s"), pat);
+	    else
+		smsg((char_u *)_("Pattern not found: %s"), pat);
+	}
+	else
+	{
+#ifdef FEAT_CLIPBOARD
+	    start_global_changes();
+#endif
+	    global_exe(cmd);
+#ifdef FEAT_CLIPBOARD
+	    end_global_changes();
+#endif
+	}
+
+	ml_clearmarked();	   /* clear rest of the marks */
+    }
+
+    vim_regfree(regmatch.regprog);
+}
+
+/*
+ * Execute "cmd" on lines marked with ml_setmarked().
+ */
+    void
+global_exe(char_u *cmd)
+{
+    linenr_T old_lcount;	/* b_ml.ml_line_count before the command */
+    buf_T    *old_buf = curbuf;	/* remember what buffer we started in */
+    linenr_T lnum;		/* line number according to old situation */
+
+    /*
+     * Set current position only once for a global command.
+     * If global_busy is set, setpcmark() will not do anything.
+     * If there is an error, global_busy will be incremented.
+     */
+    setpcmark();
+
+    /* When the command writes a message, don't overwrite the command. */
+    msg_didout = TRUE;
+
+    sub_nsubs = 0;
+    sub_nlines = 0;
+    global_need_beginline = FALSE;
+    global_busy = 1;
+    old_lcount = curbuf->b_ml.ml_line_count;
+    while (!got_int && (lnum = ml_firstmarked()) != 0 && global_busy == 1)
+    {
+	global_exe_one(cmd, lnum);
+	ui_breakcheck();
+    }
+
+    global_busy = 0;
+    if (global_need_beginline)
+	beginline(BL_WHITE | BL_FIX);
+    else
+	check_cursor();	/* cursor may be beyond the end of the line */
+
+    /* the cursor may not have moved in the text but a change in a previous
+     * line may move it on the screen */
+    changed_line_abv_curs();
+
+    /* If it looks like no message was written, allow overwriting the
+     * command with the report for number of changes. */
+    if (msg_col == 0 && msg_scrolled == 0)
+	msg_didout = FALSE;
+
+    /* If substitutes done, report number of substitutes, otherwise report
+     * number of extra or deleted lines.
+     * Don't report extra or deleted lines in the edge case where the buffer
+     * we are in after execution is different from the buffer we started in. */
+    if (!do_sub_msg(FALSE) && curbuf == old_buf)
+	msgmore(curbuf->b_ml.ml_line_count - old_lcount);
+}
+
+#ifdef FEAT_VIMINFO
+    int
+read_viminfo_sub_string(vir_T *virp, int force)
+{
+    if (force)
+	vim_free(old_sub);
+    if (force || old_sub == NULL)
+	old_sub = viminfo_readstring(virp, 1, TRUE);
+    return viminfo_readline(virp);
+}
+
+    void
+write_viminfo_sub_string(FILE *fp)
+{
+    if (get_viminfo_parameter('/') != 0 && old_sub != NULL)
+    {
+	fputs(_("\n# Last Substitute String:\n$"), fp);
+	viminfo_writestring(fp, old_sub);
+    }
+}
+#endif /* FEAT_VIMINFO */
+
+#if defined(EXITFREE) || defined(PROTO)
+    void
+free_old_sub(void)
+{
+    vim_free(old_sub);
+}
+#endif
+
+#if defined(FEAT_QUICKFIX) || defined(PROTO)
+/*
+ * Set up for a tagpreview.
+ * Return TRUE when it was created.
+ */
+    int
+prepare_tagpreview(
+    int		undo_sync)	/* sync undo when leaving the window */
+{
+    win_T	*wp;
+
+# ifdef FEAT_GUI
+    need_mouse_correct = TRUE;
+# endif
+
+    /*
+     * If there is already a preview window open, use that one.
+     */
+    if (!curwin->w_p_pvw)
+    {
+	FOR_ALL_WINDOWS(wp)
+	    if (wp->w_p_pvw)
+		break;
+	if (wp != NULL)
+	    win_enter(wp, undo_sync);
+	else
+	{
+	    /*
+	     * There is no preview window open yet.  Create one.
+	     */
+	    if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0)
+								      == FAIL)
+		return FALSE;
+	    curwin->w_p_pvw = TRUE;
+	    curwin->w_p_wfh = TRUE;
+	    RESET_BINDING(curwin);	    /* don't take over 'scrollbind'
+					       and 'cursorbind' */
+# ifdef FEAT_DIFF
+	    curwin->w_p_diff = FALSE;	    /* no 'diff' */
+# endif
+# ifdef FEAT_FOLDING
+	    curwin->w_p_fdc = 0;	    /* no 'foldcolumn' */
+# endif
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+#endif
+
+
+/*
+ * ":help": open a read-only window on a help file
+ */
+    void
+ex_help(exarg_T *eap)
+{
+    char_u	*arg;
+    char_u	*tag;
+    FILE	*helpfd;	/* file descriptor of help file */
+    int		n;
+    int		i;
+    win_T	*wp;
+    int		num_matches;
+    char_u	**matches;
+    char_u	*p;
+    int		empty_fnum = 0;
+    int		alt_fnum = 0;
+    buf_T	*buf;
+#ifdef FEAT_MULTI_LANG
+    int		len;
+    char_u	*lang;
+#endif
+#ifdef FEAT_FOLDING
+    int		old_KeyTyped = KeyTyped;
+#endif
+
+    if (eap != NULL)
+    {
+	/*
+	 * A ":help" command ends at the first LF, or at a '|' that is
+	 * followed by some text.  Set nextcmd to the following command.
+	 */
+	for (arg = eap->arg; *arg; ++arg)
+	{
+	    if (*arg == '\n' || *arg == '\r'
+		    || (*arg == '|' && arg[1] != NUL && arg[1] != '|'))
+	    {
+		*arg++ = NUL;
+		eap->nextcmd = arg;
+		break;
+	    }
+	}
+	arg = eap->arg;
+
+	if (eap->forceit && *arg == NUL && !curbuf->b_help)
+	{
+	    EMSG(_("E478: Don't panic!"));
+	    return;
+	}
+
+	if (eap->skip)	    /* not executing commands */
+	    return;
+    }
+    else
+	arg = (char_u *)"";
+
+    /* remove trailing blanks */
+    p = arg + STRLEN(arg) - 1;
+    while (p > arg && VIM_ISWHITE(*p) && p[-1] != '\\')
+	*p-- = NUL;
+
+#ifdef FEAT_MULTI_LANG
+    /* Check for a specified language */
+    lang = check_help_lang(arg);
+#endif
+
+    /* When no argument given go to the index. */
+    if (*arg == NUL)
+	arg = (char_u *)"help.txt";
+
+    /*
+     * Check if there is a match for the argument.
+     */
+    n = find_help_tags(arg, &num_matches, &matches,
+						 eap != NULL && eap->forceit);
+
+    i = 0;
+#ifdef FEAT_MULTI_LANG
+    if (n != FAIL && lang != NULL)
+	/* Find first item with the requested language. */
+	for (i = 0; i < num_matches; ++i)
+	{
+	    len = (int)STRLEN(matches[i]);
+	    if (len > 3 && matches[i][len - 3] == '@'
+				  && STRICMP(matches[i] + len - 2, lang) == 0)
+		break;
+	}
+#endif
+    if (i >= num_matches || n == FAIL)
+    {
+#ifdef FEAT_MULTI_LANG
+	if (lang != NULL)
+	    EMSG3(_("E661: Sorry, no '%s' help for %s"), lang, arg);
+	else
+#endif
+	    EMSG2(_("E149: Sorry, no help for %s"), arg);
+	if (n != FAIL)
+	    FreeWild(num_matches, matches);
+	return;
+    }
+
+    /* The first match (in the requested language) is the best match. */
+    tag = vim_strsave(matches[i]);
+    FreeWild(num_matches, matches);
+
+#ifdef FEAT_GUI
+    need_mouse_correct = TRUE;
+#endif
+
+    /*
+     * Re-use an existing help window or open a new one.
+     * Always open a new one for ":tab help".
+     */
+    if (!bt_help(curwin->w_buffer) || cmdmod.tab != 0)
+    {
+	if (cmdmod.tab != 0)
+	    wp = NULL;
+	else
+	    FOR_ALL_WINDOWS(wp)
+		if (bt_help(wp->w_buffer))
+		    break;
+	if (wp != NULL && wp->w_buffer->b_nwindows > 0)
+	    win_enter(wp, TRUE);
+	else
+	{
+	    /*
+	     * There is no help window yet.
+	     * Try to open the file specified by the "helpfile" option.
+	     */
+	    if ((helpfd = mch_fopen((char *)p_hf, READBIN)) == NULL)
+	    {
+		smsg((char_u *)_("Sorry, help file \"%s\" not found"), p_hf);
+		goto erret;
+	    }
+	    fclose(helpfd);
+
+	    /* Split off help window; put it at far top if no position
+	     * specified, the current window is vertically split and
+	     * narrow. */
+	    n = WSP_HELP;
+	    if (cmdmod.split == 0 && curwin->w_width != Columns
+						  && curwin->w_width < 80)
+		n |= WSP_TOP;
+	    if (win_split(0, n) == FAIL)
+		goto erret;
+
+	    if (curwin->w_height < p_hh)
+		win_setheight((int)p_hh);
+
+	    /*
+	     * Open help file (do_ecmd() will set b_help flag, readfile() will
+	     * set b_p_ro flag).
+	     * Set the alternate file to the previously edited file.
+	     */
+	    alt_fnum = curbuf->b_fnum;
+	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,
+			  ECMD_HIDE + ECMD_SET_HELP,
+			  NULL);  /* buffer is still open, don't store info */
+	    if (!cmdmod.keepalt)
+		curwin->w_alt_fnum = alt_fnum;
+	    empty_fnum = curbuf->b_fnum;
+	}
+    }
+
+    if (!p_im)
+	restart_edit = 0;	    /* don't want insert mode in help file */
+
+#ifdef FEAT_FOLDING
+    /* Restore KeyTyped, setting 'filetype=help' may reset it.
+     * It is needed for do_tag top open folds under the cursor. */
+    KeyTyped = old_KeyTyped;
+#endif
+
+    if (tag != NULL)
+	do_tag(tag, DT_HELP, 1, FALSE, TRUE);
+
+    /* Delete the empty buffer if we're not using it.  Careful: autocommands
+     * may have jumped to another window, check that the buffer is not in a
+     * window. */
+    if (empty_fnum != 0 && curbuf->b_fnum != empty_fnum)
+    {
+	buf = buflist_findnr(empty_fnum);
+	if (buf != NULL && buf->b_nwindows == 0)
+	    wipe_buffer(buf, TRUE);
+    }
+
+    /* keep the previous alternate file */
+    if (alt_fnum != 0 && curwin->w_alt_fnum == empty_fnum && !cmdmod.keepalt)
+	curwin->w_alt_fnum = alt_fnum;
+
+erret:
+    vim_free(tag);
+}
+
+/*
+ * ":helpclose": Close one help window
+ */
+    void
+ex_helpclose(exarg_T *eap UNUSED)
+{
+    win_T *win;
+
+    FOR_ALL_WINDOWS(win)
+    {
+	if (bt_help(win->w_buffer))
+	{
+	    win_close(win, FALSE);
+	    return;
+	}
+    }
+}
+
+#if defined(FEAT_MULTI_LANG) || defined(PROTO)
+/*
+ * In an argument search for a language specifiers in the form "@xx".
+ * Changes the "@" to NUL if found, and returns a pointer to "xx".
+ * Returns NULL if not found.
+ */
+    char_u *
+check_help_lang(char_u *arg)
+{
+    int len = (int)STRLEN(arg);
+
+    if (len >= 3 && arg[len - 3] == '@' && ASCII_ISALPHA(arg[len - 2])
+					       && ASCII_ISALPHA(arg[len - 1]))
+    {
+	arg[len - 3] = NUL;		/* remove the '@' */
+	return arg + len - 2;
+    }
+    return NULL;
+}
+#endif
+
+/*
+ * Return a heuristic indicating how well the given string matches.  The
+ * smaller the number, the better the match.  This is the order of priorities,
+ * from best match to worst match:
+ *	- Match with least alpha-numeric characters is better.
+ *	- Match with least total characters is better.
+ *	- Match towards the start is better.
+ *	- Match starting with "+" is worse (feature instead of command)
+ * Assumption is made that the matched_string passed has already been found to
+ * match some string for which help is requested.  webb.
+ */
+    int
+help_heuristic(
+    char_u	*matched_string,
+    int		offset,			/* offset for match */
+    int		wrong_case)		/* no matching case */
+{
+    int		num_letters;
+    char_u	*p;
+
+    num_letters = 0;
+    for (p = matched_string; *p; p++)
+	if (ASCII_ISALNUM(*p))
+	    num_letters++;
+
+    /*
+     * Multiply the number of letters by 100 to give it a much bigger
+     * weighting than the number of characters.
+     * If there only is a match while ignoring case, add 5000.
+     * If the match starts in the middle of a word, add 10000 to put it
+     * somewhere in the last half.
+     * If the match is more than 2 chars from the start, multiply by 200 to
+     * put it after matches at the start.
+     */
+    if (ASCII_ISALNUM(matched_string[offset]) && offset > 0
+				 && ASCII_ISALNUM(matched_string[offset - 1]))
+	offset += 10000;
+    else if (offset > 2)
+	offset *= 200;
+    if (wrong_case)
+	offset += 5000;
+    /* Features are less interesting than the subjects themselves, but "+"
+     * alone is not a feature. */
+    if (matched_string[0] == '+' && matched_string[1] != NUL)
+	offset += 100;
+    return (int)(100 * num_letters + STRLEN(matched_string) + offset);
+}
+
+/*
+ * Compare functions for qsort() below, that checks the help heuristics number
+ * that has been put after the tagname by find_tags().
+ */
+    static int
+#ifdef __BORLANDC__
+_RTLENTRYF
+#endif
+help_compare(const void *s1, const void *s2)
+{
+    char    *p1;
+    char    *p2;
+
+    p1 = *(char **)s1 + strlen(*(char **)s1) + 1;
+    p2 = *(char **)s2 + strlen(*(char **)s2) + 1;
+    return strcmp(p1, p2);
+}
+
+/*
+ * Find all help tags matching "arg", sort them and return in matches[], with
+ * the number of matches in num_matches.
+ * The matches will be sorted with a "best" match algorithm.
+ * When "keep_lang" is TRUE try keeping the language of the current buffer.
+ */
+    int
+find_help_tags(
+    char_u	*arg,
+    int		*num_matches,
+    char_u	***matches,
+    int		keep_lang)
+{
+    char_u	*s, *d;
+    int		i;
+    static char *(mtable[]) = {"*", "g*", "[*", "]*", ":*",
+			       "/*", "/\\*", "\"*", "**",
+			       "cpo-*", "/\\(\\)", "/\\%(\\)",
+			       "?", ":?", "?<CR>", "g?", "g?g?", "g??",
+			       "-?", "q?", "v_g?",
+			       "/\\?", "/\\z(\\)", "\\=", ":s\\=",
+			       "[count]", "[quotex]",
+			       "[range]", ":[range]",
+			       "[pattern]", "\\|", "\\%$",
+			       "s/\\~", "s/\\U", "s/\\L",
+			       "s/\\1", "s/\\2", "s/\\3", "s/\\9"};
+    static char *(rtable[]) = {"star", "gstar", "[star", "]star", ":star",
+			       "/star", "/\\\\star", "quotestar", "starstar",
+			       "cpo-star", "/\\\\(\\\\)", "/\\\\%(\\\\)",
+			       "?", ":?", "?<CR>", "g?", "g?g?", "g??",
+			       "-?", "q?", "v_g?",
+			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
+			       "\\[count]", "\\[quotex]",
+			       "\\[range]", ":\\[range]",
+			       "\\[pattern]", "\\\\bar", "/\\\\%\\$",
+			       "s/\\\\\\~", "s/\\\\U", "s/\\\\L",
+			       "s/\\\\1", "s/\\\\2", "s/\\\\3", "s/\\\\9"};
+    static char *(expr_table[]) = {"!=?", "!~?", "<=?", "<?", "==?", "=~?",
+				">=?", ">?", "is?", "isnot?"};
+    int flags;
+
+    d = IObuff;		    /* assume IObuff is long enough! */
+
+    if (STRNICMP(arg, "expr-", 5) == 0)
+    {
+	// When the string starting with "expr-" and containing '?' and matches
+	// the table, it is taken literally.  Otherwise '?' is recognized as a
+	// wildcard.
+	for (i = (int)(sizeof(expr_table) / sizeof(char *)); --i >= 0; )
+	    if (STRCMP(arg + 5, expr_table[i]) == 0)
+	    {
+		STRCPY(d, arg);
+		break;
+	    }
+    }
+    else
+    {
+	// Recognize a few exceptions to the rule.  Some strings that contain
+	// '*' with "star".  Otherwise '*' is recognized as a wildcard.
+	for (i = (int)(sizeof(mtable) / sizeof(char *)); --i >= 0; )
+	    if (STRCMP(arg, mtable[i]) == 0)
+	    {
+		STRCPY(d, rtable[i]);
+		break;
+	    }
+    }
+
+    if (i < 0)	/* no match in table */
+    {
+	/* Replace "\S" with "/\\S", etc.  Otherwise every tag is matched.
+	 * Also replace "\%^" and "\%(", they match every tag too.
+	 * Also "\zs", "\z1", etc.
+	 * Also "\@<", "\@=", "\@<=", etc.
+	 * And also "\_$" and "\_^". */
+	if (arg[0] == '\\'
+		&& ((arg[1] != NUL && arg[2] == NUL)
+		    || (vim_strchr((char_u *)"%_z@", arg[1]) != NULL
+							   && arg[2] != NUL)))
+	{
+	    STRCPY(d, "/\\\\");
+	    STRCPY(d + 3, arg + 1);
+	    /* Check for "/\\_$", should be "/\\_\$" */
+	    if (d[3] == '_' && d[4] == '$')
+		STRCPY(d + 4, "\\$");
+	}
+	else
+	{
+	  /* Replace:
+	   * "[:...:]" with "\[:...:]"
+	   * "[++...]" with "\[++...]"
+	   * "\{" with "\\{"		   -- matching "} \}"
+	   */
+	    if ((arg[0] == '[' && (arg[1] == ':'
+			 || (arg[1] == '+' && arg[2] == '+')))
+		    || (arg[0] == '\\' && arg[1] == '{'))
+	      *d++ = '\\';
+
+	  /*
+	   * If tag starts with "('", skip the "(". Fixes CTRL-] on ('option'.
+	   */
+	  if (*arg == '(' && arg[1] == '\'')
+	      arg++;
+	  for (s = arg; *s; ++s)
+	  {
+	    /*
+	     * Replace "|" with "bar" and '"' with "quote" to match the name of
+	     * the tags for these commands.
+	     * Replace "*" with ".*" and "?" with "." to match command line
+	     * completion.
+	     * Insert a backslash before '~', '$' and '.' to avoid their
+	     * special meaning.
+	     */
+	    if (d - IObuff > IOSIZE - 10)	/* getting too long!? */
+		break;
+	    switch (*s)
+	    {
+		case '|':   STRCPY(d, "bar");
+			    d += 3;
+			    continue;
+		case '"':   STRCPY(d, "quote");
+			    d += 5;
+			    continue;
+		case '*':   *d++ = '.';
+			    break;
+		case '?':   *d++ = '.';
+			    continue;
+		case '$':
+		case '.':
+		case '~':   *d++ = '\\';
+			    break;
+	    }
+
+	    /*
+	     * Replace "^x" by "CTRL-X". Don't do this for "^_" to make
+	     * ":help i_^_CTRL-D" work.
+	     * Insert '-' before and after "CTRL-X" when applicable.
+	     */
+	    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])
+			   || vim_strchr((char_u *)"?@[\\]^", s[1]) != NULL)))
+	    {
+		if (d > IObuff && d[-1] != '_' && d[-1] != '\\')
+		    *d++ = '_';		/* prepend a '_' to make x_CTRL-x */
+		STRCPY(d, "CTRL-");
+		d += 5;
+		if (*s < ' ')
+		{
+#ifdef EBCDIC
+		    *d++ = CtrlChar(*s);
+#else
+		    *d++ = *s + '@';
+#endif
+		    if (d[-1] == '\\')
+			*d++ = '\\';	/* double a backslash */
+		}
+		else
+		    *d++ = *++s;
+		if (s[1] != NUL && s[1] != '_')
+		    *d++ = '_';		/* append a '_' */
+		continue;
+	    }
+	    else if (*s == '^')		/* "^" or "CTRL-^" or "^_" */
+		*d++ = '\\';
+
+	    /*
+	     * Insert a backslash before a backslash after a slash, for search
+	     * pattern tags: "/\|" --> "/\\|".
+	     */
+	    else if (s[0] == '\\' && s[1] != '\\'
+					       && *arg == '/' && s == arg + 1)
+		*d++ = '\\';
+
+	    /* "CTRL-\_" -> "CTRL-\\_" to avoid the special meaning of "\_" in
+	     * "CTRL-\_CTRL-N" */
+	    if (STRNICMP(s, "CTRL-\\_", 7) == 0)
+	    {
+		STRCPY(d, "CTRL-\\\\");
+		d += 7;
+		s += 6;
+	    }
+
+	    *d++ = *s;
+
+	    /*
+	     * If tag contains "({" or "([", tag terminates at the "(".
+	     * This is for help on functions, e.g.: abs({expr}).
+	     */
+	    if (*s == '(' && (s[1] == '{' || s[1] =='['))
+		break;
+
+	    /*
+	     * If tag starts with ', toss everything after a second '. Fixes
+	     * CTRL-] on 'option'. (would include the trailing '.').
+	     */
+	    if (*s == '\'' && s > arg && *arg == '\'')
+		break;
+	    /* Also '{' and '}'. */
+	    if (*s == '}' && s > arg && *arg == '{')
+		break;
+	  }
+	  *d = NUL;
+
+	  if (*IObuff == '`')
+	  {
+	      if (d > IObuff + 2 && d[-1] == '`')
+	      {
+		  /* remove the backticks from `command` */
+		  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));
+		  d[-2] = NUL;
+	      }
+	      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')
+	      {
+		  /* remove the backticks and comma from `command`, */
+		  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));
+		  d[-3] = NUL;
+	      }
+	      else if (d > IObuff + 4 && d[-3] == '`'
+					     && d[-2] == '\\' && d[-1] == '.')
+	      {
+		  /* remove the backticks and dot from `command`\. */
+		  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));
+		  d[-4] = NUL;
+	      }
+	  }
+	}
+    }
+
+    *matches = (char_u **)"";
+    *num_matches = 0;
+    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE;
+    if (keep_lang)
+	flags |= TAG_KEEP_LANG;
+    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK
+	    && *num_matches > 0)
+    {
+	/* Sort the matches found on the heuristic number that is after the
+	 * tag name. */
+	qsort((void *)*matches, (size_t)*num_matches,
+					      sizeof(char_u *), help_compare);
+	/* Delete more than TAG_MANY to reduce the size of the listing. */
+	while (*num_matches > TAG_MANY)
+	    vim_free((*matches)[--*num_matches]);
+    }
+    return OK;
+}
+
+/*
+ * Called when starting to edit a buffer for a help file.
+ */
+    static void
+prepare_help_buffer(void)
+{
+    char_u	*p;
+
+    curbuf->b_help = TRUE;
+#ifdef FEAT_QUICKFIX
+    set_string_option_direct((char_u *)"buftype", -1,
+				     (char_u *)"help", OPT_FREE|OPT_LOCAL, 0);
+#endif
+
+    /*
+     * Always set these options after jumping to a help tag, because the
+     * user may have an autocommand that gets in the way.
+     * Accept all ASCII chars for keywords, except ' ', '*', '"', '|', and
+     * latin1 word characters (for translated help files).
+     * Only set it when needed, buf_init_chartab() is some work.
+     */
+    p =
+#ifdef EBCDIC
+	    (char_u *)"65-255,^*,^|,^\"";
+#else
+	    (char_u *)"!-~,^*,^|,^\",192-255";
+#endif
+    if (STRCMP(curbuf->b_p_isk, p) != 0)
+    {
+	set_string_option_direct((char_u *)"isk", -1, p, OPT_FREE|OPT_LOCAL, 0);
+	check_buf_options(curbuf);
+	(void)buf_init_chartab(curbuf, FALSE);
+    }
+
+#ifdef FEAT_FOLDING
+    /* Don't use the global foldmethod.*/
+    set_string_option_direct((char_u *)"fdm", -1, (char_u *)"manual",
+						       OPT_FREE|OPT_LOCAL, 0);
+#endif
+
+    curbuf->b_p_ts = 8;		/* 'tabstop' is 8 */
+    curwin->w_p_list = FALSE;	/* no list mode */
+
+    curbuf->b_p_ma = FALSE;		/* not modifiable */
+    curbuf->b_p_bin = FALSE;	/* reset 'bin' before reading file */
+    curwin->w_p_nu = 0;		/* no line numbers */
+    curwin->w_p_rnu = 0;		/* no relative line numbers */
+    RESET_BINDING(curwin);		/* no scroll or cursor binding */
+#ifdef FEAT_ARABIC
+    curwin->w_p_arab = FALSE;	/* no arabic mode */
+#endif
+#ifdef FEAT_RIGHTLEFT
+    curwin->w_p_rl  = FALSE;	/* help window is left-to-right */
+#endif
+#ifdef FEAT_FOLDING
+    curwin->w_p_fen = FALSE;	/* No folding in the help window */
+#endif
+#ifdef FEAT_DIFF
+    curwin->w_p_diff = FALSE;	/* No 'diff' */
+#endif
+#ifdef FEAT_SPELL
+    curwin->w_p_spell = FALSE;	/* No spell checking */
+#endif
+
+    set_buflisted(FALSE);
+}
+
+/*
+ * After reading a help file: May cleanup a help buffer when syntax
+ * highlighting is not used.
+ */
+    void
+fix_help_buffer(void)
+{
+    linenr_T	lnum;
+    char_u	*line;
+    int		in_example = FALSE;
+    int		len;
+    char_u	*fname;
+    char_u	*p;
+    char_u	*rt;
+    int		mustfree;
+
+    /* Set filetype to "help" if still needed. */
+    if (STRCMP(curbuf->b_p_ft, "help") != 0)
+    {
+	++curbuf_lock;
+	set_option_value((char_u *)"ft", 0L, (char_u *)"help", OPT_LOCAL);
+	--curbuf_lock;
+    }
+
+#ifdef FEAT_SYN_HL
+    if (!syntax_present(curwin))
+#endif
+    {
+	for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
+	{
+	    line = ml_get_buf(curbuf, lnum, FALSE);
+	    len = (int)STRLEN(line);
+	    if (in_example && len > 0 && !VIM_ISWHITE(line[0]))
+	    {
+		/* End of example: non-white or '<' in first column. */
+		if (line[0] == '<')
+		{
+		    /* blank-out a '<' in the first column */
+		    line = ml_get_buf(curbuf, lnum, TRUE);
+		    line[0] = ' ';
+		}
+		in_example = FALSE;
+	    }
+	    if (!in_example && len > 0)
+	    {
+		if (line[len - 1] == '>' && (len == 1 || line[len - 2] == ' '))
+		{
+		    /* blank-out a '>' in the last column (start of example) */
+		    line = ml_get_buf(curbuf, lnum, TRUE);
+		    line[len - 1] = ' ';
+		    in_example = TRUE;
+		}
+		else if (line[len - 1] == '~')
+		{
+		    /* blank-out a '~' at the end of line (header marker) */
+		    line = ml_get_buf(curbuf, lnum, TRUE);
+		    line[len - 1] = ' ';
+		}
+	    }
+	}
+    }
+
+    /*
+     * In the "help.txt" and "help.abx" file, add the locally added help
+     * files.  This uses the very first line in the help file.
+     */
+    fname = gettail(curbuf->b_fname);
+    if (fnamecmp(fname, "help.txt") == 0
+#ifdef FEAT_MULTI_LANG
+	|| (fnamencmp(fname, "help.", 5) == 0
+	    && ASCII_ISALPHA(fname[5])
+	    && ASCII_ISALPHA(fname[6])
+	    && TOLOWER_ASC(fname[7]) == 'x'
+	    && fname[8] == NUL)
+#endif
+	)
+    {
+	for (lnum = 1; lnum < curbuf->b_ml.ml_line_count; ++lnum)
+	{
+	    line = ml_get_buf(curbuf, lnum, FALSE);
+	    if (strstr((char *)line, "*local-additions*") == NULL)
+		continue;
+
+	    /* Go through all directories in 'runtimepath', skipping
+	     * $VIMRUNTIME. */
+	    p = p_rtp;
+	    while (*p != NUL)
+	    {
+		copy_option_part(&p, NameBuff, MAXPATHL, ",");
+		mustfree = FALSE;
+		rt = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
+		if (rt != NULL && fullpathcmp(rt, NameBuff, FALSE) != FPC_SAME)
+		{
+		    int		fcount;
+		    char_u	**fnames;
+		    FILE	*fd;
+		    char_u	*s;
+		    int		fi;
+#ifdef FEAT_MBYTE
+		    vimconv_T	vc;
+		    char_u	*cp;
+#endif
+
+		    /* Find all "doc/ *.txt" files in this directory. */
+		    add_pathsep(NameBuff);
+#ifdef FEAT_MULTI_LANG
+		    STRCAT(NameBuff, "doc/*.??[tx]");
+#else
+		    STRCAT(NameBuff, "doc/*.txt");
+#endif
+		    if (gen_expand_wildcards(1, &NameBuff, &fcount,
+					 &fnames, EW_FILE|EW_SILENT) == OK
+			    && fcount > 0)
+		    {
+#ifdef FEAT_MULTI_LANG
+			int	i1, i2;
+			char_u	*f1, *f2;
+			char_u	*t1, *t2;
+			char_u	*e1, *e2;
+
+			/* If foo.abx is found use it instead of foo.txt in
+			 * the same directory. */
+			for (i1 = 0; i1 < fcount; ++i1)
+			{
+			    for (i2 = 0; i2 < fcount; ++i2)
+			    {
+				if (i1 == i2)
+				    continue;
+				if (fnames[i1] == NULL || fnames[i2] == NULL)
+				    continue;
+				f1 = fnames[i1];
+				f2 = fnames[i2];
+				t1 = gettail(f1);
+				t2 = gettail(f2);
+				e1 = vim_strrchr(t1, '.');
+				e2 = vim_strrchr(t2, '.');
+				if (e1 == NULL || e2 == NULL)
+				    continue;
+				if (fnamecmp(e1, ".txt") != 0
+				    && fnamecmp(e1, fname + 4) != 0)
+				{
+				    /* Not .txt and not .abx, remove it. */
+				    VIM_CLEAR(fnames[i1]);
+				    continue;
+				}
+				if (e1 - f1 != e2 - f2
+					    || fnamencmp(f1, f2, e1 - f1) != 0)
+				    continue;
+				if (fnamecmp(e1, ".txt") == 0
+				    && fnamecmp(e2, fname + 4) == 0)
+				    /* use .abx instead of .txt */
+				    VIM_CLEAR(fnames[i1]);
+			    }
+			}
+#endif
+			for (fi = 0; fi < fcount; ++fi)
+			{
+			    if (fnames[fi] == NULL)
+				continue;
+			    fd = mch_fopen((char *)fnames[fi], "r");
+			    if (fd != NULL)
+			    {
+				vim_fgets(IObuff, IOSIZE, fd);
+				if (IObuff[0] == '*'
+					&& (s = vim_strchr(IObuff + 1, '*'))
+								  != NULL)
+				{
+#ifdef FEAT_MBYTE
+				    int	this_utf = MAYBE;
+#endif
+				    /* Change tag definition to a
+				     * reference and remove <CR>/<NL>. */
+				    IObuff[0] = '|';
+				    *s = '|';
+				    while (*s != NUL)
+				    {
+					if (*s == '\r' || *s == '\n')
+					    *s = NUL;
+#ifdef FEAT_MBYTE
+					/* The text is utf-8 when a byte
+					 * above 127 is found and no
+					 * illegal byte sequence is found.
+					 */
+					if (*s >= 0x80 && this_utf != FALSE)
+					{
+					    int	l;
+
+					    this_utf = TRUE;
+					    l = utf_ptr2len(s);
+					    if (l == 1)
+						this_utf = FALSE;
+					    s += l - 1;
+					}
+#endif
+					++s;
+				    }
+#ifdef FEAT_MBYTE
+				    /* The help file is latin1 or utf-8;
+				     * conversion to the current
+				     * 'encoding' may be required. */
+				    vc.vc_type = CONV_NONE;
+				    convert_setup(&vc, (char_u *)(
+						this_utf == TRUE ? "utf-8"
+						      : "latin1"), p_enc);
+				    if (vc.vc_type == CONV_NONE)
+					/* No conversion needed. */
+					cp = IObuff;
+				    else
+				    {
+					/* Do the conversion.  If it fails
+					 * use the unconverted text. */
+					cp = string_convert(&vc, IObuff,
+								    NULL);
+					if (cp == NULL)
+					    cp = IObuff;
+				    }
+				    convert_setup(&vc, NULL, NULL);
+
+				    ml_append(lnum, cp, (colnr_T)0, FALSE);
+				    if (cp != IObuff)
+					vim_free(cp);
+#else
+				    ml_append(lnum, IObuff, (colnr_T)0,
+								   FALSE);
+#endif
+				    ++lnum;
+				}
+				fclose(fd);
+			    }
+			}
+			FreeWild(fcount, fnames);
+		    }
+		}
+		if (mustfree)
+		    vim_free(rt);
+	    }
+	    break;
+	}
+    }
+}
+
+/*
+ * ":exusage"
+ */
+    void
+ex_exusage(exarg_T *eap UNUSED)
+{
+    do_cmdline_cmd((char_u *)"help ex-cmd-index");
+}
+
+/*
+ * ":viusage"
+ */
+    void
+ex_viusage(exarg_T *eap UNUSED)
+{
+    do_cmdline_cmd((char_u *)"help normal-index");
+}
+
+/*
+ * Generate tags in one help directory.
+ */
+    static void
+helptags_one(
+    char_u	*dir,		/* doc directory */
+    char_u	*ext,		/* suffix, ".txt", ".itx", ".frx", etc. */
+    char_u	*tagfname,	/* "tags" for English, "tags-fr" for French. */
+    int		add_help_tags)	/* add "help-tags" tag */
+{
+    FILE	*fd_tags;
+    FILE	*fd;
+    garray_T	ga;
+    int		filecount;
+    char_u	**files;
+    char_u	*p1, *p2;
+    int		fi;
+    char_u	*s;
+    int		i;
+    char_u	*fname;
+    int		dirlen;
+# ifdef FEAT_MBYTE
+    int		utf8 = MAYBE;
+    int		this_utf8;
+    int		firstline;
+    int		mix = FALSE;	/* detected mixed encodings */
+# endif
+
+    /*
+     * Find all *.txt files.
+     */
+    dirlen = (int)STRLEN(dir);
+    STRCPY(NameBuff, dir);
+    STRCAT(NameBuff, "/**/*");
+    STRCAT(NameBuff, ext);
+    if (gen_expand_wildcards(1, &NameBuff, &filecount, &files,
+						    EW_FILE|EW_SILENT) == FAIL
+	    || filecount == 0)
+    {
+	if (!got_int)
+	    EMSG2(_("E151: No match: %s"), NameBuff);
+	return;
+    }
+
+    /*
+     * Open the tags file for writing.
+     * Do this before scanning through all the files.
+     */
+    STRCPY(NameBuff, dir);
+    add_pathsep(NameBuff);
+    STRCAT(NameBuff, tagfname);
+    fd_tags = mch_fopen((char *)NameBuff, "w");
+    if (fd_tags == NULL)
+    {
+	EMSG2(_("E152: Cannot open %s for writing"), NameBuff);
+	FreeWild(filecount, files);
+	return;
+    }
+
+    /*
+     * If using the "++t" argument or generating tags for "$VIMRUNTIME/doc"
+     * add the "help-tags" tag.
+     */
+    ga_init2(&ga, (int)sizeof(char_u *), 100);
+    if (add_help_tags || fullpathcmp((char_u *)"$VIMRUNTIME/doc",
+						      dir, FALSE) == FPC_SAME)
+    {
+	if (ga_grow(&ga, 1) == FAIL)
+	    got_int = TRUE;
+	else
+	{
+	    s = alloc(18 + (unsigned)STRLEN(tagfname));
+	    if (s == NULL)
+		got_int = TRUE;
+	    else
+	    {
+		sprintf((char *)s, "help-tags\t%s\t1\n", tagfname);
+		((char_u **)ga.ga_data)[ga.ga_len] = s;
+		++ga.ga_len;
+	    }
+	}
+    }
+
+    /*
+     * Go over all the files and extract the tags.
+     */
+    for (fi = 0; fi < filecount && !got_int; ++fi)
+    {
+	fd = mch_fopen((char *)files[fi], "r");
+	if (fd == NULL)
+	{
+	    EMSG2(_("E153: Unable to open %s for reading"), files[fi]);
+	    continue;
+	}
+	fname = files[fi] + dirlen + 1;
+
+# ifdef FEAT_MBYTE
+	firstline = TRUE;
+# endif
+	while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int)
+	{
+# ifdef FEAT_MBYTE
+	    if (firstline)
+	    {
+		/* Detect utf-8 file by a non-ASCII char in the first line. */
+		this_utf8 = MAYBE;
+		for (s = IObuff; *s != NUL; ++s)
+		    if (*s >= 0x80)
+		    {
+			int l;
+
+			this_utf8 = TRUE;
+			l = utf_ptr2len(s);
+			if (l == 1)
+			{
+			    /* Illegal UTF-8 byte sequence. */
+			    this_utf8 = FALSE;
+			    break;
+			}
+			s += l - 1;
+		    }
+		if (this_utf8 == MAYBE)	    /* only ASCII characters found */
+		    this_utf8 = FALSE;
+		if (utf8 == MAYBE)	    /* first file */
+		    utf8 = this_utf8;
+		else if (utf8 != this_utf8)
+		{
+		    EMSG2(_("E670: Mix of help file encodings within a language: %s"), files[fi]);
+		    mix = !got_int;
+		    got_int = TRUE;
+		}
+		firstline = FALSE;
+	    }
+# endif
+	    p1 = vim_strchr(IObuff, '*');	/* find first '*' */
+	    while (p1 != NULL)
+	    {
+		/* Use vim_strbyte() instead of vim_strchr() so that when
+		 * 'encoding' is dbcs it still works, don't find '*' in the
+		 * second byte. */
+		p2 = vim_strbyte(p1 + 1, '*');	/* find second '*' */
+		if (p2 != NULL && p2 > p1 + 1)	/* skip "*" and "**" */
+		{
+		    for (s = p1 + 1; s < p2; ++s)
+			if (*s == ' ' || *s == '\t' || *s == '|')
+			    break;
+
+		    /*
+		     * Only accept a *tag* when it consists of valid
+		     * characters, there is white space before it and is
+		     * followed by a white character or end-of-line.
+		     */
+		    if (s == p2
+			    && (p1 == IObuff || p1[-1] == ' ' || p1[-1] == '\t')
+			    && (vim_strchr((char_u *)" \t\n\r", s[1]) != NULL
+				|| s[1] == '\0'))
+		    {
+			*p2 = '\0';
+			++p1;
+			if (ga_grow(&ga, 1) == FAIL)
+			{
+			    got_int = TRUE;
+			    break;
+			}
+			s = alloc((unsigned)(p2 - p1 + STRLEN(fname) + 2));
+			if (s == NULL)
+			{
+			    got_int = TRUE;
+			    break;
+			}
+			((char_u **)ga.ga_data)[ga.ga_len] = s;
+			++ga.ga_len;
+			sprintf((char *)s, "%s\t%s", p1, fname);
+
+			/* find next '*' */
+			p2 = vim_strchr(p2 + 1, '*');
+		    }
+		}
+		p1 = p2;
+	    }
+	    line_breakcheck();
+	}
+
+	fclose(fd);
+    }
+
+    FreeWild(filecount, files);
+
+    if (!got_int)
+    {
+	/*
+	 * Sort the tags.
+	 */
+	if (ga.ga_data != NULL)
+	    sort_strings((char_u **)ga.ga_data, ga.ga_len);
+
+	/*
+	 * Check for duplicates.
+	 */
+	for (i = 1; i < ga.ga_len; ++i)
+	{
+	    p1 = ((char_u **)ga.ga_data)[i - 1];
+	    p2 = ((char_u **)ga.ga_data)[i];
+	    while (*p1 == *p2)
+	    {
+		if (*p2 == '\t')
+		{
+		    *p2 = NUL;
+		    vim_snprintf((char *)NameBuff, MAXPATHL,
+			    _("E154: Duplicate tag \"%s\" in file %s/%s"),
+				     ((char_u **)ga.ga_data)[i], dir, p2 + 1);
+		    EMSG(NameBuff);
+		    *p2 = '\t';
+		    break;
+		}
+		++p1;
+		++p2;
+	    }
+	}
+
+# ifdef FEAT_MBYTE
+	if (utf8 == TRUE)
+	    fprintf(fd_tags, "!_TAG_FILE_ENCODING\tutf-8\t//\n");
+# endif
+
+	/*
+	 * Write the tags into the file.
+	 */
+	for (i = 0; i < ga.ga_len; ++i)
+	{
+	    s = ((char_u **)ga.ga_data)[i];
+	    if (STRNCMP(s, "help-tags\t", 10) == 0)
+		/* help-tags entry was added in formatted form */
+		fputs((char *)s, fd_tags);
+	    else
+	    {
+		fprintf(fd_tags, "%s\t/*", s);
+		for (p1 = s; *p1 != '\t'; ++p1)
+		{
+		    /* insert backslash before '\\' and '/' */
+		    if (*p1 == '\\' || *p1 == '/')
+			putc('\\', fd_tags);
+		    putc(*p1, fd_tags);
+		}
+		fprintf(fd_tags, "*\n");
+	    }
+	}
+    }
+#ifdef FEAT_MBYTE
+    if (mix)
+	got_int = FALSE;    /* continue with other languages */
+#endif
+
+    for (i = 0; i < ga.ga_len; ++i)
+	vim_free(((char_u **)ga.ga_data)[i]);
+    ga_clear(&ga);
+    fclose(fd_tags);	    /* there is no check for an error... */
+}
+
+/*
+ * Generate tags in one help directory, taking care of translations.
+ */
+    static void
+do_helptags(char_u *dirname, int add_help_tags)
+{
+#ifdef FEAT_MULTI_LANG
+    int		len;
+    int		i, j;
+    garray_T	ga;
+    char_u	lang[2];
+    char_u	ext[5];
+    char_u	fname[8];
+    int		filecount;
+    char_u	**files;
+
+    /* Get a list of all files in the help directory and in subdirectories. */
+    STRCPY(NameBuff, dirname);
+    add_pathsep(NameBuff);
+    STRCAT(NameBuff, "**");
+    if (gen_expand_wildcards(1, &NameBuff, &filecount, &files,
+						    EW_FILE|EW_SILENT) == FAIL
+	    || filecount == 0)
+    {
+	EMSG2(_("E151: No match: %s"), NameBuff);
+	return;
+    }
+
+    /* Go over all files in the directory to find out what languages are
+     * present. */
+    ga_init2(&ga, 1, 10);
+    for (i = 0; i < filecount; ++i)
+    {
+	len = (int)STRLEN(files[i]);
+	if (len > 4)
+	{
+	    if (STRICMP(files[i] + len - 4, ".txt") == 0)
+	    {
+		/* ".txt" -> language "en" */
+		lang[0] = 'e';
+		lang[1] = 'n';
+	    }
+	    else if (files[i][len - 4] == '.'
+		    && ASCII_ISALPHA(files[i][len - 3])
+		    && ASCII_ISALPHA(files[i][len - 2])
+		    && TOLOWER_ASC(files[i][len - 1]) == 'x')
+	    {
+		/* ".abx" -> language "ab" */
+		lang[0] = TOLOWER_ASC(files[i][len - 3]);
+		lang[1] = TOLOWER_ASC(files[i][len - 2]);
+	    }
+	    else
+		continue;
+
+	    /* Did we find this language already? */
+	    for (j = 0; j < ga.ga_len; j += 2)
+		if (STRNCMP(lang, ((char_u *)ga.ga_data) + j, 2) == 0)
+		    break;
+	    if (j == ga.ga_len)
+	    {
+		/* New language, add it. */
+		if (ga_grow(&ga, 2) == FAIL)
+		    break;
+		((char_u *)ga.ga_data)[ga.ga_len++] = lang[0];
+		((char_u *)ga.ga_data)[ga.ga_len++] = lang[1];
+	    }
+	}
+    }
+
+    /*
+     * Loop over the found languages to generate a tags file for each one.
+     */
+    for (j = 0; j < ga.ga_len; j += 2)
+    {
+	STRCPY(fname, "tags-xx");
+	fname[5] = ((char_u *)ga.ga_data)[j];
+	fname[6] = ((char_u *)ga.ga_data)[j + 1];
+	if (fname[5] == 'e' && fname[6] == 'n')
+	{
+	    /* English is an exception: use ".txt" and "tags". */
+	    fname[4] = NUL;
+	    STRCPY(ext, ".txt");
+	}
+	else
+	{
+	    /* Language "ab" uses ".abx" and "tags-ab". */
+	    STRCPY(ext, ".xxx");
+	    ext[1] = fname[5];
+	    ext[2] = fname[6];
+	}
+	helptags_one(dirname, ext, fname, add_help_tags);
+    }
+
+    ga_clear(&ga);
+    FreeWild(filecount, files);
+
+#else
+    /* No language support, just use "*.txt" and "tags". */
+    helptags_one(dirname, (char_u *)".txt", (char_u *)"tags", add_help_tags);
+#endif
+}
+
+    static void
+helptags_cb(char_u *fname, void *cookie)
+{
+    do_helptags(fname, *(int *)cookie);
+}
+
+/*
+ * ":helptags"
+ */
+    void
+ex_helptags(exarg_T *eap)
+{
+    expand_T	xpc;
+    char_u	*dirname;
+    int		add_help_tags = FALSE;
+
+    /* Check for ":helptags ++t {dir}". */
+    if (STRNCMP(eap->arg, "++t", 3) == 0 && VIM_ISWHITE(eap->arg[3]))
+    {
+	add_help_tags = TRUE;
+	eap->arg = skipwhite(eap->arg + 3);
+    }
+
+    if (STRCMP(eap->arg, "ALL") == 0)
+    {
+	do_in_path(p_rtp, (char_u *)"doc", DIP_ALL + DIP_DIR,
+						 helptags_cb, &add_help_tags);
+    }
+    else
+    {
+	ExpandInit(&xpc);
+	xpc.xp_context = EXPAND_DIRECTORIES;
+	dirname = ExpandOne(&xpc, eap->arg, NULL,
+			    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);
+	if (dirname == NULL || !mch_isdir(dirname))
+	    EMSG2(_("E150: Not a directory: %s"), eap->arg);
+	else
+	    do_helptags(dirname, add_help_tags);
+	vim_free(dirname);
+    }
+}
+
+#if defined(FEAT_SIGNS) || defined(PROTO)
+
+/*
+ * Struct to hold the sign properties.
+ */
+typedef struct sign sign_T;
+
+struct sign
+{
+    sign_T	*sn_next;	/* next sign in list */
+    int		sn_typenr;	/* type number of sign */
+    char_u	*sn_name;	/* name of sign */
+    char_u	*sn_icon;	/* name of pixmap */
+# ifdef FEAT_SIGN_ICONS
+    void	*sn_image;	/* icon image */
+# endif
+    char_u	*sn_text;	/* text used instead of pixmap */
+    int		sn_line_hl;	/* highlight ID for line */
+    int		sn_text_hl;	/* highlight ID for text */
+};
+
+static sign_T	*first_sign = NULL;
+static int	next_sign_typenr = 1;
+
+static int sign_cmd_idx(char_u *begin_cmd, char_u *end_cmd);
+static void sign_list_defined(sign_T *sp);
+static void sign_undefine(sign_T *sp, sign_T *sp_prev);
+
+static char *cmds[] = {
+			"define",
+# define SIGNCMD_DEFINE	0
+			"undefine",
+# define SIGNCMD_UNDEFINE 1
+			"list",
+# define SIGNCMD_LIST	2
+			"place",
+# define SIGNCMD_PLACE	3
+			"unplace",
+# define SIGNCMD_UNPLACE 4
+			"jump",
+# define SIGNCMD_JUMP	5
+			NULL
+# define SIGNCMD_LAST	6
+};
+
+/*
+ * Find index of a ":sign" subcmd from its name.
+ * "*end_cmd" must be writable.
+ */
+    static int
+sign_cmd_idx(
+    char_u	*begin_cmd,	/* begin of sign subcmd */
+    char_u	*end_cmd)	/* just after sign subcmd */
+{
+    int		idx;
+    char	save = *end_cmd;
+
+    *end_cmd = NUL;
+    for (idx = 0; ; ++idx)
+	if (cmds[idx] == NULL || STRCMP(begin_cmd, cmds[idx]) == 0)
+	    break;
+    *end_cmd = save;
+    return idx;
+}
+
+/*
+ * ":sign" command
+ */
+    void
+ex_sign(exarg_T *eap)
+{
+    char_u	*arg = eap->arg;
+    char_u	*p;
+    int		idx;
+    sign_T	*sp;
+    sign_T	*sp_prev;
+    buf_T	*buf = NULL;
+
+    /* Parse the subcommand. */
+    p = skiptowhite(arg);
+    idx = sign_cmd_idx(arg, p);
+    if (idx == SIGNCMD_LAST)
+    {
+	EMSG2(_("E160: Unknown sign command: %s"), arg);
+	return;
+    }
+    arg = skipwhite(p);
+
+    if (idx <= SIGNCMD_LIST)
+    {
+	/*
+	 * Define, undefine or list signs.
+	 */
+	if (idx == SIGNCMD_LIST && *arg == NUL)
+	{
+	    /* ":sign list": list all defined signs */
+	    for (sp = first_sign; sp != NULL && !got_int; sp = sp->sn_next)
+		sign_list_defined(sp);
+	}
+	else if (*arg == NUL)
+	    EMSG(_("E156: Missing sign name"));
+	else
+	{
+	    /* Isolate the sign name.  If it's a number skip leading zeroes,
+	     * so that "099" and "99" are the same sign.  But keep "0". */
+	    p = skiptowhite(arg);
+	    if (*p != NUL)
+		*p++ = NUL;
+	    while (arg[0] == '0' && arg[1] != NUL)
+		++arg;
+
+	    sp_prev = NULL;
+	    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	    {
+		if (STRCMP(sp->sn_name, arg) == 0)
+		    break;
+		sp_prev = sp;
+	    }
+	    if (idx == SIGNCMD_DEFINE)
+	    {
+		/* ":sign define {name} ...": define a sign */
+		if (sp == NULL)
+		{
+		    sign_T	*lp;
+		    int		start = next_sign_typenr;
+
+		    /* Allocate a new sign. */
+		    sp = (sign_T *)alloc_clear((unsigned)sizeof(sign_T));
+		    if (sp == NULL)
+			return;
+
+		    /* Check that next_sign_typenr is not already being used.
+		     * This only happens after wrapping around.  Hopefully
+		     * another one got deleted and we can use its number. */
+		    for (lp = first_sign; lp != NULL; )
+		    {
+			if (lp->sn_typenr == next_sign_typenr)
+			{
+			    ++next_sign_typenr;
+			    if (next_sign_typenr == MAX_TYPENR)
+				next_sign_typenr = 1;
+			    if (next_sign_typenr == start)
+			    {
+				vim_free(sp);
+				EMSG(_("E612: Too many signs defined"));
+				return;
+			    }
+			    lp = first_sign;  /* start all over */
+			    continue;
+			}
+			lp = lp->sn_next;
+		    }
+
+		    sp->sn_typenr = next_sign_typenr;
+		    if (++next_sign_typenr == MAX_TYPENR)
+			next_sign_typenr = 1; /* wrap around */
+
+		    sp->sn_name = vim_strsave(arg);
+		    if (sp->sn_name == NULL)  /* out of memory */
+		    {
+			vim_free(sp);
+			return;
+		    }
+
+		    /* add the new sign to the list of signs */
+		    if (sp_prev == NULL)
+			first_sign = sp;
+		    else
+			sp_prev->sn_next = sp;
+		}
+
+		/* set values for a defined sign. */
+		for (;;)
+		{
+		    arg = skipwhite(p);
+		    if (*arg == NUL)
+			break;
+		    p = skiptowhite_esc(arg);
+		    if (STRNCMP(arg, "icon=", 5) == 0)
+		    {
+			arg += 5;
+			vim_free(sp->sn_icon);
+			sp->sn_icon = vim_strnsave(arg, (int)(p - arg));
+			backslash_halve(sp->sn_icon);
+# ifdef FEAT_SIGN_ICONS
+			if (gui.in_use)
+			{
+			    out_flush();
+			    if (sp->sn_image != NULL)
+				gui_mch_destroy_sign(sp->sn_image);
+			    sp->sn_image = gui_mch_register_sign(sp->sn_icon);
+			}
+# endif
+		    }
+		    else if (STRNCMP(arg, "text=", 5) == 0)
+		    {
+			char_u	*s;
+			int	cells;
+			int	len;
+
+			arg += 5;
+# ifdef FEAT_MBYTE
+			/* Count cells and check for non-printable chars */
+			if (has_mbyte)
+			{
+			    cells = 0;
+			    for (s = arg; s < p; s += (*mb_ptr2len)(s))
+			    {
+				if (!vim_isprintc((*mb_ptr2char)(s)))
+				    break;
+				cells += (*mb_ptr2cells)(s);
+			    }
+			}
+			else
+# endif
+			{
+			    for (s = arg; s < p; ++s)
+				if (!vim_isprintc(*s))
+				    break;
+			    cells = (int)(s - arg);
+			}
+			/* Currently must be one or two display cells */
+			if (s != p || cells < 1 || cells > 2)
+			{
+			    *p = NUL;
+			    EMSG2(_("E239: Invalid sign text: %s"), arg);
+			    return;
+			}
+
+			vim_free(sp->sn_text);
+			/* Allocate one byte more if we need to pad up
+			 * with a space. */
+			len = (int)(p - arg + ((cells == 1) ? 1 : 0));
+			sp->sn_text = vim_strnsave(arg, len);
+
+			if (sp->sn_text != NULL && cells == 1)
+			    STRCPY(sp->sn_text + len - 1, " ");
+		    }
+		    else if (STRNCMP(arg, "linehl=", 7) == 0)
+		    {
+			arg += 7;
+			sp->sn_line_hl = syn_check_group(arg, (int)(p - arg));
+		    }
+		    else if (STRNCMP(arg, "texthl=", 7) == 0)
+		    {
+			arg += 7;
+			sp->sn_text_hl = syn_check_group(arg, (int)(p - arg));
+		    }
+		    else
+		    {
+			EMSG2(_(e_invarg2), arg);
+			return;
+		    }
+		}
+	    }
+	    else if (sp == NULL)
+		EMSG2(_("E155: Unknown sign: %s"), arg);
+	    else if (idx == SIGNCMD_LIST)
+		/* ":sign list {name}" */
+		sign_list_defined(sp);
+	    else
+		/* ":sign undefine {name}" */
+		sign_undefine(sp, sp_prev);
+	}
+    }
+    else
+    {
+	int		id = -1;
+	linenr_T	lnum = -1;
+	char_u		*sign_name = NULL;
+	char_u		*arg1;
+
+	if (*arg == NUL)
+	{
+	    if (idx == SIGNCMD_PLACE)
+	    {
+		/* ":sign place": list placed signs in all buffers */
+		sign_list_placed(NULL);
+	    }
+	    else if (idx == SIGNCMD_UNPLACE)
+	    {
+		/* ":sign unplace": remove placed sign at cursor */
+		id = buf_findsign_id(curwin->w_buffer, curwin->w_cursor.lnum);
+		if (id > 0)
+		{
+		    buf_delsign(curwin->w_buffer, id);
+		    update_debug_sign(curwin->w_buffer, curwin->w_cursor.lnum);
+		}
+		else
+		    EMSG(_("E159: Missing sign number"));
+	    }
+	    else
+		EMSG(_(e_argreq));
+	    return;
+	}
+
+	if (idx == SIGNCMD_UNPLACE && arg[0] == '*' && arg[1] == NUL)
+	{
+	    /* ":sign unplace *": remove all placed signs */
+	    buf_delete_all_signs();
+	    return;
+	}
+
+	/* first arg could be placed sign id */
+	arg1 = arg;
+	if (VIM_ISDIGIT(*arg))
+	{
+	    id = getdigits(&arg);
+	    if (!VIM_ISWHITE(*arg) && *arg != NUL)
+	    {
+		id = -1;
+		arg = arg1;
+	    }
+	    else
+	    {
+		arg = skipwhite(arg);
+		if (idx == SIGNCMD_UNPLACE && *arg == NUL)
+		{
+		    /* ":sign unplace {id}": remove placed sign by number */
+		    FOR_ALL_BUFFERS(buf)
+			if ((lnum = buf_delsign(buf, id)) != 0)
+			    update_debug_sign(buf, lnum);
+		    return;
+		}
+	    }
+	}
+
+	/*
+	 * Check for line={lnum} name={name} and file={fname} or buffer={nr}.
+	 * Leave "arg" pointing to {fname}.
+	 */
+	for (;;)
+	{
+	    if (STRNCMP(arg, "line=", 5) == 0)
+	    {
+		arg += 5;
+		lnum = atoi((char *)arg);
+		arg = skiptowhite(arg);
+	    }
+	    else if (STRNCMP(arg, "*", 1) == 0 && idx == SIGNCMD_UNPLACE)
+	    {
+		if (id != -1)
+		{
+		    EMSG(_(e_invarg));
+		    return;
+		}
+		id = -2;
+		arg = skiptowhite(arg + 1);
+	    }
+	    else if (STRNCMP(arg, "name=", 5) == 0)
+	    {
+		arg += 5;
+		sign_name = arg;
+		arg = skiptowhite(arg);
+		if (*arg != NUL)
+		    *arg++ = NUL;
+		while (sign_name[0] == '0' && sign_name[1] != NUL)
+		    ++sign_name;
+	    }
+	    else if (STRNCMP(arg, "file=", 5) == 0)
+	    {
+		arg += 5;
+		buf = buflist_findname(arg);
+		break;
+	    }
+	    else if (STRNCMP(arg, "buffer=", 7) == 0)
+	    {
+		arg += 7;
+		buf = buflist_findnr((int)getdigits(&arg));
+		if (*skipwhite(arg) != NUL)
+		    EMSG(_(e_trailing));
+		break;
+	    }
+	    else
+	    {
+		EMSG(_(e_invarg));
+		return;
+	    }
+	    arg = skipwhite(arg);
+	}
+
+	if (buf == NULL)
+	{
+	    EMSG2(_("E158: Invalid buffer name: %s"), arg);
+	}
+	else if (id <= 0 && !(idx == SIGNCMD_UNPLACE && id == -2))
+	{
+	    if (lnum >= 0 || sign_name != NULL)
+		EMSG(_(e_invarg));
+	    else
+		/* ":sign place file={fname}": list placed signs in one file */
+		sign_list_placed(buf);
+	}
+	else if (idx == SIGNCMD_JUMP)
+	{
+	    /* ":sign jump {id} file={fname}" */
+	    if (lnum >= 0 || sign_name != NULL)
+		EMSG(_(e_invarg));
+	    else if ((lnum = buf_findsign(buf, id)) > 0)
+	    {				/* goto a sign ... */
+		if (buf_jump_open_win(buf) != NULL)
+		{			/* ... in a current window */
+		    curwin->w_cursor.lnum = lnum;
+		    check_cursor_lnum();
+		    beginline(BL_WHITE);
+		}
+		else
+		{			/* ... not currently in a window */
+		    char_u	*cmd;
+
+		    if (buf->b_fname == NULL)
+		    {
+			EMSG(_("E934: Cannot jump to a buffer that does not have a name"));
+			return;
+		    }
+		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
+		    if (cmd == NULL)
+			return;
+		    sprintf((char *)cmd, "e +%ld %s", (long)lnum, buf->b_fname);
+		    do_cmdline_cmd(cmd);
+		    vim_free(cmd);
+		}
+# ifdef FEAT_FOLDING
+		foldOpenCursor();
+# endif
+	    }
+	    else
+		EMSGN(_("E157: Invalid sign ID: %ld"), id);
+	}
+	else if (idx == SIGNCMD_UNPLACE)
+	{
+	    if (lnum >= 0 || sign_name != NULL)
+		EMSG(_(e_invarg));
+	    else if (id == -2)
+	    {
+		/* ":sign unplace * file={fname}" */
+		redraw_buf_later(buf, NOT_VALID);
+		buf_delete_signs(buf);
+	    }
+	    else
+	    {
+		/* ":sign unplace {id} file={fname}" */
+		lnum = buf_delsign(buf, id);
+		update_debug_sign(buf, lnum);
+	    }
+	}
+	    /* idx == SIGNCMD_PLACE */
+	else if (sign_name != NULL)
+	{
+	    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+		if (STRCMP(sp->sn_name, sign_name) == 0)
+		    break;
+	    if (sp == NULL)
+	    {
+		EMSG2(_("E155: Unknown sign: %s"), sign_name);
+		return;
+	    }
+	    if (lnum > 0)
+		/* ":sign place {id} line={lnum} name={name} file={fname}":
+		 * place a sign */
+		buf_addsign(buf, id, lnum, sp->sn_typenr);
+	    else
+		/* ":sign place {id} file={fname}": change sign type */
+		lnum = buf_change_sign_type(buf, id, sp->sn_typenr);
+	    if (lnum > 0)
+		update_debug_sign(buf, lnum);
+	    else
+		EMSG2(_("E885: Not possible to change sign %s"), sign_name);
+	}
+	else
+	    EMSG(_(e_invarg));
+    }
+}
+
+# if defined(FEAT_SIGN_ICONS) || defined(PROTO)
+/*
+ * Allocate the icons.  Called when the GUI has started.  Allows defining
+ * signs before it starts.
+ */
+    void
+sign_gui_started(void)
+{
+    sign_T	*sp;
+
+    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	if (sp->sn_icon != NULL)
+	    sp->sn_image = gui_mch_register_sign(sp->sn_icon);
+}
+# endif
+
+/*
+ * List one sign.
+ */
+    static void
+sign_list_defined(sign_T *sp)
+{
+    char_u	*p;
+
+    smsg((char_u *)"sign %s", sp->sn_name);
+    if (sp->sn_icon != NULL)
+    {
+	MSG_PUTS(" icon=");
+	msg_outtrans(sp->sn_icon);
+# ifdef FEAT_SIGN_ICONS
+	if (sp->sn_image == NULL)
+	    MSG_PUTS(_(" (NOT FOUND)"));
+# else
+	MSG_PUTS(_(" (not supported)"));
+# endif
+    }
+    if (sp->sn_text != NULL)
+    {
+	MSG_PUTS(" text=");
+	msg_outtrans(sp->sn_text);
+    }
+    if (sp->sn_line_hl > 0)
+    {
+	MSG_PUTS(" linehl=");
+	p = get_highlight_name_ext(NULL, sp->sn_line_hl - 1, FALSE);
+	if (p == NULL)
+	    MSG_PUTS("NONE");
+	else
+	    msg_puts(p);
+    }
+    if (sp->sn_text_hl > 0)
+    {
+	MSG_PUTS(" texthl=");
+	p = get_highlight_name_ext(NULL, sp->sn_text_hl - 1, FALSE);
+	if (p == NULL)
+	    MSG_PUTS("NONE");
+	else
+	    msg_puts(p);
+    }
+}
+
+/*
+ * Undefine a sign and free its memory.
+ */
+    static void
+sign_undefine(sign_T *sp, sign_T *sp_prev)
+{
+    vim_free(sp->sn_name);
+    vim_free(sp->sn_icon);
+# ifdef FEAT_SIGN_ICONS
+    if (sp->sn_image != NULL)
+    {
+	out_flush();
+	gui_mch_destroy_sign(sp->sn_image);
+    }
+# endif
+    vim_free(sp->sn_text);
+    if (sp_prev == NULL)
+	first_sign = sp->sn_next;
+    else
+	sp_prev->sn_next = sp->sn_next;
+    vim_free(sp);
+}
+
+/*
+ * Get highlighting attribute for sign "typenr".
+ * If "line" is TRUE: line highl, if FALSE: text highl.
+ */
+    int
+sign_get_attr(int typenr, int line)
+{
+    sign_T	*sp;
+
+    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	if (sp->sn_typenr == typenr)
+	{
+	    if (line)
+	    {
+		if (sp->sn_line_hl > 0)
+		    return syn_id2attr(sp->sn_line_hl);
+	    }
+	    else
+	    {
+		if (sp->sn_text_hl > 0)
+		    return syn_id2attr(sp->sn_text_hl);
+	    }
+	    break;
+	}
+    return 0;
+}
+
+/*
+ * Get text mark for sign "typenr".
+ * Returns NULL if there isn't one.
+ */
+    char_u *
+sign_get_text(int typenr)
+{
+    sign_T	*sp;
+
+    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	if (sp->sn_typenr == typenr)
+	    return sp->sn_text;
+    return NULL;
+}
+
+# if defined(FEAT_SIGN_ICONS) || defined(PROTO)
+    void *
+sign_get_image(
+    int		typenr)		/* the attribute which may have a sign */
+{
+    sign_T	*sp;
+
+    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	if (sp->sn_typenr == typenr)
+	    return sp->sn_image;
+    return NULL;
+}
+# endif
+
+/*
+ * Get the name of a sign by its typenr.
+ */
+    char_u *
+sign_typenr2name(int typenr)
+{
+    sign_T	*sp;
+
+    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	if (sp->sn_typenr == typenr)
+	    return sp->sn_name;
+    return (char_u *)_("[Deleted]");
+}
+
+# if defined(EXITFREE) || defined(PROTO)
+/*
+ * Undefine/free all signs.
+ */
+    void
+free_signs(void)
+{
+    while (first_sign != NULL)
+	sign_undefine(first_sign, NULL);
+}
+# endif
+
+# if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+static enum
+{
+    EXP_SUBCMD,		/* expand :sign sub-commands */
+    EXP_DEFINE,		/* expand :sign define {name} args */
+    EXP_PLACE,		/* expand :sign place {id} args */
+    EXP_UNPLACE,	/* expand :sign unplace" */
+    EXP_SIGN_NAMES	/* expand with name of placed signs */
+} expand_what;
+
+/*
+ * Function given to ExpandGeneric() to obtain the sign command
+ * expansion.
+ */
+    char_u *
+get_sign_name(expand_T *xp UNUSED, int idx)
+{
+    sign_T	*sp;
+    int		current_idx;
+
+    switch (expand_what)
+    {
+    case EXP_SUBCMD:
+	return (char_u *)cmds[idx];
+    case EXP_DEFINE:
+	{
+	    char *define_arg[] =
+	    {
+		"icon=", "linehl=", "text=", "texthl=", NULL
+	    };
+	    return (char_u *)define_arg[idx];
+	}
+    case EXP_PLACE:
+	{
+	    char *place_arg[] =
+	    {
+		"line=", "name=", "file=", "buffer=", NULL
+	    };
+	    return (char_u *)place_arg[idx];
+	}
+    case EXP_UNPLACE:
+	{
+	    char *unplace_arg[] = { "file=", "buffer=", NULL };
+	    return (char_u *)unplace_arg[idx];
+	}
+    case EXP_SIGN_NAMES:
+	/* Complete with name of signs already defined */
+	current_idx = 0;
+	for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	    if (current_idx++ == idx)
+		return sp->sn_name;
+	return NULL;
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :sign command.
+ */
+    void
+set_context_in_sign_cmd(expand_T *xp, char_u *arg)
+{
+    char_u	*p;
+    char_u	*end_subcmd;
+    char_u	*last;
+    int		cmd_idx;
+    char_u	*begin_subcmd_args;
+
+    /* Default: expand subcommands. */
+    xp->xp_context = EXPAND_SIGN;
+    expand_what = EXP_SUBCMD;
+    xp->xp_pattern = arg;
+
+    end_subcmd = skiptowhite(arg);
+    if (*end_subcmd == NUL)
+	/* expand subcmd name
+	 * :sign {subcmd}<CTRL-D>*/
+	return;
+
+    cmd_idx = sign_cmd_idx(arg, end_subcmd);
+
+    /* :sign {subcmd} {subcmd_args}
+     *		      |
+     *		      begin_subcmd_args */
+    begin_subcmd_args = skipwhite(end_subcmd);
+    p = skiptowhite(begin_subcmd_args);
+    if (*p == NUL)
+    {
+	/*
+	 * Expand first argument of subcmd when possible.
+	 * For ":jump {id}" and ":unplace {id}", we could
+	 * possibly expand the ids of all signs already placed.
+	 */
+	xp->xp_pattern = begin_subcmd_args;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_LIST:
+	    case SIGNCMD_UNDEFINE:
+		/* :sign list <CTRL-D>
+		 * :sign undefine <CTRL-D> */
+		expand_what = EXP_SIGN_NAMES;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+	return;
+    }
+
+    /* expand last argument of subcmd */
+
+    /* :sign define {name} {args}...
+     *		    |
+     *		    p */
+
+    /* Loop until reaching last argument. */
+    do
+    {
+	p = skipwhite(p);
+	last = p;
+	p = skiptowhite(p);
+    } while (*p != NUL);
+
+    p = vim_strchr(last, '=');
+
+    /* :sign define {name} {args}... {last}=
+     *				     |	   |
+     *				  last	   p */
+    if (p == NULL)
+    {
+	/* Expand last argument name (before equal sign). */
+	xp->xp_pattern = last;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		expand_what = EXP_DEFINE;
+		break;
+	    case SIGNCMD_PLACE:
+		expand_what = EXP_PLACE;
+		break;
+	    case SIGNCMD_JUMP:
+	    case SIGNCMD_UNPLACE:
+		expand_what = EXP_UNPLACE;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+    else
+    {
+	/* Expand last argument value (after equal sign). */
+	xp->xp_pattern = p + 1;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		if (STRNCMP(last, "texthl", p - last) == 0 ||
+		    STRNCMP(last, "linehl", p - last) == 0)
+		    xp->xp_context = EXPAND_HIGHLIGHT;
+		else if (STRNCMP(last, "icon", p - last) == 0)
+		    xp->xp_context = EXPAND_FILES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    case SIGNCMD_PLACE:
+		if (STRNCMP(last, "name", p - last) == 0)
+		    expand_what = EXP_SIGN_NAMES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+}
+# endif
+#endif
+
+/*
+ * Make the user happy.
+ */
+    void
+ex_smile(exarg_T *eap UNUSED)
+{
+    static char *code[] = {
+	"\34 \4o\14$\4ox\30 \2o\30$\1ox\25 \2o\36$\1o\11 \1o\1$\3 \2$\1 \1o\1$x\5 \1o\1 \1$\1 \2o\10 \1o\44$\1o\7 \2$\1 \2$\1 \2$\1o\1$x\2 \2o\1 \1$\1 \1$\1 \1\"\1$\6 \1o\11$\4 \15$\4 \11$\1o\7 \3$\1o\2$\1o\1$x\2 \1\"\6$\1o\1$\5 \1o\11$\6 \13$\6 \12$\1o\4 \10$x\4 \7$\4 \13$\6 \13$\6 \27$x\4 \27$\4 \15$\4 \16$\2 \3\"\3$x\5 \1\"\3$\4\"\61$\5 \1\"\3$x\6 \3$\3 \1o\62$\5 \1\"\3$\1ox\5 \1o\2$\1\"\3 \63$\7 \3$\1ox\5 \3$\4 \55$\1\"\1 \1\"\6$",
+	"\5o\4$\1ox\4 \1o\3$\4o\5$\2 \45$\3 \1o\21$x\4 \10$\1\"\4$\3 \42$\5 \4$\10\"x\3 \4\"\7 \4$\4 \1\"\34$\1\"\6 \1o\3$x\16 \1\"\3$\1o\5 \3\"\22$\1\"\2$\1\"\11 \3$x\20 \3$\1o\12 \1\"\2$\2\"\6$\4\"\13 \1o\3$x\21 \4$\1o\40 \1o\3$\1\"x\22 \1\"\4$\1o\6 \1o\6$\1o\1\"\4$\1o\10 \1o\4$x\24 \1\"\5$\2o\5 \2\"\4$\1o\5$\1o\3 \1o\4$\2\"x\27 \2\"\5$\4o\2 \1\"\3$\1o\11$\3\"x\32 \2\"\7$\2o\1 \12$x\42 \4\"\13$x\46 \14$x\47 \12$\1\"x\50 \1\"\3$\4\"x"
+    };
+    char *p;
+    int n;
+    int i;
+
+    msg_start();
+    msg_putchar('\n');
+    for (i = 0; i < 2; ++i)
+	for (p = code[i]; *p != NUL; ++p)
+	    if (*p == 'x')
+		msg_putchar('\n');
+	    else
+		for (n = *p++; n > 0; --n)
+		    if (*p == 'o' || *p == '$')
+			msg_putchar_attr(*p, HL_ATTR(HLF_L));
+		    else
+			msg_putchar(*p);
+    msg_clr_eos();
+}
+
+/*
+ * ":drop"
+ * Opens the first argument in a window.  When there are two or more arguments
+ * the argument list is redefined.
+ */
+    void
+ex_drop(exarg_T *eap)
+{
+    int		split = FALSE;
+    win_T	*wp;
+    buf_T	*buf;
+    tabpage_T	*tp;
+
+    /*
+     * Check if the first argument is already being edited in a window.  If
+     * so, jump to that window.
+     * We would actually need to check all arguments, but that's complicated
+     * and mostly only one file is dropped.
+     * This also ignores wildcards, since it is very unlikely the user is
+     * editing a file name with a wildcard character.
+     */
+    set_arglist(eap->arg);
+
+    /*
+     * Expanding wildcards may result in an empty argument list.  E.g. when
+     * editing "foo.pyc" and ".pyc" is in 'wildignore'.  Assume that we
+     * already did an error message for this.
+     */
+    if (ARGCOUNT == 0)
+	return;
+
+    if (cmdmod.tab)
+    {
+	/* ":tab drop file ...": open a tab for each argument that isn't
+	 * edited in a window yet.  It's like ":tab all" but without closing
+	 * windows or tabs. */
+	ex_all(eap);
+    }
+    else
+    {
+	/* ":drop file ...": Edit the first argument.  Jump to an existing
+	 * window if possible, edit in current window if the current buffer
+	 * can be abandoned, otherwise open a new window. */
+	buf = buflist_findnr(ARGLIST[0].ae_fnum);
+
+	FOR_ALL_TAB_WINDOWS(tp, wp)
+	{
+	    if (wp->w_buffer == buf)
+	    {
+		goto_tabpage_win(tp, wp);
+		curwin->w_arg_idx = 0;
+		return;
+	    }
+	}
+
+	/*
+	 * Check whether the current buffer is changed. If so, we will need
+	 * to split the current window or data could be lost.
+	 * Skip the check if the 'hidden' option is set, as in this case the
+	 * buffer won't be lost.
+	 */
+	if (!buf_hide(curbuf))
+	{
+	    ++emsg_off;
+	    split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);
+	    --emsg_off;
+	}
+
+	/* Fake a ":sfirst" or ":first" command edit the first argument. */
+	if (split)
+	{
+	    eap->cmdidx = CMD_sfirst;
+	    eap->cmd[0] = 's';
+	}
+	else
+	    eap->cmdidx = CMD_first;
+	ex_rewind(eap);
+    }
+}
+
+/*
+ * Skip over the pattern argument of ":vimgrep /pat/[g][j]".
+ * Put the start of the pattern in "*s", unless "s" is NULL.
+ * If "flags" is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.
+ * If "s" is not NULL terminate the pattern with a NUL.
+ * Return a pointer to the char just past the pattern plus flags.
+ */
+    char_u *
+skip_vimgrep_pat(char_u *p, char_u **s, int *flags)
+{
+    int		c;
+
+    if (vim_isIDc(*p))
+    {
+	/* ":vimgrep pattern fname" */
+	if (s != NULL)
+	    *s = p;
+	p = skiptowhite(p);
+	if (s != NULL && *p != NUL)
+	    *p++ = NUL;
+    }
+    else
+    {
+	/* ":vimgrep /pattern/[g][j] fname" */
+	if (s != NULL)
+	    *s = p + 1;
+	c = *p;
+	p = skip_regexp(p + 1, c, TRUE, NULL);
+	if (*p != c)
+	    return NULL;
+
+	/* Truncate the pattern. */
+	if (s != NULL)
+	    *p = NUL;
+	++p;
+
+	/* Find the flags */
+	while (*p == 'g' || *p == 'j')
+	{
+	    if (flags != NULL)
+	    {
+		if (*p == 'g')
+		    *flags |= VGR_GLOBAL;
+		else
+		    *flags |= VGR_NOJUMP;
+	    }
+	    ++p;
+	}
+    }
+    return p;
+}
+
+#if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * List v:oldfiles in a nice way.
+ */
+    void
+ex_oldfiles(exarg_T *eap UNUSED)
+{
+    list_T	*l = get_vim_var_list(VV_OLDFILES);
+    listitem_T	*li;
+    int		nr = 0;
+    char_u	*fname;
+
+    if (l == NULL)
+	msg((char_u *)_("No old files"));
+    else
+    {
+	msg_start();
+	msg_scroll = TRUE;
+	for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)
+	{
+	    ++nr;
+	    fname = get_tv_string(&li->li_tv);
+	    if (!message_filtered(fname))
+	    {
+		msg_outnum((long)nr);
+		MSG_PUTS(": ");
+		msg_outtrans(fname);
+		msg_clr_eos();
+		msg_putchar('\n');
+		out_flush();	    /* output one line at a time */
+		ui_breakcheck();
+	    }
+	}
+
+	/* Assume "got_int" was set to truncate the listing. */
+	got_int = FALSE;
+
+# ifdef FEAT_BROWSE_CMD
+	if (cmdmod.browse)
+	{
+	    quit_more = FALSE;
+	    nr = prompt_for_number(FALSE);
+	    msg_starthere();
+	    if (nr > 0)
+	    {
+		char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),
+								    (long)nr);
+
+		if (p != NULL)
+		{
+		    p = expand_env_save(p);
+		    eap->arg = p;
+		    eap->cmdidx = CMD_edit;
+		    cmdmod.browse = FALSE;
+		    do_exedit(eap, NULL);
+		    vim_free(p);
+		}
+	    }
+	}
+# endif
+    }
+}
+#endif
diff --git a/src/ex_docmd.c b/src/ex_docmd.c
index 5b53785..df992e8 100644
--- a/src/ex_docmd.c
+++ b/src/ex_docmd.c
@@ -184,7 +184,7 @@ static void	ex_tearoff(exarg_T *eap);
 #else
 # define ex_tearoff		ex_ni
 #endif
-#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \
+#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU) || defined(FEAT_GUI_GTK) \
 	|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)
 static void	ex_popup(exarg_T *eap);
 #else
@@ -193,11 +193,11 @@ static void	ex_popup(exarg_T *eap);
 #ifndef FEAT_GUI_MSWIN
 # define ex_simalt		ex_ni
 #endif
-#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)
+#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_HAIKU) && !defined(FEAT_GUI_MOTIF)
 # define gui_mch_find_dialog	ex_ni
 # define gui_mch_replace_dialog ex_ni
 #endif
-#if !defined(FEAT_GUI_GTK)
+#if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_HAIKU)
 # define ex_helpfind		ex_ni
 #endif
 #ifndef FEAT_CSCOPE
diff --git a/src/gui.c b/src/gui.c
index 82ca09d..b80c1ea 100644
--- a/src/gui.c
+++ b/src/gui.c
@@ -427,7 +427,7 @@ gui_init_check(void)
     gui.menu_width = 0;
 # endif
 #endif
-#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))
+#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_HAIKU))
     gui.toolbar_height = 0;
 #endif
 #if defined(FEAT_FOOTER) && defined(FEAT_GUI_MOTIF)
@@ -1369,10 +1369,10 @@ gui_position_components(int total_width UNUSED)
 	text_area_y += gui.tabline_height;
 #endif
 
-#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))
+#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_HAIKU))
     if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
     {
-# ifdef FEAT_GUI_ATHENA
+# if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_HAIKU)
 	gui_mch_set_toolbar_pos(0, text_area_y,
 				gui.menu_width, gui.toolbar_height);
 # endif
@@ -1380,6 +1380,13 @@ gui_position_components(int total_width UNUSED)
     }
 #endif
 
+# if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_HAIKU))
+	gui_mch_set_tabline_pos(0, text_area_y,
+				gui.menu_width, gui.tabline_height);
+    if (gui_has_tabline())
+		text_area_y += gui.tabline_height;
+#endif
+
     text_area_width = gui.num_cols * gui.char_width + gui.border_offset * 2;
     text_area_height = gui.num_rows * gui.char_height + gui.border_offset * 2;
 
@@ -1451,7 +1458,7 @@ gui_get_base_height(void)
 #  endif
 # endif
 # if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_MOTIF))
+	|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_HAIKU))
     if (gui_has_tabline())
 	base_height += gui.tabline_height;
 # endif
@@ -1494,6 +1501,10 @@ again:
     new_pixel_height = 0;
     busy = TRUE;
 
+    #ifdef FEAT_GUI_HAIKU
+    vim_lock_screen();
+    #endif
+
     /* Flush pending output before redrawing */
     out_flush();
 
@@ -1516,6 +1527,10 @@ again:
 	    || gui.num_rows != Rows || gui.num_cols != Columns)
 	shell_resized();
 
+#ifdef FEAT_GUI_HAIKU
+    vim_unlock_screen();
+#endif
+
     gui_update_scrollbars(TRUE);
     gui_update_cursor(FALSE, TRUE);
 #if defined(FEAT_XIM) && !defined(FEAT_GUI_GTK)
@@ -4298,9 +4313,9 @@ gui_update_scrollbars(
 		y += gui.menu_height;
 #endif
 
-#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_ATHENA))
+#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_HAIKU))
 	    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
-# ifdef FEAT_GUI_ATHENA
+# if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_HAIKU)
 		y += gui.toolbar_height;
 # else
 #  ifdef FEAT_GUI_MSWIN
@@ -4309,7 +4324,7 @@ gui_update_scrollbars(
 # endif
 #endif
 
-#if defined(FEAT_GUI_TABLINE) && defined(FEAT_GUI_MSWIN)
+#if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU))
 	    if (gui_has_tabline())
 		y += gui.tabline_height;
 #endif
@@ -5019,9 +5034,10 @@ ex_gui(exarg_T *eap)
 }
 
 #if ((defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32) \
-	|| defined(FEAT_GUI_PHOTON)) && defined(FEAT_TOOLBAR)) || defined(PROTO)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_HAIKU)) \
+		&& defined(FEAT_TOOLBAR)) || defined(PROTO)
 /*
- * This is shared between Athena, Motif and GTK.
+ * This is shared between Athena, Haiku, Motif and GTK.
  */
 static void gfp_setname(char_u *fname, void *cookie);
 
diff --git a/b/src/gui.c.orig b/src/gui.c.orig
new file mode 100644
index 0000000..82ca09d
--- /dev/null
+++ b/src/gui.c.orig
@@ -0,0 +1,5530 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved		by Bram Moolenaar
+ *				GUI/Motif support by Robert Webb
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+#include "vim.h"
+
+/* Structure containing all the GUI information */
+gui_T gui;
+
+#if defined(FEAT_MBYTE) && !defined(FEAT_GUI_GTK)
+static void set_guifontwide(char_u *font_name);
+#endif
+static void gui_check_pos(void);
+static void gui_position_components(int);
+static void gui_outstr(char_u *, int);
+static int gui_screenchar(int off, int flags, guicolor_T fg, guicolor_T bg, int back);
+#ifdef FEAT_GUI_GTK
+static int gui_screenstr(int off, int len, int flags, guicolor_T fg, guicolor_T bg, int back);
+#endif
+static void gui_delete_lines(int row, int count);
+static void gui_insert_lines(int row, int count);
+static void fill_mouse_coord(char_u *p, int col, int row);
+#if defined(FEAT_GUI_TABLINE) || defined(PROTO)
+static int gui_has_tabline(void);
+#endif
+static void gui_do_scrollbar(win_T *wp, int which, int enable);
+static colnr_T scroll_line_len(linenr_T lnum);
+static linenr_T gui_find_longest_lnum(void);
+static void gui_update_horiz_scrollbar(int);
+static void gui_set_fg_color(char_u *name);
+static void gui_set_bg_color(char_u *name);
+static win_T *xy2win(int x, int y);
+
+#ifdef GUI_MAY_FORK
+static void gui_do_fork(void);
+
+static int gui_read_child_pipe(int fd);
+
+/* Return values for gui_read_child_pipe */
+enum {
+    GUI_CHILD_IO_ERROR,
+    GUI_CHILD_OK,
+    GUI_CHILD_FAILED
+};
+#endif
+
+static void gui_attempt_start(void);
+
+static int can_update_cursor = TRUE; /* can display the cursor */
+static int disable_flush = 0;	/* If > 0, gui_mch_flush() is disabled. */
+
+/*
+ * The Athena scrollbars can move the thumb to after the end of the scrollbar,
+ * this makes the thumb indicate the part of the text that is shown.  Motif
+ * can't do this.
+ */
+#if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MAC)
+# define SCROLL_PAST_END
+#endif
+
+/*
+ * gui_start -- Called when user wants to start the GUI.
+ *
+ * Careful: This function can be called recursively when there is a ":gui"
+ * command in the .gvimrc file.  Only the first call should fork, not the
+ * recursive call.
+ */
+    void
+gui_start(void)
+{
+    char_u	*old_term;
+    static int	recursive = 0;
+
+    old_term = vim_strsave(T_NAME);
+
+    settmode(TMODE_COOK);		/* stop RAW mode */
+    if (full_screen)
+	cursor_on();			/* needed for ":gui" in .vimrc */
+    full_screen = FALSE;
+
+    ++recursive;
+
+#ifdef GUI_MAY_FORK
+    /*
+     * Quit the current process and continue in the child.
+     * Makes "gvim file" disconnect from the shell it was started in.
+     * Don't do this when Vim was started with "-f" or the 'f' flag is present
+     * in 'guioptions'.
+     * Don't do this when there is a running job, we can only get the status
+     * of a child from the parent.
+     */
+    if (gui.dofork && !vim_strchr(p_go, GO_FORG) && recursive <= 1
+# ifdef FEAT_JOB_CHANNEL
+	    && !job_any_running()
+# endif
+	    )
+    {
+	gui_do_fork();
+    }
+    else
+#endif
+    {
+#ifdef FEAT_GUI_GTK
+	/* If there is 'f' in 'guioptions' and specify -g argument,
+	 * gui_mch_init_check() was not called yet.  */
+	if (gui_mch_init_check() != OK)
+	    getout_preserve_modified(1);
+#endif
+	gui_attempt_start();
+    }
+
+    if (!gui.in_use)			/* failed to start GUI */
+    {
+	/* Back to old term settings
+	 *
+	 * FIXME: If we got here because a child process failed and flagged to
+	 * the parent to resume, and X11 is enabled with FEAT_TITLE, this will
+	 * hit an X11 I/O error and do a longjmp(), leaving recursive
+	 * permanently set to 1. This is probably not as big a problem as it
+	 * sounds, because gui_mch_init() in both gui_x11.c and gui_gtk_x11.c
+	 * return "OK" unconditionally, so it would be very difficult to
+	 * actually hit this case.
+	 */
+	termcapinit(old_term);
+	settmode(TMODE_RAW);		/* restart RAW mode */
+#ifdef FEAT_TITLE
+	set_title_defaults();		/* set 'title' and 'icon' again */
+#endif
+    }
+
+    vim_free(old_term);
+
+    /* If the GUI started successfully, trigger the GUIEnter event, otherwise
+     * the GUIFailed event. */
+    gui_mch_update();
+    apply_autocmds(gui.in_use ? EVENT_GUIENTER : EVENT_GUIFAILED,
+						   NULL, NULL, FALSE, curbuf);
+    --recursive;
+}
+
+/*
+ * Set_termname() will call gui_init() to start the GUI.
+ * Set the "starting" flag, to indicate that the GUI will start.
+ *
+ * We don't want to open the GUI shell until after we've read .gvimrc,
+ * otherwise we don't know what font we will use, and hence we don't know
+ * what size the shell should be.  So if there are errors in the .gvimrc
+ * file, they will have to go to the terminal: Set full_screen to FALSE.
+ * full_screen will be set to TRUE again by a successful termcapinit().
+ */
+    static void
+gui_attempt_start(void)
+{
+    static int recursive = 0;
+
+    ++recursive;
+    gui.starting = TRUE;
+
+#ifdef FEAT_GUI_GTK
+    gui.event_time = GDK_CURRENT_TIME;
+#endif
+
+    termcapinit((char_u *)"builtin_gui");
+    gui.starting = recursive - 1;
+
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
+    if (gui.in_use)
+    {
+# ifdef FEAT_EVAL
+	Window	x11_window;
+	Display	*x11_display;
+
+	if (gui_get_x11_windis(&x11_window, &x11_display) == OK)
+	    set_vim_var_nr(VV_WINDOWID, (long)x11_window);
+# endif
+
+	/* Display error messages in a dialog now. */
+	display_errors();
+    }
+#endif
+    --recursive;
+}
+
+#ifdef GUI_MAY_FORK
+
+/* for waitpid() */
+# if defined(HAVE_SYS_WAIT_H) || defined(HAVE_UNION_WAIT)
+#  include <sys/wait.h>
+# endif
+
+/*
+ * Create a new process, by forking. In the child, start the GUI, and in
+ * the parent, exit.
+ *
+ * If something goes wrong, this will return with gui.in_use still set
+ * to FALSE, in which case the caller should continue execution without
+ * the GUI.
+ *
+ * If the child fails to start the GUI, then the child will exit and the
+ * parent will return. If the child succeeds, then the parent will exit
+ * and the child will return.
+ */
+    static void
+gui_do_fork(void)
+{
+    int		pipefd[2];	/* pipe between parent and child */
+    int		pipe_error;
+    int		status;
+    int		exit_status;
+    pid_t	pid = -1;
+
+    /* Setup a pipe between the child and the parent, so that the parent
+     * knows when the child has done the setsid() call and is allowed to
+     * exit. */
+    pipe_error = (pipe(pipefd) < 0);
+    pid = fork();
+    if (pid < 0)	    /* Fork error */
+    {
+	EMSG(_("E851: Failed to create a new process for the GUI"));
+	return;
+    }
+    else if (pid > 0)	    /* Parent */
+    {
+	/* Give the child some time to do the setsid(), otherwise the
+	 * exit() may kill the child too (when starting gvim from inside a
+	 * gvim). */
+	if (!pipe_error)
+	{
+	    /* The read returns when the child closes the pipe (or when
+	     * the child dies for some reason). */
+	    close(pipefd[1]);
+	    status = gui_read_child_pipe(pipefd[0]);
+	    if (status == GUI_CHILD_FAILED)
+	    {
+		/* The child failed to start the GUI, so the caller must
+		 * continue. There may be more error information written
+		 * to stderr by the child. */
+# ifdef __NeXT__
+		wait4(pid, &exit_status, 0, (struct rusage *)0);
+# else
+		waitpid(pid, &exit_status, 0);
+# endif
+		EMSG(_("E852: The child process failed to start the GUI"));
+		return;
+	    }
+	    else if (status == GUI_CHILD_IO_ERROR)
+	    {
+		pipe_error = TRUE;
+	    }
+	    /* else GUI_CHILD_OK: parent exit */
+	}
+
+	if (pipe_error)
+	    ui_delay(300L, TRUE);
+
+	/* When swapping screens we may need to go to the next line, e.g.,
+	 * after a hit-enter prompt and using ":gui". */
+	if (newline_on_exit)
+	    mch_errmsg("\r\n");
+
+	/*
+	 * The parent must skip the normal exit() processing, the child
+	 * will do it.  For example, GTK messes up signals when exiting.
+	 */
+	_exit(0);
+    }
+    /* Child */
+
+#ifdef FEAT_GUI_GTK
+    /* Call gtk_init_check() here after fork(). See gui_init_check(). */
+    if (gui_mch_init_check() != OK)
+	getout_preserve_modified(1);
+#endif
+
+# if defined(HAVE_SETSID) || defined(HAVE_SETPGID)
+    /*
+     * Change our process group.  On some systems/shells a CTRL-C in the
+     * shell where Vim was started would otherwise kill gvim!
+     */
+#  if defined(HAVE_SETSID)
+    (void)setsid();
+#  else
+    (void)setpgid(0, 0);
+#  endif
+# endif
+    if (!pipe_error)
+	close(pipefd[0]);
+
+# if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
+    /* Tell the session manager our new PID */
+    gui_mch_forked();
+# endif
+
+    /* Try to start the GUI */
+    gui_attempt_start();
+
+    /* Notify the parent */
+    if (!pipe_error)
+    {
+	if (gui.in_use)
+	    write_eintr(pipefd[1], "ok", 3);
+	else
+	    write_eintr(pipefd[1], "fail", 5);
+	close(pipefd[1]);
+    }
+
+    /* If we failed to start the GUI, exit now. */
+    if (!gui.in_use)
+	getout_preserve_modified(1);
+}
+
+/*
+ * Read from a pipe assumed to be connected to the child process (this
+ * function is called from the parent).
+ * Return GUI_CHILD_OK if the child successfully started the GUI,
+ * GUY_CHILD_FAILED if the child failed, or GUI_CHILD_IO_ERROR if there was
+ * some other error.
+ *
+ * The file descriptor will be closed before the function returns.
+ */
+    static int
+gui_read_child_pipe(int fd)
+{
+    long	bytes_read;
+#define READ_BUFFER_SIZE 10
+    char	buffer[READ_BUFFER_SIZE];
+
+    bytes_read = read_eintr(fd, buffer, READ_BUFFER_SIZE - 1);
+#undef READ_BUFFER_SIZE
+    close(fd);
+    if (bytes_read < 0)
+	return GUI_CHILD_IO_ERROR;
+    buffer[bytes_read] = NUL;
+    if (strcmp(buffer, "ok") == 0)
+	return GUI_CHILD_OK;
+    return GUI_CHILD_FAILED;
+}
+
+#endif /* GUI_MAY_FORK */
+
+/*
+ * Call this when vim starts up, whether or not the GUI is started
+ */
+    void
+gui_prepare(int *argc, char **argv)
+{
+    gui.in_use = FALSE;		    /* No GUI yet (maybe later) */
+    gui.starting = FALSE;	    /* No GUI yet (maybe later) */
+    gui_mch_prepare(argc, argv);
+}
+
+/*
+ * Try initializing the GUI and check if it can be started.
+ * Used from main() to check early if "vim -g" can start the GUI.
+ * Used from gui_init() to prepare for starting the GUI.
+ * Returns FAIL or OK.
+ */
+    int
+gui_init_check(void)
+{
+    static int result = MAYBE;
+
+    if (result != MAYBE)
+    {
+	if (result == FAIL)
+	    EMSG(_("E229: Cannot start the GUI"));
+	return result;
+    }
+
+    gui.shell_created = FALSE;
+    gui.dying = FALSE;
+    gui.in_focus = TRUE;		/* so the guicursor setting works */
+    gui.dragged_sb = SBAR_NONE;
+    gui.dragged_wp = NULL;
+    gui.pointer_hidden = FALSE;
+    gui.col = 0;
+    gui.row = 0;
+    gui.num_cols = Columns;
+    gui.num_rows = Rows;
+
+    gui.cursor_is_valid = FALSE;
+    gui.scroll_region_top = 0;
+    gui.scroll_region_bot = Rows - 1;
+    gui.scroll_region_left = 0;
+    gui.scroll_region_right = Columns - 1;
+    gui.highlight_mask = HL_NORMAL;
+    gui.char_width = 1;
+    gui.char_height = 1;
+    gui.char_ascent = 0;
+    gui.border_width = 0;
+
+    gui.norm_font = NOFONT;
+#ifndef FEAT_GUI_GTK
+    gui.bold_font = NOFONT;
+    gui.ital_font = NOFONT;
+    gui.boldital_font = NOFONT;
+# ifdef FEAT_XFONTSET
+    gui.fontset = NOFONTSET;
+# endif
+#endif
+#ifdef FEAT_MBYTE
+    gui.wide_font = NOFONT;
+# ifndef FEAT_GUI_GTK
+    gui.wide_bold_font = NOFONT;
+    gui.wide_ital_font = NOFONT;
+    gui.wide_boldital_font = NOFONT;
+# endif
+#endif
+
+#ifdef FEAT_MENU
+# ifndef FEAT_GUI_GTK
+#  ifdef FONTSET_ALWAYS
+    gui.menu_fontset = NOFONTSET;
+#  else
+    gui.menu_font = NOFONT;
+#  endif
+# endif
+    gui.menu_is_active = TRUE;	    /* default: include menu */
+# ifndef FEAT_GUI_GTK
+    gui.menu_height = MENU_DEFAULT_HEIGHT;
+    gui.menu_width = 0;
+# endif
+#endif
+#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))
+    gui.toolbar_height = 0;
+#endif
+#if defined(FEAT_FOOTER) && defined(FEAT_GUI_MOTIF)
+    gui.footer_height = 0;
+#endif
+#ifdef FEAT_BEVAL_TIP
+    gui.tooltip_fontset = NOFONTSET;
+#endif
+
+    gui.scrollbar_width = gui.scrollbar_height = SB_DEFAULT_WIDTH;
+    gui.prev_wrap = -1;
+
+#ifdef ALWAYS_USE_GUI
+    result = OK;
+#else
+# ifdef FEAT_GUI_GTK
+    /*
+     * Note: Don't call gtk_init_check() before fork, it will be called after
+     * the fork. When calling it before fork, it make vim hang for a while.
+     * See gui_do_fork().
+     * Use a simpler check if the GUI window can probably be opened.
+     */
+    result = gui.dofork ? gui_mch_early_init_check(TRUE) : gui_mch_init_check();
+# else
+    result = gui_mch_init_check();
+# endif
+#endif
+    return result;
+}
+
+/*
+ * This is the call which starts the GUI.
+ */
+    void
+gui_init(void)
+{
+    win_T	*wp;
+    static int	recursive = 0;
+
+    /*
+     * It's possible to use ":gui" in a .gvimrc file.  The first halve of this
+     * function will then be executed at the first call, the rest by the
+     * recursive call.  This allow the shell to be opened halfway reading a
+     * gvimrc file.
+     */
+    if (!recursive)
+    {
+	++recursive;
+
+	clip_init(TRUE);
+
+	/* If can't initialize, don't try doing the rest */
+	if (gui_init_check() == FAIL)
+	{
+	    --recursive;
+	    clip_init(FALSE);
+	    return;
+	}
+
+	/*
+	 * Reset 'paste'.  It's useful in the terminal, but not in the GUI.  It
+	 * breaks the Paste toolbar button.
+	 */
+	set_option_value((char_u *)"paste", 0L, NULL, 0);
+
+	/*
+	 * Set up system-wide default menus.
+	 */
+#if defined(SYS_MENU_FILE) && defined(FEAT_MENU)
+	if (vim_strchr(p_go, GO_NOSYSMENU) == NULL)
+	{
+	    sys_menu = TRUE;
+	    do_source((char_u *)SYS_MENU_FILE, FALSE, DOSO_NONE);
+	    sys_menu = FALSE;
+	}
+#endif
+
+	/*
+	 * Switch on the mouse by default, unless the user changed it already.
+	 * This can then be changed in the .gvimrc.
+	 */
+	if (!option_was_set((char_u *)"mouse"))
+	    set_string_option_direct((char_u *)"mouse", -1,
+					   (char_u *)"a", OPT_FREE, SID_NONE);
+
+	/*
+	 * If -U option given, use only the initializations from that file and
+	 * nothing else.  Skip all initializations for "-U NONE" or "-u NORC".
+	 */
+	if (use_gvimrc != NULL)
+	{
+	    if (STRCMP(use_gvimrc, "NONE") != 0
+		    && STRCMP(use_gvimrc, "NORC") != 0
+		    && do_source(use_gvimrc, FALSE, DOSO_NONE) != OK)
+		EMSG2(_("E230: Cannot read from \"%s\""), use_gvimrc);
+	}
+	else
+	{
+	    /*
+	     * Get system wide defaults for gvim, only when file name defined.
+	     */
+#ifdef SYS_GVIMRC_FILE
+	    do_source((char_u *)SYS_GVIMRC_FILE, FALSE, DOSO_NONE);
+#endif
+
+	    /*
+	     * Try to read GUI initialization commands from the following
+	     * places:
+	     * - environment variable GVIMINIT
+	     * - the user gvimrc file (~/.gvimrc)
+	     * - the second user gvimrc file ($VIM/.gvimrc for Dos)
+	     * - the third user gvimrc file ($VIM/.gvimrc for Amiga)
+	     * The first that exists is used, the rest is ignored.
+	     */
+	    if (process_env((char_u *)"GVIMINIT", FALSE) == FAIL
+		 && do_source((char_u *)USR_GVIMRC_FILE, TRUE,
+							  DOSO_GVIMRC) == FAIL
+#ifdef USR_GVIMRC_FILE2
+		 && do_source((char_u *)USR_GVIMRC_FILE2, TRUE,
+							  DOSO_GVIMRC) == FAIL
+#endif
+#ifdef USR_GVIMRC_FILE3
+		 && do_source((char_u *)USR_GVIMRC_FILE3, TRUE,
+							  DOSO_GVIMRC) == FAIL
+#endif
+				)
+	    {
+#ifdef USR_GVIMRC_FILE4
+		(void)do_source((char_u *)USR_GVIMRC_FILE4, TRUE, DOSO_GVIMRC);
+#endif
+	    }
+
+	    /*
+	     * Read initialization commands from ".gvimrc" in current
+	     * directory.  This is only done if the 'exrc' option is set.
+	     * Because of security reasons we disallow shell and write
+	     * commands now, except for unix if the file is owned by the user
+	     * or 'secure' option has been reset in environment of global
+	     * ".gvimrc".
+	     * Only do this if GVIMRC_FILE is not the same as USR_GVIMRC_FILE,
+	     * USR_GVIMRC_FILE2, USR_GVIMRC_FILE3 or SYS_GVIMRC_FILE.
+	     */
+	    if (p_exrc)
+	    {
+#ifdef UNIX
+		{
+		    stat_T s;
+
+		    /* if ".gvimrc" file is not owned by user, set 'secure'
+		     * mode */
+		    if (mch_stat(GVIMRC_FILE, &s) || s.st_uid != getuid())
+			secure = p_secure;
+		}
+#else
+		secure = p_secure;
+#endif
+
+		if (       fullpathcmp((char_u *)USR_GVIMRC_FILE,
+				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
+#ifdef SYS_GVIMRC_FILE
+			&& fullpathcmp((char_u *)SYS_GVIMRC_FILE,
+				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
+#endif
+#ifdef USR_GVIMRC_FILE2
+			&& fullpathcmp((char_u *)USR_GVIMRC_FILE2,
+				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
+#endif
+#ifdef USR_GVIMRC_FILE3
+			&& fullpathcmp((char_u *)USR_GVIMRC_FILE3,
+				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
+#endif
+#ifdef USR_GVIMRC_FILE4
+			&& fullpathcmp((char_u *)USR_GVIMRC_FILE4,
+				     (char_u *)GVIMRC_FILE, FALSE) != FPC_SAME
+#endif
+			)
+		    do_source((char_u *)GVIMRC_FILE, TRUE, DOSO_GVIMRC);
+
+		if (secure == 2)
+		    need_wait_return = TRUE;
+		secure = 0;
+	    }
+	}
+
+	if (need_wait_return || msg_didany)
+	    wait_return(TRUE);
+
+	--recursive;
+    }
+
+    /* If recursive call opened the shell, return here from the first call */
+    if (gui.in_use)
+	return;
+
+    /*
+     * Create the GUI shell.
+     */
+    gui.in_use = TRUE;		/* Must be set after menus have been set up */
+    if (gui_mch_init() == FAIL)
+	goto error;
+
+    /* Avoid a delay for an error message that was printed in the terminal
+     * where Vim was started. */
+    emsg_on_display = FALSE;
+    msg_scrolled = 0;
+    clear_sb_text(TRUE);
+    need_wait_return = FALSE;
+    msg_didany = FALSE;
+
+    /*
+     * Check validity of any generic resources that may have been loaded.
+     */
+    if (gui.border_width < 0)
+	gui.border_width = 0;
+
+    /*
+     * Set up the fonts.  First use a font specified with "-fn" or "-font".
+     */
+    if (font_argument != NULL)
+	set_option_value((char_u *)"gfn", 0L, (char_u *)font_argument, 0);
+    if (
+#ifdef FEAT_XFONTSET
+	    (*p_guifontset == NUL
+	     || gui_init_font(p_guifontset, TRUE) == FAIL) &&
+#endif
+	    gui_init_font(*p_guifont == NUL ? hl_get_font_name()
+						  : p_guifont, FALSE) == FAIL)
+    {
+	EMSG(_("E665: Cannot start GUI, no valid font found"));
+	goto error2;
+    }
+#ifdef FEAT_MBYTE
+    if (gui_get_wide_font() == FAIL)
+	EMSG(_("E231: 'guifontwide' invalid"));
+#endif
+
+    gui.num_cols = Columns;
+    gui.num_rows = Rows;
+    gui_reset_scroll_region();
+
+    /* Create initial scrollbars */
+    FOR_ALL_WINDOWS(wp)
+    {
+	gui_create_scrollbar(&wp->w_scrollbars[SBAR_LEFT], SBAR_LEFT, wp);
+	gui_create_scrollbar(&wp->w_scrollbars[SBAR_RIGHT], SBAR_RIGHT, wp);
+    }
+    gui_create_scrollbar(&gui.bottom_sbar, SBAR_BOTTOM, NULL);
+
+#ifdef FEAT_MENU
+    gui_create_initial_menus(root_menu);
+#endif
+#ifdef FEAT_SUN_WORKSHOP
+    if (usingSunWorkShop)
+	workshop_init();
+#endif
+#ifdef FEAT_SIGN_ICONS
+    sign_gui_started();
+#endif
+
+    /* Configure the desired menu and scrollbars */
+    gui_init_which_components(NULL);
+
+    /* All components of the GUI have been created now */
+    gui.shell_created = TRUE;
+
+#ifndef FEAT_GUI_GTK
+    /* Set the shell size, adjusted for the screen size.  For GTK this only
+     * works after the shell has been opened, thus it is further down. */
+    gui_set_shellsize(TRUE, TRUE, RESIZE_BOTH);
+#endif
+#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)
+    /* Need to set the size of the menubar after all the menus have been
+     * created. */
+    gui_mch_compute_menu_height((Widget)0);
+#endif
+
+    /*
+     * Actually open the GUI shell.
+     */
+    if (gui_mch_open() != FAIL)
+    {
+#ifdef FEAT_TITLE
+	maketitle();
+	resettitle();
+#endif
+	init_gui_options();
+#ifdef FEAT_ARABIC
+	/* Our GUI can't do bidi. */
+	p_tbidi = FALSE;
+#endif
+#if defined(FEAT_GUI_GTK)
+	/* Give GTK+ a chance to put all widget's into place. */
+	gui_mch_update();
+
+# ifdef FEAT_MENU
+	/* If there is no 'm' in 'guioptions' we need to remove the menu now.
+	 * It was still there to make F10 work. */
+	if (vim_strchr(p_go, GO_MENUS) == NULL)
+	{
+	    --gui.starting;
+	    gui_mch_enable_menu(FALSE);
+	    ++gui.starting;
+	    gui_mch_update();
+	}
+# endif
+
+	/* Now make sure the shell fits on the screen. */
+	gui_set_shellsize(TRUE, TRUE, RESIZE_BOTH);
+#endif
+	/* When 'lines' was set while starting up the topframe may have to be
+	 * resized. */
+	win_new_shellsize();
+
+#ifdef FEAT_BEVAL_GUI
+	/* Always create the Balloon Evaluation area, but disable it when
+	 * 'ballooneval' is off. */
+	if (balloonEval != NULL)
+	{
+# ifdef FEAT_VARTABS
+	    vim_free(balloonEval->vts);
+# endif
+	    vim_free(balloonEval);
+	}
+	balloonEvalForTerm = FALSE;
+# ifdef FEAT_GUI_GTK
+	balloonEval = gui_mch_create_beval_area(gui.drawarea, NULL,
+						     &general_beval_cb, NULL);
+# else
+#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
+	{
+	    extern Widget	textArea;
+	    balloonEval = gui_mch_create_beval_area(textArea, NULL,
+						     &general_beval_cb, NULL);
+	}
+#  else
+#   ifdef FEAT_GUI_W32
+	balloonEval = gui_mch_create_beval_area(NULL, NULL,
+						     &general_beval_cb, NULL);
+#   endif
+#  endif
+# endif
+	if (!p_beval)
+	    gui_mch_disable_beval_area(balloonEval);
+#endif
+
+#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
+	if (!im_xim_isvalid_imactivate())
+	    EMSG(_("E599: Value of 'imactivatekey' is invalid"));
+#endif
+	/* When 'cmdheight' was set during startup it may not have taken
+	 * effect yet. */
+	if (p_ch != 1L)
+	    command_height();
+
+	return;
+    }
+
+error2:
+#ifdef FEAT_GUI_X11
+    /* undo gui_mch_init() */
+    gui_mch_uninit();
+#endif
+
+error:
+    gui.in_use = FALSE;
+    clip_init(FALSE);
+}
+
+
+    void
+gui_exit(int rc)
+{
+    /* don't free the fonts, it leads to a BUS error
+     * richard@whitequeen.com Jul 99 */
+    free_highlight_fonts();
+    gui.in_use = FALSE;
+    gui_mch_exit(rc);
+}
+
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_MSWIN) \
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(PROTO)
+# define NEED_GUI_UPDATE_SCREEN 1
+/*
+ * Called when the GUI shell is closed by the user.  If there are no changed
+ * files Vim exits, otherwise there will be a dialog to ask the user what to
+ * do.
+ * When this function returns, Vim should NOT exit!
+ */
+    void
+gui_shell_closed(void)
+{
+    cmdmod_T	    save_cmdmod;
+
+    save_cmdmod = cmdmod;
+
+    /* Only exit when there are no changed files */
+    exiting = TRUE;
+# ifdef FEAT_BROWSE
+    cmdmod.browse = TRUE;
+# endif
+# if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+    cmdmod.confirm = TRUE;
+# endif
+    /* If there are changed buffers, present the user with a dialog if
+     * possible, otherwise give an error message. */
+    if (!check_changed_any(FALSE, FALSE))
+	getout(0);
+
+    exiting = FALSE;
+    cmdmod = save_cmdmod;
+    gui_update_screen();	/* redraw, window may show changed buffer */
+}
+#endif
+
+/*
+ * Set the font.  "font_list" is a comma separated list of font names.  The
+ * first font name that works is used.  If none is found, use the default
+ * font.
+ * If "fontset" is TRUE, the "font_list" is used as one name for the fontset.
+ * Return OK when able to set the font.  When it failed FAIL is returned and
+ * the fonts are unchanged.
+ */
+    int
+gui_init_font(char_u *font_list, int fontset UNUSED)
+{
+#define FONTLEN 320
+    char_u	font_name[FONTLEN];
+    int		font_list_empty = FALSE;
+    int		ret = FAIL;
+
+    if (!gui.in_use)
+	return FAIL;
+
+    font_name[0] = NUL;
+    if (*font_list == NUL)
+	font_list_empty = TRUE;
+    else
+    {
+#ifdef FEAT_XFONTSET
+	/* When using a fontset, the whole list of fonts is one name. */
+	if (fontset)
+	    ret = gui_mch_init_font(font_list, TRUE);
+	else
+#endif
+	    while (*font_list != NUL)
+	    {
+		/* Isolate one comma separated font name. */
+		(void)copy_option_part(&font_list, font_name, FONTLEN, ",");
+
+		/* Careful!!!  The Win32 version of gui_mch_init_font(), when
+		 * called with "*" will change p_guifont to the selected font
+		 * name, which frees the old value.  This makes font_list
+		 * invalid.  Thus when OK is returned here, font_list must no
+		 * longer be used! */
+		if (gui_mch_init_font(font_name, FALSE) == OK)
+		{
+#if defined(FEAT_MBYTE) && !defined(FEAT_GUI_GTK)
+		    /* If it's a Unicode font, try setting 'guifontwide' to a
+		     * similar double-width font. */
+		    if ((p_guifontwide == NULL || *p_guifontwide == NUL)
+				&& strstr((char *)font_name, "10646") != NULL)
+			set_guifontwide(font_name);
+#endif
+		    ret = OK;
+		    break;
+		}
+	    }
+    }
+
+    if (ret != OK
+	    && STRCMP(font_list, "*") != 0
+	    && (font_list_empty || gui.norm_font == NOFONT))
+    {
+	/*
+	 * Couldn't load any font in 'font_list', keep the current font if
+	 * there is one.  If 'font_list' is empty, or if there is no current
+	 * font, tell gui_mch_init_font() to try to find a font we can load.
+	 */
+	ret = gui_mch_init_font(NULL, FALSE);
+    }
+
+    if (ret == OK)
+    {
+#ifndef FEAT_GUI_GTK
+	/* Set normal font as current font */
+# ifdef FEAT_XFONTSET
+	if (gui.fontset != NOFONTSET)
+	    gui_mch_set_fontset(gui.fontset);
+	else
+# endif
+	    gui_mch_set_font(gui.norm_font);
+#endif
+	gui_set_shellsize(TRUE, TRUE, RESIZE_BOTH);
+    }
+
+    return ret;
+}
+
+#if defined(FEAT_MBYTE) || defined(PROTO)
+# ifndef FEAT_GUI_GTK
+/*
+ * Try setting 'guifontwide' to a font twice as wide as "name".
+ */
+    static void
+set_guifontwide(char_u *name)
+{
+    int		i = 0;
+    char_u	wide_name[FONTLEN + 10]; /* room for 2 * width and '*' */
+    char_u	*wp = NULL;
+    char_u	*p;
+    GuiFont	font;
+
+    wp = wide_name;
+    for (p = name; *p != NUL; ++p)
+    {
+	*wp++ = *p;
+	if (*p == '-')
+	{
+	    ++i;
+	    if (i == 6)		/* font type: change "--" to "-*-" */
+	    {
+		if (p[1] == '-')
+		    *wp++ = '*';
+	    }
+	    else if (i == 12)	/* found the width */
+	    {
+		++p;
+		i = getdigits(&p);
+		if (i != 0)
+		{
+		    /* Double the width specification. */
+		    sprintf((char *)wp, "%d%s", i * 2, p);
+		    font = gui_mch_get_font(wide_name, FALSE);
+		    if (font != NOFONT)
+		    {
+			gui_mch_free_font(gui.wide_font);
+			gui.wide_font = font;
+			set_string_option_direct((char_u *)"gfw", -1,
+						      wide_name, OPT_FREE, 0);
+		    }
+		}
+		break;
+	    }
+	}
+    }
+}
+# endif /* !FEAT_GUI_GTK */
+
+/*
+ * Get the font for 'guifontwide'.
+ * Return FAIL for an invalid font name.
+ */
+    int
+gui_get_wide_font(void)
+{
+    GuiFont	font = NOFONT;
+    char_u	font_name[FONTLEN];
+    char_u	*p;
+
+    if (!gui.in_use)	    /* Can't allocate font yet, assume it's OK. */
+	return OK;	    /* Will give an error message later. */
+
+    if (p_guifontwide != NULL && *p_guifontwide != NUL)
+    {
+	for (p = p_guifontwide; *p != NUL; )
+	{
+	    /* Isolate one comma separated font name. */
+	    (void)copy_option_part(&p, font_name, FONTLEN, ",");
+	    font = gui_mch_get_font(font_name, FALSE);
+	    if (font != NOFONT)
+		break;
+	}
+	if (font == NOFONT)
+	    return FAIL;
+    }
+
+    gui_mch_free_font(gui.wide_font);
+# ifdef FEAT_GUI_GTK
+    /* Avoid unnecessary overhead if 'guifontwide' is equal to 'guifont'. */
+    if (font != NOFONT && gui.norm_font != NOFONT
+			 && pango_font_description_equal(font, gui.norm_font))
+    {
+	gui.wide_font = NOFONT;
+	gui_mch_free_font(font);
+    }
+    else
+# endif
+	gui.wide_font = font;
+# ifdef FEAT_GUI_MSWIN
+    gui_mch_wide_font_changed();
+# else
+    /*
+     * TODO: setup wide_bold_font, wide_ital_font and wide_boldital_font to
+     * support those fonts for 'guifontwide'.
+     */
+# endif
+    return OK;
+}
+#endif
+
+    void
+gui_set_cursor(int row, int col)
+{
+    gui.row = row;
+    gui.col = col;
+}
+
+/*
+ * gui_check_pos - check if the cursor is on the screen.
+ */
+    static void
+gui_check_pos(void)
+{
+    if (gui.row >= screen_Rows)
+	gui.row = screen_Rows - 1;
+    if (gui.col >= screen_Columns)
+	gui.col = screen_Columns - 1;
+    if (gui.cursor_row >= screen_Rows || gui.cursor_col >= screen_Columns)
+	gui.cursor_is_valid = FALSE;
+}
+
+/*
+ * Redraw the cursor if necessary or when forced.
+ * Careful: The contents of ScreenLines[] must match what is on the screen,
+ * otherwise this goes wrong.  May need to call out_flush() first.
+ */
+    void
+gui_update_cursor(
+    int		force,		/* when TRUE, update even when not moved */
+    int		clear_selection)/* clear selection under cursor */
+{
+    int		cur_width = 0;
+    int		cur_height = 0;
+    int		old_hl_mask;
+    cursorentry_T *shape;
+    int		id;
+#ifdef FEAT_TERMINAL
+    guicolor_T	shape_fg = INVALCOLOR;
+    guicolor_T	shape_bg = INVALCOLOR;
+#endif
+    guicolor_T	cfg, cbg, cc;	/* cursor fore-/background color */
+    int		cattr;		/* cursor attributes */
+    int		attr;
+    attrentry_T *aep = NULL;
+
+    /* Don't update the cursor when halfway busy scrolling or the screen size
+     * doesn't match 'columns' and 'lines.  ScreenLines[] isn't valid then. */
+    if (!can_update_cursor || screen_Columns != gui.num_cols
+					       || screen_Rows != gui.num_rows)
+	return;
+
+    gui_check_pos();
+    if (!gui.cursor_is_valid || force
+		    || gui.row != gui.cursor_row || gui.col != gui.cursor_col)
+    {
+	gui_undraw_cursor();
+	if (gui.row < 0)
+	    return;
+#ifdef HAVE_INPUT_METHOD
+	if (gui.row != gui.cursor_row || gui.col != gui.cursor_col)
+	    im_set_position(gui.row, gui.col);
+#endif
+	gui.cursor_row = gui.row;
+	gui.cursor_col = gui.col;
+
+	/* Only write to the screen after ScreenLines[] has been initialized */
+	if (!screen_cleared || ScreenLines == NULL)
+	    return;
+
+	/* Clear the selection if we are about to write over it */
+	if (clear_selection)
+	    clip_may_clear_selection(gui.row, gui.row);
+	/* Check that the cursor is inside the shell (resizing may have made
+	 * it invalid) */
+	if (gui.row >= screen_Rows || gui.col >= screen_Columns)
+	    return;
+
+	gui.cursor_is_valid = TRUE;
+
+	/*
+	 * How the cursor is drawn depends on the current mode.
+	 * When in a terminal window use the shape/color specified there.
+	 */
+#ifdef FEAT_TERMINAL
+	if (terminal_is_active())
+	    shape = term_get_cursor_shape(&shape_fg, &shape_bg);
+	else
+#endif
+	    shape = &shape_table[get_shape_idx(FALSE)];
+	if (State & LANGMAP)
+	    id = shape->id_lm;
+	else
+	    id = shape->id;
+
+	/* get the colors and attributes for the cursor.  Default is inverted */
+	cfg = INVALCOLOR;
+	cbg = INVALCOLOR;
+	cattr = HL_INVERSE;
+	gui_mch_set_blinking(shape->blinkwait,
+			     shape->blinkon,
+			     shape->blinkoff);
+	if (shape->blinkwait == 0 || shape->blinkon == 0
+						       || shape->blinkoff == 0)
+	    gui_mch_stop_blink(FALSE);
+#ifdef FEAT_TERMINAL
+	if (shape_bg != INVALCOLOR)
+	{
+	    cattr = 0;
+	    cfg = shape_fg;
+	    cbg = shape_bg;
+	}
+	else
+#endif
+	if (id > 0)
+	{
+	    cattr = syn_id2colors(id, &cfg, &cbg);
+#if defined(HAVE_INPUT_METHOD) || defined(FEAT_HANGULIN)
+	    {
+		static int iid;
+		guicolor_T fg, bg;
+
+		if (
+# if defined(FEAT_GUI_GTK) && defined(FEAT_XIM) && !defined(FEAT_HANGULIN)
+			preedit_get_status()
+# else
+			im_get_status()
+# endif
+			)
+		{
+		    iid = syn_name2id((char_u *)"CursorIM");
+		    if (iid > 0)
+		    {
+			syn_id2colors(iid, &fg, &bg);
+			if (bg != INVALCOLOR)
+			    cbg = bg;
+			if (fg != INVALCOLOR)
+			    cfg = fg;
+		    }
+		}
+	    }
+#endif
+	}
+
+	/*
+	 * Get the attributes for the character under the cursor.
+	 * When no cursor color was given, use the character color.
+	 */
+	attr = ScreenAttrs[LineOffset[gui.row] + gui.col];
+	if (attr > HL_ALL)
+	    aep = syn_gui_attr2entry(attr);
+	if (aep != NULL)
+	{
+	    attr = aep->ae_attr;
+	    if (cfg == INVALCOLOR)
+		cfg = ((attr & HL_INVERSE)  ? aep->ae_u.gui.bg_color
+					    : aep->ae_u.gui.fg_color);
+	    if (cbg == INVALCOLOR)
+		cbg = ((attr & HL_INVERSE)  ? aep->ae_u.gui.fg_color
+					    : aep->ae_u.gui.bg_color);
+	}
+	if (cfg == INVALCOLOR)
+	    cfg = (attr & HL_INVERSE) ? gui.back_pixel : gui.norm_pixel;
+	if (cbg == INVALCOLOR)
+	    cbg = (attr & HL_INVERSE) ? gui.norm_pixel : gui.back_pixel;
+
+#ifdef FEAT_XIM
+	if (aep != NULL)
+	{
+	    xim_bg_color = ((attr & HL_INVERSE) ? aep->ae_u.gui.fg_color
+						: aep->ae_u.gui.bg_color);
+	    xim_fg_color = ((attr & HL_INVERSE) ? aep->ae_u.gui.bg_color
+						: aep->ae_u.gui.fg_color);
+	    if (xim_bg_color == INVALCOLOR)
+		xim_bg_color = (attr & HL_INVERSE) ? gui.norm_pixel
+						   : gui.back_pixel;
+	    if (xim_fg_color == INVALCOLOR)
+		xim_fg_color = (attr & HL_INVERSE) ? gui.back_pixel
+						   : gui.norm_pixel;
+	}
+	else
+	{
+	    xim_bg_color = (attr & HL_INVERSE) ? gui.norm_pixel
+					       : gui.back_pixel;
+	    xim_fg_color = (attr & HL_INVERSE) ? gui.back_pixel
+					       : gui.norm_pixel;
+	}
+#endif
+
+	attr &= ~HL_INVERSE;
+	if (cattr & HL_INVERSE)
+	{
+	    cc = cbg;
+	    cbg = cfg;
+	    cfg = cc;
+	}
+	cattr &= ~HL_INVERSE;
+
+	/*
+	 * When we don't have window focus, draw a hollow cursor.
+	 */
+	if (!gui.in_focus)
+	{
+	    gui_mch_draw_hollow_cursor(cbg);
+	    return;
+	}
+
+	old_hl_mask = gui.highlight_mask;
+	if (shape->shape == SHAPE_BLOCK
+#ifdef FEAT_HANGULIN
+		|| composing_hangul
+#endif
+	   )
+	{
+	    /*
+	     * Draw the text character with the cursor colors.	Use the
+	     * character attributes plus the cursor attributes.
+	     */
+	    gui.highlight_mask = (cattr | attr);
+#ifdef FEAT_HANGULIN
+	    if (composing_hangul)
+	    {
+		char_u *comp_buf;
+		int comp_len;
+
+		comp_buf = hangul_composing_buffer_get(&comp_len);
+		if (comp_buf)
+		{
+		    (void)gui_outstr_nowrap(comp_buf, comp_len,
+					    GUI_MON_IS_CURSOR | GUI_MON_NOCLEAR,
+					    cfg, cbg, 0);
+		    vim_free(comp_buf);
+		}
+	    }
+	    else
+#endif
+		(void)gui_screenchar(LineOffset[gui.row] + gui.col,
+			GUI_MON_IS_CURSOR | GUI_MON_NOCLEAR, cfg, cbg, 0);
+	}
+	else
+	{
+#if defined(FEAT_MBYTE) && defined(FEAT_RIGHTLEFT)
+	    int	    col_off = FALSE;
+#endif
+	    /*
+	     * First draw the partial cursor, then overwrite with the text
+	     * character, using a transparent background.
+	     */
+	    if (shape->shape == SHAPE_VER)
+	    {
+		cur_height = gui.char_height;
+		cur_width = (gui.char_width * shape->percentage + 99) / 100;
+	    }
+	    else
+	    {
+		cur_height = (gui.char_height * shape->percentage + 99) / 100;
+		cur_width = gui.char_width;
+	    }
+#ifdef FEAT_MBYTE
+	    if (has_mbyte && (*mb_off2cells)(LineOffset[gui.row] + gui.col,
+				    LineOffset[gui.row] + screen_Columns) > 1)
+	    {
+		/* Double wide character. */
+		if (shape->shape != SHAPE_VER)
+		    cur_width += gui.char_width;
+# ifdef FEAT_RIGHTLEFT
+		if (CURSOR_BAR_RIGHT)
+		{
+		    /* gui.col points to the left halve of the character but
+		     * the vertical line needs to be on the right halve.
+		     * A double-wide horizontal line is also drawn from the
+		     * right halve in gui_mch_draw_part_cursor(). */
+		    col_off = TRUE;
+		    ++gui.col;
+		}
+# endif
+	    }
+#endif
+	    gui_mch_draw_part_cursor(cur_width, cur_height, cbg);
+#if defined(FEAT_MBYTE) && defined(FEAT_RIGHTLEFT)
+	    if (col_off)
+		--gui.col;
+#endif
+
+#ifndef FEAT_GUI_MSWIN	    /* doesn't seem to work for MSWindows */
+	    gui.highlight_mask = ScreenAttrs[LineOffset[gui.row] + gui.col];
+	    (void)gui_screenchar(LineOffset[gui.row] + gui.col,
+		    GUI_MON_TRS_CURSOR | GUI_MON_NOCLEAR,
+		    (guicolor_T)0, (guicolor_T)0, 0);
+#endif
+	}
+	gui.highlight_mask = old_hl_mask;
+    }
+}
+
+#if defined(FEAT_MENU) || defined(PROTO)
+    void
+gui_position_menu(void)
+{
+# if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)
+    if (gui.menu_is_active && gui.in_use)
+	gui_mch_set_menu_pos(0, 0, gui.menu_width, gui.menu_height);
+# endif
+}
+#endif
+
+/*
+ * Position the various GUI components (text area, menu).  The vertical
+ * scrollbars are NOT handled here.  See gui_update_scrollbars().
+ */
+    static void
+gui_position_components(int total_width UNUSED)
+{
+    int	    text_area_x;
+    int	    text_area_y;
+    int	    text_area_width;
+    int	    text_area_height;
+
+    /* avoid that moving components around generates events */
+    ++hold_gui_events;
+
+    text_area_x = 0;
+    if (gui.which_scrollbars[SBAR_LEFT])
+	text_area_x += gui.scrollbar_width;
+
+    text_area_y = 0;
+#if defined(FEAT_MENU) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON))
+    gui.menu_width = total_width;
+    if (gui.menu_is_active)
+	text_area_y += gui.menu_height;
+#endif
+#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_MSWIN)
+    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
+	text_area_y = TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT;
+#endif
+
+# if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
+	|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_MAC))
+    if (gui_has_tabline())
+	text_area_y += gui.tabline_height;
+#endif
+
+#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))
+    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
+    {
+# ifdef FEAT_GUI_ATHENA
+	gui_mch_set_toolbar_pos(0, text_area_y,
+				gui.menu_width, gui.toolbar_height);
+# endif
+	text_area_y += gui.toolbar_height;
+    }
+#endif
+
+    text_area_width = gui.num_cols * gui.char_width + gui.border_offset * 2;
+    text_area_height = gui.num_rows * gui.char_height + gui.border_offset * 2;
+
+    gui_mch_set_text_area_pos(text_area_x,
+			      text_area_y,
+			      text_area_width,
+			      text_area_height
+#if defined(FEAT_XIM) && !defined(FEAT_GUI_GTK)
+				  + xim_get_status_area_height()
+#endif
+			      );
+#ifdef FEAT_MENU
+    gui_position_menu();
+#endif
+    if (gui.which_scrollbars[SBAR_BOTTOM])
+	gui_mch_set_scrollbar_pos(&gui.bottom_sbar,
+				  text_area_x,
+				  text_area_y + text_area_height,
+				  text_area_width,
+				  gui.scrollbar_height);
+    gui.left_sbar_x = 0;
+    gui.right_sbar_x = text_area_x + text_area_width;
+
+    --hold_gui_events;
+}
+
+/*
+ * Get the width of the widgets and decorations to the side of the text area.
+ */
+    int
+gui_get_base_width(void)
+{
+    int	    base_width;
+
+    base_width = 2 * gui.border_offset;
+    if (gui.which_scrollbars[SBAR_LEFT])
+	base_width += gui.scrollbar_width;
+    if (gui.which_scrollbars[SBAR_RIGHT])
+	base_width += gui.scrollbar_width;
+    return base_width;
+}
+
+/*
+ * Get the height of the widgets and decorations above and below the text area.
+ */
+    int
+gui_get_base_height(void)
+{
+    int	    base_height;
+
+    base_height = 2 * gui.border_offset;
+    if (gui.which_scrollbars[SBAR_BOTTOM])
+	base_height += gui.scrollbar_height;
+#ifdef FEAT_GUI_GTK
+    /* We can't take the sizes properly into account until anything is
+     * realized.  Therefore we recalculate all the values here just before
+     * setting the size. (--mdcki) */
+#else
+# ifdef FEAT_MENU
+    if (gui.menu_is_active)
+	base_height += gui.menu_height;
+# endif
+# ifdef FEAT_TOOLBAR
+    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
+#  if defined(FEAT_GUI_MSWIN) && defined(FEAT_TOOLBAR)
+	base_height += (TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT);
+#  else
+	base_height += gui.toolbar_height;
+#  endif
+# endif
+# if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
+	|| defined(FEAT_GUI_MOTIF))
+    if (gui_has_tabline())
+	base_height += gui.tabline_height;
+# endif
+# ifdef FEAT_FOOTER
+    if (vim_strchr(p_go, GO_FOOTER) != NULL)
+	base_height += gui.footer_height;
+# endif
+# if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)
+    base_height += gui_mch_text_area_extra_height();
+# endif
+#endif
+    return base_height;
+}
+
+/*
+ * Should be called after the GUI shell has been resized.  Its arguments are
+ * the new width and height of the shell in pixels.
+ */
+    void
+gui_resize_shell(int pixel_width, int pixel_height)
+{
+    static int	busy = FALSE;
+
+    if (!gui.shell_created)	    /* ignore when still initializing */
+	return;
+
+    /*
+     * Can't resize the screen while it is being redrawn.  Remember the new
+     * size and handle it later.
+     */
+    if (updating_screen || busy)
+    {
+	new_pixel_width = pixel_width;
+	new_pixel_height = pixel_height;
+	return;
+    }
+
+again:
+    new_pixel_width = 0;
+    new_pixel_height = 0;
+    busy = TRUE;
+
+    /* Flush pending output before redrawing */
+    out_flush();
+
+    gui.num_cols = (pixel_width - gui_get_base_width()) / gui.char_width;
+    gui.num_rows = (pixel_height - gui_get_base_height()) / gui.char_height;
+
+    gui_position_components(pixel_width);
+    gui_reset_scroll_region();
+
+    /*
+     * At the "more" and ":confirm" prompt there is no redraw, put the cursor
+     * at the last line here (why does it have to be one row too low?).
+     */
+    if (State == ASKMORE || State == CONFIRM)
+	gui.row = gui.num_rows;
+
+    /* Only comparing Rows and Columns may be sufficient, but let's stay on
+     * the safe side. */
+    if (gui.num_rows != screen_Rows || gui.num_cols != screen_Columns
+	    || gui.num_rows != Rows || gui.num_cols != Columns)
+	shell_resized();
+
+    gui_update_scrollbars(TRUE);
+    gui_update_cursor(FALSE, TRUE);
+#if defined(FEAT_XIM) && !defined(FEAT_GUI_GTK)
+    xim_set_status_area();
+#endif
+
+    busy = FALSE;
+
+    /* We may have been called again while redrawing the screen.
+     * Need to do it all again with the latest size then.  But only if the size
+     * actually changed. */
+    if (new_pixel_height)
+    {
+	if (pixel_width == new_pixel_width && pixel_height == new_pixel_height)
+	{
+	    new_pixel_width = 0;
+	    new_pixel_height = 0;
+	}
+	else
+	{
+	    pixel_width = new_pixel_width;
+	    pixel_height = new_pixel_height;
+	    goto again;
+	}
+    }
+}
+
+/*
+ * Check if gui_resize_shell() must be called.
+ */
+    void
+gui_may_resize_shell(void)
+{
+    if (new_pixel_height)
+	/* careful: gui_resize_shell() may postpone the resize again if we
+	 * were called indirectly by it */
+	gui_resize_shell(new_pixel_width, new_pixel_height);
+}
+
+    int
+gui_get_shellsize(void)
+{
+    Rows = gui.num_rows;
+    Columns = gui.num_cols;
+    return OK;
+}
+
+/*
+ * Set the size of the Vim shell according to Rows and Columns.
+ * If "fit_to_display" is TRUE then the size may be reduced to fit the window
+ * on the screen.
+ * When "mustset" is TRUE the size was set by the user. When FALSE a UI
+ * component was added or removed (e.g., a scrollbar).
+ */
+    void
+gui_set_shellsize(
+    int		mustset UNUSED,
+    int		fit_to_display,
+    int		direction)		/* RESIZE_HOR, RESIZE_VER */
+{
+    int		base_width;
+    int		base_height;
+    int		width;
+    int		height;
+    int		min_width;
+    int		min_height;
+    int		screen_w;
+    int		screen_h;
+#ifdef FEAT_GUI_GTK
+    int		un_maximize = mustset;
+    int		did_adjust = 0;
+#endif
+    int		x = -1, y = -1;
+
+    if (!gui.shell_created)
+	return;
+
+#if defined(MSWIN) || defined(FEAT_GUI_GTK)
+    /* If not setting to a user specified size and maximized, calculate the
+     * number of characters that fit in the maximized window. */
+    if (!mustset && (vim_strchr(p_go, GO_KEEPWINSIZE) != NULL
+						       || gui_mch_maximized()))
+    {
+	gui_mch_newfont();
+	return;
+    }
+#endif
+
+    base_width = gui_get_base_width();
+    base_height = gui_get_base_height();
+    if (fit_to_display)
+	/* Remember the original window position. */
+	(void)gui_mch_get_winpos(&x, &y);
+
+#ifdef USE_SUN_WORKSHOP
+    if (!mustset && usingSunWorkShop
+				&& workshop_get_width_height(&width, &height))
+    {
+	Columns = (width - base_width + gui.char_width - 1) / gui.char_width;
+	Rows = (height - base_height + gui.char_height - 1) / gui.char_height;
+    }
+    else
+#endif
+    {
+	width = Columns * gui.char_width + base_width;
+	height = Rows * gui.char_height + base_height;
+    }
+
+    if (fit_to_display)
+    {
+	gui_mch_get_screen_dimensions(&screen_w, &screen_h);
+	if ((direction & RESIZE_HOR) && width > screen_w)
+	{
+	    Columns = (screen_w - base_width) / gui.char_width;
+	    if (Columns < MIN_COLUMNS)
+		Columns = MIN_COLUMNS;
+	    width = Columns * gui.char_width + base_width;
+#ifdef FEAT_GUI_GTK
+	    ++did_adjust;
+#endif
+	}
+	if ((direction & RESIZE_VERT) && height > screen_h)
+	{
+	    Rows = (screen_h - base_height) / gui.char_height;
+	    check_shellsize();
+	    height = Rows * gui.char_height + base_height;
+#ifdef FEAT_GUI_GTK
+	    ++did_adjust;
+#endif
+	}
+#ifdef FEAT_GUI_GTK
+	if (did_adjust == 2 || (width + gui.char_width >= screen_w
+				     && height + gui.char_height >= screen_h))
+	    /* don't unmaximize if at maximum size */
+	    un_maximize = FALSE;
+#endif
+    }
+    limit_screen_size();
+    gui.num_cols = Columns;
+    gui.num_rows = Rows;
+
+    min_width = base_width + MIN_COLUMNS * gui.char_width;
+    min_height = base_height + MIN_LINES * gui.char_height;
+    min_height += tabline_height() * gui.char_height;
+
+#ifdef FEAT_GUI_GTK
+    if (un_maximize)
+    {
+	/* If the window size is smaller than the screen unmaximize the
+	 * window, otherwise resizing won't work. */
+	gui_mch_get_screen_dimensions(&screen_w, &screen_h);
+	if ((width + gui.char_width < screen_w
+				   || height + gui.char_height * 2 < screen_h)
+		&& gui_mch_maximized())
+	    gui_mch_unmaximize();
+    }
+#endif
+
+    gui_mch_set_shellsize(width, height, min_width, min_height,
+					  base_width, base_height, direction);
+
+    if (fit_to_display && x >= 0 && y >= 0)
+    {
+	/* Some window managers put the Vim window left of/above the screen.
+	 * Only change the position if it wasn't already negative before
+	 * (happens on MS-Windows with a secondary monitor). */
+	gui_mch_update();
+	if (gui_mch_get_winpos(&x, &y) == OK && (x < 0 || y < 0))
+	    gui_mch_set_winpos(x < 0 ? 0 : x, y < 0 ? 0 : y);
+    }
+
+    gui_position_components(width);
+    gui_update_scrollbars(TRUE);
+    gui_reset_scroll_region();
+}
+
+/*
+ * Called when Rows and/or Columns has changed.
+ */
+    void
+gui_new_shellsize(void)
+{
+    gui_reset_scroll_region();
+}
+
+/*
+ * Make scroll region cover whole screen.
+ */
+    void
+gui_reset_scroll_region(void)
+{
+    gui.scroll_region_top = 0;
+    gui.scroll_region_bot = gui.num_rows - 1;
+    gui.scroll_region_left = 0;
+    gui.scroll_region_right = gui.num_cols - 1;
+}
+
+    void
+gui_start_highlight(int mask)
+{
+    if (mask > HL_ALL)		    /* highlight code */
+	gui.highlight_mask = mask;
+    else			    /* mask */
+	gui.highlight_mask |= mask;
+}
+
+    void
+gui_stop_highlight(int mask)
+{
+    if (mask > HL_ALL)		    /* highlight code */
+	gui.highlight_mask = HL_NORMAL;
+    else			    /* mask */
+	gui.highlight_mask &= ~mask;
+}
+
+/*
+ * Clear a rectangular region of the screen from text pos (row1, col1) to
+ * (row2, col2) inclusive.
+ */
+    void
+gui_clear_block(
+    int	    row1,
+    int	    col1,
+    int	    row2,
+    int	    col2)
+{
+    /* Clear the selection if we are about to write over it */
+    clip_may_clear_selection(row1, row2);
+
+    gui_mch_clear_block(row1, col1, row2, col2);
+
+    /* Invalidate cursor if it was in this block */
+    if (       gui.cursor_row >= row1 && gui.cursor_row <= row2
+	    && gui.cursor_col >= col1 && gui.cursor_col <= col2)
+	gui.cursor_is_valid = FALSE;
+}
+
+/*
+ * Write code to update the cursor later.  This avoids the need to flush the
+ * output buffer before calling gui_update_cursor().
+ */
+    void
+gui_update_cursor_later(void)
+{
+    OUT_STR(IF_EB("\033|s", ESC_STR "|s"));
+}
+
+    void
+gui_write(
+    char_u	*s,
+    int		len)
+{
+    char_u	*p;
+    int		arg1 = 0, arg2 = 0;
+    int		force_cursor = FALSE;	/* force cursor update */
+    int		force_scrollbar = FALSE;
+    static win_T	*old_curwin = NULL;
+
+/* #define DEBUG_GUI_WRITE */
+#ifdef DEBUG_GUI_WRITE
+    {
+	int i;
+	char_u *str;
+
+	printf("gui_write(%d):\n    ", len);
+	for (i = 0; i < len; i++)
+	    if (s[i] == ESC)
+	    {
+		if (i != 0)
+		    printf("\n    ");
+		printf("<ESC>");
+	    }
+	    else
+	    {
+		str = transchar_byte(s[i]);
+		if (str[0] && str[1])
+		    printf("<%s>", (char *)str);
+		else
+		    printf("%s", (char *)str);
+	    }
+	printf("\n");
+    }
+#endif
+    while (len)
+    {
+	if (s[0] == ESC && s[1] == '|')
+	{
+	    p = s + 2;
+	    if (VIM_ISDIGIT(*p) || (*p == '-' && VIM_ISDIGIT(*(p + 1))))
+	    {
+		arg1 = getdigits(&p);
+		if (p > s + len)
+		    break;
+		if (*p == ';')
+		{
+		    ++p;
+		    arg2 = getdigits(&p);
+		    if (p > s + len)
+			break;
+		}
+	    }
+	    switch (*p)
+	    {
+		case 'C':	/* Clear screen */
+		    clip_scroll_selection(9999);
+		    gui_mch_clear_all();
+		    gui.cursor_is_valid = FALSE;
+		    force_scrollbar = TRUE;
+		    break;
+		case 'M':	/* Move cursor */
+		    gui_set_cursor(arg1, arg2);
+		    break;
+		case 's':	/* force cursor (shape) update */
+		    force_cursor = TRUE;
+		    break;
+		case 'R':	/* Set scroll region */
+		    if (arg1 < arg2)
+		    {
+			gui.scroll_region_top = arg1;
+			gui.scroll_region_bot = arg2;
+		    }
+		    else
+		    {
+			gui.scroll_region_top = arg2;
+			gui.scroll_region_bot = arg1;
+		    }
+		    break;
+		case 'V':	/* Set vertical scroll region */
+		    if (arg1 < arg2)
+		    {
+			gui.scroll_region_left = arg1;
+			gui.scroll_region_right = arg2;
+		    }
+		    else
+		    {
+			gui.scroll_region_left = arg2;
+			gui.scroll_region_right = arg1;
+		    }
+		    break;
+		case 'd':	/* Delete line */
+		    gui_delete_lines(gui.row, 1);
+		    break;
+		case 'D':	/* Delete lines */
+		    gui_delete_lines(gui.row, arg1);
+		    break;
+		case 'i':	/* Insert line */
+		    gui_insert_lines(gui.row, 1);
+		    break;
+		case 'I':	/* Insert lines */
+		    gui_insert_lines(gui.row, arg1);
+		    break;
+		case '$':	/* Clear to end-of-line */
+		    gui_clear_block(gui.row, gui.col, gui.row,
+							    (int)Columns - 1);
+		    break;
+		case 'h':	/* Turn on highlighting */
+		    gui_start_highlight(arg1);
+		    break;
+		case 'H':	/* Turn off highlighting */
+		    gui_stop_highlight(arg1);
+		    break;
+		case 'f':	/* flash the window (visual bell) */
+		    gui_mch_flash(arg1 == 0 ? 20 : arg1);
+		    break;
+		default:
+		    p = s + 1;	/* Skip the ESC */
+		    break;
+	    }
+	    len -= (int)(++p - s);
+	    s = p;
+	}
+	else if (
+#ifdef EBCDIC
+		CtrlChar(s[0]) != 0	/* Ctrl character */
+#else
+		s[0] < 0x20		/* Ctrl character */
+#endif
+#ifdef FEAT_SIGN_ICONS
+		&& s[0] != SIGN_BYTE
+# ifdef FEAT_NETBEANS_INTG
+		&& s[0] != MULTISIGN_BYTE
+# endif
+#endif
+		)
+	{
+	    if (s[0] == '\n')		/* NL */
+	    {
+		gui.col = 0;
+		if (gui.row < gui.scroll_region_bot)
+		    gui.row++;
+		else
+		    gui_delete_lines(gui.scroll_region_top, 1);
+	    }
+	    else if (s[0] == '\r')	/* CR */
+	    {
+		gui.col = 0;
+	    }
+	    else if (s[0] == '\b')	/* Backspace */
+	    {
+		if (gui.col)
+		    --gui.col;
+	    }
+	    else if (s[0] == Ctrl_L)	/* cursor-right */
+	    {
+		++gui.col;
+	    }
+	    else if (s[0] == Ctrl_G)	/* Beep */
+	    {
+		gui_mch_beep();
+	    }
+	    /* Other Ctrl character: shouldn't happen! */
+
+	    --len;	/* Skip this char */
+	    ++s;
+	}
+	else
+	{
+	    p = s;
+	    while (len > 0 && (
+#ifdef EBCDIC
+			CtrlChar(*p) == 0
+#else
+			*p >= 0x20
+#endif
+#ifdef FEAT_SIGN_ICONS
+			|| *p == SIGN_BYTE
+# ifdef FEAT_NETBEANS_INTG
+			|| *p == MULTISIGN_BYTE
+# endif
+#endif
+			))
+	    {
+		len--;
+		p++;
+	    }
+	    gui_outstr(s, (int)(p - s));
+	    s = p;
+	}
+    }
+
+    /* Postponed update of the cursor (won't work if "can_update_cursor" isn't
+     * set). */
+    if (force_cursor)
+	gui_update_cursor(TRUE, TRUE);
+
+    /* When switching to another window the dragging must have stopped.
+     * Required for GTK, dragged_sb isn't reset. */
+    if (old_curwin != curwin)
+	gui.dragged_sb = SBAR_NONE;
+
+    /* Update the scrollbars after clearing the screen or when switched
+     * to another window.
+     * Update the horizontal scrollbar always, it's difficult to check all
+     * situations where it might change. */
+    if (force_scrollbar || old_curwin != curwin)
+	gui_update_scrollbars(force_scrollbar);
+    else
+	gui_update_horiz_scrollbar(FALSE);
+    old_curwin = curwin;
+
+    /*
+     * We need to make sure this is cleared since Athena doesn't tell us when
+     * he is done dragging.  Do the same for GTK.
+     */
+#if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK)
+    gui.dragged_sb = SBAR_NONE;
+#endif
+
+    gui_may_flush();		    /* In case vim decides to take a nap */
+}
+
+/*
+ * When ScreenLines[] is invalid, updating the cursor should not be done, it
+ * produces wrong results.  Call gui_dont_update_cursor() before that code and
+ * gui_can_update_cursor() afterwards.
+ */
+    void
+gui_dont_update_cursor(int undraw)
+{
+    if (gui.in_use)
+    {
+	/* Undraw the cursor now, we probably can't do it after the change. */
+	if (undraw)
+	    gui_undraw_cursor();
+	can_update_cursor = FALSE;
+    }
+}
+
+    void
+gui_can_update_cursor(void)
+{
+    can_update_cursor = TRUE;
+    /* No need to update the cursor right now, there is always more output
+     * after scrolling. */
+}
+
+/*
+ * Disable issuing gui_mch_flush().
+ */
+    void
+gui_disable_flush(void)
+{
+    ++disable_flush;
+}
+
+/*
+ * Enable issuing gui_mch_flush().
+ */
+    void
+gui_enable_flush(void)
+{
+    --disable_flush;
+}
+
+/*
+ * Issue gui_mch_flush() if it is not disabled.
+ */
+    void
+gui_may_flush(void)
+{
+    if (disable_flush == 0)
+	gui_mch_flush();
+}
+
+    static void
+gui_outstr(char_u *s, int len)
+{
+    int	    this_len;
+#ifdef FEAT_MBYTE
+    int	    cells;
+#endif
+
+    if (len == 0)
+	return;
+
+    if (len < 0)
+	len = (int)STRLEN(s);
+
+    while (len > 0)
+    {
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    /* Find out how many chars fit in the current line. */
+	    cells = 0;
+	    for (this_len = 0; this_len < len; )
+	    {
+		cells += (*mb_ptr2cells)(s + this_len);
+		if (gui.col + cells > Columns)
+		    break;
+		this_len += (*mb_ptr2len)(s + this_len);
+	    }
+	    if (this_len > len)
+		this_len = len;	    /* don't include following composing char */
+	}
+	else
+#endif
+	    if (gui.col + len > Columns)
+	    this_len = Columns - gui.col;
+	else
+	    this_len = len;
+
+	(void)gui_outstr_nowrap(s, this_len,
+					  0, (guicolor_T)0, (guicolor_T)0, 0);
+	s += this_len;
+	len -= this_len;
+#ifdef FEAT_MBYTE
+	/* fill up for a double-width char that doesn't fit. */
+	if (len > 0 && gui.col < Columns)
+	    (void)gui_outstr_nowrap((char_u *)" ", 1,
+					  0, (guicolor_T)0, (guicolor_T)0, 0);
+#endif
+	/* The cursor may wrap to the next line. */
+	if (gui.col >= Columns)
+	{
+	    gui.col = 0;
+	    gui.row++;
+	}
+    }
+}
+
+/*
+ * Output one character (may be one or two display cells).
+ * Caller must check for valid "off".
+ * Returns FAIL or OK, just like gui_outstr_nowrap().
+ */
+    static int
+gui_screenchar(
+    int		off,	    /* Offset from start of screen */
+    int		flags,
+    guicolor_T	fg,	    /* colors for cursor */
+    guicolor_T	bg,	    /* colors for cursor */
+    int		back)	    /* backup this many chars when using bold trick */
+{
+#ifdef FEAT_MBYTE
+    char_u	buf[MB_MAXBYTES + 1];
+
+    /* Don't draw right halve of a double-width UTF-8 char. "cannot happen" */
+    if (enc_utf8 && ScreenLines[off] == 0)
+	return OK;
+
+    if (enc_utf8 && ScreenLinesUC[off] != 0)
+	/* Draw UTF-8 multi-byte character. */
+	return gui_outstr_nowrap(buf, utfc_char2bytes(off, buf),
+							 flags, fg, bg, back);
+
+    if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
+    {
+	buf[0] = ScreenLines[off];
+	buf[1] = ScreenLines2[off];
+	return gui_outstr_nowrap(buf, 2, flags, fg, bg, back);
+    }
+
+    /* Draw non-multi-byte character or DBCS character. */
+    return gui_outstr_nowrap(ScreenLines + off,
+	    enc_dbcs ? (*mb_ptr2len)(ScreenLines + off) : 1,
+							 flags, fg, bg, back);
+#else
+    return gui_outstr_nowrap(ScreenLines + off, 1, flags, fg, bg, back);
+#endif
+}
+
+#ifdef FEAT_GUI_GTK
+/*
+ * Output the string at the given screen position.  This is used in place
+ * of gui_screenchar() where possible because Pango needs as much context
+ * as possible to work nicely.  It's a lot faster as well.
+ */
+    static int
+gui_screenstr(
+    int		off,	    /* Offset from start of screen */
+    int		len,	    /* string length in screen cells */
+    int		flags,
+    guicolor_T	fg,	    /* colors for cursor */
+    guicolor_T	bg,	    /* colors for cursor */
+    int		back)	    /* backup this many chars when using bold trick */
+{
+    char_u  *buf;
+    int	    outlen = 0;
+    int	    i;
+    int	    retval;
+
+    if (len <= 0) /* "cannot happen"? */
+	return OK;
+
+    if (enc_utf8)
+    {
+	buf = alloc((unsigned)(len * MB_MAXBYTES + 1));
+	if (buf == NULL)
+	    return OK; /* not much we could do here... */
+
+	for (i = off; i < off + len; ++i)
+	{
+	    if (ScreenLines[i] == 0)
+		continue; /* skip second half of double-width char */
+
+	    if (ScreenLinesUC[i] == 0)
+		buf[outlen++] = ScreenLines[i];
+	    else
+		outlen += utfc_char2bytes(i, buf + outlen);
+	}
+
+	buf[outlen] = NUL; /* only to aid debugging */
+	retval = gui_outstr_nowrap(buf, outlen, flags, fg, bg, back);
+	vim_free(buf);
+
+	return retval;
+    }
+    else if (enc_dbcs == DBCS_JPNU)
+    {
+	buf = alloc((unsigned)(len * 2 + 1));
+	if (buf == NULL)
+	    return OK; /* not much we could do here... */
+
+	for (i = off; i < off + len; ++i)
+	{
+	    buf[outlen++] = ScreenLines[i];
+
+	    /* handle double-byte single-width char */
+	    if (ScreenLines[i] == 0x8e)
+		buf[outlen++] = ScreenLines2[i];
+	    else if (MB_BYTE2LEN(ScreenLines[i]) == 2)
+		buf[outlen++] = ScreenLines[++i];
+	}
+
+	buf[outlen] = NUL; /* only to aid debugging */
+	retval = gui_outstr_nowrap(buf, outlen, flags, fg, bg, back);
+	vim_free(buf);
+
+	return retval;
+    }
+    else
+    {
+	return gui_outstr_nowrap(&ScreenLines[off], len,
+				 flags, fg, bg, back);
+    }
+}
+#endif /* FEAT_GUI_GTK */
+
+/*
+ * Output the given string at the current cursor position.  If the string is
+ * too long to fit on the line, then it is truncated.
+ * "flags":
+ * GUI_MON_IS_CURSOR should only be used when this function is being called to
+ * actually draw (an inverted) cursor.
+ * GUI_MON_TRS_CURSOR is used to draw the cursor text with a transparent
+ * background.
+ * GUI_MON_NOCLEAR is used to avoid clearing the selection when drawing over
+ * it.
+ * Returns OK, unless "back" is non-zero and using the bold trick, then return
+ * FAIL (the caller should start drawing "back" chars back).
+ */
+    int
+gui_outstr_nowrap(
+    char_u	*s,
+    int		len,
+    int		flags,
+    guicolor_T	fg,	    /* colors for cursor */
+    guicolor_T	bg,	    /* colors for cursor */
+    int		back)	    /* backup this many chars when using bold trick */
+{
+    long_u	highlight_mask;
+    long_u	hl_mask_todo;
+    guicolor_T	fg_color;
+    guicolor_T	bg_color;
+    guicolor_T	sp_color;
+#if !defined(FEAT_GUI_GTK)
+    GuiFont	font = NOFONT;
+# ifdef FEAT_MBYTE
+    GuiFont	wide_font = NOFONT;
+# endif
+# ifdef FEAT_XFONTSET
+    GuiFontset	fontset = NOFONTSET;
+# endif
+#endif
+    attrentry_T	*aep = NULL;
+    int		draw_flags;
+    int		col = gui.col;
+#ifdef FEAT_SIGN_ICONS
+    int		draw_sign = FALSE;
+# ifdef FEAT_NETBEANS_INTG
+    int		multi_sign = FALSE;
+# endif
+#endif
+
+    if (len < 0)
+	len = (int)STRLEN(s);
+    if (len == 0)
+	return OK;
+
+#ifdef FEAT_SIGN_ICONS
+    if (*s == SIGN_BYTE
+# ifdef FEAT_NETBEANS_INTG
+	  || *s == MULTISIGN_BYTE
+# endif
+    )
+    {
+# ifdef FEAT_NETBEANS_INTG
+	if (*s == MULTISIGN_BYTE)
+	    multi_sign = TRUE;
+# endif
+	/* draw spaces instead */
+	s = (char_u *)"  ";
+	if (len == 1 && col > 0)
+	    --col;
+	len = 2;
+	draw_sign = TRUE;
+	highlight_mask = 0;
+    }
+    else
+#endif
+    if (gui.highlight_mask > HL_ALL)
+    {
+	aep = syn_gui_attr2entry(gui.highlight_mask);
+	if (aep == NULL)	    /* highlighting not set */
+	    highlight_mask = 0;
+	else
+	    highlight_mask = aep->ae_attr;
+    }
+    else
+	highlight_mask = gui.highlight_mask;
+    hl_mask_todo = highlight_mask;
+
+#if !defined(FEAT_GUI_GTK)
+    /* Set the font */
+    if (aep != NULL && aep->ae_u.gui.font != NOFONT)
+	font = aep->ae_u.gui.font;
+# ifdef FEAT_XFONTSET
+    else if (aep != NULL && aep->ae_u.gui.fontset != NOFONTSET)
+	fontset = aep->ae_u.gui.fontset;
+# endif
+    else
+    {
+# ifdef FEAT_XFONTSET
+	if (gui.fontset != NOFONTSET)
+	    fontset = gui.fontset;
+	else
+# endif
+	    if (hl_mask_todo & (HL_BOLD | HL_STANDOUT))
+	{
+	    if ((hl_mask_todo & HL_ITALIC) && gui.boldital_font != NOFONT)
+	    {
+		font = gui.boldital_font;
+		hl_mask_todo &= ~(HL_BOLD | HL_STANDOUT | HL_ITALIC);
+	    }
+	    else if (gui.bold_font != NOFONT)
+	    {
+		font = gui.bold_font;
+		hl_mask_todo &= ~(HL_BOLD | HL_STANDOUT);
+	    }
+	    else
+		font = gui.norm_font;
+	}
+	else if ((hl_mask_todo & HL_ITALIC) && gui.ital_font != NOFONT)
+	{
+	    font = gui.ital_font;
+	    hl_mask_todo &= ~HL_ITALIC;
+	}
+	else
+	    font = gui.norm_font;
+
+# ifdef FEAT_MBYTE
+	/*
+	 * Choose correct wide_font by font.  wide_font should be set with font
+	 * at same time in above block.  But it will make many "ifdef" nasty
+	 * blocks.  So we do it here.
+	 */
+	if (font == gui.boldital_font && gui.wide_boldital_font)
+	    wide_font = gui.wide_boldital_font;
+	else if (font == gui.bold_font && gui.wide_bold_font)
+	    wide_font = gui.wide_bold_font;
+	else if (font == gui.ital_font && gui.wide_ital_font)
+	    wide_font = gui.wide_ital_font;
+	else if (font == gui.norm_font && gui.wide_font)
+	    wide_font = gui.wide_font;
+# endif
+
+    }
+# ifdef FEAT_XFONTSET
+    if (fontset != NOFONTSET)
+	gui_mch_set_fontset(fontset);
+    else
+# endif
+	gui_mch_set_font(font);
+#endif
+
+    draw_flags = 0;
+
+    /* Set the color */
+    bg_color = gui.back_pixel;
+    if ((flags & GUI_MON_IS_CURSOR) && gui.in_focus)
+    {
+	draw_flags |= DRAW_CURSOR;
+	fg_color = fg;
+	bg_color = bg;
+	sp_color = fg;
+    }
+    else if (aep != NULL)
+    {
+	fg_color = aep->ae_u.gui.fg_color;
+	if (fg_color == INVALCOLOR)
+	    fg_color = gui.norm_pixel;
+	bg_color = aep->ae_u.gui.bg_color;
+	if (bg_color == INVALCOLOR)
+	    bg_color = gui.back_pixel;
+	sp_color = aep->ae_u.gui.sp_color;
+	if (sp_color == INVALCOLOR)
+	    sp_color = fg_color;
+    }
+    else
+    {
+	fg_color = gui.norm_pixel;
+	sp_color = fg_color;
+    }
+
+    if (highlight_mask & (HL_INVERSE | HL_STANDOUT))
+    {
+#if defined(AMIGA)
+	gui_mch_set_colors(bg_color, fg_color);
+#else
+	gui_mch_set_fg_color(bg_color);
+	gui_mch_set_bg_color(fg_color);
+#endif
+    }
+    else
+    {
+#if defined(AMIGA)
+	gui_mch_set_colors(fg_color, bg_color);
+#else
+	gui_mch_set_fg_color(fg_color);
+	gui_mch_set_bg_color(bg_color);
+#endif
+    }
+    gui_mch_set_sp_color(sp_color);
+
+    /* Clear the selection if we are about to write over it */
+    if (!(flags & GUI_MON_NOCLEAR))
+	clip_may_clear_selection(gui.row, gui.row);
+
+
+    /* If there's no bold font, then fake it */
+    if (hl_mask_todo & (HL_BOLD | HL_STANDOUT))
+	draw_flags |= DRAW_BOLD;
+
+    /*
+     * When drawing bold or italic characters the spill-over from the left
+     * neighbor may be destroyed.  Let the caller backup to start redrawing
+     * just after a blank.
+     */
+    if (back != 0 && ((draw_flags & DRAW_BOLD) || (highlight_mask & HL_ITALIC)))
+	return FAIL;
+
+#if defined(FEAT_GUI_GTK)
+    /* If there's no italic font, then fake it.
+     * For GTK2, we don't need a different font for italic style. */
+    if (hl_mask_todo & HL_ITALIC)
+	draw_flags |= DRAW_ITALIC;
+
+    /* Do we underline the text? */
+    if (hl_mask_todo & HL_UNDERLINE)
+	draw_flags |= DRAW_UNDERL;
+
+#else
+    /* Do we underline the text? */
+    if ((hl_mask_todo & HL_UNDERLINE) || (hl_mask_todo & HL_ITALIC))
+	draw_flags |= DRAW_UNDERL;
+#endif
+    /* Do we undercurl the text? */
+    if (hl_mask_todo & HL_UNDERCURL)
+	draw_flags |= DRAW_UNDERC;
+
+    /* Do we strikethrough the text? */
+    if (hl_mask_todo & HL_STRIKETHROUGH)
+	draw_flags |= DRAW_STRIKE;
+
+    /* Do we draw transparently? */
+    if (flags & GUI_MON_TRS_CURSOR)
+	draw_flags |= DRAW_TRANSP;
+
+    /*
+     * Draw the text.
+     */
+#ifdef FEAT_GUI_GTK
+    /* The value returned is the length in display cells */
+    len = gui_gtk2_draw_string(gui.row, col, s, len, draw_flags);
+#else
+# ifdef FEAT_MBYTE
+    if (enc_utf8)
+    {
+	int	start;		/* index of bytes to be drawn */
+	int	cells;		/* cellwidth of bytes to be drawn */
+	int	thislen;	/* length of bytes to be drawn */
+	int	cn;		/* cellwidth of current char */
+	int	i;		/* index of current char */
+	int	c;		/* current char value */
+	int	cl;		/* byte length of current char */
+	int	comping;	/* current char is composing */
+	int	scol = col;	/* screen column */
+	int	curr_wide = FALSE;  /* use 'guifontwide' */
+	int	prev_wide = FALSE;
+	int	wide_changed;
+#  ifdef WIN3264
+	int	sep_comp = FALSE;   /* Don't separate composing chars. */
+#  else
+	int	sep_comp = TRUE;    /* Separate composing chars. */
+#  endif
+
+	/* Break the string at a composing character, it has to be drawn on
+	 * top of the previous character. */
+	start = 0;
+	cells = 0;
+	for (i = 0; i < len; i += cl)
+	{
+	    c = utf_ptr2char(s + i);
+	    cn = utf_char2cells(c);
+	    comping = utf_iscomposing(c);
+	    if (!comping)	/* count cells from non-composing chars */
+		cells += cn;
+	    if (!comping || sep_comp)
+	    {
+		if (cn > 1
+#  ifdef FEAT_XFONTSET
+			&& fontset == NOFONTSET
+#  endif
+			&& wide_font != NOFONT)
+		    curr_wide = TRUE;
+		else
+		    curr_wide = FALSE;
+	    }
+	    cl = utf_ptr2len(s + i);
+	    if (cl == 0)	/* hit end of string */
+		len = i + cl;	/* len must be wrong "cannot happen" */
+
+	    wide_changed = curr_wide != prev_wide;
+
+	    /* Print the string so far if it's the last character or there is
+	     * a composing character. */
+	    if (i + cl >= len || (comping && sep_comp && i > start)
+		    || wide_changed
+#  if defined(FEAT_GUI_X11)
+		    || (cn > 1
+#   ifdef FEAT_XFONTSET
+			/* No fontset: At least draw char after wide char at
+			 * right position. */
+			&& fontset == NOFONTSET
+#   endif
+		       )
+#  endif
+	       )
+	    {
+		if ((comping && sep_comp) || wide_changed)
+		    thislen = i - start;
+		else
+		    thislen = i - start + cl;
+		if (thislen > 0)
+		{
+		    if (prev_wide)
+			gui_mch_set_font(wide_font);
+		    gui_mch_draw_string(gui.row, scol, s + start, thislen,
+								  draw_flags);
+		    if (prev_wide)
+			gui_mch_set_font(font);
+		    start += thislen;
+		}
+		scol += cells;
+		cells = 0;
+		/* Adjust to not draw a character which width is changed
+		 * against with last one. */
+		if (wide_changed && !(comping && sep_comp))
+		{
+		    scol -= cn;
+		    cl = 0;
+		}
+
+#  if defined(FEAT_GUI_X11)
+		/* No fontset: draw a space to fill the gap after a wide char
+		 * */
+		if (cn > 1 && (draw_flags & DRAW_TRANSP) == 0
+#   ifdef FEAT_XFONTSET
+			&& fontset == NOFONTSET
+#   endif
+			&& !wide_changed)
+		    gui_mch_draw_string(gui.row, scol - 1, (char_u *)" ",
+							       1, draw_flags);
+#  endif
+	    }
+	    /* Draw a composing char on top of the previous char. */
+	    if (comping && sep_comp)
+	    {
+#  if defined(__APPLE_CC__) && TARGET_API_MAC_CARBON
+		/* Carbon ATSUI autodraws composing char over previous char */
+		gui_mch_draw_string(gui.row, scol, s + i, cl,
+						    draw_flags | DRAW_TRANSP);
+#  else
+		gui_mch_draw_string(gui.row, scol - cn, s + i, cl,
+						    draw_flags | DRAW_TRANSP);
+#  endif
+		start = i + cl;
+	    }
+	    prev_wide = curr_wide;
+	}
+	/* The stuff below assumes "len" is the length in screen columns. */
+	len = scol - col;
+    }
+    else
+# endif
+    {
+	gui_mch_draw_string(gui.row, col, s, len, draw_flags);
+# ifdef FEAT_MBYTE
+	if (enc_dbcs == DBCS_JPNU)
+	{
+	    /* Get the length in display cells, this can be different from the
+	     * number of bytes for "euc-jp". */
+	    len = mb_string2cells(s, len);
+	}
+# endif
+    }
+#endif /* !FEAT_GUI_GTK */
+
+    if (!(flags & (GUI_MON_IS_CURSOR | GUI_MON_TRS_CURSOR)))
+	gui.col = col + len;
+
+    /* May need to invert it when it's part of the selection. */
+    if (flags & GUI_MON_NOCLEAR)
+	clip_may_redraw_selection(gui.row, col, len);
+
+    if (!(flags & (GUI_MON_IS_CURSOR | GUI_MON_TRS_CURSOR)))
+    {
+	/* Invalidate the old physical cursor position if we wrote over it */
+	if (gui.cursor_row == gui.row
+		&& gui.cursor_col >= col
+		&& gui.cursor_col < col + len)
+	    gui.cursor_is_valid = FALSE;
+    }
+
+#ifdef FEAT_SIGN_ICONS
+    if (draw_sign)
+	/* Draw the sign on top of the spaces. */
+	gui_mch_drawsign(gui.row, col, gui.highlight_mask);
+# if defined(FEAT_NETBEANS_INTG) && (defined(FEAT_GUI_X11) \
+	|| defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32))
+    if (multi_sign)
+	netbeans_draw_multisign_indicator(gui.row);
+# endif
+#endif
+
+    return OK;
+}
+
+/*
+ * Un-draw the cursor.	Actually this just redraws the character at the given
+ * position.  The character just before it too, for when it was in bold.
+ */
+    void
+gui_undraw_cursor(void)
+{
+    if (gui.cursor_is_valid)
+    {
+#ifdef FEAT_HANGULIN
+	if (composing_hangul
+		    && gui.col == gui.cursor_col && gui.row == gui.cursor_row)
+	{
+	    char_u *comp_buf;
+	    int comp_len;
+
+	    comp_buf = hangul_composing_buffer_get(&comp_len);
+	    if (comp_buf)
+	    {
+		(void)gui_outstr_nowrap(comp_buf, comp_len,
+					GUI_MON_IS_CURSOR | GUI_MON_NOCLEAR,
+					gui.norm_pixel, gui.back_pixel, 0);
+		vim_free(comp_buf);
+	    }
+	}
+	else
+	{
+#endif
+	if (gui_redraw_block(gui.cursor_row, gui.cursor_col,
+			      gui.cursor_row, gui.cursor_col, GUI_MON_NOCLEAR)
+		&& gui.cursor_col > 0)
+	    (void)gui_redraw_block(gui.cursor_row, gui.cursor_col - 1,
+			 gui.cursor_row, gui.cursor_col - 1, GUI_MON_NOCLEAR);
+#ifdef FEAT_HANGULIN
+	    if (composing_hangul)
+		(void)gui_redraw_block(gui.cursor_row, gui.cursor_col + 1,
+			gui.cursor_row, gui.cursor_col + 1, GUI_MON_NOCLEAR);
+	}
+#endif
+	/* Cursor_is_valid is reset when the cursor is undrawn, also reset it
+	 * here in case it wasn't needed to undraw it. */
+	gui.cursor_is_valid = FALSE;
+    }
+}
+
+    void
+gui_redraw(
+    int		x,
+    int		y,
+    int		w,
+    int		h)
+{
+    int		row1, col1, row2, col2;
+
+    row1 = Y_2_ROW(y);
+    col1 = X_2_COL(x);
+    row2 = Y_2_ROW(y + h - 1);
+    col2 = X_2_COL(x + w - 1);
+
+    (void)gui_redraw_block(row1, col1, row2, col2, GUI_MON_NOCLEAR);
+
+    /*
+     * We may need to redraw the cursor, but don't take it upon us to change
+     * its location after a scroll.
+     * (maybe be more strict even and test col too?)
+     * These things may be outside the update/clipping region and reality may
+     * not reflect Vims internal ideas if these operations are clipped away.
+     */
+    if (gui.row == gui.cursor_row)
+	gui_update_cursor(TRUE, TRUE);
+}
+
+/*
+ * Draw a rectangular block of characters, from row1 to row2 (inclusive) and
+ * from col1 to col2 (inclusive).
+ * Return TRUE when the character before the first drawn character has
+ * different attributes (may have to be redrawn too).
+ */
+    int
+gui_redraw_block(
+    int		row1,
+    int		col1,
+    int		row2,
+    int		col2,
+    int		flags)	/* flags for gui_outstr_nowrap() */
+{
+    int		old_row, old_col;
+    long_u	old_hl_mask;
+    int		off;
+    sattr_T	first_attr;
+    int		idx, len;
+    int		back, nback;
+    int		retval = FALSE;
+#ifdef FEAT_MBYTE
+    int		orig_col1, orig_col2;
+#endif
+
+    /* Don't try to update when ScreenLines is not valid */
+    if (!screen_cleared || ScreenLines == NULL)
+	return retval;
+
+    /* Don't try to draw outside the shell! */
+    /* Check everything, strange values may be caused by a big border width */
+    col1 = check_col(col1);
+    col2 = check_col(col2);
+    row1 = check_row(row1);
+    row2 = check_row(row2);
+
+    /* Remember where our cursor was */
+    old_row = gui.row;
+    old_col = gui.col;
+    old_hl_mask = gui.highlight_mask;
+#ifdef FEAT_MBYTE
+    orig_col1 = col1;
+    orig_col2 = col2;
+#endif
+
+    for (gui.row = row1; gui.row <= row2; gui.row++)
+    {
+#ifdef FEAT_MBYTE
+	/* When only half of a double-wide character is in the block, include
+	 * the other half. */
+	col1 = orig_col1;
+	col2 = orig_col2;
+	off = LineOffset[gui.row];
+	if (enc_dbcs != 0)
+	{
+	    if (col1 > 0)
+		col1 -= dbcs_screen_head_off(ScreenLines + off,
+						    ScreenLines + off + col1);
+	    col2 += dbcs_screen_tail_off(ScreenLines + off,
+						    ScreenLines + off + col2);
+	}
+	else if (enc_utf8)
+	{
+	    if (ScreenLines[off + col1] == 0)
+		--col1;
+# ifdef FEAT_GUI_GTK
+	    if (col2 + 1 < Columns && ScreenLines[off + col2 + 1] == 0)
+		++col2;
+# endif
+	}
+#endif
+	gui.col = col1;
+	off = LineOffset[gui.row] + gui.col;
+	len = col2 - col1 + 1;
+
+	/* Find how many chars back this highlighting starts, or where a space
+	 * is.  Needed for when the bold trick is used */
+	for (back = 0; back < col1; ++back)
+	    if (ScreenAttrs[off - 1 - back] != ScreenAttrs[off]
+		    || ScreenLines[off - 1 - back] == ' ')
+		break;
+	retval = (col1 > 0 && ScreenAttrs[off - 1] != 0 && back == 0
+					      && ScreenLines[off - 1] != ' ');
+
+	/* Break it up in strings of characters with the same attributes. */
+	/* Print UTF-8 characters individually. */
+	while (len > 0)
+	{
+	    first_attr = ScreenAttrs[off];
+	    gui.highlight_mask = first_attr;
+#if defined(FEAT_MBYTE) && !defined(FEAT_GUI_GTK)
+	    if (enc_utf8 && ScreenLinesUC[off] != 0)
+	    {
+		/* output multi-byte character separately */
+		nback = gui_screenchar(off, flags,
+					  (guicolor_T)0, (guicolor_T)0, back);
+		if (gui.col < Columns && ScreenLines[off + 1] == 0)
+		    idx = 2;
+		else
+		    idx = 1;
+	    }
+	    else if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
+	    {
+		/* output double-byte, single-width character separately */
+		nback = gui_screenchar(off, flags,
+					  (guicolor_T)0, (guicolor_T)0, back);
+		idx = 1;
+	    }
+	    else
+#endif
+	    {
+#ifdef FEAT_GUI_GTK
+		for (idx = 0; idx < len; ++idx)
+		{
+		    if (enc_utf8 && ScreenLines[off + idx] == 0)
+			continue; /* skip second half of double-width char */
+		    if (ScreenAttrs[off + idx] != first_attr)
+			break;
+		}
+		/* gui_screenstr() takes care of multibyte chars */
+		nback = gui_screenstr(off, idx, flags,
+				      (guicolor_T)0, (guicolor_T)0, back);
+#else
+		for (idx = 0; idx < len && ScreenAttrs[off + idx] == first_attr;
+									idx++)
+		{
+# ifdef FEAT_MBYTE
+		    /* Stop at a multi-byte Unicode character. */
+		    if (enc_utf8 && ScreenLinesUC[off + idx] != 0)
+			break;
+		    if (enc_dbcs == DBCS_JPNU)
+		    {
+			/* Stop at a double-byte single-width char. */
+			if (ScreenLines[off + idx] == 0x8e)
+			    break;
+			if (len > 1 && (*mb_ptr2len)(ScreenLines
+							    + off + idx) == 2)
+			    ++idx;  /* skip second byte of double-byte char */
+		    }
+# endif
+		}
+		nback = gui_outstr_nowrap(ScreenLines + off, idx, flags,
+					  (guicolor_T)0, (guicolor_T)0, back);
+#endif
+	    }
+	    if (nback == FAIL)
+	    {
+		/* Must back up to start drawing where a bold or italic word
+		 * starts. */
+		off -= back;
+		len += back;
+		gui.col -= back;
+	    }
+	    else
+	    {
+		off += idx;
+		len -= idx;
+	    }
+	    back = 0;
+	}
+    }
+
+    /* Put the cursor back where it was */
+    gui.row = old_row;
+    gui.col = old_col;
+    gui.highlight_mask = (int)old_hl_mask;
+
+    return retval;
+}
+
+    static void
+gui_delete_lines(int row, int count)
+{
+    if (count <= 0)
+	return;
+
+    if (row + count > gui.scroll_region_bot)
+	/* Scrolled out of region, just blank the lines out */
+	gui_clear_block(row, gui.scroll_region_left,
+			      gui.scroll_region_bot, gui.scroll_region_right);
+    else
+    {
+	gui_mch_delete_lines(row, count);
+
+	/* If the cursor was in the deleted lines it's now gone.  If the
+	 * cursor was in the scrolled lines adjust its position. */
+	if (gui.cursor_row >= row
+		&& gui.cursor_col >= gui.scroll_region_left
+		&& gui.cursor_col <= gui.scroll_region_right)
+	{
+	    if (gui.cursor_row < row + count)
+		gui.cursor_is_valid = FALSE;
+	    else if (gui.cursor_row <= gui.scroll_region_bot)
+		gui.cursor_row -= count;
+	}
+    }
+}
+
+    static void
+gui_insert_lines(int row, int count)
+{
+    if (count <= 0)
+	return;
+
+    if (row + count > gui.scroll_region_bot)
+	/* Scrolled out of region, just blank the lines out */
+	gui_clear_block(row, gui.scroll_region_left,
+			      gui.scroll_region_bot, gui.scroll_region_right);
+    else
+    {
+	gui_mch_insert_lines(row, count);
+
+	if (gui.cursor_row >= gui.row
+		&& gui.cursor_col >= gui.scroll_region_left
+		&& gui.cursor_col <= gui.scroll_region_right)
+	{
+	    if (gui.cursor_row <= gui.scroll_region_bot - count)
+		gui.cursor_row += count;
+	    else if (gui.cursor_row <= gui.scroll_region_bot)
+		gui.cursor_is_valid = FALSE;
+	}
+    }
+}
+
+#ifdef FEAT_TIMERS
+/*
+ * Passed to ui_wait_for_chars_or_timer(), ignoring extra arguments.
+ */
+    static int
+gui_wait_for_chars_3(
+    long wtime,
+    int *interrupted UNUSED,
+    int ignore_input UNUSED)
+{
+    return gui_mch_wait_for_chars(wtime);
+}
+#endif
+
+/*
+ * Returns OK if a character was found to be available within the given time,
+ * or FAIL otherwise.
+ */
+    static int
+gui_wait_for_chars_or_timer(long wtime)
+{
+#ifdef FEAT_TIMERS
+    return ui_wait_for_chars_or_timer(wtime, gui_wait_for_chars_3, NULL, 0);
+#else
+    return gui_mch_wait_for_chars(wtime);
+#endif
+}
+
+/*
+ * The main GUI input routine.	Waits for a character from the keyboard.
+ * wtime == -1	    Wait forever.
+ * wtime == 0	    Don't wait.
+ * wtime > 0	    Wait wtime milliseconds for a character.
+ * Returns OK if a character was found to be available within the given time,
+ * or FAIL otherwise.
+ */
+    int
+gui_wait_for_chars(long wtime, int tb_change_cnt)
+{
+    int	    retval;
+#if defined(ELAPSED_FUNC)
+    ELAPSED_TYPE start_tv;
+#endif
+
+#ifdef FEAT_MENU
+    /*
+     * If we're going to wait a bit, update the menus and mouse shape for the
+     * current State.
+     */
+    if (wtime != 0)
+	gui_update_menus(0);
+#endif
+
+    gui_mch_update();
+    if (input_available())	/* Got char, return immediately */
+	return OK;
+    if (wtime == 0)	/* Don't wait for char */
+	return FAIL;
+
+    /* Before waiting, flush any output to the screen. */
+    gui_mch_flush();
+
+    if (wtime > 0)
+    {
+	/* Blink when waiting for a character.	Probably only does something
+	 * for showmatch() */
+	gui_mch_start_blink();
+	retval = gui_wait_for_chars_or_timer(wtime);
+	gui_mch_stop_blink(TRUE);
+	return retval;
+    }
+
+#if defined(ELAPSED_FUNC)
+    ELAPSED_INIT(start_tv);
+#endif
+
+    /*
+     * While we are waiting indefinitely for a character, blink the cursor.
+     */
+    gui_mch_start_blink();
+
+    retval = FAIL;
+    /*
+     * We may want to trigger the CursorHold event.  First wait for
+     * 'updatetime' and if nothing is typed within that time, and feedkeys()
+     * wasn't used, put the K_CURSORHOLD key in the input buffer.
+     */
+    if (gui_wait_for_chars_or_timer(p_ut) == OK)
+	retval = OK;
+    else if (trigger_cursorhold()
+#ifdef ELAPSED_FUNC
+	    && ELAPSED_FUNC(start_tv) >= p_ut
+#endif
+	    && typebuf.tb_change_cnt == tb_change_cnt)
+    {
+	char_u	buf[3];
+
+	/* Put K_CURSORHOLD in the input buffer. */
+	buf[0] = CSI;
+	buf[1] = KS_EXTRA;
+	buf[2] = (int)KE_CURSORHOLD;
+	add_to_input_buf(buf, 3);
+
+	retval = OK;
+    }
+
+    if (retval == FAIL && typebuf.tb_change_cnt == tb_change_cnt)
+    {
+	/* Blocking wait. */
+	before_blocking();
+	retval = gui_wait_for_chars_or_timer(-1L);
+    }
+
+    gui_mch_stop_blink(TRUE);
+    return retval;
+}
+
+/*
+ * Equivalent of mch_inchar() for the GUI.
+ */
+    int
+gui_inchar(
+    char_u  *buf,
+    int	    maxlen,
+    long    wtime,		/* milli seconds */
+    int	    tb_change_cnt)
+{
+    if (gui_wait_for_chars(wtime, tb_change_cnt)
+	    && !typebuf_changed(tb_change_cnt))
+	return read_from_input_buf(buf, (long)maxlen);
+    return 0;
+}
+
+/*
+ * Fill p[4] with mouse coordinates encoded for check_termcode().
+ */
+    static void
+fill_mouse_coord(char_u *p, int col, int row)
+{
+    p[0] = (char_u)(col / 128 + ' ' + 1);
+    p[1] = (char_u)(col % 128 + ' ' + 1);
+    p[2] = (char_u)(row / 128 + ' ' + 1);
+    p[3] = (char_u)(row % 128 + ' ' + 1);
+}
+
+/*
+ * Generic mouse support function.  Add a mouse event to the input buffer with
+ * the given properties.
+ *  button	    --- may be any of MOUSE_LEFT, MOUSE_MIDDLE, MOUSE_RIGHT,
+ *			MOUSE_X1, MOUSE_X2
+ *			MOUSE_DRAG, or MOUSE_RELEASE.
+ *			MOUSE_4 and MOUSE_5 are used for vertical scroll wheel,
+ *			MOUSE_6 and MOUSE_7 for horizontal scroll wheel.
+ *  x, y	    --- Coordinates of mouse in pixels.
+ *  repeated_click  --- TRUE if this click comes only a short time after a
+ *			previous click.
+ *  modifiers	    --- Bit field which may be any of the following modifiers
+ *			or'ed together: MOUSE_SHIFT | MOUSE_CTRL | MOUSE_ALT.
+ * This function will ignore drag events where the mouse has not moved to a new
+ * character.
+ */
+    void
+gui_send_mouse_event(
+    int	    button,
+    int	    x,
+    int	    y,
+    int	    repeated_click,
+    int_u   modifiers)
+{
+    static int	    prev_row = 0, prev_col = 0;
+    static int	    prev_button = -1;
+    static int	    num_clicks = 1;
+    char_u	    string[10];
+    enum key_extra  button_char;
+    int		    row, col;
+#ifdef FEAT_CLIPBOARD
+    int		    checkfor;
+    int		    did_clip = FALSE;
+#endif
+
+    /*
+     * Scrolling may happen at any time, also while a selection is present.
+     */
+    switch (button)
+    {
+	case MOUSE_X1:
+	    button_char = KE_X1MOUSE;
+	    goto button_set;
+	case MOUSE_X2:
+	    button_char = KE_X2MOUSE;
+	    goto button_set;
+	case MOUSE_4:
+	    button_char = KE_MOUSEDOWN;
+	    goto button_set;
+	case MOUSE_5:
+	    button_char = KE_MOUSEUP;
+	    goto button_set;
+	case MOUSE_6:
+	    button_char = KE_MOUSELEFT;
+	    goto button_set;
+	case MOUSE_7:
+	    button_char = KE_MOUSERIGHT;
+button_set:
+	    {
+		/* Don't put events in the input queue now. */
+		if (hold_gui_events)
+		    return;
+
+		string[3] = CSI;
+		string[4] = KS_EXTRA;
+		string[5] = (int)button_char;
+
+		/* Pass the pointer coordinates of the scroll event so that we
+		 * know which window to scroll. */
+		row = gui_xy2colrow(x, y, &col);
+		string[6] = (char_u)(col / 128 + ' ' + 1);
+		string[7] = (char_u)(col % 128 + ' ' + 1);
+		string[8] = (char_u)(row / 128 + ' ' + 1);
+		string[9] = (char_u)(row % 128 + ' ' + 1);
+
+		if (modifiers == 0)
+		    add_to_input_buf(string + 3, 7);
+		else
+		{
+		    string[0] = CSI;
+		    string[1] = KS_MODIFIER;
+		    string[2] = 0;
+		    if (modifiers & MOUSE_SHIFT)
+			string[2] |= MOD_MASK_SHIFT;
+		    if (modifiers & MOUSE_CTRL)
+			string[2] |= MOD_MASK_CTRL;
+		    if (modifiers & MOUSE_ALT)
+			string[2] |= MOD_MASK_ALT;
+		    add_to_input_buf(string, 10);
+		}
+		return;
+	    }
+    }
+
+#ifdef FEAT_CLIPBOARD
+    /* If a clipboard selection is in progress, handle it */
+    if (clip_star.state == SELECT_IN_PROGRESS)
+    {
+	clip_process_selection(button, X_2_COL(x), Y_2_ROW(y), repeated_click);
+	return;
+    }
+
+    /* Determine which mouse settings to look for based on the current mode */
+    switch (get_real_state())
+    {
+	case NORMAL_BUSY:
+	case OP_PENDING:
+# ifdef FEAT_TERMINAL
+	case TERMINAL:
+# endif
+	case NORMAL:		checkfor = MOUSE_NORMAL;	break;
+	case VISUAL:		checkfor = MOUSE_VISUAL;	break;
+	case SELECTMODE:	checkfor = MOUSE_VISUAL;	break;
+	case REPLACE:
+	case REPLACE+LANGMAP:
+	case VREPLACE:
+	case VREPLACE+LANGMAP:
+	case INSERT:
+	case INSERT+LANGMAP:	checkfor = MOUSE_INSERT;	break;
+	case ASKMORE:
+	case HITRETURN:		/* At the more- and hit-enter prompt pass the
+				   mouse event for a click on or below the
+				   message line. */
+				if (Y_2_ROW(y) >= msg_row)
+				    checkfor = MOUSE_NORMAL;
+				else
+				    checkfor = MOUSE_RETURN;
+				break;
+
+	    /*
+	     * On the command line, use the clipboard selection on all lines
+	     * but the command line.  But not when pasting.
+	     */
+	case CMDLINE:
+	case CMDLINE+LANGMAP:
+	    if (Y_2_ROW(y) < cmdline_row && button != MOUSE_MIDDLE)
+		checkfor = MOUSE_NONE;
+	    else
+		checkfor = MOUSE_COMMAND;
+	    break;
+
+	default:
+	    checkfor = MOUSE_NONE;
+	    break;
+    };
+
+    /*
+     * Allow clipboard selection of text on the command line in "normal"
+     * modes.  Don't do this when dragging the status line, or extending a
+     * Visual selection.
+     */
+    if ((State == NORMAL || State == NORMAL_BUSY || (State & INSERT))
+	    && Y_2_ROW(y) >= topframe->fr_height + firstwin->w_winrow
+	    && button != MOUSE_DRAG
+# ifdef FEAT_MOUSESHAPE
+	    && !drag_status_line
+	    && !drag_sep_line
+# endif
+	    )
+	checkfor = MOUSE_NONE;
+
+    /*
+     * Use modeless selection when holding CTRL and SHIFT pressed.
+     */
+    if ((modifiers & MOUSE_CTRL) && (modifiers & MOUSE_SHIFT))
+	checkfor = MOUSE_NONEF;
+
+    /*
+     * In Ex mode, always use modeless selection.
+     */
+    if (exmode_active)
+	checkfor = MOUSE_NONE;
+
+    /*
+     * If the mouse settings say to not use the mouse, use the modeless
+     * selection.  But if Visual is active, assume that only the Visual area
+     * will be selected.
+     * Exception: On the command line, both the selection is used and a mouse
+     * key is send.
+     */
+    if (!mouse_has(checkfor) || checkfor == MOUSE_COMMAND)
+    {
+	/* Don't do modeless selection in Visual mode. */
+	if (checkfor != MOUSE_NONEF && VIsual_active && (State & NORMAL))
+	    return;
+
+	/*
+	 * When 'mousemodel' is "popup", shift-left is translated to right.
+	 * But not when also using Ctrl.
+	 */
+	if (mouse_model_popup() && button == MOUSE_LEFT
+		&& (modifiers & MOUSE_SHIFT) && !(modifiers & MOUSE_CTRL))
+	{
+	    button = MOUSE_RIGHT;
+	    modifiers &= ~ MOUSE_SHIFT;
+	}
+
+	/* If the selection is done, allow the right button to extend it.
+	 * If the selection is cleared, allow the right button to start it
+	 * from the cursor position. */
+	if (button == MOUSE_RIGHT)
+	{
+	    if (clip_star.state == SELECT_CLEARED)
+	    {
+		if (State & CMDLINE)
+		{
+		    col = msg_col;
+		    row = msg_row;
+		}
+		else
+		{
+		    col = curwin->w_wcol;
+		    row = curwin->w_wrow + W_WINROW(curwin);
+		}
+		clip_start_selection(col, row, FALSE);
+	    }
+	    clip_process_selection(button, X_2_COL(x), Y_2_ROW(y),
+							      repeated_click);
+	    did_clip = TRUE;
+	}
+	/* Allow the left button to start the selection */
+	else if (button == MOUSE_LEFT)
+	{
+	    clip_start_selection(X_2_COL(x), Y_2_ROW(y), repeated_click);
+	    did_clip = TRUE;
+	}
+
+	/* Always allow pasting */
+	if (button != MOUSE_MIDDLE)
+	{
+	    if (!mouse_has(checkfor) || button == MOUSE_RELEASE)
+		return;
+	    if (checkfor != MOUSE_COMMAND)
+		button = MOUSE_LEFT;
+	}
+	repeated_click = FALSE;
+    }
+
+    if (clip_star.state != SELECT_CLEARED && !did_clip)
+	clip_clear_selection(&clip_star);
+#endif
+
+    /* Don't put events in the input queue now. */
+    if (hold_gui_events)
+	return;
+
+    row = gui_xy2colrow(x, y, &col);
+
+    /*
+     * If we are dragging and the mouse hasn't moved far enough to be on a
+     * different character, then don't send an event to vim.
+     */
+    if (button == MOUSE_DRAG)
+    {
+	if (row == prev_row && col == prev_col)
+	    return;
+	/* Dragging above the window, set "row" to -1 to cause a scroll. */
+	if (y < 0)
+	    row = -1;
+    }
+
+    /*
+     * If topline has changed (window scrolled) since the last click, reset
+     * repeated_click, because we don't want starting Visual mode when
+     * clicking on a different character in the text.
+     */
+    if (curwin->w_topline != gui_prev_topline
+#ifdef FEAT_DIFF
+	    || curwin->w_topfill != gui_prev_topfill
+#endif
+	    )
+	repeated_click = FALSE;
+
+    string[0] = CSI;	/* this sequence is recognized by check_termcode() */
+    string[1] = KS_MOUSE;
+    string[2] = KE_FILLER;
+    if (button != MOUSE_DRAG && button != MOUSE_RELEASE)
+    {
+	if (repeated_click)
+	{
+	    /*
+	     * Handle multiple clicks.	They only count if the mouse is still
+	     * pointing at the same character.
+	     */
+	    if (button != prev_button || row != prev_row || col != prev_col)
+		num_clicks = 1;
+	    else if (++num_clicks > 4)
+		num_clicks = 1;
+	}
+	else
+	    num_clicks = 1;
+	prev_button = button;
+	gui_prev_topline = curwin->w_topline;
+#ifdef FEAT_DIFF
+	gui_prev_topfill = curwin->w_topfill;
+#endif
+
+	string[3] = (char_u)(button | 0x20);
+	SET_NUM_MOUSE_CLICKS(string[3], num_clicks);
+    }
+    else
+	string[3] = (char_u)button;
+
+    string[3] |= modifiers;
+    fill_mouse_coord(string + 4, col, row);
+    add_to_input_buf(string, 8);
+
+    if (row < 0)
+	prev_row = 0;
+    else
+	prev_row = row;
+    prev_col = col;
+
+    /*
+     * We need to make sure this is cleared since Athena doesn't tell us when
+     * he is done dragging.  Neither does GTK+ 2 -- at least for now.
+     */
+#if defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK)
+    gui.dragged_sb = SBAR_NONE;
+#endif
+}
+
+/*
+ * Convert x and y coordinate to column and row in text window.
+ * Corrects for multi-byte character.
+ * returns column in "*colp" and row as return value;
+ */
+    int
+gui_xy2colrow(int x, int y, int *colp)
+{
+    int		col = check_col(X_2_COL(x));
+    int		row = check_row(Y_2_ROW(y));
+
+#ifdef FEAT_MBYTE
+    *colp = mb_fix_col(col, row);
+#else
+    *colp = col;
+#endif
+    return row;
+}
+
+#if defined(FEAT_MENU) || defined(PROTO)
+/*
+ * Callback function for when a menu entry has been selected.
+ */
+    void
+gui_menu_cb(vimmenu_T *menu)
+{
+    char_u  bytes[sizeof(long_u)];
+
+    /* Don't put events in the input queue now. */
+    if (hold_gui_events)
+	return;
+
+    bytes[0] = CSI;
+    bytes[1] = KS_MENU;
+    bytes[2] = KE_FILLER;
+    add_to_input_buf(bytes, 3);
+    add_long_to_buf((long_u)menu, bytes);
+    add_to_input_buf_csi(bytes, sizeof(long_u));
+}
+#endif
+
+static int	prev_which_scrollbars[3];
+
+/*
+ * Set which components are present.
+ * If "oldval" is not NULL, "oldval" is the previous value, the new value is
+ * in p_go.
+ */
+    void
+gui_init_which_components(char_u *oldval UNUSED)
+{
+#ifdef FEAT_MENU
+    static int	prev_menu_is_active = -1;
+#endif
+#ifdef FEAT_TOOLBAR
+    static int	prev_toolbar = -1;
+    int		using_toolbar = FALSE;
+#endif
+#ifdef FEAT_GUI_TABLINE
+    int		using_tabline;
+#endif
+#ifdef FEAT_FOOTER
+    static int	prev_footer = -1;
+    int		using_footer = FALSE;
+#endif
+#if defined(FEAT_MENU)
+    static int	prev_tearoff = -1;
+    int		using_tearoff = FALSE;
+#endif
+
+    char_u	*p;
+    int		i;
+#ifdef FEAT_MENU
+    int		grey_old, grey_new;
+    char_u	*temp;
+#endif
+    win_T	*wp;
+    int		need_set_size;
+    int		fix_size;
+
+#ifdef FEAT_MENU
+    if (oldval != NULL && gui.in_use)
+    {
+	/*
+	 * Check if the menu's go from grey to non-grey or vise versa.
+	 */
+	grey_old = (vim_strchr(oldval, GO_GREY) != NULL);
+	grey_new = (vim_strchr(p_go, GO_GREY) != NULL);
+	if (grey_old != grey_new)
+	{
+	    temp = p_go;
+	    p_go = oldval;
+	    gui_update_menus(MENU_ALL_MODES);
+	    p_go = temp;
+	}
+    }
+    gui.menu_is_active = FALSE;
+#endif
+
+    for (i = 0; i < 3; i++)
+	gui.which_scrollbars[i] = FALSE;
+    for (p = p_go; *p; p++)
+	switch (*p)
+	{
+	    case GO_LEFT:
+		gui.which_scrollbars[SBAR_LEFT] = TRUE;
+		break;
+	    case GO_RIGHT:
+		gui.which_scrollbars[SBAR_RIGHT] = TRUE;
+		break;
+	    case GO_VLEFT:
+		if (win_hasvertsplit())
+		    gui.which_scrollbars[SBAR_LEFT] = TRUE;
+		break;
+	    case GO_VRIGHT:
+		if (win_hasvertsplit())
+		    gui.which_scrollbars[SBAR_RIGHT] = TRUE;
+		break;
+	    case GO_BOT:
+		gui.which_scrollbars[SBAR_BOTTOM] = TRUE;
+		break;
+#ifdef FEAT_MENU
+	    case GO_MENUS:
+		gui.menu_is_active = TRUE;
+		break;
+#endif
+	    case GO_GREY:
+		/* make menu's have grey items, ignored here */
+		break;
+#ifdef FEAT_TOOLBAR
+	    case GO_TOOLBAR:
+		using_toolbar = TRUE;
+		break;
+#endif
+#ifdef FEAT_FOOTER
+	    case GO_FOOTER:
+		using_footer = TRUE;
+		break;
+#endif
+	    case GO_TEAROFF:
+#if defined(FEAT_MENU)
+		using_tearoff = TRUE;
+#endif
+		break;
+	    default:
+		/* Ignore options that are not supported */
+		break;
+	}
+
+    if (gui.in_use)
+    {
+	need_set_size = 0;
+	fix_size = FALSE;
+
+#ifdef FEAT_GUI_TABLINE
+	/* Update the GUI tab line, it may appear or disappear.  This may
+	 * cause the non-GUI tab line to disappear or appear. */
+	using_tabline = gui_has_tabline();
+	if (!gui_mch_showing_tabline() != !using_tabline)
+	{
+	    /* We don't want a resize event change "Rows" here, save and
+	     * restore it.  Resizing is handled below. */
+	    i = Rows;
+	    gui_update_tabline();
+	    Rows = i;
+	    need_set_size |= RESIZE_VERT;
+	    if (using_tabline)
+		fix_size = TRUE;
+	    if (!gui_use_tabline())
+		redraw_tabline = TRUE;    /* may draw non-GUI tab line */
+	}
+#endif
+
+	for (i = 0; i < 3; i++)
+	{
+	    /* The scrollbar needs to be updated when it is shown/unshown and
+	     * when switching tab pages.  But the size only changes when it's
+	     * shown/unshown.  Thus we need two places to remember whether a
+	     * scrollbar is there or not. */
+	    if (gui.which_scrollbars[i] != prev_which_scrollbars[i]
+		    || gui.which_scrollbars[i]
+					!= curtab->tp_prev_which_scrollbars[i])
+	    {
+		if (i == SBAR_BOTTOM)
+		    gui_mch_enable_scrollbar(&gui.bottom_sbar,
+						     gui.which_scrollbars[i]);
+		else
+		{
+		    FOR_ALL_WINDOWS(wp)
+		    {
+			gui_do_scrollbar(wp, i, gui.which_scrollbars[i]);
+		    }
+		}
+		if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
+		{
+		    if (i == SBAR_BOTTOM)
+			need_set_size |= RESIZE_VERT;
+		    else
+			need_set_size |= RESIZE_HOR;
+		    if (gui.which_scrollbars[i])
+			fix_size = TRUE;
+		}
+	    }
+	    curtab->tp_prev_which_scrollbars[i] = gui.which_scrollbars[i];
+	    prev_which_scrollbars[i] = gui.which_scrollbars[i];
+	}
+
+#ifdef FEAT_MENU
+	if (gui.menu_is_active != prev_menu_is_active)
+	{
+	    /* We don't want a resize event change "Rows" here, save and
+	     * restore it.  Resizing is handled below. */
+	    i = Rows;
+	    gui_mch_enable_menu(gui.menu_is_active);
+	    Rows = i;
+	    prev_menu_is_active = gui.menu_is_active;
+	    need_set_size |= RESIZE_VERT;
+	    if (gui.menu_is_active)
+		fix_size = TRUE;
+	}
+#endif
+
+#ifdef FEAT_TOOLBAR
+	if (using_toolbar != prev_toolbar)
+	{
+	    gui_mch_show_toolbar(using_toolbar);
+	    prev_toolbar = using_toolbar;
+	    need_set_size |= RESIZE_VERT;
+	    if (using_toolbar)
+		fix_size = TRUE;
+	}
+#endif
+#ifdef FEAT_FOOTER
+	if (using_footer != prev_footer)
+	{
+	    gui_mch_enable_footer(using_footer);
+	    prev_footer = using_footer;
+	    need_set_size |= RESIZE_VERT;
+	    if (using_footer)
+		fix_size = TRUE;
+	}
+#endif
+#if defined(FEAT_MENU) && !(defined(WIN3264) && !defined(FEAT_TEAROFF))
+	if (using_tearoff != prev_tearoff)
+	{
+	    gui_mch_toggle_tearoffs(using_tearoff);
+	    prev_tearoff = using_tearoff;
+	}
+#endif
+	if (need_set_size != 0)
+	{
+#ifdef FEAT_GUI_GTK
+	    long    prev_Columns = Columns;
+	    long    prev_Rows = Rows;
+#endif
+	    /* Adjust the size of the window to make the text area keep the
+	     * same size and to avoid that part of our window is off-screen
+	     * and a scrollbar can't be used, for example. */
+	    gui_set_shellsize(FALSE, fix_size, need_set_size);
+
+#ifdef FEAT_GUI_GTK
+	    /* GTK has the annoying habit of sending us resize events when
+	     * changing the window size ourselves.  This mostly happens when
+	     * waiting for a character to arrive, quite unpredictably, and may
+	     * change Columns and Rows when we don't want it.  Wait for a
+	     * character here to avoid this effect.
+	     * If you remove this, please test this command for resizing
+	     * effects (with optional left scrollbar): ":vsp|q|vsp|q|vsp|q".
+	     * Don't do this while starting up though.
+	     * Don't change Rows when adding menu/toolbar/tabline.
+	     * Don't change Columns when adding vertical toolbar. */
+	    if (!gui.starting && need_set_size != (RESIZE_VERT | RESIZE_HOR))
+		(void)char_avail();
+	    if ((need_set_size & RESIZE_VERT) == 0)
+		Rows = prev_Rows;
+	    if ((need_set_size & RESIZE_HOR) == 0)
+		Columns = prev_Columns;
+#endif
+	}
+	/* When the console tabline appears or disappears the window positions
+	 * change. */
+	if (firstwin->w_winrow != tabline_height())
+	    shell_new_rows();	/* recompute window positions and heights */
+    }
+}
+
+#if defined(FEAT_GUI_TABLINE) || defined(PROTO)
+/*
+ * Return TRUE if the GUI is taking care of the tabline.
+ * It may still be hidden if 'showtabline' is zero.
+ */
+    int
+gui_use_tabline(void)
+{
+    return gui.in_use && vim_strchr(p_go, GO_TABLINE) != NULL;
+}
+
+/*
+ * Return TRUE if the GUI is showing the tabline.
+ * This uses 'showtabline'.
+ */
+    static int
+gui_has_tabline(void)
+{
+    if (!gui_use_tabline()
+	    || p_stal == 0
+	    || (p_stal == 1 && first_tabpage->tp_next == NULL))
+	return FALSE;
+    return TRUE;
+}
+
+/*
+ * Update the tabline.
+ * This may display/undisplay the tabline and update the labels.
+ */
+    void
+gui_update_tabline(void)
+{
+    int	    showit = gui_has_tabline();
+    int	    shown = gui_mch_showing_tabline();
+
+    if (!gui.starting && starting == 0)
+    {
+	/* Updating the tabline uses direct GUI commands, flush
+	 * outstanding instructions first. (esp. clear screen) */
+	out_flush();
+
+	if (!showit != !shown)
+	    gui_mch_show_tabline(showit);
+	if (showit != 0)
+	    gui_mch_update_tabline();
+
+	/* When the tabs change from hidden to shown or from shown to
+	 * hidden the size of the text area should remain the same. */
+	if (!showit != !shown)
+	    gui_set_shellsize(FALSE, showit, RESIZE_VERT);
+    }
+}
+
+/*
+ * Get the label or tooltip for tab page "tp" into NameBuff[].
+ */
+    void
+get_tabline_label(
+    tabpage_T	*tp,
+    int		tooltip)	/* TRUE: get tooltip */
+{
+    int		modified = FALSE;
+    char_u	buf[40];
+    int		wincount;
+    win_T	*wp;
+    char_u	**opt;
+
+    /* Use 'guitablabel' or 'guitabtooltip' if it's set. */
+    opt = (tooltip ? &p_gtt : &p_gtl);
+    if (**opt != NUL)
+    {
+	int	use_sandbox = FALSE;
+	int	save_called_emsg = called_emsg;
+	char_u	res[MAXPATHL];
+	tabpage_T *save_curtab;
+	char_u	*opt_name = (char_u *)(tooltip ? "guitabtooltip"
+							     : "guitablabel");
+
+	called_emsg = FALSE;
+
+	printer_page_num = tabpage_index(tp);
+# ifdef FEAT_EVAL
+	set_vim_var_nr(VV_LNUM, printer_page_num);
+	use_sandbox = was_set_insecurely(opt_name, 0);
+# endif
+	/* It's almost as going to the tabpage, but without autocommands. */
+	curtab->tp_firstwin = firstwin;
+	curtab->tp_lastwin = lastwin;
+	curtab->tp_curwin = curwin;
+	save_curtab = curtab;
+	curtab = tp;
+	topframe = curtab->tp_topframe;
+	firstwin = curtab->tp_firstwin;
+	lastwin = curtab->tp_lastwin;
+	curwin = curtab->tp_curwin;
+	curbuf = curwin->w_buffer;
+
+	/* Can't use NameBuff directly, build_stl_str_hl() uses it. */
+	build_stl_str_hl(curwin, res, MAXPATHL, *opt, use_sandbox,
+						 0, (int)Columns, NULL, NULL);
+	STRCPY(NameBuff, res);
+
+	/* Back to the original curtab. */
+	curtab = save_curtab;
+	topframe = curtab->tp_topframe;
+	firstwin = curtab->tp_firstwin;
+	lastwin = curtab->tp_lastwin;
+	curwin = curtab->tp_curwin;
+	curbuf = curwin->w_buffer;
+
+	if (called_emsg)
+	    set_string_option_direct(opt_name, -1,
+					   (char_u *)"", OPT_FREE, SID_ERROR);
+	called_emsg |= save_called_emsg;
+    }
+
+    /* If 'guitablabel'/'guitabtooltip' is not set or the result is empty then
+     * use a default label. */
+    if (**opt == NUL || *NameBuff == NUL)
+    {
+	/* Get the buffer name into NameBuff[] and shorten it. */
+	get_trans_bufname(tp == curtab ? curbuf : tp->tp_curwin->w_buffer);
+	if (!tooltip)
+	    shorten_dir(NameBuff);
+
+	wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
+	for (wincount = 0; wp != NULL; wp = wp->w_next, ++wincount)
+	    if (bufIsChanged(wp->w_buffer))
+		modified = TRUE;
+	if (modified || wincount > 1)
+	{
+	    if (wincount > 1)
+		vim_snprintf((char *)buf, sizeof(buf), "%d", wincount);
+	    else
+		buf[0] = NUL;
+	    if (modified)
+		STRCAT(buf, "+");
+	    STRCAT(buf, " ");
+	    STRMOVE(NameBuff + STRLEN(buf), NameBuff);
+	    mch_memmove(NameBuff, buf, STRLEN(buf));
+	}
+    }
+}
+
+/*
+ * Send the event for clicking to select tab page "nr".
+ * Returns TRUE if it was done, FALSE when skipped because we are already at
+ * that tab page or the cmdline window is open.
+ */
+    int
+send_tabline_event(int nr)
+{
+    char_u string[3];
+
+    if (nr == tabpage_index(curtab))
+	return FALSE;
+
+    /* Don't put events in the input queue now. */
+    if (hold_gui_events
+# ifdef FEAT_CMDWIN
+	    || cmdwin_type != 0
+# endif
+	    )
+    {
+	/* Set it back to the current tab page. */
+	gui_mch_set_curtab(tabpage_index(curtab));
+	return FALSE;
+    }
+
+    string[0] = CSI;
+    string[1] = KS_TABLINE;
+    string[2] = KE_FILLER;
+    add_to_input_buf(string, 3);
+    string[0] = nr;
+    add_to_input_buf_csi(string, 1);
+    return TRUE;
+}
+
+/*
+ * Send a tabline menu event
+ */
+    void
+send_tabline_menu_event(int tabidx, int event)
+{
+    char_u	    string[3];
+
+    /* Don't put events in the input queue now. */
+    if (hold_gui_events)
+	return;
+
+    string[0] = CSI;
+    string[1] = KS_TABMENU;
+    string[2] = KE_FILLER;
+    add_to_input_buf(string, 3);
+    string[0] = tabidx;
+    string[1] = (char_u)(long)event;
+    add_to_input_buf_csi(string, 2);
+}
+
+#endif
+
+/*
+ * Scrollbar stuff:
+ */
+
+/*
+ * Remove all scrollbars.  Used before switching to another tab page.
+ */
+    void
+gui_remove_scrollbars(void)
+{
+    int	    i;
+    win_T   *wp;
+
+    for (i = 0; i < 3; i++)
+    {
+	if (i == SBAR_BOTTOM)
+	    gui_mch_enable_scrollbar(&gui.bottom_sbar, FALSE);
+	else
+	{
+	    FOR_ALL_WINDOWS(wp)
+	    {
+		gui_do_scrollbar(wp, i, FALSE);
+	    }
+	}
+	curtab->tp_prev_which_scrollbars[i] = -1;
+    }
+}
+
+    void
+gui_create_scrollbar(scrollbar_T *sb, int type, win_T *wp)
+{
+    static int	sbar_ident = 0;
+
+    sb->ident = sbar_ident++;	/* No check for too big, but would it happen? */
+    sb->wp = wp;
+    sb->type = type;
+    sb->value = 0;
+#ifdef FEAT_GUI_ATHENA
+    sb->pixval = 0;
+#endif
+    sb->size = 1;
+    sb->max = 1;
+    sb->top = 0;
+    sb->height = 0;
+    sb->width = 0;
+    sb->status_height = 0;
+    gui_mch_create_scrollbar(sb, (wp == NULL) ? SBAR_HORIZ : SBAR_VERT);
+}
+
+/*
+ * Find the scrollbar with the given index.
+ */
+    scrollbar_T *
+gui_find_scrollbar(long ident)
+{
+    win_T	*wp;
+
+    if (gui.bottom_sbar.ident == ident)
+	return &gui.bottom_sbar;
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp->w_scrollbars[SBAR_LEFT].ident == ident)
+	    return &wp->w_scrollbars[SBAR_LEFT];
+	if (wp->w_scrollbars[SBAR_RIGHT].ident == ident)
+	    return &wp->w_scrollbars[SBAR_RIGHT];
+    }
+    return NULL;
+}
+
+/*
+ * For most systems: Put a code in the input buffer for a dragged scrollbar.
+ *
+ * For Win32, Macintosh and GTK+ 2:
+ * Scrollbars seem to grab focus and vim doesn't read the input queue until
+ * you stop dragging the scrollbar.  We get here each time the scrollbar is
+ * dragged another pixel, but as far as the rest of vim goes, it thinks
+ * we're just hanging in the call to DispatchMessage() in
+ * process_message().  The DispatchMessage() call that hangs was passed a
+ * mouse button click event in the scrollbar window. -- webb.
+ *
+ * Solution: Do the scrolling right here.  But only when allowed.
+ * Ignore the scrollbars while executing an external command or when there
+ * are still characters to be processed.
+ */
+    void
+gui_drag_scrollbar(scrollbar_T *sb, long value, int still_dragging)
+{
+    win_T	*wp;
+    int		sb_num;
+#ifdef USE_ON_FLY_SCROLL
+    colnr_T	old_leftcol = curwin->w_leftcol;
+    linenr_T	old_topline = curwin->w_topline;
+# ifdef FEAT_DIFF
+    int		old_topfill = curwin->w_topfill;
+# endif
+#else
+    char_u	bytes[sizeof(long_u)];
+    int		byte_count;
+#endif
+
+    if (sb == NULL)
+	return;
+
+    /* Don't put events in the input queue now. */
+    if (hold_gui_events)
+	return;
+
+#ifdef FEAT_CMDWIN
+    if (cmdwin_type != 0 && sb->wp != curwin)
+	return;
+#endif
+
+    if (still_dragging)
+    {
+	if (sb->wp == NULL)
+	    gui.dragged_sb = SBAR_BOTTOM;
+	else if (sb == &sb->wp->w_scrollbars[SBAR_LEFT])
+	    gui.dragged_sb = SBAR_LEFT;
+	else
+	    gui.dragged_sb = SBAR_RIGHT;
+	gui.dragged_wp = sb->wp;
+    }
+    else
+    {
+	gui.dragged_sb = SBAR_NONE;
+#ifdef FEAT_GUI_GTK
+	/* Keep the "dragged_wp" value until after the scrolling, for when the
+	 * mouse button is released.  GTK2 doesn't send the button-up event. */
+	gui.dragged_wp = NULL;
+#endif
+    }
+
+    /* Vertical sbar info is kept in the first sbar (the left one) */
+    if (sb->wp != NULL)
+	sb = &sb->wp->w_scrollbars[0];
+
+    /*
+     * Check validity of value
+     */
+    if (value < 0)
+	value = 0;
+#ifdef SCROLL_PAST_END
+    else if (value > sb->max)
+	value = sb->max;
+#else
+    if (value > sb->max - sb->size + 1)
+	value = sb->max - sb->size + 1;
+#endif
+
+    sb->value = value;
+
+#ifdef USE_ON_FLY_SCROLL
+    /* When not allowed to do the scrolling right now, return.
+     * This also checked input_available(), but that causes the first click in
+     * a scrollbar to be ignored when Vim doesn't have focus. */
+    if (dont_scroll)
+	return;
+#endif
+#ifdef FEAT_INS_EXPAND
+    /* Disallow scrolling the current window when the completion popup menu is
+     * visible. */
+    if ((sb->wp == NULL || sb->wp == curwin) && pum_visible())
+	return;
+#endif
+
+#ifdef FEAT_RIGHTLEFT
+    if (sb->wp == NULL && curwin->w_p_rl)
+    {
+	value = sb->max + 1 - sb->size - value;
+	if (value < 0)
+	    value = 0;
+    }
+#endif
+
+    if (sb->wp != NULL)		/* vertical scrollbar */
+    {
+	sb_num = 0;
+	for (wp = firstwin; wp != sb->wp && wp != NULL; wp = wp->w_next)
+	    sb_num++;
+	if (wp == NULL)
+	    return;
+
+#ifdef USE_ON_FLY_SCROLL
+	current_scrollbar = sb_num;
+	scrollbar_value = value;
+	if (State & NORMAL)
+	{
+	    gui_do_scroll();
+	    setcursor();
+	}
+	else if (State & INSERT)
+	{
+	    ins_scroll();
+	    setcursor();
+	}
+	else if (State & CMDLINE)
+	{
+	    if (msg_scrolled == 0)
+	    {
+		gui_do_scroll();
+		redrawcmdline();
+	    }
+	}
+# ifdef FEAT_FOLDING
+	/* Value may have been changed for closed fold. */
+	sb->value = sb->wp->w_topline - 1;
+# endif
+
+	/* When dragging one scrollbar and there is another one at the other
+	 * side move the thumb of that one too. */
+	if (gui.which_scrollbars[SBAR_RIGHT] && gui.which_scrollbars[SBAR_LEFT])
+	    gui_mch_set_scrollbar_thumb(
+		    &sb->wp->w_scrollbars[
+			    sb == &sb->wp->w_scrollbars[SBAR_RIGHT]
+						    ? SBAR_LEFT : SBAR_RIGHT],
+		    sb->value, sb->size, sb->max);
+
+#else
+	bytes[0] = CSI;
+	bytes[1] = KS_VER_SCROLLBAR;
+	bytes[2] = KE_FILLER;
+	bytes[3] = (char_u)sb_num;
+	byte_count = 4;
+#endif
+    }
+    else
+    {
+#ifdef USE_ON_FLY_SCROLL
+	scrollbar_value = value;
+
+	if (State & NORMAL)
+	    gui_do_horiz_scroll(scrollbar_value, FALSE);
+	else if (State & INSERT)
+	    ins_horscroll();
+	else if (State & CMDLINE)
+	{
+	    if (msg_scrolled == 0)
+	    {
+		gui_do_horiz_scroll(scrollbar_value, FALSE);
+		redrawcmdline();
+	    }
+	}
+	if (old_leftcol != curwin->w_leftcol)
+	{
+	    updateWindow(curwin);   /* update window, status and cmdline */
+	    setcursor();
+	}
+#else
+	bytes[0] = CSI;
+	bytes[1] = KS_HOR_SCROLLBAR;
+	bytes[2] = KE_FILLER;
+	byte_count = 3;
+#endif
+    }
+
+#ifdef USE_ON_FLY_SCROLL
+    /*
+     * synchronize other windows, as necessary according to 'scrollbind'
+     */
+    if (curwin->w_p_scb
+	    && ((sb->wp == NULL && curwin->w_leftcol != old_leftcol)
+		|| (sb->wp == curwin && (curwin->w_topline != old_topline
+# ifdef FEAT_DIFF
+					   || curwin->w_topfill != old_topfill
+# endif
+			))))
+    {
+	do_check_scrollbind(TRUE);
+	/* need to update the window right here */
+	FOR_ALL_WINDOWS(wp)
+	    if (wp->w_redr_type > 0)
+		updateWindow(wp);
+	setcursor();
+    }
+    out_flush_cursor(FALSE, TRUE);
+#else
+    add_to_input_buf(bytes, byte_count);
+    add_long_to_buf((long_u)value, bytes);
+    add_to_input_buf_csi(bytes, sizeof(long_u));
+#endif
+}
+
+/*
+ * Scrollbar stuff:
+ */
+
+/*
+ * Called when something in the window layout has changed.
+ */
+    void
+gui_may_update_scrollbars(void)
+{
+    if (gui.in_use && starting == 0)
+    {
+	out_flush();
+	gui_init_which_components(NULL);
+	gui_update_scrollbars(TRUE);
+    }
+    need_mouse_correct = TRUE;
+}
+
+    void
+gui_update_scrollbars(
+    int		force)	    /* Force all scrollbars to get updated */
+{
+    win_T	*wp;
+    scrollbar_T	*sb;
+    long	val, size, max;		/* need 32 bits here */
+    int		which_sb;
+    int		h, y;
+    static win_T *prev_curwin = NULL;
+
+    /* Update the horizontal scrollbar */
+    gui_update_horiz_scrollbar(force);
+
+#ifndef WIN3264
+    /* Return straight away if there is neither a left nor right scrollbar.
+     * On MS-Windows this is required anyway for scrollwheel messages. */
+    if (!gui.which_scrollbars[SBAR_LEFT] && !gui.which_scrollbars[SBAR_RIGHT])
+	return;
+#endif
+
+    /*
+     * Don't want to update a scrollbar while we're dragging it.  But if we
+     * have both a left and right scrollbar, and we drag one of them, we still
+     * need to update the other one.
+     */
+    if (!force && (gui.dragged_sb == SBAR_LEFT || gui.dragged_sb == SBAR_RIGHT)
+	    && gui.which_scrollbars[SBAR_LEFT]
+	    && gui.which_scrollbars[SBAR_RIGHT])
+    {
+	/*
+	 * If we have two scrollbars and one of them is being dragged, just
+	 * copy the scrollbar position from the dragged one to the other one.
+	 */
+	which_sb = SBAR_LEFT + SBAR_RIGHT - gui.dragged_sb;
+	if (gui.dragged_wp != NULL)
+	    gui_mch_set_scrollbar_thumb(
+		    &gui.dragged_wp->w_scrollbars[which_sb],
+		    gui.dragged_wp->w_scrollbars[0].value,
+		    gui.dragged_wp->w_scrollbars[0].size,
+		    gui.dragged_wp->w_scrollbars[0].max);
+    }
+
+    /* avoid that moving components around generates events */
+    ++hold_gui_events;
+
+    for (wp = firstwin; wp != NULL; wp = W_NEXT(wp))
+    {
+	if (wp->w_buffer == NULL)	/* just in case */
+	    continue;
+	/* Skip a scrollbar that is being dragged. */
+	if (!force && (gui.dragged_sb == SBAR_LEFT
+					     || gui.dragged_sb == SBAR_RIGHT)
+		&& gui.dragged_wp == wp)
+	    continue;
+
+#ifdef SCROLL_PAST_END
+	max = wp->w_buffer->b_ml.ml_line_count - 1;
+#else
+	max = wp->w_buffer->b_ml.ml_line_count + wp->w_height - 2;
+#endif
+	if (max < 0)			/* empty buffer */
+	    max = 0;
+	val = wp->w_topline - 1;
+	size = wp->w_height;
+#ifdef SCROLL_PAST_END
+	if (val > max)			/* just in case */
+	    val = max;
+#else
+	if (size > max + 1)		/* just in case */
+	    size = max + 1;
+	if (val > max - size + 1)
+	    val = max - size + 1;
+#endif
+	if (val < 0)			/* minimal value is 0 */
+	    val = 0;
+
+	/*
+	 * Scrollbar at index 0 (the left one) contains all the information.
+	 * It would be the same info for left and right so we just store it for
+	 * one of them.
+	 */
+	sb = &wp->w_scrollbars[0];
+
+	/*
+	 * Note: no check for valid w_botline.	If it's not valid the
+	 * scrollbars will be updated later anyway.
+	 */
+	if (size < 1 || wp->w_botline - 2 > max)
+	{
+	    /*
+	     * This can happen during changing files.  Just don't update the
+	     * scrollbar for now.
+	     */
+	    sb->height = 0;	    /* Force update next time */
+	    if (gui.which_scrollbars[SBAR_LEFT])
+		gui_do_scrollbar(wp, SBAR_LEFT, FALSE);
+	    if (gui.which_scrollbars[SBAR_RIGHT])
+		gui_do_scrollbar(wp, SBAR_RIGHT, FALSE);
+	    continue;
+	}
+	if (force || sb->height != wp->w_height
+	    || sb->top != wp->w_winrow
+	    || sb->status_height != wp->w_status_height
+	    || sb->width != wp->w_width
+	    || prev_curwin != curwin)
+	{
+	    /* Height, width or position of scrollbar has changed.  For
+	     * vertical split: curwin changed. */
+	    sb->height = wp->w_height;
+	    sb->top = wp->w_winrow;
+	    sb->status_height = wp->w_status_height;
+	    sb->width = wp->w_width;
+
+	    /* Calculate height and position in pixels */
+	    h = (sb->height + sb->status_height) * gui.char_height;
+	    y = sb->top * gui.char_height + gui.border_offset;
+#if defined(FEAT_MENU) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF) && !defined(FEAT_GUI_PHOTON)
+	    if (gui.menu_is_active)
+		y += gui.menu_height;
+#endif
+
+#if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_ATHENA))
+	    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
+# ifdef FEAT_GUI_ATHENA
+		y += gui.toolbar_height;
+# else
+#  ifdef FEAT_GUI_MSWIN
+		y += TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT;
+#  endif
+# endif
+#endif
+
+#if defined(FEAT_GUI_TABLINE) && defined(FEAT_GUI_MSWIN)
+	    if (gui_has_tabline())
+		y += gui.tabline_height;
+#endif
+
+	    if (wp->w_winrow == 0)
+	    {
+		/* Height of top scrollbar includes width of top border */
+		h += gui.border_offset;
+		y -= gui.border_offset;
+	    }
+	    if (gui.which_scrollbars[SBAR_LEFT])
+	    {
+		gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_LEFT],
+					  gui.left_sbar_x, y,
+					  gui.scrollbar_width, h);
+		gui_do_scrollbar(wp, SBAR_LEFT, TRUE);
+	    }
+	    if (gui.which_scrollbars[SBAR_RIGHT])
+	    {
+		gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_RIGHT],
+					  gui.right_sbar_x, y,
+					  gui.scrollbar_width, h);
+		gui_do_scrollbar(wp, SBAR_RIGHT, TRUE);
+	    }
+	}
+
+	/* Reduce the number of calls to gui_mch_set_scrollbar_thumb() by
+	 * checking if the thumb moved at least a pixel.  Only do this for
+	 * Athena, most other GUIs require the update anyway to make the
+	 * arrows work. */
+#ifdef FEAT_GUI_ATHENA
+	if (max == 0)
+	    y = 0;
+	else
+	    y = (val * (sb->height + 2) * gui.char_height + max / 2) / max;
+	if (force || sb->pixval != y || sb->size != size || sb->max != max)
+#else
+	if (force || sb->value != val || sb->size != size || sb->max != max)
+#endif
+	{
+	    /* Thumb of scrollbar has moved */
+	    sb->value = val;
+#ifdef FEAT_GUI_ATHENA
+	    sb->pixval = y;
+#endif
+	    sb->size = size;
+	    sb->max = max;
+	    if (gui.which_scrollbars[SBAR_LEFT]
+		    && (gui.dragged_sb != SBAR_LEFT || gui.dragged_wp != wp))
+		gui_mch_set_scrollbar_thumb(&wp->w_scrollbars[SBAR_LEFT],
+					    val, size, max);
+	    if (gui.which_scrollbars[SBAR_RIGHT]
+		    && (gui.dragged_sb != SBAR_RIGHT || gui.dragged_wp != wp))
+		gui_mch_set_scrollbar_thumb(&wp->w_scrollbars[SBAR_RIGHT],
+					    val, size, max);
+	}
+    }
+    prev_curwin = curwin;
+    --hold_gui_events;
+}
+
+/*
+ * Enable or disable a scrollbar.
+ * Check for scrollbars for vertically split windows which are not enabled
+ * sometimes.
+ */
+    static void
+gui_do_scrollbar(
+    win_T	*wp,
+    int		which,	    /* SBAR_LEFT or SBAR_RIGHT */
+    int		enable)	    /* TRUE to enable scrollbar */
+{
+    int		midcol = curwin->w_wincol + curwin->w_width / 2;
+    int		has_midcol = (wp->w_wincol <= midcol
+				     && wp->w_wincol + wp->w_width >= midcol);
+
+    /* Only enable scrollbars that contain the middle column of the current
+     * window. */
+    if (gui.which_scrollbars[SBAR_RIGHT] != gui.which_scrollbars[SBAR_LEFT])
+    {
+	/* Scrollbars only on one side.  Don't enable scrollbars that don't
+	 * contain the middle column of the current window. */
+	if (!has_midcol)
+	    enable = FALSE;
+    }
+    else
+    {
+	/* Scrollbars on both sides.  Don't enable scrollbars that neither
+	 * contain the middle column of the current window nor are on the far
+	 * side. */
+	if (midcol > Columns / 2)
+	{
+	    if (which == SBAR_LEFT ? wp->w_wincol != 0 : !has_midcol)
+		enable = FALSE;
+	}
+	else
+	{
+	    if (which == SBAR_RIGHT ? wp->w_wincol + wp->w_width != Columns
+								: !has_midcol)
+		enable = FALSE;
+	}
+    }
+    gui_mch_enable_scrollbar(&wp->w_scrollbars[which], enable);
+}
+
+/*
+ * Scroll a window according to the values set in the globals current_scrollbar
+ * and scrollbar_value.  Return TRUE if the cursor in the current window moved
+ * or FALSE otherwise.
+ */
+    int
+gui_do_scroll(void)
+{
+    win_T	*wp, *save_wp;
+    int		i;
+    long	nlines;
+    pos_T	old_cursor;
+    linenr_T	old_topline;
+#ifdef FEAT_DIFF
+    int		old_topfill;
+#endif
+
+    for (wp = firstwin, i = 0; i < current_scrollbar; wp = W_NEXT(wp), i++)
+	if (wp == NULL)
+	    break;
+    if (wp == NULL)
+	/* Couldn't find window */
+	return FALSE;
+
+    /*
+     * Compute number of lines to scroll.  If zero, nothing to do.
+     */
+    nlines = (long)scrollbar_value + 1 - (long)wp->w_topline;
+    if (nlines == 0)
+	return FALSE;
+
+    save_wp = curwin;
+    old_topline = wp->w_topline;
+#ifdef FEAT_DIFF
+    old_topfill = wp->w_topfill;
+#endif
+    old_cursor = wp->w_cursor;
+    curwin = wp;
+    curbuf = wp->w_buffer;
+    if (nlines < 0)
+	scrolldown(-nlines, gui.dragged_wp == NULL);
+    else
+	scrollup(nlines, gui.dragged_wp == NULL);
+    /* Reset dragged_wp after using it.  "dragged_sb" will have been reset for
+     * the mouse-up event already, but we still want it to behave like when
+     * dragging.  But not the next click in an arrow. */
+    if (gui.dragged_sb == SBAR_NONE)
+	gui.dragged_wp = NULL;
+
+    if (old_topline != wp->w_topline
+#ifdef FEAT_DIFF
+	    || old_topfill != wp->w_topfill
+#endif
+	    )
+    {
+	if (p_so != 0)
+	{
+	    cursor_correct();		/* fix window for 'so' */
+	    update_topline();		/* avoid up/down jump */
+	}
+	if (old_cursor.lnum != wp->w_cursor.lnum)
+	    coladvance(wp->w_curswant);
+	wp->w_scbind_pos = wp->w_topline;
+    }
+
+    /* Make sure wp->w_leftcol and wp->w_skipcol are correct. */
+    validate_cursor();
+
+    curwin = save_wp;
+    curbuf = save_wp->w_buffer;
+
+    /*
+     * Don't call updateWindow() when nothing has changed (it will overwrite
+     * the status line!).
+     */
+    if (old_topline != wp->w_topline
+	    || wp->w_redr_type != 0
+#ifdef FEAT_DIFF
+	    || old_topfill != wp->w_topfill
+#endif
+	    )
+    {
+	int type = VALID;
+
+#ifdef FEAT_INS_EXPAND
+	if (pum_visible())
+	{
+	    type = NOT_VALID;
+	    wp->w_lines_valid = 0;
+	}
+#endif
+	/* Don't set must_redraw here, it may cause the popup menu to
+	 * disappear when losing focus after a scrollbar drag. */
+	if (wp->w_redr_type < type)
+	    wp->w_redr_type = type;
+	mch_disable_flush();
+	updateWindow(wp);   /* update window, status line, and cmdline */
+	mch_enable_flush();
+    }
+
+#ifdef FEAT_INS_EXPAND
+    /* May need to redraw the popup menu. */
+    if (pum_visible())
+	pum_redraw();
+#endif
+
+    return (wp == curwin && !EQUAL_POS(curwin->w_cursor, old_cursor));
+}
+
+
+/*
+ * Horizontal scrollbar stuff:
+ */
+
+/*
+ * Return length of line "lnum" for horizontal scrolling.
+ */
+    static colnr_T
+scroll_line_len(linenr_T lnum)
+{
+    char_u	*p;
+    colnr_T	col;
+    int		w;
+
+    p = ml_get(lnum);
+    col = 0;
+    if (*p != NUL)
+	for (;;)
+	{
+	    w = chartabsize(p, col);
+	    MB_PTR_ADV(p);
+	    if (*p == NUL)		/* don't count the last character */
+		break;
+	    col += w;
+	}
+    return col;
+}
+
+/* Remember which line is currently the longest, so that we don't have to
+ * search for it when scrolling horizontally. */
+static linenr_T longest_lnum = 0;
+
+/*
+ * Find longest visible line number.  If this is not possible (or not desired,
+ * by setting 'h' in "guioptions") then the current line number is returned.
+ */
+    static linenr_T
+gui_find_longest_lnum(void)
+{
+    linenr_T ret = 0;
+
+    /* Calculate maximum for horizontal scrollbar.  Check for reasonable
+     * line numbers, topline and botline can be invalid when displaying is
+     * postponed. */
+    if (vim_strchr(p_go, GO_HORSCROLL) == NULL
+	    && curwin->w_topline <= curwin->w_cursor.lnum
+	    && curwin->w_botline > curwin->w_cursor.lnum
+	    && curwin->w_botline <= curbuf->b_ml.ml_line_count + 1)
+    {
+	linenr_T    lnum;
+	colnr_T	    n;
+	long	    max = 0;
+
+	/* Use maximum of all visible lines.  Remember the lnum of the
+	 * longest line, closest to the cursor line.  Used when scrolling
+	 * below. */
+	for (lnum = curwin->w_topline; lnum < curwin->w_botline; ++lnum)
+	{
+	    n = scroll_line_len(lnum);
+	    if (n > (colnr_T)max)
+	    {
+		max = n;
+		ret = lnum;
+	    }
+	    else if (n == (colnr_T)max
+		    && abs((int)(lnum - curwin->w_cursor.lnum))
+		       < abs((int)(ret - curwin->w_cursor.lnum)))
+		ret = lnum;
+	}
+    }
+    else
+	/* Use cursor line only. */
+	ret = curwin->w_cursor.lnum;
+
+    return ret;
+}
+
+    static void
+gui_update_horiz_scrollbar(int force)
+{
+    long	value, size, max;	/* need 32 bit ints here */
+
+    if (!gui.which_scrollbars[SBAR_BOTTOM])
+	return;
+
+    if (!force && gui.dragged_sb == SBAR_BOTTOM)
+	return;
+
+    if (!force && curwin->w_p_wrap && gui.prev_wrap)
+	return;
+
+    /*
+     * It is possible for the cursor to be invalid if we're in the middle of
+     * something (like changing files).  If so, don't do anything for now.
+     */
+    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
+    {
+	gui.bottom_sbar.value = -1;
+	return;
+    }
+
+    size = curwin->w_width;
+    if (curwin->w_p_wrap)
+    {
+	value = 0;
+#ifdef SCROLL_PAST_END
+	max = 0;
+#else
+	max = curwin->w_width - 1;
+#endif
+    }
+    else
+    {
+	value = curwin->w_leftcol;
+
+	longest_lnum = gui_find_longest_lnum();
+	max = scroll_line_len(longest_lnum);
+
+#ifdef FEAT_VIRTUALEDIT
+	if (virtual_active())
+	{
+	    /* May move the cursor even further to the right. */
+	    if (curwin->w_virtcol >= (colnr_T)max)
+		max = curwin->w_virtcol;
+	}
+#endif
+
+#ifndef SCROLL_PAST_END
+	max += curwin->w_width - 1;
+#endif
+	/* The line number isn't scrolled, thus there is less space when
+	 * 'number' or 'relativenumber' is set (also for 'foldcolumn'). */
+	size -= curwin_col_off();
+#ifndef SCROLL_PAST_END
+	max -= curwin_col_off();
+#endif
+    }
+
+#ifndef SCROLL_PAST_END
+    if (value > max - size + 1)
+	value = max - size + 1;	    /* limit the value to allowable range */
+#endif
+
+#ifdef FEAT_RIGHTLEFT
+    if (curwin->w_p_rl)
+    {
+	value = max + 1 - size - value;
+	if (value < 0)
+	{
+	    size += value;
+	    value = 0;
+	}
+    }
+#endif
+    if (!force && value == gui.bottom_sbar.value && size == gui.bottom_sbar.size
+						&& max == gui.bottom_sbar.max)
+	return;
+
+    gui.bottom_sbar.value = value;
+    gui.bottom_sbar.size = size;
+    gui.bottom_sbar.max = max;
+    gui.prev_wrap = curwin->w_p_wrap;
+
+    gui_mch_set_scrollbar_thumb(&gui.bottom_sbar, value, size, max);
+}
+
+/*
+ * Do a horizontal scroll.  Return TRUE if the cursor moved, FALSE otherwise.
+ */
+    int
+gui_do_horiz_scroll(long_u leftcol, int compute_longest_lnum)
+{
+    /* no wrapping, no scrolling */
+    if (curwin->w_p_wrap)
+	return FALSE;
+
+    if (curwin->w_leftcol == (colnr_T)leftcol)
+	return FALSE;
+
+    curwin->w_leftcol = (colnr_T)leftcol;
+
+    /* When the line of the cursor is too short, move the cursor to the
+     * longest visible line. */
+    if (vim_strchr(p_go, GO_HORSCROLL) == NULL
+	    && !virtual_active()
+	    && (colnr_T)leftcol > scroll_line_len(curwin->w_cursor.lnum))
+    {
+	if (compute_longest_lnum)
+	{
+	    curwin->w_cursor.lnum = gui_find_longest_lnum();
+	    curwin->w_cursor.col = 0;
+	}
+	/* Do a sanity check on "longest_lnum", just in case. */
+	else if (longest_lnum >= curwin->w_topline
+		&& longest_lnum < curwin->w_botline)
+	{
+	    curwin->w_cursor.lnum = longest_lnum;
+	    curwin->w_cursor.col = 0;
+	}
+    }
+
+    return leftcol_changed();
+}
+
+/*
+ * Check that none of the colors are the same as the background color
+ */
+    void
+gui_check_colors(void)
+{
+    if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
+    {
+	gui_set_bg_color((char_u *)"White");
+	if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
+	    gui_set_fg_color((char_u *)"Black");
+    }
+}
+
+    static void
+gui_set_fg_color(char_u *name)
+{
+    gui.norm_pixel = gui_get_color(name);
+    hl_set_fg_color_name(vim_strsave(name));
+}
+
+    static void
+gui_set_bg_color(char_u *name)
+{
+    gui.back_pixel = gui_get_color(name);
+    hl_set_bg_color_name(vim_strsave(name));
+}
+
+/*
+ * Allocate a color by name.
+ * Returns INVALCOLOR and gives an error message when failed.
+ */
+    guicolor_T
+gui_get_color(char_u *name)
+{
+    guicolor_T	t;
+
+    if (*name == NUL)
+	return INVALCOLOR;
+    t = gui_mch_get_color(name);
+
+    if (t == INVALCOLOR
+#if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
+	    && gui.in_use
+#endif
+	    )
+	EMSG2(_("E254: Cannot allocate color %s"), name);
+    return t;
+}
+
+/*
+ * Return the grey value of a color (range 0-255).
+ */
+    int
+gui_get_lightness(guicolor_T pixel)
+{
+    long_u	rgb = (long_u)gui_mch_get_rgb(pixel);
+
+    return  (int)(  (((rgb >> 16) & 0xff) * 299)
+		   + (((rgb >> 8) & 0xff) * 587)
+		   +  ((rgb	  & 0xff) * 114)) / 1000;
+}
+
+#if defined(FEAT_GUI_X11) || defined(PROTO)
+    void
+gui_new_scrollbar_colors(void)
+{
+    win_T	*wp;
+
+    /* Nothing to do if GUI hasn't started yet. */
+    if (!gui.in_use)
+	return;
+
+    FOR_ALL_WINDOWS(wp)
+    {
+	gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_LEFT]));
+	gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_RIGHT]));
+    }
+    gui_mch_set_scrollbar_colors(&gui.bottom_sbar);
+}
+#endif
+
+/*
+ * Call this when focus has changed.
+ */
+    void
+gui_focus_change(int in_focus)
+{
+/*
+ * Skip this code to avoid drawing the cursor when debugging and switching
+ * between the debugger window and gvim.
+ */
+#if 1
+    gui.in_focus = in_focus;
+    out_flush_cursor(TRUE, FALSE);
+
+# ifdef FEAT_XIM
+    xim_set_focus(in_focus);
+# endif
+
+    /* Put events in the input queue only when allowed.
+     * ui_focus_change() isn't called directly, because it invokes
+     * autocommands and that must not happen asynchronously. */
+    if (!hold_gui_events)
+    {
+	char_u  bytes[3];
+
+	bytes[0] = CSI;
+	bytes[1] = KS_EXTRA;
+	bytes[2] = in_focus ? (int)KE_FOCUSGAINED : (int)KE_FOCUSLOST;
+	add_to_input_buf(bytes, 3);
+    }
+#endif
+}
+
+/*
+ * Called when the mouse moved (but not when dragging).
+ */
+    void
+gui_mouse_moved(int x, int y)
+{
+    win_T	*wp;
+    char_u	st[8];
+
+    /* Ignore this while still starting up. */
+    if (!gui.in_use || gui.starting)
+	return;
+
+#ifdef FEAT_MOUSESHAPE
+    /* Get window pointer, and update mouse shape as well. */
+    wp = xy2win(x, y);
+#endif
+
+    /* Only handle this when 'mousefocus' set and ... */
+    if (p_mousef
+	    && !hold_gui_events		/* not holding events */
+	    && (State & (NORMAL|INSERT))/* Normal/Visual/Insert mode */
+	    && State != HITRETURN	/* but not hit-return prompt */
+	    && msg_scrolled == 0	/* no scrolled message */
+	    && !need_mouse_correct	/* not moving the pointer */
+	    && gui.in_focus)		/* gvim in focus */
+    {
+	/* Don't move the mouse when it's left or right of the Vim window */
+	if (x < 0 || x > Columns * gui.char_width)
+	    return;
+#ifndef FEAT_MOUSESHAPE
+	wp = xy2win(x, y);
+#endif
+	if (wp == curwin || wp == NULL)
+	    return;	/* still in the same old window, or none at all */
+
+	/* Ignore position in the tab pages line. */
+	if (Y_2_ROW(y) < tabline_height())
+	    return;
+
+	/*
+	 * format a mouse click on status line input
+	 * ala gui_send_mouse_event(0, x, y, 0, 0);
+	 * Trick: Use a column number -1, so that get_pseudo_mouse_code() will
+	 * generate a K_LEFTMOUSE_NM key code.
+	 */
+	if (finish_op)
+	{
+	    /* abort the current operator first */
+	    st[0] = ESC;
+	    add_to_input_buf(st, 1);
+	}
+	st[0] = CSI;
+	st[1] = KS_MOUSE;
+	st[2] = KE_FILLER;
+	st[3] = (char_u)MOUSE_LEFT;
+	fill_mouse_coord(st + 4,
+		wp->w_wincol == 0 ? -1 : wp->w_wincol + MOUSE_COLOFF,
+		wp->w_height + W_WINROW(wp));
+
+	add_to_input_buf(st, 8);
+	st[3] = (char_u)MOUSE_RELEASE;
+	add_to_input_buf(st, 8);
+#ifdef FEAT_GUI_GTK
+	/* Need to wake up the main loop */
+	if (gtk_main_level() > 0)
+	    gtk_main_quit();
+#endif
+    }
+}
+
+/*
+ * Called when mouse should be moved to window with focus.
+ */
+    void
+gui_mouse_correct(void)
+{
+    int		x, y;
+    win_T	*wp = NULL;
+
+    need_mouse_correct = FALSE;
+
+    if (!(gui.in_use && p_mousef))
+	return;
+
+    gui_mch_getmouse(&x, &y);
+    /* Don't move the mouse when it's left or right of the Vim window */
+    if (x < 0 || x > Columns * gui.char_width)
+	return;
+    if (y >= 0 && Y_2_ROW(y) >= tabline_height())
+	wp = xy2win(x, y);
+    if (wp != curwin && wp != NULL)	/* If in other than current window */
+    {
+	validate_cline_row();
+	gui_mch_setmouse((int)W_ENDCOL(curwin) * gui.char_width - 3,
+		(W_WINROW(curwin) + curwin->w_wrow) * gui.char_height
+						     + (gui.char_height) / 2);
+    }
+}
+
+/*
+ * Find window where the mouse pointer "x" / "y" coordinate is in.
+ */
+    static win_T *
+xy2win(int x UNUSED, int y UNUSED)
+{
+    int		row;
+    int		col;
+    win_T	*wp;
+
+    row = Y_2_ROW(y);
+    col = X_2_COL(x);
+    if (row < 0 || col < 0)		/* before first window */
+	return NULL;
+    wp = mouse_find_win(&row, &col);
+    if (wp == NULL)
+	return NULL;
+#ifdef FEAT_MOUSESHAPE
+    if (State == HITRETURN || State == ASKMORE)
+    {
+	if (Y_2_ROW(y) >= msg_row)
+	    update_mouseshape(SHAPE_IDX_MOREL);
+	else
+	    update_mouseshape(SHAPE_IDX_MORE);
+    }
+    else if (row > wp->w_height)	/* below status line */
+	update_mouseshape(SHAPE_IDX_CLINE);
+    else if (!(State & CMDLINE) && wp->w_vsep_width > 0 && col == wp->w_width
+	    && (row != wp->w_height || !stl_connected(wp)) && msg_scrolled == 0)
+	update_mouseshape(SHAPE_IDX_VSEP);
+    else if (!(State & CMDLINE) && wp->w_status_height > 0
+				  && row == wp->w_height && msg_scrolled == 0)
+	update_mouseshape(SHAPE_IDX_STATUS);
+    else
+	update_mouseshape(-2);
+#endif
+    return wp;
+}
+
+/*
+ * ":gui" and ":gvim": Change from the terminal version to the GUI version.
+ * File names may be given to redefine the args list.
+ */
+    void
+ex_gui(exarg_T *eap)
+{
+    char_u	*arg = eap->arg;
+
+    /*
+     * Check for "-f" argument: foreground, don't fork.
+     * Also don't fork when started with "gvim -f".
+     * Do fork when using "gui -b".
+     */
+    if (arg[0] == '-'
+	    && (arg[1] == 'f' || arg[1] == 'b')
+	    && (arg[2] == NUL || VIM_ISWHITE(arg[2])))
+    {
+	gui.dofork = (arg[1] == 'b');
+	eap->arg = skipwhite(eap->arg + 2);
+    }
+    if (!gui.in_use)
+    {
+	/* Clear the command.  Needed for when forking+exiting, to avoid part
+	 * of the argument ending up after the shell prompt. */
+	msg_clr_eos_force();
+	gui_start();
+#ifdef FEAT_JOB_CHANNEL
+	channel_gui_register_all();
+#endif
+    }
+    if (!ends_excmd(*eap->arg))
+	ex_next(eap);
+}
+
+#if ((defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32) \
+	|| defined(FEAT_GUI_PHOTON)) && defined(FEAT_TOOLBAR)) || defined(PROTO)
+/*
+ * This is shared between Athena, Motif and GTK.
+ */
+static void gfp_setname(char_u *fname, void *cookie);
+
+/*
+ * Callback function for do_in_runtimepath().
+ */
+    static void
+gfp_setname(char_u *fname, void *cookie)
+{
+    char_u	*gfp_buffer = cookie;
+
+    if (STRLEN(fname) >= MAXPATHL)
+	*gfp_buffer = NUL;
+    else
+	STRCPY(gfp_buffer, fname);
+}
+
+/*
+ * Find the path of bitmap "name" with extension "ext" in 'runtimepath'.
+ * Return FAIL for failure and OK if buffer[MAXPATHL] contains the result.
+ */
+    int
+gui_find_bitmap(char_u *name, char_u *buffer, char *ext)
+{
+    if (STRLEN(name) > MAXPATHL - 14)
+	return FAIL;
+    vim_snprintf((char *)buffer, MAXPATHL, "bitmaps/%s.%s", name, ext);
+    if (do_in_runtimepath(buffer, 0, gfp_setname, buffer) == FAIL
+							    || *buffer == NUL)
+	return FAIL;
+    return OK;
+}
+
+# if !defined(FEAT_GUI_GTK) || defined(PROTO)
+/*
+ * Given the name of the "icon=" argument, try finding the bitmap file for the
+ * icon.  If it is an absolute path name, use it as it is.  Otherwise append
+ * "ext" and search for it in 'runtimepath'.
+ * The result is put in "buffer[MAXPATHL]".  If something fails "buffer"
+ * contains "name".
+ */
+    void
+gui_find_iconfile(char_u *name, char_u *buffer, char *ext)
+{
+    char_u	buf[MAXPATHL + 1];
+
+    expand_env(name, buffer, MAXPATHL);
+    if (!mch_isFullName(buffer) && gui_find_bitmap(buffer, buf, ext) == OK)
+	STRCPY(buffer, buf);
+}
+# endif
+#endif
+
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(PROTO)
+    void
+display_errors(void)
+{
+    char_u	*p;
+
+    if (isatty(2))
+	fflush(stderr);
+    else if (error_ga.ga_data != NULL)
+    {
+	/* avoid putting up a message box with blanks only */
+	for (p = (char_u *)error_ga.ga_data; *p != NUL; ++p)
+	    if (!isspace(*p))
+	    {
+		/* Truncate a very long message, it will go off-screen. */
+		if (STRLEN(p) > 2000)
+		    STRCPY(p + 2000 - 14, "...(truncated)");
+		(void)do_dialog(VIM_ERROR, (char_u *)_("Error"),
+				       p, (char_u *)_("&Ok"), 1, NULL, FALSE);
+		break;
+	    }
+	ga_clear(&error_ga);
+    }
+}
+#endif
+
+#if defined(NO_CONSOLE_INPUT) || defined(PROTO)
+/*
+ * Return TRUE if still starting up and there is no place to enter text.
+ * For GTK and X11 we check if stderr is not a tty, which means we were
+ * (probably) started from the desktop.  Also check stdin, "vim >& file" does
+ * allow typing on stdin.
+ */
+    int
+no_console_input(void)
+{
+    return ((!gui.in_use || gui.starting)
+# ifndef NO_CONSOLE
+	    && !isatty(0) && !isatty(2)
+# endif
+	    );
+}
+#endif
+
+#if defined(FIND_REPLACE_DIALOG) || defined(FEAT_SUN_WORKSHOP) \
+	|| defined(NEED_GUI_UPDATE_SCREEN) \
+	|| defined(PROTO)
+/*
+ * Update the current window and the screen.
+ */
+    void
+gui_update_screen(void)
+{
+# ifdef FEAT_CONCEAL
+    linenr_T	conceal_old_cursor_line = 0;
+    linenr_T	conceal_new_cursor_line = 0;
+    int		conceal_update_lines = FALSE;
+# endif
+
+    update_topline();
+    validate_cursor();
+
+    /* Trigger CursorMoved if the cursor moved. */
+    if (!finish_op && (has_cursormoved()
+# ifdef FEAT_CONCEAL
+		|| curwin->w_p_cole > 0
+# endif
+		) && !EQUAL_POS(last_cursormoved, curwin->w_cursor))
+    {
+	if (has_cursormoved())
+	    apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, FALSE, curbuf);
+# ifdef FEAT_CONCEAL
+	if (curwin->w_p_cole > 0)
+	{
+	    conceal_old_cursor_line = last_cursormoved.lnum;
+	    conceal_new_cursor_line = curwin->w_cursor.lnum;
+	    conceal_update_lines = TRUE;
+	}
+# endif
+	last_cursormoved = curwin->w_cursor;
+    }
+
+    update_screen(0);	/* may need to update the screen */
+    setcursor();
+# ifdef FEAT_CONCEAL
+    if (conceal_update_lines
+	    && (conceal_old_cursor_line != conceal_new_cursor_line
+		|| conceal_cursor_line(curwin)
+		|| need_cursor_line_redraw))
+    {
+	if (conceal_old_cursor_line != conceal_new_cursor_line)
+	    update_single_line(curwin, conceal_old_cursor_line);
+	update_single_line(curwin, conceal_new_cursor_line);
+	curwin->w_valid &= ~VALID_CROW;
+    }
+# endif
+    out_flush_cursor(TRUE, FALSE);
+}
+#endif
+
+#if defined(FIND_REPLACE_DIALOG) || defined(PROTO)
+/*
+ * Get the text to use in a find/replace dialog.  Uses the last search pattern
+ * if the argument is empty.
+ * Returns an allocated string.
+ */
+    char_u *
+get_find_dialog_text(
+    char_u	*arg,
+    int		*wwordp,	/* return: TRUE if \< \> found */
+    int		*mcasep)	/* return: TRUE if \C found */
+{
+    char_u	*text;
+
+    if (*arg == NUL)
+	text = last_search_pat();
+    else
+	text = arg;
+    if (text != NULL)
+    {
+	text = vim_strsave(text);
+	if (text != NULL)
+	{
+	    int len = (int)STRLEN(text);
+	    int i;
+
+	    /* Remove "\V" */
+	    if (len >= 2 && STRNCMP(text, "\\V", 2) == 0)
+	    {
+		mch_memmove(text, text + 2, (size_t)(len - 1));
+		len -= 2;
+	    }
+
+	    /* Recognize "\c" and "\C" and remove. */
+	    if (len >= 2 && *text == '\\' && (text[1] == 'c' || text[1] == 'C'))
+	    {
+		*mcasep = (text[1] == 'C');
+		mch_memmove(text, text + 2, (size_t)(len - 1));
+		len -= 2;
+	    }
+
+	    /* Recognize "\<text\>" and remove. */
+	    if (len >= 4
+		    && STRNCMP(text, "\\<", 2) == 0
+		    && STRNCMP(text + len - 2, "\\>", 2) == 0)
+	    {
+		*wwordp = TRUE;
+		mch_memmove(text, text + 2, (size_t)(len - 4));
+		text[len - 4] = NUL;
+	    }
+
+	    /* Recognize "\/" or "\?" and remove. */
+	    for (i = 0; i + 1 < len; ++i)
+		if (text[i] == '\\' && (text[i + 1] == '/'
+						       || text[i + 1] == '?'))
+		{
+		    mch_memmove(text + i, text + i + 1, (size_t)(len - i));
+		    --len;
+		}
+	}
+    }
+    return text;
+}
+
+/*
+ * Handle the press of a button in the find-replace dialog.
+ * Return TRUE when something was added to the input buffer.
+ */
+    int
+gui_do_findrepl(
+    int		flags,		/* one of FRD_REPLACE, FRD_FINDNEXT, etc. */
+    char_u	*find_text,
+    char_u	*repl_text,
+    int		down)		/* Search downwards. */
+{
+    garray_T	ga;
+    int		i;
+    int		type = (flags & FRD_TYPE_MASK);
+    char_u	*p;
+    regmatch_T	regmatch;
+    int		save_did_emsg = did_emsg;
+    static int  busy = FALSE;
+
+    /* When the screen is being updated we should not change buffers and
+     * windows structures, it may cause freed memory to be used.  Also don't
+     * do this recursively (pressing "Find" quickly several times. */
+    if (updating_screen || busy)
+	return FALSE;
+
+    /* refuse replace when text cannot be changed */
+    if ((type == FRD_REPLACE || type == FRD_REPLACEALL) && text_locked())
+	return FALSE;
+
+    busy = TRUE;
+
+    ga_init2(&ga, 1, 100);
+    if (type == FRD_REPLACEALL)
+	ga_concat(&ga, (char_u *)"%s/");
+
+    ga_concat(&ga, (char_u *)"\\V");
+    if (flags & FRD_MATCH_CASE)
+	ga_concat(&ga, (char_u *)"\\C");
+    else
+	ga_concat(&ga, (char_u *)"\\c");
+    if (flags & FRD_WHOLE_WORD)
+	ga_concat(&ga, (char_u *)"\\<");
+    /* escape / and \ */
+    p = vim_strsave_escaped(find_text, (char_u *)"/\\");
+    if (p != NULL)
+        ga_concat(&ga, p);
+    vim_free(p);
+    if (flags & FRD_WHOLE_WORD)
+	ga_concat(&ga, (char_u *)"\\>");
+
+    if (type == FRD_REPLACEALL)
+    {
+	ga_concat(&ga, (char_u *)"/");
+						/* escape / and \ */
+	p = vim_strsave_escaped(repl_text, (char_u *)"/\\");
+	if (p != NULL)
+	    ga_concat(&ga, p);
+	vim_free(p);
+	ga_concat(&ga, (char_u *)"/g");
+    }
+    ga_append(&ga, NUL);
+
+    if (type == FRD_REPLACE)
+    {
+	/* Do the replacement when the text at the cursor matches.  Thus no
+	 * replacement is done if the cursor was moved! */
+	regmatch.regprog = vim_regcomp(ga.ga_data, RE_MAGIC + RE_STRING);
+	regmatch.rm_ic = 0;
+	if (regmatch.regprog != NULL)
+	{
+	    p = ml_get_cursor();
+	    if (vim_regexec_nl(&regmatch, p, (colnr_T)0)
+						   && regmatch.startp[0] == p)
+	    {
+		/* Clear the command line to remove any old "No match"
+		 * error. */
+		msg_end_prompt();
+
+		if (u_save_cursor() == OK)
+		{
+		    /* A button was pressed thus undo should be synced. */
+		    u_sync(FALSE);
+
+		    del_bytes((long)(regmatch.endp[0] - regmatch.startp[0]),
+								FALSE, FALSE);
+		    ins_str(repl_text);
+		}
+	    }
+	    else
+		MSG(_("No match at cursor, finding next"));
+	    vim_regfree(regmatch.regprog);
+	}
+    }
+
+    if (type == FRD_REPLACEALL)
+    {
+	/* A button was pressed, thus undo should be synced. */
+	u_sync(FALSE);
+	do_cmdline_cmd(ga.ga_data);
+    }
+    else
+    {
+	int searchflags = SEARCH_MSG + SEARCH_MARK;
+
+	/* Search for the next match.
+	 * Don't skip text under cursor for single replace. */
+	if (type == FRD_REPLACE)
+	    searchflags += SEARCH_START;
+	i = msg_scroll;
+	if (down)
+	{
+	    (void)do_search(NULL, '/', ga.ga_data, 1L, searchflags, NULL, NULL);
+	}
+	else
+	{
+	    /* We need to escape '?' if and only if we are searching in the up
+	     * direction */
+	    p = vim_strsave_escaped(ga.ga_data, (char_u *)"?");
+	    if (p != NULL)
+	        (void)do_search(NULL, '?', p, 1L, searchflags, NULL, NULL);
+	    vim_free(p);
+	}
+
+	msg_scroll = i;	    /* don't let an error message set msg_scroll */
+    }
+
+    /* Don't want to pass did_emsg to other code, it may cause disabling
+     * syntax HL if we were busy redrawing. */
+    did_emsg = save_did_emsg;
+
+    if (State & (NORMAL | INSERT))
+    {
+	gui_update_screen();		/* update the screen */
+	msg_didout = 0;			/* overwrite any message */
+	need_wait_return = FALSE;	/* don't wait for return */
+    }
+
+    vim_free(ga.ga_data);
+    busy = FALSE;
+    return (ga.ga_len > 0);
+}
+
+#endif
+
+#if defined(HAVE_DROP_FILE) || defined(PROTO)
+
+static void gui_wingoto_xy(int x, int y);
+
+/*
+ * Jump to the window at specified point (x, y).
+ */
+    static void
+gui_wingoto_xy(int x, int y)
+{
+    int		row = Y_2_ROW(y);
+    int		col = X_2_COL(x);
+    win_T	*wp;
+
+    if (row >= 0 && col >= 0)
+    {
+	wp = mouse_find_win(&row, &col);
+	if (wp != NULL && wp != curwin)
+	    win_goto(wp);
+    }
+}
+
+/*
+ * Function passed to handle_drop() for the actions to be done after the
+ * argument list has been updated.
+ */
+    static void
+drop_callback(void *cookie)
+{
+    char_u	*p = cookie;
+
+    /* If Shift held down, change to first file's directory.  If the first
+     * item is a directory, change to that directory (and let the explorer
+     * plugin show the contents). */
+    if (p != NULL)
+    {
+	if (mch_isdir(p))
+	{
+	    if (mch_chdir((char *)p) == 0)
+		shorten_fnames(TRUE);
+	}
+	else if (vim_chdirfile(p, "drop") == OK)
+	    shorten_fnames(TRUE);
+	vim_free(p);
+    }
+
+    /* Update the screen display */
+    update_screen(NOT_VALID);
+# ifdef FEAT_MENU
+    gui_update_menus(0);
+# endif
+#ifdef FEAT_TITLE
+    maketitle();
+#endif
+    setcursor();
+    out_flush_cursor(FALSE, FALSE);
+}
+
+/*
+ * Process file drop.  Mouse cursor position, key modifiers, name of files
+ * and count of files are given.  Argument "fnames[count]" has full pathnames
+ * of dropped files, they will be freed in this function, and caller can't use
+ * fnames after call this function.
+ */
+    void
+gui_handle_drop(
+    int		x UNUSED,
+    int		y UNUSED,
+    int_u	modifiers,
+    char_u	**fnames,
+    int		count)
+{
+    int		i;
+    char_u	*p;
+    static int	entered = FALSE;
+
+    /*
+     * This function is called by event handlers.  Just in case we get a
+     * second event before the first one is handled, ignore the second one.
+     * Not sure if this can ever happen, just in case.
+     */
+    if (entered)
+	return;
+    entered = TRUE;
+
+    /*
+     * When the cursor is at the command line, add the file names to the
+     * command line, don't edit the files.
+     */
+    if (State & CMDLINE)
+    {
+	shorten_filenames(fnames, count);
+	for (i = 0; i < count; ++i)
+	{
+	    if (fnames[i] != NULL)
+	    {
+		if (i > 0)
+		    add_to_input_buf((char_u*)" ", 1);
+
+		/* We don't know what command is used thus we can't be sure
+		 * about which characters need to be escaped.  Only escape the
+		 * most common ones. */
+# ifdef BACKSLASH_IN_FILENAME
+		p = vim_strsave_escaped(fnames[i], (char_u *)" \t\"|");
+# else
+		p = vim_strsave_escaped(fnames[i], (char_u *)"\\ \t\"|");
+# endif
+		if (p != NULL)
+		    add_to_input_buf_csi(p, (int)STRLEN(p));
+		vim_free(p);
+		vim_free(fnames[i]);
+	    }
+	}
+	vim_free(fnames);
+    }
+    else
+    {
+	/* Go to the window under mouse cursor, then shorten given "fnames" by
+	 * current window, because a window can have local current dir. */
+	gui_wingoto_xy(x, y);
+	shorten_filenames(fnames, count);
+
+	/* If Shift held down, remember the first item. */
+	if ((modifiers & MOUSE_SHIFT) != 0)
+	    p = vim_strsave(fnames[0]);
+	else
+	    p = NULL;
+
+	/* Handle the drop, :edit or :split to get to the file.  This also
+	 * frees fnames[].  Skip this if there is only one item it's a
+	 * directory and Shift is held down. */
+	if (count == 1 && (modifiers & MOUSE_SHIFT) != 0
+						     && mch_isdir(fnames[0]))
+	{
+	    vim_free(fnames[0]);
+	    vim_free(fnames);
+	}
+	else
+	    handle_drop(count, fnames, (modifiers & MOUSE_CTRL) != 0,
+		    drop_callback, (void *)p);
+    }
+
+    entered = FALSE;
+}
+#endif
diff --git a/b/src/gui_haiku.cc b/src/gui_haiku.cc
new file mode 100644
index 0000000..ef0ec7d
--- /dev/null
+++ b/src/gui_haiku.cc
@@ -0,0 +1,5292 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved			by Bram Moolenaar
+ *			    BeBox GUI support Copyright 1998 by Olaf Seibert.
+ *			    All Rights Reserved.
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ *
+ * Based on "GUI support for the Buzzword Enhanced Operating System."
+ *
+ * Ported to R4 by Richard Offer <richard@whitequeen.com> Jul 99
+ *
+ * Haiku support by Siarzhuk Zharski <imker@gmx.li> Apr-Mai 2009
+ *
+ */
+
+/*
+ * Structure of the Haiku GUI code:
+ *
+ * There are 3 threads.
+ * 1. The initial thread. In gui_mch_prepare() this gets to run the
+ *    BApplication message loop. But before it starts doing that,
+ *    it creates thread 2
+ * 2. The main() thread. This thread is created in gui_mch_prepare()
+ *    and its purpose in life is to call main(argc, argv) again.
+ *    This thread is doing the bulk of the work.
+ * 3. Sooner or later, a window is opened by the main() thread. This
+ *    causes a second message loop to be created: the window thread.
+ *
+ * == alternatively ===
+ *
+ * #if RUN_BAPPLICATION_IN_NEW_THREAD...
+ *
+ * 1. The initial thread. In gui_mch_prepare() this gets to spawn
+ *    thread 2. After doing that, it returns to main() to do the
+ *    bulk of the work, being the main() thread.
+ * 2. Runs the BApplication.
+ * 3. The window thread, just like in the first case.
+ *
+ * This second alternative is cleaner from Vim's viewpoint. However,
+ * the BeBook seems to assume everywhere that the BApplication *must*
+ * run in the initial thread. So perhaps doing otherwise is very wrong.
+ *
+ * However, from a B_SINGLE_LAUNCH viewpoint, the first is better.
+ * If Vim is marked "Single Launch" in its application resources,
+ * and a file is dropped on the Vim icon, and another Vim is already
+ * running, the file is passed on to the earlier Vim. This happens
+ * in BApplication::Run(). So we want Vim to terminate if
+ * BApplication::Run() terminates. (See the BeBook, on BApplication.
+ * However, it seems that the second copy of Vim isn't even started
+ * in this case... which is for the better since I wouldn't know how
+ * to detect this case.)
+ *
+ * Communication between these threads occurs mostly by translating
+ * BMessages that come in and posting an appropriate translation on
+ * the VDCMP (Vim Direct Communication Message Port). Therefore the
+ * actions required for keypresses and window resizes, etc, are mostly
+ * performed in the main() thread.
+ *
+ * A notable exception to this is the Draw() event. The redrawing of
+ * the window contents is performed asynchronously from the window
+ * thread. To make this work correctly, a locking protocol is used when
+ * any thread is accessing the essential variables that are used by
+ * the window thread.
+ *
+ * This locking protocol consists of locking Vim's window. This is both
+ * convenient and necessary.
+ */
+
+extern "C" {
+
+#include <assert.h>
+#include <float.h>
+#include <syslog.h>
+
+#include "vim.h"
+#include "globals.h"
+#include "proto.h"
+#include "version.h"
+
+}	/* extern "C" */
+
+/* ---------------- start of header part ---------------- */
+
+//#include <Alert.h>
+#include <Application.h>
+#include <Beep.h>
+#include <Bitmap.h>
+#include <Box.h>
+#include <Button.h>
+#include <Clipboard.h>
+#include <Debug.h>
+//#include <Directory.h>
+//#include <Entry.h>
+#include <File.h>
+#include <FilePanel.h>
+#include <FindDirectory.h>
+//#include <Font.h>
+#include <IconUtils.h>
+#include <Input.h>
+#include <ListView.h>
+#include <MenuBar.h>
+#include <MenuItem.h>
+//#include <MessageQueue.h>
+//#include <OS.h>
+#include <Path.h>
+#include <PictureButton.h>
+#include <PopUpMenu.h>
+//#include <Region.h>
+#include <Resources.h>
+//#include <Roster.h>
+#include <Screen.h>
+#include <ScrollBar.h>
+#include <ScrollView.h>
+#include <String.h>
+#include <StringView.h>
+//#include <SupportDefs.h>
+#include <TabView.h>
+#include <TextControl.h>
+#include <TextView.h>
+#include <TranslationUtils.h>
+#include <TranslatorFormats.h>
+#include <View.h>
+#include <Window.h>
+
+class VimApp;
+class VimFormView;
+class VimTextAreaView;
+class VimWindow;
+class VimToolbar;
+class VimTabLine;
+
+extern key_map *keyMap;
+extern char *keyMapChars;
+
+extern int main(int argc, char **argv);
+
+#ifndef B_MAX_PORT_COUNT
+#define B_MAX_PORT_COUNT    255
+#endif
+
+/*
+ * VimApp seems comparable to the X "vimShell"
+ */
+class VimApp: public BApplication
+{
+	typedef BApplication Inherited;
+	public:
+	VimApp(const char *appsig);
+	~VimApp();
+
+	// callbacks:
+#if 0
+	virtual void DispatchMessage(BMessage *m, BHandler *h)
+	{
+		m->PrintToStream();
+		Inherited::DispatchMessage(m, h);
+	}
+#endif
+	virtual void ReadyToRun();
+	virtual void ArgvReceived(int32 argc, char **argv);
+	virtual void RefsReceived(BMessage *m);
+	virtual bool QuitRequested();
+	virtual void MessageReceived(BMessage *m);
+
+	static void SendRefs(BMessage *m, bool changedir);
+
+	sem_id		fFilePanelSem;
+	BFilePanel*	fFilePanel;
+	BPath		fBrowsedPath;
+	private:
+};
+
+class VimWindow: public BWindow
+{
+	typedef BWindow Inherited;
+	public:
+	VimWindow();
+	~VimWindow();
+
+	//    virtual void DispatchMessage(BMessage *m, BHandler *h);
+	virtual void WindowActivated(bool active);
+	virtual bool QuitRequested();
+
+	VimFormView		*formView;
+
+	private:
+	void init();
+
+};
+
+class VimFormView: public BView
+{
+	typedef BView Inherited;
+	public:
+	VimFormView(BRect frame);
+	~VimFormView();
+
+	// callbacks:
+	virtual void AllAttached();
+	virtual void FrameResized(float new_width, float new_height);
+
+#define MENUBAR_MARGIN	1
+	float MenuHeight() const
+	{ return menuBar ? menuBar->Frame().Height() + MENUBAR_MARGIN: 0; }
+	BMenuBar *MenuBar() const
+	{ return menuBar; }
+
+	private:
+	void init(BRect);
+
+	BMenuBar		*menuBar;
+	VimTextAreaView	*textArea;
+
+#ifdef FEAT_TOOLBAR
+	public:
+	float ToolbarHeight() const;
+	VimToolbar *ToolBar() const
+	{ return toolBar; }
+	private:
+	VimToolbar		*toolBar;
+#endif
+
+#ifdef FEAT_GUI_TABLINE
+	public:
+	VimTabLine *TabLine() const	{ return tabLine; }
+	bool IsShowingTabLine() const { return showingTabLine; }
+	void SetShowingTabLine(bool showing) { showingTabLine = showing;	}
+	float TablineHeight() const;
+	private:
+	VimTabLine	*tabLine;
+	int	showingTabLine;
+#endif
+};
+
+class VimTextAreaView: public BView
+{
+	typedef BView Inherited;
+	public:
+	VimTextAreaView(BRect frame);
+	~VimTextAreaView();
+
+	// callbacks:
+	virtual void Draw(BRect updateRect);
+	virtual void KeyDown(const char *bytes, int32 numBytes);
+	virtual void MouseDown(BPoint point);
+	virtual void MouseUp(BPoint point);
+	virtual void MouseMoved(BPoint point, uint32 transit, const BMessage *message);
+	virtual void MessageReceived(BMessage *m);
+
+	// own functions:
+	int mchInitFont(char_u *name);
+	void mchDrawString(int row, int col, char_u *s, int len, int flags);
+	void mchClearBlock(int row1, int col1, int row2, int col2);
+	void mchClearAll();
+	void mchDeleteLines(int row, int num_lines);
+	void mchInsertLines(int row, int num_lines);
+
+	static void guiSendMouseEvent(int button, int x, int y, int repeated_click, int_u modifiers);
+	static void guiMouseMoved(int x, int y);
+	static void guiBlankMouse(bool should_hide);
+	static int_u mouseModifiersToVim(int32 beModifiers);
+
+	int32 mouseDragEventCount;
+
+#ifdef FEAT_MBYTE_IME
+	void DrawIMString(void);
+#endif
+
+	private:
+	void init(BRect);
+
+	int_u	    vimMouseButton;
+	int_u	    vimMouseModifiers;
+
+#ifdef FEAT_MBYTE_IME
+	struct {
+		BMessenger* messenger;
+		BMessage* message;
+		BPoint location;
+		int row;
+		int col;
+		int count;
+	} IMData;
+#endif
+};
+
+class VimScrollBar: public BScrollBar
+{
+	typedef BScrollBar Inherited;
+	public:
+	VimScrollBar(scrollbar_T *gsb, orientation posture);
+	~VimScrollBar();
+
+	virtual void ValueChanged(float newValue);
+	virtual void MouseUp(BPoint where);
+	void SetValue(float newval);
+	scrollbar_T *getGsb()
+	{ return gsb; }
+
+	int32	    scrollEventCount;
+
+	private:
+	scrollbar_T *gsb;
+	float	ignoreValue;
+};
+
+
+#ifdef FEAT_TOOLBAR
+
+class VimToolbar : public BBox
+{
+	static BBitmap *normalButtonsBitmap;
+	static BBitmap *grayedButtonsBitmap;
+
+	BBitmap *LoadVimBitmap(const char* fileName);
+	bool GetPictureFromBitmap(BPicture *pictureTo, int32 index, BBitmap *bitmapFrom, bool pressed);
+	bool ModifyBitmapToGrayed(BBitmap *bitmap);
+
+	BList fButtonsList;
+	void InvalidateLayout();
+
+	public:
+	VimToolbar(BRect frame, const char * name);
+	~VimToolbar();
+
+	bool PrepareButtonBitmaps();
+
+	bool AddButton(int32 index, vimmenu_T *menu);
+	bool RemoveButton(vimmenu_T *menu);
+	bool GrayButton(vimmenu_T *menu, int grey);
+
+	float ToolbarHeight() const;
+	virtual void AttachedToWindow();
+};
+
+BBitmap *VimToolbar::normalButtonsBitmap  = NULL;
+BBitmap *VimToolbar::grayedButtonsBitmap  = NULL;
+
+const float ToolbarMargin = 3.;
+const float ButtonMargin  = 3.;
+
+#endif /*FEAT_TOOLBAR*/
+
+#ifdef FEAT_GUI_TABLINE
+
+class VimTabLine : public BTabView
+{
+	public:
+		class VimTab : public BTab {
+			public:
+				VimTab() : BTab(new BView(BRect(), "-Empty-", 0, 0)) {}
+
+			virtual void Select(BView* owner);
+		};
+
+		VimTabLine(BRect r) : BTabView(r, "vimTabLine", B_WIDTH_FROM_LABEL,
+			   B_FOLLOW_LEFT | B_FOLLOW_TOP | B_FOLLOW_RIGHT, B_WILL_DRAW | B_FRAME_EVENTS) {}
+
+	float TablineHeight() const;
+	virtual void MouseDown(BPoint point);
+};
+
+#endif //FEAT_GUI_TABLINE
+
+
+/*
+ * For caching the fonts that are used;
+ * Vim seems rather sloppy in this regard.
+ */
+class VimFont: public BFont
+{
+	typedef BFont Inherited;
+	public:
+	VimFont();
+	VimFont(const VimFont *rhs);
+	VimFont(const BFont *rhs);
+	VimFont(const VimFont &rhs);
+	~VimFont();
+
+	VimFont *next;
+	int refcount;
+	char_u *name;
+
+	private:
+	void init();
+};
+
+#if defined(FEAT_GUI_DIALOG)
+
+class VimDialog : public BWindow
+{
+	typedef BWindow Inherited;
+
+	BButton* _CreateButton(int32 which, const char* label);
+
+	public:
+
+	class View : public BView {
+		typedef BView Inherited;
+
+		public:
+		View(BRect frame);
+		~View();
+
+		virtual void Draw(BRect updateRect);
+		void InitIcon(int32 type);
+
+		private:
+		BBitmap*	fIconBitmap;
+	};
+
+	VimDialog(int type, const char *title, const char *message,
+			const char *buttons, int dfltbutton, const char *textfield,
+			int ex_cmd);
+	~VimDialog();
+
+	int Go();
+
+	virtual void MessageReceived(BMessage *msg);
+
+	private:
+	sem_id			fDialogSem;
+	int				fDialogValue;
+	BList			fButtonsList;
+	BTextView*		fMessageView;
+	BTextControl*	fInputControl;
+	const char*		fInputValue;
+};
+
+class VimSelectFontDialog : public BWindow
+{
+	typedef BWindow Inherited;
+
+	void _CleanList(BListView* list);
+	void _UpdateFontStyles();
+	void _UpdateSizeInputPreview();
+	void _UpdateFontPreview();
+	bool _UpdateFromListItem(BListView* list, char* text, int textSize);
+	public:
+
+	VimSelectFontDialog(font_family* family, font_style* style, float* size);
+	~VimSelectFontDialog();
+
+	bool Go();
+
+	virtual void MessageReceived(BMessage *msg);
+
+	private:
+	status_t		fStatus;
+	sem_id			fDialogSem;
+	bool			fDialogValue;
+	font_family*	fFamily;
+	font_style*		fStyle;
+	float*			fSize;
+	font_family		fFontFamily;
+	font_style		fFontStyle;
+	float			fFontSize;
+	BStringView*	fPreview;
+	BListView*		fFamiliesList;
+	BListView*		fStylesList;
+	BListView*		fSizesList;
+	BTextControl*	fSizesInput;
+};
+
+#endif /* FEAT_GUI_DIALOG */
+
+/* ---------------- end of GUI classes ---------------- */
+
+struct MainArgs {
+	int		 argc;
+	char	**argv;
+};
+
+/*
+ * These messages are copied through the VDCMP.
+ * Therefore they ought not to have anything fancy.
+ * They must be of POD type (Plain Old Data)
+ * as the C++ standard calls them.
+ */
+
+#define	KEY_MSG_BUFSIZ	7
+#if KEY_MSG_BUFSIZ < MAX_KEY_CODE_LEN
+#error Increase KEY_MSG_BUFSIZ!
+#endif
+
+struct VimKeyMsg {
+	char_u	length;
+	char_u	chars[KEY_MSG_BUFSIZ];	/* contains Vim encoding */
+#ifdef FEAT_MBYTE
+	bool    csi_escape;
+#endif
+};
+
+struct VimResizeMsg {
+	int		width;
+	int		height;
+};
+
+struct VimScrollBarMsg {
+	VimScrollBar *sb;
+	long	value;
+	int		stillDragging;
+};
+
+struct VimMenuMsg {
+	vimmenu_T	*guiMenu;
+};
+
+struct VimMouseMsg {
+	int		button;
+	int		x;
+	int		y;
+	int		repeated_click;
+	int_u	modifiers;
+};
+
+struct VimMouseMovedMsg {
+	int		x;
+	int		y;
+};
+
+struct VimFocusMsg {
+	bool	active;
+};
+
+struct VimRefsMsg {
+	BMessage   *message;
+	bool	changedir;
+};
+
+struct VimTablineMsg {
+	int		index;
+};
+
+struct VimTablineMenuMsg {
+	int		index;
+	int		event;
+};
+
+struct VimMsg {
+	enum VimMsgType {
+		Key, Resize, ScrollBar, Menu, Mouse, MouseMoved, Focus, Refs, Tabline, TablineMenu
+	};
+
+	union {
+		struct VimKeyMsg	Key;
+		struct VimResizeMsg	NewSize;
+		struct VimScrollBarMsg	Scroll;
+		struct VimMenuMsg	Menu;
+		struct VimMouseMsg	Mouse;
+		struct VimMouseMovedMsg	MouseMoved;
+		struct VimFocusMsg	Focus;
+		struct VimRefsMsg	Refs;
+		struct VimTablineMsg	Tabline;
+		struct VimTablineMenuMsg	TablineMenu;
+	} u;
+};
+
+#define RGB(r, g, b)	((char_u)(r) << 16 | (char_u)(g) << 8 | (char_u)(b) << 0)
+#define GUI_TO_RGB(g)	{ (g) >> 16, (g) >> 8, (g) >> 0, 255 }
+
+/* ---------------- end of header part ---------------- */
+
+static struct specialkey
+{
+	uint16  BeKeys;
+#define KEY(a,b)	((a)<<8|(b))
+#define K(a)		KEY(0,a)		    // for ASCII codes
+#define F(b)		KEY(1,b)		    // for scancodes
+	char_u  vim_code0;
+	char_u  vim_code1;
+} special_keys[] =
+{
+	{K(B_UP_ARROW),	    'k', 'u'},
+	{K(B_DOWN_ARROW),	    'k', 'd'},
+	{K(B_LEFT_ARROW),	    'k', 'l'},
+	{K(B_RIGHT_ARROW),	    'k', 'r'},
+	{K(B_BACKSPACE),	    'k', 'b'},
+	{K(B_INSERT),	    'k', 'I'},
+	{K(B_DELETE),	    'k', 'D'},
+	{K(B_HOME),		    'k', 'h'},
+	{K(B_END),		    '@', '7'},
+	{K(B_PAGE_UP),	    'k', 'P'},	    /* XK_Prior */
+	{K(B_PAGE_DOWN),	    'k', 'N'},	    /* XK_Next, */
+
+#define FIRST_FUNCTION_KEY  11
+	{F(B_F1_KEY),	    'k', '1'},
+	{F(B_F2_KEY),	    'k', '2'},
+	{F(B_F3_KEY),	    'k', '3'},
+	{F(B_F4_KEY),	    'k', '4'},
+	{F(B_F5_KEY),	    'k', '5'},
+	{F(B_F6_KEY),	    'k', '6'},
+	{F(B_F7_KEY),	    'k', '7'},
+	{F(B_F8_KEY),	    'k', '8'},
+	{F(B_F9_KEY),	    'k', '9'},
+	{F(B_F10_KEY),	    'k', ';'},
+
+	{F(B_F11_KEY),	    'F', '1'},
+	{F(B_F12_KEY),	    'F', '2'},
+	//  {XK_F13,		    'F', '3'},		/* would be print screen/ */
+	/* sysreq */
+	{F(0x0F),		    'F', '4'},		/* scroll lock */
+	{F(0x10),		    'F', '5'},		/* pause/break */
+	//  {XK_F16,	    'F', '6'},
+	//  {XK_F17,	    'F', '7'},
+	//  {XK_F18,	    'F', '8'},
+	//  {XK_F19,	    'F', '9'},
+	//  {XK_F20,	    'F', 'A'},
+	//
+	//  {XK_F21,	    'F', 'B'},
+	//  {XK_F22,	    'F', 'C'},
+	//  {XK_F23,	    'F', 'D'},
+	//  {XK_F24,	    'F', 'E'},
+	//  {XK_F25,	    'F', 'F'},
+	//  {XK_F26,	    'F', 'G'},
+	//  {XK_F27,	    'F', 'H'},
+	//  {XK_F28,	    'F', 'I'},
+	//  {XK_F29,	    'F', 'J'},
+	//  {XK_F30,	    'F', 'K'},
+	//
+	//  {XK_F31,	    'F', 'L'},
+	//  {XK_F32,	    'F', 'M'},
+	//  {XK_F33,	    'F', 'N'},
+	//  {XK_F34,	    'F', 'O'},
+	//  {XK_F35,	    'F', 'P'},	    /* keysymdef.h defines up to F35 */
+
+	//  {XK_Help,	    '%', '1'},	    /* XK_Help */
+	{F(B_PRINT_KEY),	    '%', '9'},
+
+#if 0
+	/* Keypad keys: */
+	{F(0x48),	    'k', 'l'},	    /* XK_KP_Left */
+	{F(0x4A),	    'k', 'r'},	    /* XK_KP_Right */
+	{F(0x38),	    'k', 'u'},	    /* XK_KP_Up */
+	{F(0x59),	    'k', 'd'},	    /* XK_KP_Down */
+	{F(0x64),	    'k', 'I'},	    /* XK_KP_Insert */
+	{F(0x65),	    'k', 'D'},	    /* XK_KP_Delete */
+	{F(0x37),	    'k', 'h'},	    /* XK_KP_Home */
+	{F(0x58),	    '@', '7'},	    /* XK_KP_End */
+	{F(0x39),	    'k', 'P'},	    /* XK_KP_Prior */
+	{F(0x60),	    'k', 'N'},	    /* XK_KP_Next */
+	{F(0x49),	    '&', '8'},	    /* XK_Undo, keypad 5 */
+#endif
+
+	/* End of list marker: */
+	{0,			    0, 0}
+};
+
+#define NUM_SPECIAL_KEYS    (sizeof(special_keys)/sizeof(special_keys[0]))
+
+/* ---------------- VimApp ---------------- */
+
+	static void
+docd(BPath &path)
+{
+	mch_chdir((char *)path.Path());
+	/* Do this to get the side effects of a :cd command */
+	do_cmdline_cmd((char_u *)"cd .");
+}
+
+/*
+ * Really handle dropped files and folders.
+ */
+	static void
+RefsReceived(BMessage *m, bool changedir)
+{
+	uint32 type;
+	int32 count;
+
+	m->PrintToStream();
+	switch (m->what) {
+		case B_REFS_RECEIVED:
+		case B_SIMPLE_DATA:
+			m->GetInfo("refs", &type, &count);
+			if (type != B_REF_TYPE)
+				goto bad;
+			break;
+		case B_ARGV_RECEIVED:
+			m->GetInfo("argv", &type, &count);
+			if (type != B_STRING_TYPE)
+				goto bad;
+			if (changedir) {
+				char *dirname;
+				if (m->FindString("cwd", (const char **) &dirname) == B_OK) {
+					chdir(dirname);
+					do_cmdline_cmd((char_u *)"cd .");
+				}
+			}
+			break;
+		default:
+bad:
+			//fprintf(stderr, "bad!\n");
+			delete m;
+			return;
+	}
+
+#ifdef FEAT_VISUAL
+	reset_VIsual();
+#endif
+
+	char_u  **fnames;
+	fnames = (char_u **) alloc(count * sizeof(char_u *));
+	int fname_index = 0;
+
+	switch (m->what) {
+		case B_REFS_RECEIVED:
+		case B_SIMPLE_DATA:
+			//fprintf(stderr, "case B_REFS_RECEIVED\n");
+			for (int i = 0; i < count; ++i)
+			{
+				entry_ref ref;
+				if (m->FindRef("refs", i, &ref) == B_OK) {
+					BEntry entry(&ref, false);
+					BPath path;
+					entry.GetPath(&path);
+
+					/* Change to parent directory? */
+					if (changedir) {
+						BPath parentpath;
+						path.GetParent(&parentpath);
+						docd(parentpath);
+					}
+
+					/* Is it a directory? If so, cd into it. */
+					BDirectory bdir(&ref);
+					if (bdir.InitCheck() == B_OK) {
+						/* don't cd if we already did it */
+						if (!changedir)
+							docd(path);
+					} else {
+						mch_dirname(IObuff, IOSIZE);
+						char_u *fname = shorten_fname((char_u *)path.Path(), IObuff);
+						if (fname == NULL)
+							fname = (char_u *)path.Path();
+						fnames[fname_index++] = vim_strsave(fname);
+						//fprintf(stderr, "%s\n", fname);
+					}
+
+					/* Only do it for the first file/dir */
+					changedir = false;
+				}
+			}
+			break;
+		case B_ARGV_RECEIVED:
+			//fprintf(stderr, "case B_ARGV_RECEIVED\n");
+			for (int i = 1; i < count; ++i)
+			{
+				char *fname;
+
+				if (m->FindString("argv", i, (const char **) &fname) == B_OK) {
+					fnames[fname_index++] = vim_strsave((char_u *)fname);
+				}
+			}
+			break;
+		default:
+			//fprintf(stderr, "case default\n");
+			break;
+	}
+
+	delete m;
+
+	/* Handle the drop, :edit to get to the file */
+	if (fname_index > 0) {
+		handle_drop(fname_index, fnames, FALSE);
+
+		/* Update the screen display */
+		update_screen(NOT_VALID);
+		setcursor();
+		out_flush();
+	} else {
+		vim_free(fnames);
+	}
+}
+
+VimApp::VimApp(const char *appsig):
+	BApplication(appsig),
+	fFilePanelSem(-1),
+	fFilePanel(NULL)
+{
+}
+
+VimApp::~VimApp()
+{
+}
+
+	void
+VimApp::ReadyToRun()
+{
+	/*
+	 * Apparently signals are inherited by the created thread -
+	 * disable the most annoying ones.
+	 */
+	signal(SIGINT, SIG_IGN);
+	signal(SIGQUIT, SIG_IGN);
+}
+
+	void
+VimApp::ArgvReceived(int32 arg_argc, char **arg_argv)
+{
+	if (!IsLaunching()) {
+		/*
+		 * This can happen if we are set to Single or Exclusive
+		 * Launch. Be nice and open the file(s).
+		 */
+		if (gui.vimWindow)
+			gui.vimWindow->Minimize(false);
+		BMessage *m = CurrentMessage();
+		DetachCurrentMessage();
+		SendRefs(m, true);
+	}
+}
+
+	void
+VimApp::RefsReceived(BMessage *m)
+{
+	/* Horrible hack!!! XXX XXX XXX
+	 * The real problem is that b_start_ffc is set too late for
+	 * the initial empty buffer. As a result the window will be
+	 * split instead of abandoned.
+	 */
+	int limit = 15;
+	while (--limit >= 0 && (curbuf == NULL || curbuf->b_start_ffc == 0))
+		snooze(100000);    // 0.1 s
+	if (gui.vimWindow)
+		gui.vimWindow->Minimize(false);
+	DetachCurrentMessage();
+	SendRefs(m, true);
+}
+
+/*
+ * Pass a BMessage on to the main() thread.
+ * Caller must have detached the message.
+ */
+	void
+VimApp::SendRefs(BMessage *m, bool changedir)
+{
+	VimRefsMsg rm;
+	rm.message = m;
+	rm.changedir = changedir;
+
+	write_port(gui.vdcmp, VimMsg::Refs, &rm, sizeof(rm));
+	// calls ::RefsReceived
+}
+
+	void
+VimApp::MessageReceived(BMessage *m)
+{
+	switch (m->what) {
+		case 'save':
+			{
+				entry_ref refDirectory;
+				m->FindRef("directory", &refDirectory);
+				fBrowsedPath.SetTo(&refDirectory);
+				BString strName;
+				m->FindString("name", &strName);
+				fBrowsedPath.Append(strName.String());
+			}
+			break;
+		case 'open':
+			{
+				entry_ref ref;
+				m->FindRef("refs", &ref);
+				fBrowsedPath.SetTo(&ref);
+			}
+			break;
+		case B_CANCEL:
+			{
+				BFilePanel *panel;
+				m->FindPointer("source", (void**)&panel);
+				if(fFilePanelSem != -1 && panel == fFilePanel)
+				{
+					delete_sem(fFilePanelSem);
+					fFilePanelSem = -1;
+				}
+
+			}
+			break;
+		default:
+			Inherited::MessageReceived(m);
+			break;
+	}
+}
+
+	bool
+VimApp::QuitRequested()
+{
+	(void)Inherited::QuitRequested();
+	return false;
+}
+
+/* ---------------- VimWindow ---------------- */
+
+VimWindow::VimWindow():
+	BWindow(BRect(40, 40, 150, 150),
+			"Vim",
+			B_TITLED_WINDOW,
+			0,
+			B_CURRENT_WORKSPACE)
+
+{
+	init();
+}
+
+VimWindow::~VimWindow()
+{
+	if (formView) {
+		RemoveChild(formView);
+		delete formView;
+	}
+	gui.vimWindow = NULL;
+}
+
+	void
+VimWindow::init()
+{
+	/* Attach the VimFormView */
+	formView = new VimFormView(Bounds());
+	if (formView != NULL) {
+		AddChild(formView);
+	}
+}
+
+#if 0  // disabled in zeta patch
+	void
+VimWindow::DispatchMessage(BMessage *m, BHandler *h)
+{
+	/*
+	 * Route B_MOUSE_UP messages to MouseUp(), in
+	 * a manner that should be compatible with the
+	 * intended future system behaviour.
+	 */
+	switch (m->what) {
+		case B_MOUSE_UP:
+			// if (!h) h = PreferredHandler();
+			// gcc isn't happy without this extra set of braces, complains about
+			// jump to case label crosses init of 'class BView * v'
+			// richard@whitequeen.com jul 99
+			{
+				BView *v = dynamic_cast<BView *>(h);
+				if (v) {
+					//m->PrintToStream();
+					BPoint where;
+					m->FindPoint("where", &where);
+					v->MouseUp(where);
+				} else {
+					Inherited::DispatchMessage(m, h);
+				}
+			}
+			break;
+		default:
+			Inherited::DispatchMessage(m, h);
+	}
+}
+#endif
+
+	void
+VimWindow::WindowActivated(bool active)
+{
+	Inherited::WindowActivated(active);
+	/* the textArea gets the keyboard action */
+	if (active && gui.vimTextArea)
+		gui.vimTextArea->MakeFocus(true);
+
+	struct VimFocusMsg fm;
+	fm.active = active;
+
+	write_port(gui.vdcmp, VimMsg::Focus, &fm, sizeof(fm));
+}
+
+	bool
+VimWindow::QuitRequested()
+{
+	struct VimKeyMsg km;
+	km.length = 5;
+	memcpy((char *)km.chars, "\033:qa\r", km.length);
+
+#ifdef FEAT_MBYTE
+	km.csi_escape = false;
+#endif
+
+	write_port(gui.vdcmp, VimMsg::Key, &km, sizeof(km));
+
+	return false;
+}
+
+/* ---------------- VimFormView ---------------- */
+
+VimFormView::VimFormView(BRect frame):
+	BView(frame, "VimFormView", B_FOLLOW_ALL_SIDES,
+			B_WILL_DRAW | B_FRAME_EVENTS),
+	menuBar(NULL),
+#ifdef FEAT_TOOLBAR
+	toolBar(NULL),
+#endif
+#ifdef FEAT_GUI_TABLINE
+//	showingTabLine(false),
+	tabLine(NULL),
+#endif
+	textArea(NULL)
+{
+	init(frame);
+}
+
+VimFormView::~VimFormView()
+{
+	if (menuBar) {
+		RemoveChild(menuBar);
+#ifdef never
+		// deleting the menuBar leads to SEGV on exit
+		// richard@whitequeen.com Jul 99
+		delete menuBar;
+#endif
+	}
+
+#ifdef FEAT_TOOLBAR
+	delete toolBar;
+#endif
+
+#ifdef FEAT_GUI_TABLINE
+	delete tabLine;
+#endif
+
+	if (textArea) {
+		RemoveChild(textArea);
+		delete textArea;
+	}
+	gui.vimForm = NULL;
+}
+
+	void
+VimFormView::init(BRect frame)
+{
+	menuBar = new BMenuBar(BRect(0,0,-MENUBAR_MARGIN,-MENUBAR_MARGIN),
+			"VimMenuBar");
+
+	AddChild(menuBar);
+
+#ifdef FEAT_TOOLBAR
+	toolBar = new VimToolbar(BRect(0,0,0,0), "VimToolBar");
+	toolBar->PrepareButtonBitmaps();
+	AddChild(toolBar);
+#endif
+
+#ifdef FEAT_GUI_TABLINE
+	tabLine = new VimTabLine(BRect(0,0,0,0));
+//	tabLine->PrepareButtonBitmaps();
+	AddChild(tabLine);
+#endif
+
+	BRect remaining = frame;
+	textArea = new VimTextAreaView(remaining);
+	AddChild(textArea);
+	/* The textArea will be resized later when menus are added */
+
+	gui.vimForm = this;
+}
+
+#ifdef FEAT_TOOLBAR
+	float
+VimFormView::ToolbarHeight() const
+{
+	return toolBar ? toolBar->ToolbarHeight() : 0.;
+}
+#endif
+
+#ifdef FEAT_GUI_TABLINE
+	float
+VimFormView::TablineHeight() const
+{
+	return (tabLine && IsShowingTabLine()) ? tabLine->TablineHeight() : 0.;
+}
+#endif
+
+	void
+VimFormView::AllAttached()
+{
+	/*
+	 * Apparently signals are inherited by the created thread -
+	 * disable the most annoying ones.
+	 */
+	signal(SIGINT, SIG_IGN);
+	signal(SIGQUIT, SIG_IGN);
+
+	if (menuBar && textArea) {
+		/*
+		 * Resize the textArea to fill the space left over by the menu.
+		 * This is somewhat futile since it will be done again once
+		 * menus are added to the menu bar.
+		 */
+		BRect remaining = Bounds();
+
+#ifdef FEAT_MENU
+		remaining.top += MenuHeight();
+		menuBar->ResizeTo(remaining.right, remaining.top);
+		gui.menu_height = (int) MenuHeight();
+#endif
+
+#ifdef FEAT_TOOLBAR
+		toolBar->MoveTo(remaining.left, remaining.top);
+		toolBar->ResizeTo(remaining.right, ToolbarHeight());
+		remaining.top += ToolbarHeight();
+		gui.toolbar_height = ToolbarHeight();
+#endif
+
+#ifdef FEAT_GUI_TABLINE
+		tabLine->MoveTo(remaining.left, remaining.top);
+		tabLine->ResizeTo(remaining.right + 1, TablineHeight());
+		remaining.top += TablineHeight();
+		gui.tabline_height = TablineHeight();
+#endif
+
+		textArea->ResizeTo(remaining.Width(), remaining.Height());
+		textArea->MoveTo(remaining.left, remaining.top);
+	}
+
+
+	Inherited::AllAttached();
+}
+
+	void
+VimFormView::FrameResized(float new_width, float new_height)
+{
+	struct VimResizeMsg sm;
+	int adjust_h, adjust_w;
+
+	new_width += 1;	    // adjust from width to number of pixels occupied
+	new_height += 1;
+
+	sm.width = (int) new_width;
+	sm.height = (int) new_height;
+	adjust_w = ((int)new_width - gui_get_base_width()) % gui.char_width;
+	adjust_h = ((int)new_height - gui_get_base_height()) % gui.char_height;
+
+	if (adjust_w > 0 || adjust_h > 0) {
+		sm.width  -= adjust_w;
+		sm.height -= adjust_h;
+	}
+
+	write_port(gui.vdcmp, VimMsg::Resize, &sm, sizeof(sm));
+	// calls gui_resize_shell(new_width, new_height);
+
+	return;
+
+	/*
+	 * The area below the vertical scrollbar is erased to the colour
+	 * set with SetViewColor() automatically, because we had set
+	 * B_WILL_DRAW. Resizing the window tight around the vertical
+	 * scroll bar also helps to avoid debris.
+	 */
+}
+
+/* ---------------- VimTextAreaView ---------------- */
+
+VimTextAreaView::VimTextAreaView(BRect frame):
+	BView(frame, "VimTextAreaView", B_FOLLOW_ALL_SIDES,
+#ifdef FEAT_MBYTE_IME
+		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_INPUT_METHOD_AWARE),
+#else
+		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE),
+#endif
+	mouseDragEventCount(0)
+{
+#ifdef FEAT_MBYTE_IME
+	IMData.messenger = NULL;
+	IMData.message = NULL;
+#endif
+	init(frame);
+}
+
+VimTextAreaView::~VimTextAreaView()
+{
+	gui.vimTextArea = NULL;
+}
+
+	void
+VimTextAreaView::init(BRect frame)
+{
+	/* set up global var for fast access */
+	gui.vimTextArea = this;
+
+	/*
+	 * Tell the app server not to erase the view: we will
+	 * fill it in completely by ourselves.
+	 * (Does this really work? Even if not, it won't harm either.)
+	 */
+	SetViewColor(B_TRANSPARENT_32_BIT);
+#define PEN_WIDTH   1
+	SetPenSize(PEN_WIDTH);
+}
+
+	void
+VimTextAreaView::Draw(BRect updateRect)
+{
+	/*
+	 * XXX Other ports call here:
+	 * out_flush();	     * make sure all output has been processed *
+	 * but we can't do that, since it involves too much information
+	 * that is owned by other threads...
+	 */
+
+	/*
+	 *  No need to use gui.vimWindow->Lock(): we are locked already.
+	 *  However, it would not hurt.
+	 */
+	rgb_color rgb = GUI_TO_RGB(gui.back_pixel);
+	SetLowColor(rgb);
+	FillRect(updateRect, B_SOLID_LOW);
+	gui_redraw((int) updateRect.left, (int) updateRect.top,
+			(int) (updateRect.Width() + PEN_WIDTH), (int) (updateRect.Height() + PEN_WIDTH));
+
+	/* Clear the border areas if needed */
+	SetLowColor(rgb);
+
+	if (updateRect.left < FILL_X(0))	// left border
+		FillRect(BRect(updateRect.left, updateRect.top,
+					FILL_X(0)-PEN_WIDTH, updateRect.bottom), B_SOLID_LOW);
+	if (updateRect.top < FILL_Y(0))	// top border
+		FillRect(BRect(updateRect.left, updateRect.top,
+					updateRect.right, FILL_Y(0)-PEN_WIDTH), B_SOLID_LOW);
+	if (updateRect.right >= FILL_X(Columns)) // right border
+		FillRect(BRect(FILL_X((int)Columns), updateRect.top,
+					updateRect.right, updateRect.bottom), B_SOLID_LOW);
+	if (updateRect.bottom >= FILL_Y(Rows))   // bottom border
+		FillRect(BRect(updateRect.left, FILL_Y((int)Rows),
+					updateRect.right, updateRect.bottom), B_SOLID_LOW);
+
+#ifdef FEAT_MBYTE_IME
+	DrawIMString();
+#endif
+}
+
+	void
+VimTextAreaView::KeyDown(const char *bytes, int32 numBytes)
+{
+	struct VimKeyMsg km;
+	char_u *dest = km.chars;
+
+	bool canHaveVimModifiers = false;
+
+	BMessage *msg = Window()->CurrentMessage();
+	assert(msg);
+	//msg->PrintToStream();
+
+	/*
+	 * Convert special keys to Vim codes.
+	 * I think it is better to do it in the window thread
+	 * so we use at least a little bit of the potential
+	 * of our 2 CPUs. Besides, due to the fantastic mapping
+	 * of special keys to UTF-8, we have quite some work to
+	 * do...
+	 * TODO: I'm not quite happy with detection of special
+	 * keys. Perhaps I should use scan codes after all...
+	 */
+	if (numBytes > 1) {
+		/* This cannot be a special key */
+		if (numBytes > KEY_MSG_BUFSIZ)
+			numBytes = KEY_MSG_BUFSIZ;	    // should never happen... ???
+		km.length = numBytes;
+		memcpy((char *)dest, bytes, numBytes);
+#ifdef FEAT_MBYTE
+		km.csi_escape = true;
+#endif
+	} else {
+		int32 scancode = 0;
+		msg->FindInt32("key", &scancode);
+
+		int32 beModifiers = 0;
+		msg->FindInt32("modifiers", &beModifiers);
+
+		char_u string[3];
+		int len = 0;
+		km.length = 0;
+
+		/*
+		 * For normal, printable ASCII characters, don't look them up
+		 * to check if they might be a special key. They aren't.
+		 */
+		assert(B_BACKSPACE <= 0x20);
+		assert(B_DELETE == 0x7F);
+		if (((char_u)bytes[0] <= 0x20 || (char_u)bytes[0] == 0x7F) &&
+				numBytes == 1) {
+			/*
+			 * Due to the great nature of Be's mapping of special keys,
+			 * viz. into the range of the control characters,
+			 * we can only be sure it is *really* a special key if
+			 * if it is special without using ctrl. So, only if ctrl is
+			 * used, we need to check it unmodified.
+			 */
+			if (beModifiers & B_CONTROL_KEY) {
+				int index = keyMap->normal_map[scancode];
+				int newNumBytes = keyMapChars[index];
+				char_u *newBytes = (char_u *)&keyMapChars[index + 1];
+
+				/*
+				 * Check if still special without the control key.
+				 * This is needed for BACKSPACE: that key does produce
+				 * different values with modifiers (DEL).
+				 * Otherwise we could simply have checked for equality.
+				 */
+				if (newNumBytes != 1 || (*newBytes > 0x20 &&
+							*newBytes != 0x7F )) {
+					goto notspecial;
+				}
+				bytes = (char *)newBytes;
+			}
+			canHaveVimModifiers = true;
+
+			uint16 beoskey;
+			int first, last;
+
+			/*
+			 * If numBytes == 0 that probably always indicates a special key.
+			 * (does not happen yet)
+			 */
+			if (numBytes == 0 || bytes[0] == B_FUNCTION_KEY) {
+				beoskey = F(scancode);
+				first = FIRST_FUNCTION_KEY;
+				last = NUM_SPECIAL_KEYS;
+			} else if (*bytes == '\n' && scancode == 0x47) {
+				/* remap the (non-keypad) ENTER key from \n to \r. */
+				string[0] = '\r';
+				len = 1;
+				first = last = 0;
+			} else {
+				beoskey = K(bytes[0]);
+				first = 0;
+				last = FIRST_FUNCTION_KEY;
+			}
+
+			for (int i = first; i < last; i++) {
+				if (special_keys[i].BeKeys == beoskey) {
+					string[0] = CSI;
+					string[1] = special_keys[i].vim_code0;
+					string[2] = special_keys[i].vim_code1;
+					len = 3;
+				}
+			}
+		}
+notspecial:
+		if (len == 0) {
+			string[0] = bytes[0];
+			len = 1;
+		}
+
+		/* Special keys (and a few others) may have modifiers */
+#if 0
+		if (len == 3 ||
+				bytes[0] == B_SPACE || bytes[0] == B_TAB ||
+				bytes[0] == B_RETURN || bytes[0] == '\r' ||
+				bytes[0] == B_ESCAPE)
+#else
+			if (canHaveVimModifiers)
+#endif
+			{
+				int modifiers;
+				modifiers = 0;
+				if (beModifiers & B_SHIFT_KEY)
+					modifiers |= MOD_MASK_SHIFT;
+				if (beModifiers & B_CONTROL_KEY)
+					modifiers |= MOD_MASK_CTRL;
+				if (beModifiers & B_OPTION_KEY)
+					modifiers |= MOD_MASK_ALT;
+
+				/*
+				 * For some keys a shift modifier is translated into another key
+				 * code.  Do we need to handle the case where len != 1 and
+				 * string[0] != CSI? (Not for BeOS, since len == 3 implies
+				 * string[0] == CSI...)
+				 */
+				int key;
+				if (string[0] == CSI && len == 3)
+					key = TO_SPECIAL(string[1], string[2]);
+				else
+					key = string[0];
+				key = simplify_key(key, &modifiers);
+				if (IS_SPECIAL(key))
+				{
+					string[0] = CSI;
+					string[1] = K_SECOND(key);
+					string[2] = K_THIRD(key);
+					len = 3;
+				}
+				else
+				{
+					string[0] = key;
+					len = 1;
+				}
+
+				if (modifiers)
+				{
+					*dest++ = CSI;
+					*dest++ = KS_MODIFIER;
+					*dest++ = modifiers;
+					km.length = 3;
+				}
+			}
+		memcpy((char *)dest, string, len);
+		km.length += len;
+#ifdef FEAT_MBYTE
+		km.csi_escape = false;
+#endif
+	}
+
+	write_port(gui.vdcmp, VimMsg::Key, &km, sizeof(km));
+
+	/*
+	 * blank out the pointer if necessary
+	 */
+	if (p_mh && !gui.pointer_hidden)
+	{
+		guiBlankMouse(true);
+		gui.pointer_hidden = TRUE;
+	}
+}
+void
+VimTextAreaView::guiSendMouseEvent(
+		int	    button,
+		int	    x,
+		int	    y,
+		int	    repeated_click,
+		int_u   modifiers)
+{
+	VimMouseMsg mm;
+
+	mm.button = button;
+	mm.x = x;
+	mm.y = y;
+	mm.repeated_click = repeated_click;
+	mm.modifiers = modifiers;
+
+	write_port(gui.vdcmp, VimMsg::Mouse, &mm, sizeof(mm));
+	// calls gui_send_mouse_event()
+
+	/*
+	 * if our pointer is currently hidden, then we should show it.
+	 */
+	if (gui.pointer_hidden)
+	{
+		guiBlankMouse(false);
+		gui.pointer_hidden = FALSE;
+	}
+}
+
+void
+VimTextAreaView::guiMouseMoved(
+		int	    x,
+		int	    y)
+{
+	VimMouseMovedMsg mm;
+
+	mm.x = x;
+	mm.y = y;
+
+	write_port(gui.vdcmp, VimMsg::MouseMoved, &mm, sizeof(mm));
+
+	if (gui.pointer_hidden)
+	{
+		guiBlankMouse(false);
+		gui.pointer_hidden = FALSE;
+	}
+}
+
+	void
+VimTextAreaView::guiBlankMouse(bool should_hide)
+{
+	if (should_hide) {
+		//gui.vimApp->HideCursor();
+		gui.vimApp->ObscureCursor();
+		/*
+		 * ObscureCursor() would even be easier, but then
+		 * Vim's idea of mouse visibility does not necessarily
+		 * correspond to reality.
+		 */
+	} else {
+		//gui.vimApp->ShowCursor();
+	}
+}
+
+	int_u
+VimTextAreaView::mouseModifiersToVim(int32 beModifiers)
+{
+	int_u vim_modifiers = 0x0;
+
+	if (beModifiers & B_SHIFT_KEY)
+		vim_modifiers |= MOUSE_SHIFT;
+	if (beModifiers & B_CONTROL_KEY)
+		vim_modifiers |= MOUSE_CTRL;
+	if (beModifiers & B_OPTION_KEY)	    /* Alt or Meta key */
+		vim_modifiers |= MOUSE_ALT;
+
+	return vim_modifiers;
+}
+
+	void
+VimTextAreaView::MouseDown(BPoint point)
+{
+	BMessage *m = Window()->CurrentMessage();
+	assert(m);
+
+	int32 buttons = 0;
+	m->FindInt32("buttons", &buttons);
+
+	int vimButton;
+
+	if (buttons & B_PRIMARY_MOUSE_BUTTON)
+		vimButton = MOUSE_LEFT;
+	else if (buttons & B_SECONDARY_MOUSE_BUTTON)
+		vimButton = MOUSE_RIGHT;
+	else if (buttons & B_TERTIARY_MOUSE_BUTTON)
+		vimButton = MOUSE_MIDDLE;
+	else
+		return;			/* Unknown button */
+
+	vimMouseButton = 1;		/* don't care which one */
+
+	/* Handle multiple clicks */
+	int32 clicks = 0;
+	m->FindInt32("clicks", &clicks);
+
+	int32 modifiers = 0;
+	m->FindInt32("modifiers", &modifiers);
+
+	vimMouseModifiers = mouseModifiersToVim(modifiers);
+
+	guiSendMouseEvent(vimButton, point.x, point.y,
+			clicks > 1 /* = repeated_click*/, vimMouseModifiers);
+}
+
+	void
+VimTextAreaView::MouseUp(BPoint point)
+{
+	vimMouseButton = 0;
+
+	BMessage *m = Window()->CurrentMessage();
+	assert(m);
+	//m->PrintToStream();
+
+	int32 modifiers = 0;
+	m->FindInt32("modifiers", &modifiers);
+
+	vimMouseModifiers = mouseModifiersToVim(modifiers);
+
+	guiSendMouseEvent(MOUSE_RELEASE, point.x, point.y,
+			0 /* = repeated_click*/, vimMouseModifiers);
+
+	Inherited::MouseUp(point);
+}
+
+	void
+VimTextAreaView::MouseMoved(BPoint point, uint32 transit, const BMessage *message)
+{
+	/*
+	 * if our pointer is currently hidden, then we should show it.
+	 */
+	if (gui.pointer_hidden)
+	{
+		guiBlankMouse(false);
+		gui.pointer_hidden = FALSE;
+	}
+
+	if (!vimMouseButton) {    /* could also check m->"buttons" */
+		guiMouseMoved(point.x, point.y);
+		return;
+	}
+
+	atomic_add(&mouseDragEventCount, 1);
+
+	/* Don't care much about "transit" */
+	guiSendMouseEvent(MOUSE_DRAG, point.x, point.y, 0, vimMouseModifiers);
+}
+
+	void
+VimTextAreaView::MessageReceived(BMessage *m)
+{
+	switch (m->what) {
+		case 'menu':
+			{
+				VimMenuMsg mm;
+				mm.guiMenu = NULL;	/* in case no pointer in msg */
+				m->FindPointer("VimMenu", (void **)&mm.guiMenu);
+				write_port(gui.vdcmp, VimMsg::Menu, &mm, sizeof(mm));
+			}
+			break;
+		case B_MOUSE_WHEEL_CHANGED:
+			{
+				VimScrollBar* scb = curwin->w_scrollbars[1].id;
+				float small=0, big=0, dy=0;
+				m->FindFloat("be:wheel_delta_y", &dy);
+				scb->GetSteps(&small, &big);
+				scb->SetValue(scb->Value()+small*dy*3);
+				scb->ValueChanged(scb->Value());
+#if 0
+				scb = curwin->w_scrollbars[0].id;
+				scb->GetSteps(&small, &big);
+				scb->SetValue(scb->Value()+small*dy);
+				scb->ValueChanged(scb->Value());
+#endif
+			}
+			break;
+#ifdef FEAT_MBYTE_IME
+		case B_INPUT_METHOD_EVENT:
+			{
+				int32 opcode;
+				m->FindInt32("be:opcode", &opcode);
+				switch(opcode)
+				{
+					case B_INPUT_METHOD_STARTED:
+						if(!IMData.messenger) delete IMData.messenger;
+						IMData.messenger = new BMessenger();
+						m->FindMessenger("be:reply_to", IMData.messenger);
+						break;
+					case B_INPUT_METHOD_CHANGED:
+						{
+							BString str;
+							bool confirmed;
+							if(IMData.message) *(IMData.message) = *m;
+							else               IMData.message = new BMessage(*m);
+							DrawIMString();
+							m->FindBool("be:confirmed", &confirmed);
+							if (confirmed)
+							{
+								m->FindString("be:string", &str);
+								char_u *chars = (char_u*)str.String();
+								struct VimKeyMsg km;
+								km.csi_escape = true;
+								int clen;
+								int i = 0;
+								while (i < str.Length())
+								{
+									clen = utf_ptr2len(chars+i);
+									memcpy(km.chars, chars+i, clen);
+									km.length = clen;
+									write_port(gui.vdcmp, VimMsg::Key, &km, sizeof(km));
+									i += clen;
+								}
+							}
+						}
+						break;
+					case B_INPUT_METHOD_LOCATION_REQUEST:
+						{
+							BMessage msg(B_INPUT_METHOD_EVENT);
+							msg.AddInt32("be:opcode", B_INPUT_METHOD_LOCATION_REQUEST);
+							msg.AddPoint("be:location_reply", IMData.location);
+							msg.AddFloat("be:height_reply", FILL_Y(1));
+							IMData.messenger->SendMessage(&msg);
+						}
+						break;
+					case B_INPUT_METHOD_STOPPED:
+						delete IMData.messenger;
+						delete IMData.message;
+						IMData.messenger = NULL;
+						IMData.message = NULL;
+						break;
+				}
+			}
+			//TODO: sz: break here???
+#endif
+		default:
+			if (m->WasDropped()) {
+				BWindow *w = Window();
+				w->DetachCurrentMessage();
+				w->Minimize(false);
+				VimApp::SendRefs(m, (modifiers() & B_SHIFT_KEY) != 0);
+			} else {
+				Inherited::MessageReceived(m);
+			}
+			break;
+	}
+}
+
+	int
+VimTextAreaView::mchInitFont(char_u *name)
+{
+	VimFont *newFont = (VimFont *)gui_mch_get_font(name, 1);
+	if(newFont != NOFONT) {
+		gui.norm_font = (GuiFont)newFont;
+		gui_mch_set_font((GuiFont)newFont);
+		if (name && STRCMP(name, "*") != 0)
+			hl_set_font_name(name);
+
+		SetDrawingMode(B_OP_COPY);
+
+		/*
+		 * Try to load other fonts for bold, italic, and bold-italic.
+		 * We should also try to work out what font to use for these when they are
+		 * not specified by X resources, but we don't yet.
+		 */
+		return OK;
+	}
+	return FAIL;
+}
+
+	void
+VimTextAreaView::mchDrawString(int row, int col, char_u *s, int len, int flags)
+{
+	/*
+	 * First we must erase the area, because DrawString won't do
+	 * that for us. XXX Most of the time this is a waste of effort
+	 * since the bachground has been erased already... DRAW_TRANSP
+	 * should be set when appropriate!!!
+	 * (Rectangles include the bottom and right edge)
+	 */
+	if (!(flags & DRAW_TRANSP)) {
+		int cells;
+#ifdef FEAT_MBYTE
+		cells = 0;
+		for(int i=0; i<len; i++) {
+			int cn = utf_ptr2cells((char_u *)(s+i));
+			if(cn<4) cells += cn;
+		}
+#else
+		cells = len;
+#endif
+
+		BRect r(FILL_X(col), FILL_Y(row),
+				FILL_X(col + cells) - PEN_WIDTH, FILL_Y(row + 1) - PEN_WIDTH);
+		FillRect(r, B_SOLID_LOW);
+	}
+
+	BFont font;
+	this->GetFont(&font);
+	if(!font.IsFixed())
+	{
+		char* p = (char*)s;
+		int32 clen, lastpos = 0;
+		BPoint where;
+		int cells;
+		while((p - (char*)s) < len) {
+#ifdef FEAT_MBYTE
+			clen = utf_ptr2len((u_char*)p);
+#else
+			clen = 1;
+#endif
+			where.Set(TEXT_X(col+lastpos), TEXT_Y(row));
+			DrawString(p, clen, where);
+			if (flags & DRAW_BOLD) {
+				where.x += 1.0;
+				SetDrawingMode(B_OP_BLEND);
+				DrawString(p, clen, where);
+				SetDrawingMode(B_OP_COPY);
+			}
+#ifdef FEAT_MBYTE
+			cells = utf_ptr2cells((char_u *)p);
+			if(cells<4) lastpos += cells;
+			else        lastpos++;
+#else
+			lastpos++;
+#endif
+			p += clen;
+		}
+	}
+	else
+	{
+		BPoint where(TEXT_X(col), TEXT_Y(row));
+		DrawString((char*)s, len, where);
+		if (flags & DRAW_BOLD) {
+			where.x += 1.0;
+			SetDrawingMode(B_OP_BLEND);
+			DrawString((char*)s, len, where);
+			SetDrawingMode(B_OP_COPY);
+		}
+	}
+
+	if (flags & DRAW_UNDERL) {
+		int cells;
+#ifdef FEAT_MBYTE
+		cells = 0;
+		for(int i=0; i<len; i++) {
+			int cn = utf_ptr2cells((char_u *)(s+i));
+			if(cn<4) cells += cn;
+		}
+#else
+		cells = len;
+#endif
+
+		BPoint start(FILL_X(col), FILL_Y(row + 1) - PEN_WIDTH);
+		BPoint end(FILL_X(col + cells) - PEN_WIDTH, start.y);
+
+		StrokeLine(start, end);
+	}
+}
+
+void
+VimTextAreaView::mchClearBlock(
+		int		row1,
+		int		col1,
+		int		row2,
+		int		col2)
+{
+	BRect r(FILL_X(col1), FILL_Y(row1),
+			FILL_X(col2 + 1) - PEN_WIDTH, FILL_Y(row2 + 1) - PEN_WIDTH);
+	gui_mch_set_bg_color(gui.back_pixel);
+	FillRect(r, B_SOLID_LOW);
+}
+
+	void
+VimTextAreaView::mchClearAll()
+{
+	gui_mch_set_bg_color(gui.back_pixel);
+	FillRect(Bounds(), B_SOLID_LOW);
+}
+
+/*
+ * mchDeleteLines() Lock()s the window by itself.
+ */
+	void
+VimTextAreaView::mchDeleteLines(int row, int num_lines)
+{
+	BRect source, dest;
+	source.left = FILL_X(gui.scroll_region_left);
+	source.top = FILL_Y(row + num_lines);
+	source.right = FILL_X(gui.scroll_region_right + 1) - PEN_WIDTH;
+	source.bottom = FILL_Y(gui.scroll_region_bot + 1) - PEN_WIDTH;
+
+	dest.left = FILL_X(gui.scroll_region_left);
+	dest.top = FILL_Y(row);
+	dest.right = FILL_X(gui.scroll_region_right + 1) - PEN_WIDTH;
+	dest.bottom = FILL_Y(gui.scroll_region_bot - num_lines + 1) - PEN_WIDTH;
+
+	if (gui.vimWindow->Lock()) {
+		/* Clear one column more for when bold has spilled over */
+		CopyBits(source, dest);
+		gui_clear_block(gui.scroll_region_bot - num_lines + 1,
+				gui.scroll_region_left,
+				gui.scroll_region_bot, gui.scroll_region_right);
+
+
+		gui.vimWindow->Unlock();
+		/*
+		 * The Draw() callback will be called now if some of the source
+		 * bits were not in the visible region.
+		 */
+	}
+	//gui_x11_check_copy_area();
+	// }
+}
+
+/*
+ * mchInsertLines() Lock()s the window by itself.
+ */
+	void
+VimTextAreaView::mchInsertLines(int row, int num_lines)
+{
+	BRect source, dest;
+
+	/* XXX Attempt at a hack: */
+	gui.vimWindow->UpdateIfNeeded();
+	source.left = FILL_X(gui.scroll_region_left);
+	source.top = FILL_Y(row);
+	source.right = FILL_X(gui.scroll_region_right + 1) - PEN_WIDTH;
+	source.bottom = FILL_Y(gui.scroll_region_bot - num_lines + 1) - PEN_WIDTH;
+
+	dest.left = FILL_X(gui.scroll_region_left);
+	dest.top = FILL_Y(row + num_lines);
+	dest.right = FILL_X(gui.scroll_region_right + 1) - PEN_WIDTH;
+	dest.bottom = FILL_Y(gui.scroll_region_bot + 1) - PEN_WIDTH;
+
+	if (gui.vimWindow->Lock()) {
+		/* Clear one column more for when bold has spilled over */
+		CopyBits(source, dest);
+		gui_clear_block(row, gui.scroll_region_left,
+				row + num_lines - 1, gui.scroll_region_right);
+
+		gui.vimWindow->Unlock();
+		/*
+		 * The Draw() callback will be called now if some of the source
+		 * bits were not in the visible region.
+		 * However, if we scroll too fast it can't keep up and the
+		 * update region gets messed up. This seems to be because copying
+		 * un-Draw()n bits does not generate Draw() calls for the copy...
+		 * I moved the hack to before the CopyBits() to reduce the
+		 * amount of additional waiting needed.
+		 */
+
+		//gui_x11_check_copy_area();
+
+	}
+}
+
+#ifdef FEAT_MBYTE_IME
+/*
+ * DrawIMString draws string with IMData.message.
+ */
+void VimTextAreaView::DrawIMString(void)
+{
+	static const rgb_color r_highlight = {255, 152, 152, 255},
+				 b_highlight = {152, 203, 255, 255};
+	BString str;
+	const char* s;
+	int len;
+	BMessage* msg = IMData.message;
+	if (!msg)
+		return;
+	gui_redraw_block(IMData.row, 0,
+			IMData.row + IMData.count, curwin->w_width, GUI_MON_NOCLEAR);
+	bool confirmed = false;
+	msg->FindBool("be:confirmed", &confirmed);
+	if (confirmed)
+		return;
+	rgb_color hcolor = HighColor(), lcolor = LowColor();
+	msg->FindString("be:string", &str);
+	s = str.String();
+	len = str.Length();
+	SetHighColor(0, 0, 0);
+	IMData.row = gui.row;
+	IMData.col = gui.col;
+	int32 sel_start = 0, sel_end = 0;
+	msg->FindInt32("be:selection", 0, &sel_start);
+	msg->FindInt32("be:selection", 1, &sel_end);
+	int clen, cn;
+	BPoint pos(IMData.col, 0);
+	BRect r;
+	BPoint where;
+	IMData.location = ConvertToScreen(
+			BPoint(FILL_X(pos.x), FILL_Y(IMData.row + pos.y)));
+	for (int i=0; i<len; i+=clen)
+	{
+		cn = utf_ptr2cells((char_u *)(s+i));
+		clen = utf_ptr2len((char_u *)(s+i));
+		if (pos.x + cn > curwin->w_width)
+		{
+			pos.y++;
+			pos.x = 0;
+		}
+		if (sel_start<=i && i<sel_end)
+		{
+			SetLowColor(r_highlight);
+			IMData.location = ConvertToScreen(
+					BPoint(FILL_X(pos.x), FILL_Y(IMData.row + pos.y)));
+		}
+		else
+		{
+			SetLowColor(b_highlight);
+		}
+		r.Set(FILL_X(pos.x), FILL_Y(IMData.row + pos.y),
+				FILL_X(pos.x + cn) - PEN_WIDTH,
+				FILL_Y(IMData.row + pos.y + 1) - PEN_WIDTH);
+		FillRect(r, B_SOLID_LOW);
+		where.Set(TEXT_X(pos.x), TEXT_Y(IMData.row + pos.y));
+		DrawString((s+i), clen, where);
+		pos.x += cn;
+	}
+	IMData.count = (int)pos.y;
+
+	SetHighColor(hcolor);
+	SetLowColor(lcolor);
+}
+#endif
+/* ---------------- VimScrollBar ---------------- */
+
+/* BUG: XXX
+ * It seems that BScrollBar determine their direction not from
+ * "posture" but from if they are "tall" or "wide" in shape...
+ *
+ * Also, place them out of sight, because Vim enables them before
+ * they are positioned.
+ */
+VimScrollBar::VimScrollBar(scrollbar_T *g, orientation posture):
+	BScrollBar(posture == B_HORIZONTAL ?  BRect(-100,-100,-10,-90) :
+			BRect(-100,-100,-90,-10),
+			"vim scrollbar", (BView *)NULL,
+			0.0, 10.0, posture),
+	ignoreValue(-1),
+	scrollEventCount(0)
+{
+	gsb = g;
+	SetResizingMode(B_FOLLOW_NONE);
+}
+
+VimScrollBar::~VimScrollBar()
+{
+}
+
+	void
+VimScrollBar::ValueChanged(float newValue)
+{
+	if (ignoreValue >= 0.0 && newValue == ignoreValue) {
+		ignoreValue = -1;
+		return;
+	}
+	ignoreValue = -1;
+	/*
+	 * We want to throttle the amount of scroll messages generated.
+	 * Normally I presume you won't get a new message before we've
+	 * handled the previous one, but because we're passing them on this
+	 * happens very quickly. So instead we keep a counter of how many
+	 * scroll events there are (or will be) in the VDCMP, and the
+	 * throttling happens at the receiving end.
+	 */
+	atomic_add(&scrollEventCount, 1);
+
+	struct VimScrollBarMsg sm;
+
+	sm.sb = this;
+	sm.value = (long) newValue;
+	sm.stillDragging = TRUE;
+
+	write_port(gui.vdcmp, VimMsg::ScrollBar, &sm, sizeof(sm));
+
+	// calls gui_drag_scrollbar(sb, newValue, TRUE);
+}
+
+/*
+ * When the mouse goes up, report that scrolling has stopped.
+ * MouseUp() is NOT called when the mouse-up occurs outside
+ * the window, even though the thumb does move while the mouse
+ * is outside... This has some funny effects... XXX
+ * So we do special processing when the window de/activates.
+ */
+	void
+VimScrollBar::MouseUp(BPoint where)
+{
+	//BMessage *m = Window()->CurrentMessage();
+	//m->PrintToStream();
+
+	atomic_add(&scrollEventCount, 1);
+
+	struct VimScrollBarMsg sm;
+
+	sm.sb = this;
+	sm.value = (long) Value();
+	sm.stillDragging = FALSE;
+
+	write_port(gui.vdcmp, VimMsg::ScrollBar, &sm, sizeof(sm));
+
+	// calls gui_drag_scrollbar(sb, newValue, FALSE);
+
+	Inherited::MouseUp(where);
+}
+
+	void
+VimScrollBar::SetValue(float newValue)
+{
+	if (newValue == Value())
+		return;
+
+	ignoreValue = newValue;
+	Inherited::SetValue(newValue);
+}
+
+/* ---------------- VimFont ---------------- */
+
+VimFont::VimFont(): BFont()
+{
+	init();
+}
+
+VimFont::VimFont(const VimFont *rhs): BFont(rhs)
+{
+	init();
+}
+
+VimFont::VimFont(const BFont *rhs): BFont(rhs)
+{
+	init();
+}
+
+VimFont::VimFont(const VimFont &rhs): BFont(rhs)
+{
+	init();
+}
+
+VimFont::~VimFont()
+{
+}
+
+	void
+VimFont::init()
+{
+	next = NULL;
+	refcount = 1;
+	name = NULL;
+}
+
+/* ---------------- VimDialog ---------------- */
+
+#if defined(FEAT_GUI_DIALOG)
+
+const unsigned int	kVimDialogButtonMsg = 'VMDB';
+const unsigned int	kVimDialogIconStripeWidth = 30;
+const unsigned int	kVimDialogButtonsSpacingX = 9;
+const unsigned int	kVimDialogButtonsSpacingY = 4;
+const unsigned int	kVimDialogSpacingX = 6;
+const unsigned int	kVimDialogSpacingY = 10;
+const unsigned int	kVimDialogMinimalWidth  = 310;
+const unsigned int	kVimDialogMinimalHeight = 75;
+const BRect			kDefaultRect =
+BRect(0, 0, kVimDialogMinimalWidth, kVimDialogMinimalHeight);
+
+VimDialog::VimDialog(int type, const char *title, const char *message,
+		const char *buttons, int dfltbutton, const char *textfield, int ex_cmd)
+: BWindow(kDefaultRect, title, B_TITLED_WINDOW_LOOK, B_MODAL_APP_WINDOW_FEEL,
+		B_NOT_CLOSABLE | B_NOT_RESIZABLE |
+		B_NOT_ZOOMABLE | B_NOT_MINIMIZABLE | B_ASYNCHRONOUS_CONTROLS)
+	, fDialogSem(-1)
+	, fDialogValue(dfltbutton)
+	, fMessageView(NULL)
+	, fInputControl(NULL)
+	, fInputValue(textfield)
+{
+	// master view
+	VimDialog::View* view = new VimDialog::View(Bounds());
+	if(view == NULL)
+		return;
+
+	if(title == NULL)
+		SetTitle("Vim " VIM_VERSION_MEDIUM);
+
+	AddChild(view);
+
+	// icon
+	view->InitIcon(type);
+
+	// buttons
+	int32 which = 1;
+	float maxButtonWidth  = 0;
+	float maxButtonHeight = 0;
+	float buttonsWidth    = 0;
+	float buttonsHeight   = 0;
+	BString strButtons(buttons);
+	strButtons.RemoveAll("&");
+	do {
+		int32 end = strButtons.FindFirst('\n');
+		if(end != B_ERROR)
+			strButtons.SetByteAt(end, '\0');
+
+		BButton *button = _CreateButton(which++, strButtons.String());
+		view->AddChild(button);
+		fButtonsList.AddItem(button);
+
+		maxButtonWidth  = max_c(maxButtonWidth,  button->Bounds().Width());
+		maxButtonHeight = max_c(maxButtonHeight, button->Bounds().Height());
+		buttonsWidth   += button->Bounds().Width();
+		buttonsHeight  += button->Bounds().Height();
+
+		if(end == B_ERROR)
+			break;
+
+		strButtons.Remove(0, end + 1);
+	} while(true);
+
+	int32 buttonsCount = fButtonsList.CountItems();
+	buttonsWidth      += kVimDialogButtonsSpacingX * (buttonsCount - 1);
+	buttonsHeight     += kVimDialogButtonsSpacingY * (buttonsCount - 1);
+	float dialogWidth  = buttonsWidth + kVimDialogIconStripeWidth +
+		kVimDialogSpacingX * 2;
+	float dialogHeight = maxButtonHeight + kVimDialogSpacingY * 3;
+
+	/* Check 'v' flag in 'guioptions': vertical button placement. */
+	bool vertical = (vim_strchr(p_go, GO_VERTICAL) != NULL) ||
+		dialogWidth >= gui.vimWindow->Bounds().Width();
+	if(vertical) {
+		dialogWidth  -= buttonsWidth;
+		dialogWidth  += maxButtonWidth;
+		dialogHeight -= maxButtonHeight;
+		dialogHeight += buttonsHeight;
+	}
+
+	dialogWidth  = max_c(dialogWidth,  kVimDialogMinimalWidth);
+
+	// message view
+	BRect rect(0, 0, dialogWidth, 0);
+	rect.left  += kVimDialogIconStripeWidth + 16 + kVimDialogSpacingX;
+	rect.top   += kVimDialogSpacingY;
+	rect.right -= kVimDialogSpacingX;
+	rect.bottom = rect.top;
+	fMessageView = new BTextView(rect, "_tv_", rect.OffsetByCopy(B_ORIGIN),
+			B_FOLLOW_LEFT | B_FOLLOW_TOP, B_WILL_DRAW);
+
+	fMessageView->SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));
+	rgb_color textColor = ui_color(B_PANEL_TEXT_COLOR);
+	fMessageView->SetFontAndColor(be_plain_font, B_FONT_ALL, &textColor);
+	fMessageView->SetText(message);
+	fMessageView->MakeEditable(false);
+	fMessageView->MakeSelectable(false);
+	fMessageView->SetWordWrap(true);
+	AddChild(fMessageView);
+
+	float messageHeight = fMessageView->TextHeight(0, fMessageView->CountLines());
+	fMessageView->ResizeBy(0, messageHeight);
+	fMessageView->SetTextRect(BRect(0, 0, rect.Width(), messageHeight));
+
+	dialogHeight += messageHeight;
+
+	// input view
+	if(fInputValue != NULL) {
+		rect.top     =
+			rect.bottom += messageHeight + kVimDialogSpacingY;
+		fInputControl = new BTextControl(rect, "_iv_", NULL, fInputValue, NULL,
+				B_FOLLOW_LEFT | B_FOLLOW_TOP, B_WILL_DRAW | B_NAVIGABLE |  B_PULSE_NEEDED);
+		fInputControl->TextView()->SetText(fInputValue);
+		fInputControl->TextView()->SetWordWrap(false);
+		AddChild(fInputControl);
+
+		float width = 0.f, height = 0.f;
+		fInputControl->GetPreferredSize(&width, &height);
+		fInputControl->MakeFocus(true);
+
+		dialogHeight += height + kVimDialogSpacingY * 1.5;
+	}
+
+	dialogHeight = max_c(dialogHeight, kVimDialogMinimalHeight);
+
+	ResizeTo(dialogWidth, dialogHeight);
+	MoveTo((gui.vimWindow->Bounds().Width() - dialogWidth) / 2,
+			(gui.vimWindow->Bounds().Height() - dialogHeight) / 2);
+
+	// adjust layout of buttons
+	float buttonWidth = max_c(maxButtonWidth, rect.Width() * 0.66);
+	BPoint origin(dialogWidth, dialogHeight);
+	origin.x -= kVimDialogSpacingX + (vertical ? buttonWidth : buttonsWidth);
+	origin.y -= kVimDialogSpacingY + (vertical ? buttonsHeight  : maxButtonHeight);
+
+	for(int32 i = 0 ; i < buttonsCount; i++) {
+		BButton *button = (BButton*)fButtonsList.ItemAt(i);
+		button->MoveTo(origin);
+		if(vertical) {
+			origin.y += button->Frame().Height() + kVimDialogButtonsSpacingY;
+			button->ResizeTo(buttonWidth, button->Frame().Height());
+		} else
+			origin.x += button->Frame().Width() + kVimDialogButtonsSpacingX;
+
+		if(dfltbutton == i + 1) {
+			button->MakeDefault(true);
+			button->MakeFocus(fInputControl == NULL);
+		}
+	}
+}
+
+VimDialog::~VimDialog()
+{
+	if(fDialogSem > B_OK)
+		delete_sem(fDialogSem);
+}
+
+	int
+VimDialog::Go()
+{
+	fDialogSem = create_sem(0, "VimDialogSem");
+	if(fDialogSem < B_OK) {
+		Quit();
+		return fDialogValue;
+	}
+
+	Show();
+
+	while(acquire_sem(fDialogSem) == B_INTERRUPTED);
+
+	int retValue = fDialogValue;
+	if(fInputValue != NULL)
+		vim_strncpy((char_u*)fInputValue, (char_u*)fInputControl->Text(), IOSIZE - 1);
+
+	if(Lock())
+		Quit();
+
+	return retValue;
+}
+
+void VimDialog::MessageReceived(BMessage *msg)
+{
+	int32 which = 0;
+	if(msg->what != kVimDialogButtonMsg ||
+			msg->FindInt32("which", &which) != B_OK)
+		return BWindow::MessageReceived(msg);
+
+	fDialogValue = which;
+	delete_sem(fDialogSem);
+	fDialogSem = -1;
+}
+
+BButton* VimDialog::_CreateButton(int32 which, const char* label)
+{
+	BMessage *message = new BMessage(kVimDialogButtonMsg);
+	message->AddInt32("which", which);
+
+	BRect rect(0, 0, 0, 0);
+	BString name;
+	name << "_b" << which << "_";
+
+	BButton* button = new BButton(rect, name.String(), label, message,
+			B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);
+
+	float width = 0.f, height = 0.f;
+	button->GetPreferredSize(&width, &height);
+	button->ResizeTo(width, height);
+
+	return button;
+}
+
+VimDialog::View::View(BRect frame)
+	:	BView(frame, "VimDialogView", B_FOLLOW_ALL_SIDES, B_WILL_DRAW),
+	fIconBitmap(NULL)
+{
+	SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));
+}
+
+VimDialog::View::~View()
+{
+	delete fIconBitmap;
+}
+
+void VimDialog::View::Draw(BRect updateRect)
+{
+	BRect stripeRect = Bounds();
+	stripeRect.right = kVimDialogIconStripeWidth;
+	SetHighColor(tint_color(ViewColor(), B_DARKEN_1_TINT));
+	FillRect(stripeRect);
+
+	if(fIconBitmap == NULL)
+		return;
+
+	SetDrawingMode(B_OP_ALPHA);
+	SetBlendingMode(B_PIXEL_ALPHA, B_ALPHA_OVERLAY);
+	DrawBitmapAsync(fIconBitmap, BPoint(18, 6));
+}
+
+void VimDialog::View::InitIcon(int32 type)
+{
+	if(type == VIM_GENERIC)
+		return;
+
+	BPath path;
+	status_t status = find_directory(B_BEOS_SERVERS_DIRECTORY, &path);
+	if(status != B_OK) {
+		fprintf(stderr, "Cannot retrieve app info:%s\n", strerror(status));
+		return;
+	}
+
+	path.Append("app_server");
+
+	BFile file(path.Path(), O_RDONLY);
+	if(file.InitCheck() != B_OK) {
+		fprintf(stderr, "App file assignment failed:%s\n",
+				strerror(file.InitCheck()));
+		return;
+	}
+
+	BResources resources(&file);
+	if(resources.InitCheck() != B_OK) {
+		fprintf(stderr, "App server resources assignment failed:%s\n",
+				strerror(resources.InitCheck()));
+		return;
+	}
+
+	const char *name = "";
+	switch(type) {
+		case VIM_ERROR:		name = "stop"; break;
+		case VIM_WARNING:	name = "warn"; break;
+		case VIM_INFO:		name = "info"; break;
+		case VIM_QUESTION:	name = "idea"; break;
+		default: return;
+	}
+
+	int32 iconSize = 32;
+	fIconBitmap = new BBitmap(BRect(0, 0, iconSize - 1, iconSize - 1), 0, B_RGBA32);
+	if(fIconBitmap == NULL || fIconBitmap->InitCheck() != B_OK) {
+		fprintf(stderr, "Icon bitmap allocation failed:%s\n",
+				(fIconBitmap == NULL) ? "null" : strerror(fIconBitmap->InitCheck()));
+		return;
+	}
+
+	size_t size = 0;
+	const uint8* iconData = NULL;
+	// try vector icon first?
+	iconData = (const uint8*)resources.LoadResource(B_VECTOR_ICON_TYPE, name, &size);
+	if(iconData != NULL && BIconUtils::GetVectorIcon(iconData, size, fIconBitmap) == B_OK)
+		return;
+
+	// try bitmap icon now
+	iconData = (const uint8*)resources.LoadResource(B_LARGE_ICON_TYPE, name, &size);
+	if(iconData == NULL) {
+		fprintf(stderr, "Bitmap icon resource not found\n");
+		delete fIconBitmap;
+		fIconBitmap = NULL;
+		return;
+	}
+
+	if(fIconBitmap->ColorSpace() != B_CMAP8)
+		BIconUtils::ConvertFromCMAP8(iconData, iconSize, iconSize, iconSize, fIconBitmap);
+}
+
+const unsigned int	kVimDialogOKButtonMsg = 'FDOK';
+const unsigned int	kVimDialogCancelButtonMsg = 'FDCN';
+const unsigned int	kVimDialogSizeInputMsg = 'SICH';
+const unsigned int	kVimDialogFamilySelectMsg = 'MSFM';
+const unsigned int	kVimDialogStyleSelectMsg = 'MSST';
+const unsigned int	kVimDialogSizeSelectMsg = 'MSSZ';
+
+VimSelectFontDialog::VimSelectFontDialog(font_family* family, font_style* style, float* size)
+: BWindow(kDefaultRect, "Font Selection", B_TITLED_WINDOW_LOOK, B_MODAL_APP_WINDOW_FEEL,
+		B_NOT_CLOSABLE | B_NOT_RESIZABLE |
+		B_NOT_ZOOMABLE | B_NOT_MINIMIZABLE | B_ASYNCHRONOUS_CONTROLS)
+	, fStatus(B_NO_INIT)
+	, fDialogSem(-1)
+	, fDialogValue(false)
+	, fFamily(family)
+	, fStyle(style)
+	, fSize(size)
+	, fFontSize(*size)
+	, fPreview(0)
+	, fFamiliesList(0)
+	, fStylesList(0)
+	, fSizesList(0)
+	, fSizesInput(0)
+{
+	strncpy(fFontFamily, *family, B_FONT_FAMILY_LENGTH);
+	strncpy(fFontStyle, *style, B_FONT_STYLE_LENGTH);
+
+	// "client" area view
+	BBox *clientBox = new BBox(Bounds(), B_EMPTY_STRING, B_FOLLOW_ALL_SIDES,
+					B_WILL_DRAW | B_FRAME_EVENTS | B_NAVIGABLE_JUMP | B_PULSE_NEEDED,
+					B_PLAIN_BORDER);
+	AddChild(clientBox);
+
+	// client view
+	BRect RC = clientBox->Bounds();
+	RC.InsetBy(kVimDialogSpacingX, kVimDialogSpacingY);
+	BRect rc(RC.LeftTop(), RC.LeftTop());
+
+	// at first create all controls
+	fPreview = new BStringView(rc, "preview", "DejaVu Sans Mono");
+	clientBox->AddChild(fPreview);
+
+	BBox* boxDivider = new BBox(rc, B_EMPTY_STRING,
+			B_FOLLOW_NONE, B_WILL_DRAW, B_FANCY_BORDER);
+	clientBox->AddChild(boxDivider);
+
+	BStringView *labelFamily = new BStringView(rc, "labelFamily", "Family:");
+	clientBox->AddChild(labelFamily);
+	labelFamily->ResizeToPreferred();
+
+	BStringView *labelStyle = new BStringView(rc, "labelStyle", "Style:");
+	clientBox->AddChild(labelStyle);
+	labelStyle->ResizeToPreferred();
+
+	BStringView *labelSize = new BStringView(rc, "labelSize", "Size:");
+	clientBox->AddChild(labelSize);
+	labelSize->ResizeToPreferred();
+
+	fFamiliesList = new BListView(rc, "listFamily",
+			B_SINGLE_SELECTION_LIST, B_FOLLOW_ALL_SIDES);
+	BScrollView *scrollFamilies = new BScrollView("scrollFamily",
+			fFamiliesList, B_FOLLOW_LEFT_RIGHT, 0, false, true);
+	clientBox->AddChild(scrollFamilies);
+
+	fStylesList= new BListView(rc, "listStyles",
+			B_SINGLE_SELECTION_LIST, B_FOLLOW_ALL_SIDES);
+	BScrollView *scrollStyles = new BScrollView("scrollStyle",
+			fStylesList, B_FOLLOW_LEFT_RIGHT, 0, false, true);
+	clientBox->AddChild(scrollStyles);
+
+	fSizesInput = new BTextControl(rc, "inputSize", NULL, "???",
+			new BMessage(kVimDialogSizeInputMsg));
+	clientBox->AddChild(fSizesInput);
+	fSizesInput->ResizeToPreferred();
+
+	fSizesList = new BListView(rc, "listSizes",
+			B_SINGLE_SELECTION_LIST, B_FOLLOW_ALL_SIDES);
+	BScrollView *scrollSizes = new BScrollView("scrollSize",
+			fSizesList, B_FOLLOW_LEFT_RIGHT, 0, false, true);
+	clientBox->AddChild(scrollSizes);
+
+	BButton *buttonOK = new BButton(rc, "buttonOK", "OK",
+						new BMessage(kVimDialogOKButtonMsg));
+	clientBox->AddChild(buttonOK);
+	buttonOK->ResizeToPreferred();
+
+	BButton *buttonCancel = new BButton(rc, "buttonCancel", "Cancel",
+						new BMessage(kVimDialogCancelButtonMsg));
+	clientBox->AddChild(buttonCancel);
+	buttonCancel->ResizeToPreferred();
+
+	// layout controls
+	float lineHeight = labelFamily->Bounds().Height();
+	float previewHeight = lineHeight * 3;
+	float offsetYLabels = previewHeight + kVimDialogSpacingY;
+	float offsetYLists = offsetYLabels + lineHeight + kVimDialogSpacingY / 2;
+	float offsetYSizes = offsetYLists + fSizesInput->Bounds().Height() + kVimDialogSpacingY / 2;
+	float listsHeight = lineHeight * 9;
+	float offsetYButtons = offsetYLists + listsHeight +  kVimDialogSpacingY;
+	float maxControlsHeight = offsetYButtons + buttonOK->Bounds().Height();
+	float familiesWidth = labelFamily->Bounds().Width() * 5;
+	float offsetXStyles = familiesWidth + kVimDialogSpacingX;
+	float stylesWidth = labelStyle->Bounds().Width() * 4;
+	float offsetXSizes = offsetXStyles + stylesWidth + kVimDialogSpacingX;
+	float sizesWidth = labelSize->Bounds().Width() * 2;
+	float maxControlsWidth = offsetXSizes + sizesWidth;
+
+	ResizeTo(maxControlsWidth + kVimDialogSpacingX * 2,
+		maxControlsHeight + kVimDialogSpacingY * 2);
+
+	BRect rcVim = gui.vimWindow->Frame();
+	MoveTo(rcVim.left + (rcVim.Width() - Frame().Width()) / 2,
+			rcVim.top + (rcVim.Height() - Frame().Height()) / 2);
+
+	fPreview->ResizeTo(maxControlsWidth, previewHeight);
+	fPreview->SetAlignment(B_ALIGN_CENTER);
+
+	boxDivider->MoveBy(0.f, previewHeight + kVimDialogSpacingY / 2);
+	boxDivider->ResizeTo(maxControlsWidth, 1.f);
+
+	labelFamily->MoveBy(0.f, offsetYLabels);
+	labelStyle->MoveBy(offsetXStyles, offsetYLabels);
+	labelSize->MoveBy(offsetXSizes, offsetYLabels);
+
+	// text control alignment issues
+	float insetX = fSizesInput->TextView()->Bounds().Width() - fSizesInput->Bounds().Width();
+	float insetY = fSizesInput->TextView()->Bounds().Width() - fSizesInput->Bounds().Width();
+
+	scrollFamilies->MoveBy(0.f, offsetYLists);
+	scrollStyles->MoveBy(offsetXStyles, offsetYLists);
+	fSizesInput->MoveBy(offsetXSizes + insetX / 2, offsetYLists + insetY / 2);
+	scrollSizes->MoveBy(offsetXSizes, offsetYSizes);
+
+	fSizesInput->SetAlignment(B_ALIGN_CENTER, B_ALIGN_CENTER);
+
+	scrollFamilies->ResizeTo(familiesWidth, listsHeight);
+	scrollStyles->ResizeTo(stylesWidth, listsHeight);
+	fSizesInput->ResizeTo(sizesWidth, fSizesInput->Bounds().Height());
+	scrollSizes->ResizeTo(sizesWidth,
+			listsHeight - (offsetYSizes - offsetYLists));
+
+	buttonOK->MoveBy(maxControlsWidth - buttonOK->Bounds().Width(), offsetYButtons);
+	buttonCancel->MoveBy(maxControlsWidth - buttonOK->Bounds().Width()
+			- buttonCancel->Bounds().Width() - kVimDialogSpacingX, offsetYButtons);
+
+	// fill lists
+	int selIndex = -1;
+	int count = count_font_families();
+	for (int i = 0; i < count; i++) {
+		font_family family;
+		if (get_font_family(i, &family ) == B_OK) {
+			fFamiliesList->AddItem(new BStringItem((const char*)family));
+			if (strncmp(family, fFontFamily, B_FONT_FAMILY_LENGTH) == 0)
+				selIndex = i;
+		}
+	}
+
+	if (selIndex >= 0) {
+		fFamiliesList->Select(selIndex);
+		fFamiliesList->ScrollToSelection();
+	}
+
+	_UpdateFontStyles();
+
+	selIndex = -1;
+	for (int size = 8, index = 0; size <= 18; size++, index++) {
+		BString str;
+		str << size;
+		fSizesList->AddItem(new BStringItem(str));
+		if (size == fFontSize)
+			selIndex = index;
+
+	}
+
+	if (selIndex >= 0) {
+		fSizesList->Select(selIndex);
+		fSizesList->ScrollToSelection();
+	}
+
+	fFamiliesList->SetSelectionMessage(new BMessage(kVimDialogFamilySelectMsg));
+	fStylesList->SetSelectionMessage(new BMessage(kVimDialogStyleSelectMsg));
+	fSizesList->SetSelectionMessage(new BMessage(kVimDialogSizeSelectMsg));
+	fSizesInput->SetModificationMessage(new BMessage(kVimDialogSizeInputMsg));
+
+	_UpdateSizeInputPreview();
+	_UpdateFontPreview();
+
+	fStatus = B_OK;
+}
+
+VimSelectFontDialog::~VimSelectFontDialog()
+{
+	_CleanList(fFamiliesList);
+	_CleanList(fStylesList);
+	_CleanList(fSizesList);
+
+	if (fDialogSem > B_OK)
+		delete_sem(fDialogSem);
+}
+
+	void
+VimSelectFontDialog::_CleanList(BListView* list)
+{
+	while(0 < list->CountItems())
+		delete (dynamic_cast<BStringItem*>(list->RemoveItem((int32)0)));
+}
+
+	bool
+VimSelectFontDialog::Go()
+{
+	if (fStatus != B_OK) {
+		Quit();
+		return NOFONT;
+	}
+
+	fDialogSem = create_sem(0, "VimFontSelectDialogSem");
+	if(fDialogSem < B_OK) {
+		Quit();
+		return fDialogValue;
+	}
+
+	Show();
+
+	while(acquire_sem(fDialogSem) == B_INTERRUPTED);
+
+	bool retValue = fDialogValue;
+
+	if(Lock())
+		Quit();
+
+	return retValue;
+}
+
+
+void VimSelectFontDialog::_UpdateFontStyles()
+{
+	_CleanList(fStylesList);
+
+	int32 selIndex = -1;
+	int32 count = count_font_styles(fFontFamily);
+	for (int32 i = 0; i < count; i++) {
+		font_style style;
+		uint32 flags = 0;
+		if (get_font_style(fFontFamily, i, &style, &flags) == B_OK) {
+			fStylesList->AddItem(new BStringItem((const char*)style));
+			if (strncmp(style, fFontStyle, B_FONT_STYLE_LENGTH) == 0)
+				selIndex = i;
+		}
+	}
+
+	if (selIndex >= 0) {
+		fStylesList->Select(selIndex);
+		fStylesList->ScrollToSelection();
+	} else
+		fStylesList->Select(0);
+}
+
+
+void VimSelectFontDialog::_UpdateSizeInputPreview()
+{
+	char buf[10] = {0};
+	vim_snprintf(buf, sizeof(buf), (char*)"%.0f", fFontSize);
+	fSizesInput->SetText(buf);
+}
+
+
+void VimSelectFontDialog::_UpdateFontPreview()
+{
+	BFont font;
+	fPreview->GetFont(&font);
+	font.SetSize(fFontSize);
+	font.SetFamilyAndStyle(fFontFamily, fFontStyle);
+	fPreview->SetFont(&font, B_FONT_FAMILY_AND_STYLE | B_FONT_SIZE);
+
+	BString str;
+	str << fFontFamily << " " << fFontStyle << ", " << (int)fFontSize << " pt.";
+	fPreview->SetText(str);
+}
+
+
+	bool
+VimSelectFontDialog::_UpdateFromListItem(BListView* list, char* text, int textSize)
+{
+	int32 index = list->CurrentSelection();
+	if (index < 0)
+		return false;
+	BStringItem* item = (BStringItem*)list->ItemAt(index);
+	if (item == NULL)
+		return false;
+	strncpy(text, item->Text(), textSize);
+	return true;
+}
+
+
+void VimSelectFontDialog::MessageReceived(BMessage *msg)
+{
+	switch (msg->what) {
+		case kVimDialogOKButtonMsg:
+			strncpy(*fFamily, fFontFamily, B_FONT_FAMILY_LENGTH);
+			strncpy(*fStyle, fFontStyle, B_FONT_STYLE_LENGTH);
+			*fSize = fFontSize;
+			fDialogValue = true;
+		case kVimDialogCancelButtonMsg:
+			delete_sem(fDialogSem);
+			fDialogSem = -1;
+			return;
+		case B_KEY_UP:
+			{
+				int32 key = 0;
+				if (msg->FindInt32("raw_char", &key) == B_OK
+						&& key == B_ESCAPE) {
+					delete_sem(fDialogSem);
+					fDialogSem = -1;
+				}
+			}
+			break;
+
+		case kVimDialogFamilySelectMsg:
+			if (_UpdateFromListItem(fFamiliesList,
+					fFontFamily, B_FONT_FAMILY_LENGTH)) {
+				_UpdateFontStyles();
+				_UpdateFontPreview();
+			}
+			break;
+		case kVimDialogStyleSelectMsg:
+			if (_UpdateFromListItem(fStylesList,
+					fFontStyle, B_FONT_STYLE_LENGTH))
+				_UpdateFontPreview();
+			break;
+		case kVimDialogSizeSelectMsg:
+			{
+				char buf[10] = {0};
+				if (_UpdateFromListItem(fSizesList,	buf, sizeof(buf))) {
+					float size = atof(buf);
+					if (size > 0.f) {
+						fFontSize = size;
+						_UpdateSizeInputPreview();
+						_UpdateFontPreview();
+					}
+				}
+			}
+			break;
+		case kVimDialogSizeInputMsg:
+			{
+				float size = atof(fSizesInput->Text());
+				if (size > 0.f) {
+					fFontSize = size;
+					_UpdateFontPreview();
+				}
+			}
+			break;
+		default:
+			break;
+	}
+	return BWindow::MessageReceived(msg);
+}
+
+#endif /* FEAT_GUI_DIALOG */
+
+#ifdef FEAT_TOOLBAR
+
+// some forward declaration required by toolbar functions...
+static BMessage * MenuMessage(vimmenu_T *menu);
+
+VimToolbar::VimToolbar(BRect frame, const char *name) :
+	BBox(frame, name, B_FOLLOW_LEFT | B_FOLLOW_TOP, B_WILL_DRAW | B_FRAME_EVENTS, B_PLAIN_BORDER)
+{
+}
+
+VimToolbar::~VimToolbar()
+{
+	int32 count = fButtonsList.CountItems();
+	for(int32 i = 0; i < count; i++)
+		delete (BPictureButton*)fButtonsList.ItemAt(i);
+	fButtonsList.MakeEmpty();
+
+	delete normalButtonsBitmap;
+	delete grayedButtonsBitmap;
+	normalButtonsBitmap    = NULL;
+	grayedButtonsBitmap  = NULL;
+}
+
+	void
+VimToolbar::AttachedToWindow()
+{
+	BBox::AttachedToWindow();
+
+	SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));
+}
+
+	float
+VimToolbar::ToolbarHeight() const
+{
+	float size = NULL == normalButtonsBitmap ? 18. : normalButtonsBitmap->Bounds().Height();
+	return size + ToolbarMargin * 2 + ButtonMargin * 2 + 1;
+}
+
+	bool
+VimToolbar::ModifyBitmapToGrayed(BBitmap *bitmap)
+{
+	float height = bitmap->Bounds().Height();
+	float width  = bitmap->Bounds().Width();
+
+	rgb_color *bits = (rgb_color*)bitmap->Bits();
+	int32 pixels = bitmap->BitsLength() / 4;
+	for(int32 i = 0; i < pixels; i++) {
+		bits[i].red = bits[i].green =
+		bits[i].blue = ((uint32)bits[i].red + bits[i].green + bits[i].blue) / 3;
+		bits[i].alpha /= 4;
+	}
+
+	return true;
+}
+
+	bool
+VimToolbar::PrepareButtonBitmaps()
+{
+	// first try to load potentially customized $VIRUNTIME/bitmaps/builtin-tools.png
+	normalButtonsBitmap = LoadVimBitmap("builtin-tools.png");
+	if(normalButtonsBitmap == NULL)
+		// customized not found? dig application resources for "builtin-tools" one
+		normalButtonsBitmap = BTranslationUtils::GetBitmap(B_PNG_FORMAT, "builtin-tools");
+
+	if(normalButtonsBitmap == NULL)
+		return false;
+
+	BMessage archive;
+	normalButtonsBitmap->Archive(&archive);
+
+	grayedButtonsBitmap = new BBitmap(&archive);
+	if(grayedButtonsBitmap == NULL)
+		return false;
+
+	// modify grayed bitmap
+	ModifyBitmapToGrayed(grayedButtonsBitmap);
+
+	return true;
+}
+
+BBitmap *VimToolbar::LoadVimBitmap(const char* fileName)
+{
+	BBitmap *bitmap = NULL;
+
+	int mustfree = 0;
+	char_u* runtimePath = vim_getenv((char_u*)"VIMRUNTIME", &mustfree);
+	if(runtimePath != NULL && fileName != NULL) {
+		BString strPath((char*)runtimePath);
+		strPath << "/bitmaps/" << fileName;
+		bitmap = BTranslationUtils::GetBitmap(strPath.String());
+	}
+
+	if(mustfree)
+		vim_free(runtimePath);
+
+	return bitmap;
+}
+
+	bool
+VimToolbar::GetPictureFromBitmap(BPicture *pictureTo, int32 index, BBitmap *bitmapFrom, bool pressed)
+{
+	float size = bitmapFrom->Bounds().Height() + 1.;
+
+	BView view(BRect(0, 0, size, size), "", 0, 0);
+
+	AddChild(&view);
+	view.BeginPicture(pictureTo);
+
+	view.SetHighColor(ui_color(B_PANEL_BACKGROUND_COLOR));
+	view.FillRect(view.Bounds());
+	view.SetDrawingMode(B_OP_OVER);
+
+	BRect source(0, 0, size - 1, size - 1);
+	BRect destination(source);
+
+	source.OffsetBy(size * index, 0);
+	destination.OffsetBy(ButtonMargin, ButtonMargin);
+
+	view.DrawBitmap(bitmapFrom, source, destination);
+
+	if(pressed)	{
+		rgb_color shineColor  = ui_color(B_SHINE_COLOR);
+		rgb_color shadowColor = ui_color(B_SHADOW_COLOR);
+		size += ButtonMargin * 2 - 1;
+		view.BeginLineArray(4);
+		view.AddLine(BPoint(0, 0),		 BPoint(size, 0),	 shadowColor);
+		view.AddLine(BPoint(size, 0),	 BPoint(size, size), shineColor);
+		view.AddLine(BPoint(size, size), BPoint(0, size),	 shineColor);
+		view.AddLine(BPoint(0, size),	 BPoint(0, 0),		 shadowColor);
+		view.EndLineArray();
+	}
+
+	view.EndPicture();
+	RemoveChild(&view);
+
+	return true;
+}
+
+	bool
+VimToolbar::AddButton(int32 index, vimmenu_T *menu)
+{
+	BPictureButton *button = NULL;
+	if(!menu_is_separator(menu->name)) {
+		float size = normalButtonsBitmap ?
+			normalButtonsBitmap->Bounds().Height() + 1. + ButtonMargin * 2 : 18.;
+		BRect frame(0, 0, size, size);
+		BPicture pictureOn;
+		BPicture pictureOff;
+		BPicture pictureGray;
+
+		if(menu->iconfile == NULL && menu->iconidx >= 0 && normalButtonsBitmap) {
+			GetPictureFromBitmap(&pictureOn,  menu->iconidx, normalButtonsBitmap, true);
+			GetPictureFromBitmap(&pictureOff, menu->iconidx, normalButtonsBitmap, false);
+			GetPictureFromBitmap(&pictureGray, menu->iconidx, grayedButtonsBitmap, false);
+		} else {
+
+			char_u buffer[MAXPATHL] = {0};
+			BBitmap *bitmap = NULL;
+
+			if(menu->iconfile) {
+				gui_find_iconfile(menu->iconfile, buffer, (char*)"png");
+				bitmap = BTranslationUtils::GetBitmap((char*)buffer);
+			}
+
+			if(bitmap == NULL && gui_find_bitmap(menu->name, buffer, (char*)"png") == OK)
+				bitmap = BTranslationUtils::GetBitmap((char*)buffer);
+
+			if(bitmap == NULL)
+				bitmap = new BBitmap(BRect(0, 0, size, size), B_RGB32);
+
+			GetPictureFromBitmap(&pictureOn,   0, bitmap, true);
+			GetPictureFromBitmap(&pictureOff,  0, bitmap, false);
+			ModifyBitmapToGrayed(bitmap);
+			GetPictureFromBitmap(&pictureGray, 0, bitmap, false);
+
+			delete bitmap;
+		}
+
+		button = new BPictureButton(frame, (char*)menu->name,
+					&pictureOff, &pictureOn, MenuMessage(menu));
+
+		button->SetDisabledOn(&pictureGray);
+		button->SetDisabledOff(&pictureGray);
+
+		button->SetTarget(gui.vimTextArea);
+
+		AddChild(button);
+
+		menu->button = button;
+	}
+
+	bool result = fButtonsList.AddItem(button, index);
+	InvalidateLayout();
+	return result;
+}
+
+	bool
+VimToolbar::RemoveButton(vimmenu_T *menu)
+{
+	if(menu->button) {
+		if(fButtonsList.RemoveItem(menu->button)) {
+			delete menu->button;
+			menu->button = NULL;
+		}
+	}
+}
+
+	bool
+VimToolbar::GrayButton(vimmenu_T *menu, int grey)
+{
+	if(menu->button) {
+		int32 index = fButtonsList.IndexOf(menu->button);
+		if(index >= 0)
+			menu->button->SetEnabled(grey ? false : true);
+	}
+}
+
+	void
+VimToolbar::InvalidateLayout()
+{
+	int32 offset = ToolbarMargin;
+	int32 count = fButtonsList.CountItems();
+	for(int32 i = 0; i < count; i++) {
+		BPictureButton *button = (BPictureButton *)fButtonsList.ItemAt(i);
+		if(button) {
+			button->MoveTo(offset, ToolbarMargin);
+			offset += button->Bounds().Width() + ToolbarMargin;
+		} else
+			offset += ToolbarMargin * 3;
+	}
+}
+
+#endif /*FEAT_TOOLBAR*/
+
+#if defined(FEAT_GUI_TABLINE)
+
+	float
+VimTabLine::TablineHeight() const
+{
+//	float size = NULL == normalButtonsBitmap ? 18. : normalButtonsBitmap->Bounds().Height();
+//	return size + ToolbarMargin * 2 + ButtonMargin * 2 + 1;
+	return TabHeight();// + ToolbarMargin;
+}
+
+void
+VimTabLine::MouseDown(BPoint point)
+{
+	if(!gui_mch_showing_tabline())
+		return;
+
+	BMessage *m = Window()->CurrentMessage();
+	assert(m);
+
+	int32 buttons = 0;
+	m->FindInt32("buttons", &buttons);
+
+	int32 clicks = 0;
+	m->FindInt32("clicks", &clicks);
+
+	int index = 0; // 0 means here - no tab found
+	for (int i = 0; i < CountTabs(); i++) {
+		if(TabFrame(i).Contains(point)) {
+			index = i + 1; // indexes are 1-based
+			break;
+		}
+	}
+
+	int event = -1;
+
+	if ((buttons & B_PRIMARY_MOUSE_BUTTON) && clicks > 1)
+		// left button double click on - create new tab
+		event = TABLINE_MENU_NEW;
+
+	else if (buttons & B_TERTIARY_MOUSE_BUTTON)
+		// middle button click - close the pointed tab
+		// or create new one in case empty space
+		event = index > 0 ? TABLINE_MENU_CLOSE : TABLINE_MENU_NEW;
+
+	else if (buttons & B_SECONDARY_MOUSE_BUTTON) {
+		// right button click - show context menu
+		BPopUpMenu* popUpMenu = new BPopUpMenu("tabLineContextMenu", false, false);
+		popUpMenu->AddItem(new BMenuItem(_("Close tabi R"), new BMessage(TABLINE_MENU_CLOSE)));
+		popUpMenu->AddItem(new BMenuItem(_("New tab    T"), new BMessage(TABLINE_MENU_NEW)));
+		popUpMenu->AddItem(new BMenuItem(_("Open tab..."), new BMessage(TABLINE_MENU_OPEN)));
+
+		ConvertToScreen(&point);
+		BMenuItem* item = popUpMenu->Go(point);
+		if (item != NULL) {
+			event = item->Command();
+		}
+
+		delete popUpMenu;
+
+	} else {
+		// default processing
+		BTabView::MouseDown(point);
+		return;
+	}
+
+	if (event < 0)
+		return;
+
+	VimTablineMenuMsg tmm;
+	tmm.index = index;
+	tmm.event = event;
+	write_port(gui.vdcmp, VimMsg::TablineMenu, &tmm, sizeof(tmm));
+}
+
+void
+VimTabLine::VimTab::Select(BView* owner)
+{
+	BTab::Select(owner);
+
+	VimTabLine *tabLine = gui.vimForm->TabLine();
+	if(tabLine != NULL) {
+
+		int32 i = 0;
+		for (; i < tabLine->CountTabs(); i++)
+			if(this == tabLine->TabAt(i))
+				break;
+
+//		printf("%d:%d:%s\n", i, tabLine->CountTabs(), tabLine->TabAt(i)->Label());
+		if(i < tabLine->CountTabs()) {
+			VimTablineMsg tm;
+			tm.index = i + 1;
+			write_port(gui.vdcmp, VimMsg::Tabline, &tm, sizeof(tm));
+		}
+	}
+}
+
+#endif // defined(FEAT_GUI_TABLINE)
+
+/* ---------------- ---------------- */
+
+// some global variables
+static char appsig[] = "application/x-vnd.Haiku-Vim-8";
+key_map *keyMap;
+char *keyMapChars;
+int main_exitcode = 127;
+
+	status_t
+gui_haiku_process_event(bigtime_t timeout)
+{
+	struct VimMsg vm;
+	int32 what;
+	ssize_t size;
+
+	size = read_port_etc(gui.vdcmp, &what, &vm, sizeof(vm),
+			B_TIMEOUT, timeout);
+
+	if (size >= 0) {
+		switch (what) {
+			case VimMsg::Key:
+				{
+					char_u *string = vm.u.Key.chars;
+					int len = vm.u.Key.length;
+					if (len == 1 && string[0] == Ctrl_chr('C')) {
+						trash_input_buf();
+						got_int = TRUE;
+					}
+
+#ifdef FEAT_MBYTE
+					if (vm.u.Key.csi_escape)
+#ifndef FEAT_MBYTE_IME
+					{
+						int		i;
+						char_u	buf[2];
+
+						for (i = 0; i < len; ++i)
+						{
+							add_to_input_buf(string + i, 1);
+							if (string[i] == CSI)
+							{
+								/* Turn CSI into K_CSI. */
+								buf[0] = KS_EXTRA;
+								buf[1] = (int)KE_CSI;
+								add_to_input_buf(buf, 2);
+							}
+						}
+					}
+#else
+					add_to_input_buf_csi(string, len);
+#endif
+					else
+#endif
+						add_to_input_buf(string, len);
+				}
+				break;
+			case VimMsg::Resize:
+				gui_resize_shell(vm.u.NewSize.width, vm.u.NewSize.height);
+				break;
+			case VimMsg::ScrollBar:
+				{
+					/*
+					 * If loads of scroll messages queue up, use only the last
+					 * one. Always report when the scrollbar stops dragging.
+					 * This is not perfect yet anyway: these events are queued
+					 * yet again, this time in the keyboard input buffer.
+					 */
+					int32 oldCount =
+						atomic_add(&vm.u.Scroll.sb->scrollEventCount, -1);
+					if (oldCount <= 1 || !vm.u.Scroll.stillDragging)
+						gui_drag_scrollbar(vm.u.Scroll.sb->getGsb(),
+								vm.u.Scroll.value, vm.u.Scroll.stillDragging);
+				}
+				break;
+#if defined(FEAT_MENU)
+			case VimMsg::Menu:
+				gui_menu_cb(vm.u.Menu.guiMenu);
+				break;
+#endif
+			case VimMsg::Mouse:
+				{
+					int32 oldCount;
+					if (vm.u.Mouse.button == MOUSE_DRAG)
+						oldCount =
+							atomic_add(&gui.vimTextArea->mouseDragEventCount, -1);
+					else
+						oldCount = 0;
+					if (oldCount <= 1)
+						gui_send_mouse_event(vm.u.Mouse.button, vm.u.Mouse.x,
+								vm.u.Mouse.y, vm.u.Mouse.repeated_click,
+								vm.u.Mouse.modifiers);
+				}
+				break;
+			case VimMsg::MouseMoved:
+				{
+					gui_mouse_moved(vm.u.MouseMoved.x, vm.u.MouseMoved.y);
+				}
+				break;
+			case VimMsg::Focus:
+				gui.in_focus = vm.u.Focus.active;
+				/* XXX Signal that scrollbar dragging has stopped?
+				 * This is needed because we don't get a MouseUp if
+				 * that happens while outside the window... :-(
+				 */
+				if (gui.dragged_sb) {
+					gui.dragged_sb = SBAR_NONE;
+				}
+				// gui_update_cursor(TRUE, FALSE);
+				break;
+			case VimMsg::Refs:
+				::RefsReceived(vm.u.Refs.message, vm.u.Refs.changedir);
+				break;
+			case VimMsg::Tabline:
+				send_tabline_event(vm.u.Tabline.index);
+				break;
+			case VimMsg::TablineMenu:
+				send_tabline_menu_event(vm.u.TablineMenu.index, vm.u.TablineMenu.event);
+				break;
+			default:
+				// unrecognised message, ignore it
+				break;
+		}
+	}
+
+	/*
+	 * If size < B_OK, it is an error code.
+	 */
+	return size;
+}
+
+/*
+ * Here are some functions to protect access to ScreenLines[] and
+ * LineOffset[]. These are used from the window thread to respond
+ * to a Draw() callback. When that occurs, the window is already
+ * locked by the system.
+ *
+ * Other code that needs to lock is any code that changes these
+ * variables. Other read-only access, or access merely to the
+ * contents of the screen buffer, need not be locked.
+ *
+ * If there is no window, don't call Lock() but do succeed.
+ */
+
+	int
+vim_lock_screen()
+{
+	return !gui.vimWindow || gui.vimWindow->Lock();
+}
+
+	void
+vim_unlock_screen()
+{
+	if (gui.vimWindow)
+		gui.vimWindow->Unlock();
+}
+
+#define RUN_BAPPLICATION_IN_NEW_THREAD	0
+
+#if RUN_BAPPLICATION_IN_NEW_THREAD
+
+	int32
+run_vimapp(void *args)
+{
+	VimApp app(appsig);
+
+	gui.vimApp = &app;
+	app.Run();			    /* Run until Quit() called */
+
+	return 0;
+}
+
+#else
+
+	int32
+call_main(void *args)
+{
+	struct MainArgs *ma = (MainArgs *)args;
+
+	return main(ma->argc, ma->argv);
+}
+#endif
+
+/*
+ * Parse the GUI related command-line arguments.  Any arguments used are
+ * deleted from argv, and *argc is decremented accordingly.  This is called
+ * when vim is started, whether or not the GUI has been started.
+ */
+	void
+gui_mch_prepare(
+		int		*argc,
+		char	**argv)
+{
+	/*
+	 * We don't have any command line arguments for the BeOS GUI yet,
+	 * but this is an excellent place to create our Application object.
+	 */
+	if (!gui.vimApp) {
+		thread_info tinfo;
+		get_thread_info(find_thread(NULL), &tinfo);
+
+		/* May need the port very early on to process RefsReceived() */
+		gui.vdcmp = create_port(B_MAX_PORT_COUNT, "vim VDCMP");
+
+#if RUN_BAPPLICATION_IN_NEW_THREAD
+		thread_id tid = spawn_thread(run_vimapp, "vim VimApp",
+				tinfo.priority, NULL);
+		if (tid >= B_OK) {
+			resume_thread(tid);
+		} else {
+			getout(1);
+		}
+#else
+		MainArgs ma = { *argc, argv };
+		thread_id tid = spawn_thread(call_main, "vim main()",
+				tinfo.priority, &ma);
+		if (tid >= B_OK) {
+			VimApp app(appsig);
+
+			gui.vimApp = &app;
+			resume_thread(tid);
+			/*
+			 * This is rather horrible.
+			 * call_main will call main() again...
+			 * There will be no infinite recursion since
+			 * gui.vimApp is set now.
+			 */
+			app.Run();			    /* Run until Quit() called */
+			//fprintf(stderr, "app.Run() returned...\n");
+			status_t dummy_exitcode;
+			(void)wait_for_thread(tid, &dummy_exitcode);
+
+			/*
+			 * This path should be the normal one taken to exit Vim.
+			 * The main() thread calls mch_exit() which calls
+			 * gui_mch_exit() which terminates its thread.
+			 */
+			exit(main_exitcode);
+		}
+#endif
+	}
+	/* Don't fork() when starting the GUI. Spawned threads are not
+	 * duplicated with a fork(). The result is a mess.
+	 */
+	gui.dofork = FALSE;
+	/*
+	 * XXX Try to determine whether we were started from
+	 * the Tracker or the terminal.
+	 * It would be nice to have this work, because the Tracker
+	 * follows symlinks, so even if you double-click on gvim,
+	 * when it is a link to vim it will still pass a command name
+	 * of vim...
+	 * We try here to see if stdin comes from /dev/null. If so,
+	 * (or if there is an error, which should never happen) start the GUI.
+	 * This does the wrong thing for vim - </dev/null, and we're
+	 * too early to see the command line parsing. Tough.
+	 * On the other hand, it starts the gui for vim file & which is nice.
+	 */
+	if (!isatty(0)) {
+		struct stat stat_stdin, stat_dev_null;
+
+		if (fstat(0, &stat_stdin) == -1 ||
+				stat("/dev/null", &stat_dev_null) == -1 ||
+				(stat_stdin.st_dev == stat_dev_null.st_dev &&
+				 stat_stdin.st_ino == stat_dev_null.st_ino))
+			gui.starting = TRUE;
+	}
+}
+
+/*
+ * Check if the GUI can be started.  Called before gvimrc is sourced.
+ * Return OK or FAIL.
+ */
+	int
+gui_mch_init_check(void)
+{
+	return OK;		/* TODO: GUI can always be started? */
+}
+
+/*
+ * Initialise the GUI.  Create all the windows, set up all the call-backs
+ * etc.
+ */
+	int
+gui_mch_init()
+{
+    display_errors();
+	gui.def_norm_pixel = RGB(0x00, 0x00, 0x00);	// black
+	gui.def_back_pixel = RGB(0xFF, 0xFF, 0xFF);	// white
+	gui.norm_pixel = gui.def_norm_pixel;
+	gui.back_pixel = gui.def_back_pixel;
+
+	gui.scrollbar_width = (int) B_V_SCROLL_BAR_WIDTH;
+	gui.scrollbar_height = (int) B_H_SCROLL_BAR_HEIGHT;
+#ifdef FEAT_MENU
+	gui.menu_height = 19;	// initial guess -
+	// correct for my default settings
+#endif
+	gui.border_offset = 3;	// coordinates are inside window borders
+
+	if (gui.vdcmp < B_OK)
+		return FAIL;
+	get_key_map(&keyMap, &keyMapChars);
+
+	gui.vimWindow = new VimWindow();	/* hidden and locked */
+	if (!gui.vimWindow)
+		return FAIL;
+
+	gui.vimWindow->Run();		/* Run() unlocks but does not show */
+
+	/* Get the colors from the "Normal" group (set in syntax.c or in a vimrc
+	 * file) */
+	set_normal_colors();
+
+	/*
+	 * Check that none of the colors are the same as the background color
+	 */
+	gui_check_colors();
+
+	/* Get the colors for the highlight groups (gui_check_colors() might have
+	 * changed them) */
+	highlight_gui_started();		/* re-init colors and fonts */
+
+	gui_mch_new_colors();		/* window must exist for this */
+
+	return OK;
+}
+
+/*
+ * Called when the foreground or background color has been changed.
+ */
+	void
+gui_mch_new_colors()
+{
+	rgb_color rgb = GUI_TO_RGB(gui.back_pixel);
+
+	if (gui.vimWindow->Lock()) {
+		gui.vimForm->SetViewColor(rgb);
+		// Does this not have too much effect for those small rectangles?
+		gui.vimForm->Invalidate();
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Open the GUI window which was created by a call to gui_mch_init().
+ */
+	int
+gui_mch_open()
+{
+	if (gui_win_x != -1 && gui_win_y != -1)
+		gui_mch_set_winpos(gui_win_x, gui_win_y);
+
+	/* Actually open the window */
+	if (gui.vimWindow->Lock()) {
+		gui.vimWindow->Show();
+		gui.vimWindow->Unlock();
+		return OK;
+	}
+
+	return FAIL;
+}
+
+	void
+gui_mch_exit(int vim_exitcode)
+{
+	if (gui.vimWindow) {
+		thread_id tid = gui.vimWindow->Thread();
+		gui.vimWindow->Lock();
+		gui.vimWindow->Quit();
+		/* Wait until it is truely gone */
+		int32 exitcode;
+		wait_for_thread(tid, &exitcode);
+	}
+	delete_port(gui.vdcmp);
+#if !RUN_BAPPLICATION_IN_NEW_THREAD
+	/*
+	 * We are in the main() thread - quit the App thread and
+	 * quit ourselves (passing on the exitcode). Use a global since the
+	 * value from exit_thread() is only used if wait_for_thread() is
+	 * called in time (race condition).
+	 */
+#endif
+	if (gui.vimApp) {
+		VimTextAreaView::guiBlankMouse(false);
+
+		main_exitcode = vim_exitcode;
+#if RUN_BAPPLICATION_IN_NEW_THREAD
+		thread_id tid = gui.vimApp->Thread();
+		int32 exitcode;
+		gui.vimApp->Lock();
+		gui.vimApp->Quit();
+		gui.vimApp->Unlock();
+		wait_for_thread(tid, &exitcode);
+#else
+		gui.vimApp->Lock();
+		gui.vimApp->Quit();
+		gui.vimApp->Unlock();
+		/* suicide */
+		exit_thread(vim_exitcode);
+#endif
+	}
+	/* If we are somehow still here, let mch_exit() handle things. */
+}
+
+/*
+ * Get the position of the top left corner of the window.
+ */
+	int
+gui_mch_get_winpos(int *x, int *y)
+{
+	if (gui.vimWindow->Lock()) {
+		BRect r;
+		r = gui.vimWindow->Frame();
+		gui.vimWindow->Unlock();
+		*x = (int)r.left;
+		*y = (int)r.top;
+		return OK;
+	}
+	else
+		return FAIL;
+}
+
+/*
+ * Set the position of the top left corner of the window to the given
+ * coordinates.
+ */
+	void
+gui_mch_set_winpos(int x, int y)
+{
+	if (gui.vimWindow->Lock()) {
+		gui.vimWindow->MoveTo(x, y);
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Set the size of the window to the given width and height in pixels.
+ */
+void
+gui_mch_set_shellsize(
+		int		width,
+		int		height,
+		int		min_width,
+		int		min_height,
+		int		base_width,
+		int		base_height,
+		int		direction) //TODO: utilize?
+{
+	/*
+	 * We are basically given the size of the VimForm, if I understand
+	 * correctly. Since it fills the window completely, this will also
+	 * be the size of the window.
+	 */
+	if (gui.vimWindow->Lock()) {
+		gui.vimWindow->ResizeTo(width - PEN_WIDTH, height - PEN_WIDTH);
+
+		/* set size limits */
+		float minWidth, maxWidth, minHeight, maxHeight;
+
+		gui.vimWindow->GetSizeLimits(&minWidth, &maxWidth,
+				&minHeight, &maxHeight);
+		gui.vimWindow->SetSizeLimits(min_width, maxWidth,
+				min_height, maxHeight);
+
+		/*
+		 * Set the resizing alignment depending on font size.
+		 */
+		gui.vimWindow->SetWindowAlignment(
+				B_PIXEL_ALIGNMENT,		// window_alignment mode,
+				1,				// int32 h,
+				0,				// int32 hOffset = 0,
+				gui.char_width,		// int32 width = 0,
+				base_width,			// int32 widthOffset = 0,
+				1,				// int32 v = 0,
+				0,				// int32 vOffset = 0,
+				gui.char_height,		// int32 height = 0,
+				base_height			// int32 heightOffset = 0
+				);
+
+		gui.vimWindow->Unlock();
+	}
+}
+
+void
+gui_mch_get_screen_dimensions(
+		int		*screen_w,
+		int		*screen_h)
+{
+	BRect frame;
+
+	{
+		BScreen screen(gui.vimWindow);
+
+		if (screen.IsValid()) {
+			frame = screen.Frame();
+		} else {
+			frame.right = 640;
+			frame.bottom = 480;
+		}
+	}
+
+	/* XXX approximations... */
+	*screen_w = (int) frame.right - 2 * gui.scrollbar_width - 20;
+	*screen_h = (int) frame.bottom - gui.scrollbar_height
+#ifdef FEAT_MENU
+		- gui.menu_height
+#endif
+		- 30;
+}
+
+void
+gui_mch_set_text_area_pos(
+		int		x,
+		int		y,
+		int		w,
+		int		h)
+{
+	if (!gui.vimTextArea)
+		return;
+
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->MoveTo(x, y);
+		gui.vimTextArea->ResizeTo(w - PEN_WIDTH, h - PEN_WIDTH);
+
+/*#ifdef FEAT_GUI_TABLINE
+		if(gui.vimForm->TabLine() != NULL) {
+			gui.vimForm->TabLine()->ResizeTo(w, gui.vimForm->TablineHeight());
+		}
+#endif //FEAT_GUI_TABLINE*/
+
+		gui.vimWindow->Unlock();
+	}
+}
+
+
+/*
+ * Scrollbar stuff:
+ */
+
+void
+gui_mch_enable_scrollbar(
+		scrollbar_T	*sb,
+		int		flag)
+{
+	VimScrollBar *vsb = sb->id;
+	if (gui.vimWindow->Lock()) {
+		/*
+		 * This function is supposed to be idempotent, but Show()/Hide()
+		 * is not. Therefore we test if they are needed.
+		 */
+		if (flag) {
+			if (vsb->IsHidden()) {
+				vsb->Show();
+			}
+		} else {
+			if (!vsb->IsHidden()) {
+				vsb->Hide();
+			}
+		}
+		gui.vimWindow->Unlock();
+	}
+}
+
+void
+gui_mch_set_scrollbar_thumb(
+		scrollbar_T *sb,
+		int		val,
+		int		size,
+		int		max)
+{
+	if (gui.vimWindow->Lock()) {
+		VimScrollBar *s = sb->id;
+		if (max == 0) {
+			s->SetValue(0);
+			s->SetRange(0.0, 0.0);
+		} else {
+			s->SetProportion((float)size / (max + 1.0));
+			s->SetSteps(1.0, size > 5 ? size - 2 : size);
+#ifndef SCROLL_PAST_END		// really only defined in gui.c...
+			max = max + 1 - size;
+#endif
+			if (max < s->Value()) {
+				/*
+				 * If the new maximum is lower than the current value,
+				 * setting it would cause the value to be clipped and
+				 * therefore a ValueChanged() call.
+				 * We avoid this by setting the value first, because
+				 * it presumably is <= max.
+				 */
+				s->SetValue(val);
+				s->SetRange(0.0, max);
+			} else {
+				/*
+				 * In the other case, set the range first, since the
+				 * new value might be higher than the current max.
+				 */
+				s->SetRange(0.0, max);
+				s->SetValue(val);
+			}
+		}
+		gui.vimWindow->Unlock();
+	}
+}
+
+void
+gui_mch_set_scrollbar_pos(
+		scrollbar_T *sb,
+		int		x,
+		int		y,
+		int		w,
+		int		h)
+{
+	if (gui.vimWindow->Lock()) {
+		BRect winb = gui.vimWindow->Bounds();
+		float vsbx = x, vsby = y;
+		VimScrollBar *vsb = sb->id;
+		vsb->ResizeTo(w - PEN_WIDTH, h - PEN_WIDTH);
+		if(winb.right-(x+w)<w) vsbx = winb.right - (w - PEN_WIDTH);
+		vsb->MoveTo(vsbx, vsby);
+		gui.vimWindow->Unlock();
+	}
+}
+
+void
+gui_mch_create_scrollbar(
+		scrollbar_T *sb,
+		int		orient)		/* SBAR_VERT or SBAR_HORIZ */
+{
+	orientation posture =
+		(orient == SBAR_HORIZ) ? B_HORIZONTAL : B_VERTICAL;
+
+	VimScrollBar *vsb = sb->id = new VimScrollBar(sb, posture);
+	if (gui.vimWindow->Lock()) {
+		vsb->SetTarget(gui.vimTextArea);
+		vsb->Hide();
+		gui.vimForm->AddChild(vsb);
+		gui.vimWindow->Unlock();
+	}
+}
+
+void
+gui_mch_destroy_scrollbar(
+		scrollbar_T	*sb)
+{
+	if (gui.vimWindow->Lock()) {
+		sb->id->RemoveSelf();
+		delete sb->id;
+		gui.vimWindow->Unlock();
+	}
+}
+
+    int
+gui_mch_is_blink_off(void)
+{
+    return FALSE;
+}
+
+/*
+ * Cursor blink functions.
+ *
+ * This is a simple state machine:
+ * BLINK_NONE	not blinking at all
+ * BLINK_OFF	blinking, cursor is not shown
+ * BLINK_ON	blinking, cursor is shown
+ */
+
+#define BLINK_NONE  0
+#define BLINK_OFF   1
+#define BLINK_ON    2
+
+static int		blink_state = BLINK_NONE;
+static long_u		blink_waittime = 700;
+static long_u		blink_ontime = 400;
+static long_u		blink_offtime = 250;
+static int	blink_timer = 0;
+
+void
+gui_mch_set_blinking(
+		long    waittime,
+		long    on,
+		long    off)
+{
+	/* TODO */
+	blink_waittime = waittime;
+	blink_ontime = on;
+	blink_offtime = off;
+}
+
+/*
+ * Stop the cursor blinking.  Show the cursor if it wasn't shown.
+ */
+	void
+gui_mch_stop_blink()
+{
+	/* TODO */
+	if (blink_timer != 0)
+	{
+		//XtRemoveTimeOut(blink_timer);
+		blink_timer = 0;
+	}
+	if (blink_state == BLINK_OFF)
+		gui_update_cursor(TRUE, FALSE);
+	blink_state = BLINK_NONE;
+}
+
+/*
+ * Start the cursor blinking.  If it was already blinking, this restarts the
+ * waiting time and shows the cursor.
+ */
+	void
+gui_mch_start_blink()
+{
+	/* TODO */
+	if (blink_timer != 0)
+		;//XtRemoveTimeOut(blink_timer);
+	/* Only switch blinking on if none of the times is zero */
+	if (blink_waittime && blink_ontime && blink_offtime && gui.in_focus)
+	{
+		blink_timer = 1; //XtAppAddTimeOut(app_context, blink_waittime,
+		blink_state = BLINK_ON;
+		gui_update_cursor(TRUE, FALSE);
+	}
+}
+
+/*
+ * Initialise vim to use the font with the given name.	Return FAIL if the font
+ * could not be loaded, OK otherwise.
+ */
+int
+gui_mch_init_font(
+		char_u		*font_name,
+		int			fontset)
+{
+	if (gui.vimWindow->Lock())
+	{
+		int rc = gui.vimTextArea->mchInitFont(font_name);
+		gui.vimWindow->Unlock();
+
+		return rc;
+	}
+
+	return FAIL;
+}
+
+
+	int
+gui_mch_adjust_charsize()
+{
+	return FAIL;
+}
+
+
+	int
+gui_mch_font_dialog(font_family* family, font_style* style, float* size)
+{
+#if defined(FEAT_GUI_DIALOG)
+		//gui.vimWindow->Unlock();
+	VimSelectFontDialog *dialog = new VimSelectFontDialog(family, style, size);
+	return dialog->Go();
+#else
+	return NOFONT;
+#endif /* FEAT_GUI_DIALOG */
+}
+
+
+GuiFont
+gui_mch_get_font(
+		char_u		*name,
+		int			giveErrorIfMissing)
+{
+	static VimFont *fontList = NULL;
+
+	if (!gui.in_use)	// can't do this when GUI not running
+		return NOFONT;
+
+	// storage for locally modified name;
+	const int buff_size = B_FONT_FAMILY_LENGTH + B_FONT_STYLE_LENGTH + 20;
+	static char font_name[buff_size] = {0};
+	font_family family = {0};
+	font_style  style  = {0};
+	float size = 0.f;
+
+	if (name == 0 && be_fixed_font == 0) {
+		if(giveErrorIfMissing)
+			EMSG2("(fe0) default font is not defined", name);
+		return NOFONT;
+	}
+
+	bool useSelectGUI = false;
+	if (name != NULL)
+		if (STRCMP(name, "*") == 0) {
+			useSelectGUI = true;
+			STRNCPY(font_name, hl_get_font_name(), buff_size);
+		} else
+			STRNCPY(font_name, name, buff_size);
+
+	if (font_name[0] == 0) {
+		be_fixed_font->GetFamilyAndStyle(&family, &style);
+		size = be_fixed_font->Size();
+		vim_snprintf(font_name, buff_size,
+			(char*)"%s/%s/%.0f", family, style, size);
+	}
+
+	// replace underscores with spaces
+	char* end = 0;
+	while (end = strchr((char *)font_name, '_'))
+		*end = ' ';
+
+	// store the name before strtok corrupt the buffer ;-)
+	static char buff[buff_size] = {0};
+	STRNCPY(buff, font_name, buff_size);
+	STRNCPY(family, strtok(buff, "/\0"), B_FONT_FAMILY_LENGTH);
+	char* style_s = strtok(0, "/\0");
+	if (style_s != 0)
+		STRNCPY(style, style_s, B_FONT_STYLE_LENGTH);
+	size = atof((style_s != 0) ? strtok(0, "/\0") : "0");
+
+	if (useSelectGUI) {
+		if(gui_mch_font_dialog(&family, &style, &size) == NOFONT)
+			return FAIL;
+		// compose for further processing
+		vim_snprintf(font_name, buff_size,
+				(char*)"%s/%s/%.0f", family, style, size);
+		hl_set_font_name((char_u*)font_name);
+
+		// Set guifont to the name of the selected font.
+		char_u* new_p_guifont = alloc(STRLEN(font_name) + 1);
+		if (new_p_guifont != NULL) {
+			STRCPY(new_p_guifont, font_name);
+			vim_free(p_guifont);
+			p_guifont = new_p_guifont;
+			// Replace spaces in the font name with underscores.
+			for ( ; *new_p_guifont; ++new_p_guifont)
+				if (*new_p_guifont == ' ')
+					*new_p_guifont = '_';
+		}
+	}
+
+	VimFont *flp;
+	for (flp = fontList; flp; flp = flp->next) {
+		if (STRCMP(font_name, flp->name) == 0) {
+			flp->refcount++;
+			return (GuiFont)flp;
+		}
+	}
+
+	VimFont *font = new VimFont();
+	font->name = vim_strsave((char_u*)font_name);
+
+	if(count_font_styles(family) <= 0) {
+		if (giveErrorIfMissing)
+			EMSG2("(fe0) Specified font %s is not found", font->name);
+		delete font;
+		return NOFONT;
+	}
+
+	// Remember font in the static list for later use
+	font->next = fontList;
+	fontList = font;
+
+	font->SetFamilyAndStyle(family, style);
+	if(size > 0.f)
+		font->SetSize(size);
+
+	font->SetSpacing(B_FIXED_SPACING);
+	font->SetEncoding(B_UNICODE_UTF8);
+
+	return (GuiFont)font;
+}
+
+/*
+ * Set the current text font.
+ */
+void
+gui_mch_set_font(
+		GuiFont	font)
+{
+	if (gui.vimWindow->Lock()) {
+		VimFont *vf = (VimFont *)font;
+
+		gui.vimTextArea->SetFont(vf);
+
+		gui.char_width = (int) vf->StringWidth("n");
+		font_height fh;
+		vf->GetHeight(&fh);
+		gui.char_height = (int)(fh.ascent + 0.9999)
+			+ (int)(fh.descent + 0.9999) + (int)(fh.leading + 0.9999);
+		gui.char_ascent = (int)(fh.ascent + 0.9999);
+
+		gui.vimWindow->Unlock();
+	}
+}
+
+/* XXX TODO This is apparently never called... */
+void
+gui_mch_free_font(
+		GuiFont	font)
+{
+	if(font == NOFONT)
+		return;
+	VimFont *f = (VimFont *)font;
+	if (--f->refcount <= 0) {
+		if (f->refcount < 0)
+			fprintf(stderr, "VimFont: refcount < 0\n");
+		delete f;
+	}
+}
+
+	char_u *
+gui_mch_get_fontname(GuiFont font, char_u *name)
+{
+	if (name == NULL)
+		return NULL;
+	return vim_strsave(name);
+}
+
+/*
+ * Adjust gui.char_height (after 'linespace' was changed).
+ */
+	int
+gui_mch_adjust_charheight()
+{
+
+	//TODO: linespace support?
+
+//#ifdef FEAT_XFONTSET
+//	if (gui.fontset != NOFONTSET)
+//	{
+//	gui.char_height = fontset_height((XFontSet)gui.fontset) + p_linespace;
+//	gui.char_ascent = fontset_ascent((XFontSet)gui.fontset)
+//	+ p_linespace / 2;
+//	}
+//	else
+//#endif
+	{
+		VimFont *font = (VimFont *)gui.norm_font;
+		font_height fh = {0};
+		font->GetHeight(&fh);
+		gui.char_height = (int)(fh.ascent + fh.descent + 0.5) + p_linespace;
+		gui.char_ascent = (int)(fh.ascent + 0.5) + p_linespace / 2;
+	}
+	return OK;
+}
+
+/*
+ * Display the saved error message(s).
+ */
+#ifdef USE_MCH_ERRMSG
+    void
+display_errors(void)
+{
+    char	*p;
+    char_u	pError[256];
+
+    if (error_ga.ga_data == NULL)
+	return;
+
+    /* avoid putting up a message box with blanks only */
+    for (p = (char *)error_ga.ga_data; *p; ++p)
+	if (!isspace(*p))
+	{
+	    if (STRLEN(p) > 255)
+		pError[0] = 255;
+	    else
+		pError[0] = STRLEN(p);
+
+	    STRNCPY(&pError[1], p, pError[0]);
+//	    ParamText(pError, nil, nil, nil);
+//	    Alert(128, nil);
+	    break;
+	    /* TODO: handled message longer than 256 chars
+	     *	 use auto-sizeable alert
+	     *	 or dialog with scrollbars (TextEdit zone)
+	     */
+	}
+    ga_clear(&error_ga);
+}
+#endif
+
+	void
+gui_mch_getmouse(int *x, int *y)
+{
+	fprintf(stderr, "gui_mch_getmouse");
+
+	/*int		rootx, rooty, winx, winy;
+	  Window	root, child;
+	  unsigned int mask;
+
+	  if (gui.wid && XQueryPointer(gui.dpy, gui.wid, &root, &child,
+	  &rootx, &rooty, &winx, &winy, &mask)) {
+	 *x = winx;
+	 *y = winy;
+	 } else*/ {
+		 *x = -1;
+		 *y = -1;
+	 }
+}
+
+	void
+gui_mch_mousehide(int hide)
+{
+	fprintf(stderr, "gui_mch_getmouse");
+	// TODO
+}
+
+	static int
+hex_digit(int c)
+{
+	if (isdigit(c))
+		return c - '0';
+	c = TOLOWER_ASC(c);
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	return -1000;
+}
+
+/*
+ * This function has been lifted from gui_w32.c and extended a bit.
+ *
+ * Return the Pixel value (color) for the given color name.
+ * Return INVALCOLOR for error.
+ */
+guicolor_T
+gui_mch_get_color(
+		char_u	*name)
+{
+	typedef struct GuiColourTable
+	{
+		const char    *name;
+		guicolor_T     colour;
+	} GuiColourTable;
+
+#define NSTATIC_COLOURS		50 //32
+#define NDYNAMIC_COLOURS	33
+#define NCOLOURS		(NSTATIC_COLOURS + NDYNAMIC_COLOURS)
+
+	static GuiColourTable table[NCOLOURS] =
+	{
+		{"Black",	    RGB(0x00, 0x00, 0x00)},
+		{"DarkGray",	    RGB(0x80, 0x80, 0x80)},
+		{"DarkGrey",	    RGB(0x80, 0x80, 0x80)},
+		{"Gray",	    RGB(0xC0, 0xC0, 0xC0)},
+		{"Grey",	    RGB(0xC0, 0xC0, 0xC0)},
+		{"LightGray",	    RGB(0xD3, 0xD3, 0xD3)},
+		{"LightGrey",	    RGB(0xD3, 0xD3, 0xD3)},
+		{"Gray10",	    RGB(0x1A, 0x1A, 0x1A)},
+		{"Grey10",	    RGB(0x1A, 0x1A, 0x1A)},
+		{"Gray20",	    RGB(0x33, 0x33, 0x33)},
+		{"Grey20",	    RGB(0x33, 0x33, 0x33)},
+		{"Gray30",	    RGB(0x4D, 0x4D, 0x4D)},
+		{"Grey30",	    RGB(0x4D, 0x4D, 0x4D)},
+		{"Gray40",	    RGB(0x66, 0x66, 0x66)},
+		{"Grey40",	    RGB(0x66, 0x66, 0x66)},
+		{"Gray50",	    RGB(0x7F, 0x7F, 0x7F)},
+		{"Grey50",	    RGB(0x7F, 0x7F, 0x7F)},
+		{"Gray60",	    RGB(0x99, 0x99, 0x99)},
+		{"Grey60",	    RGB(0x99, 0x99, 0x99)},
+		{"Gray70",	    RGB(0xB3, 0xB3, 0xB3)},
+		{"Grey70",	    RGB(0xB3, 0xB3, 0xB3)},
+		{"Gray80",	    RGB(0xCC, 0xCC, 0xCC)},
+		{"Grey80",	    RGB(0xCC, 0xCC, 0xCC)},
+		{"Gray90",	    RGB(0xE5, 0xE5, 0xE5)},
+		{"Grey90",	    RGB(0xE5, 0xE5, 0xE5)},
+		{"White",	    RGB(0xFF, 0xFF, 0xFF)},
+		{"DarkRed",	    RGB(0x80, 0x00, 0x00)},
+		{"Red",		    RGB(0xFF, 0x00, 0x00)},
+		{"LightRed",	    RGB(0xFF, 0xA0, 0xA0)},
+		{"DarkBlue",	    RGB(0x00, 0x00, 0x80)},
+		{"Blue",	    RGB(0x00, 0x00, 0xFF)},
+		{"LightBlue",	    RGB(0xA0, 0xA0, 0xFF)},
+		{"DarkGreen",	    RGB(0x00, 0x80, 0x00)},
+		{"Green",	    RGB(0x00, 0xFF, 0x00)},
+		{"LightGreen",	    RGB(0xA0, 0xFF, 0xA0)},
+		{"DarkCyan",	    RGB(0x00, 0x80, 0x80)},
+		{"Cyan",	    RGB(0x00, 0xFF, 0xFF)},
+		{"LightCyan",	    RGB(0xA0, 0xFF, 0xFF)},
+		{"DarkMagenta",	    RGB(0x80, 0x00, 0x80)},
+		{"Magenta",	    RGB(0xFF, 0x00, 0xFF)},
+		{"LightMagenta",    RGB(0xFF, 0xA0, 0xFF)},
+		{"Brown",	    RGB(0x80, 0x40, 0x40)},
+		{"Yellow",	    RGB(0xFF, 0xFF, 0x00)},
+		{"LightYellow",	    RGB(0xFF, 0xFF, 0xA0)},
+		{"DarkYellow",	    RGB(0xBB, 0xBB, 0x00)},
+		{"SeaGreen",	    RGB(0x2E, 0x8B, 0x57)},
+		{"Orange",	    RGB(0xFF, 0xA5, 0x00)},
+		{"Purple",	    RGB(0xA0, 0x20, 0xF0)},
+		{"SlateBlue",	    RGB(0x6A, 0x5A, 0xCD)},
+		{"Violet",	    RGB(0xEE, 0x82, 0xEE)},
+		// NOTE: some entries are zero-allocated for NDDYNAMIC_COLORS
+		//		 in this table!
+	};
+
+	static int endColour = NSTATIC_COLOURS;
+	static int newColour = NSTATIC_COLOURS;
+
+	int		    r, g, b;
+	int		    i;
+
+	if (name[0] == '#' && STRLEN(name) == 7)
+	{
+		/* Name is in "#rrggbb" format */
+		r = hex_digit(name[1]) * 16 + hex_digit(name[2]);
+		g = hex_digit(name[3]) * 16 + hex_digit(name[4]);
+		b = hex_digit(name[5]) * 16 + hex_digit(name[6]);
+		if (r < 0 || g < 0 || b < 0)
+			return INVALCOLOR;
+		return RGB(r, g, b);
+	}
+	else
+	{
+		/* Check if the name is one of the colours we know */
+		for (i = 0; i < endColour; i++)
+			if (STRICMP(name, table[i].name) == 0)
+				return table[i].colour;
+	}
+
+	/*
+	 * Last attempt. Look in the file "$VIMRUNTIME/rgb.txt".
+	 */
+	{
+#define LINE_LEN 100
+		FILE	*fd;
+		char	line[LINE_LEN];
+		char_u	*fname;
+
+		fname = expand_env_save((char_u *)"$VIMRUNTIME/rgb.txt");
+		if (fname == NULL)
+			return INVALCOLOR;
+
+		fd = fopen((char *)fname, "rt");
+		vim_free(fname);
+		if (fd == NULL)
+			return INVALCOLOR;
+
+		while (!feof(fd))
+		{
+			int	    len;
+			int	    pos;
+			char    *colour;
+
+			fgets(line, LINE_LEN, fd);
+			len = strlen(line);
+
+			if (len <= 1 || line[len-1] != '\n')
+				continue;
+
+			line[len-1] = '\0';
+
+			i = sscanf(line, "%d %d %d %n", &r, &g, &b, &pos);
+			if (i != 3)
+				continue;
+
+			colour = line + pos;
+
+			if (STRICMP(colour, name) == 0)
+			{
+				fclose(fd);
+				/*
+				 * Now remember this colour in the table.
+				 * A LRU scheme might be better but this is simpler.
+				 * Or could use a growing array.
+				 */
+				guicolor_T gcolour = RGB(r,g,b);
+
+				//NOTE: see note above in table allocation! We are working here with
+				//		dynamically allocated names, not constant ones!
+				vim_free((char*)table[newColour].name);
+				table[newColour].name = (char *)vim_strsave((char_u *)colour);
+				table[newColour].colour = gcolour;
+
+				newColour++;
+				if (newColour >= NCOLOURS)
+					newColour = NSTATIC_COLOURS;
+				if (endColour < NCOLOURS)
+					endColour = newColour;
+
+				return gcolour;
+			}
+		}
+
+		fclose(fd);
+	}
+
+	return INVALCOLOR;
+}
+
+/*
+ * Set the current text foreground color.
+ */
+void
+gui_mch_set_fg_color(
+		guicolor_T	color)
+{
+	rgb_color rgb = GUI_TO_RGB(color);
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->SetHighColor(rgb);
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Set the current text background color.
+ */
+void
+gui_mch_set_bg_color(
+		guicolor_T	color)
+{
+	rgb_color rgb = GUI_TO_RGB(color);
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->SetLowColor(rgb);
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Set the current text special color.
+ */
+	void
+gui_mch_set_sp_color(guicolor_T	color)
+{
+	//prev_sp_color = color;
+}
+
+void
+gui_mch_draw_string(
+		int		row,
+		int		col,
+		char_u	*s,
+		int		len,
+		int		flags)
+{
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->mchDrawString(row, col, s, len, flags);
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Return OK if the key with the termcap name "name" is supported.
+ */
+int
+gui_mch_haskey(
+		char_u	*name)
+{
+	int i;
+
+	for (i = 0; special_keys[i].BeKeys != 0; i++)
+		if (name[0] == special_keys[i].vim_code0 &&
+				name[1] == special_keys[i].vim_code1)
+			return OK;
+	return FAIL;
+}
+
+	void
+gui_mch_beep()
+{
+	::beep();
+}
+
+	void
+gui_mch_flash(int msec)
+{
+	/* Do a visual beep by reversing the foreground and background colors */
+
+	if (gui.vimWindow->Lock()) {
+		BRect rect = gui.vimTextArea->Bounds();
+
+		gui.vimTextArea->SetDrawingMode(B_OP_INVERT);
+		gui.vimTextArea->FillRect(rect);
+		gui.vimTextArea->Sync();
+		snooze(msec * 1000);	 /* wait for a few msec */
+		gui.vimTextArea->FillRect(rect);
+		gui.vimTextArea->SetDrawingMode(B_OP_COPY);
+		gui.vimTextArea->Flush();
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Invert a rectangle from row r, column c, for nr rows and nc columns.
+ */
+void
+gui_mch_invert_rectangle(
+		int		r,
+		int		c,
+		int		nr,
+		int		nc)
+{
+	BRect rect;
+	rect.left = FILL_X(c);
+	rect.top = FILL_Y(r);
+	rect.right = rect.left + nc * gui.char_width - PEN_WIDTH;
+	rect.bottom = rect.top + nr * gui.char_height - PEN_WIDTH;
+
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->SetDrawingMode(B_OP_INVERT);
+		gui.vimTextArea->FillRect(rect);
+		gui.vimTextArea->SetDrawingMode(B_OP_COPY);
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Iconify the GUI window.
+ */
+	void
+gui_mch_iconify()
+{
+	if (gui.vimWindow->Lock()) {
+		gui.vimWindow->Minimize(true);
+		gui.vimWindow->Unlock();
+	}
+}
+
+#if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Bring the Vim window to the foreground.
+ */
+	void
+gui_mch_set_foreground()
+{
+	/* TODO */
+}
+#endif
+
+/*
+ * Set the window title
+ */
+void
+gui_mch_settitle(
+		char_u	*title,
+		char_u	*icon)
+{
+	if (gui.vimWindow->Lock()) {
+		gui.vimWindow->SetTitle((char *)title);
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Draw a cursor without focus.
+ */
+	void
+gui_mch_draw_hollow_cursor(guicolor_T color)
+{
+	gui_mch_set_fg_color(color);
+
+	BRect r;
+	r.left = FILL_X(gui.col);
+	r.top = FILL_Y(gui.row);
+#ifdef FEAT_MBYTE
+	int cells = utf_off2cells(LineOffset[gui.row] + gui.col, 100); //TODO-TODO
+	if(cells>=4) cells = 1;
+	r.right = r.left + cells*gui.char_width - PEN_WIDTH;
+#else
+	r.right = r.left + gui.char_width - PEN_WIDTH;
+#endif
+	r.bottom = r.top + gui.char_height - PEN_WIDTH;
+
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->StrokeRect(r);
+		gui.vimWindow->Unlock();
+		//gui_mch_flush();
+	}
+}
+
+/*
+ * Draw part of a cursor, only w pixels wide, and h pixels high.
+ */
+void
+gui_mch_draw_part_cursor(
+		int		w,
+		int		h,
+		guicolor_T	color)
+{
+	gui_mch_set_fg_color(color);
+
+	BRect r;
+	r.left =
+#ifdef FEAT_RIGHTLEFT
+		/* vertical line should be on the right of current point */
+		CURSOR_BAR_RIGHT ? FILL_X(gui.col + 1) - w :
+#endif
+		FILL_X(gui.col);
+	r.right = r.left + w - PEN_WIDTH;
+	r.bottom = FILL_Y(gui.row + 1) - PEN_WIDTH;
+	r.top = r.bottom - h + PEN_WIDTH;
+
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->FillRect(r);
+		gui.vimWindow->Unlock();
+		//gui_mch_flush();
+	}
+}
+
+/*
+ * Catch up with any queued events.  This may put keyboard input into the
+ * input buffer, call resize call-backs, trigger timers etc.  If there is
+ * nothing in the event queue (& no timers pending), then we return
+ * immediately.
+ */
+	void
+gui_mch_update()
+{
+	gui_mch_flush();
+	while (port_count(gui.vdcmp) > 0 &&
+			!vim_is_input_buf_full() &&
+			gui_haiku_process_event(0) >= B_OK)
+		/* nothing */ ;
+}
+
+/*
+ * GUI input routine called by gui_wait_for_chars().  Waits for a character
+ * from the keyboard.
+ *	wtime == -1		Wait forever.
+ *	wtime == 0		This should never happen.
+ *	wtime > 0		Wait wtime milliseconds for a character.
+ * Returns OK if a character was found to be available within the given time,
+ * or FAIL otherwise.
+ */
+int
+gui_mch_wait_for_chars(
+		int		wtime)
+{
+	int		    focus;
+	bigtime_t	    until, timeout;
+	status_t	    st;
+
+	if (wtime >= 0) {
+		timeout = wtime * 1000;
+		until = system_time() + timeout;
+	} else {
+		timeout = B_INFINITE_TIMEOUT;
+	}
+
+	focus = gui.in_focus;
+	for (;;)
+	{
+		/* Stop or start blinking when focus changes */
+		if (gui.in_focus != focus)
+		{
+			if (gui.in_focus)
+				gui_mch_start_blink();
+			else
+				gui_mch_stop_blink();
+			focus = gui.in_focus;
+		}
+
+		gui_mch_flush();
+		/*
+		 * Don't use gui_mch_update() because then we will spin-lock until a
+		 * char arrives, instead we use gui_haiku_process_event() to hang until
+		 * an event arrives.  No need to check for input_buf_full because we
+		 * are returning as soon as it contains a single char.
+		 */
+		st = gui_haiku_process_event(timeout);
+
+		if (input_available())
+			return OK;
+		if (st < B_OK)		    /* includes B_TIMED_OUT */
+			return FAIL;
+
+		/*
+		 * Calculate how much longer we're willing to wait for the
+		 * next event.
+		 */
+		if (wtime >= 0) {
+			timeout = until - system_time();
+			if (timeout < 0)
+				break;
+		}
+	}
+	return FAIL;
+
+}
+
+/*
+ * Output routines.
+ */
+
+/*
+ * Flush any output to the screen. This is typically called before
+ * the app goes to sleep.
+ */
+	void
+gui_mch_flush()
+{
+	// does this need to lock the window? Apparently not but be safe.
+	if (gui.vimWindow->Lock()) {
+		gui.vimWindow->Flush();
+		gui.vimWindow->Unlock();
+	}
+	return;
+}
+
+/*
+ * Clear a rectangular region of the screen from text pos (row1, col1) to
+ * (row2, col2) inclusive.
+ */
+void
+gui_mch_clear_block(
+		int		row1,
+		int		col1,
+		int		row2,
+		int		col2)
+{
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->mchClearBlock(row1, col1, row2, col2);
+		gui.vimWindow->Unlock();
+	}
+}
+
+	void
+gui_mch_clear_all()
+{
+	if (gui.vimWindow->Lock()) {
+		gui.vimTextArea->mchClearAll();
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Delete the given number of lines from the given row, scrolling up any
+ * text further down within the scroll region.
+ */
+void
+gui_mch_delete_lines(
+		int		row,
+		int		num_lines)
+{
+	gui.vimTextArea->mchDeleteLines(row, num_lines);
+}
+
+/*
+ * Insert the given number of lines before the given row, scrolling down any
+ * following text within the scroll region.
+ */
+void
+gui_mch_insert_lines(
+		int		row,
+		int		num_lines)
+{
+	gui.vimTextArea->mchInsertLines(row, num_lines);
+}
+
+#if defined(FEAT_MENU) || defined(PROTO)
+/*
+ * Menu stuff.
+ */
+
+void
+gui_mch_enable_menu(
+		int		flag)
+{
+	if (gui.vimWindow->Lock())
+	{
+		BMenuBar *menubar = gui.vimForm->MenuBar();
+		menubar->SetEnabled(flag);
+		gui.vimWindow->Unlock();
+	}
+}
+
+void
+gui_mch_set_menu_pos(
+		int		x,
+		int		y,
+		int		w,
+		int		h)
+{
+	/* It will be in the right place anyway */
+}
+
+/*
+ * Add a sub menu to the menu bar.
+ */
+void
+gui_mch_add_menu(
+		vimmenu_T	*menu,
+		int		idx)
+{
+	vimmenu_T	*parent = menu->parent;
+
+	// popup menu - just create it unattached
+	if (menu_is_popup(menu->name) && parent == NULL) {
+		BPopUpMenu* popUpMenu = new BPopUpMenu((const char*)menu->name, false, false);
+		menu->submenu_id = popUpMenu;
+		menu->id = NULL;
+		return;
+	}
+
+	if (!menu_is_menubar(menu->name)
+			|| (parent != NULL && parent->submenu_id == NULL))
+		return;
+
+	if (gui.vimWindow->Lock())
+	{
+		/* Major re-write of the menu code, it was failing with memory corruption when
+		 * we started loading multiple files (the Buffer menu)
+		 *
+		 * Note we don't use the preference values yet, all are inserted into the
+		 * menubar on a first come-first served basis...
+		 *
+		 * richard@whitequeen.com jul 99
+		 */
+
+		BMenu *tmp;
+
+		if ( parent )
+			tmp = parent->submenu_id;
+		else
+			tmp = gui.vimForm->MenuBar();
+		// make sure we don't try and add the same menu twice. The Buffers menu tries to
+		// do this and Be starts to crash...
+
+		if ( ! tmp->FindItem((const char *) menu->dname)) {
+
+			BMenu *bmenu = new BMenu((char *)menu->dname);
+
+			menu->submenu_id = bmenu;
+
+			// when we add a BMenu to another Menu, it creates the interconnecting BMenuItem
+			tmp->AddItem(bmenu);
+
+			// Now its safe to query the menu for the associated MenuItem....
+			menu->id = tmp->FindItem((const char *) menu->dname);
+
+		}
+		gui.vimWindow->Unlock();
+	}
+}
+
+	void
+gui_mch_toggle_tearoffs(int enable)
+{
+	/* no tearoff menus */
+}
+
+	static BMessage *
+MenuMessage(vimmenu_T *menu)
+{
+	BMessage *m = new BMessage('menu');
+	m->AddPointer("VimMenu", (void *)menu);
+
+	return m;
+}
+
+/*
+ * Add a menu item to a menu
+ */
+void
+gui_mch_add_menu_item(
+		vimmenu_T	*menu,
+		int		idx)
+{
+	int		mnemonic = 0;
+	vimmenu_T	*parent = menu->parent;
+
+	/* TODO: use menu->actext */
+	/* This is difficult, since on Be, an accelerator must be a single char
+	 * and a lot of Vim ones are the standard VI commands.
+	 *
+	 * Punt for Now...
+	 * richard@whiequeen.com jul 99
+	 */
+	if (gui.vimWindow->Lock())
+	{
+#ifdef FEAT_TOOLBAR
+		if(menu_is_toolbar(parent->name)) {
+			VimToolbar *toolbar = gui.vimForm->ToolBar();
+			if(toolbar != NULL) {
+				toolbar->AddButton(idx, menu);
+			}
+		} else
+#endif
+
+		if (parent->submenu_id != NULL || menu_is_popup(parent->name)) {
+			if (menu_is_separator(menu->name)) {
+				BSeparatorItem *item = new BSeparatorItem();
+				parent->submenu_id->AddItem(item);
+				menu->id = item;
+				menu->submenu_id = NULL;
+			}
+			else {
+				BMenuItem *item = new BMenuItem((char *)menu->dname,
+						MenuMessage(menu));
+				item->SetTarget(gui.vimTextArea);
+				item->SetTrigger((char) menu->mnemonic);
+				parent->submenu_id->AddItem(item);
+				menu->id = item;
+				menu->submenu_id = NULL;
+			}
+		}
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Destroy the machine specific menu widget.
+ */
+void
+gui_mch_destroy_menu(
+		vimmenu_T	*menu)
+{
+	if (gui.vimWindow->Lock())
+	{
+#ifdef FEAT_TOOLBAR
+		if(menu->parent && menu_is_toolbar(menu->parent->name)) {
+			VimToolbar *toolbar = gui.vimForm->ToolBar();
+			if(toolbar != NULL) {
+				toolbar->RemoveButton(menu);
+			}
+		} else
+#endif
+		{
+			assert(menu->submenu_id == NULL || menu->submenu_id->CountItems() == 0);
+			/*
+			 * Detach this menu from its parent, so that it is not deleted
+			 * twice once we get to delete that parent.
+			 * Deleting a BMenuItem also deletes the associated BMenu, if any
+			 * (which does not have any items anymore since they were
+			 * removed and deleted before).
+			 */
+			BMenu *bmenu = menu->id->Menu();
+			if (bmenu)
+			{
+				bmenu->RemoveItem(menu->id);
+				/*
+				 * If we removed the last item from the menu bar,
+				 * resize it out of sight.
+				 */
+				if (bmenu == gui.vimForm->MenuBar() && bmenu->CountItems() == 0)
+				{
+					bmenu->ResizeTo(-MENUBAR_MARGIN, -MENUBAR_MARGIN);
+				}
+			}
+			delete menu->id;
+			menu->id = NULL;
+			menu->submenu_id = NULL;
+
+			gui.menu_height = (int) gui.vimForm->MenuHeight();
+		}
+		gui.vimWindow->Unlock();
+	}
+}
+
+/*
+ * Make a menu either grey or not grey.
+ */
+void
+gui_mch_menu_grey(
+		vimmenu_T	*menu,
+		int		grey)
+{
+#ifdef FEAT_TOOLBAR
+	if(menu->parent && menu_is_toolbar(menu->parent->name)) {
+		if (gui.vimWindow->Lock()) {
+			VimToolbar *toolbar = gui.vimForm->ToolBar();
+			if(toolbar != NULL) {
+				toolbar->GrayButton(menu, grey);
+			}
+			gui.vimWindow->Unlock();
+		}
+	} else
+#endif
+	if (menu->id != NULL)
+		menu->id->SetEnabled(!grey);
+}
+
+/*
+ * Make menu item hidden or not hidden
+ */
+void
+gui_mch_menu_hidden(
+		vimmenu_T	*menu,
+		int		hidden)
+{
+	if (menu->id != NULL)
+		menu->id->SetEnabled(!hidden);
+}
+
+/*
+ * This is called after setting all the menus to grey/hidden or not.
+ */
+	void
+gui_mch_draw_menubar()
+{
+	/* Nothing to do in BeOS */
+}
+
+	void
+gui_mch_show_popupmenu(vimmenu_T *menu)
+{
+	if (!menu_is_popup(menu->name) || menu->submenu_id == NULL)
+		return;
+
+	BPopUpMenu* popupMenu = dynamic_cast<BPopUpMenu*>(menu->submenu_id);
+	if (popupMenu == NULL)
+		return;
+
+	BPoint point;
+	if(gui.vimWindow->Lock()) {
+		uint32 buttons = 0;
+		gui.vimTextArea->GetMouse(&point, &buttons);
+		gui.vimTextArea->ConvertToScreen(&point);
+		gui.vimWindow->Unlock();
+	}
+	popupMenu->Go(point, true);
+}
+
+#endif /* FEAT_MENU */
+
+/* Mouse stuff */
+
+#ifdef FEAT_CLIPBOARD
+/*
+ * Clipboard stuff, for cutting and pasting text to other windows.
+ */
+char textplain[] = "text/plain";
+char vimselectiontype[] = "application/x-vnd.Rhialto-Vim-selectiontype";
+
+/*
+ * Get the current selection and put it in the clipboard register.
+ */
+	void
+clip_mch_request_selection(VimClipboard *cbd)
+{
+	if (be_clipboard->Lock())
+	{
+		BMessage *m = be_clipboard->Data();
+		//m->PrintToStream();
+
+		char_u *string = NULL;
+		ssize_t stringlen = -1;
+
+		if (m->FindData(textplain, B_MIME_TYPE,
+					(const void **)&string, &stringlen) == B_OK
+				|| m->FindString("text", (const char **)&string) == B_OK)
+		{
+			if (stringlen == -1)
+				stringlen = STRLEN(string);
+
+			int type;
+			char *seltype;
+			ssize_t seltypelen;
+
+			/*
+			 * Try to get the special vim selection type first
+			 */
+			if (m->FindData(vimselectiontype, B_MIME_TYPE,
+						(const void **)&seltype, &seltypelen) == B_OK)
+			{
+				switch (*seltype)
+				{
+					default:
+					case 'L':	type = MLINE;	break;
+					case 'C':	type = MCHAR;	break;
+#ifdef FEAT_VISUAL
+					case 'B':	type = MBLOCK;	break;
+#endif
+				}
+			}
+			else
+			{
+				/* Otherwise use heuristic as documented */
+				type = memchr(string, stringlen, '\n') ? MLINE : MCHAR;
+			}
+			clip_yank_selection(type, string, (long)stringlen, cbd);
+		}
+		be_clipboard->Unlock();
+	}
+}
+/*
+ * Make vim the owner of the current selection.
+ */
+	void
+clip_mch_lose_selection(VimClipboard *cbd)
+{
+	/* Nothing needs to be done here */
+}
+
+/*
+ * Make vim the owner of the current selection.  Return OK upon success.
+ */
+	int
+clip_mch_own_selection(VimClipboard *cbd)
+{
+	/*
+	 * Never actually own the clipboard.  If another application sets the
+	 * clipboard, we don't want to think that we still own it.
+	 */
+	return FAIL;
+}
+
+/*
+ * Send the current selection to the clipboard.
+ */
+	void
+clip_mch_set_selection(VimClipboard *cbd)
+{
+	if (be_clipboard->Lock())
+	{
+		be_clipboard->Clear();
+		BMessage *m = be_clipboard->Data();
+		assert(m);
+
+		/* If the '*' register isn't already filled in, fill it in now */
+		cbd->owned = TRUE;
+		clip_get_selection(cbd);
+		cbd->owned = FALSE;
+
+		char_u  *str = NULL;
+		long_u  count;
+		int	type;
+
+		type = clip_convert_selection(&str, &count, cbd);
+
+		if (type < 0)
+			return;
+
+		m->AddData(textplain, B_MIME_TYPE, (void *)str, count);
+
+		/* Add type of selection */
+		char    vtype;
+		switch (type)
+		{
+			default:
+			case MLINE:    vtype = 'L';    break;
+			case MCHAR:    vtype = 'C';    break;
+#ifdef FEAT_VISUAL
+			case MBLOCK:   vtype = 'B';    break;
+#endif
+		}
+		m->AddData(vimselectiontype, B_MIME_TYPE, (void *)&vtype, 1);
+
+		vim_free(str);
+
+		be_clipboard->Commit();
+		be_clipboard->Unlock();
+	}
+}
+
+#endif	/* FEAT_CLIPBOARD */
+
+#ifdef FEAT_BROWSE
+/*
+ * Pop open a file browser and return the file selected, in allocated memory,
+ * or NULL if Cancel is hit.
+ *  saving  - TRUE if the file will be saved to, FALSE if it will be opened.
+ *  title   - Title message for the file browser dialog.
+ *  dflt    - Default name of file.
+ *  ext     - Default extension to be added to files without extensions.
+ *  initdir - directory in which to open the browser (NULL = current dir)
+ *  filter  - Filter for matched files to choose from.
+ *  Has a format like this:
+ *  "C Files (*.c)\0*.c\0"
+ *  "All Files\0*.*\0\0"
+ *  If these two strings were concatenated, then a choice of two file
+ *  filters will be selectable to the user.  Then only matching files will
+ *  be shown in the browser.  If NULL, the default allows all files.
+ *
+ *  *NOTE* - the filter string must be terminated with TWO nulls.
+ */
+char_u *
+gui_mch_browse(
+		int saving,
+		char_u *title,
+		char_u *dflt,
+		char_u *ext,
+		char_u *initdir,
+		char_u *filter)
+{
+	gui.vimApp->fFilePanel = new BFilePanel((saving == TRUE) ? B_SAVE_PANEL : B_OPEN_PANEL,
+			NULL, NULL, 0, false,
+			new BMessage((saving == TRUE) ? 'save' : 'open'), NULL, true);
+
+	gui.vimApp->fBrowsedPath.Unset();
+
+	gui.vimApp->fFilePanel->Window()->SetTitle((char*)title);
+	gui.vimApp->fFilePanel->SetPanelDirectory((const char*)initdir);
+
+	gui.vimApp->fFilePanel->Show();
+
+	gui.vimApp->fFilePanelSem = create_sem(0, "FilePanelSem");
+
+	while(acquire_sem(gui.vimApp->fFilePanelSem) == B_INTERRUPTED);
+
+	char_u *fileName = NULL;
+	status_t result = gui.vimApp->fBrowsedPath.InitCheck();
+	if(result == B_OK) {
+		fileName = vim_strsave((char_u*)gui.vimApp->fBrowsedPath.Path());
+	} else
+		if(result != B_NO_INIT) {
+			fprintf(stderr, "gui_mch_browse: BPath error: %#08x (%s)\n",
+					result, strerror(result));
+		}
+
+	delete gui.vimApp->fFilePanel;
+	gui.vimApp->fFilePanel = NULL;
+
+	return fileName;
+}
+#endif /* FEAT_BROWSE */
+
+
+#if defined(FEAT_GUI_DIALOG)
+
+/*
+ * Create a dialog dynamically from the parameter strings.
+ * type		= type of dialog (question, alert, etc.)
+ * title	= dialog title. may be NULL for default title.
+ * message	= text to display. Dialog sizes to accommodate it.
+ * buttons	= '\n' separated list of button captions, default first.
+ * dfltbutton	= number of default button.
+ *
+ * This routine returns 1 if the first button is pressed,
+ *			2 for the second, etc.
+ *
+ *			0 indicates Esc was pressed.
+ *			-1 for unexpected error
+ *
+ * If stubbing out this fn, return 1.
+ */
+
+int
+gui_mch_dialog(
+		int		 type,
+		char_u	*title,
+		char_u	*message,
+		char_u	*buttons,
+		int		 dfltbutton,
+		char_u	*textfield,
+		int ex_cmd)
+{
+	VimDialog *dialog = new VimDialog(type, (char*)title, (char*)message,
+			(char*)buttons, dfltbutton, (char*)textfield, ex_cmd);
+	return dialog->Go();
+}
+
+#endif /* FEAT_GUI_DIALOG */
+
+
+/*
+ * Return the RGB value of a pixel as long.
+ */
+    guicolor_T
+gui_mch_get_rgb(guicolor_T pixel)
+{
+	rgb_color rgb = GUI_TO_RGB(pixel);
+
+	return ((rgb.red & 0xff) << 16) + ((rgb.green & 0xff) << 8)
+		+ (rgb.blue & 0xff);
+}
+
+	void
+gui_mch_setmouse(int x, int y)
+{
+	TRACE();
+	/* TODO */
+}
+
+#ifdef FEAT_MBYTE_IME
+	void
+im_set_position(int row, int col)
+{
+	if(gui.vimWindow->Lock())
+	{
+		gui.vimTextArea->DrawIMString();
+		gui.vimWindow->Unlock();
+	}
+	return;
+}
+
+	void
+im_set_active(int activate)
+{
+	//TODO:
+#if 0
+	if(activate)
+		printf("IME ON\n");
+	else
+		printf("IME OFF\n");
+#endif
+	return;
+}
+
+	int
+im_get_status()
+{
+	//TODO:
+	return(1);
+}
+#endif
+
+	void
+gui_mch_show_toolbar(int showit)
+{
+	VimToolbar *toolbar = gui.vimForm->ToolBar();
+	gui.toolbar_height = (toolbar && showit) ? toolbar->ToolbarHeight() : 0.;
+}
+
+	void
+gui_mch_set_toolbar_pos(int x, int y, int w, int h)
+{
+	VimToolbar *toolbar = gui.vimForm->ToolBar();
+	if(toolbar != NULL) {
+		if (gui.vimWindow->Lock()) {
+			toolbar->MoveTo(x, y);
+			toolbar->ResizeTo(w - 1, h - 1);
+			gui.vimWindow->Unlock();
+		}
+	}
+}
+
+#if defined(FEAT_GUI_TABLINE) || defined(PROTO)
+
+/*
+ * Show or hide the tabline.
+ */
+    void
+gui_mch_show_tabline(int showit)
+{
+	VimTabLine *tabLine = gui.vimForm->TabLine();
+
+    if (tabLine == NULL)
+		return;
+
+    if (!showit != !gui.vimForm->IsShowingTabLine()) {
+		gui.vimForm->SetShowingTabLine(showit != 0);
+		gui.tabline_height = gui.vimForm->TablineHeight();
+    }
+}
+
+	void
+gui_mch_set_tabline_pos(int x, int y, int w, int h)
+{
+	VimTabLine *tabLine = gui.vimForm->TabLine();
+	if(tabLine != NULL) {
+		if (gui.vimWindow->Lock()) {
+			tabLine->MoveTo(x, y);
+			tabLine->ResizeTo(w - 1, h - 1);
+			gui.vimWindow->Unlock();
+		}
+	}
+}
+
+/*
+ * Return TRUE when tabline is displayed.
+ */
+    int
+gui_mch_showing_tabline()
+{
+	VimTabLine *tabLine = gui.vimForm->TabLine();
+    return tabLine != NULL && gui.vimForm->IsShowingTabLine();
+}
+
+/*
+ * Update the labels of the tabline.
+ */
+    void
+gui_mch_update_tabline()
+{
+    tabpage_T	*tp;
+    int		nr = 0;
+    int		curtabidx = 0;
+
+	VimTabLine *tabLine = gui.vimForm->TabLine();
+
+    if (tabLine == NULL)
+		return;
+
+	gui.vimWindow->Lock();
+
+    /* Add a label for each tab page.  They all contain the same text area. */
+    for (tp = first_tabpage; tp != NULL; tp = tp->tp_next, ++nr) {
+		if (tp == curtab)
+		    curtabidx = nr;
+
+		BTab* tab = tabLine->TabAt(nr);
+
+		if (tab == NULL) {
+			tab = new VimTabLine::VimTab();
+			tabLine->AddTab(NULL, tab);
+		}
+
+		get_tabline_label(tp, FALSE);
+		tab->SetLabel((const char*)NameBuff);
+		tabLine->Invalidate();
+    }
+
+    /* Remove any old labels. */
+	while (nr < tabLine->CountTabs())
+		tabLine->RemoveTab(nr);
+
+	if(tabLine->Selection() != curtabidx)
+		tabLine->Select(curtabidx);
+
+	gui.vimWindow->Unlock();
+}
+
+/*
+ * Set the current tab to "nr".  First tab is 1.
+ */
+    void
+gui_mch_set_curtab(int nr)
+{
+	VimTabLine *tabLine = gui.vimForm->TabLine();
+	if(tabLine == NULL)
+		return;
+
+	gui.vimWindow->Lock();
+
+	if(tabLine->Selection() != nr -1)
+		tabLine->Select(nr -1);
+
+	gui.vimWindow->Unlock();
+}
+
+#endif //FEAT_GUI_TABLINE
diff --git a/b/src/gui_haiku.h b/src/gui_haiku.h
new file mode 100644
index 0000000..414d127
--- /dev/null
+++ b/src/gui_haiku.h
@@ -0,0 +1,51 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved		by Bram Moolenaar
+ *				GUI support by Olaf "Rhialto" Seibert
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ *
+ * Haiku GUI.
+ *
+ * Based on "GUI support for the Buzzword Enhanced Operating System for PPC."
+ *
+ */
+
+/*
+ * This file must be acceptable both as C and C++.
+ * The BeOS API is defined in terms of C++, but some classes
+ * should be somewhat known in the common C code.
+ */
+
+/* System classes */
+
+struct BMenu;
+struct BMenuItem;
+struct BPictureButton;
+
+/* Our own Vim-related classes */
+
+struct VimApp;
+struct VimFormView;
+struct VimTextAreaView;
+struct VimWindow;
+struct VimScrollBar;
+
+/* Locking functions */
+
+extern int vim_lock_screen();
+extern void vim_unlock_screen();
+
+#ifndef __cplusplus
+
+typedef struct BMenu BMenu;
+typedef struct BMenuItem BMenuItem;
+typedef struct BPictureButton BPictureButton;
+typedef struct VimWindow VimWindow;
+typedef struct VimFormView VimFormView;
+typedef struct VimTextAreaView VimTextAreaView;
+typedef struct VimApp VimApp;
+typedef struct VimScrollBar VimScrollBar;
+
+#endif
diff --git a/src/misc1.c b/src/misc1.c
index dca599f..1a71fe7 100644
--- a/src/misc1.c
+++ b/src/misc1.c
@@ -18,6 +18,10 @@
 # include <lm.h>
 #endif
 
+#if defined(__HAIKU__)
+#include <storage/FindDirectory.h>
+#endif
+
 static char_u *vim_version_dir(char_u *vimdir);
 static char_u *remove_tail(char_u *p, char_u *pend, char_u *name);
 #if defined(FEAT_CMDL_COMPL)
@@ -4412,7 +4416,16 @@ vim_getenv(char_u *name, int *mustfree)
 
     vimruntime = (STRCMP(name, "VIMRUNTIME") == 0);
     if (!vimruntime && STRCMP(name, "VIM") != 0)
-	return NULL;
+#if defined(__HAIKU__)
+		// special handling for user settings directory...
+		if(STRCMP(name, "BE_USER_SETTINGS") == 0) {
+			static char userSettingsPath[MAXPATHL] = {0};
+			if(B_OK == find_directory(B_USER_SETTINGS_DIRECTORY, 0,
+										false, userSettingsPath, MAXPATHL))
+				return userSettingsPath;
+		} else
+#endif
+		return NULL;
 
     /*
      * When expanding $VIMRUNTIME fails, try using $VIM/vim<version> or $VIM.
diff --git a/b/src/misc1.c.orig b/src/misc1.c.orig
new file mode 100644
index 0000000..dca599f
--- /dev/null
+++ b/src/misc1.c.orig
@@ -0,0 +1,11535 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * misc1.c: functions that didn't seem to fit elsewhere
+ */
+
+#include "vim.h"
+#include "version.h"
+
+#if defined(FEAT_CMDL_COMPL) && defined(WIN3264)
+# include <lm.h>
+#endif
+
+static char_u *vim_version_dir(char_u *vimdir);
+static char_u *remove_tail(char_u *p, char_u *pend, char_u *name);
+#if defined(FEAT_CMDL_COMPL)
+static void init_users(void);
+#endif
+static int copy_indent(int size, char_u	*src);
+
+/* All user names (for ~user completion as done by shell). */
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+static garray_T	ga_users;
+#endif
+
+/*
+ * Count the size (in window cells) of the indent in the current line.
+ */
+    int
+get_indent(void)
+{
+#ifdef FEAT_VARTABS
+    return get_indent_str_vtab(ml_get_curline(), (int)curbuf->b_p_ts,
+						 curbuf->b_p_vts_array, FALSE);
+#else
+    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);
+#endif
+}
+
+/*
+ * Count the size (in window cells) of the indent in line "lnum".
+ */
+    int
+get_indent_lnum(linenr_T lnum)
+{
+#ifdef FEAT_VARTABS
+    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,
+						 curbuf->b_p_vts_array, FALSE);
+#else
+    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);
+#endif
+}
+
+#if defined(FEAT_FOLDING) || defined(PROTO)
+/*
+ * Count the size (in window cells) of the indent in line "lnum" of buffer
+ * "buf".
+ */
+    int
+get_indent_buf(buf_T *buf, linenr_T lnum)
+{
+#ifdef FEAT_VARTABS
+    return get_indent_str_vtab(ml_get_buf(buf, lnum, FALSE),
+			       (int)curbuf->b_p_ts, buf->b_p_vts_array, FALSE);
+#else
+    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);
+#endif
+}
+#endif
+
+/*
+ * count the size (in window cells) of the indent in line "ptr", with
+ * 'tabstop' at "ts"
+ */
+    int
+get_indent_str(
+    char_u	*ptr,
+    int		ts,
+    int		list) /* if TRUE, count only screen size for tabs */
+{
+    int		count = 0;
+
+    for ( ; *ptr; ++ptr)
+    {
+	if (*ptr == TAB)
+	{
+	    if (!list || lcs_tab1)    /* count a tab for what it is worth */
+		count += ts - (count % ts);
+	    else
+		/* In list mode, when tab is not set, count screen char width
+		 * for Tab, displays: ^I */
+		count += ptr2cells(ptr);
+	}
+	else if (*ptr == ' ')
+	    ++count;		/* count a space for one */
+	else
+	    break;
+    }
+    return count;
+}
+
+#ifdef FEAT_VARTABS
+/*
+ * Count the size (in window cells) of the indent in line "ptr", using
+ * variable tabstops.
+ * if "list" is TRUE, count only screen size for tabs.
+ */
+    int
+get_indent_str_vtab(char_u *ptr, int ts, int *vts, int list)
+{
+    int		count = 0;
+
+    for ( ; *ptr; ++ptr)
+    {
+	if (*ptr == TAB)    /* count a tab for what it is worth */
+	{
+	    if (!list || lcs_tab1)
+		count += tabstop_padding(count, ts, vts);
+	    else
+		/* In list mode, when tab is not set, count screen char width
+		 * for Tab, displays: ^I */
+		count += ptr2cells(ptr);
+	}
+	else if (*ptr == ' ')
+	    ++count;		/* count a space for one */
+	else
+	    break;
+    }
+    return count;
+}
+#endif
+
+/*
+ * Set the indent of the current line.
+ * Leaves the cursor on the first non-blank in the line.
+ * Caller must take care of undo.
+ * "flags":
+ *	SIN_CHANGED:	call changed_bytes() if the line was changed.
+ *	SIN_INSERT:	insert the indent in front of the line.
+ *	SIN_UNDO:	save line for undo before changing it.
+ * Returns TRUE if the line was changed.
+ */
+    int
+set_indent(
+    int		size,		    /* measured in spaces */
+    int		flags)
+{
+    char_u	*p;
+    char_u	*newline;
+    char_u	*oldline;
+    char_u	*s;
+    int		todo;
+    int		ind_len;	    /* measured in characters */
+    int		line_len;
+    int		doit = FALSE;
+    int		ind_done = 0;	    /* measured in spaces */
+#ifdef FEAT_VARTABS
+    int		ind_col = 0;
+#endif
+    int		tab_pad;
+    int		retval = FALSE;
+    int		orig_char_len = -1; /* number of initial whitespace chars when
+				       'et' and 'pi' are both set */
+
+    /*
+     * First check if there is anything to do and compute the number of
+     * characters needed for the indent.
+     */
+    todo = size;
+    ind_len = 0;
+    p = oldline = ml_get_curline();
+
+    /* Calculate the buffer size for the new indent, and check to see if it
+     * isn't already set */
+
+    /* if 'expandtab' isn't set: use TABs; if both 'expandtab' and
+     * 'preserveindent' are set count the number of characters at the
+     * beginning of the line to be copied */
+    if (!curbuf->b_p_et || (!(flags & SIN_INSERT) && curbuf->b_p_pi))
+    {
+	/* If 'preserveindent' is set then reuse as much as possible of
+	 * the existing indent structure for the new indent */
+	if (!(flags & SIN_INSERT) && curbuf->b_p_pi)
+	{
+	    ind_done = 0;
+
+	    /* count as many characters as we can use */
+	    while (todo > 0 && VIM_ISWHITE(*p))
+	    {
+		if (*p == TAB)
+		{
+#ifdef FEAT_VARTABS
+		    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,
+							curbuf->b_p_vts_array);
+#else
+		    tab_pad = (int)curbuf->b_p_ts
+					   - (ind_done % (int)curbuf->b_p_ts);
+#endif
+		    /* stop if this tab will overshoot the target */
+		    if (todo < tab_pad)
+			break;
+		    todo -= tab_pad;
+		    ++ind_len;
+		    ind_done += tab_pad;
+		}
+		else
+		{
+		    --todo;
+		    ++ind_len;
+		    ++ind_done;
+		}
+		++p;
+	    }
+
+#ifdef FEAT_VARTABS
+	    /* These diverge from this point. */
+	    ind_col = ind_done;
+#endif
+	    /* Set initial number of whitespace chars to copy if we are
+	     * preserving indent but expandtab is set */
+	    if (curbuf->b_p_et)
+		orig_char_len = ind_len;
+
+	    /* Fill to next tabstop with a tab, if possible */
+#ifdef FEAT_VARTABS
+	    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,
+						curbuf->b_p_vts_array);
+#else
+	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
+#endif
+	    if (todo >= tab_pad && orig_char_len == -1)
+	    {
+		doit = TRUE;
+		todo -= tab_pad;
+		++ind_len;
+		/* ind_done += tab_pad; */
+#ifdef FEAT_VARTABS
+		ind_col += tab_pad;
+#endif
+	    }
+	}
+
+	/* count tabs required for indent */
+#ifdef FEAT_VARTABS
+	for (;;)
+	{
+	    tab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,
+							curbuf->b_p_vts_array);
+	    if (todo < tab_pad)
+		break;
+	    if (*p != TAB)
+		doit = TRUE;
+	    else
+		++p;
+	    todo -= tab_pad;
+	    ++ind_len;
+	    ind_col += tab_pad;
+	}
+#else
+	while (todo >= (int)curbuf->b_p_ts)
+	{
+	    if (*p != TAB)
+		doit = TRUE;
+	    else
+		++p;
+	    todo -= (int)curbuf->b_p_ts;
+	    ++ind_len;
+	    /* ind_done += (int)curbuf->b_p_ts; */
+	}
+#endif
+    }
+    /* count spaces required for indent */
+    while (todo > 0)
+    {
+	if (*p != ' ')
+	    doit = TRUE;
+	else
+	    ++p;
+	--todo;
+	++ind_len;
+	/* ++ind_done; */
+    }
+
+    /* Return if the indent is OK already. */
+    if (!doit && !VIM_ISWHITE(*p) && !(flags & SIN_INSERT))
+	return FALSE;
+
+    /* Allocate memory for the new line. */
+    if (flags & SIN_INSERT)
+	p = oldline;
+    else
+	p = skipwhite(p);
+    line_len = (int)STRLEN(p) + 1;
+
+    /* If 'preserveindent' and 'expandtab' are both set keep the original
+     * characters and allocate accordingly.  We will fill the rest with spaces
+     * after the if (!curbuf->b_p_et) below. */
+    if (orig_char_len != -1)
+    {
+	newline = alloc(orig_char_len + size - ind_done + line_len);
+	if (newline == NULL)
+	    return FALSE;
+	todo = size - ind_done;
+	ind_len = orig_char_len + todo;    /* Set total length of indent in
+					    * characters, which may have been
+					    * undercounted until now  */
+	p = oldline;
+	s = newline;
+	while (orig_char_len > 0)
+	{
+	    *s++ = *p++;
+	    orig_char_len--;
+	}
+
+	/* Skip over any additional white space (useful when newindent is less
+	 * than old) */
+	while (VIM_ISWHITE(*p))
+	    ++p;
+
+    }
+    else
+    {
+	todo = size;
+	newline = alloc(ind_len + line_len);
+	if (newline == NULL)
+	    return FALSE;
+	s = newline;
+    }
+
+    /* Put the characters in the new line. */
+    /* if 'expandtab' isn't set: use TABs */
+    if (!curbuf->b_p_et)
+    {
+	/* If 'preserveindent' is set then reuse as much as possible of
+	 * the existing indent structure for the new indent */
+	if (!(flags & SIN_INSERT) && curbuf->b_p_pi)
+	{
+	    p = oldline;
+	    ind_done = 0;
+
+	    while (todo > 0 && VIM_ISWHITE(*p))
+	    {
+		if (*p == TAB)
+		{
+#ifdef FEAT_VARTABS
+		    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,
+							curbuf->b_p_vts_array);
+#else
+		    tab_pad = (int)curbuf->b_p_ts
+					   - (ind_done % (int)curbuf->b_p_ts);
+#endif
+		    /* stop if this tab will overshoot the target */
+		    if (todo < tab_pad)
+			break;
+		    todo -= tab_pad;
+		    ind_done += tab_pad;
+		}
+		else
+		{
+		    --todo;
+		    ++ind_done;
+		}
+		*s++ = *p++;
+	    }
+
+	    /* Fill to next tabstop with a tab, if possible */
+#ifdef FEAT_VARTABS
+	    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,
+						curbuf->b_p_vts_array);
+#else
+	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
+#endif
+	    if (todo >= tab_pad)
+	    {
+		*s++ = TAB;
+		todo -= tab_pad;
+#ifdef FEAT_VARTABS
+		ind_done += tab_pad;
+#endif
+	    }
+
+	    p = skipwhite(p);
+	}
+
+#ifdef FEAT_VARTABS
+	for (;;)
+	{
+	    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,
+							curbuf->b_p_vts_array);
+	    if (todo < tab_pad)
+		break;
+	    *s++ = TAB;
+	    todo -= tab_pad;
+	    ind_done += tab_pad;
+	}
+#else
+	while (todo >= (int)curbuf->b_p_ts)
+	{
+	    *s++ = TAB;
+	    todo -= (int)curbuf->b_p_ts;
+	}
+#endif
+    }
+    while (todo > 0)
+    {
+	*s++ = ' ';
+	--todo;
+    }
+    mch_memmove(s, p, (size_t)line_len);
+
+    /* Replace the line (unless undo fails). */
+    if (!(flags & SIN_UNDO) || u_savesub(curwin->w_cursor.lnum) == OK)
+    {
+	ml_replace(curwin->w_cursor.lnum, newline, FALSE);
+	if (flags & SIN_CHANGED)
+	    changed_bytes(curwin->w_cursor.lnum, 0);
+	/* Correct saved cursor position if it is in this line. */
+	if (saved_cursor.lnum == curwin->w_cursor.lnum)
+	{
+	    if (saved_cursor.col >= (colnr_T)(p - oldline))
+		/* cursor was after the indent, adjust for the number of
+		 * bytes added/removed */
+		saved_cursor.col += ind_len - (colnr_T)(p - oldline);
+	    else if (saved_cursor.col >= (colnr_T)(s - newline))
+		/* cursor was in the indent, and is now after it, put it back
+		 * at the start of the indent (replacing spaces with TAB) */
+		saved_cursor.col = (colnr_T)(s - newline);
+	}
+	retval = TRUE;
+    }
+    else
+	vim_free(newline);
+
+    curwin->w_cursor.col = ind_len;
+    return retval;
+}
+
+/*
+ * Copy the indent from ptr to the current line (and fill to size)
+ * Leaves the cursor on the first non-blank in the line.
+ * Returns TRUE if the line was changed.
+ */
+    static int
+copy_indent(int size, char_u *src)
+{
+    char_u	*p = NULL;
+    char_u	*line = NULL;
+    char_u	*s;
+    int		todo;
+    int		ind_len;
+    int		line_len = 0;
+    int		tab_pad;
+    int		ind_done;
+    int		round;
+#ifdef FEAT_VARTABS
+    int		ind_col;
+#endif
+
+    /* Round 1: compute the number of characters needed for the indent
+     * Round 2: copy the characters. */
+    for (round = 1; round <= 2; ++round)
+    {
+	todo = size;
+	ind_len = 0;
+	ind_done = 0;
+#ifdef FEAT_VARTABS
+	ind_col = 0;
+#endif
+	s = src;
+
+	/* Count/copy the usable portion of the source line */
+	while (todo > 0 && VIM_ISWHITE(*s))
+	{
+	    if (*s == TAB)
+	    {
+#ifdef FEAT_VARTABS
+		tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,
+							curbuf->b_p_vts_array);
+#else
+		tab_pad = (int)curbuf->b_p_ts
+					   - (ind_done % (int)curbuf->b_p_ts);
+#endif
+		/* Stop if this tab will overshoot the target */
+		if (todo < tab_pad)
+		    break;
+		todo -= tab_pad;
+		ind_done += tab_pad;
+#ifdef FEAT_VARTABS
+		ind_col += tab_pad;
+#endif
+	    }
+	    else
+	    {
+		--todo;
+		++ind_done;
+#ifdef FEAT_VARTABS
+		++ind_col;
+#endif
+	    }
+	    ++ind_len;
+	    if (p != NULL)
+		*p++ = *s;
+	    ++s;
+	}
+
+	/* Fill to next tabstop with a tab, if possible */
+#ifdef FEAT_VARTABS
+	tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,
+							curbuf->b_p_vts_array);
+#else
+	tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
+#endif
+	if (todo >= tab_pad && !curbuf->b_p_et)
+	{
+	    todo -= tab_pad;
+	    ++ind_len;
+#ifdef FEAT_VARTABS
+	    ind_col += tab_pad;
+#endif
+	    if (p != NULL)
+		*p++ = TAB;
+	}
+
+	/* Add tabs required for indent */
+	if (!curbuf->b_p_et)
+	{
+#ifdef FEAT_VARTABS
+	    for (;;)
+	    {
+		tab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,
+							curbuf->b_p_vts_array);
+		if (todo < tab_pad)
+		    break;
+		todo -= tab_pad;
+		++ind_len;
+		ind_col += tab_pad;
+		if (p != NULL)
+		    *p++ = TAB;
+	    }
+#else
+	    while (todo >= (int)curbuf->b_p_ts)
+	    {
+		todo -= (int)curbuf->b_p_ts;
+		++ind_len;
+		if (p != NULL)
+		    *p++ = TAB;
+	    }
+#endif
+	}
+
+	/* Count/add spaces required for indent */
+	while (todo > 0)
+	{
+	    --todo;
+	    ++ind_len;
+	    if (p != NULL)
+		*p++ = ' ';
+	}
+
+	if (p == NULL)
+	{
+	    /* Allocate memory for the result: the copied indent, new indent
+	     * and the rest of the line. */
+	    line_len = (int)STRLEN(ml_get_curline()) + 1;
+	    line = alloc(ind_len + line_len);
+	    if (line == NULL)
+		return FALSE;
+	    p = line;
+	}
+    }
+
+    /* Append the original line */
+    mch_memmove(p, ml_get_curline(), (size_t)line_len);
+
+    /* Replace the line */
+    ml_replace(curwin->w_cursor.lnum, line, FALSE);
+
+    /* Put the cursor after the indent. */
+    curwin->w_cursor.col = ind_len;
+    return TRUE;
+}
+
+/*
+ * Return the indent of the current line after a number.  Return -1 if no
+ * number was found.  Used for 'n' in 'formatoptions': numbered list.
+ * Since a pattern is used it can actually handle more than numbers.
+ */
+    int
+get_number_indent(linenr_T lnum)
+{
+    colnr_T	col;
+    pos_T	pos;
+
+    regmatch_T	regmatch;
+    int		lead_len = 0;	/* length of comment leader */
+
+    if (lnum > curbuf->b_ml.ml_line_count)
+	return -1;
+    pos.lnum = 0;
+
+#ifdef FEAT_COMMENTS
+    /* In format_lines() (i.e. not insert mode), fo+=q is needed too...  */
+    if ((State & INSERT) || has_format_option(FO_Q_COMS))
+	lead_len = get_leader_len(ml_get(lnum), NULL, FALSE, TRUE);
+#endif
+    regmatch.regprog = vim_regcomp(curbuf->b_p_flp, RE_MAGIC);
+    if (regmatch.regprog != NULL)
+    {
+	regmatch.rm_ic = FALSE;
+
+	/* vim_regexec() expects a pointer to a line.  This lets us
+	 * start matching for the flp beyond any comment leader...  */
+	if (vim_regexec(&regmatch, ml_get(lnum) + lead_len, (colnr_T)0))
+	{
+	    pos.lnum = lnum;
+	    pos.col = (colnr_T)(*regmatch.endp - ml_get(lnum));
+#ifdef FEAT_VIRTUALEDIT
+	    pos.coladd = 0;
+#endif
+	}
+	vim_regfree(regmatch.regprog);
+    }
+
+    if (pos.lnum == 0 || *ml_get_pos(&pos) == NUL)
+	return -1;
+    getvcol(curwin, &pos, &col, NULL, NULL);
+    return (int)col;
+}
+
+#if defined(FEAT_LINEBREAK) || defined(PROTO)
+/*
+ * Return appropriate space number for breakindent, taking influencing
+ * parameters into account. Window must be specified, since it is not
+ * necessarily always the current one.
+ */
+    int
+get_breakindent_win(
+    win_T	*wp,
+    char_u	*line) /* start of the line */
+{
+    static int	    prev_indent = 0;  /* cached indent value */
+    static long	    prev_ts     = 0L; /* cached tabstop value */
+    static char_u   *prev_line = NULL; /* cached pointer to line */
+    static varnumber_T prev_tick = 0;   /* changedtick of cached value */
+#ifdef FEAT_VARTABS
+    static int      *prev_vts = NULL;    /* cached vartabs values */
+#endif
+    int		    bri = 0;
+    /* window width minus window margin space, i.e. what rests for text */
+    const int	    eff_wwidth = wp->w_width
+			    - ((wp->w_p_nu || wp->w_p_rnu)
+				&& (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)
+						? number_width(wp) + 1 : 0);
+
+    /* used cached indent, unless pointer or 'tabstop' changed */
+    if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts
+	    || prev_tick != CHANGEDTICK(wp->w_buffer)
+#ifdef FEAT_VARTABS
+	    || prev_vts != wp->w_buffer->b_p_vts_array
+#endif
+	)
+    {
+	prev_line = line;
+	prev_ts = wp->w_buffer->b_p_ts;
+	prev_tick = CHANGEDTICK(wp->w_buffer);
+#ifdef FEAT_VARTABS
+	prev_vts = wp->w_buffer->b_p_vts_array;
+	prev_indent = get_indent_str_vtab(line,
+				     (int)wp->w_buffer->b_p_ts,
+				    wp->w_buffer->b_p_vts_array, wp->w_p_list);
+#else
+	prev_indent = get_indent_str(line,
+				     (int)wp->w_buffer->b_p_ts, wp->w_p_list);
+#endif
+    }
+    bri = prev_indent + wp->w_p_brishift;
+
+    /* indent minus the length of the showbreak string */
+    if (wp->w_p_brisbr)
+	bri -= vim_strsize(p_sbr);
+
+    /* Add offset for number column, if 'n' is in 'cpoptions' */
+    bri += win_col_off2(wp);
+
+    /* never indent past left window margin */
+    if (bri < 0)
+	bri = 0;
+    /* always leave at least bri_min characters on the left,
+     * if text width is sufficient */
+    else if (bri > eff_wwidth - wp->w_p_brimin)
+	bri = (eff_wwidth - wp->w_p_brimin < 0)
+			    ? 0 : eff_wwidth - wp->w_p_brimin;
+
+    return bri;
+}
+#endif
+
+
+#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
+
+static int cin_is_cinword(char_u *line);
+
+/*
+ * Return TRUE if the string "line" starts with a word from 'cinwords'.
+ */
+    static int
+cin_is_cinword(char_u *line)
+{
+    char_u	*cinw;
+    char_u	*cinw_buf;
+    int		cinw_len;
+    int		retval = FALSE;
+    int		len;
+
+    cinw_len = (int)STRLEN(curbuf->b_p_cinw) + 1;
+    cinw_buf = alloc((unsigned)cinw_len);
+    if (cinw_buf != NULL)
+    {
+	line = skipwhite(line);
+	for (cinw = curbuf->b_p_cinw; *cinw; )
+	{
+	    len = copy_option_part(&cinw, cinw_buf, cinw_len, ",");
+	    if (STRNCMP(line, cinw_buf, len) == 0
+		    && (!vim_iswordc(line[len]) || !vim_iswordc(line[len - 1])))
+	    {
+		retval = TRUE;
+		break;
+	    }
+	}
+	vim_free(cinw_buf);
+    }
+    return retval;
+}
+#endif
+
+/*
+ * open_line: Add a new line below or above the current line.
+ *
+ * For VREPLACE mode, we only add a new line when we get to the end of the
+ * file, otherwise we just start replacing the next line.
+ *
+ * Caller must take care of undo.  Since VREPLACE may affect any number of
+ * lines however, it may call u_save_cursor() again when starting to change a
+ * new line.
+ * "flags": OPENLINE_DELSPACES	delete spaces after cursor
+ *	    OPENLINE_DO_COM	format comments
+ *	    OPENLINE_KEEPTRAIL	keep trailing spaces
+ *	    OPENLINE_MARKFIX	adjust mark positions after the line break
+ *	    OPENLINE_COM_LIST	format comments with list or 2nd line indent
+ *
+ * "second_line_indent": indent for after ^^D in Insert mode or if flag
+ *			  OPENLINE_COM_LIST
+ *
+ * Return OK for success, FAIL for failure
+ */
+    int
+open_line(
+    int		dir,		/* FORWARD or BACKWARD */
+    int		flags,
+    int		second_line_indent)
+{
+    char_u	*saved_line;		/* copy of the original line */
+    char_u	*next_line = NULL;	/* copy of the next line */
+    char_u	*p_extra = NULL;	/* what goes to next line */
+    int		less_cols = 0;		/* less columns for mark in new line */
+    int		less_cols_off = 0;	/* columns to skip for mark adjust */
+    pos_T	old_cursor;		/* old cursor position */
+    int		newcol = 0;		/* new cursor column */
+    int		newindent = 0;		/* auto-indent of the new line */
+    int		n;
+    int		trunc_line = FALSE;	/* truncate current line afterwards */
+    int		retval = FAIL;		/* return value */
+#ifdef FEAT_COMMENTS
+    int		extra_len = 0;		/* length of p_extra string */
+    int		lead_len;		/* length of comment leader */
+    char_u	*lead_flags;	/* position in 'comments' for comment leader */
+    char_u	*leader = NULL;		/* copy of comment leader */
+#endif
+    char_u	*allocated = NULL;	/* allocated memory */
+    char_u	*p;
+    int		saved_char = NUL;	/* init for GCC */
+#if defined(FEAT_SMARTINDENT) || defined(FEAT_COMMENTS)
+    pos_T	*pos;
+#endif
+#ifdef FEAT_SMARTINDENT
+    int		do_si = (!p_paste && curbuf->b_p_si
+# ifdef FEAT_CINDENT
+					&& !curbuf->b_p_cin
+# endif
+# ifdef FEAT_EVAL
+					&& *curbuf->b_p_inde == NUL
+# endif
+			);
+    int		no_si = FALSE;		/* reset did_si afterwards */
+    int		first_char = NUL;	/* init for GCC */
+#endif
+#if defined(FEAT_LISP) || defined(FEAT_CINDENT)
+    int		vreplace_mode;
+#endif
+    int		did_append;		/* appended a new line */
+    int		saved_pi = curbuf->b_p_pi; /* copy of preserveindent setting */
+
+    /*
+     * make a copy of the current line so we can mess with it
+     */
+    saved_line = vim_strsave(ml_get_curline());
+    if (saved_line == NULL)	    /* out of memory! */
+	return FALSE;
+
+    if (State & VREPLACE_FLAG)
+    {
+	/*
+	 * With VREPLACE we make a copy of the next line, which we will be
+	 * starting to replace.  First make the new line empty and let vim play
+	 * with the indenting and comment leader to its heart's content.  Then
+	 * we grab what it ended up putting on the new line, put back the
+	 * original line, and call ins_char() to put each new character onto
+	 * the line, replacing what was there before and pushing the right
+	 * stuff onto the replace stack.  -- webb.
+	 */
+	if (curwin->w_cursor.lnum < orig_line_count)
+	    next_line = vim_strsave(ml_get(curwin->w_cursor.lnum + 1));
+	else
+	    next_line = vim_strsave((char_u *)"");
+	if (next_line == NULL)	    /* out of memory! */
+	    goto theend;
+
+	/*
+	 * In VREPLACE mode, a NL replaces the rest of the line, and starts
+	 * replacing the next line, so push all of the characters left on the
+	 * line onto the replace stack.  We'll push any other characters that
+	 * might be replaced at the start of the next line (due to autoindent
+	 * etc) a bit later.
+	 */
+	replace_push(NUL);  /* Call twice because BS over NL expects it */
+	replace_push(NUL);
+	p = saved_line + curwin->w_cursor.col;
+	while (*p != NUL)
+	{
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		p += replace_push_mb(p);
+	    else
+#endif
+		replace_push(*p++);
+	}
+	saved_line[curwin->w_cursor.col] = NUL;
+    }
+
+    if ((State & INSERT) && !(State & VREPLACE_FLAG))
+    {
+	p_extra = saved_line + curwin->w_cursor.col;
+#ifdef FEAT_SMARTINDENT
+	if (do_si)		/* need first char after new line break */
+	{
+	    p = skipwhite(p_extra);
+	    first_char = *p;
+	}
+#endif
+#ifdef FEAT_COMMENTS
+	extra_len = (int)STRLEN(p_extra);
+#endif
+	saved_char = *p_extra;
+	*p_extra = NUL;
+    }
+
+    u_clearline();		/* cannot do "U" command when adding lines */
+#ifdef FEAT_SMARTINDENT
+    did_si = FALSE;
+#endif
+    ai_col = 0;
+
+    /*
+     * If we just did an auto-indent, then we didn't type anything on
+     * the prior line, and it should be truncated.  Do this even if 'ai' is not
+     * set because automatically inserting a comment leader also sets did_ai.
+     */
+    if (dir == FORWARD && did_ai)
+	trunc_line = TRUE;
+
+    /*
+     * If 'autoindent' and/or 'smartindent' is set, try to figure out what
+     * indent to use for the new line.
+     */
+    if (curbuf->b_p_ai
+#ifdef FEAT_SMARTINDENT
+			|| do_si
+#endif
+					    )
+    {
+	/*
+	 * count white space on current line
+	 */
+#ifdef FEAT_VARTABS
+	newindent = get_indent_str_vtab(saved_line, curbuf->b_p_ts,
+						 curbuf->b_p_vts_array, FALSE);
+#else
+	newindent = get_indent_str(saved_line, (int)curbuf->b_p_ts, FALSE);
+#endif
+	if (newindent == 0 && !(flags & OPENLINE_COM_LIST))
+	    newindent = second_line_indent; /* for ^^D command in insert mode */
+
+#ifdef FEAT_SMARTINDENT
+	/*
+	 * Do smart indenting.
+	 * In insert/replace mode (only when dir == FORWARD)
+	 * we may move some text to the next line. If it starts with '{'
+	 * don't add an indent. Fixes inserting a NL before '{' in line
+	 *	"if (condition) {"
+	 */
+	if (!trunc_line && do_si && *saved_line != NUL
+				    && (p_extra == NULL || first_char != '{'))
+	{
+	    char_u  *ptr;
+	    char_u  last_char;
+
+	    old_cursor = curwin->w_cursor;
+	    ptr = saved_line;
+# ifdef FEAT_COMMENTS
+	    if (flags & OPENLINE_DO_COM)
+		lead_len = get_leader_len(ptr, NULL, FALSE, TRUE);
+	    else
+		lead_len = 0;
+# endif
+	    if (dir == FORWARD)
+	    {
+		/*
+		 * Skip preprocessor directives, unless they are
+		 * recognised as comments.
+		 */
+		if (
+# ifdef FEAT_COMMENTS
+			lead_len == 0 &&
+# endif
+			ptr[0] == '#')
+		{
+		    while (ptr[0] == '#' && curwin->w_cursor.lnum > 1)
+			ptr = ml_get(--curwin->w_cursor.lnum);
+		    newindent = get_indent();
+		}
+# ifdef FEAT_COMMENTS
+		if (flags & OPENLINE_DO_COM)
+		    lead_len = get_leader_len(ptr, NULL, FALSE, TRUE);
+		else
+		    lead_len = 0;
+		if (lead_len > 0)
+		{
+		    /*
+		     * This case gets the following right:
+		     *	    \*
+		     *	     * A comment (read '\' as '/').
+		     *	     *\
+		     * #define IN_THE_WAY
+		     *	    This should line up here;
+		     */
+		    p = skipwhite(ptr);
+		    if (p[0] == '/' && p[1] == '*')
+			p++;
+		    if (p[0] == '*')
+		    {
+			for (p++; *p; p++)
+			{
+			    if (p[0] == '/' && p[-1] == '*')
+			    {
+				/*
+				 * End of C comment, indent should line up
+				 * with the line containing the start of
+				 * the comment
+				 */
+				curwin->w_cursor.col = (colnr_T)(p - ptr);
+				if ((pos = findmatch(NULL, NUL)) != NULL)
+				{
+				    curwin->w_cursor.lnum = pos->lnum;
+				    newindent = get_indent();
+				}
+			    }
+			}
+		    }
+		}
+		else	/* Not a comment line */
+# endif
+		{
+		    /* Find last non-blank in line */
+		    p = ptr + STRLEN(ptr) - 1;
+		    while (p > ptr && VIM_ISWHITE(*p))
+			--p;
+		    last_char = *p;
+
+		    /*
+		     * find the character just before the '{' or ';'
+		     */
+		    if (last_char == '{' || last_char == ';')
+		    {
+			if (p > ptr)
+			    --p;
+			while (p > ptr && VIM_ISWHITE(*p))
+			    --p;
+		    }
+		    /*
+		     * Try to catch lines that are split over multiple
+		     * lines.  eg:
+		     *	    if (condition &&
+		     *			condition) {
+		     *		Should line up here!
+		     *	    }
+		     */
+		    if (*p == ')')
+		    {
+			curwin->w_cursor.col = (colnr_T)(p - ptr);
+			if ((pos = findmatch(NULL, '(')) != NULL)
+			{
+			    curwin->w_cursor.lnum = pos->lnum;
+			    newindent = get_indent();
+			    ptr = ml_get_curline();
+			}
+		    }
+		    /*
+		     * If last character is '{' do indent, without
+		     * checking for "if" and the like.
+		     */
+		    if (last_char == '{')
+		    {
+			did_si = TRUE;	/* do indent */
+			no_si = TRUE;	/* don't delete it when '{' typed */
+		    }
+		    /*
+		     * Look for "if" and the like, use 'cinwords'.
+		     * Don't do this if the previous line ended in ';' or
+		     * '}'.
+		     */
+		    else if (last_char != ';' && last_char != '}'
+						       && cin_is_cinword(ptr))
+			did_si = TRUE;
+		}
+	    }
+	    else /* dir == BACKWARD */
+	    {
+		/*
+		 * Skip preprocessor directives, unless they are
+		 * recognised as comments.
+		 */
+		if (
+# ifdef FEAT_COMMENTS
+			lead_len == 0 &&
+# endif
+			ptr[0] == '#')
+		{
+		    int was_backslashed = FALSE;
+
+		    while ((ptr[0] == '#' || was_backslashed) &&
+			 curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
+		    {
+			if (*ptr && ptr[STRLEN(ptr) - 1] == '\\')
+			    was_backslashed = TRUE;
+			else
+			    was_backslashed = FALSE;
+			ptr = ml_get(++curwin->w_cursor.lnum);
+		    }
+		    if (was_backslashed)
+			newindent = 0;	    /* Got to end of file */
+		    else
+			newindent = get_indent();
+		}
+		p = skipwhite(ptr);
+		if (*p == '}')	    /* if line starts with '}': do indent */
+		    did_si = TRUE;
+		else		    /* can delete indent when '{' typed */
+		    can_si_back = TRUE;
+	    }
+	    curwin->w_cursor = old_cursor;
+	}
+	if (do_si)
+	    can_si = TRUE;
+#endif /* FEAT_SMARTINDENT */
+
+	did_ai = TRUE;
+    }
+
+#ifdef FEAT_COMMENTS
+    /*
+     * Find out if the current line starts with a comment leader.
+     * This may then be inserted in front of the new line.
+     */
+    end_comment_pending = NUL;
+    if (flags & OPENLINE_DO_COM)
+	lead_len = get_leader_len(saved_line, &lead_flags, dir == BACKWARD, TRUE);
+    else
+	lead_len = 0;
+    if (lead_len > 0)
+    {
+	char_u	*lead_repl = NULL;	    /* replaces comment leader */
+	int	lead_repl_len = 0;	    /* length of *lead_repl */
+	char_u	lead_middle[COM_MAX_LEN];   /* middle-comment string */
+	char_u	lead_end[COM_MAX_LEN];	    /* end-comment string */
+	char_u	*comment_end = NULL;	    /* where lead_end has been found */
+	int	extra_space = FALSE;	    /* append extra space */
+	int	current_flag;
+	int	require_blank = FALSE;	    /* requires blank after middle */
+	char_u	*p2;
+
+	/*
+	 * If the comment leader has the start, middle or end flag, it may not
+	 * be used or may be replaced with the middle leader.
+	 */
+	for (p = lead_flags; *p && *p != ':'; ++p)
+	{
+	    if (*p == COM_BLANK)
+	    {
+		require_blank = TRUE;
+		continue;
+	    }
+	    if (*p == COM_START || *p == COM_MIDDLE)
+	    {
+		current_flag = *p;
+		if (*p == COM_START)
+		{
+		    /*
+		     * Doing "O" on a start of comment does not insert leader.
+		     */
+		    if (dir == BACKWARD)
+		    {
+			lead_len = 0;
+			break;
+		    }
+
+		    /* find start of middle part */
+		    (void)copy_option_part(&p, lead_middle, COM_MAX_LEN, ",");
+		    require_blank = FALSE;
+		}
+
+		/*
+		 * Isolate the strings of the middle and end leader.
+		 */
+		while (*p && p[-1] != ':')	/* find end of middle flags */
+		{
+		    if (*p == COM_BLANK)
+			require_blank = TRUE;
+		    ++p;
+		}
+		(void)copy_option_part(&p, lead_middle, COM_MAX_LEN, ",");
+
+		while (*p && p[-1] != ':')	/* find end of end flags */
+		{
+		    /* Check whether we allow automatic ending of comments */
+		    if (*p == COM_AUTO_END)
+			end_comment_pending = -1; /* means we want to set it */
+		    ++p;
+		}
+		n = copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
+
+		if (end_comment_pending == -1)	/* we can set it now */
+		    end_comment_pending = lead_end[n - 1];
+
+		/*
+		 * If the end of the comment is in the same line, don't use
+		 * the comment leader.
+		 */
+		if (dir == FORWARD)
+		{
+		    for (p = saved_line + lead_len; *p; ++p)
+			if (STRNCMP(p, lead_end, n) == 0)
+			{
+			    comment_end = p;
+			    lead_len = 0;
+			    break;
+			}
+		}
+
+		/*
+		 * Doing "o" on a start of comment inserts the middle leader.
+		 */
+		if (lead_len > 0)
+		{
+		    if (current_flag == COM_START)
+		    {
+			lead_repl = lead_middle;
+			lead_repl_len = (int)STRLEN(lead_middle);
+		    }
+
+		    /*
+		     * If we have hit RETURN immediately after the start
+		     * comment leader, then put a space after the middle
+		     * comment leader on the next line.
+		     */
+		    if (!VIM_ISWHITE(saved_line[lead_len - 1])
+			    && ((p_extra != NULL
+				    && (int)curwin->w_cursor.col == lead_len)
+				|| (p_extra == NULL
+				    && saved_line[lead_len] == NUL)
+				|| require_blank))
+			extra_space = TRUE;
+		}
+		break;
+	    }
+	    if (*p == COM_END)
+	    {
+		/*
+		 * Doing "o" on the end of a comment does not insert leader.
+		 * Remember where the end is, might want to use it to find the
+		 * start (for C-comments).
+		 */
+		if (dir == FORWARD)
+		{
+		    comment_end = skipwhite(saved_line);
+		    lead_len = 0;
+		    break;
+		}
+
+		/*
+		 * Doing "O" on the end of a comment inserts the middle leader.
+		 * Find the string for the middle leader, searching backwards.
+		 */
+		while (p > curbuf->b_p_com && *p != ',')
+		    --p;
+		for (lead_repl = p; lead_repl > curbuf->b_p_com
+					 && lead_repl[-1] != ':'; --lead_repl)
+		    ;
+		lead_repl_len = (int)(p - lead_repl);
+
+		/* We can probably always add an extra space when doing "O" on
+		 * the comment-end */
+		extra_space = TRUE;
+
+		/* Check whether we allow automatic ending of comments */
+		for (p2 = p; *p2 && *p2 != ':'; p2++)
+		{
+		    if (*p2 == COM_AUTO_END)
+			end_comment_pending = -1; /* means we want to set it */
+		}
+		if (end_comment_pending == -1)
+		{
+		    /* Find last character in end-comment string */
+		    while (*p2 && *p2 != ',')
+			p2++;
+		    end_comment_pending = p2[-1];
+		}
+		break;
+	    }
+	    if (*p == COM_FIRST)
+	    {
+		/*
+		 * Comment leader for first line only:	Don't repeat leader
+		 * when using "O", blank out leader when using "o".
+		 */
+		if (dir == BACKWARD)
+		    lead_len = 0;
+		else
+		{
+		    lead_repl = (char_u *)"";
+		    lead_repl_len = 0;
+		}
+		break;
+	    }
+	}
+	if (lead_len)
+	{
+	    /* allocate buffer (may concatenate p_extra later) */
+	    leader = alloc(lead_len + lead_repl_len + extra_space + extra_len
+		     + (second_line_indent > 0 ? second_line_indent : 0) + 1);
+	    allocated = leader;		    /* remember to free it later */
+
+	    if (leader == NULL)
+		lead_len = 0;
+	    else
+	    {
+		vim_strncpy(leader, saved_line, lead_len);
+
+		/*
+		 * Replace leader with lead_repl, right or left adjusted
+		 */
+		if (lead_repl != NULL)
+		{
+		    int		c = 0;
+		    int		off = 0;
+
+		    for (p = lead_flags; *p != NUL && *p != ':'; )
+		    {
+			if (*p == COM_RIGHT || *p == COM_LEFT)
+			    c = *p++;
+			else if (VIM_ISDIGIT(*p) || *p == '-')
+			    off = getdigits(&p);
+			else
+			    ++p;
+		    }
+		    if (c == COM_RIGHT)    /* right adjusted leader */
+		    {
+			/* find last non-white in the leader to line up with */
+			for (p = leader + lead_len - 1; p > leader
+						      && VIM_ISWHITE(*p); --p)
+			    ;
+			++p;
+
+#ifdef FEAT_MBYTE
+			/* Compute the length of the replaced characters in
+			 * screen characters, not bytes. */
+			{
+			    int	    repl_size = vim_strnsize(lead_repl,
+							       lead_repl_len);
+			    int	    old_size = 0;
+			    char_u  *endp = p;
+			    int	    l;
+
+			    while (old_size < repl_size && p > leader)
+			    {
+				MB_PTR_BACK(leader, p);
+				old_size += ptr2cells(p);
+			    }
+			    l = lead_repl_len - (int)(endp - p);
+			    if (l != 0)
+				mch_memmove(endp + l, endp,
+					(size_t)((leader + lead_len) - endp));
+			    lead_len += l;
+			}
+#else
+			if (p < leader + lead_repl_len)
+			    p = leader;
+			else
+			    p -= lead_repl_len;
+#endif
+			mch_memmove(p, lead_repl, (size_t)lead_repl_len);
+			if (p + lead_repl_len > leader + lead_len)
+			    p[lead_repl_len] = NUL;
+
+			/* blank-out any other chars from the old leader. */
+			while (--p >= leader)
+			{
+#ifdef FEAT_MBYTE
+			    int l = mb_head_off(leader, p);
+
+			    if (l > 1)
+			    {
+				p -= l;
+				if (ptr2cells(p) > 1)
+				{
+				    p[1] = ' ';
+				    --l;
+				}
+				mch_memmove(p + 1, p + l + 1,
+				   (size_t)((leader + lead_len) - (p + l + 1)));
+				lead_len -= l;
+				*p = ' ';
+			    }
+			    else
+#endif
+			    if (!VIM_ISWHITE(*p))
+				*p = ' ';
+			}
+		    }
+		    else		    /* left adjusted leader */
+		    {
+			p = skipwhite(leader);
+#ifdef FEAT_MBYTE
+			/* Compute the length of the replaced characters in
+			 * screen characters, not bytes. Move the part that is
+			 * not to be overwritten. */
+			{
+			    int	    repl_size = vim_strnsize(lead_repl,
+							       lead_repl_len);
+			    int	    i;
+			    int	    l;
+
+			    for (i = 0; i < lead_len && p[i] != NUL; i += l)
+			    {
+				l = (*mb_ptr2len)(p + i);
+				if (vim_strnsize(p, i + l) > repl_size)
+				    break;
+			    }
+			    if (i != lead_repl_len)
+			    {
+				mch_memmove(p + lead_repl_len, p + i,
+				       (size_t)(lead_len - i - (p - leader)));
+				lead_len += lead_repl_len - i;
+			    }
+			}
+#endif
+			mch_memmove(p, lead_repl, (size_t)lead_repl_len);
+
+			/* Replace any remaining non-white chars in the old
+			 * leader by spaces.  Keep Tabs, the indent must
+			 * remain the same. */
+			for (p += lead_repl_len; p < leader + lead_len; ++p)
+			    if (!VIM_ISWHITE(*p))
+			    {
+				/* Don't put a space before a TAB. */
+				if (p + 1 < leader + lead_len && p[1] == TAB)
+				{
+				    --lead_len;
+				    mch_memmove(p, p + 1,
+						     (leader + lead_len) - p);
+				}
+				else
+				{
+#ifdef FEAT_MBYTE
+				    int	    l = (*mb_ptr2len)(p);
+
+				    if (l > 1)
+				    {
+					if (ptr2cells(p) > 1)
+					{
+					    /* Replace a double-wide char with
+					     * two spaces */
+					    --l;
+					    *p++ = ' ';
+					}
+					mch_memmove(p + 1, p + l,
+						     (leader + lead_len) - p);
+					lead_len -= l - 1;
+				    }
+#endif
+				    *p = ' ';
+				}
+			    }
+			*p = NUL;
+		    }
+
+		    /* Recompute the indent, it may have changed. */
+		    if (curbuf->b_p_ai
+#ifdef FEAT_SMARTINDENT
+					|| do_si
+#endif
+							   )
+#ifdef FEAT_VARTABS
+			newindent = get_indent_str_vtab(leader, curbuf->b_p_ts,
+						 curbuf->b_p_vts_array, FALSE);
+#else
+			newindent = get_indent_str(leader,
+						   (int)curbuf->b_p_ts, FALSE);
+#endif
+
+		    /* Add the indent offset */
+		    if (newindent + off < 0)
+		    {
+			off = -newindent;
+			newindent = 0;
+		    }
+		    else
+			newindent += off;
+
+		    /* Correct trailing spaces for the shift, so that
+		     * alignment remains equal. */
+		    while (off > 0 && lead_len > 0
+					       && leader[lead_len - 1] == ' ')
+		    {
+			/* Don't do it when there is a tab before the space */
+			if (vim_strchr(skipwhite(leader), '\t') != NULL)
+			    break;
+			--lead_len;
+			--off;
+		    }
+
+		    /* If the leader ends in white space, don't add an
+		     * extra space */
+		    if (lead_len > 0 && VIM_ISWHITE(leader[lead_len - 1]))
+			extra_space = FALSE;
+		    leader[lead_len] = NUL;
+		}
+
+		if (extra_space)
+		{
+		    leader[lead_len++] = ' ';
+		    leader[lead_len] = NUL;
+		}
+
+		newcol = lead_len;
+
+		/*
+		 * if a new indent will be set below, remove the indent that
+		 * is in the comment leader
+		 */
+		if (newindent
+#ifdef FEAT_SMARTINDENT
+				|| did_si
+#endif
+					   )
+		{
+		    while (lead_len && VIM_ISWHITE(*leader))
+		    {
+			--lead_len;
+			--newcol;
+			++leader;
+		    }
+		}
+
+	    }
+#ifdef FEAT_SMARTINDENT
+	    did_si = can_si = FALSE;
+#endif
+	}
+	else if (comment_end != NULL)
+	{
+	    /*
+	     * We have finished a comment, so we don't use the leader.
+	     * If this was a C-comment and 'ai' or 'si' is set do a normal
+	     * indent to align with the line containing the start of the
+	     * comment.
+	     */
+	    if (comment_end[0] == '*' && comment_end[1] == '/' &&
+			(curbuf->b_p_ai
+#ifdef FEAT_SMARTINDENT
+					|| do_si
+#endif
+							   ))
+	    {
+		old_cursor = curwin->w_cursor;
+		curwin->w_cursor.col = (colnr_T)(comment_end - saved_line);
+		if ((pos = findmatch(NULL, NUL)) != NULL)
+		{
+		    curwin->w_cursor.lnum = pos->lnum;
+		    newindent = get_indent();
+		}
+		curwin->w_cursor = old_cursor;
+	    }
+	}
+    }
+#endif
+
+    /* (State == INSERT || State == REPLACE), only when dir == FORWARD */
+    if (p_extra != NULL)
+    {
+	*p_extra = saved_char;		/* restore char that NUL replaced */
+
+	/*
+	 * When 'ai' set or "flags" has OPENLINE_DELSPACES, skip to the first
+	 * non-blank.
+	 *
+	 * When in REPLACE mode, put the deleted blanks on the replace stack,
+	 * preceded by a NUL, so they can be put back when a BS is entered.
+	 */
+	if (REPLACE_NORMAL(State))
+	    replace_push(NUL);	    /* end of extra blanks */
+	if (curbuf->b_p_ai || (flags & OPENLINE_DELSPACES))
+	{
+	    while ((*p_extra == ' ' || *p_extra == '\t')
+#ifdef FEAT_MBYTE
+		    && (!enc_utf8
+			       || !utf_iscomposing(utf_ptr2char(p_extra + 1)))
+#endif
+		    )
+	    {
+		if (REPLACE_NORMAL(State))
+		    replace_push(*p_extra);
+		++p_extra;
+		++less_cols_off;
+	    }
+	}
+	if (*p_extra != NUL)
+	    did_ai = FALSE;	    /* append some text, don't truncate now */
+
+	/* columns for marks adjusted for removed columns */
+	less_cols = (int)(p_extra - saved_line);
+    }
+
+    if (p_extra == NULL)
+	p_extra = (char_u *)"";		    /* append empty line */
+
+#ifdef FEAT_COMMENTS
+    /* concatenate leader and p_extra, if there is a leader */
+    if (lead_len)
+    {
+	if (flags & OPENLINE_COM_LIST && second_line_indent > 0)
+	{
+	    int i;
+	    int padding = second_line_indent
+					  - (newindent + (int)STRLEN(leader));
+
+	    /* Here whitespace is inserted after the comment char.
+	     * Below, set_indent(newindent, SIN_INSERT) will insert the
+	     * whitespace needed before the comment char. */
+	    for (i = 0; i < padding; i++)
+	    {
+		STRCAT(leader, " ");
+		less_cols--;
+		newcol++;
+	    }
+	}
+	STRCAT(leader, p_extra);
+	p_extra = leader;
+	did_ai = TRUE;	    /* So truncating blanks works with comments */
+	less_cols -= lead_len;
+    }
+    else
+	end_comment_pending = NUL;  /* turns out there was no leader */
+#endif
+
+    old_cursor = curwin->w_cursor;
+    if (dir == BACKWARD)
+	--curwin->w_cursor.lnum;
+    if (!(State & VREPLACE_FLAG) || old_cursor.lnum >= orig_line_count)
+    {
+	if (ml_append(curwin->w_cursor.lnum, p_extra, (colnr_T)0, FALSE)
+								      == FAIL)
+	    goto theend;
+	/* Postpone calling changed_lines(), because it would mess up folding
+	 * with markers.
+	 * Skip mark_adjust when adding a line after the last one, there can't
+	 * be marks there. But still needed in diff mode. */
+	if (curwin->w_cursor.lnum + 1 < curbuf->b_ml.ml_line_count
+#ifdef FEAT_DIFF
+		|| curwin->w_p_diff
+#endif
+	    )
+	    mark_adjust(curwin->w_cursor.lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);
+	did_append = TRUE;
+    }
+    else
+    {
+	/*
+	 * In VREPLACE mode we are starting to replace the next line.
+	 */
+	curwin->w_cursor.lnum++;
+	if (curwin->w_cursor.lnum >= Insstart.lnum + vr_lines_changed)
+	{
+	    /* In case we NL to a new line, BS to the previous one, and NL
+	     * again, we don't want to save the new line for undo twice.
+	     */
+	    (void)u_save_cursor();		    /* errors are ignored! */
+	    vr_lines_changed++;
+	}
+	ml_replace(curwin->w_cursor.lnum, p_extra, TRUE);
+	changed_bytes(curwin->w_cursor.lnum, 0);
+	curwin->w_cursor.lnum--;
+	did_append = FALSE;
+    }
+
+    if (newindent
+#ifdef FEAT_SMARTINDENT
+		    || did_si
+#endif
+				)
+    {
+	++curwin->w_cursor.lnum;
+#ifdef FEAT_SMARTINDENT
+	if (did_si)
+	{
+	    int sw = (int)get_sw_value(curbuf);
+
+	    if (p_sr)
+		newindent -= newindent % sw;
+	    newindent += sw;
+	}
+#endif
+	/* Copy the indent */
+	if (curbuf->b_p_ci)
+	{
+	    (void)copy_indent(newindent, saved_line);
+
+	    /*
+	     * Set the 'preserveindent' option so that any further screwing
+	     * with the line doesn't entirely destroy our efforts to preserve
+	     * it.  It gets restored at the function end.
+	     */
+	    curbuf->b_p_pi = TRUE;
+	}
+	else
+	    (void)set_indent(newindent, SIN_INSERT);
+	less_cols -= curwin->w_cursor.col;
+
+	ai_col = curwin->w_cursor.col;
+
+	/*
+	 * In REPLACE mode, for each character in the new indent, there must
+	 * be a NUL on the replace stack, for when it is deleted with BS
+	 */
+	if (REPLACE_NORMAL(State))
+	    for (n = 0; n < (int)curwin->w_cursor.col; ++n)
+		replace_push(NUL);
+	newcol += curwin->w_cursor.col;
+#ifdef FEAT_SMARTINDENT
+	if (no_si)
+	    did_si = FALSE;
+#endif
+    }
+
+#ifdef FEAT_COMMENTS
+    /*
+     * In REPLACE mode, for each character in the extra leader, there must be
+     * a NUL on the replace stack, for when it is deleted with BS.
+     */
+    if (REPLACE_NORMAL(State))
+	while (lead_len-- > 0)
+	    replace_push(NUL);
+#endif
+
+    curwin->w_cursor = old_cursor;
+
+    if (dir == FORWARD)
+    {
+	if (trunc_line || (State & INSERT))
+	{
+	    /* truncate current line at cursor */
+	    saved_line[curwin->w_cursor.col] = NUL;
+	    /* Remove trailing white space, unless OPENLINE_KEEPTRAIL used. */
+	    if (trunc_line && !(flags & OPENLINE_KEEPTRAIL))
+		truncate_spaces(saved_line);
+	    ml_replace(curwin->w_cursor.lnum, saved_line, FALSE);
+	    saved_line = NULL;
+	    if (did_append)
+	    {
+		changed_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,
+					       curwin->w_cursor.lnum + 1, 1L);
+		did_append = FALSE;
+
+		/* Move marks after the line break to the new line. */
+		if (flags & OPENLINE_MARKFIX)
+		    mark_col_adjust(curwin->w_cursor.lnum,
+					 curwin->w_cursor.col + less_cols_off,
+							1L, (long)-less_cols);
+	    }
+	    else
+		changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);
+	}
+
+	/*
+	 * Put the cursor on the new line.  Careful: the scrollup() above may
+	 * have moved w_cursor, we must use old_cursor.
+	 */
+	curwin->w_cursor.lnum = old_cursor.lnum + 1;
+    }
+    if (did_append)
+	changed_lines(curwin->w_cursor.lnum, 0, curwin->w_cursor.lnum, 1L);
+
+    curwin->w_cursor.col = newcol;
+#ifdef FEAT_VIRTUALEDIT
+    curwin->w_cursor.coladd = 0;
+#endif
+
+#if defined(FEAT_LISP) || defined(FEAT_CINDENT)
+    /*
+     * In VREPLACE mode, we are handling the replace stack ourselves, so stop
+     * fixthisline() from doing it (via change_indent()) by telling it we're in
+     * normal INSERT mode.
+     */
+    if (State & VREPLACE_FLAG)
+    {
+	vreplace_mode = State;	/* So we know to put things right later */
+	State = INSERT;
+    }
+    else
+	vreplace_mode = 0;
+#endif
+#ifdef FEAT_LISP
+    /*
+     * May do lisp indenting.
+     */
+    if (!p_paste
+# ifdef FEAT_COMMENTS
+	    && leader == NULL
+# endif
+	    && curbuf->b_p_lisp
+	    && curbuf->b_p_ai)
+    {
+	fixthisline(get_lisp_indent);
+	ai_col = (colnr_T)getwhitecols_curline();
+    }
+#endif
+#ifdef FEAT_CINDENT
+    /*
+     * May do indenting after opening a new line.
+     */
+    if (!p_paste
+	    && (curbuf->b_p_cin
+#  ifdef FEAT_EVAL
+		    || *curbuf->b_p_inde != NUL
+#  endif
+		)
+	    && in_cinkeys(dir == FORWARD
+		? KEY_OPEN_FORW
+		: KEY_OPEN_BACK, ' ', linewhite(curwin->w_cursor.lnum)))
+    {
+	do_c_expr_indent();
+	ai_col = (colnr_T)getwhitecols_curline();
+    }
+#endif
+#if defined(FEAT_LISP) || defined(FEAT_CINDENT)
+    if (vreplace_mode != 0)
+	State = vreplace_mode;
+#endif
+
+    /*
+     * Finally, VREPLACE gets the stuff on the new line, then puts back the
+     * original line, and inserts the new stuff char by char, pushing old stuff
+     * onto the replace stack (via ins_char()).
+     */
+    if (State & VREPLACE_FLAG)
+    {
+	/* Put new line in p_extra */
+	p_extra = vim_strsave(ml_get_curline());
+	if (p_extra == NULL)
+	    goto theend;
+
+	/* Put back original line */
+	ml_replace(curwin->w_cursor.lnum, next_line, FALSE);
+
+	/* Insert new stuff into line again */
+	curwin->w_cursor.col = 0;
+#ifdef FEAT_VIRTUALEDIT
+	curwin->w_cursor.coladd = 0;
+#endif
+	ins_bytes(p_extra);	/* will call changed_bytes() */
+	vim_free(p_extra);
+	next_line = NULL;
+    }
+
+    retval = OK;		/* success! */
+theend:
+    curbuf->b_p_pi = saved_pi;
+    vim_free(saved_line);
+    vim_free(next_line);
+    vim_free(allocated);
+    return retval;
+}
+
+#if defined(FEAT_COMMENTS) || defined(PROTO)
+/*
+ * get_leader_len() returns the length in bytes of the prefix of the given
+ * string which introduces a comment.  If this string is not a comment then
+ * 0 is returned.
+ * When "flags" is not NULL, it is set to point to the flags of the recognized
+ * comment leader.
+ * "backward" must be true for the "O" command.
+ * If "include_space" is set, include trailing whitespace while calculating the
+ * length.
+ */
+    int
+get_leader_len(
+    char_u	*line,
+    char_u	**flags,
+    int		backward,
+    int		include_space)
+{
+    int		i, j;
+    int		result;
+    int		got_com = FALSE;
+    int		found_one;
+    char_u	part_buf[COM_MAX_LEN];	/* buffer for one option part */
+    char_u	*string;		/* pointer to comment string */
+    char_u	*list;
+    int		middle_match_len = 0;
+    char_u	*prev_list;
+    char_u	*saved_flags = NULL;
+
+    result = i = 0;
+    while (VIM_ISWHITE(line[i]))    /* leading white space is ignored */
+	++i;
+
+    /*
+     * Repeat to match several nested comment strings.
+     */
+    while (line[i] != NUL)
+    {
+	/*
+	 * scan through the 'comments' option for a match
+	 */
+	found_one = FALSE;
+	for (list = curbuf->b_p_com; *list; )
+	{
+	    /* Get one option part into part_buf[].  Advance "list" to next
+	     * one.  Put "string" at start of string.  */
+	    if (!got_com && flags != NULL)
+		*flags = list;	    /* remember where flags started */
+	    prev_list = list;
+	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
+	    string = vim_strchr(part_buf, ':');
+	    if (string == NULL)	    /* missing ':', ignore this part */
+		continue;
+	    *string++ = NUL;	    /* isolate flags from string */
+
+	    /* If we found a middle match previously, use that match when this
+	     * is not a middle or end. */
+	    if (middle_match_len != 0
+		    && vim_strchr(part_buf, COM_MIDDLE) == NULL
+		    && vim_strchr(part_buf, COM_END) == NULL)
+		break;
+
+	    /* When we already found a nested comment, only accept further
+	     * nested comments. */
+	    if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)
+		continue;
+
+	    /* When 'O' flag present and using "O" command skip this one. */
+	    if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)
+		continue;
+
+	    /* Line contents and string must match.
+	     * When string starts with white space, must have some white space
+	     * (but the amount does not need to match, there might be a mix of
+	     * TABs and spaces). */
+	    if (VIM_ISWHITE(string[0]))
+	    {
+		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
+		    continue;  /* missing white space */
+		while (VIM_ISWHITE(string[0]))
+		    ++string;
+	    }
+	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
+		;
+	    if (string[j] != NUL)
+		continue;  /* string doesn't match */
+
+	    /* When 'b' flag used, there must be white space or an
+	     * end-of-line after the string in the line. */
+	    if (vim_strchr(part_buf, COM_BLANK) != NULL
+			   && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
+		continue;
+
+	    /* We have found a match, stop searching unless this is a middle
+	     * comment. The middle comment can be a substring of the end
+	     * comment in which case it's better to return the length of the
+	     * end comment and its flags.  Thus we keep searching with middle
+	     * and end matches and use an end match if it matches better. */
+	    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)
+	    {
+		if (middle_match_len == 0)
+		{
+		    middle_match_len = j;
+		    saved_flags = prev_list;
+		}
+		continue;
+	    }
+	    if (middle_match_len != 0 && j > middle_match_len)
+		/* Use this match instead of the middle match, since it's a
+		 * longer thus better match. */
+		middle_match_len = 0;
+
+	    if (middle_match_len == 0)
+		i += j;
+	    found_one = TRUE;
+	    break;
+	}
+
+	if (middle_match_len != 0)
+	{
+	    /* Use the previously found middle match after failing to find a
+	     * match with an end. */
+	    if (!got_com && flags != NULL)
+		*flags = saved_flags;
+	    i += middle_match_len;
+	    found_one = TRUE;
+	}
+
+	/* No match found, stop scanning. */
+	if (!found_one)
+	    break;
+
+	result = i;
+
+	/* Include any trailing white space. */
+	while (VIM_ISWHITE(line[i]))
+	    ++i;
+
+	if (include_space)
+	    result = i;
+
+	/* If this comment doesn't nest, stop here. */
+	got_com = TRUE;
+	if (vim_strchr(part_buf, COM_NEST) == NULL)
+	    break;
+    }
+    return result;
+}
+
+/*
+ * Return the offset at which the last comment in line starts. If there is no
+ * comment in the whole line, -1 is returned.
+ *
+ * When "flags" is not null, it is set to point to the flags describing the
+ * recognized comment leader.
+ */
+    int
+get_last_leader_offset(char_u *line, char_u **flags)
+{
+    int		result = -1;
+    int		i, j;
+    int		lower_check_bound = 0;
+    char_u	*string;
+    char_u	*com_leader;
+    char_u	*com_flags;
+    char_u	*list;
+    int		found_one;
+    char_u	part_buf[COM_MAX_LEN];	/* buffer for one option part */
+
+    /*
+     * Repeat to match several nested comment strings.
+     */
+    i = (int)STRLEN(line);
+    while (--i >= lower_check_bound)
+    {
+	/*
+	 * scan through the 'comments' option for a match
+	 */
+	found_one = FALSE;
+	for (list = curbuf->b_p_com; *list; )
+	{
+	    char_u *flags_save = list;
+
+	    /*
+	     * Get one option part into part_buf[].  Advance list to next one.
+	     * put string at start of string.
+	     */
+	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
+	    string = vim_strchr(part_buf, ':');
+	    if (string == NULL)	/* If everything is fine, this cannot actually
+				 * happen. */
+	    {
+		continue;
+	    }
+	    *string++ = NUL;	/* Isolate flags from string. */
+	    com_leader = string;
+
+	    /*
+	     * Line contents and string must match.
+	     * When string starts with white space, must have some white space
+	     * (but the amount does not need to match, there might be a mix of
+	     * TABs and spaces).
+	     */
+	    if (VIM_ISWHITE(string[0]))
+	    {
+		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
+		    continue;
+		while (VIM_ISWHITE(string[0]))
+		    ++string;
+	    }
+	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
+		/* do nothing */;
+	    if (string[j] != NUL)
+		continue;
+
+	    /*
+	     * When 'b' flag used, there must be white space or an
+	     * end-of-line after the string in the line.
+	     */
+	    if (vim_strchr(part_buf, COM_BLANK) != NULL
+		    && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
+	    {
+		continue;
+	    }
+
+	    /*
+	     * We have found a match, stop searching.
+	     */
+	    found_one = TRUE;
+
+	    if (flags)
+		*flags = flags_save;
+	    com_flags = flags_save;
+
+	    break;
+	}
+
+	if (found_one)
+	{
+	    char_u  part_buf2[COM_MAX_LEN];	/* buffer for one option part */
+	    int     len1, len2, off;
+
+	    result = i;
+	    /*
+	     * If this comment nests, continue searching.
+	     */
+	    if (vim_strchr(part_buf, COM_NEST) != NULL)
+		continue;
+
+	    lower_check_bound = i;
+
+	    /* Let's verify whether the comment leader found is a substring
+	     * of other comment leaders. If it is, let's adjust the
+	     * lower_check_bound so that we make sure that we have determined
+	     * the comment leader correctly.
+	     */
+
+	    while (VIM_ISWHITE(*com_leader))
+		++com_leader;
+	    len1 = (int)STRLEN(com_leader);
+
+	    for (list = curbuf->b_p_com; *list; )
+	    {
+		char_u *flags_save = list;
+
+		(void)copy_option_part(&list, part_buf2, COM_MAX_LEN, ",");
+		if (flags_save == com_flags)
+		    continue;
+		string = vim_strchr(part_buf2, ':');
+		++string;
+		while (VIM_ISWHITE(*string))
+		    ++string;
+		len2 = (int)STRLEN(string);
+		if (len2 == 0)
+		    continue;
+
+		/* Now we have to verify whether string ends with a substring
+		 * beginning the com_leader. */
+		for (off = (len2 > i ? i : len2); off > 0 && off + len1 > len2;)
+		{
+		    --off;
+		    if (!STRNCMP(string + off, com_leader, len2 - off))
+		    {
+			if (i - off < lower_check_bound)
+			    lower_check_bound = i - off;
+		    }
+		}
+	    }
+	}
+    }
+    return result;
+}
+#endif
+
+/*
+ * Return the number of window lines occupied by buffer line "lnum".
+ */
+    int
+plines(linenr_T lnum)
+{
+    return plines_win(curwin, lnum, TRUE);
+}
+
+    int
+plines_win(
+    win_T	*wp,
+    linenr_T	lnum,
+    int		winheight)	/* when TRUE limit to window height */
+{
+#if defined(FEAT_DIFF) || defined(PROTO)
+    /* Check for filler lines above this buffer line.  When folded the result
+     * is one line anyway. */
+    return plines_win_nofill(wp, lnum, winheight) + diff_check_fill(wp, lnum);
+}
+
+    int
+plines_nofill(linenr_T lnum)
+{
+    return plines_win_nofill(curwin, lnum, TRUE);
+}
+
+    int
+plines_win_nofill(
+    win_T	*wp,
+    linenr_T	lnum,
+    int		winheight)	/* when TRUE limit to window height */
+{
+#endif
+    int		lines;
+
+    if (!wp->w_p_wrap)
+	return 1;
+
+    if (wp->w_width == 0)
+	return 1;
+
+#ifdef FEAT_FOLDING
+    /* A folded lines is handled just like an empty line. */
+    /* NOTE: Caller must handle lines that are MAYBE folded. */
+    if (lineFolded(wp, lnum) == TRUE)
+	return 1;
+#endif
+
+    lines = plines_win_nofold(wp, lnum);
+    if (winheight > 0 && lines > wp->w_height)
+	return (int)wp->w_height;
+    return lines;
+}
+
+/*
+ * Return number of window lines physical line "lnum" will occupy in window
+ * "wp".  Does not care about folding, 'wrap' or 'diff'.
+ */
+    int
+plines_win_nofold(win_T *wp, linenr_T lnum)
+{
+    char_u	*s;
+    long	col;
+    int		width;
+
+    s = ml_get_buf(wp->w_buffer, lnum, FALSE);
+    if (*s == NUL)		/* empty line */
+	return 1;
+    col = win_linetabsize(wp, s, (colnr_T)MAXCOL);
+
+    /*
+     * If list mode is on, then the '$' at the end of the line may take up one
+     * extra column.
+     */
+    if (wp->w_p_list && lcs_eol != NUL)
+	col += 1;
+
+    /*
+     * Add column offset for 'number', 'relativenumber' and 'foldcolumn'.
+     */
+    width = wp->w_width - win_col_off(wp);
+    if (width <= 0)
+	return 32000;
+    if (col <= width)
+	return 1;
+    col -= width;
+    width += win_col_off2(wp);
+    return (col + (width - 1)) / width + 1;
+}
+
+/*
+ * Like plines_win(), but only reports the number of physical screen lines
+ * used from the start of the line to the given column number.
+ */
+    int
+plines_win_col(win_T *wp, linenr_T lnum, long column)
+{
+    long	col;
+    char_u	*s;
+    int		lines = 0;
+    int		width;
+    char_u	*line;
+
+#ifdef FEAT_DIFF
+    /* Check for filler lines above this buffer line.  When folded the result
+     * is one line anyway. */
+    lines = diff_check_fill(wp, lnum);
+#endif
+
+    if (!wp->w_p_wrap)
+	return lines + 1;
+
+    if (wp->w_width == 0)
+	return lines + 1;
+
+    line = s = ml_get_buf(wp->w_buffer, lnum, FALSE);
+
+    col = 0;
+    while (*s != NUL && --column >= 0)
+    {
+	col += win_lbr_chartabsize(wp, line, s, (colnr_T)col, NULL);
+	MB_PTR_ADV(s);
+    }
+
+    /*
+     * If *s is a TAB, and the TAB is not displayed as ^I, and we're not in
+     * INSERT mode, then col must be adjusted so that it represents the last
+     * screen position of the TAB.  This only fixes an error when the TAB wraps
+     * from one screen line to the next (when 'columns' is not a multiple of
+     * 'ts') -- webb.
+     */
+    if (*s == TAB && (State & NORMAL) && (!wp->w_p_list || lcs_tab1))
+	col += win_lbr_chartabsize(wp, line, s, (colnr_T)col, NULL) - 1;
+
+    /*
+     * Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.
+     */
+    width = wp->w_width - win_col_off(wp);
+    if (width <= 0)
+	return 9999;
+
+    lines += 1;
+    if (col > width)
+	lines += (col - width) / (width + win_col_off2(wp)) + 1;
+    return lines;
+}
+
+    int
+plines_m_win(win_T *wp, linenr_T first, linenr_T last)
+{
+    int		count = 0;
+
+    while (first <= last)
+    {
+#ifdef FEAT_FOLDING
+	int	x;
+
+	/* Check if there are any really folded lines, but also included lines
+	 * that are maybe folded. */
+	x = foldedCount(wp, first, NULL);
+	if (x > 0)
+	{
+	    ++count;	    /* count 1 for "+-- folded" line */
+	    first += x;
+	}
+	else
+#endif
+	{
+#ifdef FEAT_DIFF
+	    if (first == wp->w_topline)
+		count += plines_win_nofill(wp, first, TRUE) + wp->w_topfill;
+	    else
+#endif
+		count += plines_win(wp, first, TRUE);
+	    ++first;
+	}
+    }
+    return (count);
+}
+
+/*
+ * Insert string "p" at the cursor position.  Stops at a NUL byte.
+ * Handles Replace mode and multi-byte characters.
+ */
+    void
+ins_bytes(char_u *p)
+{
+    ins_bytes_len(p, (int)STRLEN(p));
+}
+
+/*
+ * Insert string "p" with length "len" at the cursor position.
+ * Handles Replace mode and multi-byte characters.
+ */
+    void
+ins_bytes_len(char_u *p, int len)
+{
+    int		i;
+#ifdef FEAT_MBYTE
+    int		n;
+
+    if (has_mbyte)
+	for (i = 0; i < len; i += n)
+	{
+	    if (enc_utf8)
+		/* avoid reading past p[len] */
+		n = utfc_ptr2len_len(p + i, len - i);
+	    else
+		n = (*mb_ptr2len)(p + i);
+	    ins_char_bytes(p + i, n);
+	}
+    else
+#endif
+	for (i = 0; i < len; ++i)
+	    ins_char(p[i]);
+}
+
+/*
+ * Insert or replace a single character at the cursor position.
+ * When in REPLACE or VREPLACE mode, replace any existing character.
+ * Caller must have prepared for undo.
+ * For multi-byte characters we get the whole character, the caller must
+ * convert bytes to a character.
+ */
+    void
+ins_char(int c)
+{
+    char_u	buf[MB_MAXBYTES + 1];
+    int		n = 1;
+
+#ifdef FEAT_MBYTE
+    n = (*mb_char2bytes)(c, buf);
+
+    /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
+     * Happens for CTRL-Vu9900. */
+    if (buf[0] == 0)
+	buf[0] = '\n';
+#else
+    buf[0] = c;
+#endif
+
+    ins_char_bytes(buf, n);
+}
+
+    void
+ins_char_bytes(char_u *buf, int charlen)
+{
+    int		c = buf[0];
+    int		newlen;		/* nr of bytes inserted */
+    int		oldlen;		/* nr of bytes deleted (0 when not replacing) */
+    char_u	*p;
+    char_u	*newp;
+    char_u	*oldp;
+    int		linelen;	/* length of old line including NUL */
+    colnr_T	col;
+    linenr_T	lnum = curwin->w_cursor.lnum;
+    int		i;
+
+#ifdef FEAT_VIRTUALEDIT
+    /* Break tabs if needed. */
+    if (virtual_active() && curwin->w_cursor.coladd > 0)
+	coladvance_force(getviscol());
+#endif
+
+    col = curwin->w_cursor.col;
+    oldp = ml_get(lnum);
+    linelen = (int)STRLEN(oldp) + 1;
+
+    /* The lengths default to the values for when not replacing. */
+    oldlen = 0;
+    newlen = charlen;
+
+    if (State & REPLACE_FLAG)
+    {
+	if (State & VREPLACE_FLAG)
+	{
+	    colnr_T	new_vcol = 0;   /* init for GCC */
+	    colnr_T	vcol;
+	    int		old_list;
+#ifndef FEAT_MBYTE
+	    char_u	buf[2];
+#endif
+
+	    /*
+	     * Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.
+	     * Returns the old value of list, so when finished,
+	     * curwin->w_p_list should be set back to this.
+	     */
+	    old_list = curwin->w_p_list;
+	    if (old_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)
+		curwin->w_p_list = FALSE;
+
+	    /*
+	     * In virtual replace mode each character may replace one or more
+	     * characters (zero if it's a TAB).  Count the number of bytes to
+	     * be deleted to make room for the new character, counting screen
+	     * cells.  May result in adding spaces to fill a gap.
+	     */
+	    getvcol(curwin, &curwin->w_cursor, NULL, &vcol, NULL);
+#ifndef FEAT_MBYTE
+	    buf[0] = c;
+	    buf[1] = NUL;
+#endif
+	    new_vcol = vcol + chartabsize(buf, vcol);
+	    while (oldp[col + oldlen] != NUL && vcol < new_vcol)
+	    {
+		vcol += chartabsize(oldp + col + oldlen, vcol);
+		/* Don't need to remove a TAB that takes us to the right
+		 * position. */
+		if (vcol > new_vcol && oldp[col + oldlen] == TAB)
+		    break;
+#ifdef FEAT_MBYTE
+		oldlen += (*mb_ptr2len)(oldp + col + oldlen);
+#else
+		++oldlen;
+#endif
+		/* Deleted a bit too much, insert spaces. */
+		if (vcol > new_vcol)
+		    newlen += vcol - new_vcol;
+	    }
+	    curwin->w_p_list = old_list;
+	}
+	else
+	    if (oldp[col] != NUL)
+	{
+	    /* normal replace */
+#ifdef FEAT_MBYTE
+	    oldlen = (*mb_ptr2len)(oldp + col);
+#else
+	    oldlen = 1;
+#endif
+	}
+
+
+	/* Push the replaced bytes onto the replace stack, so that they can be
+	 * put back when BS is used.  The bytes of a multi-byte character are
+	 * done the other way around, so that the first byte is popped off
+	 * first (it tells the byte length of the character). */
+	replace_push(NUL);
+	for (i = 0; i < oldlen; ++i)
+	{
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		i += replace_push_mb(oldp + col + i) - 1;
+	    else
+#endif
+		replace_push(oldp[col + i]);
+	}
+    }
+
+    newp = alloc_check((unsigned)(linelen + newlen - oldlen));
+    if (newp == NULL)
+	return;
+
+    /* Copy bytes before the cursor. */
+    if (col > 0)
+	mch_memmove(newp, oldp, (size_t)col);
+
+    /* Copy bytes after the changed character(s). */
+    p = newp + col;
+    if (linelen > col + oldlen)
+	mch_memmove(p + newlen, oldp + col + oldlen,
+					    (size_t)(linelen - col - oldlen));
+
+    /* Insert or overwrite the new character. */
+#ifdef FEAT_MBYTE
+    mch_memmove(p, buf, charlen);
+    i = charlen;
+#else
+    *p = c;
+    i = 1;
+#endif
+
+    /* Fill with spaces when necessary. */
+    while (i < newlen)
+	p[i++] = ' ';
+
+    /* Replace the line in the buffer. */
+    ml_replace(lnum, newp, FALSE);
+
+    /* mark the buffer as changed and prepare for displaying */
+    changed_bytes(lnum, col);
+
+    /*
+     * If we're in Insert or Replace mode and 'showmatch' is set, then briefly
+     * show the match for right parens and braces.
+     */
+    if (p_sm && (State & INSERT)
+	    && msg_silent == 0
+#ifdef FEAT_INS_EXPAND
+	    && !ins_compl_active()
+#endif
+       )
+    {
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	    showmatch(mb_ptr2char(buf));
+	else
+#endif
+	    showmatch(c);
+    }
+
+#ifdef FEAT_RIGHTLEFT
+    if (!p_ri || (State & REPLACE_FLAG))
+#endif
+    {
+	/* Normal insert: move cursor right */
+#ifdef FEAT_MBYTE
+	curwin->w_cursor.col += charlen;
+#else
+	++curwin->w_cursor.col;
+#endif
+    }
+    /*
+     * TODO: should try to update w_row here, to avoid recomputing it later.
+     */
+}
+
+/*
+ * Insert a string at the cursor position.
+ * Note: Does NOT handle Replace mode.
+ * Caller must have prepared for undo.
+ */
+    void
+ins_str(char_u *s)
+{
+    char_u	*oldp, *newp;
+    int		newlen = (int)STRLEN(s);
+    int		oldlen;
+    colnr_T	col;
+    linenr_T	lnum = curwin->w_cursor.lnum;
+
+#ifdef FEAT_VIRTUALEDIT
+    if (virtual_active() && curwin->w_cursor.coladd > 0)
+	coladvance_force(getviscol());
+#endif
+
+    col = curwin->w_cursor.col;
+    oldp = ml_get(lnum);
+    oldlen = (int)STRLEN(oldp);
+
+    newp = alloc_check((unsigned)(oldlen + newlen + 1));
+    if (newp == NULL)
+	return;
+    if (col > 0)
+	mch_memmove(newp, oldp, (size_t)col);
+    mch_memmove(newp + col, s, (size_t)newlen);
+    mch_memmove(newp + col + newlen, oldp + col, (size_t)(oldlen - col + 1));
+    ml_replace(lnum, newp, FALSE);
+    changed_bytes(lnum, col);
+    curwin->w_cursor.col += newlen;
+}
+
+/*
+ * Delete one character under the cursor.
+ * If "fixpos" is TRUE, don't leave the cursor on the NUL after the line.
+ * Caller must have prepared for undo.
+ *
+ * return FAIL for failure, OK otherwise
+ */
+    int
+del_char(int fixpos)
+{
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+    {
+	/* Make sure the cursor is at the start of a character. */
+	mb_adjust_cursor();
+	if (*ml_get_cursor() == NUL)
+	    return FAIL;
+	return del_chars(1L, fixpos);
+    }
+#endif
+    return del_bytes(1L, fixpos, TRUE);
+}
+
+#if defined(FEAT_MBYTE) || defined(PROTO)
+/*
+ * Like del_bytes(), but delete characters instead of bytes.
+ */
+    int
+del_chars(long count, int fixpos)
+{
+    long	bytes = 0;
+    long	i;
+    char_u	*p;
+    int		l;
+
+    p = ml_get_cursor();
+    for (i = 0; i < count && *p != NUL; ++i)
+    {
+	l = (*mb_ptr2len)(p);
+	bytes += l;
+	p += l;
+    }
+    return del_bytes(bytes, fixpos, TRUE);
+}
+#endif
+
+/*
+ * Delete "count" bytes under the cursor.
+ * If "fixpos" is TRUE, don't leave the cursor on the NUL after the line.
+ * Caller must have prepared for undo.
+ *
+ * Return FAIL for failure, OK otherwise.
+ */
+    int
+del_bytes(
+    long	count,
+    int		fixpos_arg,
+    int		use_delcombine UNUSED)	    /* 'delcombine' option applies */
+{
+    char_u	*oldp, *newp;
+    colnr_T	oldlen;
+    linenr_T	lnum = curwin->w_cursor.lnum;
+    colnr_T	col = curwin->w_cursor.col;
+    int		was_alloced;
+    long	movelen;
+    int		fixpos = fixpos_arg;
+
+    oldp = ml_get(lnum);
+    oldlen = (int)STRLEN(oldp);
+
+    /* Can't do anything when the cursor is on the NUL after the line. */
+    if (col >= oldlen)
+	return FAIL;
+
+    /* If "count" is zero there is nothing to do. */
+    if (count == 0)
+	return OK;
+
+    /* If "count" is negative the caller must be doing something wrong. */
+    if (count < 1)
+    {
+	IEMSGN("E950: Invalid count for del_bytes(): %ld", count);
+	return FAIL;
+    }
+
+#ifdef FEAT_MBYTE
+    /* If 'delcombine' is set and deleting (less than) one character, only
+     * delete the last combining character. */
+    if (p_deco && use_delcombine && enc_utf8
+					 && utfc_ptr2len(oldp + col) >= count)
+    {
+	int	cc[MAX_MCO];
+	int	n;
+
+	(void)utfc_ptr2char(oldp + col, cc);
+	if (cc[0] != NUL)
+	{
+	    /* Find the last composing char, there can be several. */
+	    n = col;
+	    do
+	    {
+		col = n;
+		count = utf_ptr2len(oldp + n);
+		n += count;
+	    } while (UTF_COMPOSINGLIKE(oldp + col, oldp + n));
+	    fixpos = 0;
+	}
+    }
+#endif
+
+    /*
+     * When count is too big, reduce it.
+     */
+    movelen = (long)oldlen - (long)col - count + 1; /* includes trailing NUL */
+    if (movelen <= 1)
+    {
+	/*
+	 * If we just took off the last character of a non-blank line, and
+	 * fixpos is TRUE, we don't want to end up positioned at the NUL,
+	 * unless "restart_edit" is set or 'virtualedit' contains "onemore".
+	 */
+	if (col > 0 && fixpos && restart_edit == 0
+#ifdef FEAT_VIRTUALEDIT
+					      && (ve_flags & VE_ONEMORE) == 0
+#endif
+					      )
+	{
+	    --curwin->w_cursor.col;
+#ifdef FEAT_VIRTUALEDIT
+	    curwin->w_cursor.coladd = 0;
+#endif
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		curwin->w_cursor.col -=
+			    (*mb_head_off)(oldp, oldp + curwin->w_cursor.col);
+#endif
+	}
+	count = oldlen - col;
+	movelen = 1;
+    }
+
+    /*
+     * If the old line has been allocated the deletion can be done in the
+     * existing line. Otherwise a new line has to be allocated
+     * Can't do this when using Netbeans, because we would need to invoke
+     * netbeans_removed(), which deallocates the line.  Let ml_replace() take
+     * care of notifying Netbeans.
+     */
+#ifdef FEAT_NETBEANS_INTG
+    if (netbeans_active())
+	was_alloced = FALSE;
+    else
+#endif
+	was_alloced = ml_line_alloced();    /* check if oldp was allocated */
+    if (was_alloced)
+	newp = oldp;			    /* use same allocated memory */
+    else
+    {					    /* need to allocate a new line */
+	newp = alloc((unsigned)(oldlen + 1 - count));
+	if (newp == NULL)
+	    return FAIL;
+	mch_memmove(newp, oldp, (size_t)col);
+    }
+    mch_memmove(newp + col, oldp + col + count, (size_t)movelen);
+    if (!was_alloced)
+	ml_replace(lnum, newp, FALSE);
+
+    /* mark the buffer as changed and prepare for displaying */
+    changed_bytes(lnum, curwin->w_cursor.col);
+
+    return OK;
+}
+
+/*
+ * Delete from cursor to end of line.
+ * Caller must have prepared for undo.
+ *
+ * return FAIL for failure, OK otherwise
+ */
+    int
+truncate_line(
+    int		fixpos)	    /* if TRUE fix the cursor position when done */
+{
+    char_u	*newp;
+    linenr_T	lnum = curwin->w_cursor.lnum;
+    colnr_T	col = curwin->w_cursor.col;
+
+    if (col == 0)
+	newp = vim_strsave((char_u *)"");
+    else
+	newp = vim_strnsave(ml_get(lnum), col);
+
+    if (newp == NULL)
+	return FAIL;
+
+    ml_replace(lnum, newp, FALSE);
+
+    /* mark the buffer as changed and prepare for displaying */
+    changed_bytes(lnum, curwin->w_cursor.col);
+
+    /*
+     * If "fixpos" is TRUE we don't want to end up positioned at the NUL.
+     */
+    if (fixpos && curwin->w_cursor.col > 0)
+	--curwin->w_cursor.col;
+
+    return OK;
+}
+
+/*
+ * Delete "nlines" lines at the cursor.
+ * Saves the lines for undo first if "undo" is TRUE.
+ */
+    void
+del_lines(
+    long	nlines,		/* number of lines to delete */
+    int		undo)		/* if TRUE, prepare for undo */
+{
+    long	n;
+    linenr_T	first = curwin->w_cursor.lnum;
+
+    if (nlines <= 0)
+	return;
+
+    /* save the deleted lines for undo */
+    if (undo && u_savedel(first, nlines) == FAIL)
+	return;
+
+    for (n = 0; n < nlines; )
+    {
+	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
+	    break;
+
+	ml_delete(first, TRUE);
+	++n;
+
+	/* If we delete the last line in the file, stop */
+	if (first > curbuf->b_ml.ml_line_count)
+	    break;
+    }
+
+    /* Correct the cursor position before calling deleted_lines_mark(), it may
+     * trigger a callback to display the cursor. */
+    curwin->w_cursor.col = 0;
+    check_cursor_lnum();
+
+    /* adjust marks, mark the buffer as changed and prepare for displaying */
+    deleted_lines_mark(first, n);
+}
+
+    int
+gchar_pos(pos_T *pos)
+{
+    char_u	*ptr;
+
+    /* When searching columns is sometimes put at the end of a line. */
+    if (pos->col == MAXCOL)
+	return NUL;
+    ptr = ml_get_pos(pos);
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+	return (*mb_ptr2char)(ptr);
+#endif
+    return (int)*ptr;
+}
+
+    int
+gchar_cursor(void)
+{
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+	return (*mb_ptr2char)(ml_get_cursor());
+#endif
+    return (int)*ml_get_cursor();
+}
+
+/*
+ * Write a character at the current cursor position.
+ * It is directly written into the block.
+ */
+    void
+pchar_cursor(int c)
+{
+    *(ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE)
+						  + curwin->w_cursor.col) = c;
+}
+
+/*
+ * When extra == 0: Return TRUE if the cursor is before or on the first
+ *		    non-blank in the line.
+ * When extra == 1: Return TRUE if the cursor is before the first non-blank in
+ *		    the line.
+ */
+    int
+inindent(int extra)
+{
+    char_u	*ptr;
+    colnr_T	col;
+
+    for (col = 0, ptr = ml_get_curline(); VIM_ISWHITE(*ptr); ++col)
+	++ptr;
+    if (col >= curwin->w_cursor.col + extra)
+	return TRUE;
+    else
+	return FALSE;
+}
+
+/*
+ * Skip to next part of an option argument: Skip space and comma.
+ */
+    char_u *
+skip_to_option_part(char_u *p)
+{
+    if (*p == ',')
+	++p;
+    while (*p == ' ')
+	++p;
+    return p;
+}
+
+/*
+ * Call this function when something in the current buffer is changed.
+ *
+ * Most often called through changed_bytes() and changed_lines(), which also
+ * mark the area of the display to be redrawn.
+ *
+ * Careful: may trigger autocommands that reload the buffer.
+ */
+    void
+changed(void)
+{
+#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
+    if (p_imst == IM_ON_THE_SPOT)
+    {
+	/* The text of the preediting area is inserted, but this doesn't
+	 * mean a change of the buffer yet.  That is delayed until the
+	 * text is committed. (this means preedit becomes empty) */
+	if (im_is_preediting() && !xim_changed_while_preediting)
+	    return;
+	xim_changed_while_preediting = FALSE;
+    }
+#endif
+
+    if (!curbuf->b_changed)
+    {
+	int	save_msg_scroll = msg_scroll;
+
+	/* Give a warning about changing a read-only file.  This may also
+	 * check-out the file, thus change "curbuf"! */
+	change_warning(0);
+
+	/* Create a swap file if that is wanted.
+	 * Don't do this for "nofile" and "nowrite" buffer types. */
+	if (curbuf->b_may_swap
+#ifdef FEAT_QUICKFIX
+		&& !bt_dontwrite(curbuf)
+#endif
+		)
+	{
+	    int save_need_wait_return = need_wait_return;
+
+	    need_wait_return = FALSE;
+	    ml_open_file(curbuf);
+
+	    /* The ml_open_file() can cause an ATTENTION message.
+	     * Wait two seconds, to make sure the user reads this unexpected
+	     * message.  Since we could be anywhere, call wait_return() now,
+	     * and don't let the emsg() set msg_scroll. */
+	    if (need_wait_return && emsg_silent == 0)
+	    {
+		out_flush();
+		ui_delay(2000L, TRUE);
+		wait_return(TRUE);
+		msg_scroll = save_msg_scroll;
+	    }
+	    else
+		need_wait_return = save_need_wait_return;
+	}
+	changed_int();
+    }
+    ++CHANGEDTICK(curbuf);
+}
+
+/*
+ * Internal part of changed(), no user interaction.
+ */
+    void
+changed_int(void)
+{
+    curbuf->b_changed = TRUE;
+    ml_setflags(curbuf);
+    check_status(curbuf);
+    redraw_tabline = TRUE;
+#ifdef FEAT_TITLE
+    need_maketitle = TRUE;	    /* set window title later */
+#endif
+}
+
+static void changedOneline(buf_T *buf, linenr_T lnum);
+static void changed_lines_buf(buf_T *buf, linenr_T lnum, linenr_T lnume, long xtra);
+static void changed_common(linenr_T lnum, colnr_T col, linenr_T lnume, long xtra);
+
+/*
+ * Changed bytes within a single line for the current buffer.
+ * - marks the windows on this buffer to be redisplayed
+ * - marks the buffer changed by calling changed()
+ * - invalidates cached values
+ * Careful: may trigger autocommands that reload the buffer.
+ */
+    void
+changed_bytes(linenr_T lnum, colnr_T col)
+{
+    changedOneline(curbuf, lnum);
+    changed_common(lnum, col, lnum + 1, 0L);
+
+#ifdef FEAT_DIFF
+    /* Diff highlighting in other diff windows may need to be updated too. */
+    if (curwin->w_p_diff)
+    {
+	win_T	    *wp;
+	linenr_T    wlnum;
+
+	FOR_ALL_WINDOWS(wp)
+	    if (wp->w_p_diff && wp != curwin)
+	    {
+		redraw_win_later(wp, VALID);
+		wlnum = diff_lnum_win(lnum, wp);
+		if (wlnum > 0)
+		    changedOneline(wp->w_buffer, wlnum);
+	    }
+    }
+#endif
+}
+
+    static void
+changedOneline(buf_T *buf, linenr_T lnum)
+{
+    if (buf->b_mod_set)
+    {
+	/* find the maximum area that must be redisplayed */
+	if (lnum < buf->b_mod_top)
+	    buf->b_mod_top = lnum;
+	else if (lnum >= buf->b_mod_bot)
+	    buf->b_mod_bot = lnum + 1;
+    }
+    else
+    {
+	/* set the area that must be redisplayed to one line */
+	buf->b_mod_set = TRUE;
+	buf->b_mod_top = lnum;
+	buf->b_mod_bot = lnum + 1;
+	buf->b_mod_xlines = 0;
+    }
+}
+
+/*
+ * Appended "count" lines below line "lnum" in the current buffer.
+ * Must be called AFTER the change and after mark_adjust().
+ * Takes care of marking the buffer to be redrawn and sets the changed flag.
+ */
+    void
+appended_lines(linenr_T lnum, long count)
+{
+    changed_lines(lnum + 1, 0, lnum + 1, count);
+}
+
+/*
+ * Like appended_lines(), but adjust marks first.
+ */
+    void
+appended_lines_mark(linenr_T lnum, long count)
+{
+    /* Skip mark_adjust when adding a line after the last one, there can't
+     * be marks there. But it's still needed in diff mode. */
+    if (lnum + count < curbuf->b_ml.ml_line_count
+#ifdef FEAT_DIFF
+	    || curwin->w_p_diff
+#endif
+	)
+	mark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);
+    changed_lines(lnum + 1, 0, lnum + 1, count);
+}
+
+/*
+ * Deleted "count" lines at line "lnum" in the current buffer.
+ * Must be called AFTER the change and after mark_adjust().
+ * Takes care of marking the buffer to be redrawn and sets the changed flag.
+ */
+    void
+deleted_lines(linenr_T lnum, long count)
+{
+    changed_lines(lnum, 0, lnum + count, -count);
+}
+
+/*
+ * Like deleted_lines(), but adjust marks first.
+ * Make sure the cursor is on a valid line before calling, a GUI callback may
+ * be triggered to display the cursor.
+ */
+    void
+deleted_lines_mark(linenr_T lnum, long count)
+{
+    mark_adjust(lnum, (linenr_T)(lnum + count - 1), (long)MAXLNUM, -count);
+    changed_lines(lnum, 0, lnum + count, -count);
+}
+
+/*
+ * Changed lines for the current buffer.
+ * Must be called AFTER the change and after mark_adjust().
+ * - mark the buffer changed by calling changed()
+ * - mark the windows on this buffer to be redisplayed
+ * - invalidate cached values
+ * "lnum" is the first line that needs displaying, "lnume" the first line
+ * below the changed lines (BEFORE the change).
+ * When only inserting lines, "lnum" and "lnume" are equal.
+ * Takes care of calling changed() and updating b_mod_*.
+ * Careful: may trigger autocommands that reload the buffer.
+ */
+    void
+changed_lines(
+    linenr_T	lnum,	    /* first line with change */
+    colnr_T	col,	    /* column in first line with change */
+    linenr_T	lnume,	    /* line below last changed line */
+    long	xtra)	    /* number of extra lines (negative when deleting) */
+{
+    changed_lines_buf(curbuf, lnum, lnume, xtra);
+
+#ifdef FEAT_DIFF
+    if (xtra == 0 && curwin->w_p_diff)
+    {
+	/* When the number of lines doesn't change then mark_adjust() isn't
+	 * called and other diff buffers still need to be marked for
+	 * displaying. */
+	win_T	    *wp;
+	linenr_T    wlnum;
+
+	FOR_ALL_WINDOWS(wp)
+	    if (wp->w_p_diff && wp != curwin)
+	    {
+		redraw_win_later(wp, VALID);
+		wlnum = diff_lnum_win(lnum, wp);
+		if (wlnum > 0)
+		    changed_lines_buf(wp->w_buffer, wlnum,
+						    lnume - lnum + wlnum, 0L);
+	    }
+    }
+#endif
+
+    changed_common(lnum, col, lnume, xtra);
+}
+
+    static void
+changed_lines_buf(
+    buf_T	*buf,
+    linenr_T	lnum,	    /* first line with change */
+    linenr_T	lnume,	    /* line below last changed line */
+    long	xtra)	    /* number of extra lines (negative when deleting) */
+{
+    if (buf->b_mod_set)
+    {
+	/* find the maximum area that must be redisplayed */
+	if (lnum < buf->b_mod_top)
+	    buf->b_mod_top = lnum;
+	if (lnum < buf->b_mod_bot)
+	{
+	    /* adjust old bot position for xtra lines */
+	    buf->b_mod_bot += xtra;
+	    if (buf->b_mod_bot < lnum)
+		buf->b_mod_bot = lnum;
+	}
+	if (lnume + xtra > buf->b_mod_bot)
+	    buf->b_mod_bot = lnume + xtra;
+	buf->b_mod_xlines += xtra;
+    }
+    else
+    {
+	/* set the area that must be redisplayed */
+	buf->b_mod_set = TRUE;
+	buf->b_mod_top = lnum;
+	buf->b_mod_bot = lnume + xtra;
+	buf->b_mod_xlines = xtra;
+    }
+}
+
+/*
+ * Common code for when a change is was made.
+ * See changed_lines() for the arguments.
+ * Careful: may trigger autocommands that reload the buffer.
+ */
+    static void
+changed_common(
+    linenr_T	lnum,
+    colnr_T	col,
+    linenr_T	lnume,
+    long	xtra)
+{
+    win_T	*wp;
+    tabpage_T	*tp;
+    int		i;
+#ifdef FEAT_JUMPLIST
+    int		cols;
+    pos_T	*p;
+    int		add;
+#endif
+
+    /* mark the buffer as modified */
+    changed();
+
+    /* set the '. mark */
+    if (!cmdmod.keepjumps)
+    {
+	curbuf->b_last_change.lnum = lnum;
+	curbuf->b_last_change.col = col;
+
+#ifdef FEAT_JUMPLIST
+	/* Create a new entry if a new undo-able change was started or we
+	 * don't have an entry yet. */
+	if (curbuf->b_new_change || curbuf->b_changelistlen == 0)
+	{
+	    if (curbuf->b_changelistlen == 0)
+		add = TRUE;
+	    else
+	    {
+		/* Don't create a new entry when the line number is the same
+		 * as the last one and the column is not too far away.  Avoids
+		 * creating many entries for typing "xxxxx". */
+		p = &curbuf->b_changelist[curbuf->b_changelistlen - 1];
+		if (p->lnum != lnum)
+		    add = TRUE;
+		else
+		{
+		    cols = comp_textwidth(FALSE);
+		    if (cols == 0)
+			cols = 79;
+		    add = (p->col + cols < col || col + cols < p->col);
+		}
+	    }
+	    if (add)
+	    {
+		/* This is the first of a new sequence of undo-able changes
+		 * and it's at some distance of the last change.  Use a new
+		 * position in the changelist. */
+		curbuf->b_new_change = FALSE;
+
+		if (curbuf->b_changelistlen == JUMPLISTSIZE)
+		{
+		    /* changelist is full: remove oldest entry */
+		    curbuf->b_changelistlen = JUMPLISTSIZE - 1;
+		    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,
+					  sizeof(pos_T) * (JUMPLISTSIZE - 1));
+		    FOR_ALL_TAB_WINDOWS(tp, wp)
+		    {
+			/* Correct position in changelist for other windows on
+			 * this buffer. */
+			if (wp->w_buffer == curbuf && wp->w_changelistidx > 0)
+			    --wp->w_changelistidx;
+		    }
+		}
+		FOR_ALL_TAB_WINDOWS(tp, wp)
+		{
+		    /* For other windows, if the position in the changelist is
+		     * at the end it stays at the end. */
+		    if (wp->w_buffer == curbuf
+			    && wp->w_changelistidx == curbuf->b_changelistlen)
+			++wp->w_changelistidx;
+		}
+		++curbuf->b_changelistlen;
+	    }
+	}
+	curbuf->b_changelist[curbuf->b_changelistlen - 1] =
+							curbuf->b_last_change;
+	/* The current window is always after the last change, so that "g,"
+	 * takes you back to it. */
+	curwin->w_changelistidx = curbuf->b_changelistlen;
+#endif
+    }
+
+    FOR_ALL_TAB_WINDOWS(tp, wp)
+    {
+	if (wp->w_buffer == curbuf)
+	{
+	    /* Mark this window to be redrawn later. */
+	    if (wp->w_redr_type < VALID)
+		wp->w_redr_type = VALID;
+
+	    /* Check if a change in the buffer has invalidated the cached
+	     * values for the cursor. */
+#ifdef FEAT_FOLDING
+	    /*
+	     * Update the folds for this window.  Can't postpone this, because
+	     * a following operator might work on the whole fold: ">>dd".
+	     */
+	    foldUpdate(wp, lnum, lnume + xtra - 1);
+
+	    /* The change may cause lines above or below the change to become
+	     * included in a fold.  Set lnum/lnume to the first/last line that
+	     * might be displayed differently.
+	     * Set w_cline_folded here as an efficient way to update it when
+	     * inserting lines just above a closed fold. */
+	    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);
+	    if (wp->w_cursor.lnum == lnum)
+		wp->w_cline_folded = i;
+	    i = hasFoldingWin(wp, lnume, NULL, &lnume, FALSE, NULL);
+	    if (wp->w_cursor.lnum == lnume)
+		wp->w_cline_folded = i;
+
+	    /* If the changed line is in a range of previously folded lines,
+	     * compare with the first line in that range. */
+	    if (wp->w_cursor.lnum <= lnum)
+	    {
+		i = find_wl_entry(wp, lnum);
+		if (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)
+		    changed_line_abv_curs_win(wp);
+	    }
+#endif
+
+	    if (wp->w_cursor.lnum > lnum)
+		changed_line_abv_curs_win(wp);
+	    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)
+		changed_cline_bef_curs_win(wp);
+	    if (wp->w_botline >= lnum)
+	    {
+		/* Assume that botline doesn't change (inserted lines make
+		 * other lines scroll down below botline). */
+		approximate_botline_win(wp);
+	    }
+
+	    /* Check if any w_lines[] entries have become invalid.
+	     * For entries below the change: Correct the lnums for
+	     * inserted/deleted lines.  Makes it possible to stop displaying
+	     * after the change. */
+	    for (i = 0; i < wp->w_lines_valid; ++i)
+		if (wp->w_lines[i].wl_valid)
+		{
+		    if (wp->w_lines[i].wl_lnum >= lnum)
+		    {
+			if (wp->w_lines[i].wl_lnum < lnume)
+			{
+			    /* line included in change */
+			    wp->w_lines[i].wl_valid = FALSE;
+			}
+			else if (xtra != 0)
+			{
+			    /* line below change */
+			    wp->w_lines[i].wl_lnum += xtra;
+#ifdef FEAT_FOLDING
+			    wp->w_lines[i].wl_lastlnum += xtra;
+#endif
+			}
+		    }
+#ifdef FEAT_FOLDING
+		    else if (wp->w_lines[i].wl_lastlnum >= lnum)
+		    {
+			/* change somewhere inside this range of folded lines,
+			 * may need to be redrawn */
+			wp->w_lines[i].wl_valid = FALSE;
+		    }
+#endif
+		}
+
+#ifdef FEAT_FOLDING
+	    /* Take care of side effects for setting w_topline when folds have
+	     * changed.  Esp. when the buffer was changed in another window. */
+	    if (hasAnyFolding(wp))
+		set_topline(wp, wp->w_topline);
+#endif
+	    /* relative numbering may require updating more */
+	    if (wp->w_p_rnu)
+		redraw_win_later(wp, SOME_VALID);
+	}
+    }
+
+    /* Call update_screen() later, which checks out what needs to be redrawn,
+     * since it notices b_mod_set and then uses b_mod_*. */
+    if (must_redraw < VALID)
+	must_redraw = VALID;
+
+    /* when the cursor line is changed always trigger CursorMoved */
+    if (lnum <= curwin->w_cursor.lnum
+		 && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)
+	last_cursormoved.lnum = 0;
+}
+
+/*
+ * unchanged() is called when the changed flag must be reset for buffer 'buf'
+ */
+    void
+unchanged(
+    buf_T	*buf,
+    int		ff)	/* also reset 'fileformat' */
+{
+    if (buf->b_changed || (ff && file_ff_differs(buf, FALSE)))
+    {
+	buf->b_changed = 0;
+	ml_setflags(buf);
+	if (ff)
+	    save_file_ff(buf);
+	check_status(buf);
+	redraw_tabline = TRUE;
+#ifdef FEAT_TITLE
+	need_maketitle = TRUE;	    /* set window title later */
+#endif
+    }
+    ++CHANGEDTICK(buf);
+#ifdef FEAT_NETBEANS_INTG
+    netbeans_unmodified(buf);
+#endif
+}
+
+/*
+ * check_status: called when the status bars for the buffer 'buf'
+ *		 need to be updated
+ */
+    void
+check_status(buf_T *buf)
+{
+    win_T	*wp;
+
+    FOR_ALL_WINDOWS(wp)
+	if (wp->w_buffer == buf && wp->w_status_height)
+	{
+	    wp->w_redr_status = TRUE;
+	    if (must_redraw < VALID)
+		must_redraw = VALID;
+	}
+}
+
+/*
+ * If the file is readonly, give a warning message with the first change.
+ * Don't do this for autocommands.
+ * Don't use emsg(), because it flushes the macro buffer.
+ * If we have undone all changes b_changed will be FALSE, but "b_did_warn"
+ * will be TRUE.
+ * Careful: may trigger autocommands that reload the buffer.
+ */
+    void
+change_warning(
+    int	    col)		/* column for message; non-zero when in insert
+				   mode and 'showmode' is on */
+{
+    static char *w_readonly = N_("W10: Warning: Changing a readonly file");
+
+    if (curbuf->b_did_warn == FALSE
+	    && curbufIsChanged() == 0
+	    && !autocmd_busy
+	    && curbuf->b_p_ro)
+    {
+	++curbuf_lock;
+	apply_autocmds(EVENT_FILECHANGEDRO, NULL, NULL, FALSE, curbuf);
+	--curbuf_lock;
+	if (!curbuf->b_p_ro)
+	    return;
+	/*
+	 * Do what msg() does, but with a column offset if the warning should
+	 * be after the mode message.
+	 */
+	msg_start();
+	if (msg_row == Rows - 1)
+	    msg_col = col;
+	msg_source(HL_ATTR(HLF_W));
+	MSG_PUTS_ATTR(_(w_readonly), HL_ATTR(HLF_W) | MSG_HIST);
+#ifdef FEAT_EVAL
+	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
+#endif
+	msg_clr_eos();
+	(void)msg_end();
+	if (msg_silent == 0 && !silent_mode
+#ifdef FEAT_EVAL
+		&& time_for_testing != 1
+#endif
+		)
+	{
+	    out_flush();
+	    ui_delay(1000L, TRUE); /* give the user time to think about it */
+	}
+	curbuf->b_did_warn = TRUE;
+	redraw_cmdline = FALSE;	/* don't redraw and erase the message */
+	if (msg_row < Rows - 1)
+	    showmode();
+    }
+}
+
+/*
+ * Ask for a reply from the user, a 'y' or a 'n'.
+ * No other characters are accepted, the message is repeated until a valid
+ * reply is entered or CTRL-C is hit.
+ * If direct is TRUE, don't use vgetc() but ui_inchar(), don't get characters
+ * from any buffers but directly from the user.
+ *
+ * return the 'y' or 'n'
+ */
+    int
+ask_yesno(char_u *str, int direct)
+{
+    int	    r = ' ';
+    int	    save_State = State;
+
+    if (exiting)		/* put terminal in raw mode for this question */
+	settmode(TMODE_RAW);
+    ++no_wait_return;
+#ifdef USE_ON_FLY_SCROLL
+    dont_scroll = TRUE;		/* disallow scrolling here */
+#endif
+    State = CONFIRM;		/* mouse behaves like with :confirm */
+#ifdef FEAT_MOUSE
+    setmouse();			/* disables mouse for xterm */
+#endif
+    ++no_mapping;
+    ++allow_keys;		/* no mapping here, but recognize keys */
+
+    while (r != 'y' && r != 'n')
+    {
+	/* same highlighting as for wait_return */
+	smsg_attr(HL_ATTR(HLF_R), (char_u *)"%s (y/n)?", str);
+	if (direct)
+	    r = get_keystroke();
+	else
+	    r = plain_vgetc();
+	if (r == Ctrl_C || r == ESC)
+	    r = 'n';
+	msg_putchar(r);	    /* show what you typed */
+	out_flush();
+    }
+    --no_wait_return;
+    State = save_State;
+#ifdef FEAT_MOUSE
+    setmouse();
+#endif
+    --no_mapping;
+    --allow_keys;
+
+    return r;
+}
+
+#if defined(FEAT_MOUSE) || defined(PROTO)
+/*
+ * Return TRUE if "c" is a mouse key.
+ */
+    int
+is_mouse_key(int c)
+{
+    return c == K_LEFTMOUSE
+	|| c == K_LEFTMOUSE_NM
+	|| c == K_LEFTDRAG
+	|| c == K_LEFTRELEASE
+	|| c == K_LEFTRELEASE_NM
+	|| c == K_MOUSEMOVE
+	|| c == K_MIDDLEMOUSE
+	|| c == K_MIDDLEDRAG
+	|| c == K_MIDDLERELEASE
+	|| c == K_RIGHTMOUSE
+	|| c == K_RIGHTDRAG
+	|| c == K_RIGHTRELEASE
+	|| c == K_MOUSEDOWN
+	|| c == K_MOUSEUP
+	|| c == K_MOUSELEFT
+	|| c == K_MOUSERIGHT
+	|| c == K_X1MOUSE
+	|| c == K_X1DRAG
+	|| c == K_X1RELEASE
+	|| c == K_X2MOUSE
+	|| c == K_X2DRAG
+	|| c == K_X2RELEASE;
+}
+#endif
+
+/*
+ * Get a key stroke directly from the user.
+ * Ignores mouse clicks and scrollbar events, except a click for the left
+ * button (used at the more prompt).
+ * Doesn't use vgetc(), because it syncs undo and eats mapped characters.
+ * Disadvantage: typeahead is ignored.
+ * Translates the interrupt character for unix to ESC.
+ */
+    int
+get_keystroke(void)
+{
+    char_u	*buf = NULL;
+    int		buflen = 150;
+    int		maxlen;
+    int		len = 0;
+    int		n;
+    int		save_mapped_ctrl_c = mapped_ctrl_c;
+    int		waited = 0;
+
+    mapped_ctrl_c = FALSE;	/* mappings are not used here */
+    for (;;)
+    {
+	cursor_on();
+	out_flush();
+
+	/* Leave some room for check_termcode() to insert a key code into (max
+	 * 5 chars plus NUL).  And fix_input_buffer() can triple the number of
+	 * bytes. */
+	maxlen = (buflen - 6 - len) / 3;
+	if (buf == NULL)
+	    buf = alloc(buflen);
+	else if (maxlen < 10)
+	{
+	    char_u  *t_buf = buf;
+
+	    /* Need some more space. This might happen when receiving a long
+	     * escape sequence. */
+	    buflen += 100;
+	    buf = vim_realloc(buf, buflen);
+	    if (buf == NULL)
+		vim_free(t_buf);
+	    maxlen = (buflen - 6 - len) / 3;
+	}
+	if (buf == NULL)
+	{
+	    do_outofmem_msg((long_u)buflen);
+	    return ESC;  /* panic! */
+	}
+
+	/* First time: blocking wait.  Second time: wait up to 100ms for a
+	 * terminal code to complete. */
+	n = ui_inchar(buf + len, maxlen, len == 0 ? -1L : 100L, 0);
+	if (n > 0)
+	{
+	    /* Replace zero and CSI by a special key code. */
+	    n = fix_input_buffer(buf + len, n);
+	    len += n;
+	    waited = 0;
+	}
+	else if (len > 0)
+	    ++waited;	    /* keep track of the waiting time */
+
+	/* Incomplete termcode and not timed out yet: get more characters */
+	if ((n = check_termcode(1, buf, buflen, &len)) < 0
+	       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))
+	    continue;
+
+	if (n == KEYLEN_REMOVED)  /* key code removed */
+	{
+	    if (must_redraw != 0 && !need_wait_return && (State & CMDLINE) == 0)
+	    {
+		/* Redrawing was postponed, do it now. */
+		update_screen(0);
+		setcursor(); /* put cursor back where it belongs */
+	    }
+	    continue;
+	}
+	if (n > 0)		/* found a termcode: adjust length */
+	    len = n;
+	if (len == 0)		/* nothing typed yet */
+	    continue;
+
+	/* Handle modifier and/or special key code. */
+	n = buf[0];
+	if (n == K_SPECIAL)
+	{
+	    n = TO_SPECIAL(buf[1], buf[2]);
+	    if (buf[1] == KS_MODIFIER
+		    || n == K_IGNORE
+#ifdef FEAT_MOUSE
+		    || (is_mouse_key(n) && n != K_LEFTMOUSE)
+#endif
+#ifdef FEAT_GUI
+		    || n == K_VER_SCROLLBAR
+		    || n == K_HOR_SCROLLBAR
+#endif
+	       )
+	    {
+		if (buf[1] == KS_MODIFIER)
+		    mod_mask = buf[2];
+		len -= 3;
+		if (len > 0)
+		    mch_memmove(buf, buf + 3, (size_t)len);
+		continue;
+	    }
+	    break;
+	}
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    if (MB_BYTE2LEN(n) > len)
+		continue;	/* more bytes to get */
+	    buf[len >= buflen ? buflen - 1 : len] = NUL;
+	    n = (*mb_ptr2char)(buf);
+	}
+#endif
+#ifdef UNIX
+	if (n == intr_char)
+	    n = ESC;
+#endif
+	break;
+    }
+    vim_free(buf);
+
+    mapped_ctrl_c = save_mapped_ctrl_c;
+    return n;
+}
+
+/*
+ * Get a number from the user.
+ * When "mouse_used" is not NULL allow using the mouse.
+ */
+    int
+get_number(
+    int	    colon,			/* allow colon to abort */
+    int	    *mouse_used)
+{
+    int	n = 0;
+    int	c;
+    int typed = 0;
+
+    if (mouse_used != NULL)
+	*mouse_used = FALSE;
+
+    /* When not printing messages, the user won't know what to type, return a
+     * zero (as if CR was hit). */
+    if (msg_silent != 0)
+	return 0;
+
+#ifdef USE_ON_FLY_SCROLL
+    dont_scroll = TRUE;		/* disallow scrolling here */
+#endif
+    ++no_mapping;
+    ++allow_keys;		/* no mapping here, but recognize keys */
+    for (;;)
+    {
+	windgoto(msg_row, msg_col);
+	c = safe_vgetc();
+	if (VIM_ISDIGIT(c))
+	{
+	    n = n * 10 + c - '0';
+	    msg_putchar(c);
+	    ++typed;
+	}
+	else if (c == K_DEL || c == K_KDEL || c == K_BS || c == Ctrl_H)
+	{
+	    if (typed > 0)
+	    {
+		MSG_PUTS("\b \b");
+		--typed;
+	    }
+	    n /= 10;
+	}
+#ifdef FEAT_MOUSE
+	else if (mouse_used != NULL && c == K_LEFTMOUSE)
+	{
+	    *mouse_used = TRUE;
+	    n = mouse_row + 1;
+	    break;
+	}
+#endif
+	else if (n == 0 && c == ':' && colon)
+	{
+	    stuffcharReadbuff(':');
+	    if (!exmode_active)
+		cmdline_row = msg_row;
+	    skip_redraw = TRUE;	    /* skip redraw once */
+	    do_redraw = FALSE;
+	    break;
+	}
+	else if (c == CAR || c == NL || c == Ctrl_C || c == ESC)
+	    break;
+    }
+    --no_mapping;
+    --allow_keys;
+    return n;
+}
+
+/*
+ * Ask the user to enter a number.
+ * When "mouse_used" is not NULL allow using the mouse and in that case return
+ * the line number.
+ */
+    int
+prompt_for_number(int *mouse_used)
+{
+    int		i;
+    int		save_cmdline_row;
+    int		save_State;
+
+    /* When using ":silent" assume that <CR> was entered. */
+    if (mouse_used != NULL)
+	MSG_PUTS(_("Type number and <Enter> or click with mouse (empty cancels): "));
+    else
+	MSG_PUTS(_("Type number and <Enter> (empty cancels): "));
+
+    // Set the state such that text can be selected/copied/pasted and we still
+    // get mouse events. redraw_after_callback() will not redraw if cmdline_row
+    // is zero.
+    save_cmdline_row = cmdline_row;
+    cmdline_row = 0;
+    save_State = State;
+    State = CMDLINE;
+#ifdef FEAT_MOUSE
+    // May show different mouse shape.
+    setmouse();
+#endif
+
+    i = get_number(TRUE, mouse_used);
+    if (KeyTyped)
+    {
+	/* don't call wait_return() now */
+	/* msg_putchar('\n'); */
+	cmdline_row = msg_row - 1;
+	need_wait_return = FALSE;
+	msg_didany = FALSE;
+	msg_didout = FALSE;
+    }
+    else
+	cmdline_row = save_cmdline_row;
+    State = save_State;
+#ifdef FEAT_MOUSE
+    // May need to restore mouse shape.
+    setmouse();
+#endif
+
+    return i;
+}
+
+    void
+msgmore(long n)
+{
+    long pn;
+
+    if (global_busy	    /* no messages now, wait until global is finished */
+	    || !messaging())  /* 'lazyredraw' set, don't do messages now */
+	return;
+
+    /* We don't want to overwrite another important message, but do overwrite
+     * a previous "more lines" or "fewer lines" message, so that "5dd" and
+     * then "put" reports the last action. */
+    if (keep_msg != NULL && !keep_msg_more)
+	return;
+
+    if (n > 0)
+	pn = n;
+    else
+	pn = -n;
+
+    if (pn > p_report)
+    {
+	if (n > 0)
+	    vim_snprintf((char *)msg_buf, MSG_BUF_LEN,
+		    NGETTEXT("%ld more line", "%ld more lines", pn), pn);
+	else
+	    vim_snprintf((char *)msg_buf, MSG_BUF_LEN,
+		    NGETTEXT("%ld line less", "%ld fewer lines", pn), pn);
+	if (got_int)
+	    vim_strcat(msg_buf, (char_u *)_(" (Interrupted)"), MSG_BUF_LEN);
+	if (msg(msg_buf))
+	{
+	    set_keep_msg(msg_buf, 0);
+	    keep_msg_more = TRUE;
+	}
+    }
+}
+
+/*
+ * flush map and typeahead buffers and give a warning for an error
+ */
+    void
+beep_flush(void)
+{
+    if (emsg_silent == 0)
+    {
+	flush_buffers(FALSE);
+	vim_beep(BO_ERROR);
+    }
+}
+
+/*
+ * Give a warning for an error.
+ */
+    void
+vim_beep(
+    unsigned val) /* one of the BO_ values, e.g., BO_OPER */
+{
+#ifdef FEAT_EVAL
+    called_vim_beep = TRUE;
+#endif
+
+    if (emsg_silent == 0)
+    {
+	if (!((bo_flags & val) || (bo_flags & BO_ALL)))
+	{
+#ifdef ELAPSED_FUNC
+	    static int		did_init = FALSE;
+	    static ELAPSED_TYPE	start_tv;
+
+	    /* Only beep once per half a second, otherwise a sequence of beeps
+	     * would freeze Vim. */
+	    if (!did_init || ELAPSED_FUNC(start_tv) > 500)
+	    {
+		did_init = TRUE;
+		ELAPSED_INIT(start_tv);
+#endif
+		if (p_vb
+#ifdef FEAT_GUI
+			/* While the GUI is starting up the termcap is set for
+			 * the GUI but the output still goes to a terminal. */
+			&& !(gui.in_use && gui.starting)
+#endif
+			)
+		{
+		    out_str_cf(T_VB);
+#ifdef FEAT_VTP
+		    /* No restore color information, refresh the screen. */
+		    if (has_vtp_working() != 0
+# ifdef FEAT_TERMGUICOLORS
+			    && (p_tgc || (!p_tgc && t_colors >= 256))
+# endif
+			)
+		    {
+			redraw_later(CLEAR);
+			update_screen(0);
+			redrawcmd();
+		    }
+#endif
+		}
+		else
+		    out_char(BELL);
+#ifdef ELAPSED_FUNC
+	    }
+#endif
+	}
+
+	/* When 'debug' contains "beep" produce a message.  If we are sourcing
+	 * a script or executing a function give the user a hint where the beep
+	 * comes from. */
+	if (vim_strchr(p_debug, 'e') != NULL)
+	{
+	    msg_source(HL_ATTR(HLF_W));
+	    msg_attr((char_u *)_("Beep!"), HL_ATTR(HLF_W));
+	}
+    }
+}
+
+/*
+ * To get the "real" home directory:
+ * - get value of $HOME
+ * For Unix:
+ *  - go to that directory
+ *  - do mch_dirname() to get the real name of that directory.
+ *  This also works with mounts and links.
+ *  Don't do this for MS-DOS, it will change the "current dir" for a drive.
+ */
+static char_u	*homedir = NULL;
+
+    void
+init_homedir(void)
+{
+    char_u  *var;
+
+    /* In case we are called a second time (when 'encoding' changes). */
+    VIM_CLEAR(homedir);
+
+#ifdef VMS
+    var = mch_getenv((char_u *)"SYS$LOGIN");
+#else
+    var = mch_getenv((char_u *)"HOME");
+#endif
+
+#ifdef WIN3264
+    /*
+     * Typically, $HOME is not defined on Windows, unless the user has
+     * specifically defined it for Vim's sake.  However, on Windows NT
+     * platforms, $HOMEDRIVE and $HOMEPATH are automatically defined for
+     * each user.  Try constructing $HOME from these.
+     */
+    if (var == NULL || *var == NUL)
+    {
+	char_u *homedrive, *homepath;
+
+	homedrive = mch_getenv((char_u *)"HOMEDRIVE");
+	homepath = mch_getenv((char_u *)"HOMEPATH");
+	if (homepath == NULL || *homepath == NUL)
+	    homepath = (char_u *)"\\";
+	if (homedrive != NULL
+			   && STRLEN(homedrive) + STRLEN(homepath) < MAXPATHL)
+	{
+	    sprintf((char *)NameBuff, "%s%s", homedrive, homepath);
+	    if (NameBuff[0] != NUL)
+		var = NameBuff;
+	}
+    }
+
+    if (var == NULL)
+	var = mch_getenv((char_u *)"USERPROFILE");
+
+    /*
+     * Weird but true: $HOME may contain an indirect reference to another
+     * variable, esp. "%USERPROFILE%".  Happens when $USERPROFILE isn't set
+     * when $HOME is being set.
+     */
+    if (var != NULL && *var == '%')
+    {
+	char_u	*p;
+	char_u	*exp;
+
+	p = vim_strchr(var + 1, '%');
+	if (p != NULL)
+	{
+	    vim_strncpy(NameBuff, var + 1, p - (var + 1));
+	    exp = mch_getenv(NameBuff);
+	    if (exp != NULL && *exp != NUL
+					&& STRLEN(exp) + STRLEN(p) < MAXPATHL)
+	    {
+		vim_snprintf((char *)NameBuff, MAXPATHL, "%s%s", exp, p + 1);
+		var = NameBuff;
+	    }
+	}
+    }
+
+    if (var != NULL && *var == NUL)	/* empty is same as not set */
+	var = NULL;
+
+# ifdef FEAT_MBYTE
+    if (enc_utf8 && var != NULL)
+    {
+	int	len;
+	char_u  *pp = NULL;
+
+	/* Convert from active codepage to UTF-8.  Other conversions are
+	 * not done, because they would fail for non-ASCII characters. */
+	acp_to_enc(var, (int)STRLEN(var), &pp, &len);
+	if (pp != NULL)
+	{
+	    homedir = pp;
+	    return;
+	}
+    }
+# endif
+
+    /*
+     * Default home dir is C:/
+     * Best assumption we can make in such a situation.
+     */
+    if (var == NULL)
+	var = (char_u *)"C:/";
+#endif
+
+    if (var != NULL)
+    {
+#ifdef UNIX
+	/*
+	 * Change to the directory and get the actual path.  This resolves
+	 * links.  Don't do it when we can't return.
+	 */
+	if (mch_dirname(NameBuff, MAXPATHL) == OK
+					  && mch_chdir((char *)NameBuff) == 0)
+	{
+	    if (!mch_chdir((char *)var) && mch_dirname(IObuff, IOSIZE) == OK)
+		var = IObuff;
+	    if (mch_chdir((char *)NameBuff) != 0)
+		EMSG(_(e_prev_dir));
+	}
+#endif
+	homedir = vim_strsave(var);
+    }
+}
+
+#if defined(EXITFREE) || defined(PROTO)
+    void
+free_homedir(void)
+{
+    vim_free(homedir);
+}
+
+# ifdef FEAT_CMDL_COMPL
+    void
+free_users(void)
+{
+    ga_clear_strings(&ga_users);
+}
+# endif
+#endif
+
+/*
+ * Call expand_env() and store the result in an allocated string.
+ * This is not very memory efficient, this expects the result to be freed
+ * again soon.
+ */
+    char_u *
+expand_env_save(char_u *src)
+{
+    return expand_env_save_opt(src, FALSE);
+}
+
+/*
+ * Idem, but when "one" is TRUE handle the string as one file name, only
+ * expand "~" at the start.
+ */
+    char_u *
+expand_env_save_opt(char_u *src, int one)
+{
+    char_u	*p;
+
+    p = alloc(MAXPATHL);
+    if (p != NULL)
+	expand_env_esc(src, p, MAXPATHL, FALSE, one, NULL);
+    return p;
+}
+
+/*
+ * Expand environment variable with path name.
+ * "~/" is also expanded, using $HOME.	For Unix "~user/" is expanded.
+ * Skips over "\ ", "\~" and "\$" (not for Win32 though).
+ * If anything fails no expansion is done and dst equals src.
+ */
+    void
+expand_env(
+    char_u	*src,		/* input string e.g. "$HOME/vim.hlp" */
+    char_u	*dst,		/* where to put the result */
+    int		dstlen)		/* maximum length of the result */
+{
+    expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);
+}
+
+    void
+expand_env_esc(
+    char_u	*srcp,		/* input string e.g. "$HOME/vim.hlp" */
+    char_u	*dst,		/* where to put the result */
+    int		dstlen,		/* maximum length of the result */
+    int		esc,		/* escape spaces in expanded variables */
+    int		one,		/* "srcp" is one file name */
+    char_u	*startstr)	/* start again after this (can be NULL) */
+{
+    char_u	*src;
+    char_u	*tail;
+    int		c;
+    char_u	*var;
+    int		copy_char;
+    int		mustfree;	/* var was allocated, need to free it later */
+    int		at_start = TRUE; /* at start of a name */
+    int		startstr_len = 0;
+
+    if (startstr != NULL)
+	startstr_len = (int)STRLEN(startstr);
+
+    src = skipwhite(srcp);
+    --dstlen;		    /* leave one char space for "\," */
+    while (*src && dstlen > 0)
+    {
+#ifdef FEAT_EVAL
+	/* Skip over `=expr`. */
+	if (src[0] == '`' && src[1] == '=')
+	{
+	    size_t len;
+
+	    var = src;
+	    src += 2;
+	    (void)skip_expr(&src);
+	    if (*src == '`')
+		++src;
+	    len = src - var;
+	    if (len > (size_t)dstlen)
+		len = dstlen;
+	    vim_strncpy(dst, var, len);
+	    dst += len;
+	    dstlen -= (int)len;
+	    continue;
+	}
+#endif
+	copy_char = TRUE;
+	if ((*src == '$'
+#ifdef VMS
+		    && at_start
+#endif
+	   )
+#if defined(MSWIN)
+		|| *src == '%'
+#endif
+		|| (*src == '~' && at_start))
+	{
+	    mustfree = FALSE;
+
+	    /*
+	     * The variable name is copied into dst temporarily, because it may
+	     * be a string in read-only memory and a NUL needs to be appended.
+	     */
+	    if (*src != '~')				/* environment var */
+	    {
+		tail = src + 1;
+		var = dst;
+		c = dstlen - 1;
+
+#ifdef UNIX
+		/* Unix has ${var-name} type environment vars */
+		if (*tail == '{' && !vim_isIDc('{'))
+		{
+		    tail++;	/* ignore '{' */
+		    while (c-- > 0 && *tail && *tail != '}')
+			*var++ = *tail++;
+		}
+		else
+#endif
+		{
+		    while (c-- > 0 && *tail != NUL && ((vim_isIDc(*tail))
+#if defined(MSWIN)
+			    || (*src == '%' && *tail != '%')
+#endif
+			    ))
+		    {
+			*var++ = *tail++;
+		    }
+		}
+
+#if defined(MSWIN) || defined(UNIX)
+# ifdef UNIX
+		if (src[1] == '{' && *tail != '}')
+# else
+		if (*src == '%' && *tail != '%')
+# endif
+		    var = NULL;
+		else
+		{
+# ifdef UNIX
+		    if (src[1] == '{')
+# else
+		    if (*src == '%')
+#endif
+			++tail;
+#endif
+		    *var = NUL;
+		    var = vim_getenv(dst, &mustfree);
+#if defined(MSWIN) || defined(UNIX)
+		}
+#endif
+	    }
+							/* home directory */
+	    else if (  src[1] == NUL
+		    || vim_ispathsep(src[1])
+		    || vim_strchr((char_u *)" ,\t\n", src[1]) != NULL)
+	    {
+		var = homedir;
+		tail = src + 1;
+	    }
+	    else					/* user directory */
+	    {
+#if defined(UNIX) || (defined(VMS) && defined(USER_HOME))
+		/*
+		 * Copy ~user to dst[], so we can put a NUL after it.
+		 */
+		tail = src;
+		var = dst;
+		c = dstlen - 1;
+		while (	   c-- > 0
+			&& *tail
+			&& vim_isfilec(*tail)
+			&& !vim_ispathsep(*tail))
+		    *var++ = *tail++;
+		*var = NUL;
+# ifdef UNIX
+		/*
+		 * If the system supports getpwnam(), use it.
+		 * Otherwise, or if getpwnam() fails, the shell is used to
+		 * expand ~user.  This is slower and may fail if the shell
+		 * does not support ~user (old versions of /bin/sh).
+		 */
+#  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
+		{
+		    /* Note: memory allocated by getpwnam() is never freed.
+		     * Calling endpwent() apparently doesn't help. */
+		    struct passwd *pw = (*dst == NUL)
+					? NULL : getpwnam((char *)dst + 1);
+
+		    var = (pw == NULL) ? NULL : (char_u *)pw->pw_dir;
+		}
+		if (var == NULL)
+#  endif
+		{
+		    expand_T	xpc;
+
+		    ExpandInit(&xpc);
+		    xpc.xp_context = EXPAND_FILES;
+		    var = ExpandOne(&xpc, dst, NULL,
+				WILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);
+		    mustfree = TRUE;
+		}
+
+# else	/* !UNIX, thus VMS */
+		/*
+		 * USER_HOME is a comma-separated list of
+		 * directories to search for the user account in.
+		 */
+		{
+		    char_u	test[MAXPATHL], paths[MAXPATHL];
+		    char_u	*path, *next_path, *ptr;
+		    stat_T	st;
+
+		    STRCPY(paths, USER_HOME);
+		    next_path = paths;
+		    while (*next_path)
+		    {
+			for (path = next_path; *next_path && *next_path != ',';
+				next_path++);
+			if (*next_path)
+			    *next_path++ = NUL;
+			STRCPY(test, path);
+			STRCAT(test, "/");
+			STRCAT(test, dst + 1);
+			if (mch_stat(test, &st) == 0)
+			{
+			    var = alloc(STRLEN(test) + 1);
+			    STRCPY(var, test);
+			    mustfree = TRUE;
+			    break;
+			}
+		    }
+		}
+# endif /* UNIX */
+#else
+		/* cannot expand user's home directory, so don't try */
+		var = NULL;
+		tail = (char_u *)"";	/* for gcc */
+#endif /* UNIX || VMS */
+	    }
+
+#ifdef BACKSLASH_IN_FILENAME
+	    /* If 'shellslash' is set change backslashes to forward slashes.
+	     * Can't use slash_adjust(), p_ssl may be set temporarily. */
+	    if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL)
+	    {
+		char_u	*p = vim_strsave(var);
+
+		if (p != NULL)
+		{
+		    if (mustfree)
+			vim_free(var);
+		    var = p;
+		    mustfree = TRUE;
+		    forward_slash(var);
+		}
+	    }
+#endif
+
+	    /* If "var" contains white space, escape it with a backslash.
+	     * Required for ":e ~/tt" when $HOME includes a space. */
+	    if (esc && var != NULL && vim_strpbrk(var, (char_u *)" \t") != NULL)
+	    {
+		char_u	*p = vim_strsave_escaped(var, (char_u *)" \t");
+
+		if (p != NULL)
+		{
+		    if (mustfree)
+			vim_free(var);
+		    var = p;
+		    mustfree = TRUE;
+		}
+	    }
+
+	    if (var != NULL && *var != NUL
+		    && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen))
+	    {
+		STRCPY(dst, var);
+		dstlen -= (int)STRLEN(var);
+		c = (int)STRLEN(var);
+		/* if var[] ends in a path separator and tail[] starts
+		 * with it, skip a character */
+		if (*var != NUL && after_pathsep(dst, dst + c)
+#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)
+			&& dst[-1] != ':'
+#endif
+			&& vim_ispathsep(*tail))
+		    ++tail;
+		dst += c;
+		src = tail;
+		copy_char = FALSE;
+	    }
+	    if (mustfree)
+		vim_free(var);
+	}
+
+	if (copy_char)	    /* copy at least one char */
+	{
+	    /*
+	     * Recognize the start of a new name, for '~'.
+	     * Don't do this when "one" is TRUE, to avoid expanding "~" in
+	     * ":edit foo ~ foo".
+	     */
+	    at_start = FALSE;
+	    if (src[0] == '\\' && src[1] != NUL)
+	    {
+		*dst++ = *src++;
+		--dstlen;
+	    }
+	    else if ((src[0] == ' ' || src[0] == ',') && !one)
+		at_start = TRUE;
+	    if (dstlen > 0)
+	    {
+		*dst++ = *src++;
+		--dstlen;
+
+		if (startstr != NULL && src - startstr_len >= srcp
+			&& STRNCMP(src - startstr_len, startstr,
+							    startstr_len) == 0)
+		    at_start = TRUE;
+	    }
+	}
+
+    }
+    *dst = NUL;
+}
+
+/*
+ * Vim's version of getenv().
+ * Special handling of $HOME, $VIM and $VIMRUNTIME.
+ * Also does ACP to 'enc' conversion for Win32.
+ * "mustfree" is set to TRUE when returned is allocated, it must be
+ * initialized to FALSE by the caller.
+ */
+    char_u *
+vim_getenv(char_u *name, int *mustfree)
+{
+    char_u	*p;
+    char_u	*pend;
+    int		vimruntime;
+
+#if defined(MSWIN)
+    /* use "C:/" when $HOME is not set */
+    if (STRCMP(name, "HOME") == 0)
+	return homedir;
+#endif
+
+    p = mch_getenv(name);
+    if (p != NULL && *p == NUL)	    /* empty is the same as not set */
+	p = NULL;
+
+    if (p != NULL)
+    {
+#if defined(FEAT_MBYTE) && defined(WIN3264)
+	if (enc_utf8)
+	{
+	    int	    len;
+	    char_u  *pp = NULL;
+
+	    /* Convert from active codepage to UTF-8.  Other conversions are
+	     * not done, because they would fail for non-ASCII characters. */
+	    acp_to_enc(p, (int)STRLEN(p), &pp, &len);
+	    if (pp != NULL)
+	    {
+		p = pp;
+		*mustfree = TRUE;
+	    }
+	}
+#endif
+	return p;
+    }
+
+    vimruntime = (STRCMP(name, "VIMRUNTIME") == 0);
+    if (!vimruntime && STRCMP(name, "VIM") != 0)
+	return NULL;
+
+    /*
+     * When expanding $VIMRUNTIME fails, try using $VIM/vim<version> or $VIM.
+     * Don't do this when default_vimruntime_dir is non-empty.
+     */
+    if (vimruntime
+#ifdef HAVE_PATHDEF
+	    && *default_vimruntime_dir == NUL
+#endif
+       )
+    {
+	p = mch_getenv((char_u *)"VIM");
+	if (p != NULL && *p == NUL)	    /* empty is the same as not set */
+	    p = NULL;
+	if (p != NULL)
+	{
+	    p = vim_version_dir(p);
+	    if (p != NULL)
+		*mustfree = TRUE;
+	    else
+		p = mch_getenv((char_u *)"VIM");
+
+#if defined(FEAT_MBYTE) && defined(WIN3264)
+	    if (enc_utf8)
+	    {
+		int	len;
+		char_u  *pp = NULL;
+
+		/* Convert from active codepage to UTF-8.  Other conversions
+		 * are not done, because they would fail for non-ASCII
+		 * characters. */
+		acp_to_enc(p, (int)STRLEN(p), &pp, &len);
+		if (pp != NULL)
+		{
+		    if (*mustfree)
+			vim_free(p);
+		    p = pp;
+		    *mustfree = TRUE;
+		}
+	    }
+#endif
+	}
+    }
+
+    /*
+     * When expanding $VIM or $VIMRUNTIME fails, try using:
+     * - the directory name from 'helpfile' (unless it contains '$')
+     * - the executable name from argv[0]
+     */
+    if (p == NULL)
+    {
+	if (p_hf != NULL && vim_strchr(p_hf, '$') == NULL)
+	    p = p_hf;
+#ifdef USE_EXE_NAME
+	/*
+	 * Use the name of the executable, obtained from argv[0].
+	 */
+	else
+	    p = exe_name;
+#endif
+	if (p != NULL)
+	{
+	    /* remove the file name */
+	    pend = gettail(p);
+
+	    /* remove "doc/" from 'helpfile', if present */
+	    if (p == p_hf)
+		pend = remove_tail(p, pend, (char_u *)"doc");
+
+#ifdef USE_EXE_NAME
+# ifdef MACOS_X
+	    /* remove "MacOS" from exe_name and add "Resources/vim" */
+	    if (p == exe_name)
+	    {
+		char_u	*pend1;
+		char_u	*pnew;
+
+		pend1 = remove_tail(p, pend, (char_u *)"MacOS");
+		if (pend1 != pend)
+		{
+		    pnew = alloc((unsigned)(pend1 - p) + 15);
+		    if (pnew != NULL)
+		    {
+			STRNCPY(pnew, p, (pend1 - p));
+			STRCPY(pnew + (pend1 - p), "Resources/vim");
+			p = pnew;
+			pend = p + STRLEN(p);
+		    }
+		}
+	    }
+# endif
+	    /* remove "src/" from exe_name, if present */
+	    if (p == exe_name)
+		pend = remove_tail(p, pend, (char_u *)"src");
+#endif
+
+	    /* for $VIM, remove "runtime/" or "vim54/", if present */
+	    if (!vimruntime)
+	    {
+		pend = remove_tail(p, pend, (char_u *)RUNTIME_DIRNAME);
+		pend = remove_tail(p, pend, (char_u *)VIM_VERSION_NODOT);
+	    }
+
+	    /* remove trailing path separator */
+	    if (pend > p && after_pathsep(p, pend))
+		--pend;
+
+#ifdef MACOS_X
+	    if (p == exe_name || p == p_hf)
+#endif
+		/* check that the result is a directory name */
+		p = vim_strnsave(p, (int)(pend - p));
+
+	    if (p != NULL && !mch_isdir(p))
+		VIM_CLEAR(p);
+	    else
+	    {
+#ifdef USE_EXE_NAME
+		/* may add "/vim54" or "/runtime" if it exists */
+		if (vimruntime && (pend = vim_version_dir(p)) != NULL)
+		{
+		    vim_free(p);
+		    p = pend;
+		}
+#endif
+		*mustfree = TRUE;
+	    }
+	}
+    }
+
+#ifdef HAVE_PATHDEF
+    /* When there is a pathdef.c file we can use default_vim_dir and
+     * default_vimruntime_dir */
+    if (p == NULL)
+    {
+	/* Only use default_vimruntime_dir when it is not empty */
+	if (vimruntime && *default_vimruntime_dir != NUL)
+	{
+	    p = default_vimruntime_dir;
+	    *mustfree = FALSE;
+	}
+	else if (*default_vim_dir != NUL)
+	{
+	    if (vimruntime && (p = vim_version_dir(default_vim_dir)) != NULL)
+		*mustfree = TRUE;
+	    else
+	    {
+		p = default_vim_dir;
+		*mustfree = FALSE;
+	    }
+	}
+    }
+#endif
+
+    /*
+     * Set the environment variable, so that the new value can be found fast
+     * next time, and others can also use it (e.g. Perl).
+     */
+    if (p != NULL)
+    {
+	if (vimruntime)
+	{
+	    vim_setenv((char_u *)"VIMRUNTIME", p);
+	    didset_vimruntime = TRUE;
+	}
+	else
+	{
+	    vim_setenv((char_u *)"VIM", p);
+	    didset_vim = TRUE;
+	}
+    }
+    return p;
+}
+
+/*
+ * Check if the directory "vimdir/<version>" or "vimdir/runtime" exists.
+ * Return NULL if not, return its name in allocated memory otherwise.
+ */
+    static char_u *
+vim_version_dir(char_u *vimdir)
+{
+    char_u	*p;
+
+    if (vimdir == NULL || *vimdir == NUL)
+	return NULL;
+    p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, TRUE);
+    if (p != NULL && mch_isdir(p))
+	return p;
+    vim_free(p);
+    p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, TRUE);
+    if (p != NULL && mch_isdir(p))
+	return p;
+    vim_free(p);
+    return NULL;
+}
+
+/*
+ * If the string between "p" and "pend" ends in "name/", return "pend" minus
+ * the length of "name/".  Otherwise return "pend".
+ */
+    static char_u *
+remove_tail(char_u *p, char_u *pend, char_u *name)
+{
+    int		len = (int)STRLEN(name) + 1;
+    char_u	*newend = pend - len;
+
+    if (newend >= p
+	    && fnamencmp(newend, name, len - 1) == 0
+	    && (newend == p || after_pathsep(p, newend)))
+	return newend;
+    return pend;
+}
+
+    void
+vim_unsetenv(char_u *var)
+{
+#ifdef HAVE_UNSETENV
+    unsetenv((char *)var);
+#else
+    vim_setenv(var, (char_u *)"");
+#endif
+}
+
+
+/*
+ * Our portable version of setenv.
+ */
+    void
+vim_setenv(char_u *name, char_u *val)
+{
+#ifdef HAVE_SETENV
+    mch_setenv((char *)name, (char *)val, 1);
+#else
+    char_u	*envbuf;
+
+    /*
+     * Putenv does not copy the string, it has to remain
+     * valid.  The allocated memory will never be freed.
+     */
+    envbuf = alloc((unsigned)(STRLEN(name) + STRLEN(val) + 2));
+    if (envbuf != NULL)
+    {
+	sprintf((char *)envbuf, "%s=%s", name, val);
+	putenv((char *)envbuf);
+    }
+#endif
+#ifdef FEAT_GETTEXT
+    /*
+     * When setting $VIMRUNTIME adjust the directory to find message
+     * translations to $VIMRUNTIME/lang.
+     */
+    if (*val != NUL && STRICMP(name, "VIMRUNTIME") == 0)
+    {
+	char_u	*buf = concat_str(val, (char_u *)"/lang");
+
+	if (buf != NULL)
+	{
+	    bindtextdomain(VIMPACKAGE, (char *)buf);
+	    vim_free(buf);
+	}
+    }
+#endif
+}
+
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+/*
+ * Function given to ExpandGeneric() to obtain an environment variable name.
+ */
+    char_u *
+get_env_name(
+    expand_T	*xp UNUSED,
+    int		idx)
+{
+# if defined(AMIGA)
+    /*
+     * No environ[] on the Amiga.
+     */
+    return NULL;
+# else
+# ifndef __WIN32__
+    /* Borland C++ 5.2 has this in a header file. */
+    extern char		**environ;
+# endif
+# define ENVNAMELEN 100
+    static char_u	name[ENVNAMELEN];
+    char_u		*str;
+    int			n;
+
+    str = (char_u *)environ[idx];
+    if (str == NULL)
+	return NULL;
+
+    for (n = 0; n < ENVNAMELEN - 1; ++n)
+    {
+	if (str[n] == '=' || str[n] == NUL)
+	    break;
+	name[n] = str[n];
+    }
+    name[n] = NUL;
+    return name;
+# endif
+}
+
+/*
+ * Find all user names for user completion.
+ * Done only once and then cached.
+ */
+    static void
+init_users(void)
+{
+    static int	lazy_init_done = FALSE;
+
+    if (lazy_init_done)
+	return;
+
+    lazy_init_done = TRUE;
+    ga_init2(&ga_users, sizeof(char_u *), 20);
+
+# if defined(HAVE_GETPWENT) && defined(HAVE_PWD_H)
+    {
+	char_u*		user;
+	struct passwd*	pw;
+
+	setpwent();
+	while ((pw = getpwent()) != NULL)
+	    /* pw->pw_name shouldn't be NULL but just in case... */
+	    if (pw->pw_name != NULL)
+	    {
+		if (ga_grow(&ga_users, 1) == FAIL)
+		    break;
+		user = vim_strsave((char_u*)pw->pw_name);
+		if (user == NULL)
+		    break;
+		((char_u **)(ga_users.ga_data))[ga_users.ga_len++] = user;
+	    }
+	endpwent();
+    }
+# elif defined(WIN3264)
+    {
+	char_u*		user;
+	DWORD		nusers = 0, ntotal = 0, i;
+	PUSER_INFO_0	uinfo;
+
+	if (NetUserEnum(NULL, 0, 0, (LPBYTE *) &uinfo, MAX_PREFERRED_LENGTH,
+				       &nusers, &ntotal, NULL) == NERR_Success)
+	{
+	    for (i = 0; i < nusers; i++)
+	    {
+		if (ga_grow(&ga_users, 1) == FAIL)
+		    break;
+		user = utf16_to_enc(uinfo[i].usri0_name, NULL);
+		if (user == NULL)
+		    break;
+		((char_u **)(ga_users.ga_data))[ga_users.ga_len++] = user;
+	    }
+
+	    NetApiBufferFree(uinfo);
+	}
+    }
+# endif
+}
+
+/*
+ * Function given to ExpandGeneric() to obtain an user names.
+ */
+    char_u*
+get_users(expand_T *xp UNUSED, int idx)
+{
+    init_users();
+    if (idx < ga_users.ga_len)
+	return ((char_u **)ga_users.ga_data)[idx];
+    return NULL;
+}
+
+/*
+ * Check whether name matches a user name. Return:
+ * 0 if name does not match any user name.
+ * 1 if name partially matches the beginning of a user name.
+ * 2 is name fully matches a user name.
+ */
+    int
+match_user(char_u *name)
+{
+    int i;
+    int n = (int)STRLEN(name);
+    int result = 0;
+
+    init_users();
+    for (i = 0; i < ga_users.ga_len; i++)
+    {
+	if (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)
+	    return 2; /* full match */
+	if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)
+	    result = 1; /* partial match */
+    }
+    return result;
+}
+#endif
+
+/*
+ * Replace home directory by "~" in each space or comma separated file name in
+ * 'src'.
+ * If anything fails (except when out of space) dst equals src.
+ */
+    void
+home_replace(
+    buf_T	*buf,	/* when not NULL, check for help files */
+    char_u	*src,	/* input file name */
+    char_u	*dst,	/* where to put the result */
+    int		dstlen,	/* maximum length of the result */
+    int		one)	/* if TRUE, only replace one file name, include
+			   spaces and commas in the file name. */
+{
+    size_t	dirlen = 0, envlen = 0;
+    size_t	len;
+    char_u	*homedir_env, *homedir_env_orig;
+    char_u	*p;
+
+    if (src == NULL)
+    {
+	*dst = NUL;
+	return;
+    }
+
+    /*
+     * If the file is a help file, remove the path completely.
+     */
+    if (buf != NULL && buf->b_help)
+    {
+	vim_snprintf((char *)dst, dstlen, "%s", gettail(src));
+	return;
+    }
+
+    /*
+     * We check both the value of the $HOME environment variable and the
+     * "real" home directory.
+     */
+    if (homedir != NULL)
+	dirlen = STRLEN(homedir);
+
+#ifdef VMS
+    homedir_env_orig = homedir_env = mch_getenv((char_u *)"SYS$LOGIN");
+#else
+    homedir_env_orig = homedir_env = mch_getenv((char_u *)"HOME");
+#endif
+#ifdef WIN3264
+    if (homedir_env == NULL)
+	homedir_env_orig = homedir_env = mch_getenv((char_u *)"USERPROFILE");
+#endif
+    /* Empty is the same as not set. */
+    if (homedir_env != NULL && *homedir_env == NUL)
+	homedir_env = NULL;
+
+#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL)
+    if (homedir_env != NULL && vim_strchr(homedir_env, '~') != NULL)
+    {
+	int	usedlen = 0;
+	int	flen;
+	char_u	*fbuf = NULL;
+
+	flen = (int)STRLEN(homedir_env);
+	(void)modify_fname((char_u *)":p", FALSE, &usedlen,
+						  &homedir_env, &fbuf, &flen);
+	flen = (int)STRLEN(homedir_env);
+	if (flen > 0 && vim_ispathsep(homedir_env[flen - 1]))
+	    /* Remove the trailing / that is added to a directory. */
+	    homedir_env[flen - 1] = NUL;
+    }
+#endif
+
+    if (homedir_env != NULL)
+	envlen = STRLEN(homedir_env);
+
+    if (!one)
+	src = skipwhite(src);
+    while (*src && dstlen > 0)
+    {
+	/*
+	 * Here we are at the beginning of a file name.
+	 * First, check to see if the beginning of the file name matches
+	 * $HOME or the "real" home directory. Check that there is a '/'
+	 * after the match (so that if e.g. the file is "/home/pieter/bla",
+	 * and the home directory is "/home/piet", the file does not end up
+	 * as "~er/bla" (which would seem to indicate the file "bla" in user
+	 * er's home directory)).
+	 */
+	p = homedir;
+	len = dirlen;
+	for (;;)
+	{
+	    if (   len
+		&& fnamencmp(src, p, len) == 0
+		&& (vim_ispathsep(src[len])
+		    || (!one && (src[len] == ',' || src[len] == ' '))
+		    || src[len] == NUL))
+	    {
+		src += len;
+		if (--dstlen > 0)
+		    *dst++ = '~';
+
+		/*
+		 * If it's just the home directory, add  "/".
+		 */
+		if (!vim_ispathsep(src[0]) && --dstlen > 0)
+		    *dst++ = '/';
+		break;
+	    }
+	    if (p == homedir_env)
+		break;
+	    p = homedir_env;
+	    len = envlen;
+	}
+
+	/* if (!one) skip to separator: space or comma */
+	while (*src && (one || (*src != ',' && *src != ' ')) && --dstlen > 0)
+	    *dst++ = *src++;
+	/* skip separator */
+	while ((*src == ' ' || *src == ',') && --dstlen > 0)
+	    *dst++ = *src++;
+    }
+    /* if (dstlen == 0) out of space, what to do??? */
+
+    *dst = NUL;
+
+    if (homedir_env != homedir_env_orig)
+	vim_free(homedir_env);
+}
+
+/*
+ * Like home_replace, store the replaced string in allocated memory.
+ * When something fails, NULL is returned.
+ */
+    char_u  *
+home_replace_save(
+    buf_T	*buf,	/* when not NULL, check for help files */
+    char_u	*src)	/* input file name */
+{
+    char_u	*dst;
+    unsigned	len;
+
+    len = 3;			/* space for "~/" and trailing NUL */
+    if (src != NULL)		/* just in case */
+	len += (unsigned)STRLEN(src);
+    dst = alloc(len);
+    if (dst != NULL)
+	home_replace(buf, src, dst, len, TRUE);
+    return dst;
+}
+
+/*
+ * Compare two file names and return:
+ * FPC_SAME   if they both exist and are the same file.
+ * FPC_SAMEX  if they both don't exist and have the same file name.
+ * FPC_DIFF   if they both exist and are different files.
+ * FPC_NOTX   if they both don't exist.
+ * FPC_DIFFX  if one of them doesn't exist.
+ * For the first name environment variables are expanded
+ */
+    int
+fullpathcmp(
+    char_u *s1,
+    char_u *s2,
+    int	    checkname)		/* when both don't exist, check file names */
+{
+#ifdef UNIX
+    char_u	    exp1[MAXPATHL];
+    char_u	    full1[MAXPATHL];
+    char_u	    full2[MAXPATHL];
+    stat_T	    st1, st2;
+    int		    r1, r2;
+
+    expand_env(s1, exp1, MAXPATHL);
+    r1 = mch_stat((char *)exp1, &st1);
+    r2 = mch_stat((char *)s2, &st2);
+    if (r1 != 0 && r2 != 0)
+    {
+	/* if mch_stat() doesn't work, may compare the names */
+	if (checkname)
+	{
+	    if (fnamecmp(exp1, s2) == 0)
+		return FPC_SAMEX;
+	    r1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);
+	    r2 = vim_FullName(s2, full2, MAXPATHL, FALSE);
+	    if (r1 == OK && r2 == OK && fnamecmp(full1, full2) == 0)
+		return FPC_SAMEX;
+	}
+	return FPC_NOTX;
+    }
+    if (r1 != 0 || r2 != 0)
+	return FPC_DIFFX;
+    if (st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)
+	return FPC_SAME;
+    return FPC_DIFF;
+#else
+    char_u  *exp1;		/* expanded s1 */
+    char_u  *full1;		/* full path of s1 */
+    char_u  *full2;		/* full path of s2 */
+    int	    retval = FPC_DIFF;
+    int	    r1, r2;
+
+    /* allocate one buffer to store three paths (alloc()/free() is slow!) */
+    if ((exp1 = alloc(MAXPATHL * 3)) != NULL)
+    {
+	full1 = exp1 + MAXPATHL;
+	full2 = full1 + MAXPATHL;
+
+	expand_env(s1, exp1, MAXPATHL);
+	r1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);
+	r2 = vim_FullName(s2, full2, MAXPATHL, FALSE);
+
+	/* If vim_FullName() fails, the file probably doesn't exist. */
+	if (r1 != OK && r2 != OK)
+	{
+	    if (checkname && fnamecmp(exp1, s2) == 0)
+		retval = FPC_SAMEX;
+	    else
+		retval = FPC_NOTX;
+	}
+	else if (r1 != OK || r2 != OK)
+	    retval = FPC_DIFFX;
+	else if (fnamecmp(full1, full2))
+	    retval = FPC_DIFF;
+	else
+	    retval = FPC_SAME;
+	vim_free(exp1);
+    }
+    return retval;
+#endif
+}
+
+/*
+ * Get the tail of a path: the file name.
+ * When the path ends in a path separator the tail is the NUL after it.
+ * Fail safe: never returns NULL.
+ */
+    char_u *
+gettail(char_u *fname)
+{
+    char_u  *p1, *p2;
+
+    if (fname == NULL)
+	return (char_u *)"";
+    for (p1 = p2 = get_past_head(fname); *p2; )	/* find last part of path */
+    {
+	if (vim_ispathsep_nocolon(*p2))
+	    p1 = p2 + 1;
+	MB_PTR_ADV(p2);
+    }
+    return p1;
+}
+
+#if defined(FEAT_SEARCHPATH)
+static char_u *gettail_dir(char_u *fname);
+
+/*
+ * Return the end of the directory name, on the first path
+ * separator:
+ * "/path/file", "/path/dir/", "/path//dir", "/file"
+ *	 ^	       ^	     ^	      ^
+ */
+    static char_u *
+gettail_dir(char_u *fname)
+{
+    char_u	*dir_end = fname;
+    char_u	*next_dir_end = fname;
+    int		look_for_sep = TRUE;
+    char_u	*p;
+
+    for (p = fname; *p != NUL; )
+    {
+	if (vim_ispathsep(*p))
+	{
+	    if (look_for_sep)
+	    {
+		next_dir_end = p;
+		look_for_sep = FALSE;
+	    }
+	}
+	else
+	{
+	    if (!look_for_sep)
+		dir_end = next_dir_end;
+	    look_for_sep = TRUE;
+	}
+	MB_PTR_ADV(p);
+    }
+    return dir_end;
+}
+#endif
+
+/*
+ * Get pointer to tail of "fname", including path separators.  Putting a NUL
+ * here leaves the directory name.  Takes care of "c:/" and "//".
+ * Always returns a valid pointer.
+ */
+    char_u *
+gettail_sep(char_u *fname)
+{
+    char_u	*p;
+    char_u	*t;
+
+    p = get_past_head(fname);	/* don't remove the '/' from "c:/file" */
+    t = gettail(fname);
+    while (t > p && after_pathsep(fname, t))
+	--t;
+#ifdef VMS
+    /* path separator is part of the path */
+    ++t;
+#endif
+    return t;
+}
+
+/*
+ * get the next path component (just after the next path separator).
+ */
+    char_u *
+getnextcomp(char_u *fname)
+{
+    while (*fname && !vim_ispathsep(*fname))
+	MB_PTR_ADV(fname);
+    if (*fname)
+	++fname;
+    return fname;
+}
+
+/*
+ * Get a pointer to one character past the head of a path name.
+ * Unix: after "/"; DOS: after "c:\"; Amiga: after "disk:/"; Mac: no head.
+ * If there is no head, path is returned.
+ */
+    char_u *
+get_past_head(char_u *path)
+{
+    char_u  *retval;
+
+#if defined(MSWIN)
+    /* may skip "c:" */
+    if (isalpha(path[0]) && path[1] == ':')
+	retval = path + 2;
+    else
+	retval = path;
+#else
+# if defined(AMIGA)
+    /* may skip "label:" */
+    retval = vim_strchr(path, ':');
+    if (retval == NULL)
+	retval = path;
+# else	/* Unix */
+    retval = path;
+# endif
+#endif
+
+    while (vim_ispathsep(*retval))
+	++retval;
+
+    return retval;
+}
+
+/*
+ * Return TRUE if 'c' is a path separator.
+ * Note that for MS-Windows this includes the colon.
+ */
+    int
+vim_ispathsep(int c)
+{
+#ifdef UNIX
+    return (c == '/');	    /* UNIX has ':' inside file names */
+#else
+# ifdef BACKSLASH_IN_FILENAME
+    return (c == ':' || c == '/' || c == '\\');
+# else
+#  ifdef VMS
+    /* server"user passwd"::device:[full.path.name]fname.extension;version" */
+    return (c == ':' || c == '[' || c == ']' || c == '/'
+	    || c == '<' || c == '>' || c == '"' );
+#  else
+    return (c == ':' || c == '/');
+#  endif /* VMS */
+# endif
+#endif
+}
+
+/*
+ * Like vim_ispathsep(c), but exclude the colon for MS-Windows.
+ */
+    int
+vim_ispathsep_nocolon(int c)
+{
+    return vim_ispathsep(c)
+#ifdef BACKSLASH_IN_FILENAME
+	&& c != ':'
+#endif
+	;
+}
+
+#if defined(FEAT_SEARCHPATH) || defined(PROTO)
+/*
+ * return TRUE if 'c' is a path list separator.
+ */
+    int
+vim_ispathlistsep(int c)
+{
+#ifdef UNIX
+    return (c == ':');
+#else
+    return (c == ';');	/* might not be right for every system... */
+#endif
+}
+#endif
+
+/*
+ * Shorten the path of a file from "~/foo/../.bar/fname" to "~/f/../.b/fname"
+ * It's done in-place.
+ */
+    void
+shorten_dir(char_u *str)
+{
+    char_u	*tail, *s, *d;
+    int		skip = FALSE;
+
+    tail = gettail(str);
+    d = str;
+    for (s = str; ; ++s)
+    {
+	if (s >= tail)		    /* copy the whole tail */
+	{
+	    *d++ = *s;
+	    if (*s == NUL)
+		break;
+	}
+	else if (vim_ispathsep(*s))	    /* copy '/' and next char */
+	{
+	    *d++ = *s;
+	    skip = FALSE;
+	}
+	else if (!skip)
+	{
+	    *d++ = *s;		    /* copy next char */
+	    if (*s != '~' && *s != '.') /* and leading "~" and "." */
+		skip = TRUE;
+# ifdef FEAT_MBYTE
+	    if (has_mbyte)
+	    {
+		int l = mb_ptr2len(s);
+
+		while (--l > 0)
+		    *d++ = *++s;
+	    }
+# endif
+	}
+    }
+}
+
+/*
+ * Return TRUE if the directory of "fname" exists, FALSE otherwise.
+ * Also returns TRUE if there is no directory name.
+ * "fname" must be writable!.
+ */
+    int
+dir_of_file_exists(char_u *fname)
+{
+    char_u	*p;
+    int		c;
+    int		retval;
+
+    p = gettail_sep(fname);
+    if (p == fname)
+	return TRUE;
+    c = *p;
+    *p = NUL;
+    retval = mch_isdir(fname);
+    *p = c;
+    return retval;
+}
+
+/*
+ * Versions of fnamecmp() and fnamencmp() that handle '/' and '\' equally
+ * and deal with 'fileignorecase'.
+ */
+    int
+vim_fnamecmp(char_u *x, char_u *y)
+{
+#ifdef BACKSLASH_IN_FILENAME
+    return vim_fnamencmp(x, y, MAXPATHL);
+#else
+    if (p_fic)
+	return MB_STRICMP(x, y);
+    return STRCMP(x, y);
+#endif
+}
+
+    int
+vim_fnamencmp(char_u *x, char_u *y, size_t len)
+{
+#ifdef BACKSLASH_IN_FILENAME
+    char_u	*px = x;
+    char_u	*py = y;
+    int		cx = NUL;
+    int		cy = NUL;
+
+    while (len > 0)
+    {
+	cx = PTR2CHAR(px);
+	cy = PTR2CHAR(py);
+	if (cx == NUL || cy == NUL
+	    || ((p_fic ? MB_TOLOWER(cx) != MB_TOLOWER(cy) : cx != cy)
+		&& !(cx == '/' && cy == '\\')
+		&& !(cx == '\\' && cy == '/')))
+	    break;
+	len -= MB_PTR2LEN(px);
+	px += MB_PTR2LEN(px);
+	py += MB_PTR2LEN(py);
+    }
+    if (len == 0)
+	return 0;
+    return (cx - cy);
+#else
+    if (p_fic)
+	return MB_STRNICMP(x, y, len);
+    return STRNCMP(x, y, len);
+#endif
+}
+
+/*
+ * Concatenate file names fname1 and fname2 into allocated memory.
+ * Only add a '/' or '\\' when 'sep' is TRUE and it is necessary.
+ */
+    char_u  *
+concat_fnames(char_u *fname1, char_u *fname2, int sep)
+{
+    char_u  *dest;
+
+    dest = alloc((unsigned)(STRLEN(fname1) + STRLEN(fname2) + 3));
+    if (dest != NULL)
+    {
+	STRCPY(dest, fname1);
+	if (sep)
+	    add_pathsep(dest);
+	STRCAT(dest, fname2);
+    }
+    return dest;
+}
+
+/*
+ * Concatenate two strings and return the result in allocated memory.
+ * Returns NULL when out of memory.
+ */
+    char_u  *
+concat_str(char_u *str1, char_u *str2)
+{
+    char_u  *dest;
+    size_t  l = STRLEN(str1);
+
+    dest = alloc((unsigned)(l + STRLEN(str2) + 1L));
+    if (dest != NULL)
+    {
+	STRCPY(dest, str1);
+	STRCPY(dest + l, str2);
+    }
+    return dest;
+}
+
+/*
+ * Add a path separator to a file name, unless it already ends in a path
+ * separator.
+ */
+    void
+add_pathsep(char_u *p)
+{
+    if (*p != NUL && !after_pathsep(p, p + STRLEN(p)))
+	STRCAT(p, PATHSEPSTR);
+}
+
+/*
+ * FullName_save - Make an allocated copy of a full file name.
+ * Returns NULL when out of memory.
+ */
+    char_u  *
+FullName_save(
+    char_u	*fname,
+    int		force)		/* force expansion, even when it already looks
+				 * like a full path name */
+{
+    char_u	*buf;
+    char_u	*new_fname = NULL;
+
+    if (fname == NULL)
+	return NULL;
+
+    buf = alloc((unsigned)MAXPATHL);
+    if (buf != NULL)
+    {
+	if (vim_FullName(fname, buf, MAXPATHL, force) != FAIL)
+	    new_fname = vim_strsave(buf);
+	else
+	    new_fname = vim_strsave(fname);
+	vim_free(buf);
+    }
+    return new_fname;
+}
+
+#if defined(FEAT_CINDENT) || defined(FEAT_SYN_HL)
+
+static char_u	*skip_string(char_u *p);
+static pos_T *ind_find_start_comment(void);
+static pos_T *ind_find_start_CORS(linenr_T *is_raw);
+static pos_T *find_start_rawstring(int ind_maxcomment);
+
+/*
+ * Find the start of a comment, not knowing if we are in a comment right now.
+ * Search starts at w_cursor.lnum and goes backwards.
+ * Return NULL when not inside a comment.
+ */
+    static pos_T *
+ind_find_start_comment(void)	    /* XXX */
+{
+    return find_start_comment(curbuf->b_ind_maxcomment);
+}
+
+    pos_T *
+find_start_comment(int ind_maxcomment)	/* XXX */
+{
+    pos_T	*pos;
+    char_u	*line;
+    char_u	*p;
+    int		cur_maxcomment = ind_maxcomment;
+
+    for (;;)
+    {
+	pos = findmatchlimit(NULL, '*', FM_BACKWARD, cur_maxcomment);
+	if (pos == NULL)
+	    break;
+
+	/*
+	 * Check if the comment start we found is inside a string.
+	 * If it is then restrict the search to below this line and try again.
+	 */
+	line = ml_get(pos->lnum);
+	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
+	    p = skip_string(p);
+	if ((colnr_T)(p - line) <= pos->col)
+	    break;
+	cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;
+	if (cur_maxcomment <= 0)
+	{
+	    pos = NULL;
+	    break;
+	}
+    }
+    return pos;
+}
+
+/*
+ * Find the start of a comment or raw string, not knowing if we are in a
+ * comment or raw string right now.
+ * Search starts at w_cursor.lnum and goes backwards.
+ * If is_raw is given and returns start of raw_string, sets it to true.
+ * Return NULL when not inside a comment or raw string.
+ * "CORS" -> Comment Or Raw String
+ */
+    static pos_T *
+ind_find_start_CORS(linenr_T *is_raw)	    /* XXX */
+{
+    static pos_T comment_pos_copy;
+    pos_T	*comment_pos;
+    pos_T	*rs_pos;
+
+    comment_pos = find_start_comment(curbuf->b_ind_maxcomment);
+    if (comment_pos != NULL)
+    {
+	/* Need to make a copy of the static pos in findmatchlimit(),
+	 * calling find_start_rawstring() may change it. */
+	comment_pos_copy = *comment_pos;
+	comment_pos = &comment_pos_copy;
+    }
+    rs_pos = find_start_rawstring(curbuf->b_ind_maxcomment);
+
+    /* If comment_pos is before rs_pos the raw string is inside the comment.
+     * If rs_pos is before comment_pos the comment is inside the raw string. */
+    if (comment_pos == NULL || (rs_pos != NULL
+					     && LT_POS(*rs_pos, *comment_pos)))
+    {
+	if (is_raw != NULL && rs_pos != NULL)
+	    *is_raw = rs_pos->lnum;
+	return rs_pos;
+    }
+    return comment_pos;
+}
+
+/*
+ * Find the start of a raw string, not knowing if we are in one right now.
+ * Search starts at w_cursor.lnum and goes backwards.
+ * Return NULL when not inside a raw string.
+ */
+    static pos_T *
+find_start_rawstring(int ind_maxcomment)	/* XXX */
+{
+    pos_T	*pos;
+    char_u	*line;
+    char_u	*p;
+    int		cur_maxcomment = ind_maxcomment;
+
+    for (;;)
+    {
+	pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);
+	if (pos == NULL)
+	    break;
+
+	/*
+	 * Check if the raw string start we found is inside a string.
+	 * If it is then restrict the search to below this line and try again.
+	 */
+	line = ml_get(pos->lnum);
+	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
+	    p = skip_string(p);
+	if ((colnr_T)(p - line) <= pos->col)
+	    break;
+	cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;
+	if (cur_maxcomment <= 0)
+	{
+	    pos = NULL;
+	    break;
+	}
+    }
+    return pos;
+}
+
+/*
+ * Skip to the end of a "string" and a 'c' character.
+ * If there is no string or character, return argument unmodified.
+ */
+    static char_u *
+skip_string(char_u *p)
+{
+    int	    i;
+
+    /*
+     * We loop, because strings may be concatenated: "date""time".
+     */
+    for ( ; ; ++p)
+    {
+	if (p[0] == '\'')		    /* 'c' or '\n' or '\000' */
+	{
+	    if (!p[1])			    /* ' at end of line */
+		break;
+	    i = 2;
+	    if (p[1] == '\\')		    /* '\n' or '\000' */
+	    {
+		++i;
+		while (vim_isdigit(p[i - 1]))   /* '\000' */
+		    ++i;
+	    }
+	    if (p[i] == '\'')		    /* check for trailing ' */
+	    {
+		p += i;
+		continue;
+	    }
+	}
+	else if (p[0] == '"')		    /* start of string */
+	{
+	    for (++p; p[0]; ++p)
+	    {
+		if (p[0] == '\\' && p[1] != NUL)
+		    ++p;
+		else if (p[0] == '"')	    /* end of string */
+		    break;
+	    }
+	    if (p[0] == '"')
+		continue; /* continue for another string */
+	}
+	else if (p[0] == 'R' && p[1] == '"')
+	{
+	    /* Raw string: R"[delim](...)[delim]" */
+	    char_u *delim = p + 2;
+	    char_u *paren = vim_strchr(delim, '(');
+
+	    if (paren != NULL)
+	    {
+		size_t delim_len = paren - delim;
+
+		for (p += 3; *p; ++p)
+		    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0
+			    && p[delim_len + 1] == '"')
+		    {
+			p += delim_len + 1;
+			break;
+		    }
+		if (p[0] == '"')
+		    continue; /* continue for another string */
+	    }
+	}
+	break;				    /* no string found */
+    }
+    if (!*p)
+	--p;				    /* backup from NUL */
+    return p;
+}
+#endif /* FEAT_CINDENT || FEAT_SYN_HL */
+
+#if defined(FEAT_CINDENT) || defined(PROTO)
+
+/*
+ * Do C or expression indenting on the current line.
+ */
+    void
+do_c_expr_indent(void)
+{
+# ifdef FEAT_EVAL
+    if (*curbuf->b_p_inde != NUL)
+	fixthisline(get_expr_indent);
+    else
+# endif
+	fixthisline(get_c_indent);
+}
+
+/* Find result cache for cpp_baseclass */
+typedef struct {
+    int	    found;
+    lpos_T  lpos;
+} cpp_baseclass_cache_T;
+
+/*
+ * Functions for C-indenting.
+ * Most of this originally comes from Eric Fischer.
+ */
+/*
+ * Below "XXX" means that this function may unlock the current line.
+ */
+
+static char_u	*cin_skipcomment(char_u *);
+static int	cin_nocode(char_u *);
+static pos_T	*find_line_comment(void);
+static int	cin_has_js_key(char_u *text);
+static int	cin_islabel_skip(char_u **);
+static int	cin_isdefault(char_u *);
+static char_u	*after_label(char_u *l);
+static int	get_indent_nolabel(linenr_T lnum);
+static int	skip_label(linenr_T, char_u **pp);
+static int	cin_first_id_amount(void);
+static int	cin_get_equal_amount(linenr_T lnum);
+static int	cin_ispreproc(char_u *);
+static int	cin_iscomment(char_u *);
+static int	cin_islinecomment(char_u *);
+static int	cin_isterminated(char_u *, int, int);
+static int	cin_isinit(void);
+static int	cin_isfuncdecl(char_u **, linenr_T, linenr_T);
+static int	cin_isif(char_u *);
+static int	cin_iselse(char_u *);
+static int	cin_isdo(char_u *);
+static int	cin_iswhileofdo(char_u *, linenr_T);
+static int	cin_is_if_for_while_before_offset(char_u *line, int *poffset);
+static int	cin_iswhileofdo_end(int terminated);
+static int	cin_isbreak(char_u *);
+static int	cin_is_cpp_baseclass(cpp_baseclass_cache_T *cached);
+static int	get_baseclass_amount(int col);
+static int	cin_ends_in(char_u *, char_u *, char_u *);
+static int	cin_starts_with(char_u *s, char *word);
+static int	cin_skip2pos(pos_T *trypos);
+static pos_T	*find_start_brace(void);
+static pos_T	*find_match_paren(int);
+static pos_T	*find_match_char(int c, int ind_maxparen);
+static int	corr_ind_maxparen(pos_T *startpos);
+static int	find_last_paren(char_u *l, int start, int end);
+static int	find_match(int lookfor, linenr_T ourscope);
+static int	cin_is_cpp_namespace(char_u *);
+
+/*
+ * Skip over white space and C comments within the line.
+ * Also skip over Perl/shell comments if desired.
+ */
+    static char_u *
+cin_skipcomment(char_u *s)
+{
+    while (*s)
+    {
+	char_u *prev_s = s;
+
+	s = skipwhite(s);
+
+	/* Perl/shell # comment comment continues until eol.  Require a space
+	 * before # to avoid recognizing $#array. */
+	if (curbuf->b_ind_hash_comment != 0 && s != prev_s && *s == '#')
+	{
+	    s += STRLEN(s);
+	    break;
+	}
+	if (*s != '/')
+	    break;
+	++s;
+	if (*s == '/')		/* slash-slash comment continues till eol */
+	{
+	    s += STRLEN(s);
+	    break;
+	}
+	if (*s != '*')
+	    break;
+	for (++s; *s; ++s)	/* skip slash-star comment */
+	    if (s[0] == '*' && s[1] == '/')
+	    {
+		s += 2;
+		break;
+	    }
+    }
+    return s;
+}
+
+/*
+ * Return TRUE if there is no code at *s.  White space and comments are
+ * not considered code.
+ */
+    static int
+cin_nocode(char_u *s)
+{
+    return *cin_skipcomment(s) == NUL;
+}
+
+/*
+ * Check previous lines for a "//" line comment, skipping over blank lines.
+ */
+    static pos_T *
+find_line_comment(void) /* XXX */
+{
+    static pos_T pos;
+    char_u	 *line;
+    char_u	 *p;
+
+    pos = curwin->w_cursor;
+    while (--pos.lnum > 0)
+    {
+	line = ml_get(pos.lnum);
+	p = skipwhite(line);
+	if (cin_islinecomment(p))
+	{
+	    pos.col = (int)(p - line);
+	    return &pos;
+	}
+	if (*p != NUL)
+	    break;
+    }
+    return NULL;
+}
+
+/*
+ * Return TRUE if "text" starts with "key:".
+ */
+    static int
+cin_has_js_key(char_u *text)
+{
+    char_u *s = skipwhite(text);
+    int	    quote = -1;
+
+    if (*s == '\'' || *s == '"')
+    {
+	/* can be 'key': or "key": */
+	quote = *s;
+	++s;
+    }
+    if (!vim_isIDc(*s))	    /* need at least one ID character */
+	return FALSE;
+
+    while (vim_isIDc(*s))
+	++s;
+    if (*s == quote)
+	++s;
+
+    s = cin_skipcomment(s);
+
+    /* "::" is not a label, it's C++ */
+    return (*s == ':' && s[1] != ':');
+}
+
+/*
+ * Check if string matches "label:"; move to character after ':' if true.
+ * "*s" must point to the start of the label, if there is one.
+ */
+    static int
+cin_islabel_skip(char_u **s)
+{
+    if (!vim_isIDc(**s))	    /* need at least one ID character */
+	return FALSE;
+
+    while (vim_isIDc(**s))
+	(*s)++;
+
+    *s = cin_skipcomment(*s);
+
+    /* "::" is not a label, it's C++ */
+    return (**s == ':' && *++*s != ':');
+}
+
+/*
+ * Recognize a label: "label:".
+ * Note: curwin->w_cursor must be where we are looking for the label.
+ */
+    int
+cin_islabel(void)		/* XXX */
+{
+    char_u	*s;
+
+    s = cin_skipcomment(ml_get_curline());
+
+    /*
+     * Exclude "default" from labels, since it should be indented
+     * like a switch label.  Same for C++ scope declarations.
+     */
+    if (cin_isdefault(s))
+	return FALSE;
+    if (cin_isscopedecl(s))
+	return FALSE;
+
+    if (cin_islabel_skip(&s))
+    {
+	/*
+	 * Only accept a label if the previous line is terminated or is a case
+	 * label.
+	 */
+	pos_T	cursor_save;
+	pos_T	*trypos;
+	char_u	*line;
+
+	cursor_save = curwin->w_cursor;
+	while (curwin->w_cursor.lnum > 1)
+	{
+	    --curwin->w_cursor.lnum;
+
+	    /*
+	     * If we're in a comment or raw string now, skip to the start of
+	     * it.
+	     */
+	    curwin->w_cursor.col = 0;
+	    if ((trypos = ind_find_start_CORS(NULL)) != NULL) /* XXX */
+		curwin->w_cursor = *trypos;
+
+	    line = ml_get_curline();
+	    if (cin_ispreproc(line))	/* ignore #defines, #if, etc. */
+		continue;
+	    if (*(line = cin_skipcomment(line)) == NUL)
+		continue;
+
+	    curwin->w_cursor = cursor_save;
+	    if (cin_isterminated(line, TRUE, FALSE)
+		    || cin_isscopedecl(line)
+		    || cin_iscase(line, TRUE)
+		    || (cin_islabel_skip(&line) && cin_nocode(line)))
+		return TRUE;
+	    return FALSE;
+	}
+	curwin->w_cursor = cursor_save;
+	return TRUE;		/* label at start of file??? */
+    }
+    return FALSE;
+}
+
+/*
+ * Recognize structure initialization and enumerations:
+ * "[typedef] [static|public|protected|private] enum"
+ * "[typedef] [static|public|protected|private] = {"
+ */
+    static int
+cin_isinit(void)
+{
+    char_u	*s;
+    static char *skip[] = {"static", "public", "protected", "private"};
+
+    s = cin_skipcomment(ml_get_curline());
+
+    if (cin_starts_with(s, "typedef"))
+	s = cin_skipcomment(s + 7);
+
+    for (;;)
+    {
+	int i, l;
+
+	for (i = 0; i < (int)(sizeof(skip) / sizeof(char *)); ++i)
+	{
+	    l = (int)strlen(skip[i]);
+	    if (cin_starts_with(s, skip[i]))
+	    {
+		s = cin_skipcomment(s + l);
+		l = 0;
+		break;
+	    }
+	}
+	if (l != 0)
+	    break;
+    }
+
+    if (cin_starts_with(s, "enum"))
+	return TRUE;
+
+    if (cin_ends_in(s, (char_u *)"=", (char_u *)"{"))
+	return TRUE;
+
+    return FALSE;
+}
+
+/*
+ * Recognize a switch label: "case .*:" or "default:".
+ */
+     int
+cin_iscase(
+    char_u *s,
+    int strict) /* Allow relaxed check of case statement for JS */
+{
+    s = cin_skipcomment(s);
+    if (cin_starts_with(s, "case"))
+    {
+	for (s += 4; *s; ++s)
+	{
+	    s = cin_skipcomment(s);
+	    if (*s == ':')
+	    {
+		if (s[1] == ':')	/* skip over "::" for C++ */
+		    ++s;
+		else
+		    return TRUE;
+	    }
+	    if (*s == '\'' && s[1] && s[2] == '\'')
+		s += 2;			/* skip over ':' */
+	    else if (*s == '/' && (s[1] == '*' || s[1] == '/'))
+		return FALSE;		/* stop at comment */
+	    else if (*s == '"')
+	    {
+		/* JS etc. */
+		if (strict)
+		    return FALSE;		/* stop at string */
+		else
+		    return TRUE;
+	    }
+	}
+	return FALSE;
+    }
+
+    if (cin_isdefault(s))
+	return TRUE;
+    return FALSE;
+}
+
+/*
+ * Recognize a "default" switch label.
+ */
+    static int
+cin_isdefault(char_u *s)
+{
+    return (STRNCMP(s, "default", 7) == 0
+	    && *(s = cin_skipcomment(s + 7)) == ':'
+	    && s[1] != ':');
+}
+
+/*
+ * Recognize a "public/private/protected" scope declaration label.
+ */
+    int
+cin_isscopedecl(char_u *s)
+{
+    int		i;
+
+    s = cin_skipcomment(s);
+    if (STRNCMP(s, "public", 6) == 0)
+	i = 6;
+    else if (STRNCMP(s, "protected", 9) == 0)
+	i = 9;
+    else if (STRNCMP(s, "private", 7) == 0)
+	i = 7;
+    else
+	return FALSE;
+    return (*(s = cin_skipcomment(s + i)) == ':' && s[1] != ':');
+}
+
+/* Maximum number of lines to search back for a "namespace" line. */
+#define FIND_NAMESPACE_LIM 20
+
+/*
+ * Recognize a "namespace" scope declaration.
+ */
+    static int
+cin_is_cpp_namespace(char_u *s)
+{
+    char_u	*p;
+    int		has_name = FALSE;
+    int		has_name_start = FALSE;
+
+    s = cin_skipcomment(s);
+    if (STRNCMP(s, "namespace", 9) == 0 && (s[9] == NUL || !vim_iswordc(s[9])))
+    {
+	p = cin_skipcomment(skipwhite(s + 9));
+	while (*p != NUL)
+	{
+	    if (VIM_ISWHITE(*p))
+	    {
+		has_name = TRUE; /* found end of a name */
+		p = cin_skipcomment(skipwhite(p));
+	    }
+	    else if (*p == '{')
+	    {
+		break;
+	    }
+	    else if (vim_iswordc(*p))
+	    {
+		has_name_start = TRUE;
+		if (has_name)
+		    return FALSE; /* word character after skipping past name */
+		++p;
+	    }
+	    else if (p[0] == ':' && p[1] == ':' && vim_iswordc(p[2]))
+	    {
+		if (!has_name_start || has_name)
+		    return FALSE;
+		/* C++ 17 nested namespace */
+		p += 3;
+	    }
+	    else
+	    {
+		return FALSE;
+	    }
+	}
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Recognize a `extern "C"` or `extern "C++"` linkage specifications.
+ */
+    static int
+cin_is_cpp_extern_c(char_u *s)
+{
+    char_u	*p;
+    int		has_string_literal = FALSE;
+
+    s = cin_skipcomment(s);
+    if (STRNCMP(s, "extern", 6) == 0 && (s[6] == NUL || !vim_iswordc(s[6])))
+    {
+	p = cin_skipcomment(skipwhite(s + 6));
+	while (*p != NUL)
+	{
+	    if (VIM_ISWHITE(*p))
+	    {
+		p = cin_skipcomment(skipwhite(p));
+	    }
+	    else if (*p == '{')
+	    {
+		break;
+	    }
+	    else if (p[0] == '"' && p[1] == 'C' && p[2] == '"')
+	    {
+		if (has_string_literal)
+		    return FALSE;
+		has_string_literal = TRUE;
+		p += 3;
+	    }
+	    else if (p[0] == '"' && p[1] == 'C' && p[2] == '+' && p[3] == '+'
+		    && p[4] == '"')
+	    {
+		if (has_string_literal)
+		    return FALSE;
+		has_string_literal = TRUE;
+		p += 5;
+	    }
+	    else
+	    {
+		return FALSE;
+	    }
+	}
+	return has_string_literal ? TRUE : FALSE;
+    }
+    return FALSE;
+}
+
+/*
+ * Return a pointer to the first non-empty non-comment character after a ':'.
+ * Return NULL if not found.
+ *	  case 234:    a = b;
+ *		       ^
+ */
+    static char_u *
+after_label(char_u *l)
+{
+    for ( ; *l; ++l)
+    {
+	if (*l == ':')
+	{
+	    if (l[1] == ':')	    /* skip over "::" for C++ */
+		++l;
+	    else if (!cin_iscase(l + 1, FALSE))
+		break;
+	}
+	else if (*l == '\'' && l[1] && l[2] == '\'')
+	    l += 2;		    /* skip over 'x' */
+    }
+    if (*l == NUL)
+	return NULL;
+    l = cin_skipcomment(l + 1);
+    if (*l == NUL)
+	return NULL;
+    return l;
+}
+
+/*
+ * Get indent of line "lnum", skipping a label.
+ * Return 0 if there is nothing after the label.
+ */
+    static int
+get_indent_nolabel (linenr_T lnum)	/* XXX */
+{
+    char_u	*l;
+    pos_T	fp;
+    colnr_T	col;
+    char_u	*p;
+
+    l = ml_get(lnum);
+    p = after_label(l);
+    if (p == NULL)
+	return 0;
+
+    fp.col = (colnr_T)(p - l);
+    fp.lnum = lnum;
+    getvcol(curwin, &fp, &col, NULL, NULL);
+    return (int)col;
+}
+
+/*
+ * Find indent for line "lnum", ignoring any case or jump label.
+ * Also return a pointer to the text (after the label) in "pp".
+ *   label:	if (asdf && asdfasdf)
+ *		^
+ */
+    static int
+skip_label(linenr_T lnum, char_u **pp)
+{
+    char_u	*l;
+    int		amount;
+    pos_T	cursor_save;
+
+    cursor_save = curwin->w_cursor;
+    curwin->w_cursor.lnum = lnum;
+    l = ml_get_curline();
+				    /* XXX */
+    if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel())
+    {
+	amount = get_indent_nolabel(lnum);
+	l = after_label(ml_get_curline());
+	if (l == NULL)		/* just in case */
+	    l = ml_get_curline();
+    }
+    else
+    {
+	amount = get_indent();
+	l = ml_get_curline();
+    }
+    *pp = l;
+
+    curwin->w_cursor = cursor_save;
+    return amount;
+}
+
+/*
+ * Return the indent of the first variable name after a type in a declaration.
+ *  int	    a,			indent of "a"
+ *  static struct foo    b,	indent of "b"
+ *  enum bla    c,		indent of "c"
+ * Returns zero when it doesn't look like a declaration.
+ */
+    static int
+cin_first_id_amount(void)
+{
+    char_u	*line, *p, *s;
+    int		len;
+    pos_T	fp;
+    colnr_T	col;
+
+    line = ml_get_curline();
+    p = skipwhite(line);
+    len = (int)(skiptowhite(p) - p);
+    if (len == 6 && STRNCMP(p, "static", 6) == 0)
+    {
+	p = skipwhite(p + 6);
+	len = (int)(skiptowhite(p) - p);
+    }
+    if (len == 6 && STRNCMP(p, "struct", 6) == 0)
+	p = skipwhite(p + 6);
+    else if (len == 4 && STRNCMP(p, "enum", 4) == 0)
+	p = skipwhite(p + 4);
+    else if ((len == 8 && STRNCMP(p, "unsigned", 8) == 0)
+	    || (len == 6 && STRNCMP(p, "signed", 6) == 0))
+    {
+	s = skipwhite(p + len);
+	if ((STRNCMP(s, "int", 3) == 0 && VIM_ISWHITE(s[3]))
+		|| (STRNCMP(s, "long", 4) == 0 && VIM_ISWHITE(s[4]))
+		|| (STRNCMP(s, "short", 5) == 0 && VIM_ISWHITE(s[5]))
+		|| (STRNCMP(s, "char", 4) == 0 && VIM_ISWHITE(s[4])))
+	    p = s;
+    }
+    for (len = 0; vim_isIDc(p[len]); ++len)
+	;
+    if (len == 0 || !VIM_ISWHITE(p[len]) || cin_nocode(p))
+	return 0;
+
+    p = skipwhite(p + len);
+    fp.lnum = curwin->w_cursor.lnum;
+    fp.col = (colnr_T)(p - line);
+    getvcol(curwin, &fp, &col, NULL, NULL);
+    return (int)col;
+}
+
+/*
+ * Return the indent of the first non-blank after an equal sign.
+ *       char *foo = "here";
+ * Return zero if no (useful) equal sign found.
+ * Return -1 if the line above "lnum" ends in a backslash.
+ *      foo = "asdf\
+ *	       asdf\
+ *	       here";
+ */
+    static int
+cin_get_equal_amount(linenr_T lnum)
+{
+    char_u	*line;
+    char_u	*s;
+    colnr_T	col;
+    pos_T	fp;
+
+    if (lnum > 1)
+    {
+	line = ml_get(lnum - 1);
+	if (*line != NUL && line[STRLEN(line) - 1] == '\\')
+	    return -1;
+    }
+
+    line = s = ml_get(lnum);
+    while (*s != NUL && vim_strchr((char_u *)"=;{}\"'", *s) == NULL)
+    {
+	if (cin_iscomment(s))	/* ignore comments */
+	    s = cin_skipcomment(s);
+	else
+	    ++s;
+    }
+    if (*s != '=')
+	return 0;
+
+    s = skipwhite(s + 1);
+    if (cin_nocode(s))
+	return 0;
+
+    if (*s == '"')	/* nice alignment for continued strings */
+	++s;
+
+    fp.lnum = lnum;
+    fp.col = (colnr_T)(s - line);
+    getvcol(curwin, &fp, &col, NULL, NULL);
+    return (int)col;
+}
+
+/*
+ * Recognize a preprocessor statement: Any line that starts with '#'.
+ */
+    static int
+cin_ispreproc(char_u *s)
+{
+    if (*skipwhite(s) == '#')
+	return TRUE;
+    return FALSE;
+}
+
+/*
+ * Return TRUE if line "*pp" at "*lnump" is a preprocessor statement or a
+ * continuation line of a preprocessor statement.  Decrease "*lnump" to the
+ * start and return the line in "*pp".
+ * Put the amount of indent in "*amount".
+ */
+    static int
+cin_ispreproc_cont(char_u **pp, linenr_T *lnump, int *amount)
+{
+    char_u	*line = *pp;
+    linenr_T	lnum = *lnump;
+    int		retval = FALSE;
+    int		candidate_amount = *amount;
+
+    if (*line != NUL && line[STRLEN(line) - 1] == '\\')
+	candidate_amount = get_indent_lnum(lnum);
+
+    for (;;)
+    {
+	if (cin_ispreproc(line))
+	{
+	    retval = TRUE;
+	    *lnump = lnum;
+	    break;
+	}
+	if (lnum == 1)
+	    break;
+	line = ml_get(--lnum);
+	if (*line == NUL || line[STRLEN(line) - 1] != '\\')
+	    break;
+    }
+
+    if (lnum != *lnump)
+	*pp = ml_get(*lnump);
+    if (retval)
+	*amount = candidate_amount;
+    return retval;
+}
+
+/*
+ * Recognize the start of a C or C++ comment.
+ */
+    static int
+cin_iscomment(char_u *p)
+{
+    return (p[0] == '/' && (p[1] == '*' || p[1] == '/'));
+}
+
+/*
+ * Recognize the start of a "//" comment.
+ */
+    static int
+cin_islinecomment(char_u *p)
+{
+    return (p[0] == '/' && p[1] == '/');
+}
+
+/*
+ * Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or
+ * '}'.
+ * Don't consider "} else" a terminated line.
+ * If a line begins with an "else", only consider it terminated if no unmatched
+ * opening braces follow (handle "else { foo();" correctly).
+ * Return the character terminating the line (ending char's have precedence if
+ * both apply in order to determine initializations).
+ */
+    static int
+cin_isterminated(
+    char_u	*s,
+    int		incl_open,	/* include '{' at the end as terminator */
+    int		incl_comma)	/* recognize a trailing comma */
+{
+    char_u	found_start = 0;
+    unsigned	n_open = 0;
+    int		is_else = FALSE;
+
+    s = cin_skipcomment(s);
+
+    if (*s == '{' || (*s == '}' && !cin_iselse(s)))
+	found_start = *s;
+
+    if (!found_start)
+	is_else = cin_iselse(s);
+
+    while (*s)
+    {
+	/* skip over comments, "" strings and 'c'haracters */
+	s = skip_string(cin_skipcomment(s));
+	if (*s == '}' && n_open > 0)
+	    --n_open;
+	if ((!is_else || n_open == 0)
+		&& (*s == ';' || *s == '}' || (incl_comma && *s == ','))
+		&& cin_nocode(s + 1))
+	    return *s;
+	else if (*s == '{')
+	{
+	    if (incl_open && cin_nocode(s + 1))
+		return *s;
+	    else
+		++n_open;
+	}
+
+	if (*s)
+	    s++;
+    }
+    return found_start;
+}
+
+/*
+ * Recognize the basic picture of a function declaration -- it needs to
+ * have an open paren somewhere and a close paren at the end of the line and
+ * no semicolons anywhere.
+ * When a line ends in a comma we continue looking in the next line.
+ * "sp" points to a string with the line.  When looking at other lines it must
+ * be restored to the line.  When it's NULL fetch lines here.
+ * "first_lnum" is where we start looking.
+ * "min_lnum" is the line before which we will not be looking.
+ */
+    static int
+cin_isfuncdecl(
+    char_u	**sp,
+    linenr_T	first_lnum,
+    linenr_T	min_lnum)
+{
+    char_u	*s;
+    linenr_T	lnum = first_lnum;
+    linenr_T	save_lnum = curwin->w_cursor.lnum;
+    int		retval = FALSE;
+    pos_T	*trypos;
+    int		just_started = TRUE;
+
+    if (sp == NULL)
+	s = ml_get(lnum);
+    else
+	s = *sp;
+
+    curwin->w_cursor.lnum = lnum;
+    if (find_last_paren(s, '(', ')')
+	&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
+    {
+	lnum = trypos->lnum;
+	if (lnum < min_lnum)
+	{
+	    curwin->w_cursor.lnum = save_lnum;
+	    return FALSE;
+	}
+
+	s = ml_get(lnum);
+    }
+    curwin->w_cursor.lnum = save_lnum;
+
+    /* Ignore line starting with #. */
+    if (cin_ispreproc(s))
+	return FALSE;
+
+    while (*s && *s != '(' && *s != ';' && *s != '\'' && *s != '"')
+    {
+	if (cin_iscomment(s))	/* ignore comments */
+	    s = cin_skipcomment(s);
+	else if (*s == ':')
+	{
+	    if (*(s + 1) == ':')
+		s += 2;
+	    else
+		/* To avoid a mistake in the following situation:
+		 * A::A(int a, int b)
+		 *     : a(0)  // <--not a function decl
+		 *     , b(0)
+		 * {...
+		 */
+		return FALSE;
+	}
+	else
+	    ++s;
+    }
+    if (*s != '(')
+	return FALSE;		/* ';', ' or "  before any () or no '(' */
+
+    while (*s && *s != ';' && *s != '\'' && *s != '"')
+    {
+	if (*s == ')' && cin_nocode(s + 1))
+	{
+	    /* ')' at the end: may have found a match
+	     * Check for he previous line not to end in a backslash:
+	     *       #if defined(x) && \
+	     *		 defined(y)
+	     */
+	    lnum = first_lnum - 1;
+	    s = ml_get(lnum);
+	    if (*s == NUL || s[STRLEN(s) - 1] != '\\')
+		retval = TRUE;
+	    goto done;
+	}
+	if ((*s == ',' && cin_nocode(s + 1)) || s[1] == NUL || cin_nocode(s))
+	{
+	    int comma = (*s == ',');
+
+	    /* ',' at the end: continue looking in the next line.
+	     * At the end: check for ',' in the next line, for this style:
+	     * func(arg1
+	     *       , arg2) */
+	    for (;;)
+	    {
+		if (lnum >= curbuf->b_ml.ml_line_count)
+		    break;
+		s = ml_get(++lnum);
+		if (!cin_ispreproc(s))
+		    break;
+	    }
+	    if (lnum >= curbuf->b_ml.ml_line_count)
+		break;
+	    /* Require a comma at end of the line or a comma or ')' at the
+	     * start of next line. */
+	    s = skipwhite(s);
+	    if (!just_started && (!comma && *s != ',' && *s != ')'))
+		break;
+	    just_started = FALSE;
+	}
+	else if (cin_iscomment(s))	/* ignore comments */
+	    s = cin_skipcomment(s);
+	else
+	{
+	    ++s;
+	    just_started = FALSE;
+	}
+    }
+
+done:
+    if (lnum != first_lnum && sp != NULL)
+	*sp = ml_get(first_lnum);
+
+    return retval;
+}
+
+    static int
+cin_isif(char_u *p)
+{
+ return (STRNCMP(p, "if", 2) == 0 && !vim_isIDc(p[2]));
+}
+
+    static int
+cin_iselse(
+    char_u  *p)
+{
+    if (*p == '}')	    /* accept "} else" */
+	p = cin_skipcomment(p + 1);
+    return (STRNCMP(p, "else", 4) == 0 && !vim_isIDc(p[4]));
+}
+
+    static int
+cin_isdo(char_u *p)
+{
+    return (STRNCMP(p, "do", 2) == 0 && !vim_isIDc(p[2]));
+}
+
+/*
+ * Check if this is a "while" that should have a matching "do".
+ * We only accept a "while (condition) ;", with only white space between the
+ * ')' and ';'. The condition may be spread over several lines.
+ */
+    static int
+cin_iswhileofdo (char_u *p, linenr_T lnum)	/* XXX */
+{
+    pos_T	cursor_save;
+    pos_T	*trypos;
+    int		retval = FALSE;
+
+    p = cin_skipcomment(p);
+    if (*p == '}')		/* accept "} while (cond);" */
+	p = cin_skipcomment(p + 1);
+    if (cin_starts_with(p, "while"))
+    {
+	cursor_save = curwin->w_cursor;
+	curwin->w_cursor.lnum = lnum;
+	curwin->w_cursor.col = 0;
+	p = ml_get_curline();
+	while (*p && *p != 'w')	/* skip any '}', until the 'w' of the "while" */
+	{
+	    ++p;
+	    ++curwin->w_cursor.col;
+	}
+	if ((trypos = findmatchlimit(NULL, 0, 0,
+					      curbuf->b_ind_maxparen)) != NULL
+		&& *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')
+	    retval = TRUE;
+	curwin->w_cursor = cursor_save;
+    }
+    return retval;
+}
+
+/*
+ * Check whether in "p" there is an "if", "for" or "while" before "*poffset".
+ * Return 0 if there is none.
+ * Otherwise return !0 and update "*poffset" to point to the place where the
+ * string was found.
+ */
+    static int
+cin_is_if_for_while_before_offset(char_u *line, int *poffset)
+{
+    int offset = *poffset;
+
+    if (offset-- < 2)
+	return 0;
+    while (offset > 2 && VIM_ISWHITE(line[offset]))
+	--offset;
+
+    offset -= 1;
+    if (!STRNCMP(line + offset, "if", 2))
+	goto probablyFound;
+
+    if (offset >= 1)
+    {
+	offset -= 1;
+	if (!STRNCMP(line + offset, "for", 3))
+	    goto probablyFound;
+
+	if (offset >= 2)
+	{
+	    offset -= 2;
+	    if (!STRNCMP(line + offset, "while", 5))
+		goto probablyFound;
+	}
+    }
+    return 0;
+
+probablyFound:
+    if (!offset || !vim_isIDc(line[offset - 1]))
+    {
+	*poffset = offset;
+	return 1;
+    }
+    return 0;
+}
+
+/*
+ * Return TRUE if we are at the end of a do-while.
+ *    do
+ *       nothing;
+ *    while (foo
+ *	       && bar);  <-- here
+ * Adjust the cursor to the line with "while".
+ */
+    static int
+cin_iswhileofdo_end(int terminated)
+{
+    char_u	*line;
+    char_u	*p;
+    char_u	*s;
+    pos_T	*trypos;
+    int		i;
+
+    if (terminated != ';')	/* there must be a ';' at the end */
+	return FALSE;
+
+    p = line = ml_get_curline();
+    while (*p != NUL)
+    {
+	p = cin_skipcomment(p);
+	if (*p == ')')
+	{
+	    s = skipwhite(p + 1);
+	    if (*s == ';' && cin_nocode(s + 1))
+	    {
+		/* Found ");" at end of the line, now check there is "while"
+		 * before the matching '('.  XXX */
+		i = (int)(p - line);
+		curwin->w_cursor.col = i;
+		trypos = find_match_paren(curbuf->b_ind_maxparen);
+		if (trypos != NULL)
+		{
+		    s = cin_skipcomment(ml_get(trypos->lnum));
+		    if (*s == '}')		/* accept "} while (cond);" */
+			s = cin_skipcomment(s + 1);
+		    if (cin_starts_with(s, "while"))
+		    {
+			curwin->w_cursor.lnum = trypos->lnum;
+			return TRUE;
+		    }
+		}
+
+		/* Searching may have made "line" invalid, get it again. */
+		line = ml_get_curline();
+		p = line + i;
+	    }
+	}
+	if (*p != NUL)
+	    ++p;
+    }
+    return FALSE;
+}
+
+    static int
+cin_isbreak(char_u *p)
+{
+    return (STRNCMP(p, "break", 5) == 0 && !vim_isIDc(p[5]));
+}
+
+/*
+ * Find the position of a C++ base-class declaration or
+ * constructor-initialization. eg:
+ *
+ * class MyClass :
+ *	baseClass		<-- here
+ * class MyClass : public baseClass,
+ *	anotherBaseClass	<-- here (should probably lineup ??)
+ * MyClass::MyClass(...) :
+ *	baseClass(...)		<-- here (constructor-initialization)
+ *
+ * This is a lot of guessing.  Watch out for "cond ? func() : foo".
+ */
+    static int
+cin_is_cpp_baseclass(
+    cpp_baseclass_cache_T *cached) /* input and output */
+{
+    lpos_T	*pos = &cached->lpos;	    /* find position */
+    char_u	*s;
+    int		class_or_struct, lookfor_ctor_init, cpp_base_class;
+    linenr_T	lnum = curwin->w_cursor.lnum;
+    char_u	*line = ml_get_curline();
+
+    if (pos->lnum <= lnum)
+	return cached->found;	/* Use the cached result */
+
+    pos->col = 0;
+
+    s = skipwhite(line);
+    if (*s == '#')		/* skip #define FOO x ? (x) : x */
+	return FALSE;
+    s = cin_skipcomment(s);
+    if (*s == NUL)
+	return FALSE;
+
+    cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;
+
+    /* Search for a line starting with '#', empty, ending in ';' or containing
+     * '{' or '}' and start below it.  This handles the following situations:
+     *	a = cond ?
+     *	      func() :
+     *		   asdf;
+     *	func::foo()
+     *	      : something
+     *	{}
+     *	Foo::Foo (int one, int two)
+     *		: something(4),
+     *		somethingelse(3)
+     *	{}
+     */
+    while (lnum > 1)
+    {
+	line = ml_get(lnum - 1);
+	s = skipwhite(line);
+	if (*s == '#' || *s == NUL)
+	    break;
+	while (*s != NUL)
+	{
+	    s = cin_skipcomment(s);
+	    if (*s == '{' || *s == '}'
+		    || (*s == ';' && cin_nocode(s + 1)))
+		break;
+	    if (*s != NUL)
+		++s;
+	}
+	if (*s != NUL)
+	    break;
+	--lnum;
+    }
+
+    pos->lnum = lnum;
+    line = ml_get(lnum);
+    s = line;
+    for (;;)
+    {
+	if (*s == NUL)
+	{
+	    if (lnum == curwin->w_cursor.lnum)
+		break;
+	    /* Continue in the cursor line. */
+	    line = ml_get(++lnum);
+	    s = line;
+	}
+	if (s == line)
+	{
+	    /* don't recognize "case (foo):" as a baseclass */
+	    if (cin_iscase(s, FALSE))
+		break;
+	    s = cin_skipcomment(line);
+	    if (*s == NUL)
+		continue;
+	}
+
+	if (s[0] == '"' || (s[0] == 'R' && s[1] == '"'))
+	    s = skip_string(s) + 1;
+	else if (s[0] == ':')
+	{
+	    if (s[1] == ':')
+	    {
+		/* skip double colon. It can't be a constructor
+		 * initialization any more */
+		lookfor_ctor_init = FALSE;
+		s = cin_skipcomment(s + 2);
+	    }
+	    else if (lookfor_ctor_init || class_or_struct)
+	    {
+		/* we have something found, that looks like the start of
+		 * cpp-base-class-declaration or constructor-initialization */
+		cpp_base_class = TRUE;
+		lookfor_ctor_init = class_or_struct = FALSE;
+		pos->col = 0;
+		s = cin_skipcomment(s + 1);
+	    }
+	    else
+		s = cin_skipcomment(s + 1);
+	}
+	else if ((STRNCMP(s, "class", 5) == 0 && !vim_isIDc(s[5]))
+		|| (STRNCMP(s, "struct", 6) == 0 && !vim_isIDc(s[6])))
+	{
+	    class_or_struct = TRUE;
+	    lookfor_ctor_init = FALSE;
+
+	    if (*s == 'c')
+		s = cin_skipcomment(s + 5);
+	    else
+		s = cin_skipcomment(s + 6);
+	}
+	else
+	{
+	    if (s[0] == '{' || s[0] == '}' || s[0] == ';')
+	    {
+		cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;
+	    }
+	    else if (s[0] == ')')
+	    {
+		/* Constructor-initialization is assumed if we come across
+		 * something like "):" */
+		class_or_struct = FALSE;
+		lookfor_ctor_init = TRUE;
+	    }
+	    else if (s[0] == '?')
+	    {
+		/* Avoid seeing '() :' after '?' as constructor init. */
+		return FALSE;
+	    }
+	    else if (!vim_isIDc(s[0]))
+	    {
+		/* if it is not an identifier, we are wrong */
+		class_or_struct = FALSE;
+		lookfor_ctor_init = FALSE;
+	    }
+	    else if (pos->col == 0)
+	    {
+		/* it can't be a constructor-initialization any more */
+		lookfor_ctor_init = FALSE;
+
+		/* the first statement starts here: lineup with this one... */
+		if (cpp_base_class)
+		    pos->col = (colnr_T)(s - line);
+	    }
+
+	    /* When the line ends in a comma don't align with it. */
+	    if (lnum == curwin->w_cursor.lnum && *s == ',' && cin_nocode(s + 1))
+		pos->col = 0;
+
+	    s = cin_skipcomment(s + 1);
+	}
+    }
+
+    cached->found = cpp_base_class;
+    if (cpp_base_class)
+	pos->lnum = lnum;
+    return cpp_base_class;
+}
+
+    static int
+get_baseclass_amount(int col)
+{
+    int		amount;
+    colnr_T	vcol;
+    pos_T	*trypos;
+
+    if (col == 0)
+    {
+	amount = get_indent();
+	if (find_last_paren(ml_get_curline(), '(', ')')
+		&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
+	    amount = get_indent_lnum(trypos->lnum); /* XXX */
+	if (!cin_ends_in(ml_get_curline(), (char_u *)",", NULL))
+	    amount += curbuf->b_ind_cpp_baseclass;
+    }
+    else
+    {
+	curwin->w_cursor.col = col;
+	getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);
+	amount = (int)vcol;
+    }
+    if (amount < curbuf->b_ind_cpp_baseclass)
+	amount = curbuf->b_ind_cpp_baseclass;
+    return amount;
+}
+
+/*
+ * Return TRUE if string "s" ends with the string "find", possibly followed by
+ * white space and comments.  Skip strings and comments.
+ * Ignore "ignore" after "find" if it's not NULL.
+ */
+    static int
+cin_ends_in(char_u *s, char_u *find, char_u *ignore)
+{
+    char_u	*p = s;
+    char_u	*r;
+    int		len = (int)STRLEN(find);
+
+    while (*p != NUL)
+    {
+	p = cin_skipcomment(p);
+	if (STRNCMP(p, find, len) == 0)
+	{
+	    r = skipwhite(p + len);
+	    if (ignore != NULL && STRNCMP(r, ignore, STRLEN(ignore)) == 0)
+		r = skipwhite(r + STRLEN(ignore));
+	    if (cin_nocode(r))
+		return TRUE;
+	}
+	if (*p != NUL)
+	    ++p;
+    }
+    return FALSE;
+}
+
+/*
+ * Return TRUE when "s" starts with "word" and then a non-ID character.
+ */
+    static int
+cin_starts_with(char_u *s, char *word)
+{
+    int l = (int)STRLEN(word);
+
+    return (STRNCMP(s, word, l) == 0 && !vim_isIDc(s[l]));
+}
+
+/*
+ * Skip strings, chars and comments until at or past "trypos".
+ * Return the column found.
+ */
+    static int
+cin_skip2pos(pos_T *trypos)
+{
+    char_u	*line;
+    char_u	*p;
+    char_u	*new_p;
+
+    p = line = ml_get(trypos->lnum);
+    while (*p && (colnr_T)(p - line) < trypos->col)
+    {
+	if (cin_iscomment(p))
+	    p = cin_skipcomment(p);
+	else
+	{
+	    new_p = skip_string(p);
+	    if (new_p == p)
+		++p;
+	    else
+		p = new_p;
+	}
+    }
+    return (int)(p - line);
+}
+
+/*
+ * Find the '{' at the start of the block we are in.
+ * Return NULL if no match found.
+ * Ignore a '{' that is in a comment, makes indenting the next three lines
+ * work. */
+/* foo()    */
+/* {	    */
+/* }	    */
+
+    static pos_T *
+find_start_brace(void)	    /* XXX */
+{
+    pos_T	cursor_save;
+    pos_T	*trypos;
+    pos_T	*pos;
+    static pos_T	pos_copy;
+
+    cursor_save = curwin->w_cursor;
+    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)
+    {
+	pos_copy = *trypos;	/* copy pos_T, next findmatch will change it */
+	trypos = &pos_copy;
+	curwin->w_cursor = *trypos;
+	pos = NULL;
+	/* ignore the { if it's in a // or / *  * / comment */
+	if ((colnr_T)cin_skip2pos(trypos) == trypos->col
+		       && (pos = ind_find_start_CORS(NULL)) == NULL) /* XXX */
+	    break;
+	if (pos != NULL)
+	    curwin->w_cursor.lnum = pos->lnum;
+    }
+    curwin->w_cursor = cursor_save;
+    return trypos;
+}
+
+/*
+ * Find the matching '(', ignoring it if it is in a comment.
+ * Return NULL if no match found.
+ */
+    static pos_T *
+find_match_paren(int ind_maxparen)	/* XXX */
+{
+    return find_match_char('(', ind_maxparen);
+}
+
+    static pos_T *
+find_match_char (int c, int ind_maxparen)	/* XXX */
+{
+    pos_T	cursor_save;
+    pos_T	*trypos;
+    static pos_T pos_copy;
+    int		ind_maxp_wk;
+
+    cursor_save = curwin->w_cursor;
+    ind_maxp_wk = ind_maxparen;
+retry:
+    if ((trypos = findmatchlimit(NULL, c, 0, ind_maxp_wk)) != NULL)
+    {
+	/* check if the ( is in a // comment */
+	if ((colnr_T)cin_skip2pos(trypos) > trypos->col)
+	{
+	    ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos->lnum);
+	    if (ind_maxp_wk > 0)
+	    {
+		curwin->w_cursor = *trypos;
+		curwin->w_cursor.col = 0;	/* XXX */
+		goto retry;
+	    }
+	    trypos = NULL;
+	}
+	else
+	{
+	    pos_T	*trypos_wk;
+
+	    pos_copy = *trypos;	    /* copy trypos, findmatch will change it */
+	    trypos = &pos_copy;
+	    curwin->w_cursor = *trypos;
+	    if ((trypos_wk = ind_find_start_CORS(NULL)) != NULL) /* XXX */
+	    {
+		ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum
+			- trypos_wk->lnum);
+		if (ind_maxp_wk > 0)
+		{
+		    curwin->w_cursor = *trypos_wk;
+		    goto retry;
+		}
+		trypos = NULL;
+	    }
+	}
+    }
+    curwin->w_cursor = cursor_save;
+    return trypos;
+}
+
+/*
+ * Find the matching '(', ignoring it if it is in a comment or before an
+ * unmatched {.
+ * Return NULL if no match found.
+ */
+    static pos_T *
+find_match_paren_after_brace (int ind_maxparen)	    /* XXX */
+{
+    pos_T	*trypos = find_match_paren(ind_maxparen);
+
+    if (trypos != NULL)
+    {
+	pos_T	*tryposBrace = find_start_brace();
+
+	/* If both an unmatched '(' and '{' is found.  Ignore the '('
+	 * position if the '{' is further down. */
+	if (tryposBrace != NULL
+		&& (trypos->lnum != tryposBrace->lnum
+		    ? trypos->lnum < tryposBrace->lnum
+		    : trypos->col < tryposBrace->col))
+	    trypos = NULL;
+    }
+    return trypos;
+}
+
+/*
+ * Return ind_maxparen corrected for the difference in line number between the
+ * cursor position and "startpos".  This makes sure that searching for a
+ * matching paren above the cursor line doesn't find a match because of
+ * looking a few lines further.
+ */
+    static int
+corr_ind_maxparen(pos_T *startpos)
+{
+    long	n = (long)startpos->lnum - (long)curwin->w_cursor.lnum;
+
+    if (n > 0 && n < curbuf->b_ind_maxparen / 2)
+	return curbuf->b_ind_maxparen - (int)n;
+    return curbuf->b_ind_maxparen;
+}
+
+/*
+ * Set w_cursor.col to the column number of the last unmatched ')' or '{' in
+ * line "l".  "l" must point to the start of the line.
+ */
+    static int
+find_last_paren(char_u *l, int start, int end)
+{
+    int		i;
+    int		retval = FALSE;
+    int		open_count = 0;
+
+    curwin->w_cursor.col = 0;		    /* default is start of line */
+
+    for (i = 0; l[i] != NUL; i++)
+    {
+	i = (int)(cin_skipcomment(l + i) - l); /* ignore parens in comments */
+	i = (int)(skip_string(l + i) - l);    /* ignore parens in quotes */
+	if (l[i] == start)
+	    ++open_count;
+	else if (l[i] == end)
+	{
+	    if (open_count > 0)
+		--open_count;
+	    else
+	    {
+		curwin->w_cursor.col = i;
+		retval = TRUE;
+	    }
+	}
+    }
+    return retval;
+}
+
+/*
+ * Parse 'cinoptions' and set the values in "curbuf".
+ * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.
+ */
+    void
+parse_cino(buf_T *buf)
+{
+    char_u	*p;
+    char_u	*l;
+    char_u	*digits;
+    int		n;
+    int		divider;
+    int		fraction = 0;
+    int		sw = (int)get_sw_value(buf);
+
+    /*
+     * Set the default values.
+     */
+    /* Spaces from a block's opening brace the prevailing indent for that
+     * block should be. */
+    buf->b_ind_level = sw;
+
+    /* Spaces from the edge of the line an open brace that's at the end of a
+     * line is imagined to be. */
+    buf->b_ind_open_imag = 0;
+
+    /* Spaces from the prevailing indent for a line that is not preceded by
+     * an opening brace. */
+    buf->b_ind_no_brace = 0;
+
+    /* Column where the first { of a function should be located }. */
+    buf->b_ind_first_open = 0;
+
+    /* Spaces from the prevailing indent a leftmost open brace should be
+     * located. */
+    buf->b_ind_open_extra = 0;
+
+    /* Spaces from the matching open brace (real location for one at the left
+     * edge; imaginary location from one that ends a line) the matching close
+     * brace should be located. */
+    buf->b_ind_close_extra = 0;
+
+    /* Spaces from the edge of the line an open brace sitting in the leftmost
+     * column is imagined to be. */
+    buf->b_ind_open_left_imag = 0;
+
+    /* Spaces jump labels should be shifted to the left if N is non-negative,
+     * otherwise the jump label will be put to column 1. */
+    buf->b_ind_jump_label = -1;
+
+    /* Spaces from the switch() indent a "case xx" label should be located. */
+    buf->b_ind_case = sw;
+
+    /* Spaces from the "case xx:" code after a switch() should be located. */
+    buf->b_ind_case_code = sw;
+
+    /* Lineup break at end of case in switch() with case label. */
+    buf->b_ind_case_break = 0;
+
+    /* Spaces from the class declaration indent a scope declaration label
+     * should be located. */
+    buf->b_ind_scopedecl = sw;
+
+    /* Spaces from the scope declaration label code should be located. */
+    buf->b_ind_scopedecl_code = sw;
+
+    /* Amount K&R-style parameters should be indented. */
+    buf->b_ind_param = sw;
+
+    /* Amount a function type spec should be indented. */
+    buf->b_ind_func_type = sw;
+
+    /* Amount a cpp base class declaration or constructor initialization
+     * should be indented. */
+    buf->b_ind_cpp_baseclass = sw;
+
+    /* additional spaces beyond the prevailing indent a continuation line
+     * should be located. */
+    buf->b_ind_continuation = sw;
+
+    /* Spaces from the indent of the line with an unclosed parentheses. */
+    buf->b_ind_unclosed = sw * 2;
+
+    /* Spaces from the indent of the line with an unclosed parentheses, which
+     * itself is also unclosed. */
+    buf->b_ind_unclosed2 = sw;
+
+    /* Suppress ignoring spaces from the indent of a line starting with an
+     * unclosed parentheses. */
+    buf->b_ind_unclosed_noignore = 0;
+
+    /* If the opening paren is the last nonwhite character on the line, and
+     * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer
+     * context (for very long lines). */
+    buf->b_ind_unclosed_wrapped = 0;
+
+    /* Suppress ignoring white space when lining up with the character after
+     * an unclosed parentheses. */
+    buf->b_ind_unclosed_whiteok = 0;
+
+    /* Indent a closing parentheses under the line start of the matching
+     * opening parentheses. */
+    buf->b_ind_matching_paren = 0;
+
+    /* Indent a closing parentheses under the previous line. */
+    buf->b_ind_paren_prev = 0;
+
+    /* Extra indent for comments. */
+    buf->b_ind_comment = 0;
+
+    /* Spaces from the comment opener when there is nothing after it. */
+    buf->b_ind_in_comment = 3;
+
+    /* Boolean: if non-zero, use b_ind_in_comment even if there is something
+     * after the comment opener. */
+    buf->b_ind_in_comment2 = 0;
+
+    /* Max lines to search for an open paren. */
+    buf->b_ind_maxparen = 20;
+
+    /* Max lines to search for an open comment. */
+    buf->b_ind_maxcomment = 70;
+
+    /* Handle braces for java code. */
+    buf->b_ind_java = 0;
+
+    /* Not to confuse JS object properties with labels. */
+    buf->b_ind_js = 0;
+
+    /* Handle blocked cases correctly. */
+    buf->b_ind_keep_case_label = 0;
+
+    /* Handle C++ namespace. */
+    buf->b_ind_cpp_namespace = 0;
+
+    /* Handle continuation lines containing conditions of if(), for() and
+     * while(). */
+    buf->b_ind_if_for_while = 0;
+
+    /* indentation for # comments */
+    buf->b_ind_hash_comment = 0;
+
+    /* Handle C++ extern "C" or "C++" */
+    buf->b_ind_cpp_extern_c = 0;
+
+    for (p = buf->b_p_cino; *p; )
+    {
+	l = p++;
+	if (*p == '-')
+	    ++p;
+	digits = p;	    /* remember where the digits start */
+	n = getdigits(&p);
+	divider = 0;
+	if (*p == '.')	    /* ".5s" means a fraction */
+	{
+	    fraction = atol((char *)++p);
+	    while (VIM_ISDIGIT(*p))
+	    {
+		++p;
+		if (divider)
+		    divider *= 10;
+		else
+		    divider = 10;
+	    }
+	}
+	if (*p == 's')	    /* "2s" means two times 'shiftwidth' */
+	{
+	    if (p == digits)
+		n = sw;	/* just "s" is one 'shiftwidth' */
+	    else
+	    {
+		n *= sw;
+		if (divider)
+		    n += (sw * fraction + divider / 2) / divider;
+	    }
+	    ++p;
+	}
+	if (l[1] == '-')
+	    n = -n;
+
+	/* When adding an entry here, also update the default 'cinoptions' in
+	 * doc/indent.txt, and add explanation for it! */
+	switch (*l)
+	{
+	    case '>': buf->b_ind_level = n; break;
+	    case 'e': buf->b_ind_open_imag = n; break;
+	    case 'n': buf->b_ind_no_brace = n; break;
+	    case 'f': buf->b_ind_first_open = n; break;
+	    case '{': buf->b_ind_open_extra = n; break;
+	    case '}': buf->b_ind_close_extra = n; break;
+	    case '^': buf->b_ind_open_left_imag = n; break;
+	    case 'L': buf->b_ind_jump_label = n; break;
+	    case ':': buf->b_ind_case = n; break;
+	    case '=': buf->b_ind_case_code = n; break;
+	    case 'b': buf->b_ind_case_break = n; break;
+	    case 'p': buf->b_ind_param = n; break;
+	    case 't': buf->b_ind_func_type = n; break;
+	    case '/': buf->b_ind_comment = n; break;
+	    case 'c': buf->b_ind_in_comment = n; break;
+	    case 'C': buf->b_ind_in_comment2 = n; break;
+	    case 'i': buf->b_ind_cpp_baseclass = n; break;
+	    case '+': buf->b_ind_continuation = n; break;
+	    case '(': buf->b_ind_unclosed = n; break;
+	    case 'u': buf->b_ind_unclosed2 = n; break;
+	    case 'U': buf->b_ind_unclosed_noignore = n; break;
+	    case 'W': buf->b_ind_unclosed_wrapped = n; break;
+	    case 'w': buf->b_ind_unclosed_whiteok = n; break;
+	    case 'm': buf->b_ind_matching_paren = n; break;
+	    case 'M': buf->b_ind_paren_prev = n; break;
+	    case ')': buf->b_ind_maxparen = n; break;
+	    case '*': buf->b_ind_maxcomment = n; break;
+	    case 'g': buf->b_ind_scopedecl = n; break;
+	    case 'h': buf->b_ind_scopedecl_code = n; break;
+	    case 'j': buf->b_ind_java = n; break;
+	    case 'J': buf->b_ind_js = n; break;
+	    case 'l': buf->b_ind_keep_case_label = n; break;
+	    case '#': buf->b_ind_hash_comment = n; break;
+	    case 'N': buf->b_ind_cpp_namespace = n; break;
+	    case 'k': buf->b_ind_if_for_while = n; break;
+	    case 'E': buf->b_ind_cpp_extern_c = n; break;
+	}
+	if (*p == ',')
+	    ++p;
+    }
+}
+
+/*
+ * Return the desired indent for C code.
+ * Return -1 if the indent should be left alone (inside a raw string).
+ */
+    int
+get_c_indent(void)
+{
+    pos_T	cur_curpos;
+    int		amount;
+    int		scope_amount;
+    int		cur_amount = MAXCOL;
+    colnr_T	col;
+    char_u	*theline;
+    char_u	*linecopy;
+    pos_T	*trypos;
+    pos_T	*comment_pos;
+    pos_T	*tryposBrace = NULL;
+    pos_T	tryposCopy;
+    pos_T	our_paren_pos;
+    char_u	*start;
+    int		start_brace;
+#define BRACE_IN_COL0		1	    /* '{' is in column 0 */
+#define BRACE_AT_START		2	    /* '{' is at start of line */
+#define BRACE_AT_END		3	    /* '{' is at end of line */
+    linenr_T	ourscope;
+    char_u	*l;
+    char_u	*look;
+    char_u	terminated;
+    int		lookfor;
+#define LOOKFOR_INITIAL		0
+#define LOOKFOR_IF		1
+#define LOOKFOR_DO		2
+#define LOOKFOR_CASE		3
+#define LOOKFOR_ANY		4
+#define LOOKFOR_TERM		5
+#define LOOKFOR_UNTERM		6
+#define LOOKFOR_SCOPEDECL	7
+#define LOOKFOR_NOBREAK		8
+#define LOOKFOR_CPP_BASECLASS	9
+#define LOOKFOR_ENUM_OR_INIT	10
+#define LOOKFOR_JS_KEY		11
+#define LOOKFOR_COMMA		12
+
+    int		whilelevel;
+    linenr_T	lnum;
+    int		n;
+    int		iscase;
+    int		lookfor_break;
+    int		lookfor_cpp_namespace = FALSE;
+    int		cont_amount = 0;    /* amount for continuation line */
+    int		original_line_islabel;
+    int		added_to_amount = 0;
+    int		js_cur_has_key = 0;
+    linenr_T	raw_string_start = 0;
+    cpp_baseclass_cache_T cache_cpp_baseclass = { FALSE, { MAXLNUM, 0 } };
+
+    /* make a copy, value is changed below */
+    int		ind_continuation = curbuf->b_ind_continuation;
+
+    /* remember where the cursor was when we started */
+    cur_curpos = curwin->w_cursor;
+
+    /* if we are at line 1 zero indent is fine, right? */
+    if (cur_curpos.lnum == 1)
+	return 0;
+
+    /* Get a copy of the current contents of the line.
+     * This is required, because only the most recent line obtained with
+     * ml_get is valid! */
+    linecopy = vim_strsave(ml_get(cur_curpos.lnum));
+    if (linecopy == NULL)
+	return 0;
+
+    /*
+     * In insert mode and the cursor is on a ')' truncate the line at the
+     * cursor position.  We don't want to line up with the matching '(' when
+     * inserting new stuff.
+     * For unknown reasons the cursor might be past the end of the line, thus
+     * check for that.
+     */
+    if ((State & INSERT)
+	    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)
+	    && linecopy[curwin->w_cursor.col] == ')')
+	linecopy[curwin->w_cursor.col] = NUL;
+
+    theline = skipwhite(linecopy);
+
+    /* move the cursor to the start of the line */
+
+    curwin->w_cursor.col = 0;
+
+    original_line_islabel = cin_islabel();  /* XXX */
+
+    /*
+     * If we are inside a raw string don't change the indent.
+     * Ignore a raw string inside a comment.
+     */
+    comment_pos = ind_find_start_comment();
+    if (comment_pos != NULL)
+    {
+	/* findmatchlimit() static pos is overwritten, make a copy */
+	tryposCopy = *comment_pos;
+	comment_pos = &tryposCopy;
+    }
+    trypos = find_start_rawstring(curbuf->b_ind_maxcomment);
+    if (trypos != NULL && (comment_pos == NULL
+					     || LT_POS(*trypos, *comment_pos)))
+    {
+	amount = -1;
+	goto laterend;
+    }
+
+    /*
+     * #defines and so on always go at the left when included in 'cinkeys'.
+     */
+    if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))
+    {
+	amount = curbuf->b_ind_hash_comment;
+	goto theend;
+    }
+
+    /*
+     * Is it a non-case label?	Then that goes at the left margin too unless:
+     *  - JS flag is set.
+     *  - 'L' item has a positive value.
+     */
+    if (original_line_islabel && !curbuf->b_ind_js
+					      && curbuf->b_ind_jump_label < 0)
+    {
+	amount = 0;
+	goto theend;
+    }
+
+    /*
+     * If we're inside a "//" comment and there is a "//" comment in a
+     * previous line, lineup with that one.
+     */
+    if (cin_islinecomment(theline)
+	    && (trypos = find_line_comment()) != NULL) /* XXX */
+    {
+	/* find how indented the line beginning the comment is */
+	getvcol(curwin, trypos, &col, NULL, NULL);
+	amount = col;
+	goto theend;
+    }
+
+    /*
+     * If we're inside a comment and not looking at the start of the
+     * comment, try using the 'comments' option.
+     */
+    if (!cin_iscomment(theline) && comment_pos != NULL) /* XXX */
+    {
+	int	lead_start_len = 2;
+	int	lead_middle_len = 1;
+	char_u	lead_start[COM_MAX_LEN];	/* start-comment string */
+	char_u	lead_middle[COM_MAX_LEN];	/* middle-comment string */
+	char_u	lead_end[COM_MAX_LEN];		/* end-comment string */
+	char_u	*p;
+	int	start_align = 0;
+	int	start_off = 0;
+	int	done = FALSE;
+
+	/* find how indented the line beginning the comment is */
+	getvcol(curwin, comment_pos, &col, NULL, NULL);
+	amount = col;
+	*lead_start = NUL;
+	*lead_middle = NUL;
+
+	p = curbuf->b_p_com;
+	while (*p != NUL)
+	{
+	    int	align = 0;
+	    int	off = 0;
+	    int what = 0;
+
+	    while (*p != NUL && *p != ':')
+	    {
+		if (*p == COM_START || *p == COM_END || *p == COM_MIDDLE)
+		    what = *p++;
+		else if (*p == COM_LEFT || *p == COM_RIGHT)
+		    align = *p++;
+		else if (VIM_ISDIGIT(*p) || *p == '-')
+		    off = getdigits(&p);
+		else
+		    ++p;
+	    }
+
+	    if (*p == ':')
+		++p;
+	    (void)copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
+	    if (what == COM_START)
+	    {
+		STRCPY(lead_start, lead_end);
+		lead_start_len = (int)STRLEN(lead_start);
+		start_off = off;
+		start_align = align;
+	    }
+	    else if (what == COM_MIDDLE)
+	    {
+		STRCPY(lead_middle, lead_end);
+		lead_middle_len = (int)STRLEN(lead_middle);
+	    }
+	    else if (what == COM_END)
+	    {
+		/* If our line starts with the middle comment string, line it
+		 * up with the comment opener per the 'comments' option. */
+		if (STRNCMP(theline, lead_middle, lead_middle_len) == 0
+			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0)
+		{
+		    done = TRUE;
+		    if (curwin->w_cursor.lnum > 1)
+		    {
+			/* If the start comment string matches in the previous
+			 * line, use the indent of that line plus offset.  If
+			 * the middle comment string matches in the previous
+			 * line, use the indent of that line.  XXX */
+			look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));
+			if (STRNCMP(look, lead_start, lead_start_len) == 0)
+			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
+			else if (STRNCMP(look, lead_middle,
+							lead_middle_len) == 0)
+			{
+			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
+			    break;
+			}
+			/* If the start comment string doesn't match with the
+			 * start of the comment, skip this entry. XXX */
+			else if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,
+					     lead_start, lead_start_len) != 0)
+			    continue;
+		    }
+		    if (start_off != 0)
+			amount += start_off;
+		    else if (start_align == COM_RIGHT)
+			amount += vim_strsize(lead_start)
+						   - vim_strsize(lead_middle);
+		    break;
+		}
+
+		/* If our line starts with the end comment string, line it up
+		 * with the middle comment */
+		if (STRNCMP(theline, lead_middle, lead_middle_len) != 0
+			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0)
+		{
+		    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
+								     /* XXX */
+		    if (off != 0)
+			amount += off;
+		    else if (align == COM_RIGHT)
+			amount += vim_strsize(lead_start)
+						   - vim_strsize(lead_middle);
+		    done = TRUE;
+		    break;
+		}
+	    }
+	}
+
+	/* If our line starts with an asterisk, line up with the
+	 * asterisk in the comment opener; otherwise, line up
+	 * with the first character of the comment text.
+	 */
+	if (done)
+	    ;
+	else if (theline[0] == '*')
+	    amount += 1;
+	else
+	{
+	    /*
+	     * If we are more than one line away from the comment opener, take
+	     * the indent of the previous non-empty line.  If 'cino' has "CO"
+	     * and we are just below the comment opener and there are any
+	     * white characters after it line up with the text after it;
+	     * otherwise, add the amount specified by "c" in 'cino'
+	     */
+	    amount = -1;
+	    for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum)
+	    {
+		if (linewhite(lnum))		    /* skip blank lines */
+		    continue;
+		amount = get_indent_lnum(lnum);	    /* XXX */
+		break;
+	    }
+	    if (amount == -1)			    /* use the comment opener */
+	    {
+		if (!curbuf->b_ind_in_comment2)
+		{
+		    start = ml_get(comment_pos->lnum);
+		    look = start + comment_pos->col + 2; /* skip / and * */
+		    if (*look != NUL)		    /* if something after it */
+			comment_pos->col = (colnr_T)(skipwhite(look) - start);
+		}
+		getvcol(curwin, comment_pos, &col, NULL, NULL);
+		amount = col;
+		if (curbuf->b_ind_in_comment2 || *look == NUL)
+		    amount += curbuf->b_ind_in_comment;
+	    }
+	}
+	goto theend;
+    }
+
+    /*
+     * Are we looking at a ']' that has a match?
+     */
+    if (*skipwhite(theline) == ']'
+	    && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL)
+    {
+	/* align with the line containing the '['. */
+	amount = get_indent_lnum(trypos->lnum);
+	goto theend;
+    }
+
+    /*
+     * Are we inside parentheses or braces?
+     */						    /* XXX */
+    if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL
+		&& curbuf->b_ind_java == 0)
+	    || (tryposBrace = find_start_brace()) != NULL
+	    || trypos != NULL)
+    {
+      if (trypos != NULL && tryposBrace != NULL)
+      {
+	  /* Both an unmatched '(' and '{' is found.  Use the one which is
+	   * closer to the current cursor position, set the other to NULL. */
+	  if (trypos->lnum != tryposBrace->lnum
+		  ? trypos->lnum < tryposBrace->lnum
+		  : trypos->col < tryposBrace->col)
+	      trypos = NULL;
+	  else
+	      tryposBrace = NULL;
+      }
+
+      if (trypos != NULL)
+      {
+	/*
+	 * If the matching paren is more than one line away, use the indent of
+	 * a previous non-empty line that matches the same paren.
+	 */
+	if (theline[0] == ')' && curbuf->b_ind_paren_prev)
+	{
+	    /* Line up with the start of the matching paren line. */
+	    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  /* XXX */
+	}
+	else
+	{
+	    amount = -1;
+	    our_paren_pos = *trypos;
+	    for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum)
+	    {
+		l = skipwhite(ml_get(lnum));
+		if (cin_nocode(l))		/* skip comment lines */
+		    continue;
+		if (cin_ispreproc_cont(&l, &lnum, &amount))
+		    continue;			/* ignore #define, #if, etc. */
+		curwin->w_cursor.lnum = lnum;
+
+		/* Skip a comment or raw string. XXX */
+		if ((trypos = ind_find_start_CORS(NULL)) != NULL)
+		{
+		    lnum = trypos->lnum + 1;
+		    continue;
+		}
+
+		/* XXX */
+		if ((trypos = find_match_paren(
+			corr_ind_maxparen(&cur_curpos))) != NULL
+			&& trypos->lnum == our_paren_pos.lnum
+			&& trypos->col == our_paren_pos.col)
+		{
+			amount = get_indent_lnum(lnum);	/* XXX */
+
+			if (theline[0] == ')')
+			{
+			    if (our_paren_pos.lnum != lnum
+						       && cur_amount > amount)
+				cur_amount = amount;
+			    amount = -1;
+			}
+		    break;
+		}
+	    }
+	}
+
+	/*
+	 * Line up with line where the matching paren is. XXX
+	 * If the line starts with a '(' or the indent for unclosed
+	 * parentheses is zero, line up with the unclosed parentheses.
+	 */
+	if (amount == -1)
+	{
+	    int	    ignore_paren_col = 0;
+	    int	    is_if_for_while = 0;
+
+	    if (curbuf->b_ind_if_for_while)
+	    {
+		/* Look for the outermost opening parenthesis on this line
+		 * and check whether it belongs to an "if", "for" or "while". */
+
+		pos_T	    cursor_save = curwin->w_cursor;
+		pos_T	    outermost;
+		char_u	    *line;
+
+		trypos = &our_paren_pos;
+		do {
+		    outermost = *trypos;
+		    curwin->w_cursor.lnum = outermost.lnum;
+		    curwin->w_cursor.col = outermost.col;
+
+		    trypos = find_match_paren(curbuf->b_ind_maxparen);
+		} while (trypos && trypos->lnum == outermost.lnum);
+
+		curwin->w_cursor = cursor_save;
+
+		line = ml_get(outermost.lnum);
+
+		is_if_for_while =
+		    cin_is_if_for_while_before_offset(line, &outermost.col);
+	    }
+
+	    amount = skip_label(our_paren_pos.lnum, &look);
+	    look = skipwhite(look);
+	    if (*look == '(')
+	    {
+		linenr_T    save_lnum = curwin->w_cursor.lnum;
+		char_u	    *line;
+		int	    look_col;
+
+		/* Ignore a '(' in front of the line that has a match before
+		 * our matching '('. */
+		curwin->w_cursor.lnum = our_paren_pos.lnum;
+		line = ml_get_curline();
+		look_col = (int)(look - line);
+		curwin->w_cursor.col = look_col + 1;
+		if ((trypos = findmatchlimit(NULL, ')', 0,
+						      curbuf->b_ind_maxparen))
+								      != NULL
+			  && trypos->lnum == our_paren_pos.lnum
+			  && trypos->col < our_paren_pos.col)
+		    ignore_paren_col = trypos->col + 1;
+
+		curwin->w_cursor.lnum = save_lnum;
+		look = ml_get(our_paren_pos.lnum) + look_col;
+	    }
+	    if (theline[0] == ')' || (curbuf->b_ind_unclosed == 0
+						      && is_if_for_while == 0)
+		    || (!curbuf->b_ind_unclosed_noignore && *look == '('
+						    && ignore_paren_col == 0))
+	    {
+		/*
+		 * If we're looking at a close paren, line up right there;
+		 * otherwise, line up with the next (non-white) character.
+		 * When b_ind_unclosed_wrapped is set and the matching paren is
+		 * the last nonwhite character of the line, use either the
+		 * indent of the current line or the indentation of the next
+		 * outer paren and add b_ind_unclosed_wrapped (for very long
+		 * lines).
+		 */
+		if (theline[0] != ')')
+		{
+		    cur_amount = MAXCOL;
+		    l = ml_get(our_paren_pos.lnum);
+		    if (curbuf->b_ind_unclosed_wrapped
+				       && cin_ends_in(l, (char_u *)"(", NULL))
+		    {
+			/* look for opening unmatched paren, indent one level
+			 * for each additional level */
+			n = 1;
+			for (col = 0; col < our_paren_pos.col; ++col)
+			{
+			    switch (l[col])
+			    {
+				case '(':
+				case '{': ++n;
+					  break;
+
+				case ')':
+				case '}': if (n > 1)
+					      --n;
+					  break;
+			    }
+			}
+
+			our_paren_pos.col = 0;
+			amount += n * curbuf->b_ind_unclosed_wrapped;
+		    }
+		    else if (curbuf->b_ind_unclosed_whiteok)
+			our_paren_pos.col++;
+		    else
+		    {
+			col = our_paren_pos.col + 1;
+			while (VIM_ISWHITE(l[col]))
+			    col++;
+			if (l[col] != NUL)	/* In case of trailing space */
+			    our_paren_pos.col = col;
+			else
+			    our_paren_pos.col++;
+		    }
+		}
+
+		/*
+		 * Find how indented the paren is, or the character after it
+		 * if we did the above "if".
+		 */
+		if (our_paren_pos.col > 0)
+		{
+		    getvcol(curwin, &our_paren_pos, &col, NULL, NULL);
+		    if (cur_amount > (int)col)
+			cur_amount = col;
+		}
+	    }
+
+	    if (theline[0] == ')' && curbuf->b_ind_matching_paren)
+	    {
+		/* Line up with the start of the matching paren line. */
+	    }
+	    else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)
+		     || (!curbuf->b_ind_unclosed_noignore
+				    && *look == '(' && ignore_paren_col == 0))
+	    {
+		if (cur_amount != MAXCOL)
+		    amount = cur_amount;
+	    }
+	    else
+	    {
+		/* Add b_ind_unclosed2 for each '(' before our matching one,
+		 * but ignore (void) before the line (ignore_paren_col). */
+		col = our_paren_pos.col;
+		while ((int)our_paren_pos.col > ignore_paren_col)
+		{
+		    --our_paren_pos.col;
+		    switch (*ml_get_pos(&our_paren_pos))
+		    {
+			case '(': amount += curbuf->b_ind_unclosed2;
+				  col = our_paren_pos.col;
+				  break;
+			case ')': amount -= curbuf->b_ind_unclosed2;
+				  col = MAXCOL;
+				  break;
+		    }
+		}
+
+		/* Use b_ind_unclosed once, when the first '(' is not inside
+		 * braces */
+		if (col == MAXCOL)
+		    amount += curbuf->b_ind_unclosed;
+		else
+		{
+		    curwin->w_cursor.lnum = our_paren_pos.lnum;
+		    curwin->w_cursor.col = col;
+		    if (find_match_paren_after_brace(curbuf->b_ind_maxparen)
+								      != NULL)
+			amount += curbuf->b_ind_unclosed2;
+		    else
+		    {
+			if (is_if_for_while)
+			    amount += curbuf->b_ind_if_for_while;
+			else
+			    amount += curbuf->b_ind_unclosed;
+		    }
+		}
+		/*
+		 * For a line starting with ')' use the minimum of the two
+		 * positions, to avoid giving it more indent than the previous
+		 * lines:
+		 *  func_long_name(		    if (x
+		 *	arg				    && yy
+		 *	)	  ^ not here	       )    ^ not here
+		 */
+		if (cur_amount < amount)
+		    amount = cur_amount;
+	    }
+	}
+
+	/* add extra indent for a comment */
+	if (cin_iscomment(theline))
+	    amount += curbuf->b_ind_comment;
+      }
+      else
+      {
+	/*
+	 * We are inside braces, there is a { before this line at the position
+	 * stored in tryposBrace.
+	 * Make a copy of tryposBrace, it may point to pos_copy inside
+	 * find_start_brace(), which may be changed somewhere.
+	 */
+	tryposCopy = *tryposBrace;
+	tryposBrace = &tryposCopy;
+	trypos = tryposBrace;
+	ourscope = trypos->lnum;
+	start = ml_get(ourscope);
+
+	/*
+	 * Now figure out how indented the line is in general.
+	 * If the brace was at the start of the line, we use that;
+	 * otherwise, check out the indentation of the line as
+	 * a whole and then add the "imaginary indent" to that.
+	 */
+	look = skipwhite(start);
+	if (*look == '{')
+	{
+	    getvcol(curwin, trypos, &col, NULL, NULL);
+	    amount = col;
+	    if (*start == '{')
+		start_brace = BRACE_IN_COL0;
+	    else
+		start_brace = BRACE_AT_START;
+	}
+	else
+	{
+	    /* That opening brace might have been on a continuation
+	     * line.  if so, find the start of the line. */
+	    curwin->w_cursor.lnum = ourscope;
+
+	    /* Position the cursor over the rightmost paren, so that
+	     * matching it will take us back to the start of the line. */
+	    lnum = ourscope;
+	    if (find_last_paren(start, '(', ')')
+			&& (trypos = find_match_paren(curbuf->b_ind_maxparen))
+								      != NULL)
+		lnum = trypos->lnum;
+
+	    /* It could have been something like
+	     *	   case 1: if (asdf &&
+	     *			ldfd) {
+	     *		    }
+	     */
+	    if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)
+			   && cin_iscase(skipwhite(ml_get_curline()), FALSE))
+		amount = get_indent();
+	    else if (curbuf->b_ind_js)
+		amount = get_indent_lnum(lnum);
+	    else
+		amount = skip_label(lnum, &l);
+
+	    start_brace = BRACE_AT_END;
+	}
+
+	/* For Javascript check if the line starts with "key:". */
+	if (curbuf->b_ind_js)
+	    js_cur_has_key = cin_has_js_key(theline);
+
+	/*
+	 * If we're looking at a closing brace, that's where
+	 * we want to be.  otherwise, add the amount of room
+	 * that an indent is supposed to be.
+	 */
+	if (theline[0] == '}')
+	{
+	    /*
+	     * they may want closing braces to line up with something
+	     * other than the open brace.  indulge them, if so.
+	     */
+	    amount += curbuf->b_ind_close_extra;
+	}
+	else
+	{
+	    /*
+	     * If we're looking at an "else", try to find an "if"
+	     * to match it with.
+	     * If we're looking at a "while", try to find a "do"
+	     * to match it with.
+	     */
+	    lookfor = LOOKFOR_INITIAL;
+	    if (cin_iselse(theline))
+		lookfor = LOOKFOR_IF;
+	    else if (cin_iswhileofdo(theline, cur_curpos.lnum)) /* XXX */
+		lookfor = LOOKFOR_DO;
+	    if (lookfor != LOOKFOR_INITIAL)
+	    {
+		curwin->w_cursor.lnum = cur_curpos.lnum;
+		if (find_match(lookfor, ourscope) == OK)
+		{
+		    amount = get_indent();	/* XXX */
+		    goto theend;
+		}
+	    }
+
+	    /*
+	     * We get here if we are not on an "while-of-do" or "else" (or
+	     * failed to find a matching "if").
+	     * Search backwards for something to line up with.
+	     * First set amount for when we don't find anything.
+	     */
+
+	    /*
+	     * if the '{' is  _really_ at the left margin, use the imaginary
+	     * location of a left-margin brace.  Otherwise, correct the
+	     * location for b_ind_open_extra.
+	     */
+
+	    if (start_brace == BRACE_IN_COL0)	    /* '{' is in column 0 */
+	    {
+		amount = curbuf->b_ind_open_left_imag;
+		lookfor_cpp_namespace = TRUE;
+	    }
+	    else if (start_brace == BRACE_AT_START &&
+		    lookfor_cpp_namespace)	  /* '{' is at start */
+	    {
+
+		lookfor_cpp_namespace = TRUE;
+	    }
+	    else
+	    {
+		if (start_brace == BRACE_AT_END)    /* '{' is at end of line */
+		{
+		    amount += curbuf->b_ind_open_imag;
+
+		    l = skipwhite(ml_get_curline());
+		    if (cin_is_cpp_namespace(l))
+			amount += curbuf->b_ind_cpp_namespace;
+		    else if (cin_is_cpp_extern_c(l))
+			amount += curbuf->b_ind_cpp_extern_c;
+		}
+		else
+		{
+		    /* Compensate for adding b_ind_open_extra later. */
+		    amount -= curbuf->b_ind_open_extra;
+		    if (amount < 0)
+			amount = 0;
+		}
+	    }
+
+	    lookfor_break = FALSE;
+
+	    if (cin_iscase(theline, FALSE))	/* it's a switch() label */
+	    {
+		lookfor = LOOKFOR_CASE;	/* find a previous switch() label */
+		amount += curbuf->b_ind_case;
+	    }
+	    else if (cin_isscopedecl(theline))	/* private:, ... */
+	    {
+		lookfor = LOOKFOR_SCOPEDECL;	/* class decl is this block */
+		amount += curbuf->b_ind_scopedecl;
+	    }
+	    else
+	    {
+		if (curbuf->b_ind_case_break && cin_isbreak(theline))
+		    /* break; ... */
+		    lookfor_break = TRUE;
+
+		lookfor = LOOKFOR_INITIAL;
+		/* b_ind_level from start of block */
+		amount += curbuf->b_ind_level;
+	    }
+	    scope_amount = amount;
+	    whilelevel = 0;
+
+	    /*
+	     * Search backwards.  If we find something we recognize, line up
+	     * with that.
+	     *
+	     * If we're looking at an open brace, indent
+	     * the usual amount relative to the conditional
+	     * that opens the block.
+	     */
+	    curwin->w_cursor = cur_curpos;
+	    for (;;)
+	    {
+		curwin->w_cursor.lnum--;
+		curwin->w_cursor.col = 0;
+
+		/*
+		 * If we went all the way back to the start of our scope, line
+		 * up with it.
+		 */
+		if (curwin->w_cursor.lnum <= ourscope)
+		{
+		    /* We reached end of scope:
+		     * If looking for a enum or structure initialization
+		     * go further back:
+		     * If it is an initializer (enum xxx or xxx =), then
+		     * don't add ind_continuation, otherwise it is a variable
+		     * declaration:
+		     * int x,
+		     *     here; <-- add ind_continuation
+		     */
+		    if (lookfor == LOOKFOR_ENUM_OR_INIT)
+		    {
+			if (curwin->w_cursor.lnum == 0
+				|| curwin->w_cursor.lnum
+					  < ourscope - curbuf->b_ind_maxparen)
+			{
+			    /* nothing found (abuse curbuf->b_ind_maxparen as
+			     * limit) assume terminated line (i.e. a variable
+			     * initialization) */
+			    if (cont_amount > 0)
+				amount = cont_amount;
+			    else if (!curbuf->b_ind_js)
+				amount += ind_continuation;
+			    break;
+			}
+
+			l = ml_get_curline();
+
+			/*
+			 * If we're in a comment or raw string now, skip to
+			 * the start of it.
+			 */
+			trypos = ind_find_start_CORS(NULL);
+			if (trypos != NULL)
+			{
+			    curwin->w_cursor.lnum = trypos->lnum + 1;
+			    curwin->w_cursor.col = 0;
+			    continue;
+			}
+
+			/*
+			 * Skip preprocessor directives and blank lines.
+			 */
+			if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
+								    &amount))
+			    continue;
+
+			if (cin_nocode(l))
+			    continue;
+
+			terminated = cin_isterminated(l, FALSE, TRUE);
+
+			/*
+			 * If we are at top level and the line looks like a
+			 * function declaration, we are done
+			 * (it's a variable declaration).
+			 */
+			if (start_brace != BRACE_IN_COL0
+			     || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
+			{
+			    /* if the line is terminated with another ','
+			     * it is a continued variable initialization.
+			     * don't add extra indent.
+			     * TODO: does not work, if  a function
+			     * declaration is split over multiple lines:
+			     * cin_isfuncdecl returns FALSE then.
+			     */
+			    if (terminated == ',')
+				break;
+
+			    /* if it es a enum declaration or an assignment,
+			     * we are done.
+			     */
+			    if (terminated != ';' && cin_isinit())
+				break;
+
+			    /* nothing useful found */
+			    if (terminated == 0 || terminated == '{')
+				continue;
+			}
+
+			if (terminated != ';')
+			{
+			    /* Skip parens and braces. Position the cursor
+			     * over the rightmost paren, so that matching it
+			     * will take us back to the start of the line.
+			     */					/* XXX */
+			    trypos = NULL;
+			    if (find_last_paren(l, '(', ')'))
+				trypos = find_match_paren(
+						      curbuf->b_ind_maxparen);
+
+			    if (trypos == NULL && find_last_paren(l, '{', '}'))
+				trypos = find_start_brace();
+
+			    if (trypos != NULL)
+			    {
+				curwin->w_cursor.lnum = trypos->lnum + 1;
+				curwin->w_cursor.col = 0;
+				continue;
+			    }
+			}
+
+			/* it's a variable declaration, add indentation
+			 * like in
+			 * int a,
+			 *    b;
+			 */
+			if (cont_amount > 0)
+			    amount = cont_amount;
+			else
+			    amount += ind_continuation;
+		    }
+		    else if (lookfor == LOOKFOR_UNTERM)
+		    {
+			if (cont_amount > 0)
+			    amount = cont_amount;
+			else
+			    amount += ind_continuation;
+		    }
+		    else
+		    {
+			if (lookfor != LOOKFOR_TERM
+					&& lookfor != LOOKFOR_CPP_BASECLASS
+					&& lookfor != LOOKFOR_COMMA)
+			{
+			    amount = scope_amount;
+			    if (theline[0] == '{')
+			    {
+				amount += curbuf->b_ind_open_extra;
+				added_to_amount = curbuf->b_ind_open_extra;
+			    }
+			}
+
+			if (lookfor_cpp_namespace)
+			{
+			    /*
+			     * Looking for C++ namespace, need to look further
+			     * back.
+			     */
+			    if (curwin->w_cursor.lnum == ourscope)
+				continue;
+
+			    if (curwin->w_cursor.lnum == 0
+				    || curwin->w_cursor.lnum
+					      < ourscope - FIND_NAMESPACE_LIM)
+				break;
+
+			    l = ml_get_curline();
+
+			    /* If we're in a comment or raw string now, skip
+			     * to the start of it. */
+			    trypos = ind_find_start_CORS(NULL);
+			    if (trypos != NULL)
+			    {
+				curwin->w_cursor.lnum = trypos->lnum + 1;
+				curwin->w_cursor.col = 0;
+				continue;
+			    }
+
+			    /* Skip preprocessor directives and blank lines. */
+			    if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
+								    &amount))
+				continue;
+
+			    /* Finally the actual check for "namespace". */
+			    if (cin_is_cpp_namespace(l))
+			    {
+				amount += curbuf->b_ind_cpp_namespace
+							    - added_to_amount;
+				break;
+			    }
+			    else if (cin_is_cpp_extern_c(l))
+			    {
+				amount += curbuf->b_ind_cpp_extern_c
+							    - added_to_amount;
+				break;
+			    }
+
+			    if (cin_nocode(l))
+				continue;
+			}
+		    }
+		    break;
+		}
+
+		/*
+		 * If we're in a comment or raw string now, skip to the start
+		 * of it.
+		 */					    /* XXX */
+		if ((trypos = ind_find_start_CORS(&raw_string_start)) != NULL)
+		{
+		    curwin->w_cursor.lnum = trypos->lnum + 1;
+		    curwin->w_cursor.col = 0;
+		    continue;
+		}
+
+		l = ml_get_curline();
+
+		/*
+		 * If this is a switch() label, may line up relative to that.
+		 * If this is a C++ scope declaration, do the same.
+		 */
+		iscase = cin_iscase(l, FALSE);
+		if (iscase || cin_isscopedecl(l))
+		{
+		    /* we are only looking for cpp base class
+		     * declaration/initialization any longer */
+		    if (lookfor == LOOKFOR_CPP_BASECLASS)
+			break;
+
+		    /* When looking for a "do" we are not interested in
+		     * labels. */
+		    if (whilelevel > 0)
+			continue;
+
+		    /*
+		     *	case xx:
+		     *	    c = 99 +	    <- this indent plus continuation
+		     *->	   here;
+		     */
+		    if (lookfor == LOOKFOR_UNTERM
+					   || lookfor == LOOKFOR_ENUM_OR_INIT)
+		    {
+			if (cont_amount > 0)
+			    amount = cont_amount;
+			else
+			    amount += ind_continuation;
+			break;
+		    }
+
+		    /*
+		     *	case xx:	<- line up with this case
+		     *	    x = 333;
+		     *	case yy:
+		     */
+		    if (       (iscase && lookfor == LOOKFOR_CASE)
+			    || (iscase && lookfor_break)
+			    || (!iscase && lookfor == LOOKFOR_SCOPEDECL))
+		    {
+			/*
+			 * Check that this case label is not for another
+			 * switch()
+			 */				    /* XXX */
+			if ((trypos = find_start_brace()) == NULL
+						  || trypos->lnum == ourscope)
+			{
+			    amount = get_indent();	/* XXX */
+			    break;
+			}
+			continue;
+		    }
+
+		    n = get_indent_nolabel(curwin->w_cursor.lnum);  /* XXX */
+
+		    /*
+		     *	 case xx: if (cond)	    <- line up with this if
+		     *		      y = y + 1;
+		     * ->	  s = 99;
+		     *
+		     *	 case xx:
+		     *	     if (cond)		<- line up with this line
+		     *		 y = y + 1;
+		     * ->    s = 99;
+		     */
+		    if (lookfor == LOOKFOR_TERM)
+		    {
+			if (n)
+			    amount = n;
+
+			if (!lookfor_break)
+			    break;
+		    }
+
+		    /*
+		     *	 case xx: x = x + 1;	    <- line up with this x
+		     * ->	  y = y + 1;
+		     *
+		     *	 case xx: if (cond)	    <- line up with this if
+		     * ->	       y = y + 1;
+		     */
+		    if (n)
+		    {
+			amount = n;
+			l = after_label(ml_get_curline());
+			if (l != NULL && cin_is_cinword(l))
+			{
+			    if (theline[0] == '{')
+				amount += curbuf->b_ind_open_extra;
+			    else
+				amount += curbuf->b_ind_level
+						     + curbuf->b_ind_no_brace;
+			}
+			break;
+		    }
+
+		    /*
+		     * Try to get the indent of a statement before the switch
+		     * label.  If nothing is found, line up relative to the
+		     * switch label.
+		     *	    break;		<- may line up with this line
+		     *	 case xx:
+		     * ->   y = 1;
+		     */
+		    scope_amount = get_indent() + (iscase    /* XXX */
+					? curbuf->b_ind_case_code
+					: curbuf->b_ind_scopedecl_code);
+		    lookfor = curbuf->b_ind_case_break
+					      ? LOOKFOR_NOBREAK : LOOKFOR_ANY;
+		    continue;
+		}
+
+		/*
+		 * Looking for a switch() label or C++ scope declaration,
+		 * ignore other lines, skip {}-blocks.
+		 */
+		if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
+		{
+		    if (find_last_paren(l, '{', '}')
+				     && (trypos = find_start_brace()) != NULL)
+		    {
+			curwin->w_cursor.lnum = trypos->lnum + 1;
+			curwin->w_cursor.col = 0;
+		    }
+		    continue;
+		}
+
+		/*
+		 * Ignore jump labels with nothing after them.
+		 */
+		if (!curbuf->b_ind_js && cin_islabel())
+		{
+		    l = after_label(ml_get_curline());
+		    if (l == NULL || cin_nocode(l))
+			continue;
+		}
+
+		/*
+		 * Ignore #defines, #if, etc.
+		 * Ignore comment and empty lines.
+		 * (need to get the line again, cin_islabel() may have
+		 * unlocked it)
+		 */
+		l = ml_get_curline();
+		if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount)
+							     || cin_nocode(l))
+		    continue;
+
+		/*
+		 * Are we at the start of a cpp base class declaration or
+		 * constructor initialization?
+		 */						    /* XXX */
+		n = FALSE;
+		if (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0)
+		{
+		    n = cin_is_cpp_baseclass(&cache_cpp_baseclass);
+		    l = ml_get_curline();
+		}
+		if (n)
+		{
+		    if (lookfor == LOOKFOR_UNTERM)
+		    {
+			if (cont_amount > 0)
+			    amount = cont_amount;
+			else
+			    amount += ind_continuation;
+		    }
+		    else if (theline[0] == '{')
+		    {
+			/* Need to find start of the declaration. */
+			lookfor = LOOKFOR_UNTERM;
+			ind_continuation = 0;
+			continue;
+		    }
+		    else
+								     /* XXX */
+			amount = get_baseclass_amount(
+						cache_cpp_baseclass.lpos.col);
+		    break;
+		}
+		else if (lookfor == LOOKFOR_CPP_BASECLASS)
+		{
+		    /* only look, whether there is a cpp base class
+		     * declaration or initialization before the opening brace.
+		     */
+		    if (cin_isterminated(l, TRUE, FALSE))
+			break;
+		    else
+			continue;
+		}
+
+		/*
+		 * What happens next depends on the line being terminated.
+		 * If terminated with a ',' only consider it terminating if
+		 * there is another unterminated statement behind, eg:
+		 *   123,
+		 *   sizeof
+		 *	  here
+		 * Otherwise check whether it is a enumeration or structure
+		 * initialisation (not indented) or a variable declaration
+		 * (indented).
+		 */
+		terminated = cin_isterminated(l, FALSE, TRUE);
+
+		if (js_cur_has_key)
+		{
+		    js_cur_has_key = 0; /* only check the first line */
+		    if (curbuf->b_ind_js && terminated == ',')
+		    {
+			/* For Javascript we might be inside an object:
+			 *   key: something,  <- align with this
+			 *   key: something
+			 * or:
+			 *   key: something +  <- align with this
+			 *       something,
+			 *   key: something
+			 */
+			lookfor = LOOKFOR_JS_KEY;
+		    }
+		}
+		if (lookfor == LOOKFOR_JS_KEY && cin_has_js_key(l))
+		{
+		    amount = get_indent();
+		    break;
+		}
+		if (lookfor == LOOKFOR_COMMA)
+		{
+		    if (tryposBrace != NULL && tryposBrace->lnum
+						    >= curwin->w_cursor.lnum)
+			break;
+		    if (terminated == ',')
+			/* line below current line is the one that starts a
+			 * (possibly broken) line ending in a comma. */
+			break;
+		    else
+		    {
+			amount = get_indent();
+			if (curwin->w_cursor.lnum - 1 == ourscope)
+			    /* line above is start of the scope, thus current
+			     * line is the one that stars a (possibly broken)
+			     * line ending in a comma. */
+			    break;
+		    }
+		}
+
+		if (terminated == 0 || (lookfor != LOOKFOR_UNTERM
+							&& terminated == ','))
+		{
+		    if (lookfor != LOOKFOR_ENUM_OR_INIT &&
+			    (*skipwhite(l) == '[' || l[STRLEN(l) - 1] == '['))
+			amount += ind_continuation;
+		    /*
+		     * if we're in the middle of a paren thing,
+		     * go back to the line that starts it so
+		     * we can get the right prevailing indent
+		     *	   if ( foo &&
+		     *		    bar )
+		     */
+		    /*
+		     * Position the cursor over the rightmost paren, so that
+		     * matching it will take us back to the start of the line.
+		     * Ignore a match before the start of the block.
+		     */
+		    (void)find_last_paren(l, '(', ')');
+		    trypos = find_match_paren(corr_ind_maxparen(&cur_curpos));
+		    if (trypos != NULL && (trypos->lnum < tryposBrace->lnum
+				|| (trypos->lnum == tryposBrace->lnum
+				    && trypos->col < tryposBrace->col)))
+			trypos = NULL;
+
+		    /*
+		     * If we are looking for ',', we also look for matching
+		     * braces.
+		     */
+		    if (trypos == NULL && terminated == ','
+					      && find_last_paren(l, '{', '}'))
+			trypos = find_start_brace();
+
+		    if (trypos != NULL)
+		    {
+			/*
+			 * Check if we are on a case label now.  This is
+			 * handled above.
+			 *     case xx:  if ( asdf &&
+			 *			asdf)
+			 */
+			curwin->w_cursor = *trypos;
+			l = ml_get_curline();
+			if (cin_iscase(l, FALSE) || cin_isscopedecl(l))
+			{
+			    ++curwin->w_cursor.lnum;
+			    curwin->w_cursor.col = 0;
+			    continue;
+			}
+		    }
+
+		    /*
+		     * Skip over continuation lines to find the one to get the
+		     * indent from
+		     * char *usethis = "bla\
+		     *		 bla",
+		     *      here;
+		     */
+		    if (terminated == ',')
+		    {
+			while (curwin->w_cursor.lnum > 1)
+			{
+			    l = ml_get(curwin->w_cursor.lnum - 1);
+			    if (*l == NUL || l[STRLEN(l) - 1] != '\\')
+				break;
+			    --curwin->w_cursor.lnum;
+			    curwin->w_cursor.col = 0;
+			}
+		    }
+
+		    /*
+		     * Get indent and pointer to text for current line,
+		     * ignoring any jump label.	    XXX
+		     */
+		    if (curbuf->b_ind_js)
+			cur_amount = get_indent();
+		    else
+			cur_amount = skip_label(curwin->w_cursor.lnum, &l);
+		    /*
+		     * If this is just above the line we are indenting, and it
+		     * starts with a '{', line it up with this line.
+		     *		while (not)
+		     * ->	{
+		     *		}
+		     */
+		    if (terminated != ',' && lookfor != LOOKFOR_TERM
+							 && theline[0] == '{')
+		    {
+			amount = cur_amount;
+			/*
+			 * Only add b_ind_open_extra when the current line
+			 * doesn't start with a '{', which must have a match
+			 * in the same line (scope is the same).  Probably:
+			 *	{ 1, 2 },
+			 * ->	{ 3, 4 }
+			 */
+			if (*skipwhite(l) != '{')
+			    amount += curbuf->b_ind_open_extra;
+
+			if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js)
+			{
+			    /* have to look back, whether it is a cpp base
+			     * class declaration or initialization */
+			    lookfor = LOOKFOR_CPP_BASECLASS;
+			    continue;
+			}
+			break;
+		    }
+
+		    /*
+		     * Check if we are after an "if", "while", etc.
+		     * Also allow "   } else".
+		     */
+		    if (cin_is_cinword(l) || cin_iselse(skipwhite(l)))
+		    {
+			/*
+			 * Found an unterminated line after an if (), line up
+			 * with the last one.
+			 *   if (cond)
+			 *	    100 +
+			 * ->		here;
+			 */
+			if (lookfor == LOOKFOR_UNTERM
+					   || lookfor == LOOKFOR_ENUM_OR_INIT)
+			{
+			    if (cont_amount > 0)
+				amount = cont_amount;
+			    else
+				amount += ind_continuation;
+			    break;
+			}
+
+			/*
+			 * If this is just above the line we are indenting, we
+			 * are finished.
+			 *	    while (not)
+			 * ->		here;
+			 * Otherwise this indent can be used when the line
+			 * before this is terminated.
+			 *	yyy;
+			 *	if (stat)
+			 *	    while (not)
+			 *		xxx;
+			 * ->	here;
+			 */
+			amount = cur_amount;
+			if (theline[0] == '{')
+			    amount += curbuf->b_ind_open_extra;
+			if (lookfor != LOOKFOR_TERM)
+			{
+			    amount += curbuf->b_ind_level
+						     + curbuf->b_ind_no_brace;
+			    break;
+			}
+
+			/*
+			 * Special trick: when expecting the while () after a
+			 * do, line up with the while()
+			 *     do
+			 *	    x = 1;
+			 * ->  here
+			 */
+			l = skipwhite(ml_get_curline());
+			if (cin_isdo(l))
+			{
+			    if (whilelevel == 0)
+				break;
+			    --whilelevel;
+			}
+
+			/*
+			 * When searching for a terminated line, don't use the
+			 * one between the "if" and the matching "else".
+			 * Need to use the scope of this "else".  XXX
+			 * If whilelevel != 0 continue looking for a "do {".
+			 */
+			if (cin_iselse(l) && whilelevel == 0)
+			{
+			    /* If we're looking at "} else", let's make sure we
+			     * find the opening brace of the enclosing scope,
+			     * not the one from "if () {". */
+			    if (*l == '}')
+				curwin->w_cursor.col =
+					  (colnr_T)(l - ml_get_curline()) + 1;
+
+			    if ((trypos = find_start_brace()) == NULL
+				       || find_match(LOOKFOR_IF, trypos->lnum)
+								      == FAIL)
+				break;
+			}
+		    }
+
+		    /*
+		     * If we're below an unterminated line that is not an
+		     * "if" or something, we may line up with this line or
+		     * add something for a continuation line, depending on
+		     * the line before this one.
+		     */
+		    else
+		    {
+			/*
+			 * Found two unterminated lines on a row, line up with
+			 * the last one.
+			 *   c = 99 +
+			 *	    100 +
+			 * ->	    here;
+			 */
+			if (lookfor == LOOKFOR_UNTERM)
+			{
+			    /* When line ends in a comma add extra indent */
+			    if (terminated == ',')
+				amount += ind_continuation;
+			    break;
+			}
+
+			if (lookfor == LOOKFOR_ENUM_OR_INIT)
+			{
+			    /* Found two lines ending in ',', lineup with the
+			     * lowest one, but check for cpp base class
+			     * declaration/initialization, if it is an
+			     * opening brace or we are looking just for
+			     * enumerations/initializations. */
+			    if (terminated == ',')
+			    {
+				if (curbuf->b_ind_cpp_baseclass == 0)
+				    break;
+
+				lookfor = LOOKFOR_CPP_BASECLASS;
+				continue;
+			    }
+
+			    /* Ignore unterminated lines in between, but
+			     * reduce indent. */
+			    if (amount > cur_amount)
+				amount = cur_amount;
+			}
+			else
+			{
+			    /*
+			     * Found first unterminated line on a row, may
+			     * line up with this line, remember its indent
+			     *	    100 +
+			     * ->	    here;
+			     */
+			    l = ml_get_curline();
+			    amount = cur_amount;
+
+			    n = (int)STRLEN(l);
+			    if (terminated == ',' && (*skipwhite(l) == ']'
+					|| (n >=2 && l[n - 2] == ']')))
+				break;
+
+			    /*
+			     * If previous line ends in ',', check whether we
+			     * are in an initialization or enum
+			     * struct xxx =
+			     * {
+			     *      sizeof a,
+			     *      124 };
+			     * or a normal possible continuation line.
+			     * but only, of no other statement has been found
+			     * yet.
+			     */
+			    if (lookfor == LOOKFOR_INITIAL && terminated == ',')
+			    {
+				if (curbuf->b_ind_js)
+				{
+				    /* Search for a line ending in a comma
+				     * and line up with the line below it
+				     * (could be the current line).
+				     * some = [
+				     *     1,     <- line up here
+				     *     2,
+				     * some = [
+				     *     3 +    <- line up here
+				     *       4 *
+				     *        5,
+				     *     6,
+				     */
+				    if (cin_iscomment(skipwhite(l)))
+					break;
+				    lookfor = LOOKFOR_COMMA;
+				    trypos = find_match_char('[',
+						      curbuf->b_ind_maxparen);
+				    if (trypos != NULL)
+				    {
+					if (trypos->lnum
+						 == curwin->w_cursor.lnum - 1)
+					{
+					    /* Current line is first inside
+					     * [], line up with it. */
+					    break;
+					}
+					ourscope = trypos->lnum;
+				    }
+				}
+				else
+				{
+				    lookfor = LOOKFOR_ENUM_OR_INIT;
+				    cont_amount = cin_first_id_amount();
+				}
+			    }
+			    else
+			    {
+				if (lookfor == LOOKFOR_INITIAL
+					&& *l != NUL
+					&& l[STRLEN(l) - 1] == '\\')
+								/* XXX */
+				    cont_amount = cin_get_equal_amount(
+						       curwin->w_cursor.lnum);
+				if (lookfor != LOOKFOR_TERM
+						&& lookfor != LOOKFOR_JS_KEY
+						&& lookfor != LOOKFOR_COMMA
+						&& raw_string_start != curwin->w_cursor.lnum)
+				    lookfor = LOOKFOR_UNTERM;
+			    }
+			}
+		    }
+		}
+
+		/*
+		 * Check if we are after a while (cond);
+		 * If so: Ignore until the matching "do".
+		 */
+		else if (cin_iswhileofdo_end(terminated)) /* XXX */
+		{
+		    /*
+		     * Found an unterminated line after a while ();, line up
+		     * with the last one.
+		     *	    while (cond);
+		     *	    100 +		<- line up with this one
+		     * ->	    here;
+		     */
+		    if (lookfor == LOOKFOR_UNTERM
+					   || lookfor == LOOKFOR_ENUM_OR_INIT)
+		    {
+			if (cont_amount > 0)
+			    amount = cont_amount;
+			else
+			    amount += ind_continuation;
+			break;
+		    }
+
+		    if (whilelevel == 0)
+		    {
+			lookfor = LOOKFOR_TERM;
+			amount = get_indent();	    /* XXX */
+			if (theline[0] == '{')
+			    amount += curbuf->b_ind_open_extra;
+		    }
+		    ++whilelevel;
+		}
+
+		/*
+		 * We are after a "normal" statement.
+		 * If we had another statement we can stop now and use the
+		 * indent of that other statement.
+		 * Otherwise the indent of the current statement may be used,
+		 * search backwards for the next "normal" statement.
+		 */
+		else
+		{
+		    /*
+		     * Skip single break line, if before a switch label. It
+		     * may be lined up with the case label.
+		     */
+		    if (lookfor == LOOKFOR_NOBREAK
+				  && cin_isbreak(skipwhite(ml_get_curline())))
+		    {
+			lookfor = LOOKFOR_ANY;
+			continue;
+		    }
+
+		    /*
+		     * Handle "do {" line.
+		     */
+		    if (whilelevel > 0)
+		    {
+			l = cin_skipcomment(ml_get_curline());
+			if (cin_isdo(l))
+			{
+			    amount = get_indent();	/* XXX */
+			    --whilelevel;
+			    continue;
+			}
+		    }
+
+		    /*
+		     * Found a terminated line above an unterminated line. Add
+		     * the amount for a continuation line.
+		     *	 x = 1;
+		     *	 y = foo +
+		     * ->	here;
+		     * or
+		     *	 int x = 1;
+		     *	 int foo,
+		     * ->	here;
+		     */
+		    if (lookfor == LOOKFOR_UNTERM
+					   || lookfor == LOOKFOR_ENUM_OR_INIT)
+		    {
+			if (cont_amount > 0)
+			    amount = cont_amount;
+			else
+			    amount += ind_continuation;
+			break;
+		    }
+
+		    /*
+		     * Found a terminated line above a terminated line or "if"
+		     * etc. line. Use the amount of the line below us.
+		     *	 x = 1;				x = 1;
+		     *	 if (asdf)		    y = 2;
+		     *	     while (asdf)	  ->here;
+		     *		here;
+		     * ->foo;
+		     */
+		    if (lookfor == LOOKFOR_TERM)
+		    {
+			if (!lookfor_break && whilelevel == 0)
+			    break;
+		    }
+
+		    /*
+		     * First line above the one we're indenting is terminated.
+		     * To know what needs to be done look further backward for
+		     * a terminated line.
+		     */
+		    else
+		    {
+			/*
+			 * position the cursor over the rightmost paren, so
+			 * that matching it will take us back to the start of
+			 * the line.  Helps for:
+			 *     func(asdr,
+			 *	      asdfasdf);
+			 *     here;
+			 */
+term_again:
+			l = ml_get_curline();
+			if (find_last_paren(l, '(', ')')
+				&& (trypos = find_match_paren(
+					   curbuf->b_ind_maxparen)) != NULL)
+			{
+			    /*
+			     * Check if we are on a case label now.  This is
+			     * handled above.
+			     *	   case xx:  if ( asdf &&
+			     *			    asdf)
+			     */
+			    curwin->w_cursor = *trypos;
+			    l = ml_get_curline();
+			    if (cin_iscase(l, FALSE) || cin_isscopedecl(l))
+			    {
+				++curwin->w_cursor.lnum;
+				curwin->w_cursor.col = 0;
+				continue;
+			    }
+			}
+
+			/* When aligning with the case statement, don't align
+			 * with a statement after it.
+			 *  case 1: {   <-- don't use this { position
+			 *	stat;
+			 *  }
+			 *  case 2:
+			 *	stat;
+			 * }
+			 */
+			iscase = (curbuf->b_ind_keep_case_label
+						     && cin_iscase(l, FALSE));
+
+			/*
+			 * Get indent and pointer to text for current line,
+			 * ignoring any jump label.
+			 */
+			amount = skip_label(curwin->w_cursor.lnum, &l);
+
+			if (theline[0] == '{')
+			    amount += curbuf->b_ind_open_extra;
+			/* See remark above: "Only add b_ind_open_extra.." */
+			l = skipwhite(l);
+			if (*l == '{')
+			    amount -= curbuf->b_ind_open_extra;
+			lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;
+
+			/*
+			 * When a terminated line starts with "else" skip to
+			 * the matching "if":
+			 *       else 3;
+			 *	     indent this;
+			 * Need to use the scope of this "else".  XXX
+			 * If whilelevel != 0 continue looking for a "do {".
+			 */
+			if (lookfor == LOOKFOR_TERM
+				&& *l != '}'
+				&& cin_iselse(l)
+				&& whilelevel == 0)
+			{
+			    if ((trypos = find_start_brace()) == NULL
+				       || find_match(LOOKFOR_IF, trypos->lnum)
+								      == FAIL)
+				break;
+			    continue;
+			}
+
+			/*
+			 * If we're at the end of a block, skip to the start of
+			 * that block.
+			 */
+			l = ml_get_curline();
+			if (find_last_paren(l, '{', '}') /* XXX */
+				     && (trypos = find_start_brace()) != NULL)
+			{
+			    curwin->w_cursor = *trypos;
+			    /* if not "else {" check for terminated again */
+			    /* but skip block for "} else {" */
+			    l = cin_skipcomment(ml_get_curline());
+			    if (*l == '}' || !cin_iselse(l))
+				goto term_again;
+			    ++curwin->w_cursor.lnum;
+			    curwin->w_cursor.col = 0;
+			}
+		    }
+		}
+	    }
+	}
+      }
+
+      /* add extra indent for a comment */
+      if (cin_iscomment(theline))
+	  amount += curbuf->b_ind_comment;
+
+      /* subtract extra left-shift for jump labels */
+      if (curbuf->b_ind_jump_label > 0 && original_line_islabel)
+	  amount -= curbuf->b_ind_jump_label;
+
+      goto theend;
+    }
+
+    /*
+     * ok -- we're not inside any sort of structure at all!
+     *
+     * This means we're at the top level, and everything should
+     * basically just match where the previous line is, except
+     * for the lines immediately following a function declaration,
+     * which are K&R-style parameters and need to be indented.
+     *
+     * if our line starts with an open brace, forget about any
+     * prevailing indent and make sure it looks like the start
+     * of a function
+     */
+
+    if (theline[0] == '{')
+    {
+	amount = curbuf->b_ind_first_open;
+	goto theend;
+    }
+
+    /*
+     * If the NEXT line is a function declaration, the current
+     * line needs to be indented as a function type spec.
+     * Don't do this if the current line looks like a comment or if the
+     * current line is terminated, ie. ends in ';', or if the current line
+     * contains { or }: "void f() {\n if (1)"
+     */
+    if (cur_curpos.lnum < curbuf->b_ml.ml_line_count
+	    && !cin_nocode(theline)
+	    && vim_strchr(theline, '{') == NULL
+	    && vim_strchr(theline, '}') == NULL
+	    && !cin_ends_in(theline, (char_u *)":", NULL)
+	    && !cin_ends_in(theline, (char_u *)",", NULL)
+	    && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,
+			      cur_curpos.lnum + 1)
+	    && !cin_isterminated(theline, FALSE, TRUE))
+    {
+	amount = curbuf->b_ind_func_type;
+	goto theend;
+    }
+
+    /* search backwards until we find something we recognize */
+    amount = 0;
+    curwin->w_cursor = cur_curpos;
+    while (curwin->w_cursor.lnum > 1)
+    {
+	curwin->w_cursor.lnum--;
+	curwin->w_cursor.col = 0;
+
+	l = ml_get_curline();
+
+	/*
+	 * If we're in a comment or raw string now, skip to the start
+	 * of it.
+	 */						/* XXX */
+	if ((trypos = ind_find_start_CORS(NULL)) != NULL)
+	{
+	    curwin->w_cursor.lnum = trypos->lnum + 1;
+	    curwin->w_cursor.col = 0;
+	    continue;
+	}
+
+	/*
+	 * Are we at the start of a cpp base class declaration or
+	 * constructor initialization?
+	 */						    /* XXX */
+	n = FALSE;
+	if (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{')
+	{
+	    n = cin_is_cpp_baseclass(&cache_cpp_baseclass);
+	    l = ml_get_curline();
+	}
+	if (n)
+	{
+							     /* XXX */
+	    amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);
+	    break;
+	}
+
+	/*
+	 * Skip preprocessor directives and blank lines.
+	 */
+	if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount))
+	    continue;
+
+	if (cin_nocode(l))
+	    continue;
+
+	/*
+	 * If the previous line ends in ',', use one level of
+	 * indentation:
+	 * int foo,
+	 *     bar;
+	 * do this before checking for '}' in case of eg.
+	 * enum foobar
+	 * {
+	 *   ...
+	 * } foo,
+	 *   bar;
+	 */
+	n = 0;
+	if (cin_ends_in(l, (char_u *)",", NULL)
+		     || (*l != NUL && (n = l[STRLEN(l) - 1]) == '\\'))
+	{
+	    /* take us back to opening paren */
+	    if (find_last_paren(l, '(', ')')
+		    && (trypos = find_match_paren(
+				     curbuf->b_ind_maxparen)) != NULL)
+		curwin->w_cursor = *trypos;
+
+	    /* For a line ending in ',' that is a continuation line go
+	     * back to the first line with a backslash:
+	     * char *foo = "bla\
+	     *		 bla",
+	     *      here;
+	     */
+	    while (n == 0 && curwin->w_cursor.lnum > 1)
+	    {
+		l = ml_get(curwin->w_cursor.lnum - 1);
+		if (*l == NUL || l[STRLEN(l) - 1] != '\\')
+		    break;
+		--curwin->w_cursor.lnum;
+		curwin->w_cursor.col = 0;
+	    }
+
+	    amount = get_indent();	    /* XXX */
+
+	    if (amount == 0)
+		amount = cin_first_id_amount();
+	    if (amount == 0)
+		amount = ind_continuation;
+	    break;
+	}
+
+	/*
+	 * If the line looks like a function declaration, and we're
+	 * not in a comment, put it the left margin.
+	 */
+	if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))  /* XXX */
+	    break;
+	l = ml_get_curline();
+
+	/*
+	 * Finding the closing '}' of a previous function.  Put
+	 * current line at the left margin.  For when 'cino' has "fs".
+	 */
+	if (*skipwhite(l) == '}')
+	    break;
+
+	/*			    (matching {)
+	 * If the previous line ends on '};' (maybe followed by
+	 * comments) align at column 0.  For example:
+	 * char *string_array[] = { "foo",
+	 *     / * x * / "b};ar" }; / * foobar * /
+	 */
+	if (cin_ends_in(l, (char_u *)"};", NULL))
+	    break;
+
+	/*
+	 * If the previous line ends on '[' we are probably in an
+	 * array constant:
+	 * something = [
+	 *     234,  <- extra indent
+	 */
+	if (cin_ends_in(l, (char_u *)"[", NULL))
+	{
+	    amount = get_indent() + ind_continuation;
+	    break;
+	}
+
+	/*
+	 * Find a line only has a semicolon that belongs to a previous
+	 * line ending in '}', e.g. before an #endif.  Don't increase
+	 * indent then.
+	 */
+	if (*(look = skipwhite(l)) == ';' && cin_nocode(look + 1))
+	{
+	    pos_T curpos_save = curwin->w_cursor;
+
+	    while (curwin->w_cursor.lnum > 1)
+	    {
+		look = ml_get(--curwin->w_cursor.lnum);
+		if (!(cin_nocode(look) || cin_ispreproc_cont(
+				      &look, &curwin->w_cursor.lnum, &amount)))
+		    break;
+	    }
+	    if (curwin->w_cursor.lnum > 0
+			    && cin_ends_in(look, (char_u *)"}", NULL))
+		break;
+
+	    curwin->w_cursor = curpos_save;
+	}
+
+	/*
+	 * If the PREVIOUS line is a function declaration, the current
+	 * line (and the ones that follow) needs to be indented as
+	 * parameters.
+	 */
+	if (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
+	{
+	    amount = curbuf->b_ind_param;
+	    break;
+	}
+
+	/*
+	 * If the previous line ends in ';' and the line before the
+	 * previous line ends in ',' or '\', ident to column zero:
+	 * int foo,
+	 *     bar;
+	 * indent_to_0 here;
+	 */
+	if (cin_ends_in(l, (char_u *)";", NULL))
+	{
+	    l = ml_get(curwin->w_cursor.lnum - 1);
+	    if (cin_ends_in(l, (char_u *)",", NULL)
+		    || (*l != NUL && l[STRLEN(l) - 1] == '\\'))
+		break;
+	    l = ml_get_curline();
+	}
+
+	/*
+	 * Doesn't look like anything interesting -- so just
+	 * use the indent of this line.
+	 *
+	 * Position the cursor over the rightmost paren, so that
+	 * matching it will take us back to the start of the line.
+	 */
+	find_last_paren(l, '(', ')');
+
+	if ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
+	    curwin->w_cursor = *trypos;
+	amount = get_indent();	    /* XXX */
+	break;
+    }
+
+    /* add extra indent for a comment */
+    if (cin_iscomment(theline))
+	amount += curbuf->b_ind_comment;
+
+    /* add extra indent if the previous line ended in a backslash:
+     *	      "asdfasdf\
+     *		  here";
+     *	    char *foo = "asdf\
+     *			 here";
+     */
+    if (cur_curpos.lnum > 1)
+    {
+	l = ml_get(cur_curpos.lnum - 1);
+	if (*l != NUL && l[STRLEN(l) - 1] == '\\')
+	{
+	    cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);
+	    if (cur_amount > 0)
+		amount = cur_amount;
+	    else if (cur_amount == 0)
+		amount += ind_continuation;
+	}
+    }
+
+theend:
+    if (amount < 0)
+	amount = 0;
+
+laterend:
+    /* put the cursor back where it belongs */
+    curwin->w_cursor = cur_curpos;
+
+    vim_free(linecopy);
+
+    return amount;
+}
+
+    static int
+find_match(int lookfor, linenr_T ourscope)
+{
+    char_u	*look;
+    pos_T	*theirscope;
+    char_u	*mightbeif;
+    int		elselevel;
+    int		whilelevel;
+
+    if (lookfor == LOOKFOR_IF)
+    {
+	elselevel = 1;
+	whilelevel = 0;
+    }
+    else
+    {
+	elselevel = 0;
+	whilelevel = 1;
+    }
+
+    curwin->w_cursor.col = 0;
+
+    while (curwin->w_cursor.lnum > ourscope + 1)
+    {
+	curwin->w_cursor.lnum--;
+	curwin->w_cursor.col = 0;
+
+	look = cin_skipcomment(ml_get_curline());
+	if (cin_iselse(look)
+		|| cin_isif(look)
+		|| cin_isdo(look)			    /* XXX */
+		|| cin_iswhileofdo(look, curwin->w_cursor.lnum))
+	{
+	    /*
+	     * if we've gone outside the braces entirely,
+	     * we must be out of scope...
+	     */
+	    theirscope = find_start_brace();  /* XXX */
+	    if (theirscope == NULL)
+		break;
+
+	    /*
+	     * and if the brace enclosing this is further
+	     * back than the one enclosing the else, we're
+	     * out of luck too.
+	     */
+	    if (theirscope->lnum < ourscope)
+		break;
+
+	    /*
+	     * and if they're enclosed in a *deeper* brace,
+	     * then we can ignore it because it's in a
+	     * different scope...
+	     */
+	    if (theirscope->lnum > ourscope)
+		continue;
+
+	    /*
+	     * if it was an "else" (that's not an "else if")
+	     * then we need to go back to another if, so
+	     * increment elselevel
+	     */
+	    look = cin_skipcomment(ml_get_curline());
+	    if (cin_iselse(look))
+	    {
+		mightbeif = cin_skipcomment(look + 4);
+		if (!cin_isif(mightbeif))
+		    ++elselevel;
+		continue;
+	    }
+
+	    /*
+	     * if it was a "while" then we need to go back to
+	     * another "do", so increment whilelevel.  XXX
+	     */
+	    if (cin_iswhileofdo(look, curwin->w_cursor.lnum))
+	    {
+		++whilelevel;
+		continue;
+	    }
+
+	    /* If it's an "if" decrement elselevel */
+	    look = cin_skipcomment(ml_get_curline());
+	    if (cin_isif(look))
+	    {
+		elselevel--;
+		/*
+		 * When looking for an "if" ignore "while"s that
+		 * get in the way.
+		 */
+		if (elselevel == 0 && lookfor == LOOKFOR_IF)
+		    whilelevel = 0;
+	    }
+
+	    /* If it's a "do" decrement whilelevel */
+	    if (cin_isdo(look))
+		whilelevel--;
+
+	    /*
+	     * if we've used up all the elses, then
+	     * this must be the if that we want!
+	     * match the indent level of that if.
+	     */
+	    if (elselevel <= 0 && whilelevel <= 0)
+	    {
+		return OK;
+	    }
+	}
+    }
+    return FAIL;
+}
+
+# if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Get indent level from 'indentexpr'.
+ */
+    int
+get_expr_indent(void)
+{
+    int		indent = -1;
+    char_u	*inde_copy;
+    pos_T	save_pos;
+    colnr_T	save_curswant;
+    int		save_set_curswant;
+    int		save_State;
+    int		use_sandbox = was_set_insecurely((char_u *)"indentexpr",
+								   OPT_LOCAL);
+
+    /* Save and restore cursor position and curswant, in case it was changed
+     * via :normal commands */
+    save_pos = curwin->w_cursor;
+    save_curswant = curwin->w_curswant;
+    save_set_curswant = curwin->w_set_curswant;
+    set_vim_var_nr(VV_LNUM, curwin->w_cursor.lnum);
+    if (use_sandbox)
+	++sandbox;
+    ++textlock;
+
+    /* Need to make a copy, the 'indentexpr' option could be changed while
+     * evaluating it. */
+    inde_copy = vim_strsave(curbuf->b_p_inde);
+    if (inde_copy != NULL)
+    {
+	indent = (int)eval_to_number(inde_copy);
+	vim_free(inde_copy);
+    }
+
+    if (use_sandbox)
+	--sandbox;
+    --textlock;
+
+    /* Restore the cursor position so that 'indentexpr' doesn't need to.
+     * Pretend to be in Insert mode, allow cursor past end of line for "o"
+     * command. */
+    save_State = State;
+    State = INSERT;
+    curwin->w_cursor = save_pos;
+    curwin->w_curswant = save_curswant;
+    curwin->w_set_curswant = save_set_curswant;
+    check_cursor();
+    State = save_State;
+
+    /* If there is an error, just keep the current indent. */
+    if (indent < 0)
+	indent = get_indent();
+
+    return indent;
+}
+# endif
+
+#endif /* FEAT_CINDENT */
+
+#if defined(FEAT_LISP) || defined(PROTO)
+
+static int lisp_match(char_u *p);
+
+    static int
+lisp_match(char_u *p)
+{
+    char_u	buf[LSIZE];
+    int		len;
+    char_u	*word = *curbuf->b_p_lw != NUL ? curbuf->b_p_lw : p_lispwords;
+
+    while (*word != NUL)
+    {
+	(void)copy_option_part(&word, buf, LSIZE, ",");
+	len = (int)STRLEN(buf);
+	if (STRNCMP(buf, p, len) == 0 && p[len] == ' ')
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * When 'p' is present in 'cpoptions, a Vi compatible method is used.
+ * The incompatible newer method is quite a bit better at indenting
+ * code in lisp-like languages than the traditional one; it's still
+ * mostly heuristics however -- Dirk van Deun, dirk@rave.org
+ *
+ * TODO:
+ * Findmatch() should be adapted for lisp, also to make showmatch
+ * work correctly: now (v5.3) it seems all C/C++ oriented:
+ * - it does not recognize the #\( and #\) notations as character literals
+ * - it doesn't know about comments starting with a semicolon
+ * - it incorrectly interprets '(' as a character literal
+ * All this messes up get_lisp_indent in some rare cases.
+ * Update from Sergey Khorev:
+ * I tried to fix the first two issues.
+ */
+    int
+get_lisp_indent(void)
+{
+    pos_T	*pos, realpos, paren;
+    int		amount;
+    char_u	*that;
+    colnr_T	col;
+    colnr_T	firsttry;
+    int		parencount, quotecount;
+    int		vi_lisp;
+
+    /* Set vi_lisp to use the vi-compatible method */
+    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);
+
+    realpos = curwin->w_cursor;
+    curwin->w_cursor.col = 0;
+
+    if ((pos = findmatch(NULL, '(')) == NULL)
+	pos = findmatch(NULL, '[');
+    else
+    {
+	paren = *pos;
+	pos = findmatch(NULL, '[');
+	if (pos == NULL || LT_POSP(pos, &paren))
+	    pos = &paren;
+    }
+    if (pos != NULL)
+    {
+	/* Extra trick: Take the indent of the first previous non-white
+	 * line that is at the same () level. */
+	amount = -1;
+	parencount = 0;
+
+	while (--curwin->w_cursor.lnum >= pos->lnum)
+	{
+	    if (linewhite(curwin->w_cursor.lnum))
+		continue;
+	    for (that = ml_get_curline(); *that != NUL; ++that)
+	    {
+		if (*that == ';')
+		{
+		    while (*(that + 1) != NUL)
+			++that;
+		    continue;
+		}
+		if (*that == '\\')
+		{
+		    if (*(that + 1) != NUL)
+			++that;
+		    continue;
+		}
+		if (*that == '"' && *(that + 1) != NUL)
+		{
+		    while (*++that && *that != '"')
+		    {
+			/* skipping escaped characters in the string */
+			if (*that == '\\')
+			{
+			    if (*++that == NUL)
+				break;
+			    if (that[1] == NUL)
+			    {
+				++that;
+				break;
+			    }
+			}
+		    }
+		}
+		if (*that == '(' || *that == '[')
+		    ++parencount;
+		else if (*that == ')' || *that == ']')
+		    --parencount;
+	    }
+	    if (parencount == 0)
+	    {
+		amount = get_indent();
+		break;
+	    }
+	}
+
+	if (amount == -1)
+	{
+	    curwin->w_cursor.lnum = pos->lnum;
+	    curwin->w_cursor.col = pos->col;
+	    col = pos->col;
+
+	    that = ml_get_curline();
+
+	    if (vi_lisp && get_indent() == 0)
+		amount = 2;
+	    else
+	    {
+		char_u *line = that;
+
+		amount = 0;
+		while (*that && col)
+		{
+		    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);
+		    col--;
+		}
+
+		/*
+		 * Some keywords require "body" indenting rules (the
+		 * non-standard-lisp ones are Scheme special forms):
+		 *
+		 * (let ((a 1))    instead    (let ((a 1))
+		 *   (...))	      of	   (...))
+		 */
+
+		if (!vi_lisp && (*that == '(' || *that == '[')
+						      && lisp_match(that + 1))
+		    amount += 2;
+		else
+		{
+		    that++;
+		    amount++;
+		    firsttry = amount;
+
+		    while (VIM_ISWHITE(*that))
+		    {
+			amount += lbr_chartabsize(line, that, (colnr_T)amount);
+			++that;
+		    }
+
+		    if (*that && *that != ';') /* not a comment line */
+		    {
+			/* test *that != '(' to accommodate first let/do
+			 * argument if it is more than one line */
+			if (!vi_lisp && *that != '(' && *that != '[')
+			    firsttry++;
+
+			parencount = 0;
+			quotecount = 0;
+
+			if (vi_lisp
+				|| (*that != '"'
+				    && *that != '\''
+				    && *that != '#'
+				    && (*that < '0' || *that > '9')))
+			{
+			    while (*that
+				    && (!VIM_ISWHITE(*that)
+					|| quotecount
+					|| parencount)
+				    && (!((*that == '(' || *that == '[')
+					    && !quotecount
+					    && !parencount
+					    && vi_lisp)))
+			    {
+				if (*that == '"')
+				    quotecount = !quotecount;
+				if ((*that == '(' || *that == '[')
+							       && !quotecount)
+				    ++parencount;
+				if ((*that == ')' || *that == ']')
+							       && !quotecount)
+				    --parencount;
+				if (*that == '\\' && *(that+1) != NUL)
+				    amount += lbr_chartabsize_adv(
+						line, &that, (colnr_T)amount);
+				amount += lbr_chartabsize_adv(
+						line, &that, (colnr_T)amount);
+			    }
+			}
+			while (VIM_ISWHITE(*that))
+			{
+			    amount += lbr_chartabsize(
+						 line, that, (colnr_T)amount);
+			    that++;
+			}
+			if (!*that || *that == ';')
+			    amount = firsttry;
+		    }
+		}
+	    }
+	}
+    }
+    else
+	amount = 0;	/* no matching '(' or '[' found, use zero indent */
+
+    curwin->w_cursor = realpos;
+
+    return amount;
+}
+#endif /* FEAT_LISP */
+
+    void
+prepare_to_exit(void)
+{
+#if defined(SIGHUP) && defined(SIG_IGN)
+    /* Ignore SIGHUP, because a dropped connection causes a read error, which
+     * makes Vim exit and then handling SIGHUP causes various reentrance
+     * problems. */
+    signal(SIGHUP, SIG_IGN);
+#endif
+
+#ifdef FEAT_GUI
+    if (gui.in_use)
+    {
+	gui.dying = TRUE;
+	out_trash();	/* trash any pending output */
+    }
+    else
+#endif
+    {
+	windgoto((int)Rows - 1, 0);
+
+	/*
+	 * Switch terminal mode back now, so messages end up on the "normal"
+	 * screen (if there are two screens).
+	 */
+	settmode(TMODE_COOK);
+	stoptermcap();
+	out_flush();
+    }
+}
+
+/*
+ * Preserve files and exit.
+ * When called IObuff must contain a message.
+ * NOTE: This may be called from deathtrap() in a signal handler, avoid unsafe
+ * functions, such as allocating memory.
+ */
+    void
+preserve_exit(void)
+{
+    buf_T	*buf;
+
+    prepare_to_exit();
+
+    /* Setting this will prevent free() calls.  That avoids calling free()
+     * recursively when free() was invoked with a bad pointer. */
+    really_exiting = TRUE;
+
+    out_str(IObuff);
+    screen_start();		    /* don't know where cursor is now */
+    out_flush();
+
+    ml_close_notmod();		    /* close all not-modified buffers */
+
+    FOR_ALL_BUFFERS(buf)
+    {
+	if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)
+	{
+	    OUT_STR("Vim: preserving files...\n");
+	    screen_start();	    /* don't know where cursor is now */
+	    out_flush();
+	    ml_sync_all(FALSE, FALSE);	/* preserve all swap files */
+	    break;
+	}
+    }
+
+    ml_close_all(FALSE);	    /* close all memfiles, without deleting */
+
+    OUT_STR("Vim: Finished.\n");
+
+    getout(1);
+}
+
+/*
+ * return TRUE if "fname" exists.
+ */
+    int
+vim_fexists(char_u *fname)
+{
+    stat_T st;
+
+    if (mch_stat((char *)fname, &st))
+	return FALSE;
+    return TRUE;
+}
+
+/*
+ * Check for CTRL-C pressed, but only once in a while.
+ * Should be used instead of ui_breakcheck() for functions that check for
+ * each line in the file.  Calling ui_breakcheck() each time takes too much
+ * time, because it can be a system call.
+ */
+
+#ifndef BREAKCHECK_SKIP
+# ifdef FEAT_GUI		    /* assume the GUI only runs on fast computers */
+#  define BREAKCHECK_SKIP 200
+# else
+#  define BREAKCHECK_SKIP 32
+# endif
+#endif
+
+static int	breakcheck_count = 0;
+
+    void
+line_breakcheck(void)
+{
+    if (++breakcheck_count >= BREAKCHECK_SKIP)
+    {
+	breakcheck_count = 0;
+	ui_breakcheck();
+    }
+}
+
+/*
+ * Like line_breakcheck() but check 10 times less often.
+ */
+    void
+fast_breakcheck(void)
+{
+    if (++breakcheck_count >= BREAKCHECK_SKIP * 10)
+    {
+	breakcheck_count = 0;
+	ui_breakcheck();
+    }
+}
+
+/*
+ * Invoke expand_wildcards() for one pattern.
+ * Expand items like "%:h" before the expansion.
+ * Returns OK or FAIL.
+ */
+    int
+expand_wildcards_eval(
+    char_u	 **pat,		/* pointer to input pattern */
+    int		  *num_file,	/* resulting number of files */
+    char_u	***file,	/* array of resulting files */
+    int		   flags)	/* EW_DIR, etc. */
+{
+    int		ret = FAIL;
+    char_u	*eval_pat = NULL;
+    char_u	*exp_pat = *pat;
+    char_u      *ignored_msg;
+    int		usedlen;
+
+    if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<')
+    {
+	++emsg_off;
+	eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,
+						    NULL, &ignored_msg, NULL);
+	--emsg_off;
+	if (eval_pat != NULL)
+	    exp_pat = concat_str(eval_pat, exp_pat + usedlen);
+    }
+
+    if (exp_pat != NULL)
+	ret = expand_wildcards(1, &exp_pat, num_file, file, flags);
+
+    if (eval_pat != NULL)
+    {
+	vim_free(exp_pat);
+	vim_free(eval_pat);
+    }
+
+    return ret;
+}
+
+/*
+ * Expand wildcards.  Calls gen_expand_wildcards() and removes files matching
+ * 'wildignore'.
+ * Returns OK or FAIL.  When FAIL then "num_files" won't be set.
+ */
+    int
+expand_wildcards(
+    int		   num_pat,	/* number of input patterns */
+    char_u	 **pat,		/* array of input patterns */
+    int		  *num_files,	/* resulting number of files */
+    char_u	***files,	/* array of resulting files */
+    int		   flags)	/* EW_DIR, etc. */
+{
+    int		retval;
+    int		i, j;
+    char_u	*p;
+    int		non_suf_match;	/* number without matching suffix */
+
+    retval = gen_expand_wildcards(num_pat, pat, num_files, files, flags);
+
+    /* When keeping all matches, return here */
+    if ((flags & EW_KEEPALL) || retval == FAIL)
+	return retval;
+
+#ifdef FEAT_WILDIGN
+    /*
+     * Remove names that match 'wildignore'.
+     */
+    if (*p_wig)
+    {
+	char_u	*ffname;
+
+	/* check all files in (*files)[] */
+	for (i = 0; i < *num_files; ++i)
+	{
+	    ffname = FullName_save((*files)[i], FALSE);
+	    if (ffname == NULL)		/* out of memory */
+		break;
+# ifdef VMS
+	    vms_remove_version(ffname);
+# endif
+	    if (match_file_list(p_wig, (*files)[i], ffname))
+	    {
+		/* remove this matching file from the list */
+		vim_free((*files)[i]);
+		for (j = i; j + 1 < *num_files; ++j)
+		    (*files)[j] = (*files)[j + 1];
+		--*num_files;
+		--i;
+	    }
+	    vim_free(ffname);
+	}
+
+	/* If the number of matches is now zero, we fail. */
+	if (*num_files == 0)
+	{
+	    VIM_CLEAR(*files);
+	    return FAIL;
+	}
+    }
+#endif
+
+    /*
+     * Move the names where 'suffixes' match to the end.
+     */
+    if (*num_files > 1)
+    {
+	non_suf_match = 0;
+	for (i = 0; i < *num_files; ++i)
+	{
+	    if (!match_suffix((*files)[i]))
+	    {
+		/*
+		 * Move the name without matching suffix to the front
+		 * of the list.
+		 */
+		p = (*files)[i];
+		for (j = i; j > non_suf_match; --j)
+		    (*files)[j] = (*files)[j - 1];
+		(*files)[non_suf_match++] = p;
+	    }
+	}
+    }
+
+    return retval;
+}
+
+/*
+ * Return TRUE if "fname" matches with an entry in 'suffixes'.
+ */
+    int
+match_suffix(char_u *fname)
+{
+    int		fnamelen, setsuflen;
+    char_u	*setsuf;
+#define MAXSUFLEN 30	    /* maximum length of a file suffix */
+    char_u	suf_buf[MAXSUFLEN];
+
+    fnamelen = (int)STRLEN(fname);
+    setsuflen = 0;
+    for (setsuf = p_su; *setsuf; )
+    {
+	setsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, ".,");
+	if (setsuflen == 0)
+	{
+	    char_u *tail = gettail(fname);
+
+	    /* empty entry: match name without a '.' */
+	    if (vim_strchr(tail, '.') == NULL)
+	    {
+		setsuflen = 1;
+		break;
+	    }
+	}
+	else
+	{
+	    if (fnamelen >= setsuflen
+		    && fnamencmp(suf_buf, fname + fnamelen - setsuflen,
+						  (size_t)setsuflen) == 0)
+		break;
+	    setsuflen = 0;
+	}
+    }
+    return (setsuflen != 0);
+}
+
+#if !defined(NO_EXPANDPATH) || defined(PROTO)
+
+# ifdef VIM_BACKTICK
+static int vim_backtick(char_u *p);
+static int expand_backtick(garray_T *gap, char_u *pat, int flags);
+# endif
+
+# if defined(WIN3264)
+/*
+ * File name expansion code for MS-DOS, Win16 and Win32.  It's here because
+ * it's shared between these systems.
+ */
+# if defined(PROTO)
+#  define _cdecl
+# else
+#  ifdef __BORLANDC__
+#   define _cdecl _RTLENTRYF
+#  endif
+# endif
+
+/*
+ * comparison function for qsort in dos_expandpath()
+ */
+    static int _cdecl
+pstrcmp(const void *a, const void *b)
+{
+    return (pathcmp(*(char **)a, *(char **)b, -1));
+}
+
+/*
+ * Recursively expand one path component into all matching files and/or
+ * directories.  Adds matches to "gap".  Handles "*", "?", "[a-z]", "**", etc.
+ * Return the number of matches found.
+ * "path" has backslashes before chars that are not to be expanded, starting
+ * at "path[wildoff]".
+ * Return the number of matches found.
+ * NOTE: much of this is identical to unix_expandpath(), keep in sync!
+ */
+    static int
+dos_expandpath(
+    garray_T	*gap,
+    char_u	*path,
+    int		wildoff,
+    int		flags,		/* EW_* flags */
+    int		didstar)	/* expanded "**" once already */
+{
+    char_u	*buf;
+    char_u	*path_end;
+    char_u	*p, *s, *e;
+    int		start_len = gap->ga_len;
+    char_u	*pat;
+    regmatch_T	regmatch;
+    int		starts_with_dot;
+    int		matches;
+    int		len;
+    int		starstar = FALSE;
+    static int	stardepth = 0;	    /* depth for "**" expansion */
+    WIN32_FIND_DATA	fb;
+    HANDLE		hFind = (HANDLE)0;
+# ifdef FEAT_MBYTE
+    WIN32_FIND_DATAW    wfb;
+    WCHAR		*wn = NULL;	/* UCS-2 name, NULL when not used. */
+# endif
+    char_u		*matchname;
+    int			ok;
+
+    /* Expanding "**" may take a long time, check for CTRL-C. */
+    if (stardepth > 0)
+    {
+	ui_breakcheck();
+	if (got_int)
+	    return 0;
+    }
+
+    /* Make room for file name.  When doing encoding conversion the actual
+     * length may be quite a bit longer, thus use the maximum possible length. */
+    buf = alloc((int)MAXPATHL);
+    if (buf == NULL)
+	return 0;
+
+    /*
+     * Find the first part in the path name that contains a wildcard or a ~1.
+     * Copy it into buf, including the preceding characters.
+     */
+    p = buf;
+    s = buf;
+    e = NULL;
+    path_end = path;
+    while (*path_end != NUL)
+    {
+	/* May ignore a wildcard that has a backslash before it; it will
+	 * be removed by rem_backslash() or file_pat_to_reg_pat() below. */
+	if (path_end >= path + wildoff && rem_backslash(path_end))
+	    *p++ = *path_end++;
+	else if (*path_end == '\\' || *path_end == ':' || *path_end == '/')
+	{
+	    if (e != NULL)
+		break;
+	    s = p + 1;
+	}
+	else if (path_end >= path + wildoff
+			 && vim_strchr((char_u *)"*?[~", *path_end) != NULL)
+	    e = p;
+# ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    len = (*mb_ptr2len)(path_end);
+	    STRNCPY(p, path_end, len);
+	    p += len;
+	    path_end += len;
+	}
+	else
+# endif
+	    *p++ = *path_end++;
+    }
+    e = p;
+    *e = NUL;
+
+    /* now we have one wildcard component between s and e */
+    /* Remove backslashes between "wildoff" and the start of the wildcard
+     * component. */
+    for (p = buf + wildoff; p < s; ++p)
+	if (rem_backslash(p))
+	{
+	    STRMOVE(p, p + 1);
+	    --e;
+	    --s;
+	}
+
+    /* Check for "**" between "s" and "e". */
+    for (p = s; p < e; ++p)
+	if (p[0] == '*' && p[1] == '*')
+	    starstar = TRUE;
+
+    starts_with_dot = *s == '.';
+    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);
+    if (pat == NULL)
+    {
+	vim_free(buf);
+	return 0;
+    }
+
+    /* compile the regexp into a program */
+    if (flags & (EW_NOERROR | EW_NOTWILD))
+	++emsg_silent;
+    regmatch.rm_ic = TRUE;		/* Always ignore case */
+    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);
+    if (flags & (EW_NOERROR | EW_NOTWILD))
+	--emsg_silent;
+    vim_free(pat);
+
+    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)
+    {
+	vim_free(buf);
+	return 0;
+    }
+
+    /* remember the pattern or file name being looked for */
+    matchname = vim_strsave(s);
+
+    /* If "**" is by itself, this is the first time we encounter it and more
+     * is following then find matches without any directory. */
+    if (!didstar && stardepth < 100 && starstar && e - s == 2
+							  && *path_end == '/')
+    {
+	STRCPY(s, path_end + 1);
+	++stardepth;
+	(void)dos_expandpath(gap, buf, (int)(s - buf), flags, TRUE);
+	--stardepth;
+    }
+
+    /* Scan all files in the directory with "dir/ *.*" */
+    STRCPY(s, "*.*");
+# ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	/* The active codepage differs from 'encoding'.  Attempt using the
+	 * wide function.  If it fails because it is not implemented fall back
+	 * to the non-wide version (for Windows 98) */
+	wn = enc_to_utf16(buf, NULL);
+	if (wn != NULL)
+	{
+	    hFind = FindFirstFileW(wn, &wfb);
+	    if (hFind == INVALID_HANDLE_VALUE
+			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
+		VIM_CLEAR(wn);
+	}
+    }
+
+    if (wn == NULL)
+# endif
+	hFind = FindFirstFile((LPCSTR)buf, &fb);
+    ok = (hFind != INVALID_HANDLE_VALUE);
+
+    while (ok)
+    {
+# ifdef FEAT_MBYTE
+	if (wn != NULL)
+	    p = utf16_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
+	else
+# endif
+	    p = (char_u *)fb.cFileName;
+	/* Ignore entries starting with a dot, unless when asked for.  Accept
+	 * all entries found with "matchname". */
+	if ((p[0] != '.' || starts_with_dot
+			 || ((flags & EW_DODOT)
+			     && p[1] != NUL && (p[1] != '.' || p[2] != NUL)))
+		&& (matchname == NULL
+		  || (regmatch.regprog != NULL
+				     && vim_regexec(&regmatch, p, (colnr_T)0))
+		  || ((flags & EW_NOTWILD)
+		     && fnamencmp(path + (s - buf), p, e - s) == 0)))
+	{
+	    STRCPY(s, p);
+	    len = (int)STRLEN(buf);
+
+	    if (starstar && stardepth < 100)
+	    {
+		/* For "**" in the pattern first go deeper in the tree to
+		 * find matches. */
+		STRCPY(buf + len, "/**");
+		STRCPY(buf + len + 3, path_end);
+		++stardepth;
+		(void)dos_expandpath(gap, buf, len + 1, flags, TRUE);
+		--stardepth;
+	    }
+
+	    STRCPY(buf + len, path_end);
+	    if (mch_has_exp_wildcard(path_end))
+	    {
+		/* need to expand another component of the path */
+		/* remove backslashes for the remaining components only */
+		(void)dos_expandpath(gap, buf, len + 1, flags, FALSE);
+	    }
+	    else
+	    {
+		/* no more wildcards, check if there is a match */
+		/* remove backslashes for the remaining components only */
+		if (*path_end != 0)
+		    backslash_halve(buf + len + 1);
+		if (mch_getperm(buf) >= 0)	/* add existing file */
+		    addfile(gap, buf, flags);
+	    }
+	}
+
+# ifdef FEAT_MBYTE
+	if (wn != NULL)
+	{
+	    vim_free(p);
+	    ok = FindNextFileW(hFind, &wfb);
+	}
+	else
+# endif
+	    ok = FindNextFile(hFind, &fb);
+
+	/* If no more matches and no match was used, try expanding the name
+	 * itself.  Finds the long name of a short filename. */
+	if (!ok && matchname != NULL && gap->ga_len == start_len)
+	{
+	    STRCPY(s, matchname);
+	    FindClose(hFind);
+# ifdef FEAT_MBYTE
+	    if (wn != NULL)
+	    {
+		vim_free(wn);
+		wn = enc_to_utf16(buf, NULL);
+		if (wn != NULL)
+		    hFind = FindFirstFileW(wn, &wfb);
+	    }
+	    if (wn == NULL)
+# endif
+		hFind = FindFirstFile((LPCSTR)buf, &fb);
+	    ok = (hFind != INVALID_HANDLE_VALUE);
+	    VIM_CLEAR(matchname);
+	}
+    }
+
+    FindClose(hFind);
+# ifdef FEAT_MBYTE
+    vim_free(wn);
+# endif
+    vim_free(buf);
+    vim_regfree(regmatch.regprog);
+    vim_free(matchname);
+
+    matches = gap->ga_len - start_len;
+    if (matches > 0)
+	qsort(((char_u **)gap->ga_data) + start_len, (size_t)matches,
+						   sizeof(char_u *), pstrcmp);
+    return matches;
+}
+
+    int
+mch_expandpath(
+    garray_T	*gap,
+    char_u	*path,
+    int		flags)		/* EW_* flags */
+{
+    return dos_expandpath(gap, path, 0, flags, FALSE);
+}
+# endif /* WIN3264 */
+
+#if (defined(UNIX) && !defined(VMS)) || defined(USE_UNIXFILENAME) \
+	|| defined(PROTO)
+/*
+ * Unix style wildcard expansion code.
+ * It's here because it's used both for Unix and Mac.
+ */
+static int	pstrcmp(const void *, const void *);
+
+    static int
+pstrcmp(const void *a, const void *b)
+{
+    return (pathcmp(*(char **)a, *(char **)b, -1));
+}
+
+/*
+ * Recursively expand one path component into all matching files and/or
+ * directories.  Adds matches to "gap".  Handles "*", "?", "[a-z]", "**", etc.
+ * "path" has backslashes before chars that are not to be expanded, starting
+ * at "path + wildoff".
+ * Return the number of matches found.
+ * NOTE: much of this is identical to dos_expandpath(), keep in sync!
+ */
+    int
+unix_expandpath(
+    garray_T	*gap,
+    char_u	*path,
+    int		wildoff,
+    int		flags,		/* EW_* flags */
+    int		didstar)	/* expanded "**" once already */
+{
+    char_u	*buf;
+    char_u	*path_end;
+    char_u	*p, *s, *e;
+    int		start_len = gap->ga_len;
+    char_u	*pat;
+    regmatch_T	regmatch;
+    int		starts_with_dot;
+    int		matches;
+    int		len;
+    int		starstar = FALSE;
+    static int	stardepth = 0;	    /* depth for "**" expansion */
+
+    DIR		*dirp;
+    struct dirent *dp;
+
+    /* Expanding "**" may take a long time, check for CTRL-C. */
+    if (stardepth > 0)
+    {
+	ui_breakcheck();
+	if (got_int)
+	    return 0;
+    }
+
+    /* make room for file name */
+    buf = alloc((int)STRLEN(path) + BASENAMELEN + 5);
+    if (buf == NULL)
+	return 0;
+
+    /*
+     * Find the first part in the path name that contains a wildcard.
+     * When EW_ICASE is set every letter is considered to be a wildcard.
+     * Copy it into "buf", including the preceding characters.
+     */
+    p = buf;
+    s = buf;
+    e = NULL;
+    path_end = path;
+    while (*path_end != NUL)
+    {
+	/* May ignore a wildcard that has a backslash before it; it will
+	 * be removed by rem_backslash() or file_pat_to_reg_pat() below. */
+	if (path_end >= path + wildoff && rem_backslash(path_end))
+	    *p++ = *path_end++;
+	else if (*path_end == '/')
+	{
+	    if (e != NULL)
+		break;
+	    s = p + 1;
+	}
+	else if (path_end >= path + wildoff
+			 && (vim_strchr((char_u *)"*?[{~$", *path_end) != NULL
+			     || (!p_fic && (flags & EW_ICASE)
+					     && isalpha(PTR2CHAR(path_end)))))
+	    e = p;
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    len = (*mb_ptr2len)(path_end);
+	    STRNCPY(p, path_end, len);
+	    p += len;
+	    path_end += len;
+	}
+	else
+#endif
+	    *p++ = *path_end++;
+    }
+    e = p;
+    *e = NUL;
+
+    /* Now we have one wildcard component between "s" and "e". */
+    /* Remove backslashes between "wildoff" and the start of the wildcard
+     * component. */
+    for (p = buf + wildoff; p < s; ++p)
+	if (rem_backslash(p))
+	{
+	    STRMOVE(p, p + 1);
+	    --e;
+	    --s;
+	}
+
+    /* Check for "**" between "s" and "e". */
+    for (p = s; p < e; ++p)
+	if (p[0] == '*' && p[1] == '*')
+	    starstar = TRUE;
+
+    /* convert the file pattern to a regexp pattern */
+    starts_with_dot = *s == '.';
+    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);
+    if (pat == NULL)
+    {
+	vim_free(buf);
+	return 0;
+    }
+
+    /* compile the regexp into a program */
+    if (flags & EW_ICASE)
+	regmatch.rm_ic = TRUE;		/* 'wildignorecase' set */
+    else
+	regmatch.rm_ic = p_fic;	/* ignore case when 'fileignorecase' is set */
+    if (flags & (EW_NOERROR | EW_NOTWILD))
+	++emsg_silent;
+    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);
+    if (flags & (EW_NOERROR | EW_NOTWILD))
+	--emsg_silent;
+    vim_free(pat);
+
+    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)
+    {
+	vim_free(buf);
+	return 0;
+    }
+
+    /* If "**" is by itself, this is the first time we encounter it and more
+     * is following then find matches without any directory. */
+    if (!didstar && stardepth < 100 && starstar && e - s == 2
+							  && *path_end == '/')
+    {
+	STRCPY(s, path_end + 1);
+	++stardepth;
+	(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);
+	--stardepth;
+    }
+
+    /* open the directory for scanning */
+    *s = NUL;
+    dirp = opendir(*buf == NUL ? "." : (char *)buf);
+
+    /* Find all matching entries */
+    if (dirp != NULL)
+    {
+	for (;;)
+	{
+	    dp = readdir(dirp);
+	    if (dp == NULL)
+		break;
+	    if ((dp->d_name[0] != '.' || starts_with_dot
+			|| ((flags & EW_DODOT)
+			    && dp->d_name[1] != NUL
+			    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))
+		 && ((regmatch.regprog != NULL && vim_regexec(&regmatch,
+					     (char_u *)dp->d_name, (colnr_T)0))
+		   || ((flags & EW_NOTWILD)
+		     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))
+	    {
+		STRCPY(s, dp->d_name);
+		len = STRLEN(buf);
+
+		if (starstar && stardepth < 100)
+		{
+		    /* For "**" in the pattern first go deeper in the tree to
+		     * find matches. */
+		    STRCPY(buf + len, "/**");
+		    STRCPY(buf + len + 3, path_end);
+		    ++stardepth;
+		    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);
+		    --stardepth;
+		}
+
+		STRCPY(buf + len, path_end);
+		if (mch_has_exp_wildcard(path_end)) /* handle more wildcards */
+		{
+		    /* need to expand another component of the path */
+		    /* remove backslashes for the remaining components only */
+		    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);
+		}
+		else
+		{
+		    stat_T  sb;
+
+		    /* no more wildcards, check if there is a match */
+		    /* remove backslashes for the remaining components only */
+		    if (*path_end != NUL)
+			backslash_halve(buf + len + 1);
+		    /* add existing file or symbolic link */
+		    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0
+						      : mch_getperm(buf) >= 0)
+		    {
+#ifdef MACOS_CONVERT
+			size_t precomp_len = STRLEN(buf)+1;
+			char_u *precomp_buf =
+			    mac_precompose_path(buf, precomp_len, &precomp_len);
+
+			if (precomp_buf)
+			{
+			    mch_memmove(buf, precomp_buf, precomp_len);
+			    vim_free(precomp_buf);
+			}
+#endif
+			addfile(gap, buf, flags);
+		    }
+		}
+	    }
+	}
+
+	closedir(dirp);
+    }
+
+    vim_free(buf);
+    vim_regfree(regmatch.regprog);
+
+    matches = gap->ga_len - start_len;
+    if (matches > 0)
+	qsort(((char_u **)gap->ga_data) + start_len, matches,
+						   sizeof(char_u *), pstrcmp);
+    return matches;
+}
+#endif
+
+#if defined(FEAT_SEARCHPATH)
+static int find_previous_pathsep(char_u *path, char_u **psep);
+static int is_unique(char_u *maybe_unique, garray_T *gap, int i);
+static void expand_path_option(char_u *curdir, garray_T	*gap);
+static char_u *get_path_cutoff(char_u *fname, garray_T *gap);
+static void uniquefy_paths(garray_T *gap, char_u *pattern);
+static int expand_in_path(garray_T *gap, char_u	*pattern, int flags);
+
+/*
+ * Moves "*psep" back to the previous path separator in "path".
+ * Returns FAIL is "*psep" ends up at the beginning of "path".
+ */
+    static int
+find_previous_pathsep(char_u *path, char_u **psep)
+{
+    /* skip the current separator */
+    if (*psep > path && vim_ispathsep(**psep))
+	--*psep;
+
+    /* find the previous separator */
+    while (*psep > path)
+    {
+	if (vim_ispathsep(**psep))
+	    return OK;
+	MB_PTR_BACK(path, *psep);
+    }
+
+    return FAIL;
+}
+
+/*
+ * Returns TRUE if "maybe_unique" is unique wrt other_paths in "gap".
+ * "maybe_unique" is the end portion of "((char_u **)gap->ga_data)[i]".
+ */
+    static int
+is_unique(char_u *maybe_unique, garray_T *gap, int i)
+{
+    int	    j;
+    int	    candidate_len;
+    int	    other_path_len;
+    char_u  **other_paths = (char_u **)gap->ga_data;
+    char_u  *rival;
+
+    for (j = 0; j < gap->ga_len; j++)
+    {
+	if (j == i)
+	    continue;  /* don't compare it with itself */
+
+	candidate_len = (int)STRLEN(maybe_unique);
+	other_path_len = (int)STRLEN(other_paths[j]);
+	if (other_path_len < candidate_len)
+	    continue;  /* it's different when it's shorter */
+
+	rival = other_paths[j] + other_path_len - candidate_len;
+	if (fnamecmp(maybe_unique, rival) == 0
+		&& (rival == other_paths[j] || vim_ispathsep(*(rival - 1))))
+	    return FALSE;  /* match */
+    }
+
+    return TRUE;  /* no match found */
+}
+
+/*
+ * Split the 'path' option into an array of strings in garray_T.  Relative
+ * paths are expanded to their equivalent fullpath.  This includes the "."
+ * (relative to current buffer directory) and empty path (relative to current
+ * directory) notations.
+ *
+ * TODO: handle upward search (;) and path limiter (**N) notations by
+ * expanding each into their equivalent path(s).
+ */
+    static void
+expand_path_option(char_u *curdir, garray_T *gap)
+{
+    char_u	*path_option = *curbuf->b_p_path == NUL
+						  ? p_path : curbuf->b_p_path;
+    char_u	*buf;
+    char_u	*p;
+    int		len;
+
+    if ((buf = alloc((int)MAXPATHL)) == NULL)
+	return;
+
+    while (*path_option != NUL)
+    {
+	copy_option_part(&path_option, buf, MAXPATHL, " ,");
+
+	if (buf[0] == '.' && (buf[1] == NUL || vim_ispathsep(buf[1])))
+	{
+	    /* Relative to current buffer:
+	     * "/path/file" + "." -> "/path/"
+	     * "/path/file"  + "./subdir" -> "/path/subdir" */
+	    if (curbuf->b_ffname == NULL)
+		continue;
+	    p = gettail(curbuf->b_ffname);
+	    len = (int)(p - curbuf->b_ffname);
+	    if (len + (int)STRLEN(buf) >= MAXPATHL)
+		continue;
+	    if (buf[1] == NUL)
+		buf[len] = NUL;
+	    else
+		STRMOVE(buf + len, buf + 2);
+	    mch_memmove(buf, curbuf->b_ffname, len);
+	    simplify_filename(buf);
+	}
+	else if (buf[0] == NUL)
+	    /* relative to current directory */
+	    STRCPY(buf, curdir);
+	else if (path_with_url(buf))
+	    /* URL can't be used here */
+	    continue;
+	else if (!mch_isFullName(buf))
+	{
+	    /* Expand relative path to their full path equivalent */
+	    len = (int)STRLEN(curdir);
+	    if (len + (int)STRLEN(buf) + 3 > MAXPATHL)
+		continue;
+	    STRMOVE(buf + len + 1, buf);
+	    STRCPY(buf, curdir);
+	    buf[len] = PATHSEP;
+	    simplify_filename(buf);
+	}
+
+	if (ga_grow(gap, 1) == FAIL)
+	    break;
+
+# if defined(MSWIN)
+	/* Avoid the path ending in a backslash, it fails when a comma is
+	 * appended. */
+	len = (int)STRLEN(buf);
+	if (buf[len - 1] == '\\')
+	    buf[len - 1] = '/';
+# endif
+
+	p = vim_strsave(buf);
+	if (p == NULL)
+	    break;
+	((char_u **)gap->ga_data)[gap->ga_len++] = p;
+    }
+
+    vim_free(buf);
+}
+
+/*
+ * Returns a pointer to the file or directory name in "fname" that matches the
+ * longest path in "ga"p, or NULL if there is no match. For example:
+ *
+ *    path: /foo/bar/baz
+ *   fname: /foo/bar/baz/quux.txt
+ * returns:		 ^this
+ */
+    static char_u *
+get_path_cutoff(char_u *fname, garray_T *gap)
+{
+    int	    i;
+    int	    maxlen = 0;
+    char_u  **path_part = (char_u **)gap->ga_data;
+    char_u  *cutoff = NULL;
+
+    for (i = 0; i < gap->ga_len; i++)
+    {
+	int j = 0;
+
+	while ((fname[j] == path_part[i][j]
+# if defined(MSWIN)
+		|| (vim_ispathsep(fname[j]) && vim_ispathsep(path_part[i][j]))
+#endif
+			     ) && fname[j] != NUL && path_part[i][j] != NUL)
+	    j++;
+	if (j > maxlen)
+	{
+	    maxlen = j;
+	    cutoff = &fname[j];
+	}
+    }
+
+    /* skip to the file or directory name */
+    if (cutoff != NULL)
+	while (vim_ispathsep(*cutoff))
+	    MB_PTR_ADV(cutoff);
+
+    return cutoff;
+}
+
+/*
+ * Sorts, removes duplicates and modifies all the fullpath names in "gap" so
+ * that they are unique with respect to each other while conserving the part
+ * that matches the pattern. Beware, this is at least O(n^2) wrt "gap->ga_len".
+ */
+    static void
+uniquefy_paths(garray_T *gap, char_u *pattern)
+{
+    int		i;
+    int		len;
+    char_u	**fnames = (char_u **)gap->ga_data;
+    int		sort_again = FALSE;
+    char_u	*pat;
+    char_u      *file_pattern;
+    char_u	*curdir;
+    regmatch_T	regmatch;
+    garray_T	path_ga;
+    char_u	**in_curdir = NULL;
+    char_u	*short_name;
+
+    remove_duplicates(gap);
+    ga_init2(&path_ga, (int)sizeof(char_u *), 1);
+
+    /*
+     * We need to prepend a '*' at the beginning of file_pattern so that the
+     * regex matches anywhere in the path. FIXME: is this valid for all
+     * possible patterns?
+     */
+    len = (int)STRLEN(pattern);
+    file_pattern = alloc(len + 2);
+    if (file_pattern == NULL)
+	return;
+    file_pattern[0] = '*';
+    file_pattern[1] = NUL;
+    STRCAT(file_pattern, pattern);
+    pat = file_pat_to_reg_pat(file_pattern, NULL, NULL, TRUE);
+    vim_free(file_pattern);
+    if (pat == NULL)
+	return;
+
+    regmatch.rm_ic = TRUE;		/* always ignore case */
+    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);
+    vim_free(pat);
+    if (regmatch.regprog == NULL)
+	return;
+
+    if ((curdir = alloc((int)(MAXPATHL))) == NULL)
+	goto theend;
+    mch_dirname(curdir, MAXPATHL);
+    expand_path_option(curdir, &path_ga);
+
+    in_curdir = (char_u **)alloc_clear(gap->ga_len * sizeof(char_u *));
+    if (in_curdir == NULL)
+	goto theend;
+
+    for (i = 0; i < gap->ga_len && !got_int; i++)
+    {
+	char_u	    *path = fnames[i];
+	int	    is_in_curdir;
+	char_u	    *dir_end = gettail_dir(path);
+	char_u	    *pathsep_p;
+	char_u	    *path_cutoff;
+
+	len = (int)STRLEN(path);
+	is_in_curdir = fnamencmp(curdir, path, dir_end - path) == 0
+					     && curdir[dir_end - path] == NUL;
+	if (is_in_curdir)
+	    in_curdir[i] = vim_strsave(path);
+
+	/* Shorten the filename while maintaining its uniqueness */
+	path_cutoff = get_path_cutoff(path, &path_ga);
+
+	/* Don't assume all files can be reached without path when search
+	 * pattern starts with star star slash, so only remove path_cutoff
+	 * when possible. */
+	if (pattern[0] == '*' && pattern[1] == '*'
+		&& vim_ispathsep_nocolon(pattern[2])
+		&& path_cutoff != NULL
+		&& vim_regexec(&regmatch, path_cutoff, (colnr_T)0)
+		&& is_unique(path_cutoff, gap, i))
+	{
+	    sort_again = TRUE;
+	    mch_memmove(path, path_cutoff, STRLEN(path_cutoff) + 1);
+	}
+	else
+	{
+	    /* Here all files can be reached without path, so get shortest
+	     * unique path.  We start at the end of the path. */
+	    pathsep_p = path + len - 1;
+
+	    while (find_previous_pathsep(path, &pathsep_p))
+		if (vim_regexec(&regmatch, pathsep_p + 1, (colnr_T)0)
+			&& is_unique(pathsep_p + 1, gap, i)
+			&& path_cutoff != NULL && pathsep_p + 1 >= path_cutoff)
+		{
+		    sort_again = TRUE;
+		    mch_memmove(path, pathsep_p + 1, STRLEN(pathsep_p));
+		    break;
+		}
+	}
+
+	if (mch_isFullName(path))
+	{
+	    /*
+	     * Last resort: shorten relative to curdir if possible.
+	     * 'possible' means:
+	     * 1. It is under the current directory.
+	     * 2. The result is actually shorter than the original.
+	     *
+	     *	    Before		  curdir	After
+	     *	    /foo/bar/file.txt	  /foo/bar	./file.txt
+	     *	    c:\foo\bar\file.txt   c:\foo\bar	.\file.txt
+	     *	    /file.txt		  /		/file.txt
+	     *	    c:\file.txt		  c:\		.\file.txt
+	     */
+	    short_name = shorten_fname(path, curdir);
+	    if (short_name != NULL && short_name > path + 1
+#if defined(MSWIN)
+		    /* On windows,
+		     *	    shorten_fname("c:\a\a.txt", "c:\a\b")
+		     * returns "\a\a.txt", which is not really the short
+		     * name, hence: */
+		    && !vim_ispathsep(*short_name)
+#endif
+		)
+	    {
+		STRCPY(path, ".");
+		add_pathsep(path);
+		STRMOVE(path + STRLEN(path), short_name);
+	    }
+	}
+	ui_breakcheck();
+    }
+
+    /* Shorten filenames in /in/current/directory/{filename} */
+    for (i = 0; i < gap->ga_len && !got_int; i++)
+    {
+	char_u *rel_path;
+	char_u *path = in_curdir[i];
+
+	if (path == NULL)
+	    continue;
+
+	/* If the {filename} is not unique, change it to ./{filename}.
+	 * Else reduce it to {filename} */
+	short_name = shorten_fname(path, curdir);
+	if (short_name == NULL)
+	    short_name = path;
+	if (is_unique(short_name, gap, i))
+	{
+	    STRCPY(fnames[i], short_name);
+	    continue;
+	}
+
+	rel_path = alloc((int)(STRLEN(short_name) + STRLEN(PATHSEPSTR) + 2));
+	if (rel_path == NULL)
+	    goto theend;
+	STRCPY(rel_path, ".");
+	add_pathsep(rel_path);
+	STRCAT(rel_path, short_name);
+
+	vim_free(fnames[i]);
+	fnames[i] = rel_path;
+	sort_again = TRUE;
+	ui_breakcheck();
+    }
+
+theend:
+    vim_free(curdir);
+    if (in_curdir != NULL)
+    {
+	for (i = 0; i < gap->ga_len; i++)
+	    vim_free(in_curdir[i]);
+	vim_free(in_curdir);
+    }
+    ga_clear_strings(&path_ga);
+    vim_regfree(regmatch.regprog);
+
+    if (sort_again)
+	remove_duplicates(gap);
+}
+
+/*
+ * Calls globpath() with 'path' values for the given pattern and stores the
+ * result in "gap".
+ * Returns the total number of matches.
+ */
+    static int
+expand_in_path(
+    garray_T	*gap,
+    char_u	*pattern,
+    int		flags)		/* EW_* flags */
+{
+    char_u	*curdir;
+    garray_T	path_ga;
+    char_u	*paths = NULL;
+    int		glob_flags = 0;
+
+    if ((curdir = alloc((unsigned)MAXPATHL)) == NULL)
+	return 0;
+    mch_dirname(curdir, MAXPATHL);
+
+    ga_init2(&path_ga, (int)sizeof(char_u *), 1);
+    expand_path_option(curdir, &path_ga);
+    vim_free(curdir);
+    if (path_ga.ga_len == 0)
+	return 0;
+
+    paths = ga_concat_strings(&path_ga, ",");
+    ga_clear_strings(&path_ga);
+    if (paths == NULL)
+	return 0;
+
+    if (flags & EW_ICASE)
+	glob_flags |= WILD_ICASE;
+    if (flags & EW_ADDSLASH)
+	glob_flags |= WILD_ADD_SLASH;
+    globpath(paths, pattern, gap, glob_flags);
+    vim_free(paths);
+
+    return gap->ga_len;
+}
+#endif
+
+#if defined(FEAT_SEARCHPATH) || defined(FEAT_CMDL_COMPL) || defined(PROTO)
+/*
+ * Sort "gap" and remove duplicate entries.  "gap" is expected to contain a
+ * list of file names in allocated memory.
+ */
+    void
+remove_duplicates(garray_T *gap)
+{
+    int	    i;
+    int	    j;
+    char_u  **fnames = (char_u **)gap->ga_data;
+
+    sort_strings(fnames, gap->ga_len);
+    for (i = gap->ga_len - 1; i > 0; --i)
+	if (fnamecmp(fnames[i - 1], fnames[i]) == 0)
+	{
+	    vim_free(fnames[i]);
+	    for (j = i + 1; j < gap->ga_len; ++j)
+		fnames[j - 1] = fnames[j];
+	    --gap->ga_len;
+	}
+}
+#endif
+
+static int has_env_var(char_u *p);
+
+/*
+ * Return TRUE if "p" contains what looks like an environment variable.
+ * Allowing for escaping.
+ */
+    static int
+has_env_var(char_u *p)
+{
+    for ( ; *p; MB_PTR_ADV(p))
+    {
+	if (*p == '\\' && p[1] != NUL)
+	    ++p;
+	else if (vim_strchr((char_u *)
+#if defined(MSWIN)
+				    "$%"
+#else
+				    "$"
+#endif
+					, *p) != NULL)
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+#ifdef SPECIAL_WILDCHAR
+static int has_special_wildchar(char_u *p);
+
+/*
+ * Return TRUE if "p" contains a special wildcard character, one that Vim
+ * cannot expand, requires using a shell.
+ */
+    static int
+has_special_wildchar(char_u *p)
+{
+    for ( ; *p; MB_PTR_ADV(p))
+    {
+	/* Allow for escaping. */
+	if (*p == '\\' && p[1] != NUL)
+	    ++p;
+	else if (vim_strchr((char_u *)SPECIAL_WILDCHAR, *p) != NULL)
+	    return TRUE;
+    }
+    return FALSE;
+}
+#endif
+
+/*
+ * Generic wildcard expansion code.
+ *
+ * Characters in "pat" that should not be expanded must be preceded with a
+ * backslash. E.g., "/path\ with\ spaces/my\*star*"
+ *
+ * Return FAIL when no single file was found.  In this case "num_file" is not
+ * set, and "file" may contain an error message.
+ * Return OK when some files found.  "num_file" is set to the number of
+ * matches, "file" to the array of matches.  Call FreeWild() later.
+ */
+    int
+gen_expand_wildcards(
+    int		num_pat,	/* number of input patterns */
+    char_u	**pat,		/* array of input patterns */
+    int		*num_file,	/* resulting number of files */
+    char_u	***file,	/* array of resulting files */
+    int		flags)		/* EW_* flags */
+{
+    int			i;
+    garray_T		ga;
+    char_u		*p;
+    static int		recursive = FALSE;
+    int			add_pat;
+    int			retval = OK;
+#if defined(FEAT_SEARCHPATH)
+    int			did_expand_in_path = FALSE;
+#endif
+
+    /*
+     * expand_env() is called to expand things like "~user".  If this fails,
+     * it calls ExpandOne(), which brings us back here.  In this case, always
+     * call the machine specific expansion function, if possible.  Otherwise,
+     * return FAIL.
+     */
+    if (recursive)
+#ifdef SPECIAL_WILDCHAR
+	return mch_expand_wildcards(num_pat, pat, num_file, file, flags);
+#else
+	return FAIL;
+#endif
+
+#ifdef SPECIAL_WILDCHAR
+    /*
+     * If there are any special wildcard characters which we cannot handle
+     * here, call machine specific function for all the expansion.  This
+     * avoids starting the shell for each argument separately.
+     * For `=expr` do use the internal function.
+     */
+    for (i = 0; i < num_pat; i++)
+    {
+	if (has_special_wildchar(pat[i])
+# ifdef VIM_BACKTICK
+		&& !(vim_backtick(pat[i]) && pat[i][1] == '=')
+# endif
+	   )
+	    return mch_expand_wildcards(num_pat, pat, num_file, file, flags);
+    }
+#endif
+
+    recursive = TRUE;
+
+    /*
+     * The matching file names are stored in a growarray.  Init it empty.
+     */
+    ga_init2(&ga, (int)sizeof(char_u *), 30);
+
+    for (i = 0; i < num_pat; ++i)
+    {
+	add_pat = -1;
+	p = pat[i];
+
+#ifdef VIM_BACKTICK
+	if (vim_backtick(p))
+	{
+	    add_pat = expand_backtick(&ga, p, flags);
+	    if (add_pat == -1)
+		retval = FAIL;
+	}
+	else
+#endif
+	{
+	    /*
+	     * First expand environment variables, "~/" and "~user/".
+	     */
+	    if (has_env_var(p) || *p == '~')
+	    {
+		p = expand_env_save_opt(p, TRUE);
+		if (p == NULL)
+		    p = pat[i];
+#ifdef UNIX
+		/*
+		 * On Unix, if expand_env() can't expand an environment
+		 * variable, use the shell to do that.  Discard previously
+		 * found file names and start all over again.
+		 */
+		else if (has_env_var(p) || *p == '~')
+		{
+		    vim_free(p);
+		    ga_clear_strings(&ga);
+		    i = mch_expand_wildcards(num_pat, pat, num_file, file,
+							 flags|EW_KEEPDOLLAR);
+		    recursive = FALSE;
+		    return i;
+		}
+#endif
+	    }
+
+	    /*
+	     * If there are wildcards: Expand file names and add each match to
+	     * the list.  If there is no match, and EW_NOTFOUND is given, add
+	     * the pattern.
+	     * If there are no wildcards: Add the file name if it exists or
+	     * when EW_NOTFOUND is given.
+	     */
+	    if (mch_has_exp_wildcard(p))
+	    {
+#if defined(FEAT_SEARCHPATH)
+		if ((flags & EW_PATH)
+			&& !mch_isFullName(p)
+			&& !(p[0] == '.'
+			    && (vim_ispathsep(p[1])
+				|| (p[1] == '.' && vim_ispathsep(p[2]))))
+		   )
+		{
+		    /* :find completion where 'path' is used.
+		     * Recursiveness is OK here. */
+		    recursive = FALSE;
+		    add_pat = expand_in_path(&ga, p, flags);
+		    recursive = TRUE;
+		    did_expand_in_path = TRUE;
+		}
+		else
+#endif
+		    add_pat = mch_expandpath(&ga, p, flags);
+	    }
+	}
+
+	if (add_pat == -1 || (add_pat == 0 && (flags & EW_NOTFOUND)))
+	{
+	    char_u	*t = backslash_halve_save(p);
+
+	    /* When EW_NOTFOUND is used, always add files and dirs.  Makes
+	     * "vim c:/" work. */
+	    if (flags & EW_NOTFOUND)
+		addfile(&ga, t, flags | EW_DIR | EW_FILE);
+	    else
+		addfile(&ga, t, flags);
+	    vim_free(t);
+	}
+
+#if defined(FEAT_SEARCHPATH)
+	if (did_expand_in_path && ga.ga_len > 0 && (flags & EW_PATH))
+	    uniquefy_paths(&ga, p);
+#endif
+	if (p != pat[i])
+	    vim_free(p);
+    }
+
+    *num_file = ga.ga_len;
+    *file = (ga.ga_data != NULL) ? (char_u **)ga.ga_data : (char_u **)"";
+
+    recursive = FALSE;
+
+    return ((flags & EW_EMPTYOK) || ga.ga_data != NULL) ? retval : FAIL;
+}
+
+# ifdef VIM_BACKTICK
+
+/*
+ * Return TRUE if we can expand this backtick thing here.
+ */
+    static int
+vim_backtick(char_u *p)
+{
+    return (*p == '`' && *(p + 1) != NUL && *(p + STRLEN(p) - 1) == '`');
+}
+
+/*
+ * Expand an item in `backticks` by executing it as a command.
+ * Currently only works when pat[] starts and ends with a `.
+ * Returns number of file names found, -1 if an error is encountered.
+ */
+    static int
+expand_backtick(
+    garray_T	*gap,
+    char_u	*pat,
+    int		flags)	/* EW_* flags */
+{
+    char_u	*p;
+    char_u	*cmd;
+    char_u	*buffer;
+    int		cnt = 0;
+    int		i;
+
+    /* Create the command: lop off the backticks. */
+    cmd = vim_strnsave(pat + 1, (int)STRLEN(pat) - 2);
+    if (cmd == NULL)
+	return -1;
+
+#ifdef FEAT_EVAL
+    if (*cmd == '=')	    /* `={expr}`: Expand expression */
+	buffer = eval_to_string(cmd + 1, &p, TRUE);
+    else
+#endif
+	buffer = get_cmd_output(cmd, NULL,
+				(flags & EW_SILENT) ? SHELL_SILENT : 0, NULL);
+    vim_free(cmd);
+    if (buffer == NULL)
+	return -1;
+
+    cmd = buffer;
+    while (*cmd != NUL)
+    {
+	cmd = skipwhite(cmd);		/* skip over white space */
+	p = cmd;
+	while (*p != NUL && *p != '\r' && *p != '\n') /* skip over entry */
+	    ++p;
+	/* add an entry if it is not empty */
+	if (p > cmd)
+	{
+	    i = *p;
+	    *p = NUL;
+	    addfile(gap, cmd, flags);
+	    *p = i;
+	    ++cnt;
+	}
+	cmd = p;
+	while (*cmd != NUL && (*cmd == '\r' || *cmd == '\n'))
+	    ++cmd;
+    }
+
+    vim_free(buffer);
+    return cnt;
+}
+# endif /* VIM_BACKTICK */
+
+/*
+ * Add a file to a file list.  Accepted flags:
+ * EW_DIR	add directories
+ * EW_FILE	add files
+ * EW_EXEC	add executable files
+ * EW_NOTFOUND	add even when it doesn't exist
+ * EW_ADDSLASH	add slash after directory name
+ * EW_ALLLINKS	add symlink also when the referred file does not exist
+ */
+    void
+addfile(
+    garray_T	*gap,
+    char_u	*f,	/* filename */
+    int		flags)
+{
+    char_u	*p;
+    int		isdir;
+    stat_T	sb;
+
+    /* if the file/dir/link doesn't exist, may not add it */
+    if (!(flags & EW_NOTFOUND) && ((flags & EW_ALLLINKS)
+			? mch_lstat((char *)f, &sb) < 0 : mch_getperm(f) < 0))
+	return;
+
+#ifdef FNAME_ILLEGAL
+    /* if the file/dir contains illegal characters, don't add it */
+    if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)
+	return;
+#endif
+
+    isdir = mch_isdir(f);
+    if ((isdir && !(flags & EW_DIR)) || (!isdir && !(flags & EW_FILE)))
+	return;
+
+    /* If the file isn't executable, may not add it.  Do accept directories.
+     * When invoked from expand_shellcmd() do not use $PATH. */
+    if (!isdir && (flags & EW_EXEC)
+			     && !mch_can_exe(f, NULL, !(flags & EW_SHELLCMD)))
+	return;
+
+    /* Make room for another item in the file list. */
+    if (ga_grow(gap, 1) == FAIL)
+	return;
+
+    p = alloc((unsigned)(STRLEN(f) + 1 + isdir));
+    if (p == NULL)
+	return;
+
+    STRCPY(p, f);
+#ifdef BACKSLASH_IN_FILENAME
+    slash_adjust(p);
+#endif
+    /*
+     * Append a slash or backslash after directory names if none is present.
+     */
+#ifndef DONT_ADD_PATHSEP_TO_DIR
+    if (isdir && (flags & EW_ADDSLASH))
+	add_pathsep(p);
+#endif
+    ((char_u **)gap->ga_data)[gap->ga_len++] = p;
+}
+#endif /* !NO_EXPANDPATH */
+
+#if defined(VIM_BACKTICK) || defined(FEAT_EVAL) || defined(PROTO)
+
+#ifndef SEEK_SET
+# define SEEK_SET 0
+#endif
+#ifndef SEEK_END
+# define SEEK_END 2
+#endif
+
+/*
+ * Get the stdout of an external command.
+ * If "ret_len" is NULL replace NUL characters with NL.  When "ret_len" is not
+ * NULL store the length there.
+ * Returns an allocated string, or NULL for error.
+ */
+    char_u *
+get_cmd_output(
+    char_u	*cmd,
+    char_u	*infile,	/* optional input file name */
+    int		flags,		/* can be SHELL_SILENT */
+    int		*ret_len)
+{
+    char_u	*tempname;
+    char_u	*command;
+    char_u	*buffer = NULL;
+    int		len;
+    int		i = 0;
+    FILE	*fd;
+
+    if (check_restricted() || check_secure())
+	return NULL;
+
+    /* get a name for the temp file */
+    if ((tempname = vim_tempname('o', FALSE)) == NULL)
+    {
+	EMSG(_(e_notmp));
+	return NULL;
+    }
+
+    /* Add the redirection stuff */
+    command = make_filter_cmd(cmd, infile, tempname);
+    if (command == NULL)
+	goto done;
+
+    /*
+     * Call the shell to execute the command (errors are ignored).
+     * Don't check timestamps here.
+     */
+    ++no_check_timestamps;
+    call_shell(command, SHELL_DOOUT | SHELL_EXPAND | flags);
+    --no_check_timestamps;
+
+    vim_free(command);
+
+    /*
+     * read the names from the file into memory
+     */
+# ifdef VMS
+    /* created temporary file is not always readable as binary */
+    fd = mch_fopen((char *)tempname, "r");
+# else
+    fd = mch_fopen((char *)tempname, READBIN);
+# endif
+
+    if (fd == NULL)
+    {
+	EMSG2(_(e_notopen), tempname);
+	goto done;
+    }
+
+    fseek(fd, 0L, SEEK_END);
+    len = ftell(fd);		    /* get size of temp file */
+    fseek(fd, 0L, SEEK_SET);
+
+    buffer = alloc(len + 1);
+    if (buffer != NULL)
+	i = (int)fread((char *)buffer, (size_t)1, (size_t)len, fd);
+    fclose(fd);
+    mch_remove(tempname);
+    if (buffer == NULL)
+	goto done;
+#ifdef VMS
+    len = i;	/* VMS doesn't give us what we asked for... */
+#endif
+    if (i != len)
+    {
+	EMSG2(_(e_notread), tempname);
+	VIM_CLEAR(buffer);
+    }
+    else if (ret_len == NULL)
+    {
+	/* Change NUL into SOH, otherwise the string is truncated. */
+	for (i = 0; i < len; ++i)
+	    if (buffer[i] == NUL)
+		buffer[i] = 1;
+
+	buffer[len] = NUL;	/* make sure the buffer is terminated */
+    }
+    else
+	*ret_len = len;
+
+done:
+    vim_free(tempname);
+    return buffer;
+}
+#endif
+
+/*
+ * Free the list of files returned by expand_wildcards() or other expansion
+ * functions.
+ */
+    void
+FreeWild(int count, char_u **files)
+{
+    if (count <= 0 || files == NULL)
+	return;
+    while (count--)
+	vim_free(files[count]);
+    vim_free(files);
+}
+
+/*
+ * Return TRUE when need to go to Insert mode because of 'insertmode'.
+ * Don't do this when still processing a command or a mapping.
+ * Don't do this when inside a ":normal" command.
+ */
+    int
+goto_im(void)
+{
+    return (p_im && stuff_empty() && typebuf_typed());
+}
+
+/*
+ * Returns the isolated name of the shell in allocated memory:
+ * - Skip beyond any path.  E.g., "/usr/bin/csh -f" -> "csh -f".
+ * - Remove any argument.  E.g., "csh -f" -> "csh".
+ * But don't allow a space in the path, so that this works:
+ *   "/usr/bin/csh --rcfile ~/.cshrc"
+ * But don't do that for Windows, it's common to have a space in the path.
+ */
+    char_u *
+get_isolated_shell_name(void)
+{
+    char_u *p;
+
+#ifdef WIN3264
+    p = gettail(p_sh);
+    p = vim_strnsave(p, (int)(skiptowhite(p) - p));
+#else
+    p = skiptowhite(p_sh);
+    if (*p == NUL)
+    {
+	/* No white space, use the tail. */
+	p = vim_strsave(gettail(p_sh));
+    }
+    else
+    {
+	char_u  *p1, *p2;
+
+	/* Find the last path separator before the space. */
+	p1 = p_sh;
+	for (p2 = p_sh; p2 < p; MB_PTR_ADV(p2))
+	    if (vim_ispathsep(*p2))
+		p1 = p2 + 1;
+	p = vim_strnsave(p1, (int)(p - p1));
+    }
+#endif
+    return p;
+}
diff --git a/src/normal.c b/src/normal.c
index 41c7623..8f67df9 100644
--- a/src/normal.c
+++ b/src/normal.c
@@ -2650,13 +2650,13 @@ do_mouse(
 	{
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
 	    || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
-	    || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_PHOTON) \
+	    || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_HAIKU) || defined(FEAT_GUI_PHOTON) \
 	    || defined(FEAT_TERM_POPUP_MENU)
 # ifdef FEAT_GUI
 	    if (gui.in_use)
 	    {
 #  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
-			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_HAIKU) || defined(FEAT_GUI_MAC)
 		if (!is_click)
 		    /* Ignore right button release events, only shows the popup
 		     * menu on the button down event. */
diff --git a/src/option.h b/src/option.h
index 5df7f21..3024260 100644
--- a/src/option.h
+++ b/src/option.h
@@ -10,6 +10,8 @@
  * option.h: definition of global variables for settable options
  */
 
+#ifndef _OPTION_H_
+#define _OPTION_H_
 /*
  * Default values for 'errorformat'.
  * The "%f|%l| %m" one is used for when the contents of the quickfix window is
@@ -1199,5 +1201,7 @@ enum
     , WV_COUNT	    /* must be the last one */
 };
 
+#endif //_OPTION_H_
+
 /* Value for b_p_ul indicating the global value must be used. */
 #define NO_LOCAL_UNDOLEVEL -123456
diff --git a/b/src/option.h.orig b/src/option.h.orig
new file mode 100644
index 0000000..5df7f21
--- /dev/null
+++ b/src/option.h.orig
@@ -0,0 +1,1203 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * option.h: definition of global variables for settable options
+ */
+
+/*
+ * Default values for 'errorformat'.
+ * The "%f|%l| %m" one is used for when the contents of the quickfix window is
+ * written to a file.
+ */
+#ifdef AMIGA
+# define DFLT_EFM	"%f>%l:%c:%t:%n:%m,%f:%l: %t%*\\D%n: %m,%f %l %t%*\\D%n: %m,%*[^\"]\"%f\"%*\\D%l: %m,%f:%l:%m,%f|%l| %m"
+#else
+# if defined(WIN3264)
+#  define DFLT_EFM	"%f(%l) : %t%*\\D%n: %m,%*[^\"]\"%f\"%*\\D%l: %m,%f(%l) : %m,%*[^ ] %f %l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,%f|%l| %m"
+# else
+#  if defined(__QNX__)
+#   define DFLT_EFM	"%f(%l):%*[^WE]%t%*\\D%n:%m,%f|%l| %m"
+#  else
+#   ifdef VMS
+#    define DFLT_EFM	"%A%p^,%C%%CC-%t-%m,%Cat line number %l in file %f,%f|%l| %m"
+#   else /* Unix, probably */
+#    ifdef EBCDIC
+#define DFLT_EFM	"%*[^ ] %*[^ ] %f:%l%*[ ]%m,%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory %*[`']%f',%X%*\\a[%*\\d]: Leaving directory %*[`']%f',%DMaking %*\\a in %f,%f|%l| %m"
+#     else
+#define DFLT_EFM	"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\\,,%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory %*[`']%f',%X%*\\a[%*\\d]: Leaving directory %*[`']%f',%D%*\\a: Entering directory %*[`']%f',%X%*\\a: Leaving directory %*[`']%f',%DMaking %*\\a in %f,%f|%l| %m"
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+#define DFLT_GREPFORMAT	"%f:%l:%m,%f:%l%m,%f  %l%m"
+
+/* default values for b_p_ff 'fileformat' and p_ffs 'fileformats' */
+#define FF_DOS		"dos"
+#define FF_MAC		"mac"
+#define FF_UNIX		"unix"
+
+#ifdef USE_CRNL
+# define DFLT_FF	"dos"
+# define DFLT_FFS_VIM	"dos,unix"
+# define DFLT_FFS_VI	"dos,unix"	/* also autodetect in compatible mode */
+# define DFLT_TEXTAUTO	TRUE
+#else
+# ifdef USE_CR
+#  define DFLT_FF	"mac"
+#  define DFLT_FFS_VIM	"mac,unix,dos"
+#  define DFLT_FFS_VI	"mac,unix,dos"
+#  define DFLT_TEXTAUTO	TRUE
+# else
+#  define DFLT_FF	"unix"
+#  define DFLT_FFS_VIM	"unix,dos"
+#  ifdef __CYGWIN__
+#   define DFLT_FFS_VI	"unix,dos"	/* Cygwin always needs file detection */
+#   define DFLT_TEXTAUTO TRUE
+#  else
+#   define DFLT_FFS_VI	""
+#   define DFLT_TEXTAUTO FALSE
+#  endif
+# endif
+#endif
+
+
+#ifdef FEAT_MBYTE
+/* Possible values for 'encoding' */
+# define ENC_UCSBOM	"ucs-bom"	/* check for BOM at start of file */
+
+/* default value for 'encoding' */
+# define ENC_DFLT	"latin1"
+#endif
+
+/* end-of-line style */
+#define EOL_UNKNOWN	-1	/* not defined yet */
+#define EOL_UNIX	0	/* NL */
+#define EOL_DOS		1	/* CR NL */
+#define EOL_MAC		2	/* CR */
+
+/* Formatting options for p_fo 'formatoptions' */
+#define FO_WRAP		't'
+#define FO_WRAP_COMS	'c'
+#define FO_RET_COMS	'r'
+#define FO_OPEN_COMS	'o'
+#define FO_Q_COMS	'q'
+#define FO_Q_NUMBER	'n'
+#define FO_Q_SECOND	'2'
+#define FO_INS_VI	'v'
+#define FO_INS_LONG	'l'
+#define FO_INS_BLANK	'b'
+#define FO_MBYTE_BREAK	'm'	/* break before/after multi-byte char */
+#define FO_MBYTE_JOIN	'M'	/* no space before/after multi-byte char */
+#define FO_MBYTE_JOIN2	'B'	/* no space between multi-byte chars */
+#define FO_ONE_LETTER	'1'
+#define FO_WHITE_PAR	'w'	/* trailing white space continues paragr. */
+#define FO_AUTO		'a'	/* automatic formatting */
+#define FO_REMOVE_COMS	'j'	/* remove comment leaders when joining lines */
+
+#define DFLT_FO_VI	"vt"
+#define DFLT_FO_VIM	"tcq"
+#define FO_ALL		"tcroq2vlb1mMBn,awj"	/* for do_set() */
+
+/* characters for the p_cpo option: */
+#define CPO_ALTREAD	'a'	/* ":read" sets alternate file name */
+#define CPO_ALTWRITE	'A'	/* ":write" sets alternate file name */
+#define CPO_BAR		'b'	/* "\|" ends a mapping */
+#define CPO_BSLASH	'B'	/* backslash in mapping is not special */
+#define CPO_SEARCH	'c'
+#define CPO_CONCAT	'C'	/* Don't concatenate sourced lines */
+#define CPO_DOTTAG	'd'	/* "./tags" in 'tags' is in current dir */
+#define CPO_DIGRAPH	'D'	/* No digraph after "r", "f", etc. */
+#define CPO_EXECBUF	'e'
+#define CPO_EMPTYREGION	'E'	/* operating on empty region is an error */
+#define CPO_FNAMER	'f'	/* set file name for ":r file" */
+#define CPO_FNAMEW	'F'	/* set file name for ":w file" */
+#define CPO_GOTO1	'g'	/* goto line 1 for ":edit" */
+#define CPO_INSEND	'H'	/* "I" inserts before last blank in line */
+#define CPO_INTMOD	'i'	/* interrupt a read makes buffer modified */
+#define CPO_INDENT	'I'	/* remove auto-indent more often */
+#define CPO_JOINSP	'j'	/* only use two spaces for join after '.' */
+#define CPO_ENDOFSENT	'J'	/* need two spaces to detect end of sentence */
+#define CPO_KEYCODE	'k'	/* don't recognize raw key code in mappings */
+#define CPO_KOFFSET	'K'	/* don't wait for key code in mappings */
+#define CPO_LITERAL	'l'	/* take char after backslash in [] literal */
+#define CPO_LISTWM	'L'	/* 'list' changes wrapmargin */
+#define CPO_SHOWMATCH	'm'
+#define CPO_MATCHBSL	'M'	/* "%" ignores use of backslashes */
+#define CPO_NUMCOL	'n'	/* 'number' column also used for text */
+#define CPO_LINEOFF	'o'
+#define CPO_OVERNEW	'O'	/* silently overwrite new file */
+#define CPO_LISP	'p'	/* 'lisp' indenting */
+#define CPO_FNAMEAPP	'P'	/* set file name for ":w >>file" */
+#define CPO_JOINCOL	'q'	/* with "3J" use column after first join */
+#define CPO_REDO	'r'
+#define CPO_REMMARK	'R'	/* remove marks when filtering */
+#define CPO_BUFOPT	's'
+#define CPO_BUFOPTGLOB	'S'
+#define CPO_TAGPAT	't'
+#define CPO_UNDO	'u'	/* "u" undoes itself */
+#define CPO_BACKSPACE	'v'	/* "v" keep deleted text */
+#define CPO_CW		'w'	/* "cw" only changes one blank */
+#define CPO_FWRITE	'W'	/* "w!" doesn't overwrite readonly files */
+#define CPO_ESC		'x'
+#define CPO_REPLCNT	'X'	/* "R" with a count only deletes chars once */
+#define CPO_YANK	'y'
+#define CPO_KEEPRO	'Z'	/* don't reset 'readonly' on ":w!" */
+#define CPO_DOLLAR	'$'
+#define CPO_FILTER	'!'
+#define CPO_MATCH	'%'
+#define CPO_STAR	'*'	/* ":*" means ":@" */
+#define CPO_PLUS	'+'	/* ":write file" resets 'modified' */
+#define CPO_MINUS	'-'	/* "9-" fails at and before line 9 */
+#define CPO_SPECI	'<'	/* don't recognize <> in mappings */
+#define CPO_REGAPPEND	'>'	/* insert NL when appending to a register */
+/* POSIX flags */
+#define CPO_HASH	'#'	/* "D", "o" and "O" do not use a count */
+#define CPO_PARA	'{'	/* "{" is also a paragraph boundary */
+#define CPO_TSIZE	'|'	/* $LINES and $COLUMNS overrule term size */
+#define CPO_PRESERVE	'&'	/* keep swap file after :preserve */
+#define CPO_SUBPERCENT	'/'	/* % in :s string uses previous one */
+#define CPO_BACKSL	'\\'	/* \ is not special in [] */
+#define CPO_CHDIR	'.'	/* don't chdir if buffer is modified */
+#define CPO_SCOLON	';'	/* using "," and ";" will skip over char if
+				 * cursor would not move */
+/* default values for Vim, Vi and POSIX */
+#define CPO_VIM		"aABceFs"
+#define CPO_VI		"aAbBcCdDeEfFgHiIjJkKlLmMnoOpPqrRsStuvwWxXyZ$!%*-+<>;"
+#define CPO_ALL		"aAbBcCdDeEfFgHiIjJkKlLmMnoOpPqrRsStuvwWxXyZ$!%*-+<>#{|&/\\.;"
+
+/* characters for p_ww option: */
+#define WW_ALL		"bshl<>[],~"
+
+/* characters for p_mouse option: */
+#define MOUSE_NORMAL	'n'		/* use mouse in Normal mode */
+#define MOUSE_VISUAL	'v'		/* use mouse in Visual/Select mode */
+#define MOUSE_INSERT	'i'		/* use mouse in Insert mode */
+#define MOUSE_COMMAND	'c'		/* use mouse in Command-line mode */
+#define MOUSE_HELP	'h'		/* use mouse in help buffers */
+#define MOUSE_RETURN	'r'		/* use mouse for hit-return message */
+#define MOUSE_A		"nvich"		/* used for 'a' flag */
+#define MOUSE_ALL	"anvichr"	/* all possible characters */
+#define MOUSE_NONE	' '		/* don't use Visual selection */
+#define MOUSE_NONEF	'x'		/* forced modeless selection */
+
+#define COCU_ALL	"nvic"		/* flags for 'concealcursor' */
+
+/* characters for p_shm option: */
+#define SHM_RO		'r'		/* readonly */
+#define SHM_MOD		'm'		/* modified */
+#define SHM_FILE	'f'		/* (file 1 of 2) */
+#define SHM_LAST	'i'		/* last line incomplete */
+#define SHM_TEXT	'x'		/* tx instead of textmode */
+#define SHM_LINES	'l'		/* "L" instead of "lines" */
+#define SHM_NEW		'n'		/* "[New]" instead of "[New file]" */
+#define SHM_WRI		'w'		/* "[w]" instead of "written" */
+#define SHM_A		"rmfixlnw"	/* represented by 'a' flag */
+#define SHM_WRITE	'W'		/* don't use "written" at all */
+#define SHM_TRUNC	't'		/* trunctate file messages */
+#define SHM_TRUNCALL	'T'		/* trunctate all messages */
+#define SHM_OVER	'o'		/* overwrite file messages */
+#define SHM_OVERALL	'O'		/* overwrite more messages */
+#define SHM_SEARCH	's'		/* no search hit bottom messages */
+#define SHM_ATTENTION	'A'		/* no ATTENTION messages */
+#define SHM_INTRO	'I'		/* intro messages */
+#define SHM_COMPLETIONMENU  'c'		/* completion menu messages */
+#define SHM_RECORDING	'q'		/* short recording message */
+#define SHM_FILEINFO	'F'		/* no file info messages */
+#define SHM_ALL		"rmfixlnwaWtToOsAIcqF" /* all possible flags for 'shm' */
+
+/* characters for p_go: */
+#define GO_TERMINAL	'!'		/* use terminal for system commands */
+#define GO_ASEL		'a'		/* autoselect */
+#define GO_ASELML	'A'		/* autoselect modeless selection */
+#define GO_BOT		'b'		/* use bottom scrollbar */
+#define GO_CONDIALOG	'c'		/* use console dialog */
+#define GO_TABLINE	'e'		/* may show tabline */
+#define GO_FORG		'f'		/* start GUI in foreground */
+#define GO_GREY		'g'		/* use grey menu items */
+#define GO_HORSCROLL	'h'		/* flexible horizontal scrolling */
+#define GO_ICON		'i'		/* use Vim icon */
+#define GO_LEFT		'l'		/* use left scrollbar */
+#define GO_VLEFT	'L'		/* left scrollbar with vert split */
+#define GO_MENUS	'm'		/* use menu bar */
+#define GO_NOSYSMENU	'M'		/* don't source system menu */
+#define GO_POINTER	'p'		/* pointer enter/leave callbacks */
+#define GO_ASELPLUS	'P'		/* autoselectPlus */
+#define GO_RIGHT	'r'		/* use right scrollbar */
+#define GO_VRIGHT	'R'		/* right scrollbar with vert split */
+#define GO_TEAROFF	't'		/* add tear-off menu items */
+#define GO_TOOLBAR	'T'		/* add toolbar */
+#define GO_FOOTER	'F'		/* add footer */
+#define GO_VERTICAL	'v'		/* arrange dialog buttons vertically */
+#define GO_KEEPWINSIZE	'k'		/* keep GUI window size */
+#define GO_ALL		"!aAbcefFghilmMprtTvk" /* all possible flags for 'go' */
+
+/* flags for 'comments' option */
+#define COM_NEST	'n'		/* comments strings nest */
+#define COM_BLANK	'b'		/* needs blank after string */
+#define COM_START	's'		/* start of comment */
+#define COM_MIDDLE	'm'		/* middle of comment */
+#define COM_END		'e'		/* end of comment */
+#define COM_AUTO_END	'x'		/* last char of end closes comment */
+#define COM_FIRST	'f'		/* first line comment only */
+#define COM_LEFT	'l'		/* left adjusted */
+#define COM_RIGHT	'r'		/* right adjusted */
+#define COM_NOBACK	'O'		/* don't use for "O" command */
+#define COM_ALL		"nbsmexflrO"	/* all flags for 'comments' option */
+#define COM_MAX_LEN	50		/* maximum length of a part */
+
+/* flags for 'statusline' option */
+#define STL_FILEPATH	'f'		/* path of file in buffer */
+#define STL_FULLPATH	'F'		/* full path of file in buffer */
+#define STL_FILENAME	't'		/* last part (tail) of file path */
+#define STL_COLUMN	'c'		/* column og cursor*/
+#define STL_VIRTCOL	'v'		/* virtual column */
+#define STL_VIRTCOL_ALT	'V'		/* - with 'if different' display */
+#define STL_LINE	'l'		/* line number of cursor */
+#define STL_NUMLINES	'L'		/* number of lines in buffer */
+#define STL_BUFNO	'n'		/* current buffer number */
+#define STL_KEYMAP	'k'		/* 'keymap' when active */
+#define STL_OFFSET	'o'		/* offset of character under cursor*/
+#define STL_OFFSET_X	'O'		/* - in hexadecimal */
+#define STL_BYTEVAL	'b'		/* byte value of character */
+#define STL_BYTEVAL_X	'B'		/* - in hexadecimal */
+#define STL_ROFLAG	'r'		/* readonly flag */
+#define STL_ROFLAG_ALT	'R'		/* - other display */
+#define STL_HELPFLAG	'h'		/* window is showing a help file */
+#define STL_HELPFLAG_ALT 'H'		/* - other display */
+#define STL_FILETYPE	'y'		/* 'filetype' */
+#define STL_FILETYPE_ALT 'Y'		/* - other display */
+#define STL_PREVIEWFLAG	'w'		/* window is showing the preview buf */
+#define STL_PREVIEWFLAG_ALT 'W'		/* - other display */
+#define STL_MODIFIED	'm'		/* modified flag */
+#define STL_MODIFIED_ALT 'M'		/* - other display */
+#define STL_QUICKFIX	'q'		/* quickfix window description */
+#define STL_PERCENTAGE	'p'		/* percentage through file */
+#define STL_ALTPERCENT	'P'		/* percentage as TOP BOT ALL or NN% */
+#define STL_ARGLISTSTAT	'a'		/* argument list status as (x of y) */
+#define STL_PAGENUM	'N'		/* page number (when printing)*/
+#define STL_VIM_EXPR	'{'		/* start of expression to substitute */
+#define STL_MIDDLEMARK	'='		/* separation between left and right */
+#define STL_TRUNCMARK	'<'		/* truncation mark if line is too long*/
+#define STL_USER_HL	'*'		/* highlight from (User)1..9 or 0 */
+#define STL_HIGHLIGHT	'#'		/* highlight name */
+#define STL_TABPAGENR	'T'		/* tab page label nr */
+#define STL_TABCLOSENR	'X'		/* tab page close nr */
+#define STL_ALL		((char_u *) "fFtcvVlLknoObBrRhHmYyWwMqpPaN{#")
+
+/* flags used for parsed 'wildmode' */
+#define WIM_FULL	1
+#define WIM_LONGEST	2
+#define WIM_LIST	4
+
+/* arguments for can_bs() */
+#define BS_INDENT	'i'	/* "Indent" */
+#define BS_EOL		'o'	/* "eOl" */
+#define BS_START	's'	/* "Start" */
+
+#define LISPWORD_VALUE	"defun,define,defmacro,set!,lambda,if,case,let,flet,let*,letrec,do,do*,define-syntax,let-syntax,letrec-syntax,destructuring-bind,defpackage,defparameter,defstruct,deftype,defvar,do-all-symbols,do-external-symbols,do-symbols,dolist,dotimes,ecase,etypecase,eval-when,labels,macrolet,multiple-value-bind,multiple-value-call,multiple-value-prog1,multiple-value-setq,prog1,progv,typecase,unless,unwind-protect,when,with-input-from-string,with-open-file,with-open-stream,with-output-to-string,with-package-iterator,define-condition,handler-bind,handler-case,restart-bind,restart-case,with-simple-restart,store-value,use-value,muffle-warning,abort,continue,with-slots,with-slots*,with-accessors,with-accessors*,defclass,defmethod,print-unreadable-object"
+
+/*
+ * The following are actual variables for the options
+ */
+
+#ifdef FEAT_RIGHTLEFT
+EXTERN long	p_aleph;	/* 'aleph' */
+#endif
+#ifdef FEAT_AUTOCHDIR
+EXTERN int	p_acd;		/* 'autochdir' */
+#endif
+#ifdef FEAT_MBYTE
+EXTERN char_u	*p_ambw;	/* 'ambiwidth' */
+EXTERN char_u	*p_emoji;	/* 'emoji' */
+#endif
+#if defined(FEAT_GUI) && defined(MACOS_X)
+EXTERN int	*p_antialias;	/* 'antialias' */
+#endif
+EXTERN int	p_ar;		/* 'autoread' */
+EXTERN int	p_aw;		/* 'autowrite' */
+EXTERN int	p_awa;		/* 'autowriteall' */
+EXTERN char_u	*p_bs;		/* 'backspace' */
+EXTERN char_u	*p_bg;		/* 'background' */
+EXTERN int	p_bk;		/* 'backup' */
+EXTERN char_u	*p_bkc;		/* 'backupcopy' */
+EXTERN unsigned	bkc_flags;	/* flags from 'backupcopy' */
+#ifdef IN_OPTION_C
+static char *(p_bkc_values[]) = {"yes", "auto", "no", "breaksymlink", "breakhardlink", NULL};
+#endif
+# define BKC_YES		0x001
+# define BKC_AUTO		0x002
+# define BKC_NO			0x004
+# define BKC_BREAKSYMLINK	0x008
+# define BKC_BREAKHARDLINK	0x010
+EXTERN char_u	*p_bdir;	/* 'backupdir' */
+EXTERN char_u	*p_bex;		/* 'backupext' */
+EXTERN char_u	*p_bo;		/* 'belloff' */
+EXTERN unsigned	bo_flags;
+# ifdef IN_OPTION_C
+static char *(p_bo_values[]) = {"all", "backspace", "cursor", "complete",
+				 "copy", "ctrlg", "error", "esc", "ex",
+				 "hangul", "insertmode", "lang", "mess",
+				 "showmatch", "operator", "register", "shell",
+				 "spell", "wildmode", NULL};
+# endif
+
+/* values for the 'beepon' option */
+#define BO_ALL		0x0001
+#define BO_BS		0x0002
+#define BO_CRSR		0x0004
+#define BO_COMPL	0x0008
+#define BO_COPY		0x0010
+#define BO_CTRLG	0x0020
+#define BO_ERROR	0x0040
+#define BO_ESC		0x0080
+#define BO_EX		0x0100
+#define BO_HANGUL	0x0200
+#define BO_IM		0x0400
+#define BO_LANG		0x0800
+#define BO_MESS		0x1000
+#define BO_MATCH	0x2000
+#define BO_OPER		0x4000
+#define BO_REG		0x8000
+#define BO_SH		0x10000
+#define BO_SPELL	0x20000
+#define BO_WILD		0x40000
+
+#ifdef FEAT_WILDIGN
+EXTERN char_u	*p_bsk;		/* 'backupskip' */
+#endif
+#ifdef FEAT_CRYPT
+EXTERN char_u	*p_cm;		/* 'cryptmethod' */
+#endif
+#ifdef FEAT_BEVAL
+# ifdef FEAT_BEVAL_GUI
+EXTERN int	p_beval;	/* 'ballooneval' */
+# endif
+EXTERN long	p_bdlay;	/* 'balloondelay' */
+# ifdef FEAT_EVAL
+EXTERN char_u	*p_bexpr;
+# endif
+# ifdef FEAT_BEVAL_TERM
+EXTERN int	p_bevalterm;	/* 'balloonevalterm' */
+# endif
+#endif
+#ifdef FEAT_BROWSE
+EXTERN char_u	*p_bsdir;	/* 'browsedir' */
+#endif
+#ifdef FEAT_LINEBREAK
+EXTERN char_u	*p_breakat;	/* 'breakat' */
+#endif
+#ifdef FEAT_MBYTE
+EXTERN char_u	*p_cmp;		/* 'casemap' */
+EXTERN unsigned	cmp_flags;
+# ifdef IN_OPTION_C
+static char *(p_cmp_values[]) = {"internal", "keepascii", NULL};
+# endif
+# define CMP_INTERNAL		0x001
+# define CMP_KEEPASCII		0x002
+#endif
+#ifdef FEAT_MBYTE
+EXTERN char_u	*p_enc;		/* 'encoding' */
+EXTERN int	p_deco;		/* 'delcombine' */
+# ifdef FEAT_EVAL
+EXTERN char_u	*p_ccv;		/* 'charconvert' */
+# endif
+#endif
+#ifdef FEAT_CMDWIN
+EXTERN char_u	*p_cedit;	/* 'cedit' */
+EXTERN long	p_cwh;		/* 'cmdwinheight' */
+#endif
+#ifdef FEAT_CLIPBOARD
+EXTERN char_u	*p_cb;		/* 'clipboard' */
+#endif
+EXTERN long	p_ch;		/* 'cmdheight' */
+#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+EXTERN int	p_confirm;	/* 'confirm' */
+#endif
+EXTERN int	p_cp;		/* 'compatible' */
+#ifdef FEAT_INS_EXPAND
+EXTERN char_u	*p_cot;		/* 'completeopt' */
+EXTERN long	p_ph;		/* 'pumheight' */
+EXTERN long	p_pw;		/* 'pumwidth' */
+#endif
+EXTERN char_u	*p_cpo;		/* 'cpoptions' */
+#ifdef FEAT_CSCOPE
+EXTERN char_u	*p_csprg;	/* 'cscopeprg' */
+EXTERN int	p_csre;		/* 'cscoperelative' */
+# ifdef FEAT_QUICKFIX
+EXTERN char_u	*p_csqf;	/* 'cscopequickfix' */
+#  define	CSQF_CMDS   "sgdctefia"
+#  define	CSQF_FLAGS  "+-0"
+# endif
+EXTERN int	p_cst;		/* 'cscopetag' */
+EXTERN long	p_csto;		/* 'cscopetagorder' */
+EXTERN long	p_cspc;		/* 'cscopepathcomp' */
+EXTERN int	p_csverbose;	/* 'cscopeverbose' */
+#endif
+EXTERN char_u	*p_debug;	/* 'debug' */
+#ifdef FEAT_FIND_ID
+EXTERN char_u	*p_def;		/* 'define' */
+EXTERN char_u	*p_inc;
+#endif
+#ifdef FEAT_DIFF
+EXTERN char_u	*p_dip;		/* 'diffopt' */
+# ifdef FEAT_EVAL
+EXTERN char_u	*p_dex;		/* 'diffexpr' */
+# endif
+#endif
+#ifdef FEAT_INS_EXPAND
+EXTERN char_u	*p_dict;	/* 'dictionary' */
+#endif
+#ifdef FEAT_DIGRAPHS
+EXTERN int	p_dg;		/* 'digraph' */
+#endif
+EXTERN char_u	*p_dir;		/* 'directory' */
+EXTERN char_u	*p_dy;		/* 'display' */
+EXTERN unsigned	dy_flags;
+#ifdef IN_OPTION_C
+static char *(p_dy_values[]) = {"lastline", "truncate", "uhex", NULL};
+#endif
+#define DY_LASTLINE		0x001
+#define DY_TRUNCATE		0x002
+#define DY_UHEX			0x004
+EXTERN int	p_ed;		/* 'edcompatible' */
+EXTERN char_u	*p_ead;		/* 'eadirection' */
+EXTERN int	p_ea;		/* 'equalalways' */
+EXTERN char_u	*p_ep;		/* 'equalprg' */
+EXTERN int	p_eb;		/* 'errorbells' */
+#ifdef FEAT_QUICKFIX
+EXTERN char_u	*p_ef;		/* 'errorfile' */
+EXTERN char_u	*p_efm;		/* 'errorformat' */
+EXTERN char_u	*p_gefm;	/* 'grepformat' */
+EXTERN char_u	*p_gp;		/* 'grepprg' */
+#endif
+EXTERN char_u	*p_ei;		/* 'eventignore' */
+EXTERN int	p_ek;		/* 'esckeys' */
+EXTERN int	p_exrc;		/* 'exrc' */
+#ifdef FEAT_MBYTE
+EXTERN char_u	*p_fencs;	/* 'fileencodings' */
+#endif
+EXTERN char_u	*p_ffs;		/* 'fileformats' */
+EXTERN long	p_fic;		/* 'fileignorecase' */
+#ifdef FEAT_FOLDING
+EXTERN char_u	*p_fcl;		/* 'foldclose' */
+EXTERN long	p_fdls;		/* 'foldlevelstart' */
+EXTERN char_u	*p_fdo;		/* 'foldopen' */
+EXTERN unsigned	fdo_flags;
+# ifdef IN_OPTION_C
+static char *(p_fdo_values[]) = {"all", "block", "hor", "mark", "percent",
+				 "quickfix", "search", "tag", "insert",
+				 "undo", "jump", NULL};
+# endif
+# define FDO_ALL		0x001
+# define FDO_BLOCK		0x002
+# define FDO_HOR		0x004
+# define FDO_MARK		0x008
+# define FDO_PERCENT		0x010
+# define FDO_QUICKFIX		0x020
+# define FDO_SEARCH		0x040
+# define FDO_TAG		0x080
+# define FDO_INSERT		0x100
+# define FDO_UNDO		0x200
+# define FDO_JUMP		0x400
+#endif
+EXTERN char_u	*p_fp;		/* 'formatprg' */
+#ifdef HAVE_FSYNC
+EXTERN int	p_fs;		/* 'fsync' */
+#endif
+EXTERN int	p_gd;		/* 'gdefault' */
+#ifdef FEAT_PRINTER
+EXTERN char_u	*p_pdev;	/* 'printdevice' */
+# ifdef FEAT_POSTSCRIPT
+EXTERN char_u	*p_penc;	/* 'printencoding' */
+EXTERN char_u	*p_pexpr;	/* 'printexpr' */
+#   ifdef FEAT_MBYTE
+EXTERN char_u	*p_pmfn;	/* 'printmbfont' */
+EXTERN char_u	*p_pmcs;	/* 'printmbcharset' */
+#   endif
+# endif
+EXTERN char_u	*p_pfn;		/* 'printfont' */
+EXTERN char_u	*p_popt;	/* 'printoptions' */
+EXTERN char_u	*p_header;	/* 'printheader' */
+#endif
+EXTERN int	p_prompt;	/* 'prompt' */
+#ifdef FEAT_GUI
+EXTERN char_u	*p_guifont;	/* 'guifont' */
+# ifdef FEAT_XFONTSET
+EXTERN char_u	*p_guifontset;	/* 'guifontset' */
+# endif
+# ifdef FEAT_MBYTE
+EXTERN char_u	*p_guifontwide;	/* 'guifontwide' */
+# endif
+EXTERN int	p_guipty;	/* 'guipty' */
+#endif
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
+EXTERN long	p_ghr;		/* 'guiheadroom' */
+#endif
+#ifdef CURSOR_SHAPE
+EXTERN char_u	*p_guicursor;	/* 'guicursor' */
+#endif
+#ifdef FEAT_MOUSESHAPE
+EXTERN char_u	*p_mouseshape;	/* 'mouseshape' */
+#endif
+#if defined(FEAT_GUI)
+EXTERN char_u	*p_go;		/* 'guioptions' */
+#endif
+#if defined(FEAT_GUI_TABLINE)
+EXTERN char_u	*p_gtl;		/* 'guitablabel' */
+EXTERN char_u	*p_gtt;		/* 'guitabtooltip' */
+#endif
+EXTERN char_u	*p_hf;		/* 'helpfile' */
+EXTERN long	p_hh;		/* 'helpheight' */
+#ifdef FEAT_MULTI_LANG
+EXTERN char_u	*p_hlg;		/* 'helplang' */
+#endif
+EXTERN int	p_hid;		/* 'hidden' */
+EXTERN char_u	*p_hl;		/* 'highlight' */
+EXTERN int	p_hls;		/* 'hlsearch' */
+EXTERN long	p_hi;		/* 'history' */
+#ifdef FEAT_RIGHTLEFT
+EXTERN int	p_hkmap;	/* 'hkmap' */
+EXTERN int	p_hkmapp;	/* 'hkmapp' */
+# ifdef FEAT_FKMAP
+EXTERN int	p_fkmap;	/* 'fkmap' */
+EXTERN int	p_altkeymap;	/* 'altkeymap' */
+# endif
+# ifdef FEAT_ARABIC
+EXTERN int	p_arshape;	/* 'arabicshape' */
+# endif
+#endif
+#ifdef FEAT_TITLE
+EXTERN int	p_icon;		/* 'icon' */
+EXTERN char_u	*p_iconstring;	/* 'iconstring' */
+#endif
+EXTERN int	p_ic;		/* 'ignorecase' */
+#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
+EXTERN char_u	*p_imak;	/* 'imactivatekey' */
+#define IM_ON_THE_SPOT		0L
+#define IM_OVER_THE_SPOT	1L
+EXTERN long	p_imst;		/* 'imstyle' */
+#endif
+#if defined(FEAT_EVAL) && defined(FEAT_MBYTE)
+EXTERN char_u	*p_imaf;	/* 'imactivatefunc' */
+EXTERN char_u	*p_imsf;	/* 'imstatusfunc' */
+#endif
+#ifdef FEAT_MBYTE
+EXTERN int	p_imcmdline;	/* 'imcmdline' */
+EXTERN int	p_imdisable;	/* 'imdisable' */
+#endif
+EXTERN int	p_is;		/* 'incsearch' */
+EXTERN int	p_im;		/* 'insertmode' */
+EXTERN char_u	*p_isf;		/* 'isfname' */
+EXTERN char_u	*p_isi;		/* 'isident' */
+EXTERN char_u	*p_isp;		/* 'isprint' */
+EXTERN int	p_js;		/* 'joinspaces' */
+EXTERN char_u	*p_kp;		/* 'keywordprg' */
+EXTERN char_u	*p_km;		/* 'keymodel' */
+#ifdef FEAT_LANGMAP
+EXTERN char_u	*p_langmap;	/* 'langmap'*/
+EXTERN int	p_lnr;		/* 'langnoremap' */
+EXTERN int	p_lrm;		/* 'langremap' */
+#endif
+#if defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)
+EXTERN char_u	*p_lm;		/* 'langmenu' */
+#endif
+#ifdef FEAT_GUI
+EXTERN long	p_linespace;	/* 'linespace' */
+#endif
+#ifdef FEAT_LISP
+EXTERN char_u	*p_lispwords;	/* 'lispwords' */
+#endif
+EXTERN long	p_ls;		/* 'laststatus' */
+EXTERN long	p_stal;		/* 'showtabline' */
+EXTERN char_u	*p_lcs;		/* 'listchars' */
+
+EXTERN int	p_lz;		/* 'lazyredraw' */
+EXTERN int	p_lpl;		/* 'loadplugins' */
+#if defined(DYNAMIC_LUA)
+EXTERN char_u	*p_luadll;	/* 'luadll' */
+#endif
+#ifdef FEAT_GUI_MAC
+EXTERN int	p_macatsui;	/* 'macatsui' */
+#endif
+EXTERN int	p_magic;	/* 'magic' */
+#ifdef FEAT_MBYTE
+EXTERN char_u	*p_menc;	/* 'makeencoding' */
+#endif
+#ifdef FEAT_QUICKFIX
+EXTERN char_u	*p_mef;		/* 'makeef' */
+EXTERN char_u	*p_mp;		/* 'makeprg' */
+#endif
+#ifdef FEAT_SIGNS
+EXTERN char_u  *p_scl;		/* signcolumn */
+#endif
+#ifdef FEAT_SYN_HL
+EXTERN char_u   *p_cc;		/* 'colorcolumn' */
+EXTERN int      p_cc_cols[256]; /* array for 'colorcolumn' columns */
+#endif
+EXTERN long	p_mat;		/* 'matchtime' */
+#ifdef FEAT_MBYTE
+EXTERN long	p_mco;		/* 'maxcombine' */
+#endif
+#ifdef FEAT_EVAL
+EXTERN long	p_mfd;		/* 'maxfuncdepth' */
+#endif
+EXTERN long	p_mmd;		/* 'maxmapdepth' */
+EXTERN long	p_mm;		/* 'maxmem' */
+EXTERN long	p_mmp;		/* 'maxmempattern' */
+EXTERN long	p_mmt;		/* 'maxmemtot' */
+#ifdef FEAT_MENU
+EXTERN long	p_mis;		/* 'menuitems' */
+#endif
+#ifdef FEAT_SPELL
+EXTERN char_u	*p_msm;		/* 'mkspellmem' */
+#endif
+EXTERN long	p_mls;		/* 'modelines' */
+EXTERN char_u	*p_mouse;	/* 'mouse' */
+#ifdef FEAT_GUI
+EXTERN int	p_mousef;	/* 'mousefocus' */
+EXTERN int	p_mh;		/* 'mousehide' */
+#endif
+EXTERN char_u	*p_mousem;	/* 'mousemodel' */
+EXTERN long	p_mouset;	/* 'mousetime' */
+EXTERN int	p_more;		/* 'more' */
+#ifdef FEAT_MZSCHEME
+EXTERN long	p_mzq;		/* 'mzquantum */
+# if defined(DYNAMIC_MZSCHEME)
+EXTERN char_u	*p_mzschemedll;	/* 'mzschemedll' */
+EXTERN char_u	*p_mzschemegcdll; /* 'mzschemegcdll' */
+# endif
+#endif
+#if defined(MSWIN)
+EXTERN int	p_odev;		/* 'opendevice' */
+#endif
+EXTERN char_u	*p_opfunc;	/* 'operatorfunc' */
+EXTERN char_u	*p_para;	/* 'paragraphs' */
+EXTERN int	p_paste;	/* 'paste' */
+EXTERN char_u	*p_pt;		/* 'pastetoggle' */
+#if defined(FEAT_EVAL) && defined(FEAT_DIFF)
+EXTERN char_u	*p_pex;		/* 'patchexpr' */
+#endif
+EXTERN char_u	*p_pm;		/* 'patchmode' */
+EXTERN char_u	*p_path;	/* 'path' */
+#ifdef FEAT_SEARCHPATH
+EXTERN char_u	*p_cdpath;	/* 'cdpath' */
+#endif
+#if defined(DYNAMIC_PERL)
+EXTERN char_u	*p_perldll;	/* 'perldll' */
+#endif
+#if defined(DYNAMIC_PYTHON3)
+EXTERN char_u	*p_py3dll;	/* 'pythonthreedll' */
+#endif
+#ifdef FEAT_PYTHON3
+EXTERN char_u	*p_py3home;	/* 'pythonthreehome' */
+#endif
+#if defined(DYNAMIC_PYTHON)
+EXTERN char_u	*p_pydll;	/* 'pythondll' */
+#endif
+#ifdef FEAT_PYTHON
+EXTERN char_u	*p_pyhome;	/* 'pythonhome' */
+#endif
+#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+EXTERN long	p_pyx;		/* 'pyxversion' */
+#endif
+#ifdef FEAT_RELTIME
+EXTERN long	p_rdt;		/* 'redrawtime' */
+#endif
+EXTERN int	p_remap;	/* 'remap' */
+EXTERN long	p_re;		/* 'regexpengine' */
+#ifdef FEAT_RENDER_OPTIONS
+EXTERN char_u	*p_rop;		/* 'renderoptions' */
+#endif
+EXTERN long	p_report;	/* 'report' */
+#if defined(FEAT_QUICKFIX)
+EXTERN long	p_pvh;		/* 'previewheight' */
+#endif
+#ifdef WIN3264
+EXTERN int	p_rs;		/* 'restorescreen' */
+#endif
+#ifdef FEAT_RIGHTLEFT
+EXTERN int	p_ari;		/* 'allowrevins' */
+EXTERN int	p_ri;		/* 'revins' */
+#endif
+#if defined(DYNAMIC_RUBY)
+EXTERN char_u	*p_rubydll;	/* 'rubydll' */
+#endif
+#ifdef FEAT_CMDL_INFO
+EXTERN int	p_ru;		/* 'ruler' */
+#endif
+#ifdef FEAT_STL_OPT
+EXTERN char_u	*p_ruf;		/* 'rulerformat' */
+#endif
+EXTERN char_u	*p_pp;		/* 'packpath' */
+EXTERN char_u	*p_rtp;		/* 'runtimepath' */
+EXTERN long	p_sj;		/* 'scrolljump' */
+EXTERN long	p_so;		/* 'scrolloff' */
+EXTERN char_u	*p_sbo;		/* 'scrollopt' */
+EXTERN char_u	*p_sections;	/* 'sections' */
+EXTERN int	p_secure;	/* 'secure' */
+EXTERN char_u	*p_sel;		/* 'selection' */
+EXTERN char_u	*p_slm;		/* 'selectmode' */
+#ifdef FEAT_SESSION
+EXTERN char_u	*p_ssop;	/* 'sessionoptions' */
+EXTERN unsigned	ssop_flags;
+# ifdef IN_OPTION_C
+/* Also used for 'viewoptions'! */
+static char *(p_ssop_values[]) = {"buffers", "winpos", "resize", "winsize",
+    "localoptions", "options", "help", "blank", "globals", "slash", "unix",
+    "sesdir", "curdir", "folds", "cursor", "tabpages", "terminal", NULL};
+# endif
+# define SSOP_BUFFERS		0x001
+# define SSOP_WINPOS		0x002
+# define SSOP_RESIZE		0x004
+# define SSOP_WINSIZE		0x008
+# define SSOP_LOCALOPTIONS	0x010
+# define SSOP_OPTIONS		0x020
+# define SSOP_HELP		0x040
+# define SSOP_BLANK		0x080
+# define SSOP_GLOBALS		0x100
+# define SSOP_SLASH		0x200
+# define SSOP_UNIX		0x400
+# define SSOP_SESDIR		0x800
+# define SSOP_CURDIR		0x1000
+# define SSOP_FOLDS		0x2000
+# define SSOP_CURSOR		0x4000
+# define SSOP_TABPAGES		0x8000
+# define SSOP_TERMINAL		0x10000
+#endif
+EXTERN char_u	*p_sh;		/* 'shell' */
+EXTERN char_u	*p_shcf;	/* 'shellcmdflag' */
+#ifdef FEAT_QUICKFIX
+EXTERN char_u	*p_sp;		/* 'shellpipe' */
+#endif
+EXTERN char_u	*p_shq;		/* 'shellquote' */
+EXTERN char_u	*p_sxq;		/* 'shellxquote' */
+EXTERN char_u	*p_sxe;		/* 'shellxescape' */
+EXTERN char_u	*p_srr;		/* 'shellredir' */
+#ifdef AMIGA
+EXTERN long	p_st;		/* 'shelltype' */
+#endif
+EXTERN int	p_stmp;		/* 'shelltemp' */
+#ifdef BACKSLASH_IN_FILENAME
+EXTERN int	p_ssl;		/* 'shellslash' */
+#endif
+#ifdef FEAT_STL_OPT
+EXTERN char_u	*p_stl;		/* 'statusline' */
+#endif
+EXTERN int	p_sr;		/* 'shiftround' */
+EXTERN char_u	*p_shm;		/* 'shortmess' */
+#ifdef FEAT_LINEBREAK
+EXTERN char_u	*p_sbr;		/* 'showbreak' */
+#endif
+#ifdef FEAT_CMDL_INFO
+EXTERN int	p_sc;		/* 'showcmd' */
+#endif
+EXTERN int	p_sft;		/* 'showfulltag' */
+EXTERN int	p_sm;		/* 'showmatch' */
+EXTERN int	p_smd;		/* 'showmode' */
+EXTERN long	p_ss;		/* 'sidescroll' */
+EXTERN long	p_siso;		/* 'sidescrolloff' */
+EXTERN int	p_scs;		/* 'smartcase' */
+EXTERN int	p_sta;		/* 'smarttab' */
+EXTERN int	p_sb;		/* 'splitbelow' */
+EXTERN long	p_tpm;		/* 'tabpagemax' */
+# if defined(FEAT_STL_OPT)
+EXTERN char_u	*p_tal;		/* 'tabline' */
+# endif
+#ifdef FEAT_SPELL
+EXTERN char_u	*p_sps;		/* 'spellsuggest' */
+#endif
+EXTERN int	p_spr;		/* 'splitright' */
+EXTERN int	p_sol;		/* 'startofline' */
+EXTERN char_u	*p_su;		/* 'suffixes' */
+EXTERN char_u	*p_sws;		/* 'swapsync' */
+EXTERN char_u	*p_swb;		/* 'switchbuf' */
+EXTERN unsigned	swb_flags;
+#ifdef IN_OPTION_C
+static char *(p_swb_values[]) = {"useopen", "usetab", "split", "newtab", "vsplit", NULL};
+#endif
+#define SWB_USEOPEN		0x001
+#define SWB_USETAB		0x002
+#define SWB_SPLIT		0x004
+#define SWB_NEWTAB		0x008
+#define SWB_VSPLIT		0x010
+EXTERN int	p_tbs;		/* 'tagbsearch' */
+EXTERN char_u	*p_tc;		/* 'tagcase' */
+EXTERN unsigned tc_flags;       /* flags from 'tagcase' */
+#ifdef IN_OPTION_C
+static char *(p_tc_values[]) = {"followic", "ignore", "match", "followscs", "smart", NULL};
+#endif
+#define TC_FOLLOWIC		0x01
+#define TC_IGNORE		0x02
+#define TC_MATCH		0x04
+#define TC_FOLLOWSCS		0x08
+#define TC_SMART		0x10
+EXTERN long	p_tl;		/* 'taglength' */
+EXTERN int	p_tr;		/* 'tagrelative' */
+EXTERN char_u	*p_tags;	/* 'tags' */
+EXTERN int	p_tgst;		/* 'tagstack' */
+#if defined(DYNAMIC_TCL)
+EXTERN char_u	*p_tcldll;	/* 'tcldll' */
+#endif
+#ifdef FEAT_ARABIC
+EXTERN int	p_tbidi;	/* 'termbidi' */
+#endif
+#ifdef FEAT_MBYTE
+EXTERN char_u	*p_tenc;	/* 'termencoding' */
+#endif
+#ifdef FEAT_TERMGUICOLORS
+EXTERN int	p_tgc;		/* 'termguicolors' */
+#endif
+EXTERN int	p_terse;	/* 'terse' */
+EXTERN int	p_ta;		/* 'textauto' */
+EXTERN int	p_to;		/* 'tildeop' */
+EXTERN int	p_timeout;	/* 'timeout' */
+EXTERN long	p_tm;		/* 'timeoutlen' */
+#ifdef FEAT_TITLE
+EXTERN int	p_title;	/* 'title' */
+EXTERN long	p_titlelen;	/* 'titlelen' */
+EXTERN char_u	*p_titleold;	/* 'titleold' */
+EXTERN char_u	*p_titlestring;	/* 'titlestring' */
+#endif
+#ifdef FEAT_INS_EXPAND
+EXTERN char_u	*p_tsr;		/* 'thesaurus' */
+#endif
+EXTERN int	p_ttimeout;	/* 'ttimeout' */
+EXTERN long	p_ttm;		/* 'ttimeoutlen' */
+EXTERN int	p_tbi;		/* 'ttybuiltin' */
+EXTERN int	p_tf;		/* 'ttyfast' */
+#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
+EXTERN char_u	*p_toolbar;	/* 'toolbar' */
+EXTERN unsigned toolbar_flags;
+# ifdef IN_OPTION_C
+static char *(p_toolbar_values[]) = {"text", "icons", "tooltips", "horiz", NULL};
+# endif
+# define TOOLBAR_TEXT		0x01
+# define TOOLBAR_ICONS		0x02
+# define TOOLBAR_TOOLTIPS	0x04
+# define TOOLBAR_HORIZ		0x08
+#endif
+#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)
+EXTERN char_u	*p_tbis;	/* 'toolbariconsize' */
+EXTERN unsigned tbis_flags;
+# ifdef IN_OPTION_C
+static char *(p_tbis_values[]) = {"tiny", "small", "medium", "large", "huge", "giant", NULL};
+# endif
+# define TBIS_TINY		0x01
+# define TBIS_SMALL		0x02
+# define TBIS_MEDIUM		0x04
+# define TBIS_LARGE		0x08
+# define TBIS_HUGE		0x10
+# define TBIS_GIANT		0x20
+#endif
+EXTERN long	p_ttyscroll;	/* 'ttyscroll' */
+#if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
+EXTERN char_u	*p_ttym;	/* 'ttymouse' */
+EXTERN unsigned ttym_flags;
+# ifdef IN_OPTION_C
+static char *(p_ttym_values[]) = {"xterm", "xterm2", "dec", "netterm", "jsbterm", "pterm", "urxvt", "sgr", NULL};
+# endif
+# define TTYM_XTERM		0x01
+# define TTYM_XTERM2		0x02
+# define TTYM_DEC		0x04
+# define TTYM_NETTERM		0x08
+# define TTYM_JSBTERM		0x10
+# define TTYM_PTERM		0x20
+# define TTYM_URXVT		0x40
+# define TTYM_SGR		0x80
+#endif
+EXTERN char_u	*p_udir;	/* 'undodir' */
+EXTERN long	p_ul;		/* 'undolevels' */
+EXTERN long	p_ur;		/* 'undoreload' */
+EXTERN long	p_uc;		/* 'updatecount' */
+EXTERN long	p_ut;		/* 'updatetime' */
+EXTERN char_u	*p_fcs;		/* 'fillchar' */
+#ifdef FEAT_VIMINFO
+EXTERN char_u	*p_viminfo;	/* 'viminfo' */
+EXTERN char_u	*p_viminfofile;	/* 'viminfofile' */
+#endif
+#ifdef FEAT_SESSION
+EXTERN char_u	*p_vdir;	/* 'viewdir' */
+EXTERN char_u	*p_vop;		/* 'viewoptions' */
+EXTERN unsigned	vop_flags;	/* uses SSOP_ flags */
+#endif
+EXTERN int	p_vb;		/* 'visualbell' */
+#ifdef FEAT_VIRTUALEDIT
+EXTERN char_u	*p_ve;		/* 'virtualedit' */
+EXTERN unsigned ve_flags;
+# ifdef IN_OPTION_C
+static char *(p_ve_values[]) = {"block", "insert", "all", "onemore", NULL};
+# endif
+# define VE_BLOCK	5	/* includes "all" */
+# define VE_INSERT	6	/* includes "all" */
+# define VE_ALL		4
+# define VE_ONEMORE	8
+#endif
+EXTERN long	p_verbose;	/* 'verbose' */
+#ifdef IN_OPTION_C
+char_u	*p_vfile = (char_u *)""; /* used before options are initialized */
+#else
+extern char_u	*p_vfile;	/* 'verbosefile' */
+#endif
+EXTERN int	p_warn;		/* 'warn' */
+#ifdef FEAT_CMDL_COMPL
+EXTERN char_u	*p_wop;		/* 'wildoptions' */
+#endif
+EXTERN long	p_window;	/* 'window' */
+#if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(LINT) \
+	|| defined (FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON)
+#define FEAT_WAK
+EXTERN char_u	*p_wak;		/* 'winaltkeys' */
+#endif
+#ifdef FEAT_WILDIGN
+EXTERN char_u	*p_wig;		/* 'wildignore' */
+#endif
+EXTERN int	p_wiv;		/* 'weirdinvert' */
+EXTERN char_u	*p_ww;		/* 'whichwrap' */
+EXTERN long	p_wc;		/* 'wildchar' */
+EXTERN long	p_wcm;		/* 'wildcharm' */
+EXTERN long	p_wic;		/* 'wildignorecase' */
+EXTERN char_u	*p_wim;		/* 'wildmode' */
+#ifdef FEAT_WILDMENU
+EXTERN int	p_wmnu;		/* 'wildmenu' */
+#endif
+EXTERN long	p_wh;		/* 'winheight' */
+EXTERN long	p_wmh;		/* 'winminheight' */
+EXTERN long	p_wmw;		/* 'winminwidth' */
+EXTERN long	p_wiw;		/* 'winwidth' */
+#if defined(WIN3264) && defined(FEAT_TERMINAL)
+EXTERN char_u	*p_winptydll;	/* 'winptydll' */
+#endif
+EXTERN int	p_ws;		/* 'wrapscan' */
+EXTERN int	p_write;	/* 'write' */
+EXTERN int	p_wa;		/* 'writeany' */
+EXTERN int	p_wb;		/* 'writebackup' */
+EXTERN long	p_wd;		/* 'writedelay' */
+
+/*
+ * "indir" values for buffer-local opions.
+ * These need to be defined globally, so that the BV_COUNT can be used with
+ * b_p_scriptID[].
+ */
+enum
+{
+    BV_AI = 0
+    , BV_AR
+    , BV_BH
+    , BV_BKC
+    , BV_BT
+#ifdef FEAT_QUICKFIX
+    , BV_EFM
+    , BV_GP
+    , BV_MP
+#endif
+    , BV_BIN
+    , BV_BL
+#ifdef FEAT_MBYTE
+    , BV_BOMB
+#endif
+    , BV_CI
+#ifdef FEAT_CINDENT
+    , BV_CIN
+    , BV_CINK
+    , BV_CINO
+#endif
+#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
+    , BV_CINW
+#endif
+    , BV_CM
+#ifdef FEAT_FOLDING
+    , BV_CMS
+#endif
+#ifdef FEAT_COMMENTS
+    , BV_COM
+#endif
+#ifdef FEAT_INS_EXPAND
+    , BV_CPT
+    , BV_DICT
+    , BV_TSR
+#endif
+#ifdef FEAT_COMPL_FUNC
+    , BV_CFU
+#endif
+#ifdef FEAT_FIND_ID
+    , BV_DEF
+    , BV_INC
+#endif
+    , BV_EOL
+    , BV_FIXEOL
+    , BV_EP
+    , BV_ET
+    , BV_FENC
+    , BV_FP
+#ifdef FEAT_EVAL
+    , BV_BEXPR
+    , BV_FEX
+#endif
+    , BV_FF
+    , BV_FLP
+    , BV_FO
+    , BV_FT
+    , BV_IMI
+    , BV_IMS
+#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
+    , BV_INDE
+    , BV_INDK
+#endif
+#if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
+    , BV_INEX
+#endif
+    , BV_INF
+    , BV_ISK
+#ifdef FEAT_CRYPT
+    , BV_KEY
+#endif
+#ifdef FEAT_KEYMAP
+    , BV_KMAP
+#endif
+    , BV_KP
+#ifdef FEAT_LISP
+    , BV_LISP
+    , BV_LW
+#endif
+#ifdef FEAT_MBYTE
+    , BV_MENC
+#endif
+    , BV_MA
+    , BV_ML
+    , BV_MOD
+    , BV_MPS
+    , BV_NF
+#ifdef FEAT_COMPL_FUNC
+    , BV_OFU
+#endif
+    , BV_PATH
+    , BV_PI
+#ifdef FEAT_TEXTOBJ
+    , BV_QE
+#endif
+    , BV_RO
+#ifdef FEAT_SMARTINDENT
+    , BV_SI
+#endif
+    , BV_SN
+#ifdef FEAT_SYN_HL
+    , BV_SMC
+    , BV_SYN
+#endif
+#ifdef FEAT_SPELL
+    , BV_SPC
+    , BV_SPF
+    , BV_SPL
+#endif
+    , BV_STS
+#ifdef FEAT_SEARCHPATH
+    , BV_SUA
+#endif
+    , BV_SW
+    , BV_SWF
+    , BV_TAGS
+    , BV_TC
+    , BV_TS
+    , BV_TW
+    , BV_TX
+    , BV_UDF
+    , BV_UL
+    , BV_WM
+#ifdef FEAT_TERMINAL
+    , BV_TWSL
+#endif
+#ifdef FEAT_VARTABS
+    , BV_VSTS
+    , BV_VTS
+#endif
+    , BV_COUNT	    /* must be the last one */
+};
+
+/*
+ * "indir" values for window-local options.
+ * These need to be defined globally, so that the WV_COUNT can be used in the
+ * window structure.
+ */
+enum
+{
+    WV_LIST = 0
+#ifdef FEAT_ARABIC
+    , WV_ARAB
+#endif
+#ifdef FEAT_CONCEAL
+    , WV_COCU
+    , WV_COLE
+#endif
+#ifdef FEAT_TERMINAL
+    , WV_TWK
+    , WV_TWS
+#endif
+    , WV_CRBIND
+#ifdef FEAT_LINEBREAK
+    , WV_BRI
+    , WV_BRIOPT
+#endif
+#ifdef FEAT_DIFF
+    , WV_DIFF
+#endif
+#ifdef FEAT_FOLDING
+    , WV_FDC
+    , WV_FEN
+    , WV_FDI
+    , WV_FDL
+    , WV_FDM
+    , WV_FML
+    , WV_FDN
+# ifdef FEAT_EVAL
+    , WV_FDE
+    , WV_FDT
+# endif
+    , WV_FMR
+#endif
+#ifdef FEAT_LINEBREAK
+    , WV_LBR
+#endif
+    , WV_NU
+    , WV_RNU
+#ifdef FEAT_LINEBREAK
+    , WV_NUW
+#endif
+#if defined(FEAT_QUICKFIX)
+    , WV_PVW
+#endif
+#ifdef FEAT_RIGHTLEFT
+    , WV_RL
+    , WV_RLC
+#endif
+    , WV_SCBIND
+    , WV_SCROLL
+#ifdef FEAT_SPELL
+    , WV_SPELL
+#endif
+#ifdef FEAT_SYN_HL
+    , WV_CUC
+    , WV_CUL
+    , WV_CC
+#endif
+#ifdef FEAT_STL_OPT
+    , WV_STL
+#endif
+    , WV_WFH
+    , WV_WFW
+    , WV_WRAP
+#ifdef FEAT_SIGNS
+    , WV_SCL
+#endif
+    , WV_COUNT	    /* must be the last one */
+};
+
+/* Value for b_p_ul indicating the global value must be used. */
+#define NO_LOCAL_UNDOLEVEL -123456
diff --git a/b/src/os_haiku.h b/src/os_haiku.h
new file mode 100644
index 0000000..c9bfe75
--- /dev/null
+++ b/src/os_haiku.h
@@ -0,0 +1,29 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *		 Haiku port by Siarzhuk Zharski
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * os_haiku.h
+ */
+
+#define USE_TERM_CONSOLE
+
+#define USR_VIM_DIR "$BE_USER_SETTINGS/vim"
+
+#define USR_EXRC_FILE	USR_VIM_DIR "/exrc"
+#define USR_VIMRC_FILE	USR_VIM_DIR "/vimrc"
+#define USR_GVIMRC_FILE	USR_VIM_DIR "/gvimrc"
+#define VIMINFO_FILE	USR_VIM_DIR "/viminfo"
+
+#ifdef RUNTIME_GLOBAL
+# define DFLT_RUNTIMEPATH	USR_VIM_DIR "/vimfiles,"  RUNTIME_GLOBAL \
+			",$VIMRUNTIME," RUNTIME_GLOBAL "/after," USR_VIM_DIR "/vimfiles/after"
+#else
+# define DFLT_RUNTIMEPATH	USR_VIM_DIR "/vimfiles," "$VIM/vimfiles" \
+			",$VIMRUNTIME," "$VIM/vimfiles/after,"   USR_VIM_DIR "/vimfiles/after"
+#endif
diff --git a/b/src/os_haiku.rdef b/src/os_haiku.rdef
new file mode 100644
index 0000000..bf55aa9
--- /dev/null
+++ b/src/os_haiku.rdef
@@ -0,0 +1,143 @@
+/*
+ * os_haiku.rdef
+ */
+
+resource app_signature "application/x-vnd.Haiku-Vim-8";
+
+resource app_version {
+	major  = @MAJOR@,
+	middle = @MIDDLE@,
+	minor  = @MINOR@,
+
+	variety = B_APPV_FINAL,
+	internal = 0,
+
+	short_info = "VIM Editor",
+	long_info = "VI Improved Editor by Bram Moolenaar et al."
+};
+
+resource app_flags B_MULTIPLE_LAUNCH;
+
+resource file_types message {
+	"types" = "text",
+	"types" = "text/plain",
+	"types" = "text/x-source-code",
+	"types" = "text/x-patch",
+	"types" = "text/html",
+	"types" = "text/xml",
+	"types" = "text/x-makefile",
+	"types" = "text/x-jamfile"
+};
+
+resource vector_icon {
+	$"6E636966050501020006023B8CFD3CB8E4BF59B63E2F604BACDB47A13E00FFFF"
+	$"FFFF909DA702000603BAF8BA3CE3F6BF8EB9BDA8484BC75C4AEA1200C1C7CC79"
+	$"D9E0E5FFC1C7CC020006020000003DC000C000000000004C000049FFFF00B3FF"
+	$"B3FF026C52020006023BD04F3BD04FBED4133ED4134B6000462FB00053AB53FF"
+	$"007F00060618FFFCFFFF63FF282528252725262726262627262B262B262C282D"
+	$"272D282D2B2B582B582B592D5A2C5A2D5A2F5A2F5A305ABA2659315ABA26595E"
+	$"2D5E2D5F2C5F2A5F2B5F2A5F275F275F265D255E255D254A254A254925482748"
+	$"264827482B482B482C4A2D492D4A2D4C3A3F2D3C2D3C2D3D2D3E2B3E2C3E2B3E"
+	$"273E273E263C253D253C250618FFFCFFFF63FF28252825272526272626262726"
+	$"2B262B262C282D272D282D2B2B582B582B592D5A2C5A2D5A2F5A2F5A305ABA26"
+	$"59315ABA26595E2D5E2D5F2C5F2A5F2B5F2A5F275F275F265D255E255D254A25"
+	$"4A254925482748264827482B482B482C4A2D492D4A2D4C3A3F2D3C2D3C2D3D2D"
+	$"3E2B3E2C3E2B3E273E273E263C253D253C250A08BEA359BE3D593C5A415AC03B"
+	$"59BFD559434C404C06218A88888888C83E3F02484CC1D359C16D445A49C36B59"
+	$"C305C3CA50C5C8C50359C49D4C5A51C69B59C635C6FA50C8F8C83359C7CD545A"
+	$"59C9CB59C965CA6B4DCA6B4DCA804C5A4C584C584C574CC86D4DC8D34DC86D4D"
+	$"C73B524C534C524C504C504C4F4CC53D4DC5A34DC53D4DC40B4B4C0608EBECC0"
+	$"B64AC0B64AC11C4AC13349C14848C0F847C15E47C0F847C092C01648C02C47C0"
+	$"1648C00149C0504ABFEA4AC0504A0A04405E5E40402222400A0A000105180015"
+	$"01178600040A0001051815FF01178400040A030105000A0401051001157C0004"
+	$"0A000100381D1F001501178600040A000100381D1F15FF01178300040A010101"
+	$"201D1F0A020101301D1F01157E00040A0003020304381D1F15FF01178400040A"
+	$"0203020304281D1F15FF"
+};
+
+resource(1, "builtin-tools") #'PNG ' array {
+	$"89504E470D0A1A0A0000000D494844520000022E0000001208030000004BB3A5"
+	$"1200000300504C5445000000800000008000808000000080800080008080C0C0"
+	$"C0C0DCC0A6CAF0402000602000802000A02000C02000E0200000400020400040"
+	$"4000604000804000A04000C04000E04000006000206000406000606000806000"
+	$"A06000C06000E06000008000208000408000608000808000A08000C08000E080"
+	$"0000A00020A00040A00060A00080A000A0A000C0A000E0A00000C00020C00040"
+	$"C00060C00080C000A0C000C0C000E0C00000E00020E00040E00060E00080E000"
+	$"A0E000C0E000E0E000000040200040400040600040800040A00040C00040E000"
+	$"40002040202040402040602040802040A02040C02040E0204000404020404040"
+	$"4040604040804040A04040C04040E04040006040206040406040606040806040"
+	$"A06040C06040E06040008040208040408040608040808040A08040C08040E080"
+	$"4000A04020A04040A04060A04080A040A0A040C0A040E0A04000C04020C04040"
+	$"C04060C04080C040A0C040C0C040E0C04000E04020E04040E04060E04080E040"
+	$"A0E040C0E040E0E040000080200080400080600080800080A00080C00080E000"
+	$"80002080202080402080602080802080A02080C02080E0208000408020408040"
+	$"4080604080804080A04080C04080E04080006080206080406080606080806080"
+	$"A06080C06080E06080008080208080408080608080808080A08080C08080E080"
+	$"8000A08020A08040A08060A08080A080A0A080C0A080E0A08000C08020C08040"
+	$"C08060C08080C080A0C080C0C080E0C08000E08020E08040E08060E08080E080"
+	$"A0E080C0E080E0E0800000C02000C04000C06000C08000C0A000C0C000C0E000"
+	$"C00020C02020C04020C06020C08020C0A020C0C020C0E020C00040C02040C040"
+	$"40C06040C08040C0A040C0C040C0E040C00060C02060C04060C06060C08060C0"
+	$"A060C0C060C0E060C00080C02080C04080C06080C08080C0A080C0C080C0E080"
+	$"C000A0C020A0C040A0C060A0C080A0C0A0A0C0C0A0C0E0A0C000C0C020C0C040"
+	$"C0C060C0C080C0C0A0C0C0FFFBF0A0A0A4808080FF000000FF00FFFF000000FF"
+	$"FF00FF00FFFFFFFFFF58D234440000000874524E53FFFFFFFFFFFFFF00DE83BD"
+	$"59000000097048597300000B1200000B1201D2DD7EFC0000070D494441546881"
+	$"DD994B6E23390C86695880F6BDCD19BCCD3AD7CA7DB4CD197C965EE7044619D0"
+	$"F0299192AA5C9907D018762776D12A3DA8AF7E520E64B382FFB792FF004BCD4E"
+	$"DF02C1DC0717347779C3FFDB8D5F43A3705900FE8838FCDB868119C3F3E32EDA"
+	$"BB5A1897CA916A1B566CA49DED7865B2E3E930FC6397A9AAEDE232F10409EA37"
+	$"5B851A70793C020BB70C1B8CB4C436057EFFF6BCACE0BD0CAF75159D21567B6D"
+	$"B2BB9EC73AF7E89C21013E3EF03F1A4CD339BDA77E390523594BE549EA7E55DD"
+	$"E8793B68FEF332D4D3BD72BFE1B2D68D19171A87861F37ADB4163A3FEB87E6A7"
+	$"06411B06146E37D8B60D6E9E176C121A212D81976930BAE5C231A657895D5B80"
+	$"8735AE6BD5068729057FCC318FB5183DC682BB8924AC4D5AB456557F9771D647"
+	$"066E0B378A6491FD65381017DDB2793BD2674A9F64E14950CF67DFD8941D3D5D"
+	$"37DA62B1BB1B9ADFE4452BA3B3C41649D58BE6B77E58065C36B3EEC26C856D7A"
+	$"3E2A332ECFA73E3BBD53EE955F5BB8F939B3F85B749D2DDA003A0A5E546B392D"
+	$"6CE11962C1FD4412D6664C01702B990E4FA5C6591F18F4CDF1913475B1597975"
+	$"498A4BB3B632E7EA7B5F5C2E620A83C4C0ED2AFB7BBD4268157191693455129A"
+	$"BF6BD329C265918F461496EAF23219E5E7B3549977BF036FE1DFEDE9ACB2E7FB"
+	$"819736D9B76152F8C7B6B95E5AE06DA99327C682FBF9289E04B46B306D2519AB"
+	$"6480361D9A8ABDC0F291ABFE8271F916D9A849D505432FEA42D3E4965E5D1C2E"
+	$"B486CE463247C025E54159436982B898395C26759970A9BE9386CB948FC64473"
+	$"A676912AC06DFA53E5A51753C0A4D08F17730E6A734C81F7C94853BC3C8AF44B"
+	$"79A9974B5C18EE6573795C86041E49405ACAE68CC72168AEF9FAF686BF4D5DDC"
+	$"74CB98902AB8D7EA70112E0ACE076B1776DEFB7EA4BBE1B2509784893799BCA4"
+	$"76ED71416971BBCEEA623DF1B21197DB50D2840662853E2A2E19E95C2C6883BA"
+	$"A4B6DB63EDB23A19C536BCBF5E5ECAF329F2D22704C221DEE670113016C540DD"
+	$"C18576B7B0BA202CC2CB85B410F9B085F1D5E3228F00F45880CC221891A04EA1"
+	$"E55B7F181705081B15F12C71A9DC41FBC454489B414F4685D0D80A4E3F3E1789"
+	$"9FFA1D7521509ABCC89BF439E2E28B9BA82E0D97F844AD6A17E969D09F1E3448"
+	$"699EA2B0100FC9793C44E7E1B02DA50BA6A3E621655179E9B858FD32D1E11C75"
+	$"74B567B0CB0AC55B4EA37425106AFDEC1D35F2A1692DF24224E8BBB221840117"
+	$"038871F9DEC385122A83AF2E914B6B06E06B17C605E70F776760B8B45A32292E"
+	$"76D01E710907F0E1F4B4A72ECEE3594D417103762C223D688A4B5497391F9CF0"
+	$"80E1622393B290C0607CF2A1BA4CB84CAE6E8A4B257929242EF4CEE078F48599"
+	$"E712F900417117976DC3021AA9907F084703E885BA48426D5955E432F78B880B"
+	$"DD8AFEFB7BB32B182EDD64844299A74CB8D0C1903ED13594A1D47DA12E34B8B7"
+	$"D223E28F0249C5A5056DA52EAEA7AF2FEEE88C87BEA42364DCC83D40D97059D5"
+	$"2E7BC9A8F62D51EBC9A8B2C0DB01C9E8E80BEB7213F880F032E18240081C1D17"
+	$"03E8585D72FE91BA6805E6707987515D4CE9932F598637EECCC7B8F8134D5DA9"
+	$"8BC7E5F1F86A56DCF13AE022EAD282C6B844010CDC15DAFD331EE5C51FA5537D"
+	$"3C727E704A7A3ED9B53A198DA56E0FEB949F7AA92B0072F552A463CA8C7D6156"
+	$"BB0C7CF00E1EE0029BA41E4D47C8E9E6D5E5089755ED62CDD6B80CF21270F9F5"
+	$"ABE3C2E7202970F3E8695B2CEAD28AD81D7571C9E8FEF5B5C4C59BA94B0B9AE0"
+	$"1204D075F478281CAF3DB9A5A3968D522DC8CB0379C1B4C4BCACBF77C9FE201D"
+	$"4F46D666719016846C9D720CF234C8C968E443867BDBC1C578E927A306D0212E"
+	$"35984D09DCC54B5CDEF770E95FB3B883B439CCD3BE7751DD61D3A3D89EBAECE0"
+	$"32ABCB58EA46010C1D8D70EC7A7AADDB78C1D9154E095E5D2EFAAA87AAF990CC"
+	$"59B9D95E1BE0546747EA6CDFBB381AD2E4E158D02ADFDE022F0E17C9A81E5703"
+	$"E8B07681F12EF9C85D2C71C130BAEF78F670B1435083A37DABDB1D599391952F"
+	$"14BA78F0E1DD7500ADE73CE1A20F00DE2B995652909F22DC7B2784C2394FE6BF"
+	$"01683A0237985717AC5D742297A02E1185D196B8F0BBFE374DB730A561F6F458"
+	$"445E3C2E8155C65501A24612D60997D55DAE3399EF1A9769C7965B2867A0E2E2"
+	$"A31E7759F41835B4E9C7A71120F0EA02E51017BA45FF3253665C5C19AB70BCF6"
+	$"642D5B2423411F8C6B97868B8D9E5BED326AB84637E032B5E94A648AED17C634"
+	$"CC1E178B7D5C661302A891ECBE4E07E6591FD81A9781B3A5A339E749F94BFF32"
+	$"75AED701A01D71099DF832450BF94900492EBA3109273CD9FE02C03909FA6024"
+	$"912D194D339C0EC9D6CCAD7AD166F2C485312E93671150B617B88C8D86DC731A"
+	$"1767E7EEF90FEC3599BB77B416E3EAE7689CF114DBE3E262B898CB34FECE845E"
+	$"4CFAEF79764372DC201F65AC97B792C14FE6F387DBB4F83918273C6E9B866FD9"
+	$"FF17F6CF36F92F1B9E631E8B8F3FBC0000000049454E44AE426082"
+};
diff --git a/src/os_unix.h b/src/os_unix.h
index ca2ce70..76eef69 100644
--- a/src/os_unix.h
+++ b/src/os_unix.h
@@ -364,6 +364,8 @@ typedef struct dsc$descriptor   DESC;
 
 #define DFLT_ERRORFILE		"errors.err"
 
+#ifndef DFLT_RUNTIMEPATH
+
 #ifdef VMS
 # define DFLT_RUNTIMEPATH      "sys$login:vimfiles,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,sys$login:vimfiles/after"
 # define CLEAN_RUNTIMEPATH      "$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after"
@@ -377,6 +379,8 @@ typedef struct dsc$descriptor   DESC;
 # endif
 #endif
 
+#endif
+
 #ifdef VMS
 # ifndef VAX
 #  define VMS_TEMPNAM    /* to fix default .LIS extension */
diff --git a/src/osdef1.h.in b/src/osdef1.h.in
index 825fe94..3287761 100644
--- a/src/osdef1.h.in
+++ b/src/osdef1.h.in
@@ -65,7 +65,7 @@ extern void	memmove(char *, char *, int);
 #  endif
 # endif
 #endif
-#ifndef __BIONIC__  // Android's libc #defines bzero to memset.
+#ifndef __HAIKU__
 // used inside of FD_ZERO macro
 extern void	bzero(void *, size_t);
 #endif
diff --git a/src/proto.h b/src/proto.h
index 8570af9..638d140 100644
--- a/src/proto.h
+++ b/src/proto.h
@@ -267,6 +267,9 @@ extern char_u *vimpty_getenv(const char_u *string);	/* in misc2.c */
 extern char *vim_SelFile(Widget toplevel, char *prompt, char *init_path, int (*show_entry)(), int x, int y, guicolor_T fg, guicolor_T bg, guicolor_T scroll_fg, guicolor_T scroll_bg);
 #   endif
 #  endif
+#  ifdef FEAT_GUI_HAIKU
+#   include "gui_haiku.pro"
+#  endif
 #  ifdef FEAT_GUI_MAC
 #   include "gui_mac.pro"
 #  endif
diff --git a/b/src/proto.h.orig b/src/proto.h.orig
new file mode 100644
index 0000000..8570af9
--- /dev/null
+++ b/src/proto.h.orig
@@ -0,0 +1,324 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * proto.h: include the (automatically generated) function prototypes
+ */
+
+/*
+ * Don't include these while generating prototypes.  Prevents problems when
+ * files are missing.
+ */
+#if !defined(PROTO) && !defined(NOPROTO)
+
+/*
+ * Machine-dependent routines.
+ */
+/* avoid errors in function prototypes */
+# if !defined(FEAT_X11) && !defined(FEAT_GUI_GTK)
+#  define Display int
+#  define Widget int
+# endif
+# ifndef FEAT_GUI_GTK
+#  define GdkEvent int
+#  define GdkEventKey int
+# endif
+# ifndef FEAT_X11
+#  define XImage int
+# endif
+
+# ifdef AMIGA
+#  include "os_amiga.pro"
+# endif
+# if defined(UNIX) || defined(VMS)
+#  include "os_unix.pro"
+# endif
+# ifdef WIN3264
+#  include "os_win32.pro"
+#  include "os_mswin.pro"
+#  include "winclip.pro"
+#  if (defined(__GNUC__) && !defined(__MINGW32__)) \
+	|| (defined(__BORLANDC__) && __BORLANDC__ < 0x502)
+extern int _stricoll(char *a, char *b);
+#  endif
+# endif
+# ifdef VMS
+#  include "os_vms.pro"
+# endif
+# ifdef __BEOS__
+#  include "os_beos.pro"
+# endif
+# ifdef __QNX__
+#  include "os_qnx.pro"
+# endif
+
+# ifdef FEAT_CRYPT
+#  include "blowfish.pro"
+#  include "crypt.pro"
+#  include "crypt_zip.pro"
+# endif
+# include "buffer.pro"
+# include "charset.pro"
+# ifdef FEAT_CSCOPE
+#  include "if_cscope.pro"
+# endif
+# include "dict.pro"
+# include "diff.pro"
+# include "digraph.pro"
+# include "edit.pro"
+# include "eval.pro"
+# include "evalfunc.pro"
+# include "ex_cmds.pro"
+# include "ex_cmds2.pro"
+# include "ex_docmd.pro"
+# include "ex_eval.pro"
+# include "ex_getln.pro"
+# include "fileio.pro"
+# include "fold.pro"
+# include "getchar.pro"
+# ifdef FEAT_HANGULIN
+#  include "hangulin.pro"
+# endif
+# include "hardcopy.pro"
+# include "hashtab.pro"
+# include "json.pro"
+# include "list.pro"
+# include "main.pro"
+# include "mark.pro"
+# include "memfile.pro"
+# include "memline.pro"
+# ifdef FEAT_MENU
+#  include "menu.pro"
+# endif
+# ifdef FEAT_FKMAP
+#  include "farsi.pro"
+# endif
+# ifdef FEAT_ARABIC
+#  include "arabic.pro"
+# endif
+
+/* These prototypes cannot be produced automatically. */
+int
+#  ifdef __BORLANDC__
+_RTLENTRYF
+#  endif
+smsg(char_u *, ...);
+
+int
+#  ifdef __BORLANDC__
+_RTLENTRYF
+#  endif
+smsg_attr(int, char_u *, ...);
+
+int
+#  ifdef __BORLANDC__
+_RTLENTRYF
+#  endif
+smsg_attr_keep(int, char_u *, ...);
+
+int
+#  ifdef __BORLANDC__
+_RTLENTRYF
+#  endif
+vim_snprintf_add(char *, size_t, char *, ...)
+#ifdef USE_PRINTF_FORMAT_ATTRIBUTE
+    __attribute__((format(printf, 3, 4)))
+#endif
+    ;
+
+int
+#  ifdef __BORLANDC__
+_RTLENTRYF
+#  endif
+vim_snprintf(char *, size_t, char *, ...)
+#ifdef USE_PRINTF_FORMAT_ATTRIBUTE
+    __attribute__((format(printf, 3, 4)))
+#endif
+    ;
+
+int vim_vsnprintf(char *str, size_t str_m, char *fmt, va_list ap);
+int vim_vsnprintf_typval(char *str, size_t str_m, char *fmt, va_list ap, typval_T *tvs);
+
+# include "message.pro"
+# include "misc1.pro"
+# include "misc2.pro"
+#ifndef HAVE_STRPBRK	    /* not generated automatically from misc2.c */
+char_u *vim_strpbrk(char_u *s, char_u *charset);
+#endif
+#ifndef HAVE_QSORT
+/* Use our own qsort(), don't define the prototype when not used. */
+void qsort(void *base, size_t elm_count, size_t elm_size, int (*cmp)(const void *, const void *));
+#endif
+# include "move.pro"
+# if defined(FEAT_MBYTE) || defined(FEAT_XIM) || defined(FEAT_KEYMAP) \
+	|| defined(FEAT_POSTSCRIPT)
+#  include "mbyte.pro"
+# endif
+# include "normal.pro"
+# include "ops.pro"
+# include "option.pro"
+# include "popupmnu.pro"
+# ifdef FEAT_QUICKFIX
+#  include "quickfix.pro"
+# endif
+# include "regexp.pro"
+# include "screen.pro"
+# if defined(FEAT_CRYPT) || defined(FEAT_PERSISTENT_UNDO)
+#  include "sha256.pro"
+# endif
+# include "search.pro"
+# include "spell.pro"
+# include "spellfile.pro"
+# include "syntax.pro"
+# include "tag.pro"
+# include "term.pro"
+# ifdef FEAT_TERMINAL
+#  include "terminal.pro"
+# endif
+# if defined(HAVE_TGETENT) && (defined(AMIGA) || defined(VMS))
+#  include "termlib.pro"
+# endif
+# include "ui.pro"
+# include "undo.pro"
+# include "userfunc.pro"
+# include "version.pro"
+# include "window.pro"
+
+# ifdef FEAT_LUA
+#  include "if_lua.pro"
+# endif
+
+# ifdef FEAT_MZSCHEME
+#  include "if_mzsch.pro"
+# endif
+
+# ifdef FEAT_PYTHON
+#  include "if_python.pro"
+# endif
+
+# ifdef FEAT_PYTHON3
+#  include "if_python3.pro"
+# endif
+
+# ifdef FEAT_TCL
+#  include "if_tcl.pro"
+# endif
+
+# ifdef FEAT_RUBY
+#  include "if_ruby.pro"
+# endif
+
+/* Ugly solution for "BalloonEval" not being defined while it's used in some
+ * .pro files. */
+# ifdef FEAT_BEVAL
+#  include "beval.pro"
+# else
+#  define BalloonEval int
+# endif
+
+# ifdef FEAT_NETBEANS_INTG
+#  include "netbeans.pro"
+# endif
+# ifdef FEAT_JOB_CHANNEL
+#  include "channel.pro"
+
+/* Not generated automatically, to add extra attribute. */
+void ch_log(channel_T *ch, const char *fmt, ...)
+#ifdef USE_PRINTF_FORMAT_ATTRIBUTE
+    __attribute__((format(printf, 2, 3)))
+#endif
+    ;
+
+# endif
+
+# if defined(FEAT_GUI) || defined(FEAT_JOB_CHANNEL)
+#  if defined(UNIX) || defined(MACOS_X)
+#   include "pty.pro"
+#  endif
+# endif
+
+# ifdef FEAT_GUI
+#  include "gui.pro"
+#  if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV) && !defined(VMS)
+extern int putenv(const char *string);			/* in misc2.c */
+#   ifdef USE_VIMPTY_GETENV
+extern char_u *vimpty_getenv(const char_u *string);	/* in misc2.c */
+#   endif
+#  endif
+#  ifdef FEAT_GUI_W32
+#   include "gui_w32.pro"
+#  endif
+#  ifdef FEAT_GUI_GTK
+#   include "gui_gtk.pro"
+#   include "gui_gtk_x11.pro"
+#  endif
+#  ifdef FEAT_GUI_MOTIF
+#   include "gui_motif.pro"
+#   include "gui_xmdlg.pro"
+#  endif
+#  ifdef FEAT_GUI_ATHENA
+#   include "gui_athena.pro"
+#   ifdef FEAT_BROWSE
+extern char *vim_SelFile(Widget toplevel, char *prompt, char *init_path, int (*show_entry)(), int x, int y, guicolor_T fg, guicolor_T bg, guicolor_T scroll_fg, guicolor_T scroll_bg);
+#   endif
+#  endif
+#  ifdef FEAT_GUI_MAC
+#   include "gui_mac.pro"
+#  endif
+#  ifdef FEAT_GUI_X11
+#   include "gui_x11.pro"
+#  endif
+#  ifdef FEAT_GUI_PHOTON
+#   include "gui_photon.pro"
+#  endif
+#  ifdef FEAT_SUN_WORKSHOP
+#   include "workshop.pro"
+#  endif
+# endif	/* FEAT_GUI */
+
+# ifdef FEAT_OLE
+#  include "if_ole.pro"
+# endif
+# if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)
+#  include "if_xcmdsrv.pro"
+# endif
+
+/*
+ * The perl include files pollute the namespace, therefore proto.h must be
+ * included before the perl include files.  But then CV is not defined, which
+ * is used in if_perl.pro.  To get around this, the perl prototype files are
+ * not included here for the perl files.  Use a dummy define for CV for the
+ * other files.
+ */
+#if defined(FEAT_PERL) && !defined(IN_PERL_FILE)
+# define CV void
+# ifdef __BORLANDC__
+  #pragma option -pc
+# endif
+# include "if_perl.pro"
+# ifdef __BORLANDC__
+  #pragma option -p.
+# endif
+# include "if_perlsfio.pro"
+#endif
+
+#ifdef MACOS_CONVERT
+# include "os_mac_conv.pro"
+#endif
+#if defined(MACOS_X_DARWIN) && defined(FEAT_CLIPBOARD) && !defined(FEAT_GUI)
+/* functions in os_macosx.m */
+void clip_mch_lose_selection(VimClipboard *cbd);
+int clip_mch_own_selection(VimClipboard *cbd);
+void clip_mch_request_selection(VimClipboard *cbd);
+void clip_mch_set_selection(VimClipboard *cbd);
+#endif
+
+#ifdef __BORLANDC__
+# define _PROTO_H
+#endif
+#endif /* !PROTO && !NOPROTO */
diff --git a/src/screen.c b/src/screen.c
index 743c321..a32f4e0 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -89,6 +89,15 @@
 
 #include "vim.h"
 
+#ifdef __HAIKU__
+// FIXME!!!
+    int
+gui_mch_is_blink_off(void)
+{
+    return FALSE;
+}
+#endif
+
 #define MB_FILLER_CHAR '<'  /* character used when a double-width character
 			     * doesn't fit. */
 
@@ -8856,6 +8865,10 @@ retry:
 
     win_new_shellsize();    /* fit the windows in the new sized shell */
 
+#ifdef FEAT_GUI_HAIKU
+    vim_lock_screen();  /* be safe, put it here */
+#endif
+
     comp_col();		/* recompute columns for shown command and ruler */
 
     /*
@@ -9073,6 +9086,10 @@ give_up:
     }
 #endif
 
+#ifdef FEAT_GUI_HAIKU
+    vim_unlock_screen();
+#endif
+
     entered = FALSE;
     --RedrawingDisabled;
 
@@ -9916,6 +9933,10 @@ screen_ins_lines(
 	clip_scroll_selection(-line_count);
 #endif
 
+#ifdef FEAT_GUI_HAIKU
+    vim_lock_screen();
+#endif
+
 #ifdef FEAT_GUI
     /* Don't update the GUI cursor here, ScreenLines[] is invalid until the
      * scrolling is actually carried out. */
@@ -9970,6 +9991,10 @@ screen_ins_lines(
 	}
     }
 
+#ifdef FEAT_GUI_HAIKU
+    vim_unlock_screen();
+#endif
+
     screen_stop_highlight();
     windgoto(cursor_row, cursor_col);
     if (clear_attr != 0)
@@ -10136,6 +10161,10 @@ screen_del_lines(
 	clip_scroll_selection(line_count);
 #endif
 
+#ifdef FEAT_GUI_HAIKU
+    vim_lock_screen();
+#endif
+
 #ifdef FEAT_GUI
     /* Don't update the GUI cursor here, ScreenLines[] is invalid until the
      * scrolling is actually carried out. */
@@ -10198,6 +10227,10 @@ screen_del_lines(
 	}
     }
 
+#ifdef FEAT_GUI_HAIKU
+    vim_unlock_screen();
+#endif
+
     if (screen_attr != clear_attr)
 	screen_stop_highlight();
     if (clear_attr != 0)
diff --git a/b/src/screen.c.orig b/src/screen.c.orig
new file mode 100644
index 0000000..743c321
--- /dev/null
+++ b/src/screen.c.orig
@@ -0,0 +1,11196 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * screen.c: code for displaying on the screen
+ *
+ * Output to the screen (console, terminal emulator or GUI window) is minimized
+ * by remembering what is already on the screen, and only updating the parts
+ * that changed.
+ *
+ * ScreenLines[off]  Contains a copy of the whole screen, as it is currently
+ *		     displayed (excluding text written by external commands).
+ * ScreenAttrs[off]  Contains the associated attributes.
+ * LineOffset[row]   Contains the offset into ScreenLines*[] and ScreenAttrs[]
+ *		     for each line.
+ * LineWraps[row]    Flag for each line whether it wraps to the next line.
+ *
+ * For double-byte characters, two consecutive bytes in ScreenLines[] can form
+ * one character which occupies two display cells.
+ * For UTF-8 a multi-byte character is converted to Unicode and stored in
+ * ScreenLinesUC[].  ScreenLines[] contains the first byte only.  For an ASCII
+ * character without composing chars ScreenLinesUC[] will be 0 and
+ * ScreenLinesC[][] is not used.  When the character occupies two display
+ * cells the next byte in ScreenLines[] is 0.
+ * ScreenLinesC[][] contain up to 'maxcombine' composing characters
+ * (drawn on top of the first character).  There is 0 after the last one used.
+ * ScreenLines2[] is only used for euc-jp to store the second byte if the
+ * first byte is 0x8e (single-width character).
+ *
+ * The screen_*() functions write to the screen and handle updating
+ * ScreenLines[].
+ *
+ * update_screen() is the function that updates all windows and status lines.
+ * It is called form the main loop when must_redraw is non-zero.  It may be
+ * called from other places when an immediate screen update is needed.
+ *
+ * The part of the buffer that is displayed in a window is set with:
+ * - w_topline (first buffer line in window)
+ * - w_topfill (filler lines above the first line)
+ * - w_leftcol (leftmost window cell in window),
+ * - w_skipcol (skipped window cells of first line)
+ *
+ * Commands that only move the cursor around in a window, do not need to take
+ * action to update the display.  The main loop will check if w_topline is
+ * valid and update it (scroll the window) when needed.
+ *
+ * Commands that scroll a window change w_topline and must call
+ * check_cursor() to move the cursor into the visible part of the window, and
+ * call redraw_later(VALID) to have the window displayed by update_screen()
+ * later.
+ *
+ * Commands that change text in the buffer must call changed_bytes() or
+ * changed_lines() to mark the area that changed and will require updating
+ * later.  The main loop will call update_screen(), which will update each
+ * window that shows the changed buffer.  This assumes text above the change
+ * can remain displayed as it is.  Text after the change may need updating for
+ * scrolling, folding and syntax highlighting.
+ *
+ * Commands that change how a window is displayed (e.g., setting 'list') or
+ * invalidate the contents of a window in another way (e.g., change fold
+ * settings), must call redraw_later(NOT_VALID) to have the whole window
+ * redisplayed by update_screen() later.
+ *
+ * Commands that change how a buffer is displayed (e.g., setting 'tabstop')
+ * must call redraw_curbuf_later(NOT_VALID) to have all the windows for the
+ * buffer redisplayed by update_screen() later.
+ *
+ * Commands that change highlighting and possibly cause a scroll too must call
+ * redraw_later(SOME_VALID) to update the whole window but still use scrolling
+ * to avoid redrawing everything.  But the length of displayed lines must not
+ * change, use NOT_VALID then.
+ *
+ * Commands that move the window position must call redraw_later(NOT_VALID).
+ * TODO: should minimize redrawing by scrolling when possible.
+ *
+ * Commands that change everything (e.g., resizing the screen) must call
+ * redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).
+ *
+ * Things that are handled indirectly:
+ * - When messages scroll the screen up, msg_scrolled will be set and
+ *   update_screen() called to redraw.
+ */
+
+#include "vim.h"
+
+#define MB_FILLER_CHAR '<'  /* character used when a double-width character
+			     * doesn't fit. */
+
+/*
+ * The attributes that are actually active for writing to the screen.
+ */
+static int	screen_attr = 0;
+
+/*
+ * Positioning the cursor is reduced by remembering the last position.
+ * Mostly used by windgoto() and screen_char().
+ */
+static int	screen_cur_row, screen_cur_col;	/* last known cursor position */
+
+#ifdef FEAT_SEARCH_EXTRA
+static match_T search_hl;	/* used for 'hlsearch' highlight matching */
+#endif
+
+#if defined(FEAT_MENU) || defined(FEAT_FOLDING)
+static int text_to_screenline(win_T *wp, char_u *text, int col);
+#endif
+#ifdef FEAT_FOLDING
+static foldinfo_T win_foldinfo;	/* info for 'foldcolumn' */
+static int compute_foldcolumn(win_T *wp, int col);
+#endif
+
+/* Flag that is set when drawing for a callback, not from the main command
+ * loop. */
+static int redrawing_for_callback = 0;
+
+/*
+ * Buffer for one screen line (characters and attributes).
+ */
+static schar_T	*current_ScreenLine;
+
+static void win_update(win_T *wp);
+static void win_redr_status(win_T *wp, int ignore_pum);
+static void win_draw_end(win_T *wp, int c1, int c2, int row, int endrow, hlf_T hl);
+#ifdef FEAT_FOLDING
+static void fold_line(win_T *wp, long fold_count, foldinfo_T *foldinfo, linenr_T lnum, int row);
+static void fill_foldcolumn(char_u *p, win_T *wp, int closed, linenr_T lnum);
+static void copy_text_attr(int off, char_u *buf, int len, int attr);
+#endif
+static int win_line(win_T *, linenr_T, int, int, int nochange);
+static int char_needs_redraw(int off_from, int off_to, int cols);
+static void draw_vsep_win(win_T *wp, int row);
+#ifdef FEAT_STL_OPT
+static void redraw_custom_statusline(win_T *wp);
+#endif
+#ifdef FEAT_SEARCH_EXTRA
+# define SEARCH_HL_PRIORITY 0
+static void start_search_hl(void);
+static void end_search_hl(void);
+static void init_search_hl(win_T *wp);
+static void prepare_search_hl(win_T *wp, linenr_T lnum);
+static void next_search_hl(win_T *win, match_T *shl, linenr_T lnum, colnr_T mincol, matchitem_T *cur);
+static int next_search_hl_pos(match_T *shl, linenr_T lnum, posmatch_T *pos, colnr_T mincol);
+#endif
+static void screen_start_highlight(int attr);
+static void screen_char(unsigned off, int row, int col);
+#ifdef FEAT_MBYTE
+static void screen_char_2(unsigned off, int row, int col);
+#endif
+static void screenclear2(void);
+static void lineclear(unsigned off, int width, int attr);
+static void lineinvalid(unsigned off, int width);
+static void linecopy(int to, int from, win_T *wp);
+static void redraw_block(int row, int end, win_T *wp);
+static int win_do_lines(win_T *wp, int row, int line_count, int mayclear, int del, int clear_attr);
+static void win_rest_invalid(win_T *wp);
+static void msg_pos_mode(void);
+static void recording_mode(int attr);
+static void draw_tabline(void);
+static int fillchar_status(int *attr, win_T *wp);
+static int fillchar_vsep(int *attr);
+#ifdef FEAT_MENU
+static void redraw_win_toolbar(win_T *wp);
+#endif
+#ifdef FEAT_STL_OPT
+static void win_redr_custom(win_T *wp, int draw_ruler);
+#endif
+#ifdef FEAT_CMDL_INFO
+static void win_redr_ruler(win_T *wp, int always, int ignore_pum);
+#endif
+
+/* Ugly global: overrule attribute used by screen_char() */
+static int screen_char_attr = 0;
+
+#if defined(FEAT_SYN_HL) && defined(FEAT_RELTIME)
+/* Can limit syntax highlight time to 'redrawtime'. */
+# define SYN_TIME_LIMIT 1
+#endif
+
+#ifdef FEAT_RIGHTLEFT
+# define HAS_RIGHTLEFT(x) x
+#else
+# define HAS_RIGHTLEFT(x) FALSE
+#endif
+
+/*
+ * Redraw the current window later, with update_screen(type).
+ * Set must_redraw only if not already set to a higher value.
+ * e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.
+ */
+    void
+redraw_later(int type)
+{
+    redraw_win_later(curwin, type);
+}
+
+    void
+redraw_win_later(
+    win_T	*wp,
+    int		type)
+{
+    if (!exiting && wp->w_redr_type < type)
+    {
+	wp->w_redr_type = type;
+	if (type >= NOT_VALID)
+	    wp->w_lines_valid = 0;
+	if (must_redraw < type)	/* must_redraw is the maximum of all windows */
+	    must_redraw = type;
+    }
+}
+
+/*
+ * Force a complete redraw later.  Also resets the highlighting.  To be used
+ * after executing a shell command that messes up the screen.
+ */
+    void
+redraw_later_clear(void)
+{
+    redraw_all_later(CLEAR);
+#ifdef FEAT_GUI
+    if (gui.in_use)
+	/* Use a code that will reset gui.highlight_mask in
+	 * gui_stop_highlight(). */
+	screen_attr = HL_ALL + 1;
+    else
+#endif
+	/* Use attributes that is very unlikely to appear in text. */
+	screen_attr = HL_BOLD | HL_UNDERLINE | HL_INVERSE | HL_STRIKETHROUGH;
+}
+
+/*
+ * Mark all windows to be redrawn later.
+ */
+    void
+redraw_all_later(int type)
+{
+    win_T	*wp;
+
+    FOR_ALL_WINDOWS(wp)
+    {
+	redraw_win_later(wp, type);
+    }
+}
+
+/*
+ * Mark all windows that are editing the current buffer to be updated later.
+ */
+    void
+redraw_curbuf_later(int type)
+{
+    redraw_buf_later(curbuf, type);
+}
+
+    void
+redraw_buf_later(buf_T *buf, int type)
+{
+    win_T	*wp;
+
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp->w_buffer == buf)
+	    redraw_win_later(wp, type);
+    }
+}
+
+    void
+redraw_buf_and_status_later(buf_T *buf, int type)
+{
+    win_T	*wp;
+
+#ifdef FEAT_WILDMENU
+    if (wild_menu_showing != 0)
+	/* Don't redraw while the command line completion is displayed, it
+	 * would disappear. */
+	return;
+#endif
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp->w_buffer == buf)
+	{
+	    redraw_win_later(wp, type);
+	    wp->w_redr_status = TRUE;
+	}
+    }
+}
+
+/*
+ * Redraw as soon as possible.  When the command line is not scrolled redraw
+ * right away and restore what was on the command line.
+ * Return a code indicating what happened.
+ */
+    int
+redraw_asap(int type)
+{
+    int		rows;
+    int		cols = screen_Columns;
+    int		r;
+    int		ret = 0;
+    schar_T	*screenline;	/* copy from ScreenLines[] */
+    sattr_T	*screenattr;	/* copy from ScreenAttrs[] */
+#ifdef FEAT_MBYTE
+    int		i;
+    u8char_T	*screenlineUC = NULL;	/* copy from ScreenLinesUC[] */
+    u8char_T	*screenlineC[MAX_MCO];	/* copy from ScreenLinesC[][] */
+    schar_T	*screenline2 = NULL;	/* copy from ScreenLines2[] */
+#endif
+
+    redraw_later(type);
+    if (msg_scrolled || (State != NORMAL && State != NORMAL_BUSY) || exiting)
+	return ret;
+
+    /* Allocate space to save the text displayed in the command line area. */
+    rows = screen_Rows - cmdline_row;
+    screenline = (schar_T *)lalloc(
+			   (long_u)(rows * cols * sizeof(schar_T)), FALSE);
+    screenattr = (sattr_T *)lalloc(
+			   (long_u)(rows * cols * sizeof(sattr_T)), FALSE);
+    if (screenline == NULL || screenattr == NULL)
+	ret = 2;
+#ifdef FEAT_MBYTE
+    if (enc_utf8)
+    {
+	screenlineUC = (u8char_T *)lalloc(
+			  (long_u)(rows * cols * sizeof(u8char_T)), FALSE);
+	if (screenlineUC == NULL)
+	    ret = 2;
+	for (i = 0; i < p_mco; ++i)
+	{
+	    screenlineC[i] = (u8char_T *)lalloc(
+			  (long_u)(rows * cols * sizeof(u8char_T)), FALSE);
+	    if (screenlineC[i] == NULL)
+		ret = 2;
+	}
+    }
+    if (enc_dbcs == DBCS_JPNU)
+    {
+	screenline2 = (schar_T *)lalloc(
+			   (long_u)(rows * cols * sizeof(schar_T)), FALSE);
+	if (screenline2 == NULL)
+	    ret = 2;
+    }
+#endif
+
+    if (ret != 2)
+    {
+	/* Save the text displayed in the command line area. */
+	for (r = 0; r < rows; ++r)
+	{
+	    mch_memmove(screenline + r * cols,
+			ScreenLines + LineOffset[cmdline_row + r],
+			(size_t)cols * sizeof(schar_T));
+	    mch_memmove(screenattr + r * cols,
+			ScreenAttrs + LineOffset[cmdline_row + r],
+			(size_t)cols * sizeof(sattr_T));
+#ifdef FEAT_MBYTE
+	    if (enc_utf8)
+	    {
+		mch_memmove(screenlineUC + r * cols,
+			    ScreenLinesUC + LineOffset[cmdline_row + r],
+			    (size_t)cols * sizeof(u8char_T));
+		for (i = 0; i < p_mco; ++i)
+		    mch_memmove(screenlineC[i] + r * cols,
+				ScreenLinesC[i] + LineOffset[cmdline_row + r],
+				(size_t)cols * sizeof(u8char_T));
+	    }
+	    if (enc_dbcs == DBCS_JPNU)
+		mch_memmove(screenline2 + r * cols,
+			    ScreenLines2 + LineOffset[cmdline_row + r],
+			    (size_t)cols * sizeof(schar_T));
+#endif
+	}
+
+	update_screen(0);
+	ret = 3;
+
+	if (must_redraw == 0)
+	{
+	    int	off = (int)(current_ScreenLine - ScreenLines);
+
+	    /* Restore the text displayed in the command line area. */
+	    for (r = 0; r < rows; ++r)
+	    {
+		mch_memmove(current_ScreenLine,
+			    screenline + r * cols,
+			    (size_t)cols * sizeof(schar_T));
+		mch_memmove(ScreenAttrs + off,
+			    screenattr + r * cols,
+			    (size_t)cols * sizeof(sattr_T));
+#ifdef FEAT_MBYTE
+		if (enc_utf8)
+		{
+		    mch_memmove(ScreenLinesUC + off,
+				screenlineUC + r * cols,
+				(size_t)cols * sizeof(u8char_T));
+		    for (i = 0; i < p_mco; ++i)
+			mch_memmove(ScreenLinesC[i] + off,
+				    screenlineC[i] + r * cols,
+				    (size_t)cols * sizeof(u8char_T));
+		}
+		if (enc_dbcs == DBCS_JPNU)
+		    mch_memmove(ScreenLines2 + off,
+				screenline2 + r * cols,
+				(size_t)cols * sizeof(schar_T));
+#endif
+		screen_line(cmdline_row + r, 0, cols, cols, FALSE);
+	    }
+	    ret = 4;
+	}
+    }
+
+    vim_free(screenline);
+    vim_free(screenattr);
+#ifdef FEAT_MBYTE
+    if (enc_utf8)
+    {
+	vim_free(screenlineUC);
+	for (i = 0; i < p_mco; ++i)
+	    vim_free(screenlineC[i]);
+    }
+    if (enc_dbcs == DBCS_JPNU)
+	vim_free(screenline2);
+#endif
+
+    /* Show the intro message when appropriate. */
+    maybe_intro_message();
+
+    setcursor();
+
+    return ret;
+}
+
+/*
+ * Invoked after an asynchronous callback is called.
+ * If an echo command was used the cursor needs to be put back where
+ * it belongs. If highlighting was changed a redraw is needed.
+ * If "call_update_screen" is FALSE don't call update_screen() when at the
+ * command line.
+ */
+    void
+redraw_after_callback(int call_update_screen)
+{
+    ++redrawing_for_callback;
+
+    if (State == HITRETURN || State == ASKMORE)
+	; // do nothing
+    else if (State & CMDLINE)
+    {
+	// Don't redraw when in prompt_for_number().
+	if (cmdline_row > 0)
+	{
+	    // Redrawing only works when the screen didn't scroll. Don't clear
+	    // wildmenu entries.
+	    if (msg_scrolled == 0
+#ifdef FEAT_WILDMENU
+		    && wild_menu_showing == 0
+#endif
+		    && call_update_screen)
+		update_screen(0);
+
+	    // Redraw in the same position, so that the user can continue
+	    // editing the command.
+	    redrawcmdline_ex(FALSE);
+	}
+    }
+    else if (State & (NORMAL | INSERT | TERMINAL))
+    {
+	// keep the command line if possible
+	update_screen(VALID_NO_UPDATE);
+	setcursor();
+    }
+    cursor_on();
+#ifdef FEAT_GUI
+    if (gui.in_use && !gui_mch_is_blink_off())
+	// Don't update the cursor when it is blinking and off to avoid
+	// flicker.
+	out_flush_cursor(FALSE, FALSE);
+    else
+#endif
+	out_flush();
+
+    --redrawing_for_callback;
+}
+
+/*
+ * Changed something in the current window, at buffer line "lnum", that
+ * requires that line and possibly other lines to be redrawn.
+ * Used when entering/leaving Insert mode with the cursor on a folded line.
+ * Used to remove the "$" from a change command.
+ * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
+ * may become invalid and the whole window will have to be redrawn.
+ */
+    void
+redrawWinline(
+    linenr_T	lnum,
+    int		invalid UNUSED)	/* window line height is invalid now */
+{
+#ifdef FEAT_FOLDING
+    int		i;
+#endif
+
+    if (curwin->w_redraw_top == 0 || curwin->w_redraw_top > lnum)
+	curwin->w_redraw_top = lnum;
+    if (curwin->w_redraw_bot == 0 || curwin->w_redraw_bot < lnum)
+	curwin->w_redraw_bot = lnum;
+    redraw_later(VALID);
+
+#ifdef FEAT_FOLDING
+    if (invalid)
+    {
+	/* A w_lines[] entry for this lnum has become invalid. */
+	i = find_wl_entry(curwin, lnum);
+	if (i >= 0)
+	    curwin->w_lines[i].wl_valid = FALSE;
+    }
+#endif
+}
+
+    void
+reset_updating_screen(int may_resize_shell UNUSED)
+{
+    updating_screen = FALSE;
+#ifdef FEAT_GUI
+    if (may_resize_shell)
+	gui_may_resize_shell();
+#endif
+#ifdef FEAT_TERMINAL
+    term_check_channel_closed_recently();
+#endif
+
+#ifdef HAVE_DROP_FILE
+    // If handle_drop() was called while updating_screen was TRUE need to
+    // handle the drop now.
+    handle_any_postponed_drop();
+#endif
+}
+
+/*
+ * Update all windows that are editing the current buffer.
+ */
+    void
+update_curbuf(int type)
+{
+    redraw_curbuf_later(type);
+    update_screen(type);
+}
+
+/*
+ * Based on the current value of curwin->w_topline, transfer a screenfull
+ * of stuff from Filemem to ScreenLines[], and update curwin->w_botline.
+ * Return OK when the screen was updated, FAIL if it was not done.
+ */
+    int
+update_screen(int type_arg)
+{
+    int		type = type_arg;
+    win_T	*wp;
+    static int	did_intro = FALSE;
+#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
+    int		did_one;
+#endif
+#ifdef FEAT_GUI
+    int		did_undraw = FALSE;
+    int		gui_cursor_col;
+    int		gui_cursor_row;
+#endif
+    int		no_update = FALSE;
+
+    /* Don't do anything if the screen structures are (not yet) valid. */
+    if (!screen_valid(TRUE))
+	return FAIL;
+
+    if (type == VALID_NO_UPDATE)
+    {
+	no_update = TRUE;
+	type = 0;
+    }
+
+    if (must_redraw)
+    {
+	if (type < must_redraw)	    /* use maximal type */
+	    type = must_redraw;
+
+	/* must_redraw is reset here, so that when we run into some weird
+	 * reason to redraw while busy redrawing (e.g., asynchronous
+	 * scrolling), or update_topline() in win_update() will cause a
+	 * scroll, the screen will be redrawn later or in win_update(). */
+	must_redraw = 0;
+    }
+
+    /* May need to update w_lines[]. */
+    if (curwin->w_lines_valid == 0 && type < NOT_VALID
+#ifdef FEAT_TERMINAL
+	    && !term_do_update_window(curwin)
+#endif
+		)
+	type = NOT_VALID;
+
+    /* Postpone the redrawing when it's not needed and when being called
+     * recursively. */
+    if (!redrawing() || updating_screen)
+    {
+	redraw_later(type);		/* remember type for next time */
+	must_redraw = type;
+	if (type > INVERTED_ALL)
+	    curwin->w_lines_valid = 0;	/* don't use w_lines[].wl_size now */
+	return FAIL;
+    }
+
+    updating_screen = TRUE;
+#ifdef FEAT_SYN_HL
+    ++display_tick;	    /* let syntax code know we're in a next round of
+			     * display updating */
+#endif
+    if (no_update)
+	++no_win_do_lines_ins;
+
+    /*
+     * if the screen was scrolled up when displaying a message, scroll it down
+     */
+    if (msg_scrolled)
+    {
+	clear_cmdline = TRUE;
+	if (msg_scrolled > Rows - 5)	    /* clearing is faster */
+	    type = CLEAR;
+	else if (type != CLEAR)
+	{
+	    check_for_delay(FALSE);
+	    if (screen_ins_lines(0, 0, msg_scrolled, (int)Rows, 0, NULL)
+								       == FAIL)
+		type = CLEAR;
+	    FOR_ALL_WINDOWS(wp)
+	    {
+		if (W_WINROW(wp) < msg_scrolled)
+		{
+		    if (W_WINROW(wp) + wp->w_height > msg_scrolled
+			    && wp->w_redr_type < REDRAW_TOP
+			    && wp->w_lines_valid > 0
+			    && wp->w_topline == wp->w_lines[0].wl_lnum)
+		    {
+			wp->w_upd_rows = msg_scrolled - W_WINROW(wp);
+			wp->w_redr_type = REDRAW_TOP;
+		    }
+		    else
+		    {
+			wp->w_redr_type = NOT_VALID;
+			if (W_WINROW(wp) + wp->w_height + wp->w_status_height
+							       <= msg_scrolled)
+			    wp->w_redr_status = TRUE;
+		    }
+		}
+	    }
+	    if (!no_update)
+		redraw_cmdline = TRUE;
+	    redraw_tabline = TRUE;
+	}
+	msg_scrolled = 0;
+	need_wait_return = FALSE;
+    }
+
+    /* reset cmdline_row now (may have been changed temporarily) */
+    compute_cmdrow();
+
+    /* Check for changed highlighting */
+    if (need_highlight_changed)
+	highlight_changed();
+
+    if (type == CLEAR)		/* first clear screen */
+    {
+	screenclear();		/* will reset clear_cmdline */
+	type = NOT_VALID;
+	/* must_redraw may be set indirectly, avoid another redraw later */
+	must_redraw = 0;
+    }
+
+    if (clear_cmdline)		/* going to clear cmdline (done below) */
+	check_for_delay(FALSE);
+
+#ifdef FEAT_LINEBREAK
+    /* Force redraw when width of 'number' or 'relativenumber' column
+     * changes. */
+    if (curwin->w_redr_type < NOT_VALID
+	   && curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)
+				    ? number_width(curwin) : 0))
+	curwin->w_redr_type = NOT_VALID;
+#endif
+
+    /*
+     * Only start redrawing if there is really something to do.
+     */
+    if (type == INVERTED)
+	update_curswant();
+    if (curwin->w_redr_type < type
+	    && !((type == VALID
+		    && curwin->w_lines[0].wl_valid
+#ifdef FEAT_DIFF
+		    && curwin->w_topfill == curwin->w_old_topfill
+		    && curwin->w_botfill == curwin->w_old_botfill
+#endif
+		    && curwin->w_topline == curwin->w_lines[0].wl_lnum)
+		|| (type == INVERTED
+		    && VIsual_active
+		    && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum
+		    && curwin->w_old_visual_mode == VIsual_mode
+		    && (curwin->w_valid & VALID_VIRTCOL)
+		    && curwin->w_old_curswant == curwin->w_curswant)
+		))
+	curwin->w_redr_type = type;
+
+    /* Redraw the tab pages line if needed. */
+    if (redraw_tabline || type >= NOT_VALID)
+	draw_tabline();
+
+#ifdef FEAT_SYN_HL
+    /*
+     * Correct stored syntax highlighting info for changes in each displayed
+     * buffer.  Each buffer must only be done once.
+     */
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp->w_buffer->b_mod_set)
+	{
+	    win_T	*wwp;
+
+	    /* Check if we already did this buffer. */
+	    for (wwp = firstwin; wwp != wp; wwp = wwp->w_next)
+		if (wwp->w_buffer == wp->w_buffer)
+		    break;
+	    if (wwp == wp && syntax_present(wp))
+		syn_stack_apply_changes(wp->w_buffer);
+	}
+    }
+#endif
+
+    /*
+     * Go from top to bottom through the windows, redrawing the ones that need
+     * it.
+     */
+#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
+    did_one = FALSE;
+#endif
+#ifdef FEAT_SEARCH_EXTRA
+    search_hl.rm.regprog = NULL;
+#endif
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp->w_redr_type != 0)
+	{
+	    cursor_off();
+#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
+	    if (!did_one)
+	    {
+		did_one = TRUE;
+# ifdef FEAT_SEARCH_EXTRA
+		start_search_hl();
+# endif
+# ifdef FEAT_CLIPBOARD
+		/* When Visual area changed, may have to update selection. */
+		if (clip_star.available && clip_isautosel_star())
+		    clip_update_selection(&clip_star);
+		if (clip_plus.available && clip_isautosel_plus())
+		    clip_update_selection(&clip_plus);
+# endif
+#ifdef FEAT_GUI
+		/* Remove the cursor before starting to do anything, because
+		 * scrolling may make it difficult to redraw the text under
+		 * it. */
+		if (gui.in_use && wp == curwin)
+		{
+		    gui_cursor_col = gui.cursor_col;
+		    gui_cursor_row = gui.cursor_row;
+		    gui_undraw_cursor();
+		    did_undraw = TRUE;
+		}
+#endif
+	    }
+#endif
+	    win_update(wp);
+	}
+
+	/* redraw status line after the window to minimize cursor movement */
+	if (wp->w_redr_status)
+	{
+	    cursor_off();
+	    win_redr_status(wp, TRUE); // any popup menu will be redrawn below
+	}
+    }
+#if defined(FEAT_SEARCH_EXTRA)
+    end_search_hl();
+#endif
+#ifdef FEAT_INS_EXPAND
+    /* May need to redraw the popup menu. */
+    pum_may_redraw();
+#endif
+
+    /* Reset b_mod_set flags.  Going through all windows is probably faster
+     * than going through all buffers (there could be many buffers). */
+    FOR_ALL_WINDOWS(wp)
+	wp->w_buffer->b_mod_set = FALSE;
+
+    reset_updating_screen(TRUE);
+
+    /* Clear or redraw the command line.  Done last, because scrolling may
+     * mess up the command line. */
+    if (clear_cmdline || redraw_cmdline)
+	showmode();
+
+    if (no_update)
+	--no_win_do_lines_ins;
+
+    /* May put up an introductory message when not editing a file */
+    if (!did_intro)
+	maybe_intro_message();
+    did_intro = TRUE;
+
+#ifdef FEAT_GUI
+    /* Redraw the cursor and update the scrollbars when all screen updating is
+     * done. */
+    if (gui.in_use)
+    {
+	if (did_undraw && !gui_mch_is_blink_off())
+	{
+	    mch_disable_flush();
+	    out_flush();	/* required before updating the cursor */
+	    mch_enable_flush();
+
+	    /* Put the GUI position where the cursor was, gui_update_cursor()
+	     * uses that. */
+	    gui.col = gui_cursor_col;
+	    gui.row = gui_cursor_row;
+# ifdef FEAT_MBYTE
+	    gui.col = mb_fix_col(gui.col, gui.row);
+# endif
+	    gui_update_cursor(FALSE, FALSE);
+	    gui_may_flush();
+	    screen_cur_col = gui.col;
+	    screen_cur_row = gui.row;
+	}
+	else
+	    out_flush();
+	gui_update_scrollbars(FALSE);
+    }
+#endif
+    return OK;
+}
+
+#if defined(FEAT_SIGNS) || defined(FEAT_GUI) || defined(FEAT_CONCEAL)
+/*
+ * Prepare for updating one or more windows.
+ * Caller must check for "updating_screen" already set to avoid recursiveness.
+ */
+    static void
+update_prepare(void)
+{
+    cursor_off();
+    updating_screen = TRUE;
+#ifdef FEAT_GUI
+    /* Remove the cursor before starting to do anything, because scrolling may
+     * make it difficult to redraw the text under it. */
+    if (gui.in_use)
+	gui_undraw_cursor();
+#endif
+#ifdef FEAT_SEARCH_EXTRA
+    start_search_hl();
+#endif
+}
+
+/*
+ * Finish updating one or more windows.
+ */
+    static void
+update_finish(void)
+{
+    if (redraw_cmdline)
+	showmode();
+
+# ifdef FEAT_SEARCH_EXTRA
+    end_search_hl();
+# endif
+
+    reset_updating_screen(TRUE);
+
+# ifdef FEAT_GUI
+    /* Redraw the cursor and update the scrollbars when all screen updating is
+     * done. */
+    if (gui.in_use)
+    {
+	out_flush_cursor(FALSE, FALSE);
+	gui_update_scrollbars(FALSE);
+    }
+# endif
+}
+#endif
+
+#if defined(FEAT_CONCEAL) || defined(PROTO)
+/*
+ * Return TRUE if the cursor line in window "wp" may be concealed, according
+ * to the 'concealcursor' option.
+ */
+    int
+conceal_cursor_line(win_T *wp)
+{
+    int		c;
+
+    if (*wp->w_p_cocu == NUL)
+	return FALSE;
+    if (get_real_state() & VISUAL)
+	c = 'v';
+    else if (State & INSERT)
+	c = 'i';
+    else if (State & NORMAL)
+	c = 'n';
+    else if (State & CMDLINE)
+	c = 'c';
+    else
+	return FALSE;
+    return vim_strchr(wp->w_p_cocu, c) != NULL;
+}
+
+/*
+ * Check if the cursor line needs to be redrawn because of 'concealcursor'.
+ */
+    void
+conceal_check_cursor_line(void)
+{
+    if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin))
+    {
+	need_cursor_line_redraw = TRUE;
+	/* Need to recompute cursor column, e.g., when starting Visual mode
+	 * without concealing. */
+	curs_columns(TRUE);
+    }
+}
+
+    void
+update_single_line(win_T *wp, linenr_T lnum)
+{
+    int		row;
+    int		j;
+#ifdef SYN_TIME_LIMIT
+    proftime_T	syntax_tm;
+#endif
+
+    /* Don't do anything if the screen structures are (not yet) valid. */
+    if (!screen_valid(TRUE) || updating_screen)
+	return;
+
+    if (lnum >= wp->w_topline && lnum < wp->w_botline
+				 && foldedCount(wp, lnum, &win_foldinfo) == 0)
+    {
+#ifdef SYN_TIME_LIMIT
+	/* Set the time limit to 'redrawtime'. */
+	profile_setlimit(p_rdt, &syntax_tm);
+	syn_set_timeout(&syntax_tm);
+#endif
+	update_prepare();
+
+	row = 0;
+	for (j = 0; j < wp->w_lines_valid; ++j)
+	{
+	    if (lnum == wp->w_lines[j].wl_lnum)
+	    {
+		screen_start();	/* not sure of screen cursor */
+# ifdef FEAT_SEARCH_EXTRA
+		init_search_hl(wp);
+		start_search_hl();
+		prepare_search_hl(wp, lnum);
+# endif
+		win_line(wp, lnum, row, row + wp->w_lines[j].wl_size, FALSE);
+# if defined(FEAT_SEARCH_EXTRA)
+		end_search_hl();
+# endif
+		break;
+	    }
+	    row += wp->w_lines[j].wl_size;
+	}
+
+	update_finish();
+
+#ifdef SYN_TIME_LIMIT
+	syn_set_timeout(NULL);
+#endif
+    }
+    need_cursor_line_redraw = FALSE;
+}
+#endif
+
+#if defined(FEAT_SIGNS) || defined(PROTO)
+    void
+update_debug_sign(buf_T *buf, linenr_T lnum)
+{
+    win_T	*wp;
+    int		doit = FALSE;
+
+# ifdef FEAT_FOLDING
+    win_foldinfo.fi_level = 0;
+# endif
+
+    /* update/delete a specific mark */
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (buf != NULL && lnum > 0)
+	{
+	    if (wp->w_buffer == buf && lnum >= wp->w_topline
+						      && lnum < wp->w_botline)
+	    {
+		if (wp->w_redraw_top == 0 || wp->w_redraw_top > lnum)
+		    wp->w_redraw_top = lnum;
+		if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lnum)
+		    wp->w_redraw_bot = lnum;
+		redraw_win_later(wp, VALID);
+	    }
+	}
+	else
+	    redraw_win_later(wp, VALID);
+	if (wp->w_redr_type != 0)
+	    doit = TRUE;
+    }
+
+    /* Return when there is nothing to do, screen updating is already
+     * happening (recursive call), messages on the screen or still starting up.
+     */
+    if (!doit || updating_screen
+	    || State == ASKMORE || State == HITRETURN
+	    || msg_scrolled
+#ifdef FEAT_GUI
+	    || gui.starting
+#endif
+	    || starting)
+	return;
+
+    /* update all windows that need updating */
+    update_prepare();
+
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp->w_redr_type != 0)
+	    win_update(wp);
+	if (wp->w_redr_status)
+	    win_redr_status(wp, FALSE);
+    }
+
+    update_finish();
+}
+#endif
+
+
+#if defined(FEAT_GUI) || defined(PROTO)
+/*
+ * Update a single window, its status line and maybe the command line msg.
+ * Used for the GUI scrollbar.
+ */
+    void
+updateWindow(win_T *wp)
+{
+    /* return if already busy updating */
+    if (updating_screen)
+	return;
+
+    update_prepare();
+
+#ifdef FEAT_CLIPBOARD
+    /* When Visual area changed, may have to update selection. */
+    if (clip_star.available && clip_isautosel_star())
+	clip_update_selection(&clip_star);
+    if (clip_plus.available && clip_isautosel_plus())
+	clip_update_selection(&clip_plus);
+#endif
+
+    win_update(wp);
+
+    /* When the screen was cleared redraw the tab pages line. */
+    if (redraw_tabline)
+	draw_tabline();
+
+    if (wp->w_redr_status
+# ifdef FEAT_CMDL_INFO
+	    || p_ru
+# endif
+# ifdef FEAT_STL_OPT
+	    || *p_stl != NUL || *wp->w_p_stl != NUL
+# endif
+	    )
+	win_redr_status(wp, FALSE);
+
+    update_finish();
+}
+#endif
+
+/*
+ * Update a single window.
+ *
+ * This may cause the windows below it also to be redrawn (when clearing the
+ * screen or scrolling lines).
+ *
+ * How the window is redrawn depends on wp->w_redr_type.  Each type also
+ * implies the one below it.
+ * NOT_VALID	redraw the whole window
+ * SOME_VALID	redraw the whole window but do scroll when possible
+ * REDRAW_TOP	redraw the top w_upd_rows window lines, otherwise like VALID
+ * INVERTED	redraw the changed part of the Visual area
+ * INVERTED_ALL	redraw the whole Visual area
+ * VALID	1. scroll up/down to adjust for a changed w_topline
+ *		2. update lines at the top when scrolled down
+ *		3. redraw changed text:
+ *		   - if wp->w_buffer->b_mod_set set, update lines between
+ *		     b_mod_top and b_mod_bot.
+ *		   - if wp->w_redraw_top non-zero, redraw lines between
+ *		     wp->w_redraw_top and wp->w_redr_bot.
+ *		   - continue redrawing when syntax status is invalid.
+ *		4. if scrolled up, update lines at the bottom.
+ * This results in three areas that may need updating:
+ * top:	from first row to top_end (when scrolled down)
+ * mid: from mid_start to mid_end (update inversion or changed text)
+ * bot: from bot_start to last row (when scrolled up)
+ */
+    static void
+win_update(win_T *wp)
+{
+    buf_T	*buf = wp->w_buffer;
+    int		type;
+    int		top_end = 0;	/* Below last row of the top area that needs
+				   updating.  0 when no top area updating. */
+    int		mid_start = 999;/* first row of the mid area that needs
+				   updating.  999 when no mid area updating. */
+    int		mid_end = 0;	/* Below last row of the mid area that needs
+				   updating.  0 when no mid area updating. */
+    int		bot_start = 999;/* first row of the bot area that needs
+				   updating.  999 when no bot area updating */
+    int		scrolled_down = FALSE;	/* TRUE when scrolled down when
+					   w_topline got smaller a bit */
+#ifdef FEAT_SEARCH_EXTRA
+    matchitem_T *cur;		/* points to the match list */
+    int		top_to_mod = FALSE;    /* redraw above mod_top */
+#endif
+
+    int		row;		/* current window row to display */
+    linenr_T	lnum;		/* current buffer lnum to display */
+    int		idx;		/* current index in w_lines[] */
+    int		srow;		/* starting row of the current line */
+
+    int		eof = FALSE;	/* if TRUE, we hit the end of the file */
+    int		didline = FALSE; /* if TRUE, we finished the last line */
+    int		i;
+    long	j;
+    static int	recursive = FALSE;	/* being called recursively */
+    int		old_botline = wp->w_botline;
+#ifdef FEAT_FOLDING
+    long	fold_count;
+#endif
+#ifdef FEAT_SYN_HL
+    /* remember what happened to the previous line, to know if
+     * check_visual_highlight() can be used */
+#define DID_NONE 1	/* didn't update a line */
+#define DID_LINE 2	/* updated a normal line */
+#define DID_FOLD 3	/* updated a folded line */
+    int		did_update = DID_NONE;
+    linenr_T	syntax_last_parsed = 0;		/* last parsed text line */
+#endif
+    linenr_T	mod_top = 0;
+    linenr_T	mod_bot = 0;
+#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
+    int		save_got_int;
+#endif
+#ifdef SYN_TIME_LIMIT
+    proftime_T	syntax_tm;
+#endif
+
+    type = wp->w_redr_type;
+
+    if (type == NOT_VALID)
+    {
+	wp->w_redr_status = TRUE;
+	wp->w_lines_valid = 0;
+    }
+
+    /* Window is zero-height: nothing to draw. */
+    if (wp->w_height + WINBAR_HEIGHT(wp) == 0)
+    {
+	wp->w_redr_type = 0;
+	return;
+    }
+
+    /* Window is zero-width: Only need to draw the separator. */
+    if (wp->w_width == 0)
+    {
+	/* draw the vertical separator right of this window */
+	draw_vsep_win(wp, 0);
+	wp->w_redr_type = 0;
+	return;
+    }
+
+#ifdef FEAT_TERMINAL
+    // If this window contains a terminal, redraw works completely differently.
+    if (term_do_update_window(wp))
+    {
+	term_update_window(wp);
+# ifdef FEAT_MENU
+	/* Draw the window toolbar, if there is one. */
+	if (winbar_height(wp) > 0)
+	    redraw_win_toolbar(wp);
+# endif
+	wp->w_redr_type = 0;
+	return;
+    }
+#endif
+
+#ifdef FEAT_SEARCH_EXTRA
+    init_search_hl(wp);
+#endif
+
+#ifdef FEAT_LINEBREAK
+    /* Force redraw when width of 'number' or 'relativenumber' column
+     * changes. */
+    i = (wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) : 0;
+    if (wp->w_nrwidth != i)
+    {
+	type = NOT_VALID;
+	wp->w_nrwidth = i;
+    }
+    else
+#endif
+
+    if (buf->b_mod_set && buf->b_mod_xlines != 0 && wp->w_redraw_top != 0)
+    {
+	/*
+	 * When there are both inserted/deleted lines and specific lines to be
+	 * redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw
+	 * everything (only happens when redrawing is off for while).
+	 */
+	type = NOT_VALID;
+    }
+    else
+    {
+	/*
+	 * Set mod_top to the first line that needs displaying because of
+	 * changes.  Set mod_bot to the first line after the changes.
+	 */
+	mod_top = wp->w_redraw_top;
+	if (wp->w_redraw_bot != 0)
+	    mod_bot = wp->w_redraw_bot + 1;
+	else
+	    mod_bot = 0;
+	wp->w_redraw_top = 0;	/* reset for next time */
+	wp->w_redraw_bot = 0;
+	if (buf->b_mod_set)
+	{
+	    if (mod_top == 0 || mod_top > buf->b_mod_top)
+	    {
+		mod_top = buf->b_mod_top;
+#ifdef FEAT_SYN_HL
+		/* Need to redraw lines above the change that may be included
+		 * in a pattern match. */
+		if (syntax_present(wp))
+		{
+		    mod_top -= buf->b_s.b_syn_sync_linebreaks;
+		    if (mod_top < 1)
+			mod_top = 1;
+		}
+#endif
+	    }
+	    if (mod_bot == 0 || mod_bot < buf->b_mod_bot)
+		mod_bot = buf->b_mod_bot;
+
+#ifdef FEAT_SEARCH_EXTRA
+	    /* When 'hlsearch' is on and using a multi-line search pattern, a
+	     * change in one line may make the Search highlighting in a
+	     * previous line invalid.  Simple solution: redraw all visible
+	     * lines above the change.
+	     * Same for a match pattern.
+	     */
+	    if (search_hl.rm.regprog != NULL
+					&& re_multiline(search_hl.rm.regprog))
+		top_to_mod = TRUE;
+	    else
+	    {
+		cur = wp->w_match_head;
+		while (cur != NULL)
+		{
+		    if (cur->match.regprog != NULL
+					   && re_multiline(cur->match.regprog))
+		    {
+			top_to_mod = TRUE;
+			break;
+		    }
+		    cur = cur->next;
+		}
+	    }
+#endif
+	}
+#ifdef FEAT_FOLDING
+	if (mod_top != 0 && hasAnyFolding(wp))
+	{
+	    linenr_T	lnumt, lnumb;
+
+	    /*
+	     * A change in a line can cause lines above it to become folded or
+	     * unfolded.  Find the top most buffer line that may be affected.
+	     * If the line was previously folded and displayed, get the first
+	     * line of that fold.  If the line is folded now, get the first
+	     * folded line.  Use the minimum of these two.
+	     */
+
+	    /* Find last valid w_lines[] entry above mod_top.  Set lnumt to
+	     * the line below it.  If there is no valid entry, use w_topline.
+	     * Find the first valid w_lines[] entry below mod_bot.  Set lnumb
+	     * to this line.  If there is no valid entry, use MAXLNUM. */
+	    lnumt = wp->w_topline;
+	    lnumb = MAXLNUM;
+	    for (i = 0; i < wp->w_lines_valid; ++i)
+		if (wp->w_lines[i].wl_valid)
+		{
+		    if (wp->w_lines[i].wl_lastlnum < mod_top)
+			lnumt = wp->w_lines[i].wl_lastlnum + 1;
+		    if (lnumb == MAXLNUM && wp->w_lines[i].wl_lnum >= mod_bot)
+		    {
+			lnumb = wp->w_lines[i].wl_lnum;
+			/* When there is a fold column it might need updating
+			 * in the next line ("J" just above an open fold). */
+			if (compute_foldcolumn(wp, 0) > 0)
+			    ++lnumb;
+		    }
+		}
+
+	    (void)hasFoldingWin(wp, mod_top, &mod_top, NULL, TRUE, NULL);
+	    if (mod_top > lnumt)
+		mod_top = lnumt;
+
+	    /* Now do the same for the bottom line (one above mod_bot). */
+	    --mod_bot;
+	    (void)hasFoldingWin(wp, mod_bot, NULL, &mod_bot, TRUE, NULL);
+	    ++mod_bot;
+	    if (mod_bot < lnumb)
+		mod_bot = lnumb;
+	}
+#endif
+
+	/* When a change starts above w_topline and the end is below
+	 * w_topline, start redrawing at w_topline.
+	 * If the end of the change is above w_topline: do like no change was
+	 * made, but redraw the first line to find changes in syntax. */
+	if (mod_top != 0 && mod_top < wp->w_topline)
+	{
+	    if (mod_bot > wp->w_topline)
+		mod_top = wp->w_topline;
+#ifdef FEAT_SYN_HL
+	    else if (syntax_present(wp))
+		top_end = 1;
+#endif
+	}
+
+	/* When line numbers are displayed need to redraw all lines below
+	 * inserted/deleted lines. */
+	if (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu)
+	    mod_bot = MAXLNUM;
+    }
+
+    /*
+     * When only displaying the lines at the top, set top_end.  Used when
+     * window has scrolled down for msg_scrolled.
+     */
+    if (type == REDRAW_TOP)
+    {
+	j = 0;
+	for (i = 0; i < wp->w_lines_valid; ++i)
+	{
+	    j += wp->w_lines[i].wl_size;
+	    if (j >= wp->w_upd_rows)
+	    {
+		top_end = j;
+		break;
+	    }
+	}
+	if (top_end == 0)
+	    /* not found (cannot happen?): redraw everything */
+	    type = NOT_VALID;
+	else
+	    /* top area defined, the rest is VALID */
+	    type = VALID;
+    }
+
+    /* Trick: we want to avoid clearing the screen twice.  screenclear() will
+     * set "screen_cleared" to TRUE.  The special value MAYBE (which is still
+     * non-zero and thus not FALSE) will indicate that screenclear() was not
+     * called. */
+    if (screen_cleared)
+	screen_cleared = MAYBE;
+
+    /*
+     * If there are no changes on the screen that require a complete redraw,
+     * handle three cases:
+     * 1: we are off the top of the screen by a few lines: scroll down
+     * 2: wp->w_topline is below wp->w_lines[0].wl_lnum: may scroll up
+     * 3: wp->w_topline is wp->w_lines[0].wl_lnum: find first entry in
+     *    w_lines[] that needs updating.
+     */
+    if ((type == VALID || type == SOME_VALID
+				  || type == INVERTED || type == INVERTED_ALL)
+#ifdef FEAT_DIFF
+	    && !wp->w_botfill && !wp->w_old_botfill
+#endif
+	    )
+    {
+	if (mod_top != 0 && wp->w_topline == mod_top)
+	{
+	    /*
+	     * w_topline is the first changed line, the scrolling will be done
+	     * further down.
+	     */
+	}
+	else if (wp->w_lines[0].wl_valid
+		&& (wp->w_topline < wp->w_lines[0].wl_lnum
+#ifdef FEAT_DIFF
+		    || (wp->w_topline == wp->w_lines[0].wl_lnum
+			&& wp->w_topfill > wp->w_old_topfill)
+#endif
+		   ))
+	{
+	    /*
+	     * New topline is above old topline: May scroll down.
+	     */
+#ifdef FEAT_FOLDING
+	    if (hasAnyFolding(wp))
+	    {
+		linenr_T ln;
+
+		/* count the number of lines we are off, counting a sequence
+		 * of folded lines as one */
+		j = 0;
+		for (ln = wp->w_topline; ln < wp->w_lines[0].wl_lnum; ++ln)
+		{
+		    ++j;
+		    if (j >= wp->w_height - 2)
+			break;
+		    (void)hasFoldingWin(wp, ln, NULL, &ln, TRUE, NULL);
+		}
+	    }
+	    else
+#endif
+		j = wp->w_lines[0].wl_lnum - wp->w_topline;
+	    if (j < wp->w_height - 2)		/* not too far off */
+	    {
+		i = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);
+#ifdef FEAT_DIFF
+		/* insert extra lines for previously invisible filler lines */
+		if (wp->w_lines[0].wl_lnum != wp->w_topline)
+		    i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)
+							  - wp->w_old_topfill;
+#endif
+		if (i < wp->w_height - 2)	/* less than a screen off */
+		{
+		    /*
+		     * Try to insert the correct number of lines.
+		     * If not the last window, delete the lines at the bottom.
+		     * win_ins_lines may fail when the terminal can't do it.
+		     */
+		    if (i > 0)
+			check_for_delay(FALSE);
+		    if (win_ins_lines(wp, 0, i, FALSE, wp == firstwin) == OK)
+		    {
+			if (wp->w_lines_valid != 0)
+			{
+			    /* Need to update rows that are new, stop at the
+			     * first one that scrolled down. */
+			    top_end = i;
+			    scrolled_down = TRUE;
+
+			    /* Move the entries that were scrolled, disable
+			     * the entries for the lines to be redrawn. */
+			    if ((wp->w_lines_valid += j) > wp->w_height)
+				wp->w_lines_valid = wp->w_height;
+			    for (idx = wp->w_lines_valid; idx - j >= 0; idx--)
+				wp->w_lines[idx] = wp->w_lines[idx - j];
+			    while (idx >= 0)
+				wp->w_lines[idx--].wl_valid = FALSE;
+			}
+		    }
+		    else
+			mid_start = 0;		/* redraw all lines */
+		}
+		else
+		    mid_start = 0;		/* redraw all lines */
+	    }
+	    else
+		mid_start = 0;		/* redraw all lines */
+	}
+	else
+	{
+	    /*
+	     * New topline is at or below old topline: May scroll up.
+	     * When topline didn't change, find first entry in w_lines[] that
+	     * needs updating.
+	     */
+
+	    /* try to find wp->w_topline in wp->w_lines[].wl_lnum */
+	    j = -1;
+	    row = 0;
+	    for (i = 0; i < wp->w_lines_valid; i++)
+	    {
+		if (wp->w_lines[i].wl_valid
+			&& wp->w_lines[i].wl_lnum == wp->w_topline)
+		{
+		    j = i;
+		    break;
+		}
+		row += wp->w_lines[i].wl_size;
+	    }
+	    if (j == -1)
+	    {
+		/* if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all
+		 * lines */
+		mid_start = 0;
+	    }
+	    else
+	    {
+		/*
+		 * Try to delete the correct number of lines.
+		 * wp->w_topline is at wp->w_lines[i].wl_lnum.
+		 */
+#ifdef FEAT_DIFF
+		/* If the topline didn't change, delete old filler lines,
+		 * otherwise delete filler lines of the new topline... */
+		if (wp->w_lines[0].wl_lnum == wp->w_topline)
+		    row += wp->w_old_topfill;
+		else
+		    row += diff_check_fill(wp, wp->w_topline);
+		/* ... but don't delete new filler lines. */
+		row -= wp->w_topfill;
+#endif
+		if (row > 0)
+		{
+		    check_for_delay(FALSE);
+		    if (win_del_lines(wp, 0, row, FALSE, wp == firstwin, 0)
+									 == OK)
+			bot_start = wp->w_height - row;
+		    else
+			mid_start = 0;		/* redraw all lines */
+		}
+		if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0)
+		{
+		    /*
+		     * Skip the lines (below the deleted lines) that are still
+		     * valid and don't need redrawing.	Copy their info
+		     * upwards, to compensate for the deleted lines.  Set
+		     * bot_start to the first row that needs redrawing.
+		     */
+		    bot_start = 0;
+		    idx = 0;
+		    for (;;)
+		    {
+			wp->w_lines[idx] = wp->w_lines[j];
+			/* stop at line that didn't fit, unless it is still
+			 * valid (no lines deleted) */
+			if (row > 0 && bot_start + row
+				 + (int)wp->w_lines[j].wl_size > wp->w_height)
+			{
+			    wp->w_lines_valid = idx + 1;
+			    break;
+			}
+			bot_start += wp->w_lines[idx++].wl_size;
+
+			/* stop at the last valid entry in w_lines[].wl_size */
+			if (++j >= wp->w_lines_valid)
+			{
+			    wp->w_lines_valid = idx;
+			    break;
+			}
+		    }
+#ifdef FEAT_DIFF
+		    /* Correct the first entry for filler lines at the top
+		     * when it won't get updated below. */
+		    if (wp->w_p_diff && bot_start > 0)
+			wp->w_lines[0].wl_size =
+			    plines_win_nofill(wp, wp->w_topline, TRUE)
+							      + wp->w_topfill;
+#endif
+		}
+	    }
+	}
+
+	/* When starting redraw in the first line, redraw all lines.  When
+	 * there is only one window it's probably faster to clear the screen
+	 * first. */
+	if (mid_start == 0)
+	{
+	    mid_end = wp->w_height;
+	    if (ONE_WINDOW)
+	    {
+		/* Clear the screen when it was not done by win_del_lines() or
+		 * win_ins_lines() above, "screen_cleared" is FALSE or MAYBE
+		 * then. */
+		if (screen_cleared != TRUE)
+		    screenclear();
+		/* The screen was cleared, redraw the tab pages line. */
+		if (redraw_tabline)
+		    draw_tabline();
+	    }
+	}
+
+	/* When win_del_lines() or win_ins_lines() caused the screen to be
+	 * cleared (only happens for the first window) or when screenclear()
+	 * was called directly above, "must_redraw" will have been set to
+	 * NOT_VALID, need to reset it here to avoid redrawing twice. */
+	if (screen_cleared == TRUE)
+	    must_redraw = 0;
+    }
+    else
+    {
+	/* Not VALID or INVERTED: redraw all lines. */
+	mid_start = 0;
+	mid_end = wp->w_height;
+    }
+
+    if (type == SOME_VALID)
+    {
+	/* SOME_VALID: redraw all lines. */
+	mid_start = 0;
+	mid_end = wp->w_height;
+	type = NOT_VALID;
+    }
+
+    /* check if we are updating or removing the inverted part */
+    if ((VIsual_active && buf == curwin->w_buffer)
+	    || (wp->w_old_cursor_lnum != 0 && type != NOT_VALID))
+    {
+	linenr_T    from, to;
+
+	if (VIsual_active)
+	{
+	    if (VIsual_active
+		    && (VIsual_mode != wp->w_old_visual_mode
+			|| type == INVERTED_ALL))
+	    {
+		/*
+		 * If the type of Visual selection changed, redraw the whole
+		 * selection.  Also when the ownership of the X selection is
+		 * gained or lost.
+		 */
+		if (curwin->w_cursor.lnum < VIsual.lnum)
+		{
+		    from = curwin->w_cursor.lnum;
+		    to = VIsual.lnum;
+		}
+		else
+		{
+		    from = VIsual.lnum;
+		    to = curwin->w_cursor.lnum;
+		}
+		/* redraw more when the cursor moved as well */
+		if (wp->w_old_cursor_lnum < from)
+		    from = wp->w_old_cursor_lnum;
+		if (wp->w_old_cursor_lnum > to)
+		    to = wp->w_old_cursor_lnum;
+		if (wp->w_old_visual_lnum < from)
+		    from = wp->w_old_visual_lnum;
+		if (wp->w_old_visual_lnum > to)
+		    to = wp->w_old_visual_lnum;
+	    }
+	    else
+	    {
+		/*
+		 * Find the line numbers that need to be updated: The lines
+		 * between the old cursor position and the current cursor
+		 * position.  Also check if the Visual position changed.
+		 */
+		if (curwin->w_cursor.lnum < wp->w_old_cursor_lnum)
+		{
+		    from = curwin->w_cursor.lnum;
+		    to = wp->w_old_cursor_lnum;
+		}
+		else
+		{
+		    from = wp->w_old_cursor_lnum;
+		    to = curwin->w_cursor.lnum;
+		    if (from == 0)	/* Visual mode just started */
+			from = to;
+		}
+
+		if (VIsual.lnum != wp->w_old_visual_lnum
+					|| VIsual.col != wp->w_old_visual_col)
+		{
+		    if (wp->w_old_visual_lnum < from
+						&& wp->w_old_visual_lnum != 0)
+			from = wp->w_old_visual_lnum;
+		    if (wp->w_old_visual_lnum > to)
+			to = wp->w_old_visual_lnum;
+		    if (VIsual.lnum < from)
+			from = VIsual.lnum;
+		    if (VIsual.lnum > to)
+			to = VIsual.lnum;
+		}
+	    }
+
+	    /*
+	     * If in block mode and changed column or curwin->w_curswant:
+	     * update all lines.
+	     * First compute the actual start and end column.
+	     */
+	    if (VIsual_mode == Ctrl_V)
+	    {
+		colnr_T	    fromc, toc;
+#if defined(FEAT_VIRTUALEDIT) && defined(FEAT_LINEBREAK)
+		int	    save_ve_flags = ve_flags;
+
+		if (curwin->w_p_lbr)
+		    ve_flags = VE_ALL;
+#endif
+		getvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);
+#if defined(FEAT_VIRTUALEDIT) && defined(FEAT_LINEBREAK)
+		ve_flags = save_ve_flags;
+#endif
+		++toc;
+		if (curwin->w_curswant == MAXCOL)
+		    toc = MAXCOL;
+
+		if (fromc != wp->w_old_cursor_fcol
+			|| toc != wp->w_old_cursor_lcol)
+		{
+		    if (from > VIsual.lnum)
+			from = VIsual.lnum;
+		    if (to < VIsual.lnum)
+			to = VIsual.lnum;
+		}
+		wp->w_old_cursor_fcol = fromc;
+		wp->w_old_cursor_lcol = toc;
+	    }
+	}
+	else
+	{
+	    /* Use the line numbers of the old Visual area. */
+	    if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum)
+	    {
+		from = wp->w_old_cursor_lnum;
+		to = wp->w_old_visual_lnum;
+	    }
+	    else
+	    {
+		from = wp->w_old_visual_lnum;
+		to = wp->w_old_cursor_lnum;
+	    }
+	}
+
+	/*
+	 * There is no need to update lines above the top of the window.
+	 */
+	if (from < wp->w_topline)
+	    from = wp->w_topline;
+
+	/*
+	 * If we know the value of w_botline, use it to restrict the update to
+	 * the lines that are visible in the window.
+	 */
+	if (wp->w_valid & VALID_BOTLINE)
+	{
+	    if (from >= wp->w_botline)
+		from = wp->w_botline - 1;
+	    if (to >= wp->w_botline)
+		to = wp->w_botline - 1;
+	}
+
+	/*
+	 * Find the minimal part to be updated.
+	 * Watch out for scrolling that made entries in w_lines[] invalid.
+	 * E.g., CTRL-U makes the first half of w_lines[] invalid and sets
+	 * top_end; need to redraw from top_end to the "to" line.
+	 * A middle mouse click with a Visual selection may change the text
+	 * above the Visual area and reset wl_valid, do count these for
+	 * mid_end (in srow).
+	 */
+	if (mid_start > 0)
+	{
+	    lnum = wp->w_topline;
+	    idx = 0;
+	    srow = 0;
+	    if (scrolled_down)
+		mid_start = top_end;
+	    else
+		mid_start = 0;
+	    while (lnum < from && idx < wp->w_lines_valid)	/* find start */
+	    {
+		if (wp->w_lines[idx].wl_valid)
+		    mid_start += wp->w_lines[idx].wl_size;
+		else if (!scrolled_down)
+		    srow += wp->w_lines[idx].wl_size;
+		++idx;
+# ifdef FEAT_FOLDING
+		if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)
+		    lnum = wp->w_lines[idx].wl_lnum;
+		else
+# endif
+		    ++lnum;
+	    }
+	    srow += mid_start;
+	    mid_end = wp->w_height;
+	    for ( ; idx < wp->w_lines_valid; ++idx)		/* find end */
+	    {
+		if (wp->w_lines[idx].wl_valid
+			&& wp->w_lines[idx].wl_lnum >= to + 1)
+		{
+		    /* Only update until first row of this line */
+		    mid_end = srow;
+		    break;
+		}
+		srow += wp->w_lines[idx].wl_size;
+	    }
+	}
+    }
+
+    if (VIsual_active && buf == curwin->w_buffer)
+    {
+	wp->w_old_visual_mode = VIsual_mode;
+	wp->w_old_cursor_lnum = curwin->w_cursor.lnum;
+	wp->w_old_visual_lnum = VIsual.lnum;
+	wp->w_old_visual_col = VIsual.col;
+	wp->w_old_curswant = curwin->w_curswant;
+    }
+    else
+    {
+	wp->w_old_visual_mode = 0;
+	wp->w_old_cursor_lnum = 0;
+	wp->w_old_visual_lnum = 0;
+	wp->w_old_visual_col = 0;
+    }
+
+#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
+    /* reset got_int, otherwise regexp won't work */
+    save_got_int = got_int;
+    got_int = 0;
+#endif
+#ifdef SYN_TIME_LIMIT
+    /* Set the time limit to 'redrawtime'. */
+    profile_setlimit(p_rdt, &syntax_tm);
+    syn_set_timeout(&syntax_tm);
+#endif
+#ifdef FEAT_FOLDING
+    win_foldinfo.fi_level = 0;
+#endif
+
+#ifdef FEAT_MENU
+    /*
+     * Draw the window toolbar, if there is one.
+     * TODO: only when needed.
+     */
+    if (winbar_height(wp) > 0)
+	redraw_win_toolbar(wp);
+#endif
+
+    /*
+     * Update all the window rows.
+     */
+    idx = 0;		/* first entry in w_lines[].wl_size */
+    row = 0;
+    srow = 0;
+    lnum = wp->w_topline;	/* first line shown in window */
+    for (;;)
+    {
+	/* stop updating when reached the end of the window (check for _past_
+	 * the end of the window is at the end of the loop) */
+	if (row == wp->w_height)
+	{
+	    didline = TRUE;
+	    break;
+	}
+
+	/* stop updating when hit the end of the file */
+	if (lnum > buf->b_ml.ml_line_count)
+	{
+	    eof = TRUE;
+	    break;
+	}
+
+	/* Remember the starting row of the line that is going to be dealt
+	 * with.  It is used further down when the line doesn't fit. */
+	srow = row;
+
+	/*
+	 * Update a line when it is in an area that needs updating, when it
+	 * has changes or w_lines[idx] is invalid.
+	 * bot_start may be halfway a wrapped line after using
+	 * win_del_lines(), check if the current line includes it.
+	 * When syntax folding is being used, the saved syntax states will
+	 * already have been updated, we can't see where the syntax state is
+	 * the same again, just update until the end of the window.
+	 */
+	if (row < top_end
+		|| (row >= mid_start && row < mid_end)
+#ifdef FEAT_SEARCH_EXTRA
+		|| top_to_mod
+#endif
+		|| idx >= wp->w_lines_valid
+		|| (row + wp->w_lines[idx].wl_size > bot_start)
+		|| (mod_top != 0
+		    && (lnum == mod_top
+			|| (lnum >= mod_top
+			    && (lnum < mod_bot
+#ifdef FEAT_SYN_HL
+				|| did_update == DID_FOLD
+				|| (did_update == DID_LINE
+				    && syntax_present(wp)
+				    && (
+# ifdef FEAT_FOLDING
+					(foldmethodIsSyntax(wp)
+						      && hasAnyFolding(wp)) ||
+# endif
+					syntax_check_changed(lnum)))
+#endif
+#ifdef FEAT_SEARCH_EXTRA
+				/* match in fixed position might need redraw
+				 * if lines were inserted or deleted */
+				|| (wp->w_match_head != NULL
+						    && buf->b_mod_xlines != 0)
+#endif
+				)))))
+	{
+#ifdef FEAT_SEARCH_EXTRA
+	    if (lnum == mod_top)
+		top_to_mod = FALSE;
+#endif
+
+	    /*
+	     * When at start of changed lines: May scroll following lines
+	     * up or down to minimize redrawing.
+	     * Don't do this when the change continues until the end.
+	     * Don't scroll when dollar_vcol >= 0, keep the "$".
+	     */
+	    if (lnum == mod_top
+		    && mod_bot != MAXLNUM
+		    && !(dollar_vcol >= 0 && mod_bot == mod_top + 1))
+	    {
+		int		old_rows = 0;
+		int		new_rows = 0;
+		int		xtra_rows;
+		linenr_T	l;
+
+		/* Count the old number of window rows, using w_lines[], which
+		 * should still contain the sizes for the lines as they are
+		 * currently displayed. */
+		for (i = idx; i < wp->w_lines_valid; ++i)
+		{
+		    /* Only valid lines have a meaningful wl_lnum.  Invalid
+		     * lines are part of the changed area. */
+		    if (wp->w_lines[i].wl_valid
+			    && wp->w_lines[i].wl_lnum == mod_bot)
+			break;
+		    old_rows += wp->w_lines[i].wl_size;
+#ifdef FEAT_FOLDING
+		    if (wp->w_lines[i].wl_valid
+			    && wp->w_lines[i].wl_lastlnum + 1 == mod_bot)
+		    {
+			/* Must have found the last valid entry above mod_bot.
+			 * Add following invalid entries. */
+			++i;
+			while (i < wp->w_lines_valid
+						  && !wp->w_lines[i].wl_valid)
+			    old_rows += wp->w_lines[i++].wl_size;
+			break;
+		    }
+#endif
+		}
+
+		if (i >= wp->w_lines_valid)
+		{
+		    /* We can't find a valid line below the changed lines,
+		     * need to redraw until the end of the window.
+		     * Inserting/deleting lines has no use. */
+		    bot_start = 0;
+		}
+		else
+		{
+		    /* Able to count old number of rows: Count new window
+		     * rows, and may insert/delete lines */
+		    j = idx;
+		    for (l = lnum; l < mod_bot; ++l)
+		    {
+#ifdef FEAT_FOLDING
+			if (hasFoldingWin(wp, l, NULL, &l, TRUE, NULL))
+			    ++new_rows;
+			else
+#endif
+#ifdef FEAT_DIFF
+			    if (l == wp->w_topline)
+			    new_rows += plines_win_nofill(wp, l, TRUE)
+							      + wp->w_topfill;
+			else
+#endif
+			    new_rows += plines_win(wp, l, TRUE);
+			++j;
+			if (new_rows > wp->w_height - row - 2)
+			{
+			    /* it's getting too much, must redraw the rest */
+			    new_rows = 9999;
+			    break;
+			}
+		    }
+		    xtra_rows = new_rows - old_rows;
+		    if (xtra_rows < 0)
+		    {
+			/* May scroll text up.  If there is not enough
+			 * remaining text or scrolling fails, must redraw the
+			 * rest.  If scrolling works, must redraw the text
+			 * below the scrolled text. */
+			if (row - xtra_rows >= wp->w_height - 2)
+			    mod_bot = MAXLNUM;
+			else
+			{
+			    check_for_delay(FALSE);
+			    if (win_del_lines(wp, row,
+					  -xtra_rows, FALSE, FALSE, 0) == FAIL)
+				mod_bot = MAXLNUM;
+			    else
+				bot_start = wp->w_height + xtra_rows;
+			}
+		    }
+		    else if (xtra_rows > 0)
+		    {
+			/* May scroll text down.  If there is not enough
+			 * remaining text of scrolling fails, must redraw the
+			 * rest. */
+			if (row + xtra_rows >= wp->w_height - 2)
+			    mod_bot = MAXLNUM;
+			else
+			{
+			    check_for_delay(FALSE);
+			    if (win_ins_lines(wp, row + old_rows,
+					     xtra_rows, FALSE, FALSE) == FAIL)
+				mod_bot = MAXLNUM;
+			    else if (top_end > row + old_rows)
+				/* Scrolled the part at the top that requires
+				 * updating down. */
+				top_end += xtra_rows;
+			}
+		    }
+
+		    /* When not updating the rest, may need to move w_lines[]
+		     * entries. */
+		    if (mod_bot != MAXLNUM && i != j)
+		    {
+			if (j < i)
+			{
+			    int x = row + new_rows;
+
+			    /* move entries in w_lines[] upwards */
+			    for (;;)
+			    {
+				/* stop at last valid entry in w_lines[] */
+				if (i >= wp->w_lines_valid)
+				{
+				    wp->w_lines_valid = j;
+				    break;
+				}
+				wp->w_lines[j] = wp->w_lines[i];
+				/* stop at a line that won't fit */
+				if (x + (int)wp->w_lines[j].wl_size
+							   > wp->w_height)
+				{
+				    wp->w_lines_valid = j + 1;
+				    break;
+				}
+				x += wp->w_lines[j++].wl_size;
+				++i;
+			    }
+			    if (bot_start > x)
+				bot_start = x;
+			}
+			else /* j > i */
+			{
+			    /* move entries in w_lines[] downwards */
+			    j -= i;
+			    wp->w_lines_valid += j;
+			    if (wp->w_lines_valid > wp->w_height)
+				wp->w_lines_valid = wp->w_height;
+			    for (i = wp->w_lines_valid; i - j >= idx; --i)
+				wp->w_lines[i] = wp->w_lines[i - j];
+
+			    /* The w_lines[] entries for inserted lines are
+			     * now invalid, but wl_size may be used above.
+			     * Reset to zero. */
+			    while (i >= idx)
+			    {
+				wp->w_lines[i].wl_size = 0;
+				wp->w_lines[i--].wl_valid = FALSE;
+			    }
+			}
+		    }
+		}
+	    }
+
+#ifdef FEAT_FOLDING
+	    /*
+	     * When lines are folded, display one line for all of them.
+	     * Otherwise, display normally (can be several display lines when
+	     * 'wrap' is on).
+	     */
+	    fold_count = foldedCount(wp, lnum, &win_foldinfo);
+	    if (fold_count != 0)
+	    {
+		fold_line(wp, fold_count, &win_foldinfo, lnum, row);
+		++row;
+		--fold_count;
+		wp->w_lines[idx].wl_folded = TRUE;
+		wp->w_lines[idx].wl_lastlnum = lnum + fold_count;
+# ifdef FEAT_SYN_HL
+		did_update = DID_FOLD;
+# endif
+	    }
+	    else
+#endif
+	    if (idx < wp->w_lines_valid
+		    && wp->w_lines[idx].wl_valid
+		    && wp->w_lines[idx].wl_lnum == lnum
+		    && lnum > wp->w_topline
+		    && !(dy_flags & (DY_LASTLINE | DY_TRUNCATE))
+		    && srow + wp->w_lines[idx].wl_size > wp->w_height
+#ifdef FEAT_DIFF
+		    && diff_check_fill(wp, lnum) == 0
+#endif
+		    )
+	    {
+		/* This line is not going to fit.  Don't draw anything here,
+		 * will draw "@  " lines below. */
+		row = wp->w_height + 1;
+	    }
+	    else
+	    {
+#ifdef FEAT_SEARCH_EXTRA
+		prepare_search_hl(wp, lnum);
+#endif
+#ifdef FEAT_SYN_HL
+		/* Let the syntax stuff know we skipped a few lines. */
+		if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum
+						       && syntax_present(wp))
+		    syntax_end_parsing(syntax_last_parsed + 1);
+#endif
+
+		/*
+		 * Display one line.
+		 */
+		row = win_line(wp, lnum, srow, wp->w_height, mod_top == 0);
+
+#ifdef FEAT_FOLDING
+		wp->w_lines[idx].wl_folded = FALSE;
+		wp->w_lines[idx].wl_lastlnum = lnum;
+#endif
+#ifdef FEAT_SYN_HL
+		did_update = DID_LINE;
+		syntax_last_parsed = lnum;
+#endif
+	    }
+
+	    wp->w_lines[idx].wl_lnum = lnum;
+	    wp->w_lines[idx].wl_valid = TRUE;
+
+	    /* Past end of the window or end of the screen. Note that after
+	     * resizing wp->w_height may be end up too big. That's a problem
+	     * elsewhere, but prevent a crash here. */
+	    if (row > wp->w_height || row + wp->w_winrow >= Rows)
+	    {
+		/* we may need the size of that too long line later on */
+		if (dollar_vcol == -1)
+		    wp->w_lines[idx].wl_size = plines_win(wp, lnum, TRUE);
+		++idx;
+		break;
+	    }
+	    if (dollar_vcol == -1)
+		wp->w_lines[idx].wl_size = row - srow;
+	    ++idx;
+#ifdef FEAT_FOLDING
+	    lnum += fold_count + 1;
+#else
+	    ++lnum;
+#endif
+	}
+	else
+	{
+	    /* This line does not need updating, advance to the next one */
+	    row += wp->w_lines[idx++].wl_size;
+	    if (row > wp->w_height)	/* past end of screen */
+		break;
+#ifdef FEAT_FOLDING
+	    lnum = wp->w_lines[idx - 1].wl_lastlnum + 1;
+#else
+	    ++lnum;
+#endif
+#ifdef FEAT_SYN_HL
+	    did_update = DID_NONE;
+#endif
+	}
+
+	if (lnum > buf->b_ml.ml_line_count)
+	{
+	    eof = TRUE;
+	    break;
+	}
+    }
+    /*
+     * End of loop over all window lines.
+     */
+
+#ifdef FEAT_VTP
+    /* Rewrite the character at the end of the screen line. */
+    if (use_vtp())
+    {
+	int i;
+
+	for (i = 0; i < Rows; ++i)
+# ifdef FEAT_MBYTE
+	    if (enc_utf8)
+		if ((*mb_off2cells)(LineOffset[i] + Columns - 2,
+					   LineOffset[i] + screen_Columns) > 1)
+		    screen_draw_rectangle(i, Columns - 2, 1, 2, FALSE);
+		else
+		    screen_draw_rectangle(i, Columns - 1, 1, 1, FALSE);
+	    else
+# endif
+		screen_char(LineOffset[i] + Columns - 1, i, Columns - 1);
+    }
+#endif
+
+    if (idx > wp->w_lines_valid)
+	wp->w_lines_valid = idx;
+
+#ifdef FEAT_SYN_HL
+    /*
+     * Let the syntax stuff know we stop parsing here.
+     */
+    if (syntax_last_parsed != 0 && syntax_present(wp))
+	syntax_end_parsing(syntax_last_parsed + 1);
+#endif
+
+    /*
+     * If we didn't hit the end of the file, and we didn't finish the last
+     * line we were working on, then the line didn't fit.
+     */
+    wp->w_empty_rows = 0;
+#ifdef FEAT_DIFF
+    wp->w_filler_rows = 0;
+#endif
+    if (!eof && !didline)
+    {
+	if (lnum == wp->w_topline)
+	{
+	    /*
+	     * Single line that does not fit!
+	     * Don't overwrite it, it can be edited.
+	     */
+	    wp->w_botline = lnum + 1;
+	}
+#ifdef FEAT_DIFF
+	else if (diff_check_fill(wp, lnum) >= wp->w_height - srow)
+	{
+	    /* Window ends in filler lines. */
+	    wp->w_botline = lnum;
+	    wp->w_filler_rows = wp->w_height - srow;
+	}
+#endif
+	else if (dy_flags & DY_TRUNCATE)	/* 'display' has "truncate" */
+	{
+	    int scr_row = W_WINROW(wp) + wp->w_height - 1;
+
+	    /*
+	     * Last line isn't finished: Display "@@@" in the last screen line.
+	     */
+	    screen_puts_len((char_u *)"@@", 2, scr_row, wp->w_wincol,
+							      HL_ATTR(HLF_AT));
+	    screen_fill(scr_row, scr_row + 1,
+		    (int)wp->w_wincol + 2, (int)W_ENDCOL(wp),
+		    '@', ' ', HL_ATTR(HLF_AT));
+	    set_empty_rows(wp, srow);
+	    wp->w_botline = lnum;
+	}
+	else if (dy_flags & DY_LASTLINE)	/* 'display' has "lastline" */
+	{
+	    /*
+	     * Last line isn't finished: Display "@@@" at the end.
+	     */
+	    screen_fill(W_WINROW(wp) + wp->w_height - 1,
+		    W_WINROW(wp) + wp->w_height,
+		    (int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),
+		    '@', '@', HL_ATTR(HLF_AT));
+	    set_empty_rows(wp, srow);
+	    wp->w_botline = lnum;
+	}
+	else
+	{
+	    win_draw_end(wp, '@', ' ', srow, wp->w_height, HLF_AT);
+	    wp->w_botline = lnum;
+	}
+    }
+    else
+    {
+	draw_vsep_win(wp, row);
+	if (eof)		/* we hit the end of the file */
+	{
+	    wp->w_botline = buf->b_ml.ml_line_count + 1;
+#ifdef FEAT_DIFF
+	    j = diff_check_fill(wp, wp->w_botline);
+	    if (j > 0 && !wp->w_botfill)
+	    {
+		/*
+		 * Display filler lines at the end of the file
+		 */
+		if (char2cells(fill_diff) > 1)
+		    i = '-';
+		else
+		    i = fill_diff;
+		if (row + j > wp->w_height)
+		    j = wp->w_height - row;
+		win_draw_end(wp, i, i, row, row + (int)j, HLF_DED);
+		row += j;
+	    }
+#endif
+	}
+	else if (dollar_vcol == -1)
+	    wp->w_botline = lnum;
+
+	/* make sure the rest of the screen is blank */
+	/* put '~'s on rows that aren't part of the file. */
+	win_draw_end(wp, '~', ' ', row, wp->w_height, HLF_EOB);
+    }
+
+#ifdef SYN_TIME_LIMIT
+    syn_set_timeout(NULL);
+#endif
+
+    /* Reset the type of redrawing required, the window has been updated. */
+    wp->w_redr_type = 0;
+#ifdef FEAT_DIFF
+    wp->w_old_topfill = wp->w_topfill;
+    wp->w_old_botfill = wp->w_botfill;
+#endif
+
+    if (dollar_vcol == -1)
+    {
+	/*
+	 * There is a trick with w_botline.  If we invalidate it on each
+	 * change that might modify it, this will cause a lot of expensive
+	 * calls to plines() in update_topline() each time.  Therefore the
+	 * value of w_botline is often approximated, and this value is used to
+	 * compute the value of w_topline.  If the value of w_botline was
+	 * wrong, check that the value of w_topline is correct (cursor is on
+	 * the visible part of the text).  If it's not, we need to redraw
+	 * again.  Mostly this just means scrolling up a few lines, so it
+	 * doesn't look too bad.  Only do this for the current window (where
+	 * changes are relevant).
+	 */
+	wp->w_valid |= VALID_BOTLINE;
+	if (wp == curwin && wp->w_botline != old_botline && !recursive)
+	{
+	    recursive = TRUE;
+	    curwin->w_valid &= ~VALID_TOPLINE;
+	    update_topline();	/* may invalidate w_botline again */
+	    if (must_redraw != 0)
+	    {
+		/* Don't update for changes in buffer again. */
+		i = curbuf->b_mod_set;
+		curbuf->b_mod_set = FALSE;
+		win_update(curwin);
+		must_redraw = 0;
+		curbuf->b_mod_set = i;
+	    }
+	    recursive = FALSE;
+	}
+    }
+
+#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
+    /* restore got_int, unless CTRL-C was hit while redrawing */
+    if (!got_int)
+	got_int = save_got_int;
+#endif
+}
+
+/*
+ * Clear the rest of the window and mark the unused lines with "c1".  use "c2"
+ * as the filler character.
+ */
+    static void
+win_draw_end(
+    win_T	*wp,
+    int		c1,
+    int		c2,
+    int		row,
+    int		endrow,
+    hlf_T	hl)
+{
+#if defined(FEAT_FOLDING) || defined(FEAT_SIGNS) || defined(FEAT_CMDWIN)
+    int		n = 0;
+# define FDC_OFF n
+#else
+# define FDC_OFF 0
+#endif
+#ifdef FEAT_FOLDING
+    int		fdc = compute_foldcolumn(wp, 0);
+#endif
+
+#ifdef FEAT_RIGHTLEFT
+    if (wp->w_p_rl)
+    {
+	/* No check for cmdline window: should never be right-left. */
+# ifdef FEAT_FOLDING
+	n = fdc;
+
+	if (n > 0)
+	{
+	    /* draw the fold column at the right */
+	    if (n > wp->w_width)
+		n = wp->w_width;
+	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		    W_ENDCOL(wp) - n, (int)W_ENDCOL(wp),
+		    ' ', ' ', HL_ATTR(HLF_FC));
+	}
+# endif
+# ifdef FEAT_SIGNS
+	if (signcolumn_on(wp))
+	{
+	    int nn = n + 2;
+
+	    /* draw the sign column left of the fold column */
+	    if (nn > wp->w_width)
+		nn = wp->w_width;
+	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		    W_ENDCOL(wp) - nn, (int)W_ENDCOL(wp) - n,
+		    ' ', ' ', HL_ATTR(HLF_SC));
+	    n = nn;
+	}
+# endif
+	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		wp->w_wincol, W_ENDCOL(wp) - 1 - FDC_OFF,
+		c2, c2, HL_ATTR(hl));
+	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		W_ENDCOL(wp) - 1 - FDC_OFF, W_ENDCOL(wp) - FDC_OFF,
+		c1, c2, HL_ATTR(hl));
+    }
+    else
+#endif
+    {
+#ifdef FEAT_CMDWIN
+	if (cmdwin_type != 0 && wp == curwin)
+	{
+	    /* draw the cmdline character in the leftmost column */
+	    n = 1;
+	    if (n > wp->w_width)
+		n = wp->w_width;
+	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		    wp->w_wincol, (int)wp->w_wincol + n,
+		    cmdwin_type, ' ', HL_ATTR(HLF_AT));
+	}
+#endif
+#ifdef FEAT_FOLDING
+	if (fdc > 0)
+	{
+	    int	    nn = n + fdc;
+
+	    /* draw the fold column at the left */
+	    if (nn > wp->w_width)
+		nn = wp->w_width;
+	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		    wp->w_wincol + n, (int)wp->w_wincol + nn,
+		    ' ', ' ', HL_ATTR(HLF_FC));
+	    n = nn;
+	}
+#endif
+#ifdef FEAT_SIGNS
+	if (signcolumn_on(wp))
+	{
+	    int	    nn = n + 2;
+
+	    /* draw the sign column after the fold column */
+	    if (nn > wp->w_width)
+		nn = wp->w_width;
+	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		    wp->w_wincol + n, (int)wp->w_wincol + nn,
+		    ' ', ' ', HL_ATTR(HLF_SC));
+	    n = nn;
+	}
+#endif
+	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
+		wp->w_wincol + FDC_OFF, (int)W_ENDCOL(wp),
+		c1, c2, HL_ATTR(hl));
+    }
+    set_empty_rows(wp, row);
+}
+
+#ifdef FEAT_SYN_HL
+static int advance_color_col(int vcol, int **color_cols);
+
+/*
+ * Advance **color_cols and return TRUE when there are columns to draw.
+ */
+    static int
+advance_color_col(int vcol, int **color_cols)
+{
+    while (**color_cols >= 0 && vcol > **color_cols)
+	++*color_cols;
+    return (**color_cols >= 0);
+}
+#endif
+
+#if defined(FEAT_MENU) || defined(FEAT_FOLDING)
+/*
+ * Copy "text" to ScreenLines using "attr".
+ * Returns the next screen column.
+ */
+    static int
+text_to_screenline(win_T *wp, char_u *text, int col)
+{
+    int		off = (int)(current_ScreenLine - ScreenLines);
+
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+    {
+	int	cells;
+	int	u8c, u8cc[MAX_MCO];
+	int	i;
+	int	idx;
+	int	c_len;
+	char_u	*p;
+# ifdef FEAT_ARABIC
+	int	prev_c = 0;		/* previous Arabic character */
+	int	prev_c1 = 0;		/* first composing char for prev_c */
+# endif
+
+# ifdef FEAT_RIGHTLEFT
+	if (wp->w_p_rl)
+	    idx = off;
+	else
+# endif
+	    idx = off + col;
+
+	/* Store multibyte characters in ScreenLines[] et al. correctly. */
+	for (p = text; *p != NUL; )
+	{
+	    cells = (*mb_ptr2cells)(p);
+	    c_len = (*mb_ptr2len)(p);
+	    if (col + cells > wp->w_width
+# ifdef FEAT_RIGHTLEFT
+		    - (wp->w_p_rl ? col : 0)
+# endif
+		    )
+		break;
+	    ScreenLines[idx] = *p;
+	    if (enc_utf8)
+	    {
+		u8c = utfc_ptr2char(p, u8cc);
+		if (*p < 0x80 && u8cc[0] == 0)
+		{
+		    ScreenLinesUC[idx] = 0;
+#ifdef FEAT_ARABIC
+		    prev_c = u8c;
+#endif
+		}
+		else
+		{
+#ifdef FEAT_ARABIC
+		    if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))
+		    {
+			/* Do Arabic shaping. */
+			int	pc, pc1, nc;
+			int	pcc[MAX_MCO];
+			int	firstbyte = *p;
+
+			/* The idea of what is the previous and next
+			 * character depends on 'rightleft'. */
+			if (wp->w_p_rl)
+			{
+			    pc = prev_c;
+			    pc1 = prev_c1;
+			    nc = utf_ptr2char(p + c_len);
+			    prev_c1 = u8cc[0];
+			}
+			else
+			{
+			    pc = utfc_ptr2char(p + c_len, pcc);
+			    nc = prev_c;
+			    pc1 = pcc[0];
+			}
+			prev_c = u8c;
+
+			u8c = arabic_shape(u8c, &firstbyte, &u8cc[0],
+								 pc, pc1, nc);
+			ScreenLines[idx] = firstbyte;
+		    }
+		    else
+			prev_c = u8c;
+#endif
+		    /* Non-BMP character: display as ? or fullwidth ?. */
+#ifdef UNICODE16
+		    if (u8c >= 0x10000)
+			ScreenLinesUC[idx] = (cells == 2) ? 0xff1f : (int)'?';
+		    else
+#endif
+			ScreenLinesUC[idx] = u8c;
+		    for (i = 0; i < Screen_mco; ++i)
+		    {
+			ScreenLinesC[i][idx] = u8cc[i];
+			if (u8cc[i] == 0)
+			    break;
+		    }
+		}
+		if (cells > 1)
+		    ScreenLines[idx + 1] = 0;
+	    }
+	    else if (enc_dbcs == DBCS_JPNU && *p == 0x8e)
+		/* double-byte single width character */
+		ScreenLines2[idx] = p[1];
+	    else if (cells > 1)
+		/* double-width character */
+		ScreenLines[idx + 1] = p[1];
+	    col += cells;
+	    idx += cells;
+	    p += c_len;
+	}
+    }
+    else
+#endif
+    {
+	int len = (int)STRLEN(text);
+
+	if (len > wp->w_width - col)
+	    len = wp->w_width - col;
+	if (len > 0)
+	{
+#ifdef FEAT_RIGHTLEFT
+	    if (wp->w_p_rl)
+		STRNCPY(current_ScreenLine, text, len);
+	    else
+#endif
+		STRNCPY(current_ScreenLine + col, text, len);
+	    col += len;
+	}
+    }
+    return col;
+}
+#endif
+
+#ifdef FEAT_FOLDING
+/*
+ * Compute the width of the foldcolumn.  Based on 'foldcolumn' and how much
+ * space is available for window "wp", minus "col".
+ */
+    static int
+compute_foldcolumn(win_T *wp, int col)
+{
+    int fdc = wp->w_p_fdc;
+    int wmw = wp == curwin && p_wmw == 0 ? 1 : p_wmw;
+    int wwidth = wp->w_width;
+
+    if (fdc > wwidth - (col + wmw))
+	fdc = wwidth - (col + wmw);
+    return fdc;
+}
+
+/*
+ * Display one folded line.
+ */
+    static void
+fold_line(
+    win_T	*wp,
+    long	fold_count,
+    foldinfo_T	*foldinfo,
+    linenr_T	lnum,
+    int		row)
+{
+    char_u	buf[FOLD_TEXT_LEN];
+    pos_T	*top, *bot;
+    linenr_T	lnume = lnum + fold_count - 1;
+    int		len;
+    char_u	*text;
+    int		fdc;
+    int		col;
+    int		txtcol;
+    int		off = (int)(current_ScreenLine - ScreenLines);
+    int		ri;
+
+    /* Build the fold line:
+     * 1. Add the cmdwin_type for the command-line window
+     * 2. Add the 'foldcolumn'
+     * 3. Add the 'number' or 'relativenumber' column
+     * 4. Compose the text
+     * 5. Add the text
+     * 6. set highlighting for the Visual area an other text
+     */
+    col = 0;
+
+    /*
+     * 1. Add the cmdwin_type for the command-line window
+     * Ignores 'rightleft', this window is never right-left.
+     */
+#ifdef FEAT_CMDWIN
+    if (cmdwin_type != 0 && wp == curwin)
+    {
+	ScreenLines[off] = cmdwin_type;
+	ScreenAttrs[off] = HL_ATTR(HLF_AT);
+#ifdef FEAT_MBYTE
+	if (enc_utf8)
+	    ScreenLinesUC[off] = 0;
+#endif
+	++col;
+    }
+#endif
+
+    /*
+     * 2. Add the 'foldcolumn'
+     *    Reduce the width when there is not enough space.
+     */
+    fdc = compute_foldcolumn(wp, col);
+    if (fdc > 0)
+    {
+	fill_foldcolumn(buf, wp, TRUE, lnum);
+#ifdef FEAT_RIGHTLEFT
+	if (wp->w_p_rl)
+	{
+	    int		i;
+
+	    copy_text_attr(off + wp->w_width - fdc - col, buf, fdc,
+							     HL_ATTR(HLF_FC));
+	    /* reverse the fold column */
+	    for (i = 0; i < fdc; ++i)
+		ScreenLines[off + wp->w_width - i - 1 - col] = buf[i];
+	}
+	else
+#endif
+	    copy_text_attr(off + col, buf, fdc, HL_ATTR(HLF_FC));
+	col += fdc;
+    }
+
+#ifdef FEAT_RIGHTLEFT
+# define RL_MEMSET(p, v, l) \
+    do { \
+	if (wp->w_p_rl) \
+	    for (ri = 0; ri < l; ++ri) \
+	       ScreenAttrs[off + (wp->w_width - (p) - (l)) + ri] = v; \
+	 else \
+	    for (ri = 0; ri < l; ++ri) \
+	       ScreenAttrs[off + (p) + ri] = v; \
+    } while (0)
+#else
+# define RL_MEMSET(p, v, l) \
+    do { \
+	for (ri = 0; ri < l; ++ri) \
+	    ScreenAttrs[off + (p) + ri] = v; \
+    } while (0)
+#endif
+
+    /* Set all attributes of the 'number' or 'relativenumber' column and the
+     * text */
+    RL_MEMSET(col, HL_ATTR(HLF_FL), wp->w_width - col);
+
+#ifdef FEAT_SIGNS
+    /* If signs are being displayed, add two spaces. */
+    if (signcolumn_on(wp))
+    {
+	len = wp->w_width - col;
+	if (len > 0)
+	{
+	    if (len > 2)
+		len = 2;
+# ifdef FEAT_RIGHTLEFT
+	    if (wp->w_p_rl)
+		/* the line number isn't reversed */
+		copy_text_attr(off + wp->w_width - len - col,
+					(char_u *)"  ", len, HL_ATTR(HLF_FL));
+	    else
+# endif
+		copy_text_attr(off + col, (char_u *)"  ", len, HL_ATTR(HLF_FL));
+	    col += len;
+	}
+    }
+#endif
+
+    /*
+     * 3. Add the 'number' or 'relativenumber' column
+     */
+    if (wp->w_p_nu || wp->w_p_rnu)
+    {
+	len = wp->w_width - col;
+	if (len > 0)
+	{
+	    int	    w = number_width(wp);
+	    long    num;
+	    char    *fmt = "%*ld ";
+
+	    if (len > w + 1)
+		len = w + 1;
+
+	    if (wp->w_p_nu && !wp->w_p_rnu)
+		/* 'number' + 'norelativenumber' */
+		num = (long)lnum;
+	    else
+	    {
+		/* 'relativenumber', don't use negative numbers */
+		num = labs((long)get_cursor_rel_lnum(wp, lnum));
+		if (num == 0 && wp->w_p_nu && wp->w_p_rnu)
+		{
+		    /* 'number' + 'relativenumber': cursor line shows absolute
+		     * line number */
+		    num = lnum;
+		    fmt = "%-*ld ";
+		}
+	    }
+
+	    sprintf((char *)buf, fmt, w, num);
+#ifdef FEAT_RIGHTLEFT
+	    if (wp->w_p_rl)
+		/* the line number isn't reversed */
+		copy_text_attr(off + wp->w_width - len - col, buf, len,
+							     HL_ATTR(HLF_FL));
+	    else
+#endif
+		copy_text_attr(off + col, buf, len, HL_ATTR(HLF_FL));
+	    col += len;
+	}
+    }
+
+    /*
+     * 4. Compose the folded-line string with 'foldtext', if set.
+     */
+    text = get_foldtext(wp, lnum, lnume, foldinfo, buf);
+
+    txtcol = col;	/* remember where text starts */
+
+    /*
+     * 5. move the text to current_ScreenLine.  Fill up with "fill_fold".
+     *    Right-left text is put in columns 0 - number-col, normal text is put
+     *    in columns number-col - window-width.
+     */
+    col = text_to_screenline(wp, text, col);
+
+    /* Fill the rest of the line with the fold filler */
+#ifdef FEAT_RIGHTLEFT
+    if (wp->w_p_rl)
+	col -= txtcol;
+#endif
+    while (col < wp->w_width
+#ifdef FEAT_RIGHTLEFT
+		    - (wp->w_p_rl ? txtcol : 0)
+#endif
+	    )
+    {
+#ifdef FEAT_MBYTE
+	if (enc_utf8)
+	{
+	    if (fill_fold >= 0x80)
+	    {
+		ScreenLinesUC[off + col] = fill_fold;
+		ScreenLinesC[0][off + col] = 0;
+		ScreenLines[off + col] = 0x80; /* avoid storing zero */
+	    }
+	    else
+	    {
+		ScreenLinesUC[off + col] = 0;
+		ScreenLines[off + col] = fill_fold;
+	    }
+	    col++;
+	}
+	else
+#endif
+	    ScreenLines[off + col++] = fill_fold;
+    }
+
+    if (text != buf)
+	vim_free(text);
+
+    /*
+     * 6. set highlighting for the Visual area an other text.
+     * If all folded lines are in the Visual area, highlight the line.
+     */
+    if (VIsual_active && wp->w_buffer == curwin->w_buffer)
+    {
+	if (LTOREQ_POS(curwin->w_cursor, VIsual))
+	{
+	    /* Visual is after curwin->w_cursor */
+	    top = &curwin->w_cursor;
+	    bot = &VIsual;
+	}
+	else
+	{
+	    /* Visual is before curwin->w_cursor */
+	    top = &VIsual;
+	    bot = &curwin->w_cursor;
+	}
+	if (lnum >= top->lnum
+		&& lnume <= bot->lnum
+		&& (VIsual_mode != 'v'
+		    || ((lnum > top->lnum
+			    || (lnum == top->lnum
+				&& top->col == 0))
+			&& (lnume < bot->lnum
+			    || (lnume == bot->lnum
+				&& (bot->col - (*p_sel == 'e'))
+		>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
+	{
+	    if (VIsual_mode == Ctrl_V)
+	    {
+		/* Visual block mode: highlight the chars part of the block */
+		if (wp->w_old_cursor_fcol + txtcol < (colnr_T)wp->w_width)
+		{
+		    if (wp->w_old_cursor_lcol != MAXCOL
+			     && wp->w_old_cursor_lcol + txtcol
+						       < (colnr_T)wp->w_width)
+			len = wp->w_old_cursor_lcol;
+		    else
+			len = wp->w_width - txtcol;
+		    RL_MEMSET(wp->w_old_cursor_fcol + txtcol, HL_ATTR(HLF_V),
+					    len - (int)wp->w_old_cursor_fcol);
+		}
+	    }
+	    else
+	    {
+		/* Set all attributes of the text */
+		RL_MEMSET(txtcol, HL_ATTR(HLF_V), wp->w_width - txtcol);
+	    }
+	}
+    }
+
+#ifdef FEAT_SYN_HL
+    /* Show colorcolumn in the fold line, but let cursorcolumn override it. */
+    if (wp->w_p_cc_cols)
+    {
+	int i = 0;
+	int j = wp->w_p_cc_cols[i];
+	int old_txtcol = txtcol;
+
+	while (j > -1)
+	{
+	    txtcol += j;
+	    if (wp->w_p_wrap)
+		txtcol -= wp->w_skipcol;
+	    else
+		txtcol -= wp->w_leftcol;
+	    if (txtcol >= 0 && txtcol < wp->w_width)
+		ScreenAttrs[off + txtcol] = hl_combine_attr(
+				    ScreenAttrs[off + txtcol], HL_ATTR(HLF_MC));
+	    txtcol = old_txtcol;
+	    j = wp->w_p_cc_cols[++i];
+	}
+    }
+
+    /* Show 'cursorcolumn' in the fold line. */
+    if (wp->w_p_cuc)
+    {
+	txtcol += wp->w_virtcol;
+	if (wp->w_p_wrap)
+	    txtcol -= wp->w_skipcol;
+	else
+	    txtcol -= wp->w_leftcol;
+	if (txtcol >= 0 && txtcol < wp->w_width)
+	    ScreenAttrs[off + txtcol] = hl_combine_attr(
+				 ScreenAttrs[off + txtcol], HL_ATTR(HLF_CUC));
+    }
+#endif
+
+    screen_line(row + W_WINROW(wp), wp->w_wincol, (int)wp->w_width,
+						     (int)wp->w_width, FALSE);
+
+    /*
+     * Update w_cline_height and w_cline_folded if the cursor line was
+     * updated (saves a call to plines() later).
+     */
+    if (wp == curwin
+	    && lnum <= curwin->w_cursor.lnum
+	    && lnume >= curwin->w_cursor.lnum)
+    {
+	curwin->w_cline_row = row;
+	curwin->w_cline_height = 1;
+	curwin->w_cline_folded = TRUE;
+	curwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);
+    }
+}
+
+/*
+ * Copy "buf[len]" to ScreenLines["off"] and set attributes to "attr".
+ */
+    static void
+copy_text_attr(
+    int		off,
+    char_u	*buf,
+    int		len,
+    int		attr)
+{
+    int		i;
+
+    mch_memmove(ScreenLines + off, buf, (size_t)len);
+# ifdef FEAT_MBYTE
+    if (enc_utf8)
+	vim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);
+# endif
+    for (i = 0; i < len; ++i)
+	ScreenAttrs[off + i] = attr;
+}
+
+/*
+ * Fill the foldcolumn at "p" for window "wp".
+ * Only to be called when 'foldcolumn' > 0.
+ */
+    static void
+fill_foldcolumn(
+    char_u	*p,
+    win_T	*wp,
+    int		closed,		/* TRUE of FALSE */
+    linenr_T	lnum)		/* current line number */
+{
+    int		i = 0;
+    int		level;
+    int		first_level;
+    int		empty;
+    int		fdc = compute_foldcolumn(wp, 0);
+
+    /* Init to all spaces. */
+    vim_memset(p, ' ', (size_t)fdc);
+
+    level = win_foldinfo.fi_level;
+    if (level > 0)
+    {
+	/* If there is only one column put more info in it. */
+	empty = (fdc == 1) ? 0 : 1;
+
+	/* If the column is too narrow, we start at the lowest level that
+	 * fits and use numbers to indicated the depth. */
+	first_level = level - fdc - closed + 1 + empty;
+	if (first_level < 1)
+	    first_level = 1;
+
+	for (i = 0; i + empty < fdc; ++i)
+	{
+	    if (win_foldinfo.fi_lnum == lnum
+			      && first_level + i >= win_foldinfo.fi_low_level)
+		p[i] = '-';
+	    else if (first_level == 1)
+		p[i] = '|';
+	    else if (first_level + i <= 9)
+		p[i] = '0' + first_level + i;
+	    else
+		p[i] = '>';
+	    if (first_level + i == level)
+		break;
+	}
+    }
+    if (closed)
+	p[i >= fdc ? i - 1 : i] = '+';
+}
+#endif /* FEAT_FOLDING */
+
+/*
+ * Display line "lnum" of window 'wp' on the screen.
+ * Start at row "startrow", stop when "endrow" is reached.
+ * wp->w_virtcol needs to be valid.
+ *
+ * Return the number of last row the line occupies.
+ */
+    static int
+win_line(
+    win_T	*wp,
+    linenr_T	lnum,
+    int		startrow,
+    int		endrow,
+    int		nochange UNUSED)	/* not updating for changed text */
+{
+    int		col = 0;		/* visual column on screen */
+    unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
+    int		c = 0;			/* init for GCC */
+    long	vcol = 0;		/* virtual column (for tabs) */
+#ifdef FEAT_LINEBREAK
+    long	vcol_sbr = -1;		/* virtual column after showbreak */
+#endif
+    long	vcol_prev = -1;		/* "vcol" of previous character */
+    char_u	*line;			/* current line */
+    char_u	*ptr;			/* current position in "line" */
+    int		row;			/* row in the window, excl w_winrow */
+    int		screen_row;		/* row on the screen, incl w_winrow */
+
+    char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
+    int		n_extra = 0;		/* number of extra chars */
+    char_u	*p_extra = NULL;	/* string of extra chars, plus NUL */
+    char_u	*p_extra_free = NULL;   /* p_extra needs to be freed */
+    int		c_extra = NUL;		/* extra chars, all the same */
+    int		extra_attr = 0;		/* attributes when n_extra != 0 */
+    static char_u *at_end_str = (char_u *)""; /* used for p_extra when
+					   displaying lcs_eol at end-of-line */
+    int		lcs_eol_one = lcs_eol;	/* lcs_eol until it's been used */
+    int		lcs_prec_todo = lcs_prec;   /* lcs_prec until it's been used */
+
+    /* saved "extra" items for when draw_state becomes WL_LINE (again) */
+    int		saved_n_extra = 0;
+    char_u	*saved_p_extra = NULL;
+    int		saved_c_extra = 0;
+    int		saved_char_attr = 0;
+
+    int		n_attr = 0;		/* chars with special attr */
+    int		saved_attr2 = 0;	/* char_attr saved for n_attr */
+    int		n_attr3 = 0;		/* chars with overruling special attr */
+    int		saved_attr3 = 0;	/* char_attr saved for n_attr3 */
+
+    int		n_skip = 0;		/* nr of chars to skip for 'nowrap' */
+
+    int		fromcol, tocol;		/* start/end of inverting */
+    int		fromcol_prev = -2;	/* start of inverting after cursor */
+    int		noinvcur = FALSE;	/* don't invert the cursor */
+    pos_T	*top, *bot;
+    int		lnum_in_visual_area = FALSE;
+    pos_T	pos;
+    long	v;
+
+    int		char_attr = 0;		/* attributes for next character */
+    int		attr_pri = FALSE;	/* char_attr has priority */
+    int		area_highlighting = FALSE; /* Visual or incsearch highlighting
+					      in this line */
+    int		attr = 0;		/* attributes for area highlighting */
+    int		area_attr = 0;		/* attributes desired by highlighting */
+    int		search_attr = 0;	/* attributes desired by 'hlsearch' */
+#ifdef FEAT_SYN_HL
+    int		vcol_save_attr = 0;	/* saved attr for 'cursorcolumn' */
+    int		syntax_attr = 0;	/* attributes desired by syntax */
+    int		has_syntax = FALSE;	/* this buffer has syntax highl. */
+    int		save_did_emsg;
+    int		eol_hl_off = 0;		/* 1 if highlighted char after EOL */
+    int		draw_color_col = FALSE;	/* highlight colorcolumn */
+    int		*color_cols = NULL;	/* pointer to according columns array */
+#endif
+#ifdef FEAT_SPELL
+    int		has_spell = FALSE;	/* this buffer has spell checking */
+# define SPWORDLEN 150
+    char_u	nextline[SPWORDLEN * 2];/* text with start of the next line */
+    int		nextlinecol = 0;	/* column where nextline[] starts */
+    int		nextline_idx = 0;	/* index in nextline[] where next line
+					   starts */
+    int		spell_attr = 0;		/* attributes desired by spelling */
+    int		word_end = 0;		/* last byte with same spell_attr */
+    static linenr_T  checked_lnum = 0;	/* line number for "checked_col" */
+    static int	checked_col = 0;	/* column in "checked_lnum" up to which
+					 * there are no spell errors */
+    static int	cap_col = -1;		/* column to check for Cap word */
+    static linenr_T capcol_lnum = 0;	/* line number where "cap_col" used */
+    int		cur_checked_col = 0;	/* checked column for current line */
+#endif
+    int		extra_check;		/* has syntax or linebreak */
+#ifdef FEAT_MBYTE
+    int		multi_attr = 0;		/* attributes desired by multibyte */
+    int		mb_l = 1;		/* multi-byte byte length */
+    int		mb_c = 0;		/* decoded multi-byte character */
+    int		mb_utf8 = FALSE;	/* screen char is UTF-8 char */
+    int		u8cc[MAX_MCO];		/* composing UTF-8 chars */
+#endif
+#ifdef FEAT_DIFF
+    int		filler_lines;		/* nr of filler lines to be drawn */
+    int		filler_todo;		/* nr of filler lines still to do + 1 */
+    hlf_T	diff_hlf = (hlf_T)0;	/* type of diff highlighting */
+    int		change_start = MAXCOL;	/* first col of changed area */
+    int		change_end = -1;	/* last col of changed area */
+#endif
+    colnr_T	trailcol = MAXCOL;	/* start of trailing spaces */
+#ifdef FEAT_LINEBREAK
+    int		need_showbreak = FALSE; /* overlong line, skipping first x
+					   chars */
+#endif
+#if defined(FEAT_SIGNS) || defined(FEAT_QUICKFIX) \
+	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
+# define LINE_ATTR
+    int		line_attr = 0;		/* attribute for the whole line */
+#endif
+#ifdef FEAT_SEARCH_EXTRA
+    matchitem_T *cur;			/* points to the match list */
+    match_T	*shl;			/* points to search_hl or a match */
+    int		shl_flag;		/* flag to indicate whether search_hl
+					   has been processed or not */
+    int		pos_inprogress;		/* marks that position match search is
+					   in progress */
+    int		prevcol_hl_flag;	/* flag to indicate whether prevcol
+					   equals startcol of search_hl or one
+					   of the matches */
+#endif
+#ifdef FEAT_ARABIC
+    int		prev_c = 0;		/* previous Arabic character */
+    int		prev_c1 = 0;		/* first composing char for prev_c */
+#endif
+#if defined(LINE_ATTR)
+    int		did_line_attr = 0;
+#endif
+#ifdef FEAT_TERMINAL
+    int		get_term_attr = FALSE;
+    int		term_attr = 0;		/* background for terminal window */
+#endif
+
+    /* draw_state: items that are drawn in sequence: */
+#define WL_START	0		/* nothing done yet */
+#ifdef FEAT_CMDWIN
+# define WL_CMDLINE	WL_START + 1	/* cmdline window column */
+#else
+# define WL_CMDLINE	WL_START
+#endif
+#ifdef FEAT_FOLDING
+# define WL_FOLD	WL_CMDLINE + 1	/* 'foldcolumn' */
+#else
+# define WL_FOLD	WL_CMDLINE
+#endif
+#ifdef FEAT_SIGNS
+# define WL_SIGN	WL_FOLD + 1	/* column for signs */
+#else
+# define WL_SIGN	WL_FOLD		/* column for signs */
+#endif
+#define WL_NR		WL_SIGN + 1	/* line number */
+#ifdef FEAT_LINEBREAK
+# define WL_BRI		WL_NR + 1	/* 'breakindent' */
+#else
+# define WL_BRI		WL_NR
+#endif
+#if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
+# define WL_SBR		WL_BRI + 1	/* 'showbreak' or 'diff' */
+#else
+# define WL_SBR		WL_BRI
+#endif
+#define WL_LINE		WL_SBR + 1	/* text in the line */
+    int		draw_state = WL_START;	/* what to draw next */
+#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
+    int		feedback_col = 0;
+    int		feedback_old_attr = -1;
+#endif
+
+#ifdef FEAT_CONCEAL
+    int		syntax_flags	= 0;
+    int		syntax_seqnr	= 0;
+    int		prev_syntax_id	= 0;
+    int		conceal_attr	= HL_ATTR(HLF_CONCEAL);
+    int		is_concealing	= FALSE;
+    int		boguscols	= 0;	/* nonexistent columns added to force
+					   wrapping */
+    int		vcol_off	= 0;	/* offset for concealed characters */
+    int		did_wcol	= FALSE;
+    int		match_conc	= 0;	/* cchar for match functions */
+    int		has_match_conc  = 0;	/* match wants to conceal */
+    int		old_boguscols   = 0;
+# define VCOL_HLC (vcol - vcol_off)
+# define FIX_FOR_BOGUSCOLS \
+    { \
+	n_extra += vcol_off; \
+	vcol -= vcol_off; \
+	vcol_off = 0; \
+	col -= boguscols; \
+	old_boguscols = boguscols; \
+	boguscols = 0; \
+    }
+#else
+# define VCOL_HLC (vcol)
+#endif
+
+    if (startrow > endrow)		/* past the end already! */
+	return startrow;
+
+    row = startrow;
+    screen_row = row + W_WINROW(wp);
+
+    /*
+     * To speed up the loop below, set extra_check when there is linebreak,
+     * trailing white space and/or syntax processing to be done.
+     */
+#ifdef FEAT_LINEBREAK
+    extra_check = wp->w_p_lbr;
+#else
+    extra_check = 0;
+#endif
+#ifdef FEAT_SYN_HL
+    if (syntax_present(wp) && !wp->w_s->b_syn_error
+# ifdef SYN_TIME_LIMIT
+	    && !wp->w_s->b_syn_slow
+# endif
+       )
+    {
+	/* Prepare for syntax highlighting in this line.  When there is an
+	 * error, stop syntax highlighting. */
+	save_did_emsg = did_emsg;
+	did_emsg = FALSE;
+	syntax_start(wp, lnum);
+	if (did_emsg)
+	    wp->w_s->b_syn_error = TRUE;
+	else
+	{
+	    did_emsg = save_did_emsg;
+#ifdef SYN_TIME_LIMIT
+	    if (!wp->w_s->b_syn_slow)
+#endif
+	    {
+		has_syntax = TRUE;
+		extra_check = TRUE;
+	    }
+	}
+    }
+
+    /* Check for columns to display for 'colorcolumn'. */
+    color_cols = wp->w_p_cc_cols;
+    if (color_cols != NULL)
+	draw_color_col = advance_color_col(VCOL_HLC, &color_cols);
+#endif
+
+#ifdef FEAT_TERMINAL
+    if (term_show_buffer(wp->w_buffer))
+    {
+	extra_check = TRUE;
+	get_term_attr = TRUE;
+	term_attr = term_get_attr(wp->w_buffer, lnum, -1);
+    }
+#endif
+
+#ifdef FEAT_SPELL
+    if (wp->w_p_spell
+	    && *wp->w_s->b_p_spl != NUL
+	    && wp->w_s->b_langp.ga_len > 0
+	    && *(char **)(wp->w_s->b_langp.ga_data) != NULL)
+    {
+	/* Prepare for spell checking. */
+	has_spell = TRUE;
+	extra_check = TRUE;
+
+	/* Get the start of the next line, so that words that wrap to the next
+	 * line are found too: "et<line-break>al.".
+	 * Trick: skip a few chars for C/shell/Vim comments */
+	nextline[SPWORDLEN] = NUL;
+	if (lnum < wp->w_buffer->b_ml.ml_line_count)
+	{
+	    line = ml_get_buf(wp->w_buffer, lnum + 1, FALSE);
+	    spell_cat_line(nextline + SPWORDLEN, line, SPWORDLEN);
+	}
+
+	/* When a word wrapped from the previous line the start of the current
+	 * line is valid. */
+	if (lnum == checked_lnum)
+	    cur_checked_col = checked_col;
+	checked_lnum = 0;
+
+	/* When there was a sentence end in the previous line may require a
+	 * word starting with capital in this line.  In line 1 always check
+	 * the first word. */
+	if (lnum != capcol_lnum)
+	    cap_col = -1;
+	if (lnum == 1)
+	    cap_col = 0;
+	capcol_lnum = 0;
+    }
+#endif
+
+    /*
+     * handle visual active in this window
+     */
+    fromcol = -10;
+    tocol = MAXCOL;
+    if (VIsual_active && wp->w_buffer == curwin->w_buffer)
+    {
+					/* Visual is after curwin->w_cursor */
+	if (LTOREQ_POS(curwin->w_cursor, VIsual))
+	{
+	    top = &curwin->w_cursor;
+	    bot = &VIsual;
+	}
+	else				/* Visual is before curwin->w_cursor */
+	{
+	    top = &VIsual;
+	    bot = &curwin->w_cursor;
+	}
+	lnum_in_visual_area = (lnum >= top->lnum && lnum <= bot->lnum);
+	if (VIsual_mode == Ctrl_V)	/* block mode */
+	{
+	    if (lnum_in_visual_area)
+	    {
+		fromcol = wp->w_old_cursor_fcol;
+		tocol = wp->w_old_cursor_lcol;
+	    }
+	}
+	else				/* non-block mode */
+	{
+	    if (lnum > top->lnum && lnum <= bot->lnum)
+		fromcol = 0;
+	    else if (lnum == top->lnum)
+	    {
+		if (VIsual_mode == 'V')	/* linewise */
+		    fromcol = 0;
+		else
+		{
+		    getvvcol(wp, top, (colnr_T *)&fromcol, NULL, NULL);
+		    if (gchar_pos(top) == NUL)
+			tocol = fromcol + 1;
+		}
+	    }
+	    if (VIsual_mode != 'V' && lnum == bot->lnum)
+	    {
+		if (*p_sel == 'e' && bot->col == 0
+#ifdef FEAT_VIRTUALEDIT
+			&& bot->coladd == 0
+#endif
+		   )
+		{
+		    fromcol = -10;
+		    tocol = MAXCOL;
+		}
+		else if (bot->col == MAXCOL)
+		    tocol = MAXCOL;
+		else
+		{
+		    pos = *bot;
+		    if (*p_sel == 'e')
+			getvvcol(wp, &pos, (colnr_T *)&tocol, NULL, NULL);
+		    else
+		    {
+			getvvcol(wp, &pos, NULL, NULL, (colnr_T *)&tocol);
+			++tocol;
+		    }
+		}
+	    }
+	}
+
+	/* Check if the character under the cursor should not be inverted */
+	if (!highlight_match && lnum == curwin->w_cursor.lnum && wp == curwin
+#ifdef FEAT_GUI
+		&& !gui.in_use
+#endif
+		)
+	    noinvcur = TRUE;
+
+	/* if inverting in this line set area_highlighting */
+	if (fromcol >= 0)
+	{
+	    area_highlighting = TRUE;
+	    attr = HL_ATTR(HLF_V);
+#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+	    if ((clip_star.available && !clip_star.owned
+						     && clip_isautosel_star())
+		    || (clip_plus.available && !clip_plus.owned
+						    && clip_isautosel_plus()))
+		attr = HL_ATTR(HLF_VNC);
+#endif
+	}
+    }
+
+    /*
+     * handle 'incsearch' and ":s///c" highlighting
+     */
+    else if (highlight_match
+	    && wp == curwin
+	    && lnum >= curwin->w_cursor.lnum
+	    && lnum <= curwin->w_cursor.lnum + search_match_lines)
+    {
+	if (lnum == curwin->w_cursor.lnum)
+	    getvcol(curwin, &(curwin->w_cursor),
+					     (colnr_T *)&fromcol, NULL, NULL);
+	else
+	    fromcol = 0;
+	if (lnum == curwin->w_cursor.lnum + search_match_lines)
+	{
+	    pos.lnum = lnum;
+	    pos.col = search_match_endcol;
+	    getvcol(curwin, &pos, (colnr_T *)&tocol, NULL, NULL);
+	}
+	else
+	    tocol = MAXCOL;
+	/* do at least one character; happens when past end of line */
+	if (fromcol == tocol)
+	    tocol = fromcol + 1;
+	area_highlighting = TRUE;
+	attr = HL_ATTR(HLF_I);
+    }
+
+#ifdef FEAT_DIFF
+    filler_lines = diff_check(wp, lnum);
+    if (filler_lines < 0)
+    {
+	if (filler_lines == -1)
+	{
+	    if (diff_find_change(wp, lnum, &change_start, &change_end))
+		diff_hlf = HLF_ADD;	/* added line */
+	    else if (change_start == 0)
+		diff_hlf = HLF_TXD;	/* changed text */
+	    else
+		diff_hlf = HLF_CHD;	/* changed line */
+	}
+	else
+	    diff_hlf = HLF_ADD;		/* added line */
+	filler_lines = 0;
+	area_highlighting = TRUE;
+    }
+    if (lnum == wp->w_topline)
+	filler_lines = wp->w_topfill;
+    filler_todo = filler_lines;
+#endif
+
+#ifdef LINE_ATTR
+# ifdef FEAT_SIGNS
+    /* If this line has a sign with line highlighting set line_attr. */
+    v = buf_getsigntype(wp->w_buffer, lnum, SIGN_LINEHL);
+    if (v != 0)
+	line_attr = sign_get_attr((int)v, TRUE);
+# endif
+# if defined(FEAT_QUICKFIX)
+    /* Highlight the current line in the quickfix window. */
+    if (bt_quickfix(wp->w_buffer) && qf_current_entry(wp) == lnum)
+	line_attr = HL_ATTR(HLF_QFL);
+# endif
+    if (line_attr != 0)
+	area_highlighting = TRUE;
+#endif
+
+    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
+    ptr = line;
+
+#ifdef FEAT_SPELL
+    if (has_spell)
+    {
+	/* For checking first word with a capital skip white space. */
+	if (cap_col == 0)
+	    cap_col = getwhitecols(line);
+
+	/* To be able to spell-check over line boundaries copy the end of the
+	 * current line into nextline[].  Above the start of the next line was
+	 * copied to nextline[SPWORDLEN]. */
+	if (nextline[SPWORDLEN] == NUL)
+	{
+	    /* No next line or it is empty. */
+	    nextlinecol = MAXCOL;
+	    nextline_idx = 0;
+	}
+	else
+	{
+	    v = (long)STRLEN(line);
+	    if (v < SPWORDLEN)
+	    {
+		/* Short line, use it completely and append the start of the
+		 * next line. */
+		nextlinecol = 0;
+		mch_memmove(nextline, line, (size_t)v);
+		STRMOVE(nextline + v, nextline + SPWORDLEN);
+		nextline_idx = v + 1;
+	    }
+	    else
+	    {
+		/* Long line, use only the last SPWORDLEN bytes. */
+		nextlinecol = v - SPWORDLEN;
+		mch_memmove(nextline, line + nextlinecol, SPWORDLEN);
+		nextline_idx = SPWORDLEN + 1;
+	    }
+	}
+    }
+#endif
+
+    if (wp->w_p_list)
+    {
+	if (lcs_space || lcs_trail)
+	    extra_check = TRUE;
+	/* find start of trailing whitespace */
+	if (lcs_trail)
+	{
+	    trailcol = (colnr_T)STRLEN(ptr);
+	    while (trailcol > (colnr_T)0 && VIM_ISWHITE(ptr[trailcol - 1]))
+		--trailcol;
+	    trailcol += (colnr_T) (ptr - line);
+	}
+    }
+
+    /*
+     * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the
+     * first character to be displayed.
+     */
+    if (wp->w_p_wrap)
+	v = wp->w_skipcol;
+    else
+	v = wp->w_leftcol;
+    if (v > 0)
+    {
+#ifdef FEAT_MBYTE
+	char_u	*prev_ptr = ptr;
+#endif
+	while (vcol < v && *ptr != NUL)
+	{
+	    c = win_lbr_chartabsize(wp, line, ptr, (colnr_T)vcol, NULL);
+	    vcol += c;
+#ifdef FEAT_MBYTE
+	    prev_ptr = ptr;
+#endif
+	    MB_PTR_ADV(ptr);
+	}
+
+	/* When:
+	 * - 'cuc' is set, or
+	 * - 'colorcolumn' is set, or
+	 * - 'virtualedit' is set, or
+	 * - the visual mode is active,
+	 * the end of the line may be before the start of the displayed part.
+	 */
+	if (vcol < v && (
+#ifdef FEAT_SYN_HL
+	     wp->w_p_cuc || draw_color_col ||
+#endif
+#ifdef FEAT_VIRTUALEDIT
+	     virtual_active() ||
+#endif
+	     (VIsual_active && wp->w_buffer == curwin->w_buffer)))
+	{
+	    vcol = v;
+	}
+
+	/* Handle a character that's not completely on the screen: Put ptr at
+	 * that character but skip the first few screen characters. */
+	if (vcol > v)
+	{
+	    vcol -= c;
+#ifdef FEAT_MBYTE
+	    ptr = prev_ptr;
+#else
+	    --ptr;
+#endif
+	    /* If the character fits on the screen, don't need to skip it.
+	     * Except for a TAB. */
+	    if ((
+#ifdef FEAT_MBYTE
+			(*mb_ptr2cells)(ptr) >= c ||
+#endif
+		       *ptr == TAB) && col == 0)
+	       n_skip = v - vcol;
+	}
+
+	/*
+	 * Adjust for when the inverted text is before the screen,
+	 * and when the start of the inverted text is before the screen.
+	 */
+	if (tocol <= vcol)
+	    fromcol = 0;
+	else if (fromcol >= 0 && fromcol < vcol)
+	    fromcol = vcol;
+
+#ifdef FEAT_LINEBREAK
+	/* When w_skipcol is non-zero, first line needs 'showbreak' */
+	if (wp->w_p_wrap)
+	    need_showbreak = TRUE;
+#endif
+#ifdef FEAT_SPELL
+	/* When spell checking a word we need to figure out the start of the
+	 * word and if it's badly spelled or not. */
+	if (has_spell)
+	{
+	    int		len;
+	    colnr_T	linecol = (colnr_T)(ptr - line);
+	    hlf_T	spell_hlf = HLF_COUNT;
+
+	    pos = wp->w_cursor;
+	    wp->w_cursor.lnum = lnum;
+	    wp->w_cursor.col = linecol;
+	    len = spell_move_to(wp, FORWARD, TRUE, TRUE, &spell_hlf);
+
+	    /* spell_move_to() may call ml_get() and make "line" invalid */
+	    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
+	    ptr = line + linecol;
+
+	    if (len == 0 || (int)wp->w_cursor.col > ptr - line)
+	    {
+		/* no bad word found at line start, don't check until end of a
+		 * word */
+		spell_hlf = HLF_COUNT;
+		word_end = (int)(spell_to_word_end(ptr, wp) - line + 1);
+	    }
+	    else
+	    {
+		/* bad word found, use attributes until end of word */
+		word_end = wp->w_cursor.col + len + 1;
+
+		/* Turn index into actual attributes. */
+		if (spell_hlf != HLF_COUNT)
+		    spell_attr = highlight_attr[spell_hlf];
+	    }
+	    wp->w_cursor = pos;
+
+# ifdef FEAT_SYN_HL
+	    /* Need to restart syntax highlighting for this line. */
+	    if (has_syntax)
+		syntax_start(wp, lnum);
+# endif
+	}
+#endif
+    }
+
+    /*
+     * Correct highlighting for cursor that can't be disabled.
+     * Avoids having to check this for each character.
+     */
+    if (fromcol >= 0)
+    {
+	if (noinvcur)
+	{
+	    if ((colnr_T)fromcol == wp->w_virtcol)
+	    {
+		/* highlighting starts at cursor, let it start just after the
+		 * cursor */
+		fromcol_prev = fromcol;
+		fromcol = -1;
+	    }
+	    else if ((colnr_T)fromcol < wp->w_virtcol)
+		/* restart highlighting after the cursor */
+		fromcol_prev = wp->w_virtcol;
+	}
+	if (fromcol >= tocol)
+	    fromcol = -1;
+    }
+
+#ifdef FEAT_SEARCH_EXTRA
+    /*
+     * Handle highlighting the last used search pattern and matches.
+     * Do this for both search_hl and the match list.
+     */
+    cur = wp->w_match_head;
+    shl_flag = FALSE;
+    while (cur != NULL || shl_flag == FALSE)
+    {
+	if (shl_flag == FALSE)
+	{
+	    shl = &search_hl;
+	    shl_flag = TRUE;
+	}
+	else
+	    shl = &cur->hl;
+	shl->startcol = MAXCOL;
+	shl->endcol = MAXCOL;
+	shl->attr_cur = 0;
+	shl->is_addpos = FALSE;
+	v = (long)(ptr - line);
+	if (cur != NULL)
+	    cur->pos.cur = 0;
+	next_search_hl(wp, shl, lnum, (colnr_T)v,
+					       shl == &search_hl ? NULL : cur);
+
+	/* Need to get the line again, a multi-line regexp may have made it
+	 * invalid. */
+	line = ml_get_buf(wp->w_buffer, lnum, FALSE);
+	ptr = line + v;
+
+	if (shl->lnum != 0 && shl->lnum <= lnum)
+	{
+	    if (shl->lnum == lnum)
+		shl->startcol = shl->rm.startpos[0].col;
+	    else
+		shl->startcol = 0;
+	    if (lnum == shl->lnum + shl->rm.endpos[0].lnum
+						- shl->rm.startpos[0].lnum)
+		shl->endcol = shl->rm.endpos[0].col;
+	    else
+		shl->endcol = MAXCOL;
+	    /* Highlight one character for an empty match. */
+	    if (shl->startcol == shl->endcol)
+	    {
+#ifdef FEAT_MBYTE
+		if (has_mbyte && line[shl->endcol] != NUL)
+		    shl->endcol += (*mb_ptr2len)(line + shl->endcol);
+		else
+#endif
+		    ++shl->endcol;
+	    }
+	    if ((long)shl->startcol < v)  /* match at leftcol */
+	    {
+		shl->attr_cur = shl->attr;
+		search_attr = shl->attr;
+	    }
+	    area_highlighting = TRUE;
+	}
+	if (shl != &search_hl && cur != NULL)
+	    cur = cur->next;
+    }
+#endif
+
+#ifdef FEAT_SYN_HL
+    /* Cursor line highlighting for 'cursorline' in the current window.  Not
+     * when Visual mode is active, because it's not clear what is selected
+     * then. */
+    if (wp->w_p_cul && lnum == wp->w_cursor.lnum
+					 && !(wp == curwin && VIsual_active))
+    {
+	line_attr = HL_ATTR(HLF_CUL);
+	area_highlighting = TRUE;
+    }
+#endif
+
+    off = (unsigned)(current_ScreenLine - ScreenLines);
+    col = 0;
+#ifdef FEAT_RIGHTLEFT
+    if (wp->w_p_rl)
+    {
+	/* Rightleft window: process the text in the normal direction, but put
+	 * it in current_ScreenLine[] from right to left.  Start at the
+	 * rightmost column of the window. */
+	col = wp->w_width - 1;
+	off += col;
+    }
+#endif
+
+    /*
+     * Repeat for the whole displayed line.
+     */
+    for (;;)
+    {
+#ifdef FEAT_CONCEAL
+	has_match_conc = 0;
+#endif
+	/* Skip this quickly when working on the text. */
+	if (draw_state != WL_LINE)
+	{
+#ifdef FEAT_CMDWIN
+	    if (draw_state == WL_CMDLINE - 1 && n_extra == 0)
+	    {
+		draw_state = WL_CMDLINE;
+		if (cmdwin_type != 0 && wp == curwin)
+		{
+		    /* Draw the cmdline character. */
+		    n_extra = 1;
+		    c_extra = cmdwin_type;
+		    char_attr = HL_ATTR(HLF_AT);
+		}
+	    }
+#endif
+
+#ifdef FEAT_FOLDING
+	    if (draw_state == WL_FOLD - 1 && n_extra == 0)
+	    {
+		int fdc = compute_foldcolumn(wp, 0);
+
+		draw_state = WL_FOLD;
+		if (fdc > 0)
+		{
+		    /* Draw the 'foldcolumn'.  Allocate a buffer, "extra" may
+		     * already be in use. */
+		    vim_free(p_extra_free);
+		    p_extra_free = alloc(12 + 1);
+
+		    if (p_extra_free != NULL)
+		    {
+			fill_foldcolumn(p_extra_free, wp, FALSE, lnum);
+			n_extra = fdc;
+			p_extra_free[n_extra] = NUL;
+			p_extra = p_extra_free;
+			c_extra = NUL;
+			char_attr = HL_ATTR(HLF_FC);
+		    }
+		}
+	    }
+#endif
+
+#ifdef FEAT_SIGNS
+	    if (draw_state == WL_SIGN - 1 && n_extra == 0)
+	    {
+		draw_state = WL_SIGN;
+		/* Show the sign column when there are any signs in this
+		 * buffer or when using Netbeans. */
+		if (signcolumn_on(wp))
+		{
+		    int	text_sign;
+# ifdef FEAT_SIGN_ICONS
+		    int	icon_sign;
+# endif
+
+		    /* Draw two cells with the sign value or blank. */
+		    c_extra = ' ';
+		    char_attr = HL_ATTR(HLF_SC);
+		    n_extra = 2;
+
+		    if (row == startrow
+#ifdef FEAT_DIFF
+			    + filler_lines && filler_todo <= 0
+#endif
+			    )
+		    {
+			text_sign = buf_getsigntype(wp->w_buffer, lnum,
+								   SIGN_TEXT);
+# ifdef FEAT_SIGN_ICONS
+			icon_sign = buf_getsigntype(wp->w_buffer, lnum,
+								   SIGN_ICON);
+			if (gui.in_use && icon_sign != 0)
+			{
+			    /* Use the image in this position. */
+			    c_extra = SIGN_BYTE;
+#  ifdef FEAT_NETBEANS_INTG
+			    if (buf_signcount(wp->w_buffer, lnum) > 1)
+				c_extra = MULTISIGN_BYTE;
+#  endif
+			    char_attr = icon_sign;
+			}
+			else
+# endif
+			    if (text_sign != 0)
+			{
+			    p_extra = sign_get_text(text_sign);
+			    if (p_extra != NULL)
+			    {
+				c_extra = NUL;
+				n_extra = (int)STRLEN(p_extra);
+			    }
+			    char_attr = sign_get_attr(text_sign, FALSE);
+			}
+		    }
+		}
+	    }
+#endif
+
+	    if (draw_state == WL_NR - 1 && n_extra == 0)
+	    {
+		draw_state = WL_NR;
+		/* Display the absolute or relative line number. After the
+		 * first fill with blanks when the 'n' flag isn't in 'cpo' */
+		if ((wp->w_p_nu || wp->w_p_rnu)
+			&& (row == startrow
+#ifdef FEAT_DIFF
+			    + filler_lines
+#endif
+			    || vim_strchr(p_cpo, CPO_NUMCOL) == NULL))
+		{
+		    /* Draw the line number (empty space after wrapping). */
+		    if (row == startrow
+#ifdef FEAT_DIFF
+			    + filler_lines
+#endif
+			    )
+		    {
+			long num;
+			char *fmt = "%*ld ";
+
+			if (wp->w_p_nu && !wp->w_p_rnu)
+			    /* 'number' + 'norelativenumber' */
+			    num = (long)lnum;
+			else
+			{
+			    /* 'relativenumber', don't use negative numbers */
+			    num = labs((long)get_cursor_rel_lnum(wp, lnum));
+			    if (num == 0 && wp->w_p_nu && wp->w_p_rnu)
+			    {
+				/* 'number' + 'relativenumber' */
+				num = lnum;
+				fmt = "%-*ld ";
+			    }
+			}
+
+			sprintf((char *)extra, fmt,
+						number_width(wp), num);
+			if (wp->w_skipcol > 0)
+			    for (p_extra = extra; *p_extra == ' '; ++p_extra)
+				*p_extra = '-';
+#ifdef FEAT_RIGHTLEFT
+			if (wp->w_p_rl)		    /* reverse line numbers */
+			    rl_mirror(extra);
+#endif
+			p_extra = extra;
+			c_extra = NUL;
+		    }
+		    else
+			c_extra = ' ';
+		    n_extra = number_width(wp) + 1;
+		    char_attr = HL_ATTR(HLF_N);
+#ifdef FEAT_SYN_HL
+		    /* When 'cursorline' is set highlight the line number of
+		     * the current line differently.
+		     * TODO: Can we use CursorLine instead of CursorLineNr
+		     * when CursorLineNr isn't set? */
+		    if ((wp->w_p_cul || wp->w_p_rnu)
+						 && lnum == wp->w_cursor.lnum)
+			char_attr = HL_ATTR(HLF_CLN);
+#endif
+		}
+	    }
+
+#ifdef FEAT_LINEBREAK
+	    if (wp->w_p_brisbr && draw_state == WL_BRI - 1
+					     && n_extra == 0 && *p_sbr != NUL)
+		/* draw indent after showbreak value */
+		draw_state = WL_BRI;
+	    else if (wp->w_p_brisbr && draw_state == WL_SBR && n_extra == 0)
+		/* After the showbreak, draw the breakindent */
+		draw_state = WL_BRI - 1;
+
+	    /* draw 'breakindent': indent wrapped text accordingly */
+	    if (draw_state == WL_BRI - 1 && n_extra == 0)
+	    {
+		draw_state = WL_BRI;
+		/* if need_showbreak is set, breakindent also applies */
+		if (wp->w_p_bri && n_extra == 0
+					 && (row != startrow || need_showbreak)
+# ifdef FEAT_DIFF
+			&& filler_lines == 0
+# endif
+		   )
+		{
+		    char_attr = 0;
+# ifdef FEAT_DIFF
+		    if (diff_hlf != (hlf_T)0)
+		    {
+			char_attr = HL_ATTR(diff_hlf);
+#  ifdef FEAT_SYN_HL
+			if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+			    char_attr = hl_combine_attr(char_attr,
+							    HL_ATTR(HLF_CUL));
+#  endif
+		    }
+# endif
+		    p_extra = NULL;
+		    c_extra = ' ';
+		    n_extra = get_breakindent_win(wp,
+				       ml_get_buf(wp->w_buffer, lnum, FALSE));
+		    /* Correct end of highlighted area for 'breakindent',
+		     * required when 'linebreak' is also set. */
+		    if (tocol == vcol)
+			tocol += n_extra;
+		}
+	    }
+#endif
+
+#if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
+	    if (draw_state == WL_SBR - 1 && n_extra == 0)
+	    {
+		draw_state = WL_SBR;
+# ifdef FEAT_DIFF
+		if (filler_todo > 0)
+		{
+		    /* Draw "deleted" diff line(s). */
+		    if (char2cells(fill_diff) > 1)
+			c_extra = '-';
+		    else
+			c_extra = fill_diff;
+#  ifdef FEAT_RIGHTLEFT
+		    if (wp->w_p_rl)
+			n_extra = col + 1;
+		    else
+#  endif
+			n_extra = wp->w_width - col;
+		    char_attr = HL_ATTR(HLF_DED);
+		}
+# endif
+# ifdef FEAT_LINEBREAK
+		if (*p_sbr != NUL && need_showbreak)
+		{
+		    /* Draw 'showbreak' at the start of each broken line. */
+		    p_extra = p_sbr;
+		    c_extra = NUL;
+		    n_extra = (int)STRLEN(p_sbr);
+		    char_attr = HL_ATTR(HLF_AT);
+		    need_showbreak = FALSE;
+		    vcol_sbr = vcol + MB_CHARLEN(p_sbr);
+		    /* Correct end of highlighted area for 'showbreak',
+		     * required when 'linebreak' is also set. */
+		    if (tocol == vcol)
+			tocol += n_extra;
+#ifdef FEAT_SYN_HL
+		    /* combine 'showbreak' with 'cursorline' */
+		    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+			char_attr = hl_combine_attr(char_attr,
+							    HL_ATTR(HLF_CUL));
+#endif
+		}
+# endif
+	    }
+#endif
+
+	    if (draw_state == WL_LINE - 1 && n_extra == 0)
+	    {
+		draw_state = WL_LINE;
+		if (saved_n_extra)
+		{
+		    /* Continue item from end of wrapped line. */
+		    n_extra = saved_n_extra;
+		    c_extra = saved_c_extra;
+		    p_extra = saved_p_extra;
+		    char_attr = saved_char_attr;
+		}
+		else
+		    char_attr = 0;
+	    }
+	}
+
+	/* When still displaying '$' of change command, stop at cursor */
+	if (dollar_vcol >= 0 && wp == curwin
+		   && lnum == wp->w_cursor.lnum && vcol >= (long)wp->w_virtcol
+#ifdef FEAT_DIFF
+				   && filler_todo <= 0
+#endif
+		)
+	{
+	    screen_line(screen_row, wp->w_wincol, col, -(int)wp->w_width,
+						    HAS_RIGHTLEFT(wp->w_p_rl));
+	    /* Pretend we have finished updating the window.  Except when
+	     * 'cursorcolumn' is set. */
+#ifdef FEAT_SYN_HL
+	    if (wp->w_p_cuc)
+		row = wp->w_cline_row + wp->w_cline_height;
+	    else
+#endif
+		row = wp->w_height;
+	    break;
+	}
+
+	if (draw_state == WL_LINE && area_highlighting)
+	{
+	    /* handle Visual or match highlighting in this line */
+	    if (vcol == fromcol
+#ifdef FEAT_MBYTE
+		    || (has_mbyte && vcol + 1 == fromcol && n_extra == 0
+			&& (*mb_ptr2cells)(ptr) > 1)
+#endif
+		    || ((int)vcol_prev == fromcol_prev
+			&& vcol_prev < vcol	/* not at margin */
+			&& vcol < tocol))
+		area_attr = attr;		/* start highlighting */
+	    else if (area_attr != 0
+		    && (vcol == tocol
+			|| (noinvcur && (colnr_T)vcol == wp->w_virtcol)))
+		area_attr = 0;			/* stop highlighting */
+
+#ifdef FEAT_SEARCH_EXTRA
+	    if (!n_extra)
+	    {
+		/*
+		 * Check for start/end of search pattern match.
+		 * After end, check for start/end of next match.
+		 * When another match, have to check for start again.
+		 * Watch out for matching an empty string!
+		 * Do this for 'search_hl' and the match list (ordered by
+		 * priority).
+		 */
+		v = (long)(ptr - line);
+		cur = wp->w_match_head;
+		shl_flag = FALSE;
+		while (cur != NULL || shl_flag == FALSE)
+		{
+		    if (shl_flag == FALSE
+			    && ((cur != NULL
+				    && cur->priority > SEARCH_HL_PRIORITY)
+				|| cur == NULL))
+		    {
+			shl = &search_hl;
+			shl_flag = TRUE;
+		    }
+		    else
+			shl = &cur->hl;
+		    if (cur != NULL)
+			cur->pos.cur = 0;
+		    pos_inprogress = TRUE;
+		    while (shl->rm.regprog != NULL
+					   || (cur != NULL && pos_inprogress))
+		    {
+			if (shl->startcol != MAXCOL
+				&& v >= (long)shl->startcol
+				&& v < (long)shl->endcol)
+			{
+#ifdef FEAT_MBYTE
+			    int tmp_col = v + MB_PTR2LEN(ptr);
+
+			    if (shl->endcol < tmp_col)
+				shl->endcol = tmp_col;
+#endif
+			    shl->attr_cur = shl->attr;
+#ifdef FEAT_CONCEAL
+			    if (cur != NULL && syn_name2id((char_u *)"Conceal")
+							       == cur->hlg_id)
+			    {
+				has_match_conc =
+					     v == (long)shl->startcol ? 2 : 1;
+				match_conc = cur->conceal_char;
+			    }
+			    else
+				has_match_conc = match_conc = 0;
+#endif
+			}
+			else if (v == (long)shl->endcol)
+			{
+			    shl->attr_cur = 0;
+			    next_search_hl(wp, shl, lnum, (colnr_T)v,
+					       shl == &search_hl ? NULL : cur);
+			    pos_inprogress = cur == NULL || cur->pos.cur == 0
+							       ? FALSE : TRUE;
+
+			    /* Need to get the line again, a multi-line regexp
+			     * may have made it invalid. */
+			    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
+			    ptr = line + v;
+
+			    if (shl->lnum == lnum)
+			    {
+				shl->startcol = shl->rm.startpos[0].col;
+				if (shl->rm.endpos[0].lnum == 0)
+				    shl->endcol = shl->rm.endpos[0].col;
+				else
+				    shl->endcol = MAXCOL;
+
+				if (shl->startcol == shl->endcol)
+				{
+				    /* highlight empty match, try again after
+				     * it */
+#ifdef FEAT_MBYTE
+				    if (has_mbyte)
+					shl->endcol += (*mb_ptr2len)(line
+							       + shl->endcol);
+				    else
+#endif
+					++shl->endcol;
+				}
+
+				/* Loop to check if the match starts at the
+				 * current position */
+				continue;
+			    }
+			}
+			break;
+		    }
+		    if (shl != &search_hl && cur != NULL)
+			cur = cur->next;
+		}
+
+		/* Use attributes from match with highest priority among
+		 * 'search_hl' and the match list. */
+		search_attr = search_hl.attr_cur;
+		cur = wp->w_match_head;
+		shl_flag = FALSE;
+		while (cur != NULL || shl_flag == FALSE)
+		{
+		    if (shl_flag == FALSE
+			    && ((cur != NULL
+				    && cur->priority > SEARCH_HL_PRIORITY)
+				|| cur == NULL))
+		    {
+			shl = &search_hl;
+			shl_flag = TRUE;
+		    }
+		    else
+			shl = &cur->hl;
+		    if (shl->attr_cur != 0)
+			search_attr = shl->attr_cur;
+		    if (shl != &search_hl && cur != NULL)
+			cur = cur->next;
+		}
+		/* Only highlight one character after the last column. */
+		if (*ptr == NUL && (did_line_attr >= 1
+				    || (wp->w_p_list && lcs_eol_one == -1)))
+		    search_attr = 0;
+	    }
+#endif
+
+#ifdef FEAT_DIFF
+	    if (diff_hlf != (hlf_T)0)
+	    {
+		if (diff_hlf == HLF_CHD && ptr - line >= change_start
+							      && n_extra == 0)
+		    diff_hlf = HLF_TXD;		/* changed text */
+		if (diff_hlf == HLF_TXD && ptr - line > change_end
+							      && n_extra == 0)
+		    diff_hlf = HLF_CHD;		/* changed line */
+		line_attr = HL_ATTR(diff_hlf);
+		if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+		    line_attr = hl_combine_attr(line_attr, HL_ATTR(HLF_CUL));
+	    }
+#endif
+
+	    /* Decide which of the highlight attributes to use. */
+	    attr_pri = TRUE;
+#ifdef LINE_ATTR
+	    if (area_attr != 0)
+		char_attr = hl_combine_attr(line_attr, area_attr);
+	    else if (search_attr != 0)
+		char_attr = hl_combine_attr(line_attr, search_attr);
+		/* Use line_attr when not in the Visual or 'incsearch' area
+		 * (area_attr may be 0 when "noinvcur" is set). */
+	    else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)
+				|| vcol < fromcol || vcol_prev < fromcol_prev
+				|| vcol >= tocol))
+		char_attr = line_attr;
+#else
+	    if (area_attr != 0)
+		char_attr = area_attr;
+	    else if (search_attr != 0)
+		char_attr = search_attr;
+#endif
+	    else
+	    {
+		attr_pri = FALSE;
+#ifdef FEAT_SYN_HL
+		if (has_syntax)
+		    char_attr = syntax_attr;
+		else
+#endif
+		    char_attr = 0;
+	    }
+	}
+
+	/*
+	 * Get the next character to put on the screen.
+	 */
+	/*
+	 * The "p_extra" points to the extra stuff that is inserted to
+	 * represent special characters (non-printable stuff) and other
+	 * things.  When all characters are the same, c_extra is used.
+	 * "p_extra" must end in a NUL to avoid mb_ptr2len() reads past
+	 * "p_extra[n_extra]".
+	 * For the '$' of the 'list' option, n_extra == 1, p_extra == "".
+	 */
+	if (n_extra > 0)
+	{
+	    if (c_extra != NUL)
+	    {
+		c = c_extra;
+#ifdef FEAT_MBYTE
+		mb_c = c;	/* doesn't handle non-utf-8 multi-byte! */
+		if (enc_utf8 && utf_char2len(c) > 1)
+		{
+		    mb_utf8 = TRUE;
+		    u8cc[0] = 0;
+		    c = 0xc0;
+		}
+		else
+		    mb_utf8 = FALSE;
+#endif
+	    }
+	    else
+	    {
+		c = *p_extra;
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		{
+		    mb_c = c;
+		    if (enc_utf8)
+		    {
+			/* If the UTF-8 character is more than one byte:
+			 * Decode it into "mb_c". */
+			mb_l = utfc_ptr2len(p_extra);
+			mb_utf8 = FALSE;
+			if (mb_l > n_extra)
+			    mb_l = 1;
+			else if (mb_l > 1)
+			{
+			    mb_c = utfc_ptr2char(p_extra, u8cc);
+			    mb_utf8 = TRUE;
+			    c = 0xc0;
+			}
+		    }
+		    else
+		    {
+			/* if this is a DBCS character, put it in "mb_c" */
+			mb_l = MB_BYTE2LEN(c);
+			if (mb_l >= n_extra)
+			    mb_l = 1;
+			else if (mb_l > 1)
+			    mb_c = (c << 8) + p_extra[1];
+		    }
+		    if (mb_l == 0)  /* at the NUL at end-of-line */
+			mb_l = 1;
+
+		    /* If a double-width char doesn't fit display a '>' in the
+		     * last column. */
+		    if ((
+# ifdef FEAT_RIGHTLEFT
+			    wp->w_p_rl ? (col <= 0) :
+# endif
+				    (col >= wp->w_width - 1))
+			    && (*mb_char2cells)(mb_c) == 2)
+		    {
+			c = '>';
+			mb_c = c;
+			mb_l = 1;
+			mb_utf8 = FALSE;
+			multi_attr = HL_ATTR(HLF_AT);
+			/* put the pointer back to output the double-width
+			 * character at the start of the next line. */
+			++n_extra;
+			--p_extra;
+		    }
+		    else
+		    {
+			n_extra -= mb_l - 1;
+			p_extra += mb_l - 1;
+		    }
+		}
+#endif
+		++p_extra;
+	    }
+	    --n_extra;
+	}
+	else
+	{
+#ifdef FEAT_LINEBREAK
+	    int c0;
+#endif
+
+	    if (p_extra_free != NULL)
+		VIM_CLEAR(p_extra_free);
+	    /*
+	     * Get a character from the line itself.
+	     */
+	    c = *ptr;
+#ifdef FEAT_LINEBREAK
+	    c0 = *ptr;
+#endif
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+	    {
+		mb_c = c;
+		if (enc_utf8)
+		{
+		    /* If the UTF-8 character is more than one byte: Decode it
+		     * into "mb_c". */
+		    mb_l = utfc_ptr2len(ptr);
+		    mb_utf8 = FALSE;
+		    if (mb_l > 1)
+		    {
+			mb_c = utfc_ptr2char(ptr, u8cc);
+			/* Overlong encoded ASCII or ASCII with composing char
+			 * is displayed normally, except a NUL. */
+			if (mb_c < 0x80)
+			{
+			    c = mb_c;
+# ifdef FEAT_LINEBREAK
+			    c0 = mb_c;
+# endif
+			}
+			mb_utf8 = TRUE;
+
+			/* At start of the line we can have a composing char.
+			 * Draw it as a space with a composing char. */
+			if (utf_iscomposing(mb_c))
+			{
+			    int i;
+
+			    for (i = Screen_mco - 1; i > 0; --i)
+				u8cc[i] = u8cc[i - 1];
+			    u8cc[0] = mb_c;
+			    mb_c = ' ';
+			}
+		    }
+
+		    if ((mb_l == 1 && c >= 0x80)
+			    || (mb_l >= 1 && mb_c == 0)
+			    || (mb_l > 1 && (!vim_isprintc(mb_c)
+# ifdef UNICODE16
+							 || mb_c >= 0x10000
+# endif
+							 )))
+		    {
+			/*
+			 * Illegal UTF-8 byte: display as <xx>.
+			 * Non-BMP character : display as ? or fullwidth ?.
+			 */
+# ifdef UNICODE16
+			if (mb_c < 0x10000)
+# endif
+			{
+			    transchar_hex(extra, mb_c);
+# ifdef FEAT_RIGHTLEFT
+			    if (wp->w_p_rl)		/* reverse */
+				rl_mirror(extra);
+# endif
+			}
+# ifdef UNICODE16
+			else if (utf_char2cells(mb_c) != 2)
+			    STRCPY(extra, "?");
+			else
+			    /* 0xff1f in UTF-8: full-width '?' */
+			    STRCPY(extra, "\357\274\237");
+# endif
+
+			p_extra = extra;
+			c = *p_extra;
+			mb_c = mb_ptr2char_adv(&p_extra);
+			mb_utf8 = (c >= 0x80);
+			n_extra = (int)STRLEN(p_extra);
+			c_extra = NUL;
+			if (area_attr == 0 && search_attr == 0)
+			{
+			    n_attr = n_extra + 1;
+			    extra_attr = HL_ATTR(HLF_8);
+			    saved_attr2 = char_attr; /* save current attr */
+			}
+		    }
+		    else if (mb_l == 0)  /* at the NUL at end-of-line */
+			mb_l = 1;
+#ifdef FEAT_ARABIC
+		    else if (p_arshape && !p_tbidi && ARABIC_CHAR(mb_c))
+		    {
+			/* Do Arabic shaping. */
+			int	pc, pc1, nc;
+			int	pcc[MAX_MCO];
+
+			/* The idea of what is the previous and next
+			 * character depends on 'rightleft'. */
+			if (wp->w_p_rl)
+			{
+			    pc = prev_c;
+			    pc1 = prev_c1;
+			    nc = utf_ptr2char(ptr + mb_l);
+			    prev_c1 = u8cc[0];
+			}
+			else
+			{
+			    pc = utfc_ptr2char(ptr + mb_l, pcc);
+			    nc = prev_c;
+			    pc1 = pcc[0];
+			}
+			prev_c = mb_c;
+
+			mb_c = arabic_shape(mb_c, &c, &u8cc[0], pc, pc1, nc);
+		    }
+		    else
+			prev_c = mb_c;
+#endif
+		}
+		else	/* enc_dbcs */
+		{
+		    mb_l = MB_BYTE2LEN(c);
+		    if (mb_l == 0)  /* at the NUL at end-of-line */
+			mb_l = 1;
+		    else if (mb_l > 1)
+		    {
+			/* We assume a second byte below 32 is illegal.
+			 * Hopefully this is OK for all double-byte encodings!
+			 */
+			if (ptr[1] >= 32)
+			    mb_c = (c << 8) + ptr[1];
+			else
+			{
+			    if (ptr[1] == NUL)
+			    {
+				/* head byte at end of line */
+				mb_l = 1;
+				transchar_nonprint(extra, c);
+			    }
+			    else
+			    {
+				/* illegal tail byte */
+				mb_l = 2;
+				STRCPY(extra, "XX");
+			    }
+			    p_extra = extra;
+			    n_extra = (int)STRLEN(extra) - 1;
+			    c_extra = NUL;
+			    c = *p_extra++;
+			    if (area_attr == 0 && search_attr == 0)
+			    {
+				n_attr = n_extra + 1;
+				extra_attr = HL_ATTR(HLF_8);
+				saved_attr2 = char_attr; /* save current attr */
+			    }
+			    mb_c = c;
+			}
+		    }
+		}
+		/* If a double-width char doesn't fit display a '>' in the
+		 * last column; the character is displayed at the start of the
+		 * next line. */
+		if ((
+# ifdef FEAT_RIGHTLEFT
+			    wp->w_p_rl ? (col <= 0) :
+# endif
+				(col >= wp->w_width - 1))
+			&& (*mb_char2cells)(mb_c) == 2)
+		{
+		    c = '>';
+		    mb_c = c;
+		    mb_utf8 = FALSE;
+		    mb_l = 1;
+		    multi_attr = HL_ATTR(HLF_AT);
+		    /* Put pointer back so that the character will be
+		     * displayed at the start of the next line. */
+		    --ptr;
+		}
+		else if (*ptr != NUL)
+		    ptr += mb_l - 1;
+
+		/* If a double-width char doesn't fit at the left side display
+		 * a '<' in the first column.  Don't do this for unprintable
+		 * characters. */
+		if (n_skip > 0 && mb_l > 1 && n_extra == 0)
+		{
+		    n_extra = 1;
+		    c_extra = MB_FILLER_CHAR;
+		    c = ' ';
+		    if (area_attr == 0 && search_attr == 0)
+		    {
+			n_attr = n_extra + 1;
+			extra_attr = HL_ATTR(HLF_AT);
+			saved_attr2 = char_attr; /* save current attr */
+		    }
+		    mb_c = c;
+		    mb_utf8 = FALSE;
+		    mb_l = 1;
+		}
+
+	    }
+#endif
+	    ++ptr;
+
+	    if (extra_check)
+	    {
+#ifdef FEAT_SPELL
+		int	can_spell = TRUE;
+#endif
+
+#ifdef FEAT_TERMINAL
+		if (get_term_attr)
+		{
+		    syntax_attr = term_get_attr(wp->w_buffer, lnum, vcol);
+
+		    if (!attr_pri)
+			char_attr = syntax_attr;
+		    else
+			char_attr = hl_combine_attr(syntax_attr, char_attr);
+		}
+#endif
+
+#ifdef FEAT_SYN_HL
+		/* Get syntax attribute, unless still at the start of the line
+		 * (double-wide char that doesn't fit). */
+		v = (long)(ptr - line);
+		if (has_syntax && v > 0)
+		{
+		    /* Get the syntax attribute for the character.  If there
+		     * is an error, disable syntax highlighting. */
+		    save_did_emsg = did_emsg;
+		    did_emsg = FALSE;
+
+		    syntax_attr = get_syntax_attr((colnr_T)v - 1,
+# ifdef FEAT_SPELL
+						has_spell ? &can_spell :
+# endif
+						NULL, FALSE);
+
+		    if (did_emsg)
+		    {
+			wp->w_s->b_syn_error = TRUE;
+			has_syntax = FALSE;
+		    }
+		    else
+			did_emsg = save_did_emsg;
+#ifdef SYN_TIME_LIMIT
+		    if (wp->w_s->b_syn_slow)
+			has_syntax = FALSE;
+#endif
+
+		    /* Need to get the line again, a multi-line regexp may
+		     * have made it invalid. */
+		    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
+		    ptr = line + v;
+
+		    if (!attr_pri)
+			char_attr = syntax_attr;
+		    else
+			char_attr = hl_combine_attr(syntax_attr, char_attr);
+# ifdef FEAT_CONCEAL
+		    /* no concealing past the end of the line, it interferes
+		     * with line highlighting */
+		    if (c == NUL)
+			syntax_flags = 0;
+		    else
+			syntax_flags = get_syntax_info(&syntax_seqnr);
+# endif
+		}
+#endif
+
+#ifdef FEAT_SPELL
+		/* Check spelling (unless at the end of the line).
+		 * Only do this when there is no syntax highlighting, the
+		 * @Spell cluster is not used or the current syntax item
+		 * contains the @Spell cluster. */
+		if (has_spell && v >= word_end && v > cur_checked_col)
+		{
+		    spell_attr = 0;
+# ifdef FEAT_SYN_HL
+		    if (!attr_pri)
+			char_attr = syntax_attr;
+# endif
+		    if (c != 0 && (
+# ifdef FEAT_SYN_HL
+				!has_syntax ||
+# endif
+				can_spell))
+		    {
+			char_u	*prev_ptr, *p;
+			int	len;
+			hlf_T	spell_hlf = HLF_COUNT;
+# ifdef FEAT_MBYTE
+			if (has_mbyte)
+			{
+			    prev_ptr = ptr - mb_l;
+			    v -= mb_l - 1;
+			}
+			else
+# endif
+			    prev_ptr = ptr - 1;
+
+			/* Use nextline[] if possible, it has the start of the
+			 * next line concatenated. */
+			if ((prev_ptr - line) - nextlinecol >= 0)
+			    p = nextline + (prev_ptr - line) - nextlinecol;
+			else
+			    p = prev_ptr;
+			cap_col -= (int)(prev_ptr - line);
+			len = spell_check(wp, p, &spell_hlf, &cap_col,
+								    nochange);
+			word_end = v + len;
+
+			/* In Insert mode only highlight a word that
+			 * doesn't touch the cursor. */
+			if (spell_hlf != HLF_COUNT
+				&& (State & INSERT) != 0
+				&& wp->w_cursor.lnum == lnum
+				&& wp->w_cursor.col >=
+						    (colnr_T)(prev_ptr - line)
+				&& wp->w_cursor.col < (colnr_T)word_end)
+			{
+			    spell_hlf = HLF_COUNT;
+			    spell_redraw_lnum = lnum;
+			}
+
+			if (spell_hlf == HLF_COUNT && p != prev_ptr
+				       && (p - nextline) + len > nextline_idx)
+			{
+			    /* Remember that the good word continues at the
+			     * start of the next line. */
+			    checked_lnum = lnum + 1;
+			    checked_col = (int)((p - nextline) + len - nextline_idx);
+			}
+
+			/* Turn index into actual attributes. */
+			if (spell_hlf != HLF_COUNT)
+			    spell_attr = highlight_attr[spell_hlf];
+
+			if (cap_col > 0)
+			{
+			    if (p != prev_ptr
+				   && (p - nextline) + cap_col >= nextline_idx)
+			    {
+				/* Remember that the word in the next line
+				 * must start with a capital. */
+				capcol_lnum = lnum + 1;
+				cap_col = (int)((p - nextline) + cap_col
+							       - nextline_idx);
+			    }
+			    else
+				/* Compute the actual column. */
+				cap_col += (int)(prev_ptr - line);
+			}
+		    }
+		}
+		if (spell_attr != 0)
+		{
+		    if (!attr_pri)
+			char_attr = hl_combine_attr(char_attr, spell_attr);
+		    else
+			char_attr = hl_combine_attr(spell_attr, char_attr);
+		}
+#endif
+#ifdef FEAT_LINEBREAK
+		/*
+		 * Found last space before word: check for line break.
+		 */
+		if (wp->w_p_lbr && c0 == c
+				  && VIM_ISBREAK(c) && !VIM_ISBREAK((int)*ptr))
+		{
+# ifdef FEAT_MBYTE
+		    int mb_off = has_mbyte ? (*mb_head_off)(line, ptr - 1) : 0;
+# endif
+		    char_u *p = ptr - (
+# ifdef FEAT_MBYTE
+				mb_off +
+# endif
+				1);
+
+		    /* TODO: is passing p for start of the line OK? */
+		    n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol,
+								    NULL) - 1;
+		    if (c == TAB && n_extra + col > wp->w_width)
+# ifdef FEAT_VARTABS
+			n_extra = tabstop_padding(vcol, wp->w_buffer->b_p_ts,
+					      wp->w_buffer->b_p_vts_array) - 1;
+# else
+			n_extra = (int)wp->w_buffer->b_p_ts
+				       - vcol % (int)wp->w_buffer->b_p_ts - 1;
+# endif
+
+# ifdef FEAT_MBYTE
+		    c_extra = mb_off > 0 ? MB_FILLER_CHAR : ' ';
+# else
+		    c_extra = ' ';
+# endif
+		    if (VIM_ISWHITE(c))
+		    {
+#ifdef FEAT_CONCEAL
+			if (c == TAB)
+			    /* See "Tab alignment" below. */
+			    FIX_FOR_BOGUSCOLS;
+#endif
+			if (!wp->w_p_list)
+			    c = ' ';
+		    }
+		}
+#endif
+
+		/* 'list': change char 160 to lcs_nbsp and space to lcs_space.
+		 */
+		if (wp->w_p_list
+			&& (((c == 160
+#ifdef FEAT_MBYTE
+			      || (mb_utf8 && (mb_c == 160 || mb_c == 0x202f))
+#endif
+			     ) && lcs_nbsp)
+			|| (c == ' ' && lcs_space && ptr - line <= trailcol)))
+		{
+		    c = (c == ' ') ? lcs_space : lcs_nbsp;
+		    if (area_attr == 0 && search_attr == 0)
+		    {
+			n_attr = 1;
+			extra_attr = HL_ATTR(HLF_8);
+			saved_attr2 = char_attr; /* save current attr */
+		    }
+#ifdef FEAT_MBYTE
+		    mb_c = c;
+		    if (enc_utf8 && utf_char2len(c) > 1)
+		    {
+			mb_utf8 = TRUE;
+			u8cc[0] = 0;
+			c = 0xc0;
+		    }
+		    else
+			mb_utf8 = FALSE;
+#endif
+		}
+
+		if (trailcol != MAXCOL && ptr > line + trailcol && c == ' ')
+		{
+		    c = lcs_trail;
+		    if (!attr_pri)
+		    {
+			n_attr = 1;
+			extra_attr = HL_ATTR(HLF_8);
+			saved_attr2 = char_attr; /* save current attr */
+		    }
+#ifdef FEAT_MBYTE
+		    mb_c = c;
+		    if (enc_utf8 && utf_char2len(c) > 1)
+		    {
+			mb_utf8 = TRUE;
+			u8cc[0] = 0;
+			c = 0xc0;
+		    }
+		    else
+			mb_utf8 = FALSE;
+#endif
+		}
+	    }
+
+	    /*
+	     * Handling of non-printable characters.
+	     */
+	    if (!vim_isprintc(c))
+	    {
+		/*
+		 * when getting a character from the file, we may have to
+		 * turn it into something else on the way to putting it
+		 * into "ScreenLines".
+		 */
+		if (c == TAB && (!wp->w_p_list || lcs_tab1))
+		{
+		    int tab_len = 0;
+		    long vcol_adjusted = vcol; /* removed showbreak length */
+#ifdef FEAT_LINEBREAK
+		    /* only adjust the tab_len, when at the first column
+		     * after the showbreak value was drawn */
+		    if (*p_sbr != NUL && vcol == vcol_sbr && wp->w_p_wrap)
+			vcol_adjusted = vcol - MB_CHARLEN(p_sbr);
+#endif
+		    /* tab amount depends on current column */
+#ifdef FEAT_VARTABS
+		    tab_len = tabstop_padding(vcol_adjusted,
+					      wp->w_buffer->b_p_ts,
+					      wp->w_buffer->b_p_vts_array) - 1;
+#else
+		    tab_len = (int)wp->w_buffer->b_p_ts
+			       - vcol_adjusted % (int)wp->w_buffer->b_p_ts - 1;
+#endif
+
+#ifdef FEAT_LINEBREAK
+		    if (!wp->w_p_lbr || !wp->w_p_list)
+#endif
+		    /* tab amount depends on current column */
+			n_extra = tab_len;
+#ifdef FEAT_LINEBREAK
+		    else
+		    {
+			char_u *p;
+			int	len = n_extra;
+			int	i;
+			int	saved_nextra = n_extra;
+
+#ifdef FEAT_CONCEAL
+			if (vcol_off > 0)
+			    /* there are characters to conceal */
+			    tab_len += vcol_off;
+			/* boguscols before FIX_FOR_BOGUSCOLS macro from above
+			 */
+			if (wp->w_p_list && lcs_tab1 && old_boguscols > 0
+							 && n_extra > tab_len)
+			    tab_len += n_extra - tab_len;
+#endif
+
+			/* if n_extra > 0, it gives the number of chars, to
+			 * use for a tab, else we need to calculate the width
+			 * for a tab */
+#ifdef FEAT_MBYTE
+			len = (tab_len * mb_char2len(lcs_tab2));
+			if (n_extra > 0)
+			    len += n_extra - tab_len;
+#endif
+			c = lcs_tab1;
+			p = alloc((unsigned)(len + 1));
+			vim_memset(p, ' ', len);
+			p[len] = NUL;
+			vim_free(p_extra_free);
+			p_extra_free = p;
+			for (i = 0; i < tab_len; i++)
+			{
+			    if (*p == NUL)
+			    {
+				tab_len = i;
+				break;
+			    }
+#ifdef FEAT_MBYTE
+			    mb_char2bytes(lcs_tab2, p);
+			    p += mb_char2len(lcs_tab2);
+			    n_extra += mb_char2len(lcs_tab2)
+						 - (saved_nextra > 0 ? 1 : 0);
+#else
+			    p[i] = lcs_tab2;
+#endif
+			}
+			p_extra = p_extra_free;
+#ifdef FEAT_CONCEAL
+			/* n_extra will be increased by FIX_FOX_BOGUSCOLS
+			 * macro below, so need to adjust for that here */
+			if (vcol_off > 0)
+			    n_extra -= vcol_off;
+#endif
+		    }
+#endif
+#ifdef FEAT_CONCEAL
+		    {
+			int vc_saved = vcol_off;
+
+			/* Tab alignment should be identical regardless of
+			 * 'conceallevel' value. So tab compensates of all
+			 * previous concealed characters, and thus resets
+			 * vcol_off and boguscols accumulated so far in the
+			 * line. Note that the tab can be longer than
+			 * 'tabstop' when there are concealed characters. */
+			FIX_FOR_BOGUSCOLS;
+
+			/* Make sure, the highlighting for the tab char will be
+			 * correctly set further below (effectively reverts the
+			 * FIX_FOR_BOGSUCOLS macro */
+			if (n_extra == tab_len + vc_saved && wp->w_p_list
+								  && lcs_tab1)
+			    tab_len += vc_saved;
+		    }
+#endif
+#ifdef FEAT_MBYTE
+		    mb_utf8 = FALSE;	/* don't draw as UTF-8 */
+#endif
+		    if (wp->w_p_list)
+		    {
+			c = lcs_tab1;
+#ifdef FEAT_LINEBREAK
+			if (wp->w_p_lbr)
+			    c_extra = NUL; /* using p_extra from above */
+			else
+#endif
+			    c_extra = lcs_tab2;
+			n_attr = tab_len + 1;
+			extra_attr = HL_ATTR(HLF_8);
+			saved_attr2 = char_attr; /* save current attr */
+#ifdef FEAT_MBYTE
+			mb_c = c;
+			if (enc_utf8 && utf_char2len(c) > 1)
+			{
+			    mb_utf8 = TRUE;
+			    u8cc[0] = 0;
+			    c = 0xc0;
+			}
+#endif
+		    }
+		    else
+		    {
+			c_extra = ' ';
+			c = ' ';
+		    }
+		}
+		else if (c == NUL
+			&& (wp->w_p_list
+			    || ((fromcol >= 0 || fromcol_prev >= 0)
+				&& tocol > vcol
+				&& VIsual_mode != Ctrl_V
+				&& (
+# ifdef FEAT_RIGHTLEFT
+				    wp->w_p_rl ? (col >= 0) :
+# endif
+				    (col < wp->w_width))
+				&& !(noinvcur
+				    && lnum == wp->w_cursor.lnum
+				    && (colnr_T)vcol == wp->w_virtcol)))
+			&& lcs_eol_one > 0)
+		{
+		    /* Display a '$' after the line or highlight an extra
+		     * character if the line break is included. */
+#if defined(FEAT_DIFF) || defined(LINE_ATTR)
+		    /* For a diff line the highlighting continues after the
+		     * "$". */
+		    if (
+# ifdef FEAT_DIFF
+			    diff_hlf == (hlf_T)0
+#  ifdef LINE_ATTR
+			    &&
+#  endif
+# endif
+# ifdef LINE_ATTR
+			    line_attr == 0
+# endif
+		       )
+#endif
+		    {
+#ifdef FEAT_VIRTUALEDIT
+			/* In virtualedit, visual selections may extend
+			 * beyond end of line. */
+			if (area_highlighting && virtual_active()
+				&& tocol != MAXCOL && vcol < tocol)
+			    n_extra = 0;
+			else
+#endif
+			{
+			    p_extra = at_end_str;
+			    n_extra = 1;
+			    c_extra = NUL;
+			}
+		    }
+		    if (wp->w_p_list && lcs_eol > 0)
+			c = lcs_eol;
+		    else
+			c = ' ';
+		    lcs_eol_one = -1;
+		    --ptr;	    /* put it back at the NUL */
+		    if (!attr_pri)
+		    {
+			extra_attr = HL_ATTR(HLF_AT);
+			n_attr = 1;
+		    }
+#ifdef FEAT_MBYTE
+		    mb_c = c;
+		    if (enc_utf8 && utf_char2len(c) > 1)
+		    {
+			mb_utf8 = TRUE;
+			u8cc[0] = 0;
+			c = 0xc0;
+		    }
+		    else
+			mb_utf8 = FALSE;	/* don't draw as UTF-8 */
+#endif
+		}
+		else if (c != NUL)
+		{
+		    p_extra = transchar(c);
+		    if (n_extra == 0)
+			n_extra = byte2cells(c) - 1;
+#ifdef FEAT_RIGHTLEFT
+		    if ((dy_flags & DY_UHEX) && wp->w_p_rl)
+			rl_mirror(p_extra);	/* reverse "<12>" */
+#endif
+		    c_extra = NUL;
+#ifdef FEAT_LINEBREAK
+		    if (wp->w_p_lbr)
+		    {
+			char_u *p;
+
+			c = *p_extra;
+			p = alloc((unsigned)n_extra + 1);
+			vim_memset(p, ' ', n_extra);
+			STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);
+			p[n_extra] = NUL;
+			vim_free(p_extra_free);
+			p_extra_free = p_extra = p;
+		    }
+		    else
+#endif
+		    {
+			n_extra = byte2cells(c) - 1;
+			c = *p_extra++;
+		    }
+		    if (!attr_pri)
+		    {
+			n_attr = n_extra + 1;
+			extra_attr = HL_ATTR(HLF_8);
+			saved_attr2 = char_attr; /* save current attr */
+		    }
+#ifdef FEAT_MBYTE
+		    mb_utf8 = FALSE;	/* don't draw as UTF-8 */
+#endif
+		}
+#ifdef FEAT_VIRTUALEDIT
+		else if (VIsual_active
+			 && (VIsual_mode == Ctrl_V
+			     || VIsual_mode == 'v')
+			 && virtual_active()
+			 && tocol != MAXCOL
+			 && vcol < tocol
+			 && (
+# ifdef FEAT_RIGHTLEFT
+			    wp->w_p_rl ? (col >= 0) :
+# endif
+			    (col < wp->w_width)))
+		{
+		    c = ' ';
+		    --ptr;	    /* put it back at the NUL */
+		}
+#endif
+#if defined(LINE_ATTR)
+		else if ((
+# ifdef FEAT_DIFF
+			    diff_hlf != (hlf_T)0 ||
+# endif
+# ifdef FEAT_TERMINAL
+			    term_attr != 0 ||
+# endif
+			    line_attr != 0
+			) && (
+# ifdef FEAT_RIGHTLEFT
+			    wp->w_p_rl ? (col >= 0) :
+# endif
+			    (col
+# ifdef FEAT_CONCEAL
+				- boguscols
+# endif
+					    < wp->w_width)))
+		{
+		    /* Highlight until the right side of the window */
+		    c = ' ';
+		    --ptr;	    /* put it back at the NUL */
+
+		    /* Remember we do the char for line highlighting. */
+		    ++did_line_attr;
+
+		    /* don't do search HL for the rest of the line */
+		    if (line_attr != 0 && char_attr == search_attr
+					&& (did_line_attr > 1
+					    || (wp->w_p_list && lcs_eol > 0)))
+			char_attr = line_attr;
+# ifdef FEAT_DIFF
+		    if (diff_hlf == HLF_TXD)
+		    {
+			diff_hlf = HLF_CHD;
+			if (attr == 0 || char_attr != attr)
+			{
+			    char_attr = HL_ATTR(diff_hlf);
+			    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+				char_attr = hl_combine_attr(char_attr,
+							    HL_ATTR(HLF_CUL));
+			}
+		    }
+# endif
+# ifdef FEAT_TERMINAL
+		    if (term_attr != 0)
+		    {
+			char_attr = term_attr;
+			if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+			    char_attr = hl_combine_attr(char_attr,
+							    HL_ATTR(HLF_CUL));
+		    }
+# endif
+		}
+#endif
+	    }
+
+#ifdef FEAT_CONCEAL
+	    if (   wp->w_p_cole > 0
+		&& (wp != curwin || lnum != wp->w_cursor.lnum ||
+							conceal_cursor_line(wp) )
+		&& ( (syntax_flags & HL_CONCEAL) != 0 || has_match_conc > 0)
+		&& !(lnum_in_visual_area
+				    && vim_strchr(wp->w_p_cocu, 'v') == NULL))
+	    {
+		char_attr = conceal_attr;
+		if ((prev_syntax_id != syntax_seqnr || has_match_conc > 1)
+			&& (syn_get_sub_char() != NUL || match_conc
+							 || wp->w_p_cole == 1)
+			&& wp->w_p_cole != 3)
+		{
+		    /* First time at this concealed item: display one
+		     * character. */
+		    if (match_conc)
+			c = match_conc;
+		    else if (syn_get_sub_char() != NUL)
+			c = syn_get_sub_char();
+		    else if (lcs_conceal != NUL)
+			c = lcs_conceal;
+		    else
+			c = ' ';
+
+		    prev_syntax_id = syntax_seqnr;
+
+		    if (n_extra > 0)
+			vcol_off += n_extra;
+		    vcol += n_extra;
+		    if (wp->w_p_wrap && n_extra > 0)
+		    {
+# ifdef FEAT_RIGHTLEFT
+			if (wp->w_p_rl)
+			{
+			    col -= n_extra;
+			    boguscols -= n_extra;
+			}
+			else
+# endif
+			{
+			    boguscols += n_extra;
+			    col += n_extra;
+			}
+		    }
+		    n_extra = 0;
+		    n_attr = 0;
+		}
+		else if (n_skip == 0)
+		{
+		    is_concealing = TRUE;
+		    n_skip = 1;
+		}
+# ifdef FEAT_MBYTE
+		mb_c = c;
+		if (enc_utf8 && utf_char2len(c) > 1)
+		{
+		    mb_utf8 = TRUE;
+		    u8cc[0] = 0;
+		    c = 0xc0;
+		}
+		else
+		    mb_utf8 = FALSE;	/* don't draw as UTF-8 */
+# endif
+	    }
+	    else
+	    {
+		prev_syntax_id = 0;
+		is_concealing = FALSE;
+	    }
+#endif /* FEAT_CONCEAL */
+	}
+
+#ifdef FEAT_CONCEAL
+	/* In the cursor line and we may be concealing characters: correct
+	 * the cursor column when we reach its position. */
+	if (!did_wcol && draw_state == WL_LINE
+		&& wp == curwin && lnum == wp->w_cursor.lnum
+		&& conceal_cursor_line(wp)
+		&& (int)wp->w_virtcol <= vcol + n_skip)
+	{
+#  ifdef FEAT_RIGHTLEFT
+	    if (wp->w_p_rl)
+		wp->w_wcol = wp->w_width - col + boguscols - 1;
+	    else
+#  endif
+		wp->w_wcol = col - boguscols;
+	    wp->w_wrow = row;
+	    did_wcol = TRUE;
+	}
+#endif
+
+	/* Don't override visual selection highlighting. */
+	if (n_attr > 0
+		&& draw_state == WL_LINE
+		&& !attr_pri)
+	    char_attr = extra_attr;
+
+#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
+	/* XIM don't send preedit_start and preedit_end, but they send
+	 * preedit_changed and commit.  Thus Vim can't set "im_is_active", use
+	 * im_is_preediting() here. */
+	if (p_imst == IM_ON_THE_SPOT
+		&& xic != NULL
+		&& lnum == wp->w_cursor.lnum
+		&& (State & INSERT)
+		&& !p_imdisable
+		&& im_is_preediting()
+		&& draw_state == WL_LINE)
+	{
+	    colnr_T tcol;
+
+	    if (preedit_end_col == MAXCOL)
+		getvcol(curwin, &(wp->w_cursor), &tcol, NULL, NULL);
+	    else
+		tcol = preedit_end_col;
+	    if ((long)preedit_start_col <= vcol && vcol < (long)tcol)
+	    {
+		if (feedback_old_attr < 0)
+		{
+		    feedback_col = 0;
+		    feedback_old_attr = char_attr;
+		}
+		char_attr = im_get_feedback_attr(feedback_col);
+		if (char_attr < 0)
+		    char_attr = feedback_old_attr;
+		feedback_col++;
+	    }
+	    else if (feedback_old_attr >= 0)
+	    {
+		char_attr = feedback_old_attr;
+		feedback_old_attr = -1;
+		feedback_col = 0;
+	    }
+	}
+#endif
+	/*
+	 * Handle the case where we are in column 0 but not on the first
+	 * character of the line and the user wants us to show us a
+	 * special character (via 'listchars' option "precedes:<char>".
+	 */
+	if (lcs_prec_todo != NUL
+		&& wp->w_p_list
+		&& (wp->w_p_wrap ? wp->w_skipcol > 0 : wp->w_leftcol > 0)
+#ifdef FEAT_DIFF
+		&& filler_todo <= 0
+#endif
+		&& draw_state > WL_NR
+		&& c != NUL)
+	{
+	    c = lcs_prec;
+	    lcs_prec_todo = NUL;
+#ifdef FEAT_MBYTE
+	    if (has_mbyte && (*mb_char2cells)(mb_c) > 1)
+	    {
+		/* Double-width character being overwritten by the "precedes"
+		 * character, need to fill up half the character. */
+		c_extra = MB_FILLER_CHAR;
+		n_extra = 1;
+		n_attr = 2;
+		extra_attr = HL_ATTR(HLF_AT);
+	    }
+	    mb_c = c;
+	    if (enc_utf8 && utf_char2len(c) > 1)
+	    {
+		mb_utf8 = TRUE;
+		u8cc[0] = 0;
+		c = 0xc0;
+	    }
+	    else
+		mb_utf8 = FALSE;	/* don't draw as UTF-8 */
+#endif
+	    if (!attr_pri)
+	    {
+		saved_attr3 = char_attr; /* save current attr */
+		char_attr = HL_ATTR(HLF_AT); /* later copied to char_attr */
+		n_attr3 = 1;
+	    }
+	}
+
+	/*
+	 * At end of the text line or just after the last character.
+	 */
+	if (c == NUL
+#if defined(LINE_ATTR)
+		|| did_line_attr == 1
+#endif
+		)
+	{
+#ifdef FEAT_SEARCH_EXTRA
+	    long prevcol = (long)(ptr - line) - (c == NUL);
+
+	    /* we're not really at that column when skipping some text */
+	    if ((long)(wp->w_p_wrap ? wp->w_skipcol : wp->w_leftcol) > prevcol)
+		++prevcol;
+#endif
+
+	    /* Invert at least one char, used for Visual and empty line or
+	     * highlight match at end of line. If it's beyond the last
+	     * char on the screen, just overwrite that one (tricky!)  Not
+	     * needed when a '$' was displayed for 'list'. */
+#ifdef FEAT_SEARCH_EXTRA
+	    prevcol_hl_flag = FALSE;
+	    if (!search_hl.is_addpos && prevcol == (long)search_hl.startcol)
+		prevcol_hl_flag = TRUE;
+	    else
+	    {
+		cur = wp->w_match_head;
+		while (cur != NULL)
+		{
+		    if (!cur->hl.is_addpos && prevcol == (long)cur->hl.startcol)
+		    {
+			prevcol_hl_flag = TRUE;
+			break;
+		    }
+		    cur = cur->next;
+		}
+	    }
+#endif
+	    if (lcs_eol == lcs_eol_one
+		    && ((area_attr != 0 && vcol == fromcol
+			    && (VIsual_mode != Ctrl_V
+				|| lnum == VIsual.lnum
+				|| lnum == curwin->w_cursor.lnum)
+			    && c == NUL)
+#ifdef FEAT_SEARCH_EXTRA
+			/* highlight 'hlsearch' match at end of line */
+			|| (prevcol_hl_flag == TRUE
+# ifdef FEAT_SYN_HL
+			    && !(wp->w_p_cul && lnum == wp->w_cursor.lnum
+				    && !(wp == curwin && VIsual_active))
+# endif
+# ifdef FEAT_DIFF
+			    && diff_hlf == (hlf_T)0
+# endif
+# if defined(LINE_ATTR)
+			    && did_line_attr <= 1
+# endif
+			   )
+#endif
+		       ))
+	    {
+		int n = 0;
+
+#ifdef FEAT_RIGHTLEFT
+		if (wp->w_p_rl)
+		{
+		    if (col < 0)
+			n = 1;
+		}
+		else
+#endif
+		{
+		    if (col >= wp->w_width)
+			n = -1;
+		}
+		if (n != 0)
+		{
+		    /* At the window boundary, highlight the last character
+		     * instead (better than nothing). */
+		    off += n;
+		    col += n;
+		}
+		else
+		{
+		    /* Add a blank character to highlight. */
+		    ScreenLines[off] = ' ';
+#ifdef FEAT_MBYTE
+		    if (enc_utf8)
+			ScreenLinesUC[off] = 0;
+#endif
+		}
+#ifdef FEAT_SEARCH_EXTRA
+		if (area_attr == 0)
+		{
+		    /* Use attributes from match with highest priority among
+		     * 'search_hl' and the match list. */
+		    char_attr = search_hl.attr;
+		    cur = wp->w_match_head;
+		    shl_flag = FALSE;
+		    while (cur != NULL || shl_flag == FALSE)
+		    {
+			if (shl_flag == FALSE
+				&& ((cur != NULL
+					&& cur->priority > SEARCH_HL_PRIORITY)
+				    || cur == NULL))
+			{
+			    shl = &search_hl;
+			    shl_flag = TRUE;
+			}
+			else
+			    shl = &cur->hl;
+			if ((ptr - line) - 1 == (long)shl->startcol
+				&& (shl == &search_hl || !shl->is_addpos))
+			    char_attr = shl->attr;
+			if (shl != &search_hl && cur != NULL)
+			    cur = cur->next;
+		    }
+		}
+#endif
+		ScreenAttrs[off] = char_attr;
+#ifdef FEAT_RIGHTLEFT
+		if (wp->w_p_rl)
+		{
+		    --col;
+		    --off;
+		}
+		else
+#endif
+		{
+		    ++col;
+		    ++off;
+		}
+		++vcol;
+#ifdef FEAT_SYN_HL
+		eol_hl_off = 1;
+#endif
+	    }
+	}
+
+	/*
+	 * At end of the text line.
+	 */
+	if (c == NUL)
+	{
+#ifdef FEAT_SYN_HL
+	    /* Highlight 'cursorcolumn' & 'colorcolumn' past end of the line. */
+	    if (wp->w_p_wrap)
+		v = wp->w_skipcol;
+	    else
+		v = wp->w_leftcol;
+
+	    /* check if line ends before left margin */
+	    if (vcol < v + col - win_col_off(wp))
+		vcol = v + col - win_col_off(wp);
+#ifdef FEAT_CONCEAL
+	    /* Get rid of the boguscols now, we want to draw until the right
+	     * edge for 'cursorcolumn'. */
+	    col -= boguscols;
+	    boguscols = 0;
+#endif
+
+	    if (draw_color_col)
+		draw_color_col = advance_color_col(VCOL_HLC, &color_cols);
+
+	    if (((wp->w_p_cuc
+		      && (int)wp->w_virtcol >= VCOL_HLC - eol_hl_off
+		      && (int)wp->w_virtcol <
+					wp->w_width * (row - startrow + 1) + v
+		      && lnum != wp->w_cursor.lnum)
+		    || draw_color_col)
+# ifdef FEAT_RIGHTLEFT
+		    && !wp->w_p_rl
+# endif
+		    )
+	    {
+		int	rightmost_vcol = 0;
+		int	i;
+
+		if (wp->w_p_cuc)
+		    rightmost_vcol = wp->w_virtcol;
+		if (draw_color_col)
+		    /* determine rightmost colorcolumn to possibly draw */
+		    for (i = 0; color_cols[i] >= 0; ++i)
+			if (rightmost_vcol < color_cols[i])
+			    rightmost_vcol = color_cols[i];
+
+		while (col < wp->w_width)
+		{
+		    ScreenLines[off] = ' ';
+#ifdef FEAT_MBYTE
+		    if (enc_utf8)
+			ScreenLinesUC[off] = 0;
+#endif
+		    ++col;
+		    if (draw_color_col)
+			draw_color_col = advance_color_col(VCOL_HLC,
+								 &color_cols);
+
+		    if (wp->w_p_cuc && VCOL_HLC == (long)wp->w_virtcol)
+			ScreenAttrs[off++] = HL_ATTR(HLF_CUC);
+		    else if (draw_color_col && VCOL_HLC == *color_cols)
+			ScreenAttrs[off++] = HL_ATTR(HLF_MC);
+		    else
+			ScreenAttrs[off++] = 0;
+
+		    if (VCOL_HLC >= rightmost_vcol)
+			break;
+
+		    ++vcol;
+		}
+	    }
+#endif
+
+	    screen_line(screen_row, wp->w_wincol, col,
+				  (int)wp->w_width, HAS_RIGHTLEFT(wp->w_p_rl));
+	    row++;
+
+	    /*
+	     * Update w_cline_height and w_cline_folded if the cursor line was
+	     * updated (saves a call to plines() later).
+	     */
+	    if (wp == curwin && lnum == curwin->w_cursor.lnum)
+	    {
+		curwin->w_cline_row = startrow;
+		curwin->w_cline_height = row - startrow;
+#ifdef FEAT_FOLDING
+		curwin->w_cline_folded = FALSE;
+#endif
+		curwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);
+	    }
+
+	    break;
+	}
+
+	/* line continues beyond line end */
+	if (lcs_ext
+		&& !wp->w_p_wrap
+#ifdef FEAT_DIFF
+		&& filler_todo <= 0
+#endif
+		&& (
+#ifdef FEAT_RIGHTLEFT
+		    wp->w_p_rl ? col == 0 :
+#endif
+		    col == wp->w_width - 1)
+		&& (*ptr != NUL
+		    || (wp->w_p_list && lcs_eol_one > 0)
+		    || (n_extra && (c_extra != NUL || *p_extra != NUL))))
+	{
+	    c = lcs_ext;
+	    char_attr = HL_ATTR(HLF_AT);
+#ifdef FEAT_MBYTE
+	    mb_c = c;
+	    if (enc_utf8 && utf_char2len(c) > 1)
+	    {
+		mb_utf8 = TRUE;
+		u8cc[0] = 0;
+		c = 0xc0;
+	    }
+	    else
+		mb_utf8 = FALSE;
+#endif
+	}
+
+#ifdef FEAT_SYN_HL
+	/* advance to the next 'colorcolumn' */
+	if (draw_color_col)
+	    draw_color_col = advance_color_col(VCOL_HLC, &color_cols);
+
+	/* Highlight the cursor column if 'cursorcolumn' is set.  But don't
+	 * highlight the cursor position itself.
+	 * Also highlight the 'colorcolumn' if it is different than
+	 * 'cursorcolumn' */
+	vcol_save_attr = -1;
+	if (draw_state == WL_LINE && !lnum_in_visual_area
+		&& search_attr == 0 && area_attr == 0)
+	{
+	    if (wp->w_p_cuc && VCOL_HLC == (long)wp->w_virtcol
+						 && lnum != wp->w_cursor.lnum)
+	    {
+		vcol_save_attr = char_attr;
+		char_attr = hl_combine_attr(char_attr, HL_ATTR(HLF_CUC));
+	    }
+	    else if (draw_color_col && VCOL_HLC == *color_cols)
+	    {
+		vcol_save_attr = char_attr;
+		char_attr = hl_combine_attr(char_attr, HL_ATTR(HLF_MC));
+	    }
+	}
+#endif
+
+	/*
+	 * Store character to be displayed.
+	 * Skip characters that are left of the screen for 'nowrap'.
+	 */
+	vcol_prev = vcol;
+	if (draw_state < WL_LINE || n_skip <= 0)
+	{
+	    /*
+	     * Store the character.
+	     */
+#if defined(FEAT_RIGHTLEFT) && defined(FEAT_MBYTE)
+	    if (has_mbyte && wp->w_p_rl && (*mb_char2cells)(mb_c) > 1)
+	    {
+		/* A double-wide character is: put first halve in left cell. */
+		--off;
+		--col;
+	    }
+#endif
+	    ScreenLines[off] = c;
+#ifdef FEAT_MBYTE
+	    if (enc_dbcs == DBCS_JPNU)
+	    {
+		if ((mb_c & 0xff00) == 0x8e00)
+		    ScreenLines[off] = 0x8e;
+		ScreenLines2[off] = mb_c & 0xff;
+	    }
+	    else if (enc_utf8)
+	    {
+		if (mb_utf8)
+		{
+		    int i;
+
+		    ScreenLinesUC[off] = mb_c;
+		    if ((c & 0xff) == 0)
+			ScreenLines[off] = 0x80;   /* avoid storing zero */
+		    for (i = 0; i < Screen_mco; ++i)
+		    {
+			ScreenLinesC[i][off] = u8cc[i];
+			if (u8cc[i] == 0)
+			    break;
+		    }
+		}
+		else
+		    ScreenLinesUC[off] = 0;
+	    }
+	    if (multi_attr)
+	    {
+		ScreenAttrs[off] = multi_attr;
+		multi_attr = 0;
+	    }
+	    else
+#endif
+		ScreenAttrs[off] = char_attr;
+
+#ifdef FEAT_MBYTE
+	    if (has_mbyte && (*mb_char2cells)(mb_c) > 1)
+	    {
+		/* Need to fill two screen columns. */
+		++off;
+		++col;
+		if (enc_utf8)
+		    /* UTF-8: Put a 0 in the second screen char. */
+		    ScreenLines[off] = 0;
+		else
+		    /* DBCS: Put second byte in the second screen char. */
+		    ScreenLines[off] = mb_c & 0xff;
+		if (draw_state > WL_NR
+#ifdef FEAT_DIFF
+			&& filler_todo <= 0
+#endif
+			)
+		    ++vcol;
+		/* When "tocol" is halfway a character, set it to the end of
+		 * the character, otherwise highlighting won't stop. */
+		if (tocol == vcol)
+		    ++tocol;
+#ifdef FEAT_RIGHTLEFT
+		if (wp->w_p_rl)
+		{
+		    /* now it's time to backup one cell */
+		    --off;
+		    --col;
+		}
+#endif
+	    }
+#endif
+#ifdef FEAT_RIGHTLEFT
+	    if (wp->w_p_rl)
+	    {
+		--off;
+		--col;
+	    }
+	    else
+#endif
+	    {
+		++off;
+		++col;
+	    }
+	}
+#ifdef FEAT_CONCEAL
+	else if (wp->w_p_cole > 0 && is_concealing)
+	{
+	    --n_skip;
+	    ++vcol_off;
+	    if (n_extra > 0)
+		vcol_off += n_extra;
+	    if (wp->w_p_wrap)
+	    {
+		/*
+		 * Special voodoo required if 'wrap' is on.
+		 *
+		 * Advance the column indicator to force the line
+		 * drawing to wrap early. This will make the line
+		 * take up the same screen space when parts are concealed,
+		 * so that cursor line computations aren't messed up.
+		 *
+		 * To avoid the fictitious advance of 'col' causing
+		 * trailing junk to be written out of the screen line
+		 * we are building, 'boguscols' keeps track of the number
+		 * of bad columns we have advanced.
+		 */
+		if (n_extra > 0)
+		{
+		    vcol += n_extra;
+# ifdef FEAT_RIGHTLEFT
+		    if (wp->w_p_rl)
+		    {
+			col -= n_extra;
+			boguscols -= n_extra;
+		    }
+		    else
+# endif
+		    {
+			col += n_extra;
+			boguscols += n_extra;
+		    }
+		    n_extra = 0;
+		    n_attr = 0;
+		}
+
+
+# ifdef FEAT_MBYTE
+		if (has_mbyte && (*mb_char2cells)(mb_c) > 1)
+		{
+		    /* Need to fill two screen columns. */
+#  ifdef FEAT_RIGHTLEFT
+		    if (wp->w_p_rl)
+		    {
+			--boguscols;
+			--col;
+		    }
+		    else
+#  endif
+		    {
+			++boguscols;
+			++col;
+		    }
+		}
+# endif
+
+# ifdef FEAT_RIGHTLEFT
+		if (wp->w_p_rl)
+		{
+		    --boguscols;
+		    --col;
+		}
+		else
+# endif
+		{
+		    ++boguscols;
+		    ++col;
+		}
+	    }
+	    else
+	    {
+		if (n_extra > 0)
+		{
+		    vcol += n_extra;
+		    n_extra = 0;
+		    n_attr = 0;
+		}
+	    }
+
+	}
+#endif /* FEAT_CONCEAL */
+	else
+	    --n_skip;
+
+	/* Only advance the "vcol" when after the 'number' or 'relativenumber'
+	 * column. */
+	if (draw_state > WL_NR
+#ifdef FEAT_DIFF
+		&& filler_todo <= 0
+#endif
+		)
+	    ++vcol;
+
+#ifdef FEAT_SYN_HL
+	if (vcol_save_attr >= 0)
+	    char_attr = vcol_save_attr;
+#endif
+
+	/* restore attributes after "predeces" in 'listchars' */
+	if (draw_state > WL_NR && n_attr3 > 0 && --n_attr3 == 0)
+	    char_attr = saved_attr3;
+
+	/* restore attributes after last 'listchars' or 'number' char */
+	if (n_attr > 0 && draw_state == WL_LINE && --n_attr == 0)
+	    char_attr = saved_attr2;
+
+	/*
+	 * At end of screen line and there is more to come: Display the line
+	 * so far.  If there is no more to display it is caught above.
+	 */
+	if ((
+#ifdef FEAT_RIGHTLEFT
+	    wp->w_p_rl ? (col < 0) :
+#endif
+				    (col >= wp->w_width))
+		&& (*ptr != NUL
+#ifdef FEAT_DIFF
+		    || filler_todo > 0
+#endif
+		    || (wp->w_p_list && lcs_eol != NUL && p_extra != at_end_str)
+		    || (n_extra != 0 && (c_extra != NUL || *p_extra != NUL)))
+		)
+	{
+#ifdef FEAT_CONCEAL
+	    screen_line(screen_row, wp->w_wincol, col - boguscols,
+				  (int)wp->w_width, HAS_RIGHTLEFT(wp->w_p_rl));
+	    boguscols = 0;
+#else
+	    screen_line(screen_row, wp->w_wincol, col,
+				  (int)wp->w_width, HAS_RIGHTLEFT(wp->w_p_rl));
+#endif
+	    ++row;
+	    ++screen_row;
+
+	    /* When not wrapping and finished diff lines, or when displayed
+	     * '$' and highlighting until last column, break here. */
+	    if ((!wp->w_p_wrap
+#ifdef FEAT_DIFF
+		    && filler_todo <= 0
+#endif
+		    ) || lcs_eol_one == -1)
+		break;
+
+	    /* When the window is too narrow draw all "@" lines. */
+	    if (draw_state != WL_LINE
+#ifdef FEAT_DIFF
+		    && filler_todo <= 0
+#endif
+		    )
+	    {
+		win_draw_end(wp, '@', ' ', row, wp->w_height, HLF_AT);
+		draw_vsep_win(wp, row);
+		row = endrow;
+	    }
+
+	    /* When line got too long for screen break here. */
+	    if (row == endrow)
+	    {
+		++row;
+		break;
+	    }
+
+	    if (screen_cur_row == screen_row - 1
+#ifdef FEAT_DIFF
+		     && filler_todo <= 0
+#endif
+		     && wp->w_width == Columns)
+	    {
+		/* Remember that the line wraps, used for modeless copy. */
+		LineWraps[screen_row - 1] = TRUE;
+
+		/*
+		 * Special trick to make copy/paste of wrapped lines work with
+		 * xterm/screen: write an extra character beyond the end of
+		 * the line. This will work with all terminal types
+		 * (regardless of the xn,am settings).
+		 * Only do this on a fast tty.
+		 * Only do this if the cursor is on the current line
+		 * (something has been written in it).
+		 * Don't do this for the GUI.
+		 * Don't do this for double-width characters.
+		 * Don't do this for a window not at the right screen border.
+		 */
+		if (p_tf
+#ifdef FEAT_GUI
+			 && !gui.in_use
+#endif
+#ifdef FEAT_MBYTE
+			 && !(has_mbyte
+			     && ((*mb_off2cells)(LineOffset[screen_row],
+				     LineOffset[screen_row] + screen_Columns)
+									  == 2
+				 || (*mb_off2cells)(LineOffset[screen_row - 1]
+							+ (int)Columns - 2,
+				     LineOffset[screen_row] + screen_Columns)
+									== 2))
+#endif
+		   )
+		{
+		    /* First make sure we are at the end of the screen line,
+		     * then output the same character again to let the
+		     * terminal know about the wrap.  If the terminal doesn't
+		     * auto-wrap, we overwrite the character. */
+		    if (screen_cur_col != wp->w_width)
+			screen_char(LineOffset[screen_row - 1]
+						      + (unsigned)Columns - 1,
+					  screen_row - 1, (int)(Columns - 1));
+
+#ifdef FEAT_MBYTE
+		    /* When there is a multi-byte character, just output a
+		     * space to keep it simple. */
+		    if (has_mbyte && MB_BYTE2LEN(ScreenLines[LineOffset[
+					screen_row - 1] + (Columns - 1)]) > 1)
+			out_char(' ');
+		    else
+#endif
+			out_char(ScreenLines[LineOffset[screen_row - 1]
+							    + (Columns - 1)]);
+		    /* force a redraw of the first char on the next line */
+		    ScreenAttrs[LineOffset[screen_row]] = (sattr_T)-1;
+		    screen_start();	/* don't know where cursor is now */
+		}
+	    }
+
+	    col = 0;
+	    off = (unsigned)(current_ScreenLine - ScreenLines);
+#ifdef FEAT_RIGHTLEFT
+	    if (wp->w_p_rl)
+	    {
+		col = wp->w_width - 1;	/* col is not used if breaking! */
+		off += col;
+	    }
+#endif
+
+	    /* reset the drawing state for the start of a wrapped line */
+	    draw_state = WL_START;
+	    saved_n_extra = n_extra;
+	    saved_p_extra = p_extra;
+	    saved_c_extra = c_extra;
+	    saved_char_attr = char_attr;
+	    n_extra = 0;
+	    lcs_prec_todo = lcs_prec;
+#ifdef FEAT_LINEBREAK
+# ifdef FEAT_DIFF
+	    if (filler_todo <= 0)
+# endif
+		need_showbreak = TRUE;
+#endif
+#ifdef FEAT_DIFF
+	    --filler_todo;
+	    /* When the filler lines are actually below the last line of the
+	     * file, don't draw the line itself, break here. */
+	    if (filler_todo == 0 && wp->w_botfill)
+		break;
+#endif
+	}
+
+    }	/* for every character in the line */
+
+#ifdef FEAT_SPELL
+    /* After an empty line check first word for capital. */
+    if (*skipwhite(line) == NUL)
+    {
+	capcol_lnum = lnum + 1;
+	cap_col = 0;
+    }
+#endif
+
+    vim_free(p_extra_free);
+    return row;
+}
+
+#ifdef FEAT_MBYTE
+static int comp_char_differs(int, int);
+
+/*
+ * Return if the composing characters at "off_from" and "off_to" differ.
+ * Only to be used when ScreenLinesUC[off_from] != 0.
+ */
+    static int
+comp_char_differs(int off_from, int off_to)
+{
+    int	    i;
+
+    for (i = 0; i < Screen_mco; ++i)
+    {
+	if (ScreenLinesC[i][off_from] != ScreenLinesC[i][off_to])
+	    return TRUE;
+	if (ScreenLinesC[i][off_from] == 0)
+	    break;
+    }
+    return FALSE;
+}
+#endif
+
+/*
+ * Check whether the given character needs redrawing:
+ * - the (first byte of the) character is different
+ * - the attributes are different
+ * - the character is multi-byte and the next byte is different
+ * - the character is two cells wide and the second cell differs.
+ */
+    static int
+char_needs_redraw(int off_from, int off_to, int cols)
+{
+    if (cols > 0
+	    && ((ScreenLines[off_from] != ScreenLines[off_to]
+		    || ScreenAttrs[off_from] != ScreenAttrs[off_to])
+
+#ifdef FEAT_MBYTE
+		|| (enc_dbcs != 0
+		    && MB_BYTE2LEN(ScreenLines[off_from]) > 1
+		    && (enc_dbcs == DBCS_JPNU && ScreenLines[off_from] == 0x8e
+			? ScreenLines2[off_from] != ScreenLines2[off_to]
+			: (cols > 1 && ScreenLines[off_from + 1]
+						 != ScreenLines[off_to + 1])))
+		|| (enc_utf8
+		    && (ScreenLinesUC[off_from] != ScreenLinesUC[off_to]
+			|| (ScreenLinesUC[off_from] != 0
+			    && comp_char_differs(off_from, off_to))
+			|| ((*mb_off2cells)(off_from, off_from + cols) > 1
+			    && ScreenLines[off_from + 1]
+						  != ScreenLines[off_to + 1])))
+#endif
+	       ))
+	return TRUE;
+    return FALSE;
+}
+
+#if defined(FEAT_TERMINAL) || defined(PROTO)
+/*
+ * Return the index in ScreenLines[] for the current screen line.
+ */
+    int
+screen_get_current_line_off()
+{
+    return (int)(current_ScreenLine - ScreenLines);
+}
+#endif
+
+/*
+ * Move one "cooked" screen line to the screen, but only the characters that
+ * have actually changed.  Handle insert/delete character.
+ * "coloff" gives the first column on the screen for this line.
+ * "endcol" gives the columns where valid characters are.
+ * "clear_width" is the width of the window.  It's > 0 if the rest of the line
+ * needs to be cleared, negative otherwise.
+ * "rlflag" is TRUE in a rightleft window:
+ *    When TRUE and "clear_width" > 0, clear columns 0 to "endcol"
+ *    When FALSE and "clear_width" > 0, clear columns "endcol" to "clear_width"
+ */
+    void
+screen_line(
+    int	    row,
+    int	    coloff,
+    int	    endcol,
+    int	    clear_width,
+    int	    rlflag UNUSED)
+{
+    unsigned	    off_from;
+    unsigned	    off_to;
+#ifdef FEAT_MBYTE
+    unsigned	    max_off_from;
+    unsigned	    max_off_to;
+#endif
+    int		    col = 0;
+    int		    hl;
+    int		    force = FALSE;	/* force update rest of the line */
+    int		    redraw_this		/* bool: does character need redraw? */
+#ifdef FEAT_GUI
+				= TRUE	/* For GUI when while-loop empty */
+#endif
+				;
+    int		    redraw_next;	/* redraw_this for next character */
+#ifdef FEAT_MBYTE
+    int		    clear_next = FALSE;
+    int		    char_cells;		/* 1: normal char */
+					/* 2: occupies two display cells */
+# define CHAR_CELLS char_cells
+#else
+# define CHAR_CELLS 1
+#endif
+
+    /* Check for illegal row and col, just in case. */
+    if (row >= Rows)
+	row = Rows - 1;
+    if (endcol > Columns)
+	endcol = Columns;
+
+# ifdef FEAT_CLIPBOARD
+    clip_may_clear_selection(row, row);
+# endif
+
+    off_from = (unsigned)(current_ScreenLine - ScreenLines);
+    off_to = LineOffset[row] + coloff;
+#ifdef FEAT_MBYTE
+    max_off_from = off_from + screen_Columns;
+    max_off_to = LineOffset[row] + screen_Columns;
+#endif
+
+#ifdef FEAT_RIGHTLEFT
+    if (rlflag)
+    {
+	/* Clear rest first, because it's left of the text. */
+	if (clear_width > 0)
+	{
+	    while (col <= endcol && ScreenLines[off_to] == ' '
+		    && ScreenAttrs[off_to] == 0
+# ifdef FEAT_MBYTE
+				  && (!enc_utf8 || ScreenLinesUC[off_to] == 0)
+# endif
+						  )
+	    {
+		++off_to;
+		++col;
+	    }
+	    if (col <= endcol)
+		screen_fill(row, row + 1, col + coloff,
+					    endcol + coloff + 1, ' ', ' ', 0);
+	}
+	col = endcol + 1;
+	off_to = LineOffset[row] + col + coloff;
+	off_from += col;
+	endcol = (clear_width > 0 ? clear_width : -clear_width);
+    }
+#endif /* FEAT_RIGHTLEFT */
+
+    redraw_next = char_needs_redraw(off_from, off_to, endcol - col);
+
+    while (col < endcol)
+    {
+#ifdef FEAT_MBYTE
+	if (has_mbyte && (col + 1 < endcol))
+	    char_cells = (*mb_off2cells)(off_from, max_off_from);
+	else
+	    char_cells = 1;
+#endif
+
+	redraw_this = redraw_next;
+	redraw_next = force || char_needs_redraw(off_from + CHAR_CELLS,
+			      off_to + CHAR_CELLS, endcol - col - CHAR_CELLS);
+
+#ifdef FEAT_GUI
+	/* If the next character was bold, then redraw the current character to
+	 * remove any pixels that might have spilt over into us.  This only
+	 * happens in the GUI.
+	 */
+	if (redraw_next && gui.in_use)
+	{
+	    hl = ScreenAttrs[off_to + CHAR_CELLS];
+	    if (hl > HL_ALL)
+		hl = syn_attr2attr(hl);
+	    if (hl & HL_BOLD)
+		redraw_this = TRUE;
+	}
+#endif
+
+	if (redraw_this)
+	{
+	    /*
+	     * Special handling when 'xs' termcap flag set (hpterm):
+	     * Attributes for characters are stored at the position where the
+	     * cursor is when writing the highlighting code.  The
+	     * start-highlighting code must be written with the cursor on the
+	     * first highlighted character.  The stop-highlighting code must
+	     * be written with the cursor just after the last highlighted
+	     * character.
+	     * Overwriting a character doesn't remove it's highlighting.  Need
+	     * to clear the rest of the line, and force redrawing it
+	     * completely.
+	     */
+	    if (       p_wiv
+		    && !force
+#ifdef FEAT_GUI
+		    && !gui.in_use
+#endif
+		    && ScreenAttrs[off_to] != 0
+		    && ScreenAttrs[off_from] != ScreenAttrs[off_to])
+	    {
+		/*
+		 * Need to remove highlighting attributes here.
+		 */
+		windgoto(row, col + coloff);
+		out_str(T_CE);		/* clear rest of this screen line */
+		screen_start();		/* don't know where cursor is now */
+		force = TRUE;		/* force redraw of rest of the line */
+		redraw_next = TRUE;	/* or else next char would miss out */
+
+		/*
+		 * If the previous character was highlighted, need to stop
+		 * highlighting at this character.
+		 */
+		if (col + coloff > 0 && ScreenAttrs[off_to - 1] != 0)
+		{
+		    screen_attr = ScreenAttrs[off_to - 1];
+		    term_windgoto(row, col + coloff);
+		    screen_stop_highlight();
+		}
+		else
+		    screen_attr = 0;	    /* highlighting has stopped */
+	    }
+#ifdef FEAT_MBYTE
+	    if (enc_dbcs != 0)
+	    {
+		/* Check if overwriting a double-byte with a single-byte or
+		 * the other way around requires another character to be
+		 * redrawn.  For UTF-8 this isn't needed, because comparing
+		 * ScreenLinesUC[] is sufficient. */
+		if (char_cells == 1
+			&& col + 1 < endcol
+			&& (*mb_off2cells)(off_to, max_off_to) > 1)
+		{
+		    /* Writing a single-cell character over a double-cell
+		     * character: need to redraw the next cell. */
+		    ScreenLines[off_to + 1] = 0;
+		    redraw_next = TRUE;
+		}
+		else if (char_cells == 2
+			&& col + 2 < endcol
+			&& (*mb_off2cells)(off_to, max_off_to) == 1
+			&& (*mb_off2cells)(off_to + 1, max_off_to) > 1)
+		{
+		    /* Writing the second half of a double-cell character over
+		     * a double-cell character: need to redraw the second
+		     * cell. */
+		    ScreenLines[off_to + 2] = 0;
+		    redraw_next = TRUE;
+		}
+
+		if (enc_dbcs == DBCS_JPNU)
+		    ScreenLines2[off_to] = ScreenLines2[off_from];
+	    }
+	    /* When writing a single-width character over a double-width
+	     * character and at the end of the redrawn text, need to clear out
+	     * the right halve of the old character.
+	     * Also required when writing the right halve of a double-width
+	     * char over the left halve of an existing one. */
+	    if (has_mbyte && col + char_cells == endcol
+		    && ((char_cells == 1
+			    && (*mb_off2cells)(off_to, max_off_to) > 1)
+			|| (char_cells == 2
+			    && (*mb_off2cells)(off_to, max_off_to) == 1
+			    && (*mb_off2cells)(off_to + 1, max_off_to) > 1)))
+		clear_next = TRUE;
+#endif
+
+	    ScreenLines[off_to] = ScreenLines[off_from];
+#ifdef FEAT_MBYTE
+	    if (enc_utf8)
+	    {
+		ScreenLinesUC[off_to] = ScreenLinesUC[off_from];
+		if (ScreenLinesUC[off_from] != 0)
+		{
+		    int	    i;
+
+		    for (i = 0; i < Screen_mco; ++i)
+			ScreenLinesC[i][off_to] = ScreenLinesC[i][off_from];
+		}
+	    }
+	    if (char_cells == 2)
+		ScreenLines[off_to + 1] = ScreenLines[off_from + 1];
+#endif
+
+#if defined(FEAT_GUI) || defined(UNIX)
+	    /* The bold trick makes a single column of pixels appear in the
+	     * next character.  When a bold character is removed, the next
+	     * character should be redrawn too.  This happens for our own GUI
+	     * and for some xterms. */
+	    if (
+# ifdef FEAT_GUI
+		    gui.in_use
+# endif
+# if defined(FEAT_GUI) && defined(UNIX)
+		    ||
+# endif
+# ifdef UNIX
+		    term_is_xterm
+# endif
+		    )
+	    {
+		hl = ScreenAttrs[off_to];
+		if (hl > HL_ALL)
+		    hl = syn_attr2attr(hl);
+		if (hl & HL_BOLD)
+		    redraw_next = TRUE;
+	    }
+#endif
+	    ScreenAttrs[off_to] = ScreenAttrs[off_from];
+#ifdef FEAT_MBYTE
+	    /* For simplicity set the attributes of second half of a
+	     * double-wide character equal to the first half. */
+	    if (char_cells == 2)
+		ScreenAttrs[off_to + 1] = ScreenAttrs[off_from];
+
+	    if (enc_dbcs != 0 && char_cells == 2)
+		screen_char_2(off_to, row, col + coloff);
+	    else
+#endif
+		screen_char(off_to, row, col + coloff);
+	}
+	else if (  p_wiv
+#ifdef FEAT_GUI
+		&& !gui.in_use
+#endif
+		&& col + coloff > 0)
+	{
+	    if (ScreenAttrs[off_to] == ScreenAttrs[off_to - 1])
+	    {
+		/*
+		 * Don't output stop-highlight when moving the cursor, it will
+		 * stop the highlighting when it should continue.
+		 */
+		screen_attr = 0;
+	    }
+	    else if (screen_attr != 0)
+		screen_stop_highlight();
+	}
+
+	off_to += CHAR_CELLS;
+	off_from += CHAR_CELLS;
+	col += CHAR_CELLS;
+    }
+
+#ifdef FEAT_MBYTE
+    if (clear_next)
+    {
+	/* Clear the second half of a double-wide character of which the left
+	 * half was overwritten with a single-wide character. */
+	ScreenLines[off_to] = ' ';
+	if (enc_utf8)
+	    ScreenLinesUC[off_to] = 0;
+	screen_char(off_to, row, col + coloff);
+    }
+#endif
+
+    if (clear_width > 0
+#ifdef FEAT_RIGHTLEFT
+		    && !rlflag
+#endif
+				   )
+    {
+#ifdef FEAT_GUI
+	int startCol = col;
+#endif
+
+	/* blank out the rest of the line */
+	while (col < clear_width && ScreenLines[off_to] == ' '
+						  && ScreenAttrs[off_to] == 0
+#ifdef FEAT_MBYTE
+				  && (!enc_utf8 || ScreenLinesUC[off_to] == 0)
+#endif
+						  )
+	{
+	    ++off_to;
+	    ++col;
+	}
+	if (col < clear_width)
+	{
+#ifdef FEAT_GUI
+	    /*
+	     * In the GUI, clearing the rest of the line may leave pixels
+	     * behind if the first character cleared was bold.  Some bold
+	     * fonts spill over the left.  In this case we redraw the previous
+	     * character too.  If we didn't skip any blanks above, then we
+	     * only redraw if the character wasn't already redrawn anyway.
+	     */
+	    if (gui.in_use && (col > startCol || !redraw_this))
+	    {
+		hl = ScreenAttrs[off_to];
+		if (hl > HL_ALL || (hl & HL_BOLD))
+		{
+		    int prev_cells = 1;
+# ifdef FEAT_MBYTE
+		    if (enc_utf8)
+			/* for utf-8, ScreenLines[char_offset + 1] == 0 means
+			 * that its width is 2. */
+			prev_cells = ScreenLines[off_to - 1] == 0 ? 2 : 1;
+		    else if (enc_dbcs != 0)
+		    {
+			/* find previous character by counting from first
+			 * column and get its width. */
+			unsigned off = LineOffset[row];
+			unsigned max_off = LineOffset[row] + screen_Columns;
+
+			while (off < off_to)
+			{
+			    prev_cells = (*mb_off2cells)(off, max_off);
+			    off += prev_cells;
+			}
+		    }
+
+		    if (enc_dbcs != 0 && prev_cells > 1)
+			screen_char_2(off_to - prev_cells, row,
+						   col + coloff - prev_cells);
+		    else
+# endif
+			screen_char(off_to - prev_cells, row,
+						   col + coloff - prev_cells);
+		}
+	    }
+#endif
+	    screen_fill(row, row + 1, col + coloff, clear_width + coloff,
+								 ' ', ' ', 0);
+	    off_to += clear_width - col;
+	    col = clear_width;
+	}
+    }
+
+    if (clear_width > 0)
+    {
+	/* For a window that's left of another, draw the separator char. */
+	if (col + coloff < Columns)
+	{
+	    int c;
+
+	    c = fillchar_vsep(&hl);
+	    if (ScreenLines[off_to] != (schar_T)c
+#ifdef FEAT_MBYTE
+		    || (enc_utf8 && (int)ScreenLinesUC[off_to]
+						       != (c >= 0x80 ? c : 0))
+#endif
+		    || ScreenAttrs[off_to] != hl)
+	    {
+		ScreenLines[off_to] = c;
+		ScreenAttrs[off_to] = hl;
+#ifdef FEAT_MBYTE
+		if (enc_utf8)
+		{
+		    if (c >= 0x80)
+		    {
+			ScreenLinesUC[off_to] = c;
+			ScreenLinesC[0][off_to] = 0;
+		    }
+		    else
+			ScreenLinesUC[off_to] = 0;
+		}
+#endif
+		screen_char(off_to, row, col + coloff);
+	    }
+	}
+	else
+	    LineWraps[row] = FALSE;
+    }
+}
+
+#if defined(FEAT_RIGHTLEFT) || defined(PROTO)
+/*
+ * Mirror text "str" for right-left displaying.
+ * Only works for single-byte characters (e.g., numbers).
+ */
+    void
+rl_mirror(char_u *str)
+{
+    char_u	*p1, *p2;
+    int		t;
+
+    for (p1 = str, p2 = str + STRLEN(str) - 1; p1 < p2; ++p1, --p2)
+    {
+	t = *p1;
+	*p1 = *p2;
+	*p2 = t;
+    }
+}
+#endif
+
+/*
+ * mark all status lines for redraw; used after first :cd
+ */
+    void
+status_redraw_all(void)
+{
+    win_T	*wp;
+
+    FOR_ALL_WINDOWS(wp)
+	if (wp->w_status_height)
+	{
+	    wp->w_redr_status = TRUE;
+	    redraw_later(VALID);
+	}
+}
+
+/*
+ * mark all status lines of the current buffer for redraw
+ */
+    void
+status_redraw_curbuf(void)
+{
+    win_T	*wp;
+
+    FOR_ALL_WINDOWS(wp)
+	if (wp->w_status_height != 0 && wp->w_buffer == curbuf)
+	{
+	    wp->w_redr_status = TRUE;
+	    redraw_later(VALID);
+	}
+}
+
+/*
+ * Redraw all status lines that need to be redrawn.
+ */
+    void
+redraw_statuslines(void)
+{
+    win_T	*wp;
+
+    FOR_ALL_WINDOWS(wp)
+	if (wp->w_redr_status)
+	    win_redr_status(wp, FALSE);
+    if (redraw_tabline)
+	draw_tabline();
+}
+
+#if defined(FEAT_WILDMENU) || defined(PROTO)
+/*
+ * Redraw all status lines at the bottom of frame "frp".
+ */
+    void
+win_redraw_last_status(frame_T *frp)
+{
+    if (frp->fr_layout == FR_LEAF)
+	frp->fr_win->w_redr_status = TRUE;
+    else if (frp->fr_layout == FR_ROW)
+    {
+	for (frp = frp->fr_child; frp != NULL; frp = frp->fr_next)
+	    win_redraw_last_status(frp);
+    }
+    else /* frp->fr_layout == FR_COL */
+    {
+	frp = frp->fr_child;
+	while (frp->fr_next != NULL)
+	    frp = frp->fr_next;
+	win_redraw_last_status(frp);
+    }
+}
+#endif
+
+/*
+ * Draw the verticap separator right of window "wp" starting with line "row".
+ */
+    static void
+draw_vsep_win(win_T *wp, int row)
+{
+    int		hl;
+    int		c;
+
+    if (wp->w_vsep_width)
+    {
+	/* draw the vertical separator right of this window */
+	c = fillchar_vsep(&hl);
+	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + wp->w_height,
+		W_ENDCOL(wp), W_ENDCOL(wp) + 1,
+		c, ' ', hl);
+    }
+}
+
+#ifdef FEAT_WILDMENU
+static int status_match_len(expand_T *xp, char_u *s);
+static int skip_status_match_char(expand_T *xp, char_u *s);
+
+/*
+ * Get the length of an item as it will be shown in the status line.
+ */
+    static int
+status_match_len(expand_T *xp, char_u *s)
+{
+    int	len = 0;
+
+#ifdef FEAT_MENU
+    int emenu = (xp->xp_context == EXPAND_MENUS
+	    || xp->xp_context == EXPAND_MENUNAMES);
+
+    /* Check for menu separators - replace with '|'. */
+    if (emenu && menu_is_separator(s))
+	return 1;
+#endif
+
+    while (*s != NUL)
+    {
+	s += skip_status_match_char(xp, s);
+	len += ptr2cells(s);
+	MB_PTR_ADV(s);
+    }
+
+    return len;
+}
+
+/*
+ * Return the number of characters that should be skipped in a status match.
+ * These are backslashes used for escaping.  Do show backslashes in help tags.
+ */
+    static int
+skip_status_match_char(expand_T *xp, char_u *s)
+{
+    if ((rem_backslash(s) && xp->xp_context != EXPAND_HELP)
+#ifdef FEAT_MENU
+	    || ((xp->xp_context == EXPAND_MENUS
+		    || xp->xp_context == EXPAND_MENUNAMES)
+			  && (s[0] == '\t' || (s[0] == '\\' && s[1] != NUL)))
+#endif
+	   )
+    {
+#ifndef BACKSLASH_IN_FILENAME
+	if (xp->xp_shell && csh_like_shell() && s[1] == '\\' && s[2] == '!')
+	    return 2;
+#endif
+	return 1;
+    }
+    return 0;
+}
+
+/*
+ * Show wildchar matches in the status line.
+ * Show at least the "match" item.
+ * We start at item 'first_match' in the list and show all matches that fit.
+ *
+ * If inversion is possible we use it. Else '=' characters are used.
+ */
+    void
+win_redr_status_matches(
+    expand_T	*xp,
+    int		num_matches,
+    char_u	**matches,	/* list of matches */
+    int		match,
+    int		showtail)
+{
+#define L_MATCH(m) (showtail ? sm_gettail(matches[m]) : matches[m])
+    int		row;
+    char_u	*buf;
+    int		len;
+    int		clen;		/* length in screen cells */
+    int		fillchar;
+    int		attr;
+    int		i;
+    int		highlight = TRUE;
+    char_u	*selstart = NULL;
+    int		selstart_col = 0;
+    char_u	*selend = NULL;
+    static int	first_match = 0;
+    int		add_left = FALSE;
+    char_u	*s;
+#ifdef FEAT_MENU
+    int		emenu;
+#endif
+#if defined(FEAT_MBYTE) || defined(FEAT_MENU)
+    int		l;
+#endif
+
+    if (matches == NULL)	/* interrupted completion? */
+	return;
+
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+	buf = alloc((unsigned)Columns * MB_MAXBYTES + 1);
+    else
+#endif
+	buf = alloc((unsigned)Columns + 1);
+    if (buf == NULL)
+	return;
+
+    if (match == -1)	/* don't show match but original text */
+    {
+	match = 0;
+	highlight = FALSE;
+    }
+    /* count 1 for the ending ">" */
+    clen = status_match_len(xp, L_MATCH(match)) + 3;
+    if (match == 0)
+	first_match = 0;
+    else if (match < first_match)
+    {
+	/* jumping left, as far as we can go */
+	first_match = match;
+	add_left = TRUE;
+    }
+    else
+    {
+	/* check if match fits on the screen */
+	for (i = first_match; i < match; ++i)
+	    clen += status_match_len(xp, L_MATCH(i)) + 2;
+	if (first_match > 0)
+	    clen += 2;
+	/* jumping right, put match at the left */
+	if ((long)clen > Columns)
+	{
+	    first_match = match;
+	    /* if showing the last match, we can add some on the left */
+	    clen = 2;
+	    for (i = match; i < num_matches; ++i)
+	    {
+		clen += status_match_len(xp, L_MATCH(i)) + 2;
+		if ((long)clen >= Columns)
+		    break;
+	    }
+	    if (i == num_matches)
+		add_left = TRUE;
+	}
+    }
+    if (add_left)
+	while (first_match > 0)
+	{
+	    clen += status_match_len(xp, L_MATCH(first_match - 1)) + 2;
+	    if ((long)clen >= Columns)
+		break;
+	    --first_match;
+	}
+
+    fillchar = fillchar_status(&attr, curwin);
+
+    if (first_match == 0)
+    {
+	*buf = NUL;
+	len = 0;
+    }
+    else
+    {
+	STRCPY(buf, "< ");
+	len = 2;
+    }
+    clen = len;
+
+    i = first_match;
+    while ((long)(clen + status_match_len(xp, L_MATCH(i)) + 2) < Columns)
+    {
+	if (i == match)
+	{
+	    selstart = buf + len;
+	    selstart_col = clen;
+	}
+
+	s = L_MATCH(i);
+	/* Check for menu separators - replace with '|' */
+#ifdef FEAT_MENU
+	emenu = (xp->xp_context == EXPAND_MENUS
+		|| xp->xp_context == EXPAND_MENUNAMES);
+	if (emenu && menu_is_separator(s))
+	{
+	    STRCPY(buf + len, transchar('|'));
+	    l = (int)STRLEN(buf + len);
+	    len += l;
+	    clen += l;
+	}
+	else
+#endif
+	    for ( ; *s != NUL; ++s)
+	{
+	    s += skip_status_match_char(xp, s);
+	    clen += ptr2cells(s);
+#ifdef FEAT_MBYTE
+	    if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)
+	    {
+		STRNCPY(buf + len, s, l);
+		s += l - 1;
+		len += l;
+	    }
+	    else
+#endif
+	    {
+		STRCPY(buf + len, transchar_byte(*s));
+		len += (int)STRLEN(buf + len);
+	    }
+	}
+	if (i == match)
+	    selend = buf + len;
+
+	*(buf + len++) = ' ';
+	*(buf + len++) = ' ';
+	clen += 2;
+	if (++i == num_matches)
+		break;
+    }
+
+    if (i != num_matches)
+    {
+	*(buf + len++) = '>';
+	++clen;
+    }
+
+    buf[len] = NUL;
+
+    row = cmdline_row - 1;
+    if (row >= 0)
+    {
+	if (wild_menu_showing == 0)
+	{
+	    if (msg_scrolled > 0)
+	    {
+		/* Put the wildmenu just above the command line.  If there is
+		 * no room, scroll the screen one line up. */
+		if (cmdline_row == Rows - 1)
+		{
+		    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
+		    ++msg_scrolled;
+		}
+		else
+		{
+		    ++cmdline_row;
+		    ++row;
+		}
+		wild_menu_showing = WM_SCROLLED;
+	    }
+	    else
+	    {
+		/* Create status line if needed by setting 'laststatus' to 2.
+		 * Set 'winminheight' to zero to avoid that the window is
+		 * resized. */
+		if (lastwin->w_status_height == 0)
+		{
+		    save_p_ls = p_ls;
+		    save_p_wmh = p_wmh;
+		    p_ls = 2;
+		    p_wmh = 0;
+		    last_status(FALSE);
+		}
+		wild_menu_showing = WM_SHOWN;
+	    }
+	}
+
+	screen_puts(buf, row, 0, attr);
+	if (selstart != NULL && highlight)
+	{
+	    *selend = NUL;
+	    screen_puts(selstart, row, selstart_col, HL_ATTR(HLF_WM));
+	}
+
+	screen_fill(row, row + 1, clen, (int)Columns, fillchar, fillchar, attr);
+    }
+
+    win_redraw_last_status(topframe);
+    vim_free(buf);
+}
+#endif
+
+/*
+ * Redraw the status line of window wp.
+ *
+ * If inversion is possible we use it. Else '=' characters are used.
+ * If "ignore_pum" is TRUE, also redraw statusline when the popup menu is
+ * displayed.
+ */
+    static void
+win_redr_status(win_T *wp, int ignore_pum UNUSED)
+{
+    int		row;
+    char_u	*p;
+    int		len;
+    int		fillchar;
+    int		attr;
+    int		this_ru_col;
+    static int  busy = FALSE;
+
+    /* It's possible to get here recursively when 'statusline' (indirectly)
+     * invokes ":redrawstatus".  Simply ignore the call then. */
+    if (busy)
+	return;
+    busy = TRUE;
+
+    wp->w_redr_status = FALSE;
+    if (wp->w_status_height == 0)
+    {
+	/* no status line, can only be last window */
+	redraw_cmdline = TRUE;
+    }
+    else if (!redrawing()
+#ifdef FEAT_INS_EXPAND
+	    // don't update status line when popup menu is visible and may be
+	    // drawn over it, unless it will be redrawn later
+	    || (!ignore_pum && pum_visible())
+#endif
+	    )
+    {
+	/* Don't redraw right now, do it later. */
+	wp->w_redr_status = TRUE;
+    }
+#ifdef FEAT_STL_OPT
+    else if (*p_stl != NUL || *wp->w_p_stl != NUL)
+    {
+	/* redraw custom status line */
+	redraw_custom_statusline(wp);
+    }
+#endif
+    else
+    {
+	fillchar = fillchar_status(&attr, wp);
+
+	get_trans_bufname(wp->w_buffer);
+	p = NameBuff;
+	len = (int)STRLEN(p);
+
+	if (bt_help(wp->w_buffer)
+#ifdef FEAT_QUICKFIX
+		|| wp->w_p_pvw
+#endif
+		|| bufIsChanged(wp->w_buffer)
+		|| wp->w_buffer->b_p_ro)
+	    *(p + len++) = ' ';
+	if (bt_help(wp->w_buffer))
+	{
+	    STRCPY(p + len, _("[Help]"));
+	    len += (int)STRLEN(p + len);
+	}
+#ifdef FEAT_QUICKFIX
+	if (wp->w_p_pvw)
+	{
+	    STRCPY(p + len, _("[Preview]"));
+	    len += (int)STRLEN(p + len);
+	}
+#endif
+	if (bufIsChanged(wp->w_buffer)
+#ifdef FEAT_TERMINAL
+		&& !bt_terminal(wp->w_buffer)
+#endif
+		)
+	{
+	    STRCPY(p + len, "[+]");
+	    len += 3;
+	}
+	if (wp->w_buffer->b_p_ro)
+	{
+	    STRCPY(p + len, _("[RO]"));
+	    len += (int)STRLEN(p + len);
+	}
+
+	this_ru_col = ru_col - (Columns - wp->w_width);
+	if (this_ru_col < (wp->w_width + 1) / 2)
+	    this_ru_col = (wp->w_width + 1) / 2;
+	if (this_ru_col <= 1)
+	{
+	    p = (char_u *)"<";		/* No room for file name! */
+	    len = 1;
+	}
+	else
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+	    {
+		int	clen = 0, i;
+
+		/* Count total number of display cells. */
+		clen = mb_string2cells(p, -1);
+
+		/* Find first character that will fit.
+		 * Going from start to end is much faster for DBCS. */
+		for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;
+					      i += (*mb_ptr2len)(p + i))
+		    clen -= (*mb_ptr2cells)(p + i);
+		len = clen;
+		if (i > 0)
+		{
+		    p = p + i - 1;
+		    *p = '<';
+		    ++len;
+		}
+
+	    }
+	    else
+#endif
+	    if (len > this_ru_col - 1)
+	    {
+		p += len - (this_ru_col - 1);
+		*p = '<';
+		len = this_ru_col - 1;
+	    }
+
+	row = W_WINROW(wp) + wp->w_height;
+	screen_puts(p, row, wp->w_wincol, attr);
+	screen_fill(row, row + 1, len + wp->w_wincol,
+			this_ru_col + wp->w_wincol, fillchar, fillchar, attr);
+
+	if (get_keymap_str(wp, (char_u *)"<%s>", NameBuff, MAXPATHL)
+		&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))
+	    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)
+						   - 1 + wp->w_wincol), attr);
+
+#ifdef FEAT_CMDL_INFO
+	win_redr_ruler(wp, TRUE, ignore_pum);
+#endif
+    }
+
+    /*
+     * May need to draw the character below the vertical separator.
+     */
+    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())
+    {
+	if (stl_connected(wp))
+	    fillchar = fillchar_status(&attr, wp);
+	else
+	    fillchar = fillchar_vsep(&attr);
+	screen_putchar(fillchar, W_WINROW(wp) + wp->w_height, W_ENDCOL(wp),
+									attr);
+    }
+    busy = FALSE;
+}
+
+#ifdef FEAT_STL_OPT
+/*
+ * Redraw the status line according to 'statusline' and take care of any
+ * errors encountered.
+ */
+    static void
+redraw_custom_statusline(win_T *wp)
+{
+    static int	    entered = FALSE;
+    int		    saved_did_emsg = did_emsg;
+
+    /* When called recursively return.  This can happen when the statusline
+     * contains an expression that triggers a redraw. */
+    if (entered)
+	return;
+    entered = TRUE;
+
+    did_emsg = FALSE;
+    win_redr_custom(wp, FALSE);
+    if (did_emsg)
+    {
+	/* When there is an error disable the statusline, otherwise the
+	 * display is messed up with errors and a redraw triggers the problem
+	 * again and again. */
+	set_string_option_direct((char_u *)"statusline", -1,
+		(char_u *)"", OPT_FREE | (*wp->w_p_stl != NUL
+					? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);
+    }
+    did_emsg |= saved_did_emsg;
+    entered = FALSE;
+}
+#endif
+
+/*
+ * Return TRUE if the status line of window "wp" is connected to the status
+ * line of the window right of it.  If not, then it's a vertical separator.
+ * Only call if (wp->w_vsep_width != 0).
+ */
+    int
+stl_connected(win_T *wp)
+{
+    frame_T	*fr;
+
+    fr = wp->w_frame;
+    while (fr->fr_parent != NULL)
+    {
+	if (fr->fr_parent->fr_layout == FR_COL)
+	{
+	    if (fr->fr_next != NULL)
+		break;
+	}
+	else
+	{
+	    if (fr->fr_next != NULL)
+		return TRUE;
+	}
+	fr = fr->fr_parent;
+    }
+    return FALSE;
+}
+
+
+/*
+ * Get the value to show for the language mappings, active 'keymap'.
+ */
+    int
+get_keymap_str(
+    win_T	*wp,
+    char_u	*fmt,	    /* format string containing one %s item */
+    char_u	*buf,	    /* buffer for the result */
+    int		len)	    /* length of buffer */
+{
+    char_u	*p;
+
+    if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP)
+	return FALSE;
+
+    {
+#ifdef FEAT_EVAL
+	buf_T	*old_curbuf = curbuf;
+	win_T	*old_curwin = curwin;
+	char_u	*s;
+
+	curbuf = wp->w_buffer;
+	curwin = wp;
+	STRCPY(buf, "b:keymap_name");	/* must be writable */
+	++emsg_skip;
+	s = p = eval_to_string(buf, NULL, FALSE);
+	--emsg_skip;
+	curbuf = old_curbuf;
+	curwin = old_curwin;
+	if (p == NULL || *p == NUL)
+#endif
+	{
+#ifdef FEAT_KEYMAP
+	    if (wp->w_buffer->b_kmap_state & KEYMAP_LOADED)
+		p = wp->w_buffer->b_p_keymap;
+	    else
+#endif
+		p = (char_u *)"lang";
+	}
+	if (vim_snprintf((char *)buf, len, (char *)fmt, p) > len - 1)
+	    buf[0] = NUL;
+#ifdef FEAT_EVAL
+	vim_free(s);
+#endif
+    }
+    return buf[0] != NUL;
+}
+
+#if defined(FEAT_STL_OPT) || defined(PROTO)
+/*
+ * Redraw the status line or ruler of window "wp".
+ * When "wp" is NULL redraw the tab pages line from 'tabline'.
+ */
+    static void
+win_redr_custom(
+    win_T	*wp,
+    int		draw_ruler)	/* TRUE or FALSE */
+{
+    static int	entered = FALSE;
+    int		attr;
+    int		curattr;
+    int		row;
+    int		col = 0;
+    int		maxwidth;
+    int		width;
+    int		n;
+    int		len;
+    int		fillchar;
+    char_u	buf[MAXPATHL];
+    char_u	*stl;
+    char_u	*p;
+    struct	stl_hlrec hltab[STL_MAX_ITEM];
+    struct	stl_hlrec tabtab[STL_MAX_ITEM];
+    int		use_sandbox = FALSE;
+    win_T	*ewp;
+    int		p_crb_save;
+
+    /* There is a tiny chance that this gets called recursively: When
+     * redrawing a status line triggers redrawing the ruler or tabline.
+     * Avoid trouble by not allowing recursion. */
+    if (entered)
+	return;
+    entered = TRUE;
+
+    /* setup environment for the task at hand */
+    if (wp == NULL)
+    {
+	/* Use 'tabline'.  Always at the first line of the screen. */
+	stl = p_tal;
+	row = 0;
+	fillchar = ' ';
+	attr = HL_ATTR(HLF_TPF);
+	maxwidth = Columns;
+# ifdef FEAT_EVAL
+	use_sandbox = was_set_insecurely((char_u *)"tabline", 0);
+# endif
+    }
+    else
+    {
+	row = W_WINROW(wp) + wp->w_height;
+	fillchar = fillchar_status(&attr, wp);
+	maxwidth = wp->w_width;
+
+	if (draw_ruler)
+	{
+	    stl = p_ruf;
+	    /* advance past any leading group spec - implicit in ru_col */
+	    if (*stl == '%')
+	    {
+		if (*++stl == '-')
+		    stl++;
+		if (atoi((char *)stl))
+		    while (VIM_ISDIGIT(*stl))
+			stl++;
+		if (*stl++ != '(')
+		    stl = p_ruf;
+	    }
+	    col = ru_col - (Columns - wp->w_width);
+	    if (col < (wp->w_width + 1) / 2)
+		col = (wp->w_width + 1) / 2;
+	    maxwidth = wp->w_width - col;
+	    if (!wp->w_status_height)
+	    {
+		row = Rows - 1;
+		--maxwidth;	/* writing in last column may cause scrolling */
+		fillchar = ' ';
+		attr = 0;
+	    }
+
+# ifdef FEAT_EVAL
+	    use_sandbox = was_set_insecurely((char_u *)"rulerformat", 0);
+# endif
+	}
+	else
+	{
+	    if (*wp->w_p_stl != NUL)
+		stl = wp->w_p_stl;
+	    else
+		stl = p_stl;
+# ifdef FEAT_EVAL
+	    use_sandbox = was_set_insecurely((char_u *)"statusline",
+					 *wp->w_p_stl == NUL ? 0 : OPT_LOCAL);
+# endif
+	}
+
+	col += wp->w_wincol;
+    }
+
+    if (maxwidth <= 0)
+	goto theend;
+
+    /* Temporarily reset 'cursorbind', we don't want a side effect from moving
+     * the cursor away and back. */
+    ewp = wp == NULL ? curwin : wp;
+    p_crb_save = ewp->w_p_crb;
+    ewp->w_p_crb = FALSE;
+
+    /* Make a copy, because the statusline may include a function call that
+     * might change the option value and free the memory. */
+    stl = vim_strsave(stl);
+    width = build_stl_str_hl(ewp, buf, sizeof(buf),
+				stl, use_sandbox,
+				fillchar, maxwidth, hltab, tabtab);
+    vim_free(stl);
+    ewp->w_p_crb = p_crb_save;
+
+    /* Make all characters printable. */
+    p = transstr(buf);
+    if (p != NULL)
+    {
+	vim_strncpy(buf, p, sizeof(buf) - 1);
+	vim_free(p);
+    }
+
+    /* fill up with "fillchar" */
+    len = (int)STRLEN(buf);
+    while (width < maxwidth && len < (int)sizeof(buf) - 1)
+    {
+#ifdef FEAT_MBYTE
+	len += (*mb_char2bytes)(fillchar, buf + len);
+#else
+	buf[len++] = fillchar;
+#endif
+	++width;
+    }
+    buf[len] = NUL;
+
+    /*
+     * Draw each snippet with the specified highlighting.
+     */
+    curattr = attr;
+    p = buf;
+    for (n = 0; hltab[n].start != NULL; n++)
+    {
+	len = (int)(hltab[n].start - p);
+	screen_puts_len(p, len, row, col, curattr);
+	col += vim_strnsize(p, len);
+	p = hltab[n].start;
+
+	if (hltab[n].userhl == 0)
+	    curattr = attr;
+	else if (hltab[n].userhl < 0)
+	    curattr = syn_id2attr(-hltab[n].userhl);
+#ifdef FEAT_TERMINAL
+	else if (wp != NULL && wp != curwin && bt_terminal(wp->w_buffer)
+						   && wp->w_status_height != 0)
+	    curattr = highlight_stltermnc[hltab[n].userhl - 1];
+	else if (wp != NULL && bt_terminal(wp->w_buffer)
+						   && wp->w_status_height != 0)
+	    curattr = highlight_stlterm[hltab[n].userhl - 1];
+#endif
+	else if (wp != NULL && wp != curwin && wp->w_status_height != 0)
+	    curattr = highlight_stlnc[hltab[n].userhl - 1];
+	else
+	    curattr = highlight_user[hltab[n].userhl - 1];
+    }
+    screen_puts(p, row, col, curattr);
+
+    if (wp == NULL)
+    {
+	/* Fill the TabPageIdxs[] array for clicking in the tab pagesline. */
+	col = 0;
+	len = 0;
+	p = buf;
+	fillchar = 0;
+	for (n = 0; tabtab[n].start != NULL; n++)
+	{
+	    len += vim_strnsize(p, (int)(tabtab[n].start - p));
+	    while (col < len)
+		TabPageIdxs[col++] = fillchar;
+	    p = tabtab[n].start;
+	    fillchar = tabtab[n].userhl;
+	}
+	while (col < Columns)
+	    TabPageIdxs[col++] = fillchar;
+    }
+
+theend:
+    entered = FALSE;
+}
+
+#endif /* FEAT_STL_OPT */
+
+/*
+ * Output a single character directly to the screen and update ScreenLines.
+ */
+    void
+screen_putchar(int c, int row, int col, int attr)
+{
+    char_u	buf[MB_MAXBYTES + 1];
+
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+	buf[(*mb_char2bytes)(c, buf)] = NUL;
+    else
+#endif
+    {
+	buf[0] = c;
+	buf[1] = NUL;
+    }
+    screen_puts(buf, row, col, attr);
+}
+
+/*
+ * Get a single character directly from ScreenLines into "bytes[]".
+ * Also return its attribute in *attrp;
+ */
+    void
+screen_getbytes(int row, int col, char_u *bytes, int *attrp)
+{
+    unsigned off;
+
+    /* safety check */
+    if (ScreenLines != NULL && row < screen_Rows && col < screen_Columns)
+    {
+	off = LineOffset[row] + col;
+	*attrp = ScreenAttrs[off];
+	bytes[0] = ScreenLines[off];
+	bytes[1] = NUL;
+
+#ifdef FEAT_MBYTE
+	if (enc_utf8 && ScreenLinesUC[off] != 0)
+	    bytes[utfc_char2bytes(off, bytes)] = NUL;
+	else if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
+	{
+	    bytes[0] = ScreenLines[off];
+	    bytes[1] = ScreenLines2[off];
+	    bytes[2] = NUL;
+	}
+	else if (enc_dbcs && MB_BYTE2LEN(bytes[0]) > 1)
+	{
+	    bytes[1] = ScreenLines[off + 1];
+	    bytes[2] = NUL;
+	}
+#endif
+    }
+}
+
+#ifdef FEAT_MBYTE
+static int screen_comp_differs(int, int*);
+
+/*
+ * Return TRUE if composing characters for screen posn "off" differs from
+ * composing characters in "u8cc".
+ * Only to be used when ScreenLinesUC[off] != 0.
+ */
+    static int
+screen_comp_differs(int off, int *u8cc)
+{
+    int	    i;
+
+    for (i = 0; i < Screen_mco; ++i)
+    {
+	if (ScreenLinesC[i][off] != (u8char_T)u8cc[i])
+	    return TRUE;
+	if (u8cc[i] == 0)
+	    break;
+    }
+    return FALSE;
+}
+#endif
+
+/*
+ * Put string '*text' on the screen at position 'row' and 'col', with
+ * attributes 'attr', and update ScreenLines[] and ScreenAttrs[].
+ * Note: only outputs within one row, message is truncated at screen boundary!
+ * Note: if ScreenLines[], row and/or col is invalid, nothing is done.
+ */
+    void
+screen_puts(
+    char_u	*text,
+    int		row,
+    int		col,
+    int		attr)
+{
+    screen_puts_len(text, -1, row, col, attr);
+}
+
+/*
+ * Like screen_puts(), but output "text[len]".  When "len" is -1 output up to
+ * a NUL.
+ */
+    void
+screen_puts_len(
+    char_u	*text,
+    int		textlen,
+    int		row,
+    int		col,
+    int		attr)
+{
+    unsigned	off;
+    char_u	*ptr = text;
+    int		len = textlen;
+    int		c;
+#ifdef FEAT_MBYTE
+    unsigned	max_off;
+    int		mbyte_blen = 1;
+    int		mbyte_cells = 1;
+    int		u8c = 0;
+    int		u8cc[MAX_MCO];
+    int		clear_next_cell = FALSE;
+# ifdef FEAT_ARABIC
+    int		prev_c = 0;		/* previous Arabic character */
+    int		pc, nc, nc1;
+    int		pcc[MAX_MCO];
+# endif
+#endif
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    int		force_redraw_this;
+    int		force_redraw_next = FALSE;
+#endif
+    int		need_redraw;
+
+    if (ScreenLines == NULL || row >= screen_Rows)	/* safety check */
+	return;
+    off = LineOffset[row] + col;
+
+#ifdef FEAT_MBYTE
+    /* When drawing over the right halve of a double-wide char clear out the
+     * left halve.  Only needed in a terminal. */
+    if (has_mbyte && col > 0 && col < screen_Columns
+# ifdef FEAT_GUI
+	    && !gui.in_use
+# endif
+	    && mb_fix_col(col, row) != col)
+    {
+	ScreenLines[off - 1] = ' ';
+	ScreenAttrs[off - 1] = 0;
+	if (enc_utf8)
+	{
+	    ScreenLinesUC[off - 1] = 0;
+	    ScreenLinesC[0][off - 1] = 0;
+	}
+	/* redraw the previous cell, make it empty */
+	screen_char(off - 1, row, col - 1);
+	/* force the cell at "col" to be redrawn */
+	force_redraw_next = TRUE;
+    }
+#endif
+
+#ifdef FEAT_MBYTE
+    max_off = LineOffset[row] + screen_Columns;
+#endif
+    while (col < screen_Columns
+	    && (len < 0 || (int)(ptr - text) < len)
+	    && *ptr != NUL)
+    {
+	c = *ptr;
+#ifdef FEAT_MBYTE
+	/* check if this is the first byte of a multibyte */
+	if (has_mbyte)
+	{
+	    if (enc_utf8 && len > 0)
+		mbyte_blen = utfc_ptr2len_len(ptr, (int)((text + len) - ptr));
+	    else
+		mbyte_blen = (*mb_ptr2len)(ptr);
+	    if (enc_dbcs == DBCS_JPNU && c == 0x8e)
+		mbyte_cells = 1;
+	    else if (enc_dbcs != 0)
+		mbyte_cells = mbyte_blen;
+	    else	/* enc_utf8 */
+	    {
+		if (len >= 0)
+		    u8c = utfc_ptr2char_len(ptr, u8cc,
+						   (int)((text + len) - ptr));
+		else
+		    u8c = utfc_ptr2char(ptr, u8cc);
+		mbyte_cells = utf_char2cells(u8c);
+# ifdef UNICODE16
+		/* Non-BMP character: display as ? or fullwidth ?. */
+		if (u8c >= 0x10000)
+		{
+		    u8c = (mbyte_cells == 2) ? 0xff1f : (int)'?';
+		    if (attr == 0)
+			attr = HL_ATTR(HLF_8);
+		}
+# endif
+# ifdef FEAT_ARABIC
+		if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))
+		{
+		    /* Do Arabic shaping. */
+		    if (len >= 0 && (int)(ptr - text) + mbyte_blen >= len)
+		    {
+			/* Past end of string to be displayed. */
+			nc = NUL;
+			nc1 = NUL;
+		    }
+		    else
+		    {
+			nc = utfc_ptr2char_len(ptr + mbyte_blen, pcc,
+				      (int)((text + len) - ptr - mbyte_blen));
+			nc1 = pcc[0];
+		    }
+		    pc = prev_c;
+		    prev_c = u8c;
+		    u8c = arabic_shape(u8c, &c, &u8cc[0], nc, nc1, pc);
+		}
+		else
+		    prev_c = u8c;
+# endif
+		if (col + mbyte_cells > screen_Columns)
+		{
+		    /* Only 1 cell left, but character requires 2 cells:
+		     * display a '>' in the last column to avoid wrapping. */
+		    c = '>';
+		    mbyte_cells = 1;
+		}
+	    }
+	}
+#endif
+
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+	force_redraw_this = force_redraw_next;
+	force_redraw_next = FALSE;
+#endif
+
+	need_redraw = ScreenLines[off] != c
+#ifdef FEAT_MBYTE
+		|| (mbyte_cells == 2
+		    && ScreenLines[off + 1] != (enc_dbcs ? ptr[1] : 0))
+		|| (enc_dbcs == DBCS_JPNU
+		    && c == 0x8e
+		    && ScreenLines2[off] != ptr[1])
+		|| (enc_utf8
+		    && (ScreenLinesUC[off] !=
+				(u8char_T)(c < 0x80 && u8cc[0] == 0 ? 0 : u8c)
+			|| (ScreenLinesUC[off] != 0
+					  && screen_comp_differs(off, u8cc))))
+#endif
+		|| ScreenAttrs[off] != attr
+		|| exmode_active;
+
+	if (need_redraw
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+		|| force_redraw_this
+#endif
+		)
+	{
+#if defined(FEAT_GUI) || defined(UNIX)
+	    /* The bold trick makes a single row of pixels appear in the next
+	     * character.  When a bold character is removed, the next
+	     * character should be redrawn too.  This happens for our own GUI
+	     * and for some xterms. */
+	    if (need_redraw && ScreenLines[off] != ' ' && (
+# ifdef FEAT_GUI
+		    gui.in_use
+# endif
+# if defined(FEAT_GUI) && defined(UNIX)
+		    ||
+# endif
+# ifdef UNIX
+		    term_is_xterm
+# endif
+		    ))
+	    {
+		int	n = ScreenAttrs[off];
+
+		if (n > HL_ALL)
+		    n = syn_attr2attr(n);
+		if (n & HL_BOLD)
+		    force_redraw_next = TRUE;
+	    }
+#endif
+#ifdef FEAT_MBYTE
+	    /* When at the end of the text and overwriting a two-cell
+	     * character with a one-cell character, need to clear the next
+	     * cell.  Also when overwriting the left halve of a two-cell char
+	     * with the right halve of a two-cell char.  Do this only once
+	     * (mb_off2cells() may return 2 on the right halve). */
+	    if (clear_next_cell)
+		clear_next_cell = FALSE;
+	    else if (has_mbyte
+		    && (len < 0 ? ptr[mbyte_blen] == NUL
+					     : ptr + mbyte_blen >= text + len)
+		    && ((mbyte_cells == 1 && (*mb_off2cells)(off, max_off) > 1)
+			|| (mbyte_cells == 2
+			    && (*mb_off2cells)(off, max_off) == 1
+			    && (*mb_off2cells)(off + 1, max_off) > 1)))
+		clear_next_cell = TRUE;
+
+	    /* Make sure we never leave a second byte of a double-byte behind,
+	     * it confuses mb_off2cells(). */
+	    if (enc_dbcs
+		    && ((mbyte_cells == 1 && (*mb_off2cells)(off, max_off) > 1)
+			|| (mbyte_cells == 2
+			    && (*mb_off2cells)(off, max_off) == 1
+			    && (*mb_off2cells)(off + 1, max_off) > 1)))
+		ScreenLines[off + mbyte_blen] = 0;
+#endif
+	    ScreenLines[off] = c;
+	    ScreenAttrs[off] = attr;
+#ifdef FEAT_MBYTE
+	    if (enc_utf8)
+	    {
+		if (c < 0x80 && u8cc[0] == 0)
+		    ScreenLinesUC[off] = 0;
+		else
+		{
+		    int	    i;
+
+		    ScreenLinesUC[off] = u8c;
+		    for (i = 0; i < Screen_mco; ++i)
+		    {
+			ScreenLinesC[i][off] = u8cc[i];
+			if (u8cc[i] == 0)
+			    break;
+		    }
+		}
+		if (mbyte_cells == 2)
+		{
+		    ScreenLines[off + 1] = 0;
+		    ScreenAttrs[off + 1] = attr;
+		}
+		screen_char(off, row, col);
+	    }
+	    else if (mbyte_cells == 2)
+	    {
+		ScreenLines[off + 1] = ptr[1];
+		ScreenAttrs[off + 1] = attr;
+		screen_char_2(off, row, col);
+	    }
+	    else if (enc_dbcs == DBCS_JPNU && c == 0x8e)
+	    {
+		ScreenLines2[off] = ptr[1];
+		screen_char(off, row, col);
+	    }
+	    else
+#endif
+		screen_char(off, row, col);
+	}
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    off += mbyte_cells;
+	    col += mbyte_cells;
+	    ptr += mbyte_blen;
+	    if (clear_next_cell)
+	    {
+		/* This only happens at the end, display one space next. */
+		ptr = (char_u *)" ";
+		len = -1;
+	    }
+	}
+	else
+#endif
+	{
+	    ++off;
+	    ++col;
+	    ++ptr;
+	}
+    }
+
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    /* If we detected the next character needs to be redrawn, but the text
+     * doesn't extend up to there, update the character here. */
+    if (force_redraw_next && col < screen_Columns)
+    {
+# ifdef FEAT_MBYTE
+	if (enc_dbcs != 0 && dbcs_off2cells(off, max_off) > 1)
+	    screen_char_2(off, row, col);
+	else
+# endif
+	    screen_char(off, row, col);
+    }
+#endif
+}
+
+#ifdef FEAT_SEARCH_EXTRA
+/*
+ * Prepare for 'hlsearch' highlighting.
+ */
+    static void
+start_search_hl(void)
+{
+    if (p_hls && !no_hlsearch)
+    {
+	last_pat_prog(&search_hl.rm);
+	search_hl.attr = HL_ATTR(HLF_L);
+# ifdef FEAT_RELTIME
+	/* Set the time limit to 'redrawtime'. */
+	profile_setlimit(p_rdt, &search_hl.tm);
+# endif
+    }
+}
+
+/*
+ * Clean up for 'hlsearch' highlighting.
+ */
+    static void
+end_search_hl(void)
+{
+    if (search_hl.rm.regprog != NULL)
+    {
+	vim_regfree(search_hl.rm.regprog);
+	search_hl.rm.regprog = NULL;
+    }
+}
+
+/*
+ * Init for calling prepare_search_hl().
+ */
+    static void
+init_search_hl(win_T *wp)
+{
+    matchitem_T *cur;
+
+    /* Setup for match and 'hlsearch' highlighting.  Disable any previous
+     * match */
+    cur = wp->w_match_head;
+    while (cur != NULL)
+    {
+	cur->hl.rm = cur->match;
+	if (cur->hlg_id == 0)
+	    cur->hl.attr = 0;
+	else
+	    cur->hl.attr = syn_id2attr(cur->hlg_id);
+	cur->hl.buf = wp->w_buffer;
+	cur->hl.lnum = 0;
+	cur->hl.first_lnum = 0;
+# ifdef FEAT_RELTIME
+	/* Set the time limit to 'redrawtime'. */
+	profile_setlimit(p_rdt, &(cur->hl.tm));
+# endif
+	cur = cur->next;
+    }
+    search_hl.buf = wp->w_buffer;
+    search_hl.lnum = 0;
+    search_hl.first_lnum = 0;
+    /* time limit is set at the toplevel, for all windows */
+}
+
+/*
+ * Advance to the match in window "wp" line "lnum" or past it.
+ */
+    static void
+prepare_search_hl(win_T *wp, linenr_T lnum)
+{
+    matchitem_T *cur;		/* points to the match list */
+    match_T	*shl;		/* points to search_hl or a match */
+    int		shl_flag;	/* flag to indicate whether search_hl
+				   has been processed or not */
+    int		pos_inprogress;	/* marks that position match search is
+				   in progress */
+    int		n;
+
+    /*
+     * When using a multi-line pattern, start searching at the top
+     * of the window or just after a closed fold.
+     * Do this both for search_hl and the match list.
+     */
+    cur = wp->w_match_head;
+    shl_flag = FALSE;
+    while (cur != NULL || shl_flag == FALSE)
+    {
+	if (shl_flag == FALSE)
+	{
+	    shl = &search_hl;
+	    shl_flag = TRUE;
+	}
+	else
+	    shl = &cur->hl;
+	if (shl->rm.regprog != NULL
+		&& shl->lnum == 0
+		&& re_multiline(shl->rm.regprog))
+	{
+	    if (shl->first_lnum == 0)
+	    {
+# ifdef FEAT_FOLDING
+		for (shl->first_lnum = lnum;
+			   shl->first_lnum > wp->w_topline; --shl->first_lnum)
+		    if (hasFoldingWin(wp, shl->first_lnum - 1,
+						      NULL, NULL, TRUE, NULL))
+			break;
+# else
+		shl->first_lnum = wp->w_topline;
+# endif
+	    }
+	    if (cur != NULL)
+		cur->pos.cur = 0;
+	    pos_inprogress = TRUE;
+	    n = 0;
+	    while (shl->first_lnum < lnum && (shl->rm.regprog != NULL
+					  || (cur != NULL && pos_inprogress)))
+	    {
+		next_search_hl(wp, shl, shl->first_lnum, (colnr_T)n,
+					       shl == &search_hl ? NULL : cur);
+		pos_inprogress = cur == NULL || cur->pos.cur == 0
+							      ? FALSE : TRUE;
+		if (shl->lnum != 0)
+		{
+		    shl->first_lnum = shl->lnum
+				    + shl->rm.endpos[0].lnum
+				    - shl->rm.startpos[0].lnum;
+		    n = shl->rm.endpos[0].col;
+		}
+		else
+		{
+		    ++shl->first_lnum;
+		    n = 0;
+		}
+	    }
+	}
+	if (shl != &search_hl && cur != NULL)
+	    cur = cur->next;
+    }
+}
+
+/*
+ * Search for a next 'hlsearch' or match.
+ * Uses shl->buf.
+ * Sets shl->lnum and shl->rm contents.
+ * Note: Assumes a previous match is always before "lnum", unless
+ * shl->lnum is zero.
+ * Careful: Any pointers for buffer lines will become invalid.
+ */
+    static void
+next_search_hl(
+    win_T	    *win,
+    match_T	    *shl,	/* points to search_hl or a match */
+    linenr_T	    lnum,
+    colnr_T	    mincol,	/* minimal column for a match */
+    matchitem_T	    *cur)	/* to retrieve match positions if any */
+{
+    linenr_T	l;
+    colnr_T	matchcol;
+    long	nmatched;
+    int		save_called_emsg = called_emsg;
+
+    // for :{range}s/pat only highlight inside the range
+    if (lnum < search_first_line || lnum > search_last_line)
+    {
+	shl->lnum = 0;
+	return;
+    }
+
+    if (shl->lnum != 0)
+    {
+	/* Check for three situations:
+	 * 1. If the "lnum" is below a previous match, start a new search.
+	 * 2. If the previous match includes "mincol", use it.
+	 * 3. Continue after the previous match.
+	 */
+	l = shl->lnum + shl->rm.endpos[0].lnum - shl->rm.startpos[0].lnum;
+	if (lnum > l)
+	    shl->lnum = 0;
+	else if (lnum < l || shl->rm.endpos[0].col > mincol)
+	    return;
+    }
+
+    /*
+     * Repeat searching for a match until one is found that includes "mincol"
+     * or none is found in this line.
+     */
+    called_emsg = FALSE;
+    for (;;)
+    {
+#ifdef FEAT_RELTIME
+	/* Stop searching after passing the time limit. */
+	if (profile_passed_limit(&(shl->tm)))
+	{
+	    shl->lnum = 0;		/* no match found in time */
+	    break;
+	}
+#endif
+	/* Three situations:
+	 * 1. No useful previous match: search from start of line.
+	 * 2. Not Vi compatible or empty match: continue at next character.
+	 *    Break the loop if this is beyond the end of the line.
+	 * 3. Vi compatible searching: continue at end of previous match.
+	 */
+	if (shl->lnum == 0)
+	    matchcol = 0;
+	else if (vim_strchr(p_cpo, CPO_SEARCH) == NULL
+		|| (shl->rm.endpos[0].lnum == 0
+		    && shl->rm.endpos[0].col <= shl->rm.startpos[0].col))
+	{
+	    char_u	*ml;
+
+	    matchcol = shl->rm.startpos[0].col;
+	    ml = ml_get_buf(shl->buf, lnum, FALSE) + matchcol;
+	    if (*ml == NUL)
+	    {
+		++matchcol;
+		shl->lnum = 0;
+		break;
+	    }
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		matchcol += mb_ptr2len(ml);
+	    else
+#endif
+		++matchcol;
+	}
+	else
+	    matchcol = shl->rm.endpos[0].col;
+
+	shl->lnum = lnum;
+	if (shl->rm.regprog != NULL)
+	{
+	    /* Remember whether shl->rm is using a copy of the regprog in
+	     * cur->match. */
+	    int regprog_is_copy = (shl != &search_hl && cur != NULL
+				&& shl == &cur->hl
+				&& cur->match.regprog == cur->hl.rm.regprog);
+	    int timed_out = FALSE;
+
+	    nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum,
+		    matchcol,
+#ifdef FEAT_RELTIME
+		    &(shl->tm), &timed_out
+#else
+		    NULL, NULL
+#endif
+		    );
+	    /* Copy the regprog, in case it got freed and recompiled. */
+	    if (regprog_is_copy)
+		cur->match.regprog = cur->hl.rm.regprog;
+
+	    if (called_emsg || got_int || timed_out)
+	    {
+		/* Error while handling regexp: stop using this regexp. */
+		if (shl == &search_hl)
+		{
+		    /* don't free regprog in the match list, it's a copy */
+		    vim_regfree(shl->rm.regprog);
+		    set_no_hlsearch(TRUE);
+		}
+		shl->rm.regprog = NULL;
+		shl->lnum = 0;
+		got_int = FALSE;  /* avoid the "Type :quit to exit Vim"
+				     message */
+		break;
+	    }
+	}
+	else if (cur != NULL)
+	    nmatched = next_search_hl_pos(shl, lnum, &(cur->pos), matchcol);
+	else
+	    nmatched = 0;
+	if (nmatched == 0)
+	{
+	    shl->lnum = 0;		/* no match found */
+	    break;
+	}
+	if (shl->rm.startpos[0].lnum > 0
+		|| shl->rm.startpos[0].col >= mincol
+		|| nmatched > 1
+		|| shl->rm.endpos[0].col > mincol)
+	{
+	    shl->lnum += shl->rm.startpos[0].lnum;
+	    break;			/* useful match found */
+	}
+    }
+
+    // Restore called_emsg for assert_fails().
+    called_emsg = save_called_emsg;
+}
+
+/*
+ * If there is a match fill "shl" and return one.
+ * Return zero otherwise.
+ */
+    static int
+next_search_hl_pos(
+    match_T	    *shl,	/* points to a match */
+    linenr_T	    lnum,
+    posmatch_T	    *posmatch,	/* match positions */
+    colnr_T	    mincol)	/* minimal column for a match */
+{
+    int	    i;
+    int	    found = -1;
+
+    for (i = posmatch->cur; i < MAXPOSMATCH; i++)
+    {
+	llpos_T	*pos = &posmatch->pos[i];
+
+	if (pos->lnum == 0)
+	    break;
+	if (pos->len == 0 && pos->col < mincol)
+	    continue;
+	if (pos->lnum == lnum)
+	{
+	    if (found >= 0)
+	    {
+		/* if this match comes before the one at "found" then swap
+		 * them */
+		if (pos->col < posmatch->pos[found].col)
+		{
+		    llpos_T	tmp = *pos;
+
+		    *pos = posmatch->pos[found];
+		    posmatch->pos[found] = tmp;
+		}
+	    }
+	    else
+		found = i;
+	}
+    }
+    posmatch->cur = 0;
+    if (found >= 0)
+    {
+	colnr_T	start = posmatch->pos[found].col == 0
+					    ? 0 : posmatch->pos[found].col - 1;
+	colnr_T	end = posmatch->pos[found].col == 0
+				   ? MAXCOL : start + posmatch->pos[found].len;
+
+	shl->lnum = lnum;
+	shl->rm.startpos[0].lnum = 0;
+	shl->rm.startpos[0].col = start;
+	shl->rm.endpos[0].lnum = 0;
+	shl->rm.endpos[0].col = end;
+	shl->is_addpos = TRUE;
+	posmatch->cur = found + 1;
+	return 1;
+    }
+    return 0;
+}
+#endif
+
+      static void
+screen_start_highlight(int attr)
+{
+    attrentry_T *aep = NULL;
+
+    screen_attr = attr;
+    if (full_screen
+#ifdef WIN3264
+		    && termcap_active
+#endif
+				       )
+    {
+#ifdef FEAT_GUI
+	if (gui.in_use)
+	{
+	    char	buf[20];
+
+	    /* The GUI handles this internally. */
+	    sprintf(buf, IF_EB("\033|%dh", ESC_STR "|%dh"), attr);
+	    OUT_STR(buf);
+	}
+	else
+#endif
+	{
+	    if (attr > HL_ALL)				/* special HL attr. */
+	    {
+		if (IS_CTERM)
+		    aep = syn_cterm_attr2entry(attr);
+		else
+		    aep = syn_term_attr2entry(attr);
+		if (aep == NULL)	    /* did ":syntax clear" */
+		    attr = 0;
+		else
+		    attr = aep->ae_attr;
+	    }
+	    if ((attr & HL_BOLD) && *T_MD != NUL)	/* bold */
+		out_str(T_MD);
+	    else if (aep != NULL && cterm_normal_fg_bold && (
+#ifdef FEAT_TERMGUICOLORS
+			p_tgc && aep->ae_u.cterm.fg_rgb != CTERMCOLOR
+			  ? aep->ae_u.cterm.fg_rgb != INVALCOLOR
+			  :
+#endif
+			    t_colors > 1 && aep->ae_u.cterm.fg_color))
+		/* If the Normal FG color has BOLD attribute and the new HL
+		 * has a FG color defined, clear BOLD. */
+		out_str(T_ME);
+	    if ((attr & HL_STANDOUT) && *T_SO != NUL)	/* standout */
+		out_str(T_SO);
+	    if ((attr & HL_UNDERCURL) && *T_UCS != NUL) /* undercurl */
+		out_str(T_UCS);
+	    if (((attr & HL_UNDERLINE)	    /* underline or undercurl */
+			|| ((attr & HL_UNDERCURL) && *T_UCS == NUL))
+		    && *T_US != NUL)
+		out_str(T_US);
+	    if ((attr & HL_ITALIC) && *T_CZH != NUL)	/* italic */
+		out_str(T_CZH);
+	    if ((attr & HL_INVERSE) && *T_MR != NUL)	/* inverse (reverse) */
+		out_str(T_MR);
+	    if ((attr & HL_STRIKETHROUGH) && *T_STS != NUL)	/* strike */
+		out_str(T_STS);
+
+	    /*
+	     * Output the color or start string after bold etc., in case the
+	     * bold etc. override the color setting.
+	     */
+	    if (aep != NULL)
+	    {
+#ifdef FEAT_TERMGUICOLORS
+		/* When 'termguicolors' is set but fg or bg is unset,
+		 * fall back to the cterm colors.   This helps for SpellBad,
+		 * where the GUI uses a red undercurl. */
+		if (p_tgc && aep->ae_u.cterm.fg_rgb != CTERMCOLOR)
+		{
+		    if (aep->ae_u.cterm.fg_rgb != INVALCOLOR)
+			term_fg_rgb_color(aep->ae_u.cterm.fg_rgb);
+		}
+		else
+#endif
+		if (t_colors > 1)
+		{
+		    if (aep->ae_u.cterm.fg_color)
+			term_fg_color(aep->ae_u.cterm.fg_color - 1);
+		}
+#ifdef FEAT_TERMGUICOLORS
+		if (p_tgc && aep->ae_u.cterm.bg_rgb != CTERMCOLOR)
+		{
+		    if (aep->ae_u.cterm.bg_rgb != INVALCOLOR)
+			term_bg_rgb_color(aep->ae_u.cterm.bg_rgb);
+		}
+		else
+#endif
+		if (t_colors > 1)
+		{
+		    if (aep->ae_u.cterm.bg_color)
+			term_bg_color(aep->ae_u.cterm.bg_color - 1);
+		}
+
+		if (!IS_CTERM)
+		{
+		    if (aep->ae_u.term.start != NULL)
+			out_str(aep->ae_u.term.start);
+		}
+	    }
+	}
+    }
+}
+
+      void
+screen_stop_highlight(void)
+{
+    int	    do_ME = FALSE;	    /* output T_ME code */
+
+    if (screen_attr != 0
+#ifdef WIN3264
+			&& termcap_active
+#endif
+					   )
+    {
+#ifdef FEAT_GUI
+	if (gui.in_use)
+	{
+	    char	buf[20];
+
+	    /* use internal GUI code */
+	    sprintf(buf, IF_EB("\033|%dH", ESC_STR "|%dH"), screen_attr);
+	    OUT_STR(buf);
+	}
+	else
+#endif
+	{
+	    if (screen_attr > HL_ALL)			/* special HL attr. */
+	    {
+		attrentry_T *aep;
+
+		if (IS_CTERM)
+		{
+		    /*
+		     * Assume that t_me restores the original colors!
+		     */
+		    aep = syn_cterm_attr2entry(screen_attr);
+		    if (aep != NULL && ((
+#ifdef FEAT_TERMGUICOLORS
+			    p_tgc && aep->ae_u.cterm.fg_rgb != CTERMCOLOR
+				? aep->ae_u.cterm.fg_rgb != INVALCOLOR
+				:
+#endif
+				aep->ae_u.cterm.fg_color) || (
+#ifdef FEAT_TERMGUICOLORS
+			    p_tgc && aep->ae_u.cterm.bg_rgb != CTERMCOLOR
+				? aep->ae_u.cterm.bg_rgb != INVALCOLOR
+				:
+#endif
+				aep->ae_u.cterm.bg_color)))
+			do_ME = TRUE;
+		}
+		else
+		{
+		    aep = syn_term_attr2entry(screen_attr);
+		    if (aep != NULL && aep->ae_u.term.stop != NULL)
+		    {
+			if (STRCMP(aep->ae_u.term.stop, T_ME) == 0)
+			    do_ME = TRUE;
+			else
+			    out_str(aep->ae_u.term.stop);
+		    }
+		}
+		if (aep == NULL)	    /* did ":syntax clear" */
+		    screen_attr = 0;
+		else
+		    screen_attr = aep->ae_attr;
+	    }
+
+	    /*
+	     * Often all ending-codes are equal to T_ME.  Avoid outputting the
+	     * same sequence several times.
+	     */
+	    if (screen_attr & HL_STANDOUT)
+	    {
+		if (STRCMP(T_SE, T_ME) == 0)
+		    do_ME = TRUE;
+		else
+		    out_str(T_SE);
+	    }
+	    if ((screen_attr & HL_UNDERCURL) && *T_UCE != NUL)
+	    {
+		if (STRCMP(T_UCE, T_ME) == 0)
+		    do_ME = TRUE;
+		else
+		    out_str(T_UCE);
+	    }
+	    if ((screen_attr & HL_UNDERLINE)
+			    || ((screen_attr & HL_UNDERCURL) && *T_UCE == NUL))
+	    {
+		if (STRCMP(T_UE, T_ME) == 0)
+		    do_ME = TRUE;
+		else
+		    out_str(T_UE);
+	    }
+	    if (screen_attr & HL_ITALIC)
+	    {
+		if (STRCMP(T_CZR, T_ME) == 0)
+		    do_ME = TRUE;
+		else
+		    out_str(T_CZR);
+	    }
+	    if (screen_attr & HL_STRIKETHROUGH)
+	    {
+		if (STRCMP(T_STE, T_ME) == 0)
+		    do_ME = TRUE;
+		else
+		    out_str(T_STE);
+	    }
+	    if (do_ME || (screen_attr & (HL_BOLD | HL_INVERSE)))
+		out_str(T_ME);
+
+#ifdef FEAT_TERMGUICOLORS
+	    if (p_tgc)
+	    {
+		if (cterm_normal_fg_gui_color != INVALCOLOR)
+		    term_fg_rgb_color(cterm_normal_fg_gui_color);
+		if (cterm_normal_bg_gui_color != INVALCOLOR)
+		    term_bg_rgb_color(cterm_normal_bg_gui_color);
+	    }
+	    else
+#endif
+	    {
+		if (t_colors > 1)
+		{
+		    /* set Normal cterm colors */
+		    if (cterm_normal_fg_color != 0)
+			term_fg_color(cterm_normal_fg_color - 1);
+		    if (cterm_normal_bg_color != 0)
+			term_bg_color(cterm_normal_bg_color - 1);
+		    if (cterm_normal_fg_bold)
+			out_str(T_MD);
+		}
+	    }
+	}
+    }
+    screen_attr = 0;
+}
+
+/*
+ * Reset the colors for a cterm.  Used when leaving Vim.
+ * The machine specific code may override this again.
+ */
+    void
+reset_cterm_colors(void)
+{
+    if (IS_CTERM)
+    {
+	/* set Normal cterm colors */
+#ifdef FEAT_TERMGUICOLORS
+	if (p_tgc ? (cterm_normal_fg_gui_color != INVALCOLOR
+		 || cterm_normal_bg_gui_color != INVALCOLOR)
+		: (cterm_normal_fg_color > 0 || cterm_normal_bg_color > 0))
+#else
+	if (cterm_normal_fg_color > 0 || cterm_normal_bg_color > 0)
+#endif
+	{
+	    out_str(T_OP);
+	    screen_attr = -1;
+	}
+	if (cterm_normal_fg_bold)
+	{
+	    out_str(T_ME);
+	    screen_attr = -1;
+	}
+    }
+}
+
+/*
+ * Put character ScreenLines["off"] on the screen at position "row" and "col",
+ * using the attributes from ScreenAttrs["off"].
+ */
+    static void
+screen_char(unsigned off, int row, int col)
+{
+    int		attr;
+
+    /* Check for illegal values, just in case (could happen just after
+     * resizing). */
+    if (row >= screen_Rows || col >= screen_Columns)
+	return;
+
+    /* Outputting a character in the last cell on the screen may scroll the
+     * screen up.  Only do it when the "xn" termcap property is set, otherwise
+     * mark the character invalid (update it when scrolled up). */
+    if (*T_XN == NUL
+	    && row == screen_Rows - 1 && col == screen_Columns - 1
+#ifdef FEAT_RIGHTLEFT
+	    /* account for first command-line character in rightleft mode */
+	    && !cmdmsg_rl
+#endif
+       )
+    {
+	ScreenAttrs[off] = (sattr_T)-1;
+	return;
+    }
+
+    /*
+     * Stop highlighting first, so it's easier to move the cursor.
+     */
+    if (screen_char_attr != 0)
+	attr = screen_char_attr;
+    else
+	attr = ScreenAttrs[off];
+    if (screen_attr != attr)
+	screen_stop_highlight();
+
+    windgoto(row, col);
+
+    if (screen_attr != attr)
+	screen_start_highlight(attr);
+
+#ifdef FEAT_MBYTE
+    if (enc_utf8 && ScreenLinesUC[off] != 0)
+    {
+	char_u	    buf[MB_MAXBYTES + 1];
+
+	if (utf_ambiguous_width(ScreenLinesUC[off]))
+	{
+	    if (*p_ambw == 'd'
+# ifdef FEAT_GUI
+		    && !gui.in_use
+# endif
+		    )
+	    {
+		/* Clear the two screen cells. If the character is actually
+		 * single width it won't change the second cell. */
+		out_str((char_u *)"  ");
+		term_windgoto(row, col);
+	    }
+	    /* not sure where the cursor is after drawing the ambiguous width
+	     * character */
+	    screen_cur_col = 9999;
+	}
+	else if (utf_char2cells(ScreenLinesUC[off]) > 1)
+	    ++screen_cur_col;
+
+	/* Convert the UTF-8 character to bytes and write it. */
+	buf[utfc_char2bytes(off, buf)] = NUL;
+	out_str(buf);
+    }
+    else
+#endif
+    {
+#ifdef FEAT_MBYTE
+	out_flush_check();
+#endif
+	out_char(ScreenLines[off]);
+#ifdef FEAT_MBYTE
+	/* double-byte character in single-width cell */
+	if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
+	    out_char(ScreenLines2[off]);
+#endif
+    }
+
+    screen_cur_col++;
+}
+
+#ifdef FEAT_MBYTE
+
+/*
+ * Used for enc_dbcs only: Put one double-wide character at ScreenLines["off"]
+ * on the screen at position 'row' and 'col'.
+ * The attributes of the first byte is used for all.  This is required to
+ * output the two bytes of a double-byte character with nothing in between.
+ */
+    static void
+screen_char_2(unsigned off, int row, int col)
+{
+    /* Check for illegal values (could be wrong when screen was resized). */
+    if (off + 1 >= (unsigned)(screen_Rows * screen_Columns))
+	return;
+
+    /* Outputting the last character on the screen may scrollup the screen.
+     * Don't to it!  Mark the character invalid (update it when scrolled up) */
+    if (row == screen_Rows - 1 && col >= screen_Columns - 2)
+    {
+	ScreenAttrs[off] = (sattr_T)-1;
+	return;
+    }
+
+    /* Output the first byte normally (positions the cursor), then write the
+     * second byte directly. */
+    screen_char(off, row, col);
+    out_char(ScreenLines[off + 1]);
+    ++screen_cur_col;
+}
+#endif
+
+/*
+ * Draw a rectangle of the screen, inverted when "invert" is TRUE.
+ * This uses the contents of ScreenLines[] and doesn't change it.
+ */
+    void
+screen_draw_rectangle(
+    int		row,
+    int		col,
+    int		height,
+    int		width,
+    int		invert)
+{
+    int		r, c;
+    int		off;
+#ifdef FEAT_MBYTE
+    int		max_off;
+#endif
+
+    /* Can't use ScreenLines unless initialized */
+    if (ScreenLines == NULL)
+	return;
+
+    if (invert)
+	screen_char_attr = HL_INVERSE;
+    for (r = row; r < row + height; ++r)
+    {
+	off = LineOffset[r];
+#ifdef FEAT_MBYTE
+	max_off = off + screen_Columns;
+#endif
+	for (c = col; c < col + width; ++c)
+	{
+#ifdef FEAT_MBYTE
+	    if (enc_dbcs != 0 && dbcs_off2cells(off + c, max_off) > 1)
+	    {
+		screen_char_2(off + c, r, c);
+		++c;
+	    }
+	    else
+#endif
+	    {
+		screen_char(off + c, r, c);
+#ifdef FEAT_MBYTE
+		if (utf_off2cells(off + c, max_off) > 1)
+		    ++c;
+#endif
+	    }
+	}
+    }
+    screen_char_attr = 0;
+}
+
+/*
+ * Redraw the characters for a vertically split window.
+ */
+    static void
+redraw_block(int row, int end, win_T *wp)
+{
+    int		col;
+    int		width;
+
+# ifdef FEAT_CLIPBOARD
+    clip_may_clear_selection(row, end - 1);
+# endif
+
+    if (wp == NULL)
+    {
+	col = 0;
+	width = Columns;
+    }
+    else
+    {
+	col = wp->w_wincol;
+	width = wp->w_width;
+    }
+    screen_draw_rectangle(row, col, end - row, width, FALSE);
+}
+
+    static void
+space_to_screenline(int off, int attr)
+{
+    ScreenLines[off] = ' ';
+    ScreenAttrs[off] = attr;
+# ifdef FEAT_MBYTE
+    if (enc_utf8)
+	ScreenLinesUC[off] = 0;
+# endif
+}
+
+/*
+ * Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
+ * with character 'c1' in first column followed by 'c2' in the other columns.
+ * Use attributes 'attr'.
+ */
+    void
+screen_fill(
+    int	    start_row,
+    int	    end_row,
+    int	    start_col,
+    int	    end_col,
+    int	    c1,
+    int	    c2,
+    int	    attr)
+{
+    int		    row;
+    int		    col;
+    int		    off;
+    int		    end_off;
+    int		    did_delete;
+    int		    c;
+    int		    norm_term;
+#if defined(FEAT_GUI) || defined(UNIX)
+    int		    force_next = FALSE;
+#endif
+
+    if (end_row > screen_Rows)		/* safety check */
+	end_row = screen_Rows;
+    if (end_col > screen_Columns)	/* safety check */
+	end_col = screen_Columns;
+    if (ScreenLines == NULL
+	    || start_row >= end_row
+	    || start_col >= end_col)	/* nothing to do */
+	return;
+
+    /* it's a "normal" terminal when not in a GUI or cterm */
+    norm_term = (
+#ifdef FEAT_GUI
+	    !gui.in_use &&
+#endif
+	    !IS_CTERM);
+    for (row = start_row; row < end_row; ++row)
+    {
+#ifdef FEAT_MBYTE
+	if (has_mbyte
+# ifdef FEAT_GUI
+		&& !gui.in_use
+# endif
+	   )
+	{
+	    /* When drawing over the right halve of a double-wide char clear
+	     * out the left halve.  When drawing over the left halve of a
+	     * double wide-char clear out the right halve.  Only needed in a
+	     * terminal. */
+	    if (start_col > 0 && mb_fix_col(start_col, row) != start_col)
+		screen_puts_len((char_u *)" ", 1, row, start_col - 1, 0);
+	    if (end_col < screen_Columns && mb_fix_col(end_col, row) != end_col)
+		screen_puts_len((char_u *)" ", 1, row, end_col, 0);
+	}
+#endif
+	/*
+	 * Try to use delete-line termcap code, when no attributes or in a
+	 * "normal" terminal, where a bold/italic space is just a
+	 * space.
+	 */
+	did_delete = FALSE;
+	if (c2 == ' '
+		&& end_col == Columns
+		&& can_clear(T_CE)
+		&& (attr == 0
+		    || (norm_term
+			&& attr <= HL_ALL
+			&& ((attr & ~(HL_BOLD | HL_ITALIC)) == 0))))
+	{
+	    /*
+	     * check if we really need to clear something
+	     */
+	    col = start_col;
+	    if (c1 != ' ')			/* don't clear first char */
+		++col;
+
+	    off = LineOffset[row] + col;
+	    end_off = LineOffset[row] + end_col;
+
+	    /* skip blanks (used often, keep it fast!) */
+#ifdef FEAT_MBYTE
+	    if (enc_utf8)
+		while (off < end_off && ScreenLines[off] == ' '
+			  && ScreenAttrs[off] == 0 && ScreenLinesUC[off] == 0)
+		    ++off;
+	    else
+#endif
+		while (off < end_off && ScreenLines[off] == ' '
+						     && ScreenAttrs[off] == 0)
+		    ++off;
+	    if (off < end_off)		/* something to be cleared */
+	    {
+		col = off - LineOffset[row];
+		screen_stop_highlight();
+		term_windgoto(row, col);/* clear rest of this screen line */
+		out_str(T_CE);
+		screen_start();		/* don't know where cursor is now */
+		col = end_col - col;
+		while (col--)		/* clear chars in ScreenLines */
+		{
+		    space_to_screenline(off, 0);
+		    ++off;
+		}
+	    }
+	    did_delete = TRUE;		/* the chars are cleared now */
+	}
+
+	off = LineOffset[row] + start_col;
+	c = c1;
+	for (col = start_col; col < end_col; ++col)
+	{
+	    if (ScreenLines[off] != c
+#ifdef FEAT_MBYTE
+		    || (enc_utf8 && (int)ScreenLinesUC[off]
+						       != (c >= 0x80 ? c : 0))
+#endif
+		    || ScreenAttrs[off] != attr
+#if defined(FEAT_GUI) || defined(UNIX)
+		    || force_next
+#endif
+		    )
+	    {
+#if defined(FEAT_GUI) || defined(UNIX)
+		/* The bold trick may make a single row of pixels appear in
+		 * the next character.  When a bold character is removed, the
+		 * next character should be redrawn too.  This happens for our
+		 * own GUI and for some xterms.  */
+		if (
+# ifdef FEAT_GUI
+			gui.in_use
+# endif
+# if defined(FEAT_GUI) && defined(UNIX)
+			||
+# endif
+# ifdef UNIX
+			term_is_xterm
+# endif
+		   )
+		{
+		    if (ScreenLines[off] != ' '
+			    && (ScreenAttrs[off] > HL_ALL
+				|| ScreenAttrs[off] & HL_BOLD))
+			force_next = TRUE;
+		    else
+			force_next = FALSE;
+		}
+#endif
+		ScreenLines[off] = c;
+#ifdef FEAT_MBYTE
+		if (enc_utf8)
+		{
+		    if (c >= 0x80)
+		    {
+			ScreenLinesUC[off] = c;
+			ScreenLinesC[0][off] = 0;
+		    }
+		    else
+			ScreenLinesUC[off] = 0;
+		}
+#endif
+		ScreenAttrs[off] = attr;
+		if (!did_delete || c != ' ')
+		    screen_char(off, row, col);
+	    }
+	    ++off;
+	    if (col == start_col)
+	    {
+		if (did_delete)
+		    break;
+		c = c2;
+	    }
+	}
+	if (end_col == Columns)
+	    LineWraps[row] = FALSE;
+	if (row == Rows - 1)		/* overwritten the command line */
+	{
+	    redraw_cmdline = TRUE;
+	    if (start_col == 0 && end_col == Columns
+		    && c1 == ' ' && c2 == ' ' && attr == 0)
+		clear_cmdline = FALSE;	/* command line has been cleared */
+	    if (start_col == 0)
+		mode_displayed = FALSE; /* mode cleared or overwritten */
+	}
+    }
+}
+
+/*
+ * Check if there should be a delay.  Used before clearing or redrawing the
+ * screen or the command line.
+ */
+    void
+check_for_delay(int check_msg_scroll)
+{
+    if ((emsg_on_display || (check_msg_scroll && msg_scroll))
+	    && !did_wait_return
+	    && emsg_silent == 0)
+    {
+	out_flush();
+	ui_delay(1000L, TRUE);
+	emsg_on_display = FALSE;
+	if (check_msg_scroll)
+	    msg_scroll = FALSE;
+    }
+}
+
+/*
+ * screen_valid -  allocate screen buffers if size changed
+ *   If "doclear" is TRUE: clear screen if it has been resized.
+ *	Returns TRUE if there is a valid screen to write to.
+ *	Returns FALSE when starting up and screen not initialized yet.
+ */
+    int
+screen_valid(int doclear)
+{
+    screenalloc(doclear);	   /* allocate screen buffers if size changed */
+    return (ScreenLines != NULL);
+}
+
+/*
+ * Resize the shell to Rows and Columns.
+ * Allocate ScreenLines[] and associated items.
+ *
+ * There may be some time between setting Rows and Columns and (re)allocating
+ * ScreenLines[].  This happens when starting up and when (manually) changing
+ * the shell size.  Always use screen_Rows and screen_Columns to access items
+ * in ScreenLines[].  Use Rows and Columns for positioning text etc. where the
+ * final size of the shell is needed.
+ */
+    void
+screenalloc(int doclear)
+{
+    int		    new_row, old_row;
+#ifdef FEAT_GUI
+    int		    old_Rows;
+#endif
+    win_T	    *wp;
+    int		    outofmem = FALSE;
+    int		    len;
+    schar_T	    *new_ScreenLines;
+#ifdef FEAT_MBYTE
+    u8char_T	    *new_ScreenLinesUC = NULL;
+    u8char_T	    *new_ScreenLinesC[MAX_MCO];
+    schar_T	    *new_ScreenLines2 = NULL;
+    int		    i;
+#endif
+    sattr_T	    *new_ScreenAttrs;
+    unsigned	    *new_LineOffset;
+    char_u	    *new_LineWraps;
+    short	    *new_TabPageIdxs;
+    tabpage_T	    *tp;
+    static int	    entered = FALSE;		/* avoid recursiveness */
+    static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
+    int		    retry_count = 0;
+
+retry:
+    /*
+     * Allocation of the screen buffers is done only when the size changes and
+     * when Rows and Columns have been set and we have started doing full
+     * screen stuff.
+     */
+    if ((ScreenLines != NULL
+		&& Rows == screen_Rows
+		&& Columns == screen_Columns
+#ifdef FEAT_MBYTE
+		&& enc_utf8 == (ScreenLinesUC != NULL)
+		&& (enc_dbcs == DBCS_JPNU) == (ScreenLines2 != NULL)
+		&& p_mco == Screen_mco
+#endif
+		)
+	    || Rows == 0
+	    || Columns == 0
+	    || (!full_screen && ScreenLines == NULL))
+	return;
+
+    /*
+     * It's possible that we produce an out-of-memory message below, which
+     * will cause this function to be called again.  To break the loop, just
+     * return here.
+     */
+    if (entered)
+	return;
+    entered = TRUE;
+
+    /*
+     * Note that the window sizes are updated before reallocating the arrays,
+     * thus we must not redraw here!
+     */
+    ++RedrawingDisabled;
+
+    win_new_shellsize();    /* fit the windows in the new sized shell */
+
+    comp_col();		/* recompute columns for shown command and ruler */
+
+    /*
+     * We're changing the size of the screen.
+     * - Allocate new arrays for ScreenLines and ScreenAttrs.
+     * - Move lines from the old arrays into the new arrays, clear extra
+     *	 lines (unless the screen is going to be cleared).
+     * - Free the old arrays.
+     *
+     * If anything fails, make ScreenLines NULL, so we don't do anything!
+     * Continuing with the old ScreenLines may result in a crash, because the
+     * size is wrong.
+     */
+    FOR_ALL_TAB_WINDOWS(tp, wp)
+	win_free_lsize(wp);
+    if (aucmd_win != NULL)
+	win_free_lsize(aucmd_win);
+
+    new_ScreenLines = (schar_T *)lalloc((long_u)(
+			      (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
+#ifdef FEAT_MBYTE
+    vim_memset(new_ScreenLinesC, 0, sizeof(u8char_T *) * MAX_MCO);
+    if (enc_utf8)
+    {
+	new_ScreenLinesUC = (u8char_T *)lalloc((long_u)(
+			     (Rows + 1) * Columns * sizeof(u8char_T)), FALSE);
+	for (i = 0; i < p_mco; ++i)
+	    new_ScreenLinesC[i] = (u8char_T *)lalloc_clear((long_u)(
+			     (Rows + 1) * Columns * sizeof(u8char_T)), FALSE);
+    }
+    if (enc_dbcs == DBCS_JPNU)
+	new_ScreenLines2 = (schar_T *)lalloc((long_u)(
+			     (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
+#endif
+    new_ScreenAttrs = (sattr_T *)lalloc((long_u)(
+			      (Rows + 1) * Columns * sizeof(sattr_T)), FALSE);
+    new_LineOffset = (unsigned *)lalloc((long_u)(
+					 Rows * sizeof(unsigned)), FALSE);
+    new_LineWraps = (char_u *)lalloc((long_u)(Rows * sizeof(char_u)), FALSE);
+    new_TabPageIdxs = (short *)lalloc((long_u)(Columns * sizeof(short)), FALSE);
+
+    FOR_ALL_TAB_WINDOWS(tp, wp)
+    {
+	if (win_alloc_lines(wp) == FAIL)
+	{
+	    outofmem = TRUE;
+	    goto give_up;
+	}
+    }
+    if (aucmd_win != NULL && aucmd_win->w_lines == NULL
+					&& win_alloc_lines(aucmd_win) == FAIL)
+	outofmem = TRUE;
+give_up:
+
+#ifdef FEAT_MBYTE
+    for (i = 0; i < p_mco; ++i)
+	if (new_ScreenLinesC[i] == NULL)
+	    break;
+#endif
+    if (new_ScreenLines == NULL
+#ifdef FEAT_MBYTE
+	    || (enc_utf8 && (new_ScreenLinesUC == NULL || i != p_mco))
+	    || (enc_dbcs == DBCS_JPNU && new_ScreenLines2 == NULL)
+#endif
+	    || new_ScreenAttrs == NULL
+	    || new_LineOffset == NULL
+	    || new_LineWraps == NULL
+	    || new_TabPageIdxs == NULL
+	    || outofmem)
+    {
+	if (ScreenLines != NULL || !done_outofmem_msg)
+	{
+	    /* guess the size */
+	    do_outofmem_msg((long_u)((Rows + 1) * Columns));
+
+	    /* Remember we did this to avoid getting outofmem messages over
+	     * and over again. */
+	    done_outofmem_msg = TRUE;
+	}
+	VIM_CLEAR(new_ScreenLines);
+#ifdef FEAT_MBYTE
+	VIM_CLEAR(new_ScreenLinesUC);
+	for (i = 0; i < p_mco; ++i)
+	    VIM_CLEAR(new_ScreenLinesC[i]);
+	VIM_CLEAR(new_ScreenLines2);
+#endif
+	VIM_CLEAR(new_ScreenAttrs);
+	VIM_CLEAR(new_LineOffset);
+	VIM_CLEAR(new_LineWraps);
+	VIM_CLEAR(new_TabPageIdxs);
+    }
+    else
+    {
+	done_outofmem_msg = FALSE;
+
+	for (new_row = 0; new_row < Rows; ++new_row)
+	{
+	    new_LineOffset[new_row] = new_row * Columns;
+	    new_LineWraps[new_row] = FALSE;
+
+	    /*
+	     * If the screen is not going to be cleared, copy as much as
+	     * possible from the old screen to the new one and clear the rest
+	     * (used when resizing the window at the "--more--" prompt or when
+	     * executing an external command, for the GUI).
+	     */
+	    if (!doclear)
+	    {
+		(void)vim_memset(new_ScreenLines + new_row * Columns,
+				      ' ', (size_t)Columns * sizeof(schar_T));
+#ifdef FEAT_MBYTE
+		if (enc_utf8)
+		{
+		    (void)vim_memset(new_ScreenLinesUC + new_row * Columns,
+				       0, (size_t)Columns * sizeof(u8char_T));
+		    for (i = 0; i < p_mco; ++i)
+			(void)vim_memset(new_ScreenLinesC[i]
+							  + new_row * Columns,
+				       0, (size_t)Columns * sizeof(u8char_T));
+		}
+		if (enc_dbcs == DBCS_JPNU)
+		    (void)vim_memset(new_ScreenLines2 + new_row * Columns,
+				       0, (size_t)Columns * sizeof(schar_T));
+#endif
+		(void)vim_memset(new_ScreenAttrs + new_row * Columns,
+					0, (size_t)Columns * sizeof(sattr_T));
+		old_row = new_row + (screen_Rows - Rows);
+		if (old_row >= 0 && ScreenLines != NULL)
+		{
+		    if (screen_Columns < Columns)
+			len = screen_Columns;
+		    else
+			len = Columns;
+#ifdef FEAT_MBYTE
+		    /* When switching to utf-8 don't copy characters, they
+		     * may be invalid now.  Also when p_mco changes. */
+		    if (!(enc_utf8 && ScreenLinesUC == NULL)
+						       && p_mco == Screen_mco)
+#endif
+			mch_memmove(new_ScreenLines + new_LineOffset[new_row],
+				ScreenLines + LineOffset[old_row],
+				(size_t)len * sizeof(schar_T));
+#ifdef FEAT_MBYTE
+		    if (enc_utf8 && ScreenLinesUC != NULL
+						       && p_mco == Screen_mco)
+		    {
+			mch_memmove(new_ScreenLinesUC + new_LineOffset[new_row],
+				ScreenLinesUC + LineOffset[old_row],
+				(size_t)len * sizeof(u8char_T));
+			for (i = 0; i < p_mco; ++i)
+			    mch_memmove(new_ScreenLinesC[i]
+						    + new_LineOffset[new_row],
+				ScreenLinesC[i] + LineOffset[old_row],
+				(size_t)len * sizeof(u8char_T));
+		    }
+		    if (enc_dbcs == DBCS_JPNU && ScreenLines2 != NULL)
+			mch_memmove(new_ScreenLines2 + new_LineOffset[new_row],
+				ScreenLines2 + LineOffset[old_row],
+				(size_t)len * sizeof(schar_T));
+#endif
+		    mch_memmove(new_ScreenAttrs + new_LineOffset[new_row],
+			    ScreenAttrs + LineOffset[old_row],
+			    (size_t)len * sizeof(sattr_T));
+		}
+	    }
+	}
+	/* Use the last line of the screen for the current line. */
+	current_ScreenLine = new_ScreenLines + Rows * Columns;
+    }
+
+    free_screenlines();
+
+    ScreenLines = new_ScreenLines;
+#ifdef FEAT_MBYTE
+    ScreenLinesUC = new_ScreenLinesUC;
+    for (i = 0; i < p_mco; ++i)
+	ScreenLinesC[i] = new_ScreenLinesC[i];
+    Screen_mco = p_mco;
+    ScreenLines2 = new_ScreenLines2;
+#endif
+    ScreenAttrs = new_ScreenAttrs;
+    LineOffset = new_LineOffset;
+    LineWraps = new_LineWraps;
+    TabPageIdxs = new_TabPageIdxs;
+
+    /* It's important that screen_Rows and screen_Columns reflect the actual
+     * size of ScreenLines[].  Set them before calling anything. */
+#ifdef FEAT_GUI
+    old_Rows = screen_Rows;
+#endif
+    screen_Rows = Rows;
+    screen_Columns = Columns;
+
+    must_redraw = CLEAR;	/* need to clear the screen later */
+    if (doclear)
+	screenclear2();
+
+#ifdef FEAT_GUI
+    else if (gui.in_use
+	    && !gui.starting
+	    && ScreenLines != NULL
+	    && old_Rows != Rows)
+    {
+	(void)gui_redraw_block(0, 0, (int)Rows - 1, (int)Columns - 1, 0);
+	/*
+	 * Adjust the position of the cursor, for when executing an external
+	 * command.
+	 */
+	if (msg_row >= Rows)		/* Rows got smaller */
+	    msg_row = Rows - 1;		/* put cursor at last row */
+	else if (Rows > old_Rows)	/* Rows got bigger */
+	    msg_row += Rows - old_Rows; /* put cursor in same place */
+	if (msg_col >= Columns)		/* Columns got smaller */
+	    msg_col = Columns - 1;	/* put cursor at last column */
+    }
+#endif
+
+    entered = FALSE;
+    --RedrawingDisabled;
+
+    /*
+     * Do not apply autocommands more than 3 times to avoid an endless loop
+     * in case applying autocommands always changes Rows or Columns.
+     */
+    if (starting == 0 && ++retry_count <= 3)
+    {
+	apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);
+	/* In rare cases, autocommands may have altered Rows or Columns,
+	 * jump back to check if we need to allocate the screen again. */
+	goto retry;
+    }
+}
+
+    void
+free_screenlines(void)
+{
+#ifdef FEAT_MBYTE
+    int		i;
+
+    vim_free(ScreenLinesUC);
+    for (i = 0; i < Screen_mco; ++i)
+	vim_free(ScreenLinesC[i]);
+    vim_free(ScreenLines2);
+#endif
+    vim_free(ScreenLines);
+    vim_free(ScreenAttrs);
+    vim_free(LineOffset);
+    vim_free(LineWraps);
+    vim_free(TabPageIdxs);
+}
+
+    void
+screenclear(void)
+{
+    check_for_delay(FALSE);
+    screenalloc(FALSE);	    /* allocate screen buffers if size changed */
+    screenclear2();	    /* clear the screen */
+}
+
+    static void
+screenclear2(void)
+{
+    int	    i;
+
+    if (starting == NO_SCREEN || ScreenLines == NULL
+#ifdef FEAT_GUI
+	    || (gui.in_use && gui.starting)
+#endif
+	    )
+	return;
+
+#ifdef FEAT_GUI
+    if (!gui.in_use)
+#endif
+	screen_attr = -1;	/* force setting the Normal colors */
+    screen_stop_highlight();	/* don't want highlighting here */
+
+#ifdef FEAT_CLIPBOARD
+    /* disable selection without redrawing it */
+    clip_scroll_selection(9999);
+#endif
+
+    /* blank out ScreenLines */
+    for (i = 0; i < Rows; ++i)
+    {
+	lineclear(LineOffset[i], (int)Columns, 0);
+	LineWraps[i] = FALSE;
+    }
+
+    if (can_clear(T_CL))
+    {
+	out_str(T_CL);		/* clear the display */
+	clear_cmdline = FALSE;
+	mode_displayed = FALSE;
+    }
+    else
+    {
+	/* can't clear the screen, mark all chars with invalid attributes */
+	for (i = 0; i < Rows; ++i)
+	    lineinvalid(LineOffset[i], (int)Columns);
+	clear_cmdline = TRUE;
+    }
+
+    screen_cleared = TRUE;	/* can use contents of ScreenLines now */
+
+    win_rest_invalid(firstwin);
+    redraw_cmdline = TRUE;
+    redraw_tabline = TRUE;
+    if (must_redraw == CLEAR)	/* no need to clear again */
+	must_redraw = NOT_VALID;
+    compute_cmdrow();
+    msg_row = cmdline_row;	/* put cursor on last line for messages */
+    msg_col = 0;
+    screen_start();		/* don't know where cursor is now */
+    msg_scrolled = 0;		/* can't scroll back */
+    msg_didany = FALSE;
+    msg_didout = FALSE;
+}
+
+/*
+ * Clear one line in ScreenLines.
+ */
+    static void
+lineclear(unsigned off, int width, int attr)
+{
+    (void)vim_memset(ScreenLines + off, ' ', (size_t)width * sizeof(schar_T));
+#ifdef FEAT_MBYTE
+    if (enc_utf8)
+	(void)vim_memset(ScreenLinesUC + off, 0,
+					  (size_t)width * sizeof(u8char_T));
+#endif
+    (void)vim_memset(ScreenAttrs + off, attr, (size_t)width * sizeof(sattr_T));
+}
+
+/*
+ * Mark one line in ScreenLines invalid by setting the attributes to an
+ * invalid value.
+ */
+    static void
+lineinvalid(unsigned off, int width)
+{
+    (void)vim_memset(ScreenAttrs + off, -1, (size_t)width * sizeof(sattr_T));
+}
+
+/*
+ * Copy part of a Screenline for vertically split window "wp".
+ */
+    static void
+linecopy(int to, int from, win_T *wp)
+{
+    unsigned	off_to = LineOffset[to] + wp->w_wincol;
+    unsigned	off_from = LineOffset[from] + wp->w_wincol;
+
+    mch_memmove(ScreenLines + off_to, ScreenLines + off_from,
+	    wp->w_width * sizeof(schar_T));
+#ifdef FEAT_MBYTE
+    if (enc_utf8)
+    {
+	int	i;
+
+	mch_memmove(ScreenLinesUC + off_to, ScreenLinesUC + off_from,
+		wp->w_width * sizeof(u8char_T));
+	for (i = 0; i < p_mco; ++i)
+	    mch_memmove(ScreenLinesC[i] + off_to, ScreenLinesC[i] + off_from,
+		    wp->w_width * sizeof(u8char_T));
+    }
+    if (enc_dbcs == DBCS_JPNU)
+	mch_memmove(ScreenLines2 + off_to, ScreenLines2 + off_from,
+		wp->w_width * sizeof(schar_T));
+#endif
+    mch_memmove(ScreenAttrs + off_to, ScreenAttrs + off_from,
+	    wp->w_width * sizeof(sattr_T));
+}
+
+/*
+ * Return TRUE if clearing with term string "p" would work.
+ * It can't work when the string is empty or it won't set the right background.
+ */
+    int
+can_clear(char_u *p)
+{
+    return (*p != NUL && (t_colors <= 1
+#ifdef FEAT_GUI
+		|| gui.in_use
+#endif
+#ifdef FEAT_TERMGUICOLORS
+		|| (p_tgc && cterm_normal_bg_gui_color == INVALCOLOR)
+		|| (!p_tgc && cterm_normal_bg_color == 0)
+#else
+		|| cterm_normal_bg_color == 0
+#endif
+		|| *T_UT != NUL));
+}
+
+/*
+ * Reset cursor position. Use whenever cursor was moved because of outputting
+ * something directly to the screen (shell commands) or a terminal control
+ * code.
+ */
+    void
+screen_start(void)
+{
+    screen_cur_row = screen_cur_col = 9999;
+}
+
+/*
+ * Move the cursor to position "row","col" in the screen.
+ * This tries to find the most efficient way to move, minimizing the number of
+ * characters sent to the terminal.
+ */
+    void
+windgoto(int row, int col)
+{
+    sattr_T	    *p;
+    int		    i;
+    int		    plan;
+    int		    cost;
+    int		    wouldbe_col;
+    int		    noinvcurs;
+    char_u	    *bs;
+    int		    goto_cost;
+    int		    attr;
+
+#define GOTO_COST   7	/* assume a term_windgoto() takes about 7 chars */
+#define HIGHL_COST  5	/* assume unhighlight takes 5 chars */
+
+#define PLAN_LE	    1
+#define PLAN_CR	    2
+#define PLAN_NL	    3
+#define PLAN_WRITE  4
+    /* Can't use ScreenLines unless initialized */
+    if (ScreenLines == NULL)
+	return;
+
+    if (col != screen_cur_col || row != screen_cur_row)
+    {
+	/* Check for valid position. */
+	if (row < 0)	/* window without text lines? */
+	    row = 0;
+	if (row >= screen_Rows)
+	    row = screen_Rows - 1;
+	if (col >= screen_Columns)
+	    col = screen_Columns - 1;
+
+	/* check if no cursor movement is allowed in highlight mode */
+	if (screen_attr && *T_MS == NUL)
+	    noinvcurs = HIGHL_COST;
+	else
+	    noinvcurs = 0;
+	goto_cost = GOTO_COST + noinvcurs;
+
+	/*
+	 * Plan how to do the positioning:
+	 * 1. Use CR to move it to column 0, same row.
+	 * 2. Use T_LE to move it a few columns to the left.
+	 * 3. Use NL to move a few lines down, column 0.
+	 * 4. Move a few columns to the right with T_ND or by writing chars.
+	 *
+	 * Don't do this if the cursor went beyond the last column, the cursor
+	 * position is unknown then (some terminals wrap, some don't )
+	 *
+	 * First check if the highlighting attributes allow us to write
+	 * characters to move the cursor to the right.
+	 */
+	if (row >= screen_cur_row && screen_cur_col < Columns)
+	{
+	    /*
+	     * If the cursor is in the same row, bigger col, we can use CR
+	     * or T_LE.
+	     */
+	    bs = NULL;			    /* init for GCC */
+	    attr = screen_attr;
+	    if (row == screen_cur_row && col < screen_cur_col)
+	    {
+		/* "le" is preferred over "bc", because "bc" is obsolete */
+		if (*T_LE)
+		    bs = T_LE;		    /* "cursor left" */
+		else
+		    bs = T_BC;		    /* "backspace character (old) */
+		if (*bs)
+		    cost = (screen_cur_col - col) * (int)STRLEN(bs);
+		else
+		    cost = 999;
+		if (col + 1 < cost)	    /* using CR is less characters */
+		{
+		    plan = PLAN_CR;
+		    wouldbe_col = 0;
+		    cost = 1;		    /* CR is just one character */
+		}
+		else
+		{
+		    plan = PLAN_LE;
+		    wouldbe_col = col;
+		}
+		if (noinvcurs)		    /* will stop highlighting */
+		{
+		    cost += noinvcurs;
+		    attr = 0;
+		}
+	    }
+
+	    /*
+	     * If the cursor is above where we want to be, we can use CR LF.
+	     */
+	    else if (row > screen_cur_row)
+	    {
+		plan = PLAN_NL;
+		wouldbe_col = 0;
+		cost = (row - screen_cur_row) * 2;  /* CR LF */
+		if (noinvcurs)		    /* will stop highlighting */
+		{
+		    cost += noinvcurs;
+		    attr = 0;
+		}
+	    }
+
+	    /*
+	     * If the cursor is in the same row, smaller col, just use write.
+	     */
+	    else
+	    {
+		plan = PLAN_WRITE;
+		wouldbe_col = screen_cur_col;
+		cost = 0;
+	    }
+
+	    /*
+	     * Check if any characters that need to be written have the
+	     * correct attributes.  Also avoid UTF-8 characters.
+	     */
+	    i = col - wouldbe_col;
+	    if (i > 0)
+		cost += i;
+	    if (cost < goto_cost && i > 0)
+	    {
+		/*
+		 * Check if the attributes are correct without additionally
+		 * stopping highlighting.
+		 */
+		p = ScreenAttrs + LineOffset[row] + wouldbe_col;
+		while (i && *p++ == attr)
+		    --i;
+		if (i != 0)
+		{
+		    /*
+		     * Try if it works when highlighting is stopped here.
+		     */
+		    if (*--p == 0)
+		    {
+			cost += noinvcurs;
+			while (i && *p++ == 0)
+			    --i;
+		    }
+		    if (i != 0)
+			cost = 999;	/* different attributes, don't do it */
+		}
+#ifdef FEAT_MBYTE
+		if (enc_utf8)
+		{
+		    /* Don't use an UTF-8 char for positioning, it's slow. */
+		    for (i = wouldbe_col; i < col; ++i)
+			if (ScreenLinesUC[LineOffset[row] + i] != 0)
+			{
+			    cost = 999;
+			    break;
+			}
+		}
+#endif
+	    }
+
+	    /*
+	     * We can do it without term_windgoto()!
+	     */
+	    if (cost < goto_cost)
+	    {
+		if (plan == PLAN_LE)
+		{
+		    if (noinvcurs)
+			screen_stop_highlight();
+		    while (screen_cur_col > col)
+		    {
+			out_str(bs);
+			--screen_cur_col;
+		    }
+		}
+		else if (plan == PLAN_CR)
+		{
+		    if (noinvcurs)
+			screen_stop_highlight();
+		    out_char('\r');
+		    screen_cur_col = 0;
+		}
+		else if (plan == PLAN_NL)
+		{
+		    if (noinvcurs)
+			screen_stop_highlight();
+		    while (screen_cur_row < row)
+		    {
+			out_char('\n');
+			++screen_cur_row;
+		    }
+		    screen_cur_col = 0;
+		}
+
+		i = col - screen_cur_col;
+		if (i > 0)
+		{
+		    /*
+		     * Use cursor-right if it's one character only.  Avoids
+		     * removing a line of pixels from the last bold char, when
+		     * using the bold trick in the GUI.
+		     */
+		    if (T_ND[0] != NUL && T_ND[1] == NUL)
+		    {
+			while (i-- > 0)
+			    out_char(*T_ND);
+		    }
+		    else
+		    {
+			int	off;
+
+			off = LineOffset[row] + screen_cur_col;
+			while (i-- > 0)
+			{
+			    if (ScreenAttrs[off] != screen_attr)
+				screen_stop_highlight();
+#ifdef FEAT_MBYTE
+			    out_flush_check();
+#endif
+			    out_char(ScreenLines[off]);
+#ifdef FEAT_MBYTE
+			    if (enc_dbcs == DBCS_JPNU
+						  && ScreenLines[off] == 0x8e)
+				out_char(ScreenLines2[off]);
+#endif
+			    ++off;
+			}
+		    }
+		}
+	    }
+	}
+	else
+	    cost = 999;
+
+	if (cost >= goto_cost)
+	{
+	    if (noinvcurs)
+		screen_stop_highlight();
+	    if (row == screen_cur_row && (col > screen_cur_col)
+							     && *T_CRI != NUL)
+		term_cursor_right(col - screen_cur_col);
+	    else
+		term_windgoto(row, col);
+	}
+	screen_cur_row = row;
+	screen_cur_col = col;
+    }
+}
+
+/*
+ * Set cursor to its position in the current window.
+ */
+    void
+setcursor(void)
+{
+    setcursor_mayforce(FALSE);
+}
+
+/*
+ * Set cursor to its position in the current window.
+ * When "force" is TRUE also when not redrawing.
+ */
+    void
+setcursor_mayforce(int force)
+{
+    if (force || redrawing())
+    {
+	validate_cursor();
+	windgoto(W_WINROW(curwin) + curwin->w_wrow,
+		curwin->w_wincol + (
+#ifdef FEAT_RIGHTLEFT
+		/* With 'rightleft' set and the cursor on a double-wide
+		 * character, position it on the leftmost column. */
+		curwin->w_p_rl ? ((int)curwin->w_width - curwin->w_wcol - (
+# ifdef FEAT_MBYTE
+			(has_mbyte
+			   && (*mb_ptr2cells)(ml_get_cursor()) == 2
+			   && vim_isprintc(gchar_cursor())) ? 2 :
+# endif
+			1)) :
+#endif
+							    curwin->w_wcol));
+    }
+}
+
+
+/*
+ * Insert 'line_count' lines at 'row' in window 'wp'.
+ * If 'invalid' is TRUE the wp->w_lines[].wl_lnum is invalidated.
+ * If 'mayclear' is TRUE the screen will be cleared if it is faster than
+ * scrolling.
+ * Returns FAIL if the lines are not inserted, OK for success.
+ */
+    int
+win_ins_lines(
+    win_T	*wp,
+    int		row,
+    int		line_count,
+    int		invalid,
+    int		mayclear)
+{
+    int		did_delete;
+    int		nextrow;
+    int		lastrow;
+    int		retval;
+
+    if (invalid)
+	wp->w_lines_valid = 0;
+
+    if (wp->w_height < 5)
+	return FAIL;
+
+    if (line_count > wp->w_height - row)
+	line_count = wp->w_height - row;
+
+    retval = win_do_lines(wp, row, line_count, mayclear, FALSE, 0);
+    if (retval != MAYBE)
+	return retval;
+
+    /*
+     * If there is a next window or a status line, we first try to delete the
+     * lines at the bottom to avoid messing what is after the window.
+     * If this fails and there are following windows, don't do anything to avoid
+     * messing up those windows, better just redraw.
+     */
+    did_delete = FALSE;
+    if (wp->w_next != NULL || wp->w_status_height)
+    {
+	if (screen_del_lines(0, W_WINROW(wp) + wp->w_height - line_count,
+				  line_count, (int)Rows, FALSE, 0, NULL) == OK)
+	    did_delete = TRUE;
+	else if (wp->w_next)
+	    return FAIL;
+    }
+    /*
+     * if no lines deleted, blank the lines that will end up below the window
+     */
+    if (!did_delete)
+    {
+	wp->w_redr_status = TRUE;
+	redraw_cmdline = TRUE;
+	nextrow = W_WINROW(wp) + wp->w_height + wp->w_status_height;
+	lastrow = nextrow + line_count;
+	if (lastrow > Rows)
+	    lastrow = Rows;
+	screen_fill(nextrow - line_count, lastrow - line_count,
+		  wp->w_wincol, (int)W_ENDCOL(wp),
+		  ' ', ' ', 0);
+    }
+
+    if (screen_ins_lines(0, W_WINROW(wp) + row, line_count, (int)Rows, 0, NULL)
+								      == FAIL)
+    {
+	    /* deletion will have messed up other windows */
+	if (did_delete)
+	{
+	    wp->w_redr_status = TRUE;
+	    win_rest_invalid(W_NEXT(wp));
+	}
+	return FAIL;
+    }
+
+    return OK;
+}
+
+/*
+ * Delete "line_count" window lines at "row" in window "wp".
+ * If "invalid" is TRUE curwin->w_lines[] is invalidated.
+ * If "mayclear" is TRUE the screen will be cleared if it is faster than
+ * scrolling
+ * Return OK for success, FAIL if the lines are not deleted.
+ */
+    int
+win_del_lines(
+    win_T	*wp,
+    int		row,
+    int		line_count,
+    int		invalid,
+    int		mayclear,
+    int		clear_attr)	    /* for clearing lines */
+{
+    int		retval;
+
+    if (invalid)
+	wp->w_lines_valid = 0;
+
+    if (line_count > wp->w_height - row)
+	line_count = wp->w_height - row;
+
+    retval = win_do_lines(wp, row, line_count, mayclear, TRUE, clear_attr);
+    if (retval != MAYBE)
+	return retval;
+
+    if (screen_del_lines(0, W_WINROW(wp) + row, line_count,
+				   (int)Rows, FALSE, clear_attr, NULL) == FAIL)
+	return FAIL;
+
+    /*
+     * If there are windows or status lines below, try to put them at the
+     * correct place. If we can't do that, they have to be redrawn.
+     */
+    if (wp->w_next || wp->w_status_height || cmdline_row < Rows - 1)
+    {
+	if (screen_ins_lines(0, W_WINROW(wp) + wp->w_height - line_count,
+			      line_count, (int)Rows, clear_attr, NULL) == FAIL)
+	{
+	    wp->w_redr_status = TRUE;
+	    win_rest_invalid(wp->w_next);
+	}
+    }
+    /*
+     * If this is the last window and there is no status line, redraw the
+     * command line later.
+     */
+    else
+	redraw_cmdline = TRUE;
+    return OK;
+}
+
+/*
+ * Common code for win_ins_lines() and win_del_lines().
+ * Returns OK or FAIL when the work has been done.
+ * Returns MAYBE when not finished yet.
+ */
+    static int
+win_do_lines(
+    win_T	*wp,
+    int		row,
+    int		line_count,
+    int		mayclear,
+    int		del,
+    int		clear_attr)
+{
+    int		retval;
+
+    if (!redrawing() || line_count <= 0)
+	return FAIL;
+
+    /* When inserting lines would result in loss of command output, just redraw
+     * the lines. */
+    if (no_win_do_lines_ins && !del)
+	return FAIL;
+
+    /* only a few lines left: redraw is faster */
+    if (mayclear && Rows - line_count < 5 && wp->w_width == Columns)
+    {
+	if (!no_win_do_lines_ins)
+	    screenclear();	    /* will set wp->w_lines_valid to 0 */
+	return FAIL;
+    }
+
+    /*
+     * Delete all remaining lines
+     */
+    if (row + line_count >= wp->w_height)
+    {
+	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + wp->w_height,
+		wp->w_wincol, (int)W_ENDCOL(wp),
+		' ', ' ', 0);
+	return OK;
+    }
+
+    /*
+     * When scrolling, the message on the command line should be cleared,
+     * otherwise it will stay there forever.
+     * Don't do this when avoiding to insert lines.
+     */
+    if (!no_win_do_lines_ins)
+	clear_cmdline = TRUE;
+
+    /*
+     * If the terminal can set a scroll region, use that.
+     * Always do this in a vertically split window.  This will redraw from
+     * ScreenLines[] when t_CV isn't defined.  That's faster than using
+     * win_line().
+     * Don't use a scroll region when we are going to redraw the text, writing
+     * a character in the lower right corner of the scroll region may cause a
+     * scroll-up .
+     */
+    if (scroll_region || wp->w_width != Columns)
+    {
+	if (scroll_region && (wp->w_width == Columns || *T_CSV != NUL))
+	    scroll_region_set(wp, row);
+	if (del)
+	    retval = screen_del_lines(W_WINROW(wp) + row, 0, line_count,
+				    wp->w_height - row, FALSE, clear_attr, wp);
+	else
+	    retval = screen_ins_lines(W_WINROW(wp) + row, 0, line_count,
+					   wp->w_height - row, clear_attr, wp);
+	if (scroll_region && (wp->w_width == Columns || *T_CSV != NUL))
+	    scroll_region_reset();
+	return retval;
+    }
+
+    if (wp->w_next != NULL && p_tf) /* don't delete/insert on fast terminal */
+	return FAIL;
+
+    return MAYBE;
+}
+
+/*
+ * window 'wp' and everything after it is messed up, mark it for redraw
+ */
+    static void
+win_rest_invalid(win_T *wp)
+{
+    while (wp != NULL)
+    {
+	redraw_win_later(wp, NOT_VALID);
+	wp->w_redr_status = TRUE;
+	wp = wp->w_next;
+    }
+    redraw_cmdline = TRUE;
+}
+
+/*
+ * The rest of the routines in this file perform screen manipulations. The
+ * given operation is performed physically on the screen. The corresponding
+ * change is also made to the internal screen image. In this way, the editor
+ * anticipates the effect of editing changes on the appearance of the screen.
+ * That way, when we call screenupdate a complete redraw isn't usually
+ * necessary. Another advantage is that we can keep adding code to anticipate
+ * screen changes, and in the meantime, everything still works.
+ */
+
+/*
+ * types for inserting or deleting lines
+ */
+#define USE_T_CAL   1
+#define USE_T_CDL   2
+#define USE_T_AL    3
+#define USE_T_CE    4
+#define USE_T_DL    5
+#define USE_T_SR    6
+#define USE_NL	    7
+#define USE_T_CD    8
+#define USE_REDRAW  9
+
+/*
+ * insert lines on the screen and update ScreenLines[]
+ * 'end' is the line after the scrolled part. Normally it is Rows.
+ * When scrolling region used 'off' is the offset from the top for the region.
+ * 'row' and 'end' are relative to the start of the region.
+ *
+ * return FAIL for failure, OK for success.
+ */
+    int
+screen_ins_lines(
+    int		off,
+    int		row,
+    int		line_count,
+    int		end,
+    int		clear_attr,
+    win_T	*wp)	    /* NULL or window to use width from */
+{
+    int		i;
+    int		j;
+    unsigned	temp;
+    int		cursor_row;
+    int		cursor_col = 0;
+    int		type;
+    int		result_empty;
+    int		can_ce = can_clear(T_CE);
+
+    /*
+     * FAIL if
+     * - there is no valid screen
+     * - the screen has to be redrawn completely
+     * - the line count is less than one
+     * - the line count is more than 'ttyscroll'
+     * - redrawing for a callback and there is a modeless selection
+     */
+     if (!screen_valid(TRUE) || line_count <= 0 || line_count > p_ttyscroll
+#ifdef FEAT_CLIPBOARD
+	     || (clip_star.state != SELECT_CLEARED
+						 && redrawing_for_callback > 0)
+#endif
+	     )
+	return FAIL;
+
+    /*
+     * There are seven ways to insert lines:
+     * 0. When in a vertically split window and t_CV isn't set, redraw the
+     *    characters from ScreenLines[].
+     * 1. Use T_CD (clear to end of display) if it exists and the result of
+     *	  the insert is just empty lines
+     * 2. Use T_CAL (insert multiple lines) if it exists and T_AL is not
+     *	  present or line_count > 1. It looks better if we do all the inserts
+     *	  at once.
+     * 3. Use T_CDL (delete multiple lines) if it exists and the result of the
+     *	  insert is just empty lines and T_CE is not present or line_count >
+     *	  1.
+     * 4. Use T_AL (insert line) if it exists.
+     * 5. Use T_CE (erase line) if it exists and the result of the insert is
+     *	  just empty lines.
+     * 6. Use T_DL (delete line) if it exists and the result of the insert is
+     *	  just empty lines.
+     * 7. Use T_SR (scroll reverse) if it exists and inserting at row 0 and
+     *	  the 'da' flag is not set or we have clear line capability.
+     * 8. redraw the characters from ScreenLines[].
+     *
+     * Careful: In a hpterm scroll reverse doesn't work as expected, it moves
+     * the scrollbar for the window. It does have insert line, use that if it
+     * exists.
+     */
+    result_empty = (row + line_count >= end);
+    if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
+	type = USE_REDRAW;
+    else if (can_clear(T_CD) && result_empty)
+	type = USE_T_CD;
+    else if (*T_CAL != NUL && (line_count > 1 || *T_AL == NUL))
+	type = USE_T_CAL;
+    else if (*T_CDL != NUL && result_empty && (line_count > 1 || !can_ce))
+	type = USE_T_CDL;
+    else if (*T_AL != NUL)
+	type = USE_T_AL;
+    else if (can_ce && result_empty)
+	type = USE_T_CE;
+    else if (*T_DL != NUL && result_empty)
+	type = USE_T_DL;
+    else if (*T_SR != NUL && row == 0 && (*T_DA == NUL || can_ce))
+	type = USE_T_SR;
+    else
+	return FAIL;
+
+    /*
+     * For clearing the lines screen_del_lines() is used. This will also take
+     * care of t_db if necessary.
+     */
+    if (type == USE_T_CD || type == USE_T_CDL ||
+					 type == USE_T_CE || type == USE_T_DL)
+	return screen_del_lines(off, row, line_count, end, FALSE, 0, wp);
+
+    /*
+     * If text is retained below the screen, first clear or delete as many
+     * lines at the bottom of the window as are about to be inserted so that
+     * the deleted lines won't later surface during a screen_del_lines.
+     */
+    if (*T_DB)
+	screen_del_lines(off, end - line_count, line_count, end, FALSE, 0, wp);
+
+#ifdef FEAT_CLIPBOARD
+    /* Remove a modeless selection when inserting lines halfway the screen
+     * or not the full width of the screen. */
+    if (off + row > 0 || (wp != NULL && wp->w_width != Columns))
+	clip_clear_selection(&clip_star);
+    else
+	clip_scroll_selection(-line_count);
+#endif
+
+#ifdef FEAT_GUI
+    /* Don't update the GUI cursor here, ScreenLines[] is invalid until the
+     * scrolling is actually carried out. */
+    gui_dont_update_cursor(row + off <= gui.cursor_row);
+#endif
+
+    if (wp != NULL && wp->w_wincol != 0 && *T_CSV != NUL && *T_CCS == NUL)
+	cursor_col = wp->w_wincol;
+
+    if (*T_CCS != NUL)	   /* cursor relative to region */
+	cursor_row = row;
+    else
+	cursor_row = row + off;
+
+    /*
+     * Shift LineOffset[] line_count down to reflect the inserted lines.
+     * Clear the inserted lines in ScreenLines[].
+     */
+    row += off;
+    end += off;
+    for (i = 0; i < line_count; ++i)
+    {
+	if (wp != NULL && wp->w_width != Columns)
+	{
+	    /* need to copy part of a line */
+	    j = end - 1 - i;
+	    while ((j -= line_count) >= row)
+		linecopy(j + line_count, j, wp);
+	    j += line_count;
+	    if (can_clear((char_u *)" "))
+		lineclear(LineOffset[j] + wp->w_wincol, wp->w_width,
+								   clear_attr);
+	    else
+		lineinvalid(LineOffset[j] + wp->w_wincol, wp->w_width);
+	    LineWraps[j] = FALSE;
+	}
+	else
+	{
+	    j = end - 1 - i;
+	    temp = LineOffset[j];
+	    while ((j -= line_count) >= row)
+	    {
+		LineOffset[j + line_count] = LineOffset[j];
+		LineWraps[j + line_count] = LineWraps[j];
+	    }
+	    LineOffset[j + line_count] = temp;
+	    LineWraps[j + line_count] = FALSE;
+	    if (can_clear((char_u *)" "))
+		lineclear(temp, (int)Columns, clear_attr);
+	    else
+		lineinvalid(temp, (int)Columns);
+	}
+    }
+
+    screen_stop_highlight();
+    windgoto(cursor_row, cursor_col);
+    if (clear_attr != 0)
+	screen_start_highlight(clear_attr);
+
+    /* redraw the characters */
+    if (type == USE_REDRAW)
+	redraw_block(row, end, wp);
+    else if (type == USE_T_CAL)
+    {
+	term_append_lines(line_count);
+	screen_start();		/* don't know where cursor is now */
+    }
+    else
+    {
+	for (i = 0; i < line_count; i++)
+	{
+	    if (type == USE_T_AL)
+	    {
+		if (i && cursor_row != 0)
+		    windgoto(cursor_row, cursor_col);
+		out_str(T_AL);
+	    }
+	    else  /* type == USE_T_SR */
+		out_str(T_SR);
+	    screen_start();	    /* don't know where cursor is now */
+	}
+    }
+
+    /*
+     * With scroll-reverse and 'da' flag set we need to clear the lines that
+     * have been scrolled down into the region.
+     */
+    if (type == USE_T_SR && *T_DA)
+    {
+	for (i = 0; i < line_count; ++i)
+	{
+	    windgoto(off + i, cursor_col);
+	    out_str(T_CE);
+	    screen_start();	    /* don't know where cursor is now */
+	}
+    }
+
+#ifdef FEAT_GUI
+    gui_can_update_cursor();
+    if (gui.in_use)
+	out_flush();	/* always flush after a scroll */
+#endif
+    return OK;
+}
+
+/*
+ * Delete lines on the screen and update ScreenLines[].
+ * "end" is the line after the scrolled part. Normally it is Rows.
+ * When scrolling region used "off" is the offset from the top for the region.
+ * "row" and "end" are relative to the start of the region.
+ *
+ * Return OK for success, FAIL if the lines are not deleted.
+ */
+    int
+screen_del_lines(
+    int		off,
+    int		row,
+    int		line_count,
+    int		end,
+    int		force,		/* even when line_count > p_ttyscroll */
+    int		clear_attr,	/* used for clearing lines */
+    win_T	*wp UNUSED)	/* NULL or window to use width from */
+{
+    int		j;
+    int		i;
+    unsigned	temp;
+    int		cursor_row;
+    int		cursor_col = 0;
+    int		cursor_end;
+    int		result_empty;	/* result is empty until end of region */
+    int		can_delete;	/* deleting line codes can be used */
+    int		type;
+
+    /*
+     * FAIL if
+     * - there is no valid screen
+     * - the screen has to be redrawn completely
+     * - the line count is less than one
+     * - the line count is more than 'ttyscroll'
+     * - redrawing for a callback and there is a modeless selection
+     */
+    if (!screen_valid(TRUE) || line_count <= 0
+					|| (!force && line_count > p_ttyscroll)
+#ifdef FEAT_CLIPBOARD
+	     || (clip_star.state != SELECT_CLEARED
+						 && redrawing_for_callback > 0)
+#endif
+       )
+	return FAIL;
+
+    /*
+     * Check if the rest of the current region will become empty.
+     */
+    result_empty = row + line_count >= end;
+
+    /*
+     * We can delete lines only when 'db' flag not set or when 'ce' option
+     * available.
+     */
+    can_delete = (*T_DB == NUL || can_clear(T_CE));
+
+    /*
+     * There are six ways to delete lines:
+     * 0. When in a vertically split window and t_CV isn't set, redraw the
+     *    characters from ScreenLines[].
+     * 1. Use T_CD if it exists and the result is empty.
+     * 2. Use newlines if row == 0 and count == 1 or T_CDL does not exist.
+     * 3. Use T_CDL (delete multiple lines) if it exists and line_count > 1 or
+     *	  none of the other ways work.
+     * 4. Use T_CE (erase line) if the result is empty.
+     * 5. Use T_DL (delete line) if it exists.
+     * 6. redraw the characters from ScreenLines[].
+     */
+    if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
+	type = USE_REDRAW;
+    else if (can_clear(T_CD) && result_empty)
+	type = USE_T_CD;
+#if defined(__BEOS__) && defined(BEOS_DR8)
+    /*
+     * USE_NL does not seem to work in Terminal of DR8 so we set T_DB="" in
+     * its internal termcap... this works okay for tests which test *T_DB !=
+     * NUL.  It has the disadvantage that the user cannot use any :set t_*
+     * command to get T_DB (back) to empty_option, only :set term=... will do
+     * the trick...
+     * Anyway, this hack will hopefully go away with the next OS release.
+     * (Olaf Seibert)
+     */
+    else if (row == 0 && T_DB == empty_option
+					&& (line_count == 1 || *T_CDL == NUL))
+#else
+    else if (row == 0 && (
+#ifndef AMIGA
+	/* On the Amiga, somehow '\n' on the last line doesn't always scroll
+	 * up, so use delete-line command */
+			    line_count == 1 ||
+#endif
+						*T_CDL == NUL))
+#endif
+	type = USE_NL;
+    else if (*T_CDL != NUL && line_count > 1 && can_delete)
+	type = USE_T_CDL;
+    else if (can_clear(T_CE) && result_empty
+	    && (wp == NULL || wp->w_width == Columns))
+	type = USE_T_CE;
+    else if (*T_DL != NUL && can_delete)
+	type = USE_T_DL;
+    else if (*T_CDL != NUL && can_delete)
+	type = USE_T_CDL;
+    else
+	return FAIL;
+
+#ifdef FEAT_CLIPBOARD
+    /* Remove a modeless selection when deleting lines halfway the screen or
+     * not the full width of the screen. */
+    if (off + row > 0 || (wp != NULL && wp->w_width != Columns))
+	clip_clear_selection(&clip_star);
+    else
+	clip_scroll_selection(line_count);
+#endif
+
+#ifdef FEAT_GUI
+    /* Don't update the GUI cursor here, ScreenLines[] is invalid until the
+     * scrolling is actually carried out. */
+    gui_dont_update_cursor(gui.cursor_row >= row + off
+						&& gui.cursor_row < end + off);
+#endif
+
+    if (wp != NULL && wp->w_wincol != 0 && *T_CSV != NUL && *T_CCS == NUL)
+	cursor_col = wp->w_wincol;
+
+    if (*T_CCS != NUL)	    /* cursor relative to region */
+    {
+	cursor_row = row;
+	cursor_end = end;
+    }
+    else
+    {
+	cursor_row = row + off;
+	cursor_end = end + off;
+    }
+
+    /*
+     * Now shift LineOffset[] line_count up to reflect the deleted lines.
+     * Clear the inserted lines in ScreenLines[].
+     */
+    row += off;
+    end += off;
+    for (i = 0; i < line_count; ++i)
+    {
+	if (wp != NULL && wp->w_width != Columns)
+	{
+	    /* need to copy part of a line */
+	    j = row + i;
+	    while ((j += line_count) <= end - 1)
+		linecopy(j - line_count, j, wp);
+	    j -= line_count;
+	    if (can_clear((char_u *)" "))
+		lineclear(LineOffset[j] + wp->w_wincol, wp->w_width,
+								   clear_attr);
+	    else
+		lineinvalid(LineOffset[j] + wp->w_wincol, wp->w_width);
+	    LineWraps[j] = FALSE;
+	}
+	else
+	{
+	    /* whole width, moving the line pointers is faster */
+	    j = row + i;
+	    temp = LineOffset[j];
+	    while ((j += line_count) <= end - 1)
+	    {
+		LineOffset[j - line_count] = LineOffset[j];
+		LineWraps[j - line_count] = LineWraps[j];
+	    }
+	    LineOffset[j - line_count] = temp;
+	    LineWraps[j - line_count] = FALSE;
+	    if (can_clear((char_u *)" "))
+		lineclear(temp, (int)Columns, clear_attr);
+	    else
+		lineinvalid(temp, (int)Columns);
+	}
+    }
+
+    if (screen_attr != clear_attr)
+	screen_stop_highlight();
+    if (clear_attr != 0)
+	screen_start_highlight(clear_attr);
+
+    /* redraw the characters */
+    if (type == USE_REDRAW)
+	redraw_block(row, end, wp);
+    else if (type == USE_T_CD)	/* delete the lines */
+    {
+	windgoto(cursor_row, cursor_col);
+	out_str(T_CD);
+	screen_start();			/* don't know where cursor is now */
+    }
+    else if (type == USE_T_CDL)
+    {
+	windgoto(cursor_row, cursor_col);
+	term_delete_lines(line_count);
+	screen_start();			/* don't know where cursor is now */
+    }
+    /*
+     * Deleting lines at top of the screen or scroll region: Just scroll
+     * the whole screen (scroll region) up by outputting newlines on the
+     * last line.
+     */
+    else if (type == USE_NL)
+    {
+	windgoto(cursor_end - 1, cursor_col);
+	for (i = line_count; --i >= 0; )
+	    out_char('\n');		/* cursor will remain on same line */
+    }
+    else
+    {
+	for (i = line_count; --i >= 0; )
+	{
+	    if (type == USE_T_DL)
+	    {
+		windgoto(cursor_row, cursor_col);
+		out_str(T_DL);		/* delete a line */
+	    }
+	    else /* type == USE_T_CE */
+	    {
+		windgoto(cursor_row + i, cursor_col);
+		out_str(T_CE);		/* erase a line */
+	    }
+	    screen_start();		/* don't know where cursor is now */
+	}
+    }
+
+    /*
+     * If the 'db' flag is set, we need to clear the lines that have been
+     * scrolled up at the bottom of the region.
+     */
+    if (*T_DB && (type == USE_T_DL || type == USE_T_CDL))
+    {
+	for (i = line_count; i > 0; --i)
+	{
+	    windgoto(cursor_end - i, cursor_col);
+	    out_str(T_CE);		/* erase a line */
+	    screen_start();		/* don't know where cursor is now */
+	}
+    }
+
+#ifdef FEAT_GUI
+    gui_can_update_cursor();
+    if (gui.in_use)
+	out_flush();	/* always flush after a scroll */
+#endif
+
+    return OK;
+}
+
+/*
+ * Show the current mode and ruler.
+ *
+ * If clear_cmdline is TRUE, clear the rest of the cmdline.
+ * If clear_cmdline is FALSE there may be a message there that needs to be
+ * cleared only if a mode is shown.
+ * Return the length of the message (0 if no message).
+ */
+    int
+showmode(void)
+{
+    int		need_clear;
+    int		length = 0;
+    int		do_mode;
+    int		attr;
+    int		nwr_save;
+#ifdef FEAT_INS_EXPAND
+    int		sub_attr;
+#endif
+
+    do_mode = ((p_smd && msg_silent == 0)
+	    && ((State & INSERT)
+		|| restart_edit != NUL
+		|| VIsual_active));
+    if (do_mode || reg_recording != 0)
+    {
+	/*
+	 * Don't show mode right now, when not redrawing or inside a mapping.
+	 * Call char_avail() only when we are going to show something, because
+	 * it takes a bit of time.
+	 */
+	if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0)
+	{
+	    redraw_cmdline = TRUE;		/* show mode later */
+	    return 0;
+	}
+
+	nwr_save = need_wait_return;
+
+	/* wait a bit before overwriting an important message */
+	check_for_delay(FALSE);
+
+	/* if the cmdline is more than one line high, erase top lines */
+	need_clear = clear_cmdline;
+	if (clear_cmdline && cmdline_row < Rows - 1)
+	    msg_clr_cmdline();			/* will reset clear_cmdline */
+
+	/* Position on the last line in the window, column 0 */
+	msg_pos_mode();
+	cursor_off();
+	attr = HL_ATTR(HLF_CM);			/* Highlight mode */
+	if (do_mode)
+	{
+	    MSG_PUTS_ATTR("--", attr);
+#if defined(FEAT_XIM)
+	    if (
+# ifdef FEAT_GUI_GTK
+		    preedit_get_status()
+# else
+		    im_get_status()
+# endif
+	       )
+# ifdef FEAT_GUI_GTK /* most of the time, it's not XIM being used */
+		MSG_PUTS_ATTR(" IM", attr);
+# else
+		MSG_PUTS_ATTR(" XIM", attr);
+# endif
+#endif
+#if defined(FEAT_HANGULIN) && defined(FEAT_GUI)
+	    if (gui.in_use)
+	    {
+		if (hangul_input_state_get())
+		{
+		    /* HANGUL */
+		    if (enc_utf8)
+			MSG_PUTS_ATTR(" \355\225\234\352\270\200", attr);
+		    else
+			MSG_PUTS_ATTR(" \307\321\261\333", attr);
+		}
+	    }
+#endif
+#ifdef FEAT_INS_EXPAND
+	    /* CTRL-X in Insert mode */
+	    if (edit_submode != NULL && !shortmess(SHM_COMPLETIONMENU))
+	    {
+		/* These messages can get long, avoid a wrap in a narrow
+		 * window.  Prefer showing edit_submode_extra. */
+		length = (Rows - msg_row) * Columns - 3;
+		if (edit_submode_extra != NULL)
+		    length -= vim_strsize(edit_submode_extra);
+		if (length > 0)
+		{
+		    if (edit_submode_pre != NULL)
+			length -= vim_strsize(edit_submode_pre);
+		    if (length - vim_strsize(edit_submode) > 0)
+		    {
+			if (edit_submode_pre != NULL)
+			    msg_puts_attr(edit_submode_pre, attr);
+			msg_puts_attr(edit_submode, attr);
+		    }
+		    if (edit_submode_extra != NULL)
+		    {
+			MSG_PUTS_ATTR(" ", attr);  /* add a space in between */
+			if ((int)edit_submode_highl < (int)HLF_COUNT)
+			    sub_attr = HL_ATTR(edit_submode_highl);
+			else
+			    sub_attr = attr;
+			msg_puts_attr(edit_submode_extra, sub_attr);
+		    }
+		}
+	    }
+	    else
+#endif
+	    {
+		if (State & VREPLACE_FLAG)
+		    MSG_PUTS_ATTR(_(" VREPLACE"), attr);
+		else if (State & REPLACE_FLAG)
+		    MSG_PUTS_ATTR(_(" REPLACE"), attr);
+		else if (State & INSERT)
+		{
+#ifdef FEAT_RIGHTLEFT
+		    if (p_ri)
+			MSG_PUTS_ATTR(_(" REVERSE"), attr);
+#endif
+		    MSG_PUTS_ATTR(_(" INSERT"), attr);
+		}
+		else if (restart_edit == 'I' || restart_edit == 'A')
+		    MSG_PUTS_ATTR(_(" (insert)"), attr);
+		else if (restart_edit == 'R')
+		    MSG_PUTS_ATTR(_(" (replace)"), attr);
+		else if (restart_edit == 'V')
+		    MSG_PUTS_ATTR(_(" (vreplace)"), attr);
+#ifdef FEAT_RIGHTLEFT
+		if (p_hkmap)
+		    MSG_PUTS_ATTR(_(" Hebrew"), attr);
+# ifdef FEAT_FKMAP
+		if (p_fkmap)
+		    MSG_PUTS_ATTR(farsi_text_5, attr);
+# endif
+#endif
+#ifdef FEAT_KEYMAP
+		if (State & LANGMAP)
+		{
+# ifdef FEAT_ARABIC
+		    if (curwin->w_p_arab)
+			MSG_PUTS_ATTR(_(" Arabic"), attr);
+		    else
+# endif
+			if (get_keymap_str(curwin, (char_u *)" (%s)",
+							   NameBuff, MAXPATHL))
+			    MSG_PUTS_ATTR(NameBuff, attr);
+		}
+#endif
+		if ((State & INSERT) && p_paste)
+		    MSG_PUTS_ATTR(_(" (paste)"), attr);
+
+		if (VIsual_active)
+		{
+		    char *p;
+
+		    /* Don't concatenate separate words to avoid translation
+		     * problems. */
+		    switch ((VIsual_select ? 4 : 0)
+			    + (VIsual_mode == Ctrl_V) * 2
+			    + (VIsual_mode == 'V'))
+		    {
+			case 0:	p = N_(" VISUAL"); break;
+			case 1: p = N_(" VISUAL LINE"); break;
+			case 2: p = N_(" VISUAL BLOCK"); break;
+			case 4: p = N_(" SELECT"); break;
+			case 5: p = N_(" SELECT LINE"); break;
+			default: p = N_(" SELECT BLOCK"); break;
+		    }
+		    MSG_PUTS_ATTR(_(p), attr);
+		}
+		MSG_PUTS_ATTR(" --", attr);
+	    }
+
+	    need_clear = TRUE;
+	}
+	if (reg_recording != 0
+#ifdef FEAT_INS_EXPAND
+		&& edit_submode == NULL	    /* otherwise it gets too long */
+#endif
+		)
+	{
+	    recording_mode(attr);
+	    need_clear = TRUE;
+	}
+
+	mode_displayed = TRUE;
+	if (need_clear || clear_cmdline)
+	    msg_clr_eos();
+	msg_didout = FALSE;		/* overwrite this message */
+	length = msg_col;
+	msg_col = 0;
+	need_wait_return = nwr_save;	/* never ask for hit-return for this */
+    }
+    else if (clear_cmdline && msg_silent == 0)
+	/* Clear the whole command line.  Will reset "clear_cmdline". */
+	msg_clr_cmdline();
+
+#ifdef FEAT_CMDL_INFO
+    /* In Visual mode the size of the selected area must be redrawn. */
+    if (VIsual_active)
+	clear_showcmd();
+
+    /* If the last window has no status line, the ruler is after the mode
+     * message and must be redrawn */
+    if (redrawing() && lastwin->w_status_height == 0)
+	win_redr_ruler(lastwin, TRUE, FALSE);
+#endif
+    redraw_cmdline = FALSE;
+    clear_cmdline = FALSE;
+
+    return length;
+}
+
+/*
+ * Position for a mode message.
+ */
+    static void
+msg_pos_mode(void)
+{
+    msg_col = 0;
+    msg_row = Rows - 1;
+}
+
+/*
+ * Delete mode message.  Used when ESC is typed which is expected to end
+ * Insert mode (but Insert mode didn't end yet!).
+ * Caller should check "mode_displayed".
+ */
+    void
+unshowmode(int force)
+{
+    /*
+     * Don't delete it right now, when not redrawing or inside a mapping.
+     */
+    if (!redrawing() || (!force && char_avail() && !KeyTyped))
+	redraw_cmdline = TRUE;		/* delete mode later */
+    else
+	clearmode();
+}
+
+/*
+ * Clear the mode message.
+ */
+    void
+clearmode(void)
+{
+    int save_msg_row = msg_row;
+    int save_msg_col = msg_col;
+
+    msg_pos_mode();
+    if (reg_recording != 0)
+	recording_mode(HL_ATTR(HLF_CM));
+    msg_clr_eos();
+
+    msg_col = save_msg_col;
+    msg_row = save_msg_row;
+}
+
+    static void
+recording_mode(int attr)
+{
+    MSG_PUTS_ATTR(_("recording"), attr);
+    if (!shortmess(SHM_RECORDING))
+    {
+	char_u s[4];
+	sprintf((char *)s, " @%c", reg_recording);
+	MSG_PUTS_ATTR(s, attr);
+    }
+}
+
+/*
+ * Draw the tab pages line at the top of the Vim window.
+ */
+    static void
+draw_tabline(void)
+{
+    int		tabcount = 0;
+    tabpage_T	*tp;
+    int		tabwidth;
+    int		col = 0;
+    int		scol = 0;
+    int		attr;
+    win_T	*wp;
+    win_T	*cwp;
+    int		wincount;
+    int		modified;
+    int		c;
+    int		len;
+    int		attr_sel = HL_ATTR(HLF_TPS);
+    int		attr_nosel = HL_ATTR(HLF_TP);
+    int		attr_fill = HL_ATTR(HLF_TPF);
+    char_u	*p;
+    int		room;
+    int		use_sep_chars = (t_colors < 8
+#ifdef FEAT_GUI
+					    && !gui.in_use
+#endif
+#ifdef FEAT_TERMGUICOLORS
+					    && !p_tgc
+#endif
+					    );
+
+    if (ScreenLines == NULL)
+	return;
+    redraw_tabline = FALSE;
+
+#ifdef FEAT_GUI_TABLINE
+    /* Take care of a GUI tabline. */
+    if (gui_use_tabline())
+    {
+	gui_update_tabline();
+	return;
+    }
+#endif
+
+    if (tabline_height() < 1)
+	return;
+
+#if defined(FEAT_STL_OPT)
+
+    /* Init TabPageIdxs[] to zero: Clicking outside of tabs has no effect. */
+    for (scol = 0; scol < Columns; ++scol)
+	TabPageIdxs[scol] = 0;
+
+    /* Use the 'tabline' option if it's set. */
+    if (*p_tal != NUL)
+    {
+	int	saved_did_emsg = did_emsg;
+
+	/* Check for an error.  If there is one we would loop in redrawing the
+	 * screen.  Avoid that by making 'tabline' empty. */
+	did_emsg = FALSE;
+	win_redr_custom(NULL, FALSE);
+	if (did_emsg)
+	    set_string_option_direct((char_u *)"tabline", -1,
+					   (char_u *)"", OPT_FREE, SID_ERROR);
+	did_emsg |= saved_did_emsg;
+    }
+    else
+#endif
+    {
+	FOR_ALL_TABPAGES(tp)
+	    ++tabcount;
+
+	tabwidth = (Columns - 1 + tabcount / 2) / tabcount;
+	if (tabwidth < 6)
+	    tabwidth = 6;
+
+	attr = attr_nosel;
+	tabcount = 0;
+	scol = 0;
+	for (tp = first_tabpage; tp != NULL && col < Columns - 4;
+							     tp = tp->tp_next)
+	{
+	    scol = col;
+
+	    if (tp->tp_topframe == topframe)
+		attr = attr_sel;
+	    if (use_sep_chars && col > 0)
+		screen_putchar('|', 0, col++, attr);
+
+	    if (tp->tp_topframe != topframe)
+		attr = attr_nosel;
+
+	    screen_putchar(' ', 0, col++, attr);
+
+	    if (tp == curtab)
+	    {
+		cwp = curwin;
+		wp = firstwin;
+	    }
+	    else
+	    {
+		cwp = tp->tp_curwin;
+		wp = tp->tp_firstwin;
+	    }
+
+	    modified = FALSE;
+	    for (wincount = 0; wp != NULL; wp = wp->w_next, ++wincount)
+		if (bufIsChanged(wp->w_buffer))
+		    modified = TRUE;
+	    if (modified || wincount > 1)
+	    {
+		if (wincount > 1)
+		{
+		    vim_snprintf((char *)NameBuff, MAXPATHL, "%d", wincount);
+		    len = (int)STRLEN(NameBuff);
+		    if (col + len >= Columns - 3)
+			break;
+		    screen_puts_len(NameBuff, len, 0, col,
+#if defined(FEAT_SYN_HL)
+					 hl_combine_attr(attr, HL_ATTR(HLF_T))
+#else
+					 attr
+#endif
+					       );
+		    col += len;
+		}
+		if (modified)
+		    screen_puts_len((char_u *)"+", 1, 0, col++, attr);
+		screen_putchar(' ', 0, col++, attr);
+	    }
+
+	    room = scol - col + tabwidth - 1;
+	    if (room > 0)
+	    {
+		/* Get buffer name in NameBuff[] */
+		get_trans_bufname(cwp->w_buffer);
+		shorten_dir(NameBuff);
+		len = vim_strsize(NameBuff);
+		p = NameBuff;
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		    while (len > room)
+		    {
+			len -= ptr2cells(p);
+			MB_PTR_ADV(p);
+		    }
+		else
+#endif
+		    if (len > room)
+		{
+		    p += len - room;
+		    len = room;
+		}
+		if (len > Columns - col - 1)
+		    len = Columns - col - 1;
+
+		screen_puts_len(p, (int)STRLEN(p), 0, col, attr);
+		col += len;
+	    }
+	    screen_putchar(' ', 0, col++, attr);
+
+	    /* Store the tab page number in TabPageIdxs[], so that
+	     * jump_to_mouse() knows where each one is. */
+	    ++tabcount;
+	    while (scol < col)
+		TabPageIdxs[scol++] = tabcount;
+	}
+
+	if (use_sep_chars)
+	    c = '_';
+	else
+	    c = ' ';
+	screen_fill(0, 1, col, (int)Columns, c, c, attr_fill);
+
+	/* Put an "X" for closing the current tab if there are several. */
+	if (first_tabpage->tp_next != NULL)
+	{
+	    screen_putchar('X', 0, (int)Columns - 1, attr_nosel);
+	    TabPageIdxs[Columns - 1] = -999;
+	}
+    }
+
+    /* Reset the flag here again, in case evaluating 'tabline' causes it to be
+     * set. */
+    redraw_tabline = FALSE;
+}
+
+/*
+ * Get buffer name for "buf" into NameBuff[].
+ * Takes care of special buffer names and translates special characters.
+ */
+    void
+get_trans_bufname(buf_T *buf)
+{
+    if (buf_spname(buf) != NULL)
+	vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);
+    else
+	home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);
+    trans_characters(NameBuff, MAXPATHL);
+}
+
+/*
+ * Get the character to use in a status line.  Get its attributes in "*attr".
+ */
+    static int
+fillchar_status(int *attr, win_T *wp)
+{
+    int fill;
+
+#ifdef FEAT_TERMINAL
+    if (bt_terminal(wp->w_buffer))
+    {
+	if (wp == curwin)
+	{
+	    *attr = HL_ATTR(HLF_ST);
+	    fill = fill_stl;
+	}
+	else
+	{
+	    *attr = HL_ATTR(HLF_STNC);
+	    fill = fill_stlnc;
+	}
+    }
+    else
+#endif
+    if (wp == curwin)
+    {
+	*attr = HL_ATTR(HLF_S);
+	fill = fill_stl;
+    }
+    else
+    {
+	*attr = HL_ATTR(HLF_SNC);
+	fill = fill_stlnc;
+    }
+    /* Use fill when there is highlighting, and highlighting of current
+     * window differs, or the fillchars differ, or this is not the
+     * current window */
+    if (*attr != 0 && ((HL_ATTR(HLF_S) != HL_ATTR(HLF_SNC)
+			|| wp != curwin || ONE_WINDOW)
+		    || (fill_stl != fill_stlnc)))
+	return fill;
+    if (wp == curwin)
+	return '^';
+    return '=';
+}
+
+/*
+ * Get the character to use in a separator between vertically split windows.
+ * Get its attributes in "*attr".
+ */
+    static int
+fillchar_vsep(int *attr)
+{
+    *attr = HL_ATTR(HLF_C);
+    if (*attr == 0 && fill_vert == ' ')
+	return '|';
+    else
+	return fill_vert;
+}
+
+/*
+ * Return TRUE if redrawing should currently be done.
+ */
+    int
+redrawing(void)
+{
+#ifdef FEAT_EVAL
+    if (disable_redraw_for_testing)
+	return 0;
+    else
+#endif
+	return (!RedrawingDisabled
+		       && !(p_lz && char_avail() && !KeyTyped && !do_redraw));
+}
+
+/*
+ * Return TRUE if printing messages should currently be done.
+ */
+    int
+messaging(void)
+{
+    return (!(p_lz && char_avail() && !KeyTyped));
+}
+
+#ifdef FEAT_MENU
+/*
+ * Draw the window toolbar.
+ */
+    static void
+redraw_win_toolbar(win_T *wp)
+{
+    vimmenu_T	*menu;
+    int		item_idx = 0;
+    int		item_count = 0;
+    int		col = 0;
+    int		next_col;
+    int		off = (int)(current_ScreenLine - ScreenLines);
+    int		fill_attr = syn_name2attr((char_u *)"ToolbarLine");
+    int		button_attr = syn_name2attr((char_u *)"ToolbarButton");
+
+    vim_free(wp->w_winbar_items);
+    for (menu = wp->w_winbar->children; menu != NULL; menu = menu->next)
+	++item_count;
+    wp->w_winbar_items = (winbar_item_T *)alloc_clear(
+			   (unsigned)sizeof(winbar_item_T) * (item_count + 1));
+
+    /* TODO: use fewer spaces if there is not enough room */
+    for (menu = wp->w_winbar->children;
+			  menu != NULL && col < wp->w_width; menu = menu->next)
+    {
+	space_to_screenline(off + col, fill_attr);
+	if (++col >= wp->w_width)
+	    break;
+	if (col > 1)
+	{
+	    space_to_screenline(off + col, fill_attr);
+	    if (++col >= wp->w_width)
+		break;
+	}
+
+	wp->w_winbar_items[item_idx].wb_startcol = col;
+	space_to_screenline(off + col, button_attr);
+	if (++col >= wp->w_width)
+	    break;
+
+	next_col = text_to_screenline(wp, menu->name, col);
+	while (col < next_col)
+	{
+	    ScreenAttrs[off + col] = button_attr;
+	    ++col;
+	}
+	wp->w_winbar_items[item_idx].wb_endcol = col;
+	wp->w_winbar_items[item_idx].wb_menu = menu;
+	++item_idx;
+
+	if (col >= wp->w_width)
+	    break;
+	space_to_screenline(off + col, button_attr);
+	++col;
+    }
+    while (col < wp->w_width)
+    {
+	space_to_screenline(off + col, fill_attr);
+	++col;
+    }
+    wp->w_winbar_items[item_idx].wb_menu = NULL; /* end marker */
+
+    screen_line(wp->w_winrow, wp->w_wincol, (int)wp->w_width,
+						     (int)wp->w_width, FALSE);
+}
+#endif
+
+/*
+ * Show current status info in ruler and various other places
+ * If always is FALSE, only show ruler if position has changed.
+ */
+    void
+showruler(int always)
+{
+    if (!always && !redrawing())
+	return;
+#ifdef FEAT_INS_EXPAND
+    if (pum_visible())
+    {
+	/* Don't redraw right now, do it later. */
+	curwin->w_redr_status = TRUE;
+	return;
+    }
+#endif
+#if defined(FEAT_STL_OPT)
+    if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
+    {
+	redraw_custom_statusline(curwin);
+    }
+    else
+#endif
+#ifdef FEAT_CMDL_INFO
+	win_redr_ruler(curwin, always, FALSE);
+#endif
+
+#ifdef FEAT_TITLE
+    if (need_maketitle
+# ifdef FEAT_STL_OPT
+	    || (p_icon && (stl_syntax & STL_IN_ICON))
+	    || (p_title && (stl_syntax & STL_IN_TITLE))
+# endif
+       )
+	maketitle();
+#endif
+    /* Redraw the tab pages line if needed. */
+    if (redraw_tabline)
+	draw_tabline();
+}
+
+#ifdef FEAT_CMDL_INFO
+    static void
+win_redr_ruler(win_T *wp, int always, int ignore_pum)
+{
+#define RULER_BUF_LEN 70
+    char_u	buffer[RULER_BUF_LEN];
+    int		row;
+    int		fillchar;
+    int		attr;
+    int		empty_line = FALSE;
+    colnr_T	virtcol;
+    int		i;
+    size_t	len;
+    int		o;
+    int		this_ru_col;
+    int		off = 0;
+    int		width = Columns;
+
+    /* If 'ruler' off or redrawing disabled, don't do anything */
+    if (!p_ru)
+	return;
+
+    /*
+     * Check if cursor.lnum is valid, since win_redr_ruler() may be called
+     * after deleting lines, before cursor.lnum is corrected.
+     */
+    if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)
+	return;
+
+#ifdef FEAT_INS_EXPAND
+    /* Don't draw the ruler while doing insert-completion, it might overwrite
+     * the (long) mode message. */
+    if (wp == lastwin && lastwin->w_status_height == 0)
+	if (edit_submode != NULL)
+	    return;
+    // Don't draw the ruler when the popup menu is visible, it may overlap.
+    // Except when the popup menu will be redrawn anyway.
+    if (!ignore_pum && pum_visible())
+	return;
+#endif
+
+#ifdef FEAT_STL_OPT
+    if (*p_ruf)
+    {
+	int	save_called_emsg = called_emsg;
+
+	called_emsg = FALSE;
+	win_redr_custom(wp, TRUE);
+	if (called_emsg)
+	    set_string_option_direct((char_u *)"rulerformat", -1,
+					   (char_u *)"", OPT_FREE, SID_ERROR);
+	called_emsg |= save_called_emsg;
+	return;
+    }
+#endif
+
+    /*
+     * Check if not in Insert mode and the line is empty (will show "0-1").
+     */
+    if (!(State & INSERT)
+		&& *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)
+	empty_line = TRUE;
+
+    /*
+     * Only draw the ruler when something changed.
+     */
+    validate_virtcol_win(wp);
+    if (       redraw_cmdline
+	    || always
+	    || wp->w_cursor.lnum != wp->w_ru_cursor.lnum
+	    || wp->w_cursor.col != wp->w_ru_cursor.col
+	    || wp->w_virtcol != wp->w_ru_virtcol
+#ifdef FEAT_VIRTUALEDIT
+	    || wp->w_cursor.coladd != wp->w_ru_cursor.coladd
+#endif
+	    || wp->w_topline != wp->w_ru_topline
+	    || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count
+#ifdef FEAT_DIFF
+	    || wp->w_topfill != wp->w_ru_topfill
+#endif
+	    || empty_line != wp->w_ru_empty)
+    {
+	cursor_off();
+	if (wp->w_status_height)
+	{
+	    row = W_WINROW(wp) + wp->w_height;
+	    fillchar = fillchar_status(&attr, wp);
+	    off = wp->w_wincol;
+	    width = wp->w_width;
+	}
+	else
+	{
+	    row = Rows - 1;
+	    fillchar = ' ';
+	    attr = 0;
+	    width = Columns;
+	    off = 0;
+	}
+
+	/* In list mode virtcol needs to be recomputed */
+	virtcol = wp->w_virtcol;
+	if (wp->w_p_list && lcs_tab1 == NUL)
+	{
+	    wp->w_p_list = FALSE;
+	    getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);
+	    wp->w_p_list = TRUE;
+	}
+
+	/*
+	 * Some sprintfs return the length, some return a pointer.
+	 * To avoid portability problems we use strlen() here.
+	 */
+	vim_snprintf((char *)buffer, RULER_BUF_LEN, "%ld,",
+		(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
+		    ? 0L
+		    : (long)(wp->w_cursor.lnum));
+	len = STRLEN(buffer);
+	col_print(buffer + len, RULER_BUF_LEN - len,
+			empty_line ? 0 : (int)wp->w_cursor.col + 1,
+			(int)virtcol + 1);
+
+	/*
+	 * Add a "50%" if there is room for it.
+	 * On the last line, don't print in the last column (scrolls the
+	 * screen up on some terminals).
+	 */
+	i = (int)STRLEN(buffer);
+	get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
+	o = i + vim_strsize(buffer + i + 1);
+	if (wp->w_status_height == 0)	/* can't use last char of screen */
+	    ++o;
+	this_ru_col = ru_col - (Columns - width);
+	if (this_ru_col < 0)
+	    this_ru_col = 0;
+	/* Never use more than half the window/screen width, leave the other
+	 * half for the filename. */
+	if (this_ru_col < (width + 1) / 2)
+	    this_ru_col = (width + 1) / 2;
+	if (this_ru_col + o < width)
+	{
+	    /* need at least 3 chars left for get_rel_pos() + NUL */
+	    while (this_ru_col + o < width && RULER_BUF_LEN > i + 4)
+	    {
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		    i += (*mb_char2bytes)(fillchar, buffer + i);
+		else
+#endif
+		    buffer[i++] = fillchar;
+		++o;
+	    }
+	    get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);
+	}
+	/* Truncate at window boundary. */
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    o = 0;
+	    for (i = 0; buffer[i] != NUL; i += (*mb_ptr2len)(buffer + i))
+	    {
+		o += (*mb_ptr2cells)(buffer + i);
+		if (this_ru_col + o > width)
+		{
+		    buffer[i] = NUL;
+		    break;
+		}
+	    }
+	}
+	else
+#endif
+	if (this_ru_col + (int)STRLEN(buffer) > width)
+	    buffer[width - this_ru_col] = NUL;
+
+	screen_puts(buffer, row, this_ru_col + off, attr);
+	i = redraw_cmdline;
+	screen_fill(row, row + 1,
+		this_ru_col + off + (int)STRLEN(buffer),
+		(int)(off + width),
+		fillchar, fillchar, attr);
+	/* don't redraw the cmdline because of showing the ruler */
+	redraw_cmdline = i;
+	wp->w_ru_cursor = wp->w_cursor;
+	wp->w_ru_virtcol = wp->w_virtcol;
+	wp->w_ru_empty = empty_line;
+	wp->w_ru_topline = wp->w_topline;
+	wp->w_ru_line_count = wp->w_buffer->b_ml.ml_line_count;
+#ifdef FEAT_DIFF
+	wp->w_ru_topfill = wp->w_topfill;
+#endif
+    }
+}
+#endif
+
+#if defined(FEAT_LINEBREAK) || defined(PROTO)
+/*
+ * Return the width of the 'number' and 'relativenumber' column.
+ * Caller may need to check if 'number' or 'relativenumber' is set.
+ * Otherwise it depends on 'numberwidth' and the line count.
+ */
+    int
+number_width(win_T *wp)
+{
+    int		n;
+    linenr_T	lnum;
+
+    if (wp->w_p_rnu && !wp->w_p_nu)
+	/* cursor line shows "0" */
+	lnum = wp->w_height;
+    else
+	/* cursor line shows absolute line number */
+	lnum = wp->w_buffer->b_ml.ml_line_count;
+
+    if (lnum == wp->w_nrwidth_line_count && wp->w_nuw_cached == wp->w_p_nuw)
+	return wp->w_nrwidth_width;
+    wp->w_nrwidth_line_count = lnum;
+
+    n = 0;
+    do
+    {
+	lnum /= 10;
+	++n;
+    } while (lnum > 0);
+
+    /* 'numberwidth' gives the minimal width plus one */
+    if (n < wp->w_p_nuw - 1)
+	n = wp->w_p_nuw - 1;
+
+    wp->w_nrwidth_width = n;
+    wp->w_nuw_cached = wp->w_p_nuw;
+    return n;
+}
+#endif
+
+/*
+ * Return the current cursor column. This is the actual position on the
+ * screen. First column is 0.
+ */
+    int
+screen_screencol(void)
+{
+    return screen_cur_col;
+}
+
+/*
+ * Return the current cursor row. This is the actual position on the screen.
+ * First row is 0.
+ */
+    int
+screen_screenrow(void)
+{
+    return screen_cur_row;
+}
diff --git a/src/structs.h b/src/structs.h
index ec109eb..8f86265 100644
--- a/src/structs.h
+++ b/src/structs.h
@@ -3143,6 +3143,13 @@ struct VimMenu
     HMENU	submenu_id;	    /* If this is submenu, add children here */
     HWND	tearoff_handle;	    /* hWnd of tearoff if created */
 #endif
+#if FEAT_GUI_HAIKU
+    BMenuItem	*id;		    /* Id of menu item */
+    BMenu	*submenu_id;	    /* If this is submenu, add children here */
+# ifdef FEAT_TOOLBAR
+	BPictureButton *button;
+# endif
+#endif
 #ifdef FEAT_GUI_MAC
 /*  MenuHandle	id; */
 /*  short	index;	*/	    /* the item index within the father menu */
diff --git a/b/src/structs.h.orig b/src/structs.h.orig
new file mode 100644
index 0000000..ec109eb
--- /dev/null
+++ b/src/structs.h.orig
@@ -0,0 +1,3448 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * This file contains various definitions of structures that are used by Vim
+ */
+
+/*
+ * There is something wrong in the SAS compiler that makes typedefs not
+ * valid in include files.  Has been fixed in version 6.58.
+ */
+#if defined(SASC) && SASC < 658
+typedef long		linenr_T;
+typedef int		colnr_T;
+typedef unsigned short	short_u;
+#endif
+
+/*
+ * position in file or buffer
+ */
+typedef struct
+{
+    linenr_T	lnum;	/* line number */
+    colnr_T	col;	/* column number */
+#ifdef FEAT_VIRTUALEDIT
+    colnr_T	coladd;
+#endif
+} pos_T;
+
+#ifdef FEAT_VIRTUALEDIT
+# define INIT_POS_T(l, c, ca) {l, c, ca}
+#else
+# define INIT_POS_T(l, c, ca) {l, c}
+#endif
+
+/*
+ * Same, but without coladd.
+ */
+typedef struct
+{
+    linenr_T	lnum;	/* line number */
+    colnr_T	col;	/* column number */
+} lpos_T;
+
+/*
+ * Structure used for growing arrays.
+ * This is used to store information that only grows, is deleted all at
+ * once, and needs to be accessed by index.  See ga_clear() and ga_grow().
+ */
+typedef struct growarray
+{
+    int	    ga_len;		    /* current number of items used */
+    int	    ga_maxlen;		    /* maximum number of items possible */
+    int	    ga_itemsize;	    /* sizeof(item) */
+    int	    ga_growsize;	    /* number of items to grow each time */
+    void    *ga_data;		    /* pointer to the first item */
+} garray_T;
+
+#define GA_EMPTY    {0, 0, 0, 0, NULL}
+
+typedef struct window_S		win_T;
+typedef struct wininfo_S	wininfo_T;
+typedef struct frame_S		frame_T;
+typedef int			scid_T;		/* script ID */
+typedef struct file_buffer	buf_T;  /* forward declaration */
+typedef struct terminal_S	term_T;
+
+#ifdef FEAT_MENU
+typedef struct VimMenu vimmenu_T;
+#endif
+
+/*
+ * Reference to a buffer that stores the value of buf_free_count.
+ * bufref_valid() only needs to check "buf" when the count differs.
+ */
+typedef struct {
+    buf_T   *br_buf;
+    int	    br_fnum;
+    int	    br_buf_free_count;
+} bufref_T;
+
+/*
+ * This is here because regexp.h needs pos_T and below regprog_T is used.
+ */
+#include "regexp.h"
+
+/*
+ * This is here because gui.h needs the pos_T and win_T, and win_T needs gui.h
+ * for scrollbar_T.
+ */
+#ifdef FEAT_GUI
+# include "gui.h"
+#else
+# ifdef FEAT_XCLIPBOARD
+#  include <X11/Intrinsic.h>
+# endif
+# define guicolor_T long
+# define INVALCOLOR ((guicolor_T)0x1ffffff)
+    /* only used for cterm.bg_rgb and cterm.fg_rgb: use cterm color */
+# define CTERMCOLOR ((guicolor_T)0x1fffffe)
+#endif
+#define COLOR_INVALID(x) ((x) == INVALCOLOR || (x) == CTERMCOLOR)
+
+/*
+ * marks: positions in a file
+ * (a normal mark is a lnum/col pair, the same as a file position)
+ */
+
+/* (Note: for EBCDIC there are more than 26, because there are gaps in the
+ * alphabet coding.  To minimize changes to the code, I decided to just
+ * increase the number of possible marks. */
+#define NMARKS		('z' - 'a' + 1)	/* max. # of named marks */
+#define JUMPLISTSIZE	100		/* max. # of marks in jump list */
+#define TAGSTACKSIZE	20		/* max. # of tags in tag stack */
+
+typedef struct filemark
+{
+    pos_T	mark;		/* cursor position */
+    int		fnum;		/* file number */
+} fmark_T;
+
+/* Xtended file mark: also has a file name */
+typedef struct xfilemark
+{
+    fmark_T	fmark;
+    char_u	*fname;		/* file name, used when fnum == 0 */
+#ifdef FEAT_VIMINFO
+    time_T	time_set;
+#endif
+} xfmark_T;
+
+/*
+ * The taggy struct is used to store the information about a :tag command.
+ */
+typedef struct taggy
+{
+    char_u	*tagname;	/* tag name */
+    fmark_T	fmark;		/* cursor position BEFORE ":tag" */
+    int		cur_match;	/* match number */
+    int		cur_fnum;	/* buffer number used for cur_match */
+} taggy_T;
+
+/*
+ * Structure that contains all options that are local to a window.
+ * Used twice in a window: for the current buffer and for all buffers.
+ * Also used in wininfo_T.
+ */
+typedef struct
+{
+#ifdef FEAT_ARABIC
+    int		wo_arab;
+# define w_p_arab w_onebuf_opt.wo_arab	/* 'arabic' */
+#endif
+#ifdef FEAT_LINEBREAK
+    int		wo_bri;
+# define w_p_bri w_onebuf_opt.wo_bri	/* 'breakindent' */
+    char_u	*wo_briopt;
+# define w_p_briopt w_onebuf_opt.wo_briopt /* 'breakindentopt' */
+#endif
+#ifdef FEAT_DIFF
+    int		wo_diff;
+# define w_p_diff w_onebuf_opt.wo_diff	/* 'diff' */
+#endif
+#ifdef FEAT_FOLDING
+    long	wo_fdc;
+# define w_p_fdc w_onebuf_opt.wo_fdc	/* 'foldcolumn' */
+    int		wo_fdc_save;
+# define w_p_fdc_save w_onebuf_opt.wo_fdc_save	/* 'foldenable' saved for diff mode */
+    int		wo_fen;
+# define w_p_fen w_onebuf_opt.wo_fen	/* 'foldenable' */
+    int		wo_fen_save;
+# define w_p_fen_save w_onebuf_opt.wo_fen_save	/* 'foldenable' saved for diff mode */
+    char_u	*wo_fdi;
+# define w_p_fdi w_onebuf_opt.wo_fdi	/* 'foldignore' */
+    long	wo_fdl;
+# define w_p_fdl w_onebuf_opt.wo_fdl	/* 'foldlevel' */
+    int		wo_fdl_save;
+# define w_p_fdl_save w_onebuf_opt.wo_fdl_save	/* 'foldlevel' state saved for diff mode */
+    char_u	*wo_fdm;
+# define w_p_fdm w_onebuf_opt.wo_fdm	/* 'foldmethod' */
+    char_u	*wo_fdm_save;
+# define w_p_fdm_save w_onebuf_opt.wo_fdm_save	/* 'fdm' saved for diff mode */
+    long	wo_fml;
+# define w_p_fml w_onebuf_opt.wo_fml	/* 'foldminlines' */
+    long	wo_fdn;
+# define w_p_fdn w_onebuf_opt.wo_fdn	/* 'foldnestmax' */
+# ifdef FEAT_EVAL
+    char_u	*wo_fde;
+# define w_p_fde w_onebuf_opt.wo_fde	/* 'foldexpr' */
+    char_u	*wo_fdt;
+#  define w_p_fdt w_onebuf_opt.wo_fdt	/* 'foldtext' */
+# endif
+    char_u	*wo_fmr;
+# define w_p_fmr w_onebuf_opt.wo_fmr	/* 'foldmarker' */
+#endif
+#ifdef FEAT_LINEBREAK
+    int		wo_lbr;
+# define w_p_lbr w_onebuf_opt.wo_lbr	/* 'linebreak' */
+#endif
+    int		wo_list;
+#define w_p_list w_onebuf_opt.wo_list	/* 'list' */
+    int		wo_nu;
+#define w_p_nu w_onebuf_opt.wo_nu	/* 'number' */
+    int		wo_rnu;
+#define w_p_rnu w_onebuf_opt.wo_rnu	/* 'relativenumber' */
+#ifdef FEAT_LINEBREAK
+    long	wo_nuw;
+# define w_p_nuw w_onebuf_opt.wo_nuw	/* 'numberwidth' */
+#endif
+    int		wo_wfh;
+# define w_p_wfh w_onebuf_opt.wo_wfh	/* 'winfixheight' */
+    int		wo_wfw;
+# define w_p_wfw w_onebuf_opt.wo_wfw	/* 'winfixwidth' */
+#if defined(FEAT_QUICKFIX)
+    int		wo_pvw;
+# define w_p_pvw w_onebuf_opt.wo_pvw	/* 'previewwindow' */
+#endif
+#ifdef FEAT_RIGHTLEFT
+    int		wo_rl;
+# define w_p_rl w_onebuf_opt.wo_rl	/* 'rightleft' */
+    char_u	*wo_rlc;
+# define w_p_rlc w_onebuf_opt.wo_rlc	/* 'rightleftcmd' */
+#endif
+    long	wo_scr;
+#define w_p_scr w_onebuf_opt.wo_scr	/* 'scroll' */
+#ifdef FEAT_SPELL
+    int		wo_spell;
+# define w_p_spell w_onebuf_opt.wo_spell /* 'spell' */
+#endif
+#ifdef FEAT_SYN_HL
+    int		wo_cuc;
+# define w_p_cuc w_onebuf_opt.wo_cuc	/* 'cursorcolumn' */
+    int		wo_cul;
+# define w_p_cul w_onebuf_opt.wo_cul	/* 'cursorline' */
+    char_u	*wo_cc;
+# define w_p_cc w_onebuf_opt.wo_cc	/* 'colorcolumn' */
+#endif
+#ifdef FEAT_STL_OPT
+    char_u	*wo_stl;
+#define w_p_stl w_onebuf_opt.wo_stl	/* 'statusline' */
+#endif
+    int		wo_scb;
+#define w_p_scb w_onebuf_opt.wo_scb	/* 'scrollbind' */
+    int		wo_diff_saved; /* options were saved for starting diff mode */
+#define w_p_diff_saved w_onebuf_opt.wo_diff_saved
+    int		wo_scb_save;	/* 'scrollbind' saved for diff mode*/
+#define w_p_scb_save w_onebuf_opt.wo_scb_save
+    int		wo_wrap;
+#define w_p_wrap w_onebuf_opt.wo_wrap	/* 'wrap' */
+#ifdef FEAT_DIFF
+    int		wo_wrap_save;	/* 'wrap' state saved for diff mode*/
+# define w_p_wrap_save w_onebuf_opt.wo_wrap_save
+#endif
+#ifdef FEAT_CONCEAL
+    char_u	*wo_cocu;		/* 'concealcursor' */
+# define w_p_cocu w_onebuf_opt.wo_cocu
+    long	wo_cole;		/* 'conceallevel' */
+# define w_p_cole w_onebuf_opt.wo_cole
+#endif
+    int		wo_crb;
+#define w_p_crb w_onebuf_opt.wo_crb	/* 'cursorbind' */
+    int		wo_crb_save;	/* 'cursorbind' state saved for diff mode*/
+#define w_p_crb_save w_onebuf_opt.wo_crb_save
+#ifdef FEAT_SIGNS
+    char_u	*wo_scl;
+# define w_p_scl w_onebuf_opt.wo_scl	/* 'signcolumn' */
+#endif
+#ifdef FEAT_TERMINAL
+    char_u	*wo_twk;
+# define w_p_twk w_onebuf_opt.wo_twk	/* 'termwinkey' */
+    char_u	*wo_tws;
+# define w_p_tws w_onebuf_opt.wo_tws	/* 'termwinsize' */
+#endif
+
+#ifdef FEAT_EVAL
+    int		wo_scriptID[WV_COUNT];	/* SIDs for window-local options */
+# define w_p_scriptID w_onebuf_opt.wo_scriptID
+#endif
+} winopt_T;
+
+/*
+ * Window info stored with a buffer.
+ *
+ * Two types of info are kept for a buffer which are associated with a
+ * specific window:
+ * 1. Each window can have a different line number associated with a buffer.
+ * 2. The window-local options for a buffer work in a similar way.
+ * The window-info is kept in a list at b_wininfo.  It is kept in
+ * most-recently-used order.
+ */
+struct wininfo_S
+{
+    wininfo_T	*wi_next;	/* next entry or NULL for last entry */
+    wininfo_T	*wi_prev;	/* previous entry or NULL for first entry */
+    win_T	*wi_win;	/* pointer to window that did set wi_fpos */
+    pos_T	wi_fpos;	/* last cursor position in the file */
+    int		wi_optset;	/* TRUE when wi_opt has useful values */
+    winopt_T	wi_opt;		/* local window options */
+#ifdef FEAT_FOLDING
+    int		wi_fold_manual;	/* copy of w_fold_manual */
+    garray_T	wi_folds;	/* clone of w_folds */
+#endif
+};
+
+/*
+ * Info used to pass info about a fold from the fold-detection code to the
+ * code that displays the foldcolumn.
+ */
+typedef struct foldinfo
+{
+    int		fi_level;	/* level of the fold; when this is zero the
+				   other fields are invalid */
+    int		fi_lnum;	/* line number where fold starts */
+    int		fi_low_level;	/* lowest fold level that starts in the same
+				   line */
+} foldinfo_T;
+
+/* Structure to store info about the Visual area. */
+typedef struct
+{
+    pos_T	vi_start;	/* start pos of last VIsual */
+    pos_T	vi_end;		/* end position of last VIsual */
+    int		vi_mode;	/* VIsual_mode of last VIsual */
+    colnr_T	vi_curswant;	/* MAXCOL from w_curswant */
+} visualinfo_T;
+
+/*
+ * structures used for undo
+ */
+
+typedef struct u_entry u_entry_T;
+typedef struct u_header u_header_T;
+struct u_entry
+{
+    u_entry_T	*ue_next;	/* pointer to next entry in list */
+    linenr_T	ue_top;		/* number of line above undo block */
+    linenr_T	ue_bot;		/* number of line below undo block */
+    linenr_T	ue_lcount;	/* linecount when u_save called */
+    char_u	**ue_array;	/* array of lines in undo block */
+    long	ue_size;	/* number of lines in ue_array */
+#ifdef U_DEBUG
+    int		ue_magic;	/* magic number to check allocation */
+#endif
+};
+
+struct u_header
+{
+    /* The following have a pointer and a number. The number is used when
+     * reading the undo file in u_read_undo() */
+    union {
+	u_header_T *ptr;	/* pointer to next undo header in list */
+	long	   seq;
+    } uh_next;
+    union {
+	u_header_T *ptr;	/* pointer to previous header in list */
+	long	   seq;
+    } uh_prev;
+    union {
+	u_header_T *ptr;	/* pointer to next header for alt. redo */
+	long	   seq;
+    } uh_alt_next;
+    union {
+	u_header_T *ptr;	/* pointer to previous header for alt. redo */
+	long	   seq;
+    } uh_alt_prev;
+    long	uh_seq;		/* sequence number, higher == newer undo */
+    int		uh_walk;	/* used by undo_time() */
+    u_entry_T	*uh_entry;	/* pointer to first entry */
+    u_entry_T	*uh_getbot_entry; /* pointer to where ue_bot must be set */
+    pos_T	uh_cursor;	/* cursor position before saving */
+#ifdef FEAT_VIRTUALEDIT
+    long	uh_cursor_vcol;
+#endif
+    int		uh_flags;	/* see below */
+    pos_T	uh_namedm[NMARKS];	/* marks before undo/after redo */
+    visualinfo_T uh_visual;	/* Visual areas before undo/after redo */
+    time_T	uh_time;	/* timestamp when the change was made */
+    long	uh_save_nr;	/* set when the file was saved after the
+				   changes in this block */
+#ifdef U_DEBUG
+    int		uh_magic;	/* magic number to check allocation */
+#endif
+};
+
+/* values for uh_flags */
+#define UH_CHANGED  0x01	/* b_changed flag before undo/after redo */
+#define UH_EMPTYBUF 0x02	/* buffer was empty */
+
+/*
+ * structures used in undo.c
+ */
+#if VIM_SIZEOF_INT > 2
+# define ALIGN_LONG	/* longword alignment and use filler byte */
+# define ALIGN_SIZE (sizeof(long))
+#else
+# define ALIGN_SIZE (sizeof(short))
+#endif
+
+#define ALIGN_MASK (ALIGN_SIZE - 1)
+
+typedef struct m_info minfo_T;
+
+/*
+ * structure used to link chunks in one of the free chunk lists.
+ */
+struct m_info
+{
+#ifdef ALIGN_LONG
+    long_u	m_size;		/* size of the chunk (including m_info) */
+#else
+    short_u	m_size;		/* size of the chunk (including m_info) */
+#endif
+    minfo_T	*m_next;	/* pointer to next free chunk in the list */
+};
+
+/*
+ * things used in memfile.c
+ */
+
+typedef struct block_hdr    bhdr_T;
+typedef struct memfile	    memfile_T;
+typedef long		    blocknr_T;
+
+/*
+ * mf_hashtab_T is a chained hashtable with blocknr_T key and arbitrary
+ * structures as items.  This is an intrusive data structure: we require
+ * that items begin with mf_hashitem_T which contains the key and linked
+ * list pointers.  List of items in each bucket is doubly-linked.
+ */
+
+typedef struct mf_hashitem_S mf_hashitem_T;
+
+struct mf_hashitem_S
+{
+    mf_hashitem_T   *mhi_next;
+    mf_hashitem_T   *mhi_prev;
+    blocknr_T	    mhi_key;
+};
+
+#define MHT_INIT_SIZE   64
+
+typedef struct mf_hashtab_S
+{
+    long_u	    mht_mask;	    /* mask used for hash value (nr of items
+				     * in array is "mht_mask" + 1) */
+    long_u	    mht_count;	    /* nr of items inserted into hashtable */
+    mf_hashitem_T   **mht_buckets;  /* points to mht_small_buckets or
+				     *dynamically allocated array */
+    mf_hashitem_T   *mht_small_buckets[MHT_INIT_SIZE];   /* initial buckets */
+    char	    mht_fixed;	    /* non-zero value forbids growth */
+} mf_hashtab_T;
+
+/*
+ * for each (previously) used block in the memfile there is one block header.
+ *
+ * The block may be linked in the used list OR in the free list.
+ * The used blocks are also kept in hash lists.
+ *
+ * The used list is a doubly linked list, most recently used block first.
+ *	The blocks in the used list have a block of memory allocated.
+ *	mf_used_count is the number of pages in the used list.
+ * The hash lists are used to quickly find a block in the used list.
+ * The free list is a single linked list, not sorted.
+ *	The blocks in the free list have no block of memory allocated and
+ *	the contents of the block in the file (if any) is irrelevant.
+ */
+
+struct block_hdr
+{
+    mf_hashitem_T bh_hashitem;      /* header for hash table and key */
+#define bh_bnum bh_hashitem.mhi_key /* block number, part of bh_hashitem */
+
+    bhdr_T	*bh_next;	    /* next block_hdr in free or used list */
+    bhdr_T	*bh_prev;	    /* previous block_hdr in used list */
+    char_u	*bh_data;	    /* pointer to memory (for used block) */
+    int		bh_page_count;	    /* number of pages in this block */
+
+#define BH_DIRTY    1
+#define BH_LOCKED   2
+    char	bh_flags;	    /* BH_DIRTY or BH_LOCKED */
+};
+
+/*
+ * when a block with a negative number is flushed to the file, it gets
+ * a positive number. Because the reference to the block is still the negative
+ * number, we remember the translation to the new positive number in the
+ * double linked trans lists. The structure is the same as the hash lists.
+ */
+typedef struct nr_trans NR_TRANS;
+
+struct nr_trans
+{
+    mf_hashitem_T nt_hashitem;		/* header for hash table and key */
+#define nt_old_bnum nt_hashitem.mhi_key	/* old, negative, number */
+
+    blocknr_T	nt_new_bnum;		/* new, positive, number */
+};
+
+
+typedef struct buffblock buffblock_T;
+typedef struct buffheader buffheader_T;
+
+/*
+ * structure used to store one block of the stuff/redo/recording buffers
+ */
+struct buffblock
+{
+    buffblock_T	*b_next;	/* pointer to next buffblock */
+    char_u	b_str[1];	/* contents (actually longer) */
+};
+
+/*
+ * header used for the stuff buffer and the redo buffer
+ */
+struct buffheader
+{
+    buffblock_T	bh_first;	/* first (dummy) block of list */
+    buffblock_T	*bh_curr;	/* buffblock for appending */
+    int		bh_index;	/* index for reading */
+    int		bh_space;	/* space in bh_curr for appending */
+};
+
+typedef struct
+{
+    buffheader_T sr_redobuff;
+    buffheader_T sr_old_redobuff;
+} save_redo_T;
+
+/*
+ * used for completion on the command line
+ */
+typedef struct expand
+{
+    int		xp_context;		/* type of expansion */
+    char_u	*xp_pattern;		/* start of item to expand */
+    int		xp_pattern_len;		/* bytes in xp_pattern before cursor */
+#if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
+    char_u	*xp_arg;		/* completion function */
+    int		xp_scriptID;		/* SID for completion function */
+#endif
+    int		xp_backslash;		/* one of the XP_BS_ values */
+#ifndef BACKSLASH_IN_FILENAME
+    int		xp_shell;		/* TRUE for a shell command, more
+					   characters need to be escaped */
+#endif
+    int		xp_numfiles;		/* number of files found by
+						    file name completion */
+    char_u	**xp_files;		/* list of files */
+    char_u	*xp_line;		/* text being completed */
+    int		xp_col;			/* cursor position in line */
+} expand_T;
+
+/* values for xp_backslash */
+#define XP_BS_NONE	0	/* nothing special for backslashes */
+#define XP_BS_ONE	1	/* uses one backslash before a space */
+#define XP_BS_THREE	2	/* uses three backslashes before a space */
+
+/*
+ * Command modifiers ":vertical", ":browse", ":confirm" and ":hide" set a flag.
+ * This needs to be saved for recursive commands, put them in a structure for
+ * easy manipulation.
+ */
+typedef struct
+{
+    int		hide;			/* TRUE when ":hide" was used */
+# ifdef FEAT_BROWSE_CMD
+    int		browse;			/* TRUE to invoke file dialog */
+# endif
+    int		split;			/* flags for win_split() */
+    int		tab;			/* > 0 when ":tab" was used */
+# if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
+    int		confirm;		/* TRUE to invoke yes/no dialog */
+# endif
+    int		keepalt;		/* TRUE when ":keepalt" was used */
+    int		keepmarks;		/* TRUE when ":keepmarks" was used */
+    int		keepjumps;		/* TRUE when ":keepjumps" was used */
+    int		lockmarks;		/* TRUE when ":lockmarks" was used */
+    int		keeppatterns;		/* TRUE when ":keeppatterns" was used */
+    int		noswapfile;		/* TRUE when ":noswapfile" was used */
+    char_u	*save_ei;		/* saved value of 'eventignore' */
+    regmatch_T	filter_regmatch;	/* set by :filter /pat/ */
+    int		filter_force;		/* set for :filter! */
+} cmdmod_T;
+
+#define MF_SEED_LEN	8
+
+struct memfile
+{
+    char_u	*mf_fname;		/* name of the file */
+    char_u	*mf_ffname;		/* idem, full path */
+    int		mf_fd;			/* file descriptor */
+    bhdr_T	*mf_free_first;		/* first block_hdr in free list */
+    bhdr_T	*mf_used_first;		/* mru block_hdr in used list */
+    bhdr_T	*mf_used_last;		/* lru block_hdr in used list */
+    unsigned	mf_used_count;		/* number of pages in used list */
+    unsigned	mf_used_count_max;	/* maximum number of pages in memory */
+    mf_hashtab_T mf_hash;		/* hash lists */
+    mf_hashtab_T mf_trans;		/* trans lists */
+    blocknr_T	mf_blocknr_max;		/* highest positive block number + 1*/
+    blocknr_T	mf_blocknr_min;		/* lowest negative block number - 1 */
+    blocknr_T	mf_neg_count;		/* number of negative blocks numbers */
+    blocknr_T	mf_infile_count;	/* number of pages in the file */
+    unsigned	mf_page_size;		/* number of bytes in a page */
+    int		mf_dirty;		/* TRUE if there are dirty blocks */
+#ifdef FEAT_CRYPT
+    buf_T	*mf_buffer;		/* buffer this memfile is for */
+    char_u	mf_seed[MF_SEED_LEN];	/* seed for encryption */
+
+    /* Values for key, method and seed used for reading data blocks when
+     * updating for a newly set key or method. Only when mf_old_key != NULL. */
+    char_u	*mf_old_key;
+    int		mf_old_cm;
+    char_u	mf_old_seed[MF_SEED_LEN];
+#endif
+};
+
+/*
+ * things used in memline.c
+ */
+/*
+ * When searching for a specific line, we remember what blocks in the tree
+ * are the branches leading to that block. This is stored in ml_stack.  Each
+ * entry is a pointer to info in a block (may be data block or pointer block)
+ */
+typedef struct info_pointer
+{
+    blocknr_T	ip_bnum;	/* block number */
+    linenr_T	ip_low;		/* lowest lnum in this block */
+    linenr_T	ip_high;	/* highest lnum in this block */
+    int		ip_index;	/* index for block with current lnum */
+} infoptr_T;	/* block/index pair */
+
+#ifdef FEAT_BYTEOFF
+typedef struct ml_chunksize
+{
+    int		mlcs_numlines;
+    long	mlcs_totalsize;
+} chunksize_T;
+
+ /* Flags when calling ml_updatechunk() */
+
+#define ML_CHNK_ADDLINE 1
+#define ML_CHNK_DELLINE 2
+#define ML_CHNK_UPDLINE 3
+#endif
+
+/*
+ * the memline structure holds all the information about a memline
+ */
+typedef struct memline
+{
+    linenr_T	ml_line_count;	/* number of lines in the buffer */
+
+    memfile_T	*ml_mfp;	/* pointer to associated memfile */
+
+#define ML_EMPTY	1	/* empty buffer */
+#define ML_LINE_DIRTY	2	/* cached line was changed and allocated */
+#define ML_LOCKED_DIRTY	4	/* ml_locked was changed */
+#define ML_LOCKED_POS	8	/* ml_locked needs positive block number */
+    int		ml_flags;
+
+    infoptr_T	*ml_stack;	/* stack of pointer blocks (array of IPTRs) */
+    int		ml_stack_top;	/* current top of ml_stack */
+    int		ml_stack_size;	/* total number of entries in ml_stack */
+
+    linenr_T	ml_line_lnum;	/* line number of cached line, 0 if not valid */
+    char_u	*ml_line_ptr;	/* pointer to cached line */
+
+    bhdr_T	*ml_locked;	/* block used by last ml_get */
+    linenr_T	ml_locked_low;	/* first line in ml_locked */
+    linenr_T	ml_locked_high;	/* last line in ml_locked */
+    int		ml_locked_lineadd;  /* number of lines inserted in ml_locked */
+#ifdef FEAT_BYTEOFF
+    chunksize_T *ml_chunksize;
+    int		ml_numchunks;
+    int		ml_usedchunks;
+#endif
+} memline_T;
+
+#if defined(FEAT_SIGNS) || defined(PROTO)
+typedef struct signlist signlist_T;
+
+struct signlist
+{
+    int		id;		/* unique identifier for each placed sign */
+    linenr_T	lnum;		/* line number which has this sign */
+    int		typenr;		/* typenr of sign */
+    signlist_T	*next;		/* next signlist entry */
+# ifdef FEAT_NETBEANS_INTG
+    signlist_T  *prev;		/* previous entry -- for easy reordering */
+# endif
+};
+
+/* type argument for buf_getsigntype() */
+#define SIGN_ANY	0
+#define SIGN_LINEHL	1
+#define SIGN_ICON	2
+#define SIGN_TEXT	3
+#endif
+
+/*
+ * Argument list: Array of file names.
+ * Used for the global argument list and the argument lists local to a window.
+ */
+typedef struct arglist
+{
+    garray_T	al_ga;		/* growarray with the array of file names */
+    int		al_refcount;	/* number of windows using this arglist */
+    int		id;		/* id of this arglist */
+} alist_T;
+
+/*
+ * For each argument remember the file name as it was given, and the buffer
+ * number that contains the expanded file name (required for when ":cd" is
+ * used.
+ */
+typedef struct argentry
+{
+    char_u	*ae_fname;	/* file name as specified */
+    int		ae_fnum;	/* buffer number with expanded file name */
+} aentry_T;
+
+#define ALIST(win)	(win)->w_alist
+#define GARGLIST	((aentry_T *)global_alist.al_ga.ga_data)
+#define ARGLIST		((aentry_T *)ALIST(curwin)->al_ga.ga_data)
+#define WARGLIST(wp)	((aentry_T *)ALIST(wp)->al_ga.ga_data)
+#define AARGLIST(al)	((aentry_T *)((al)->al_ga.ga_data))
+#define GARGCOUNT	(global_alist.al_ga.ga_len)
+#define ARGCOUNT	(ALIST(curwin)->al_ga.ga_len)
+#define WARGCOUNT(wp)	(ALIST(wp)->al_ga.ga_len)
+
+/*
+ * A list used for saving values of "emsg_silent".  Used by ex_try() to save the
+ * value of "emsg_silent" if it was non-zero.  When this is done, the CSF_SILENT
+ * flag below is set.
+ */
+
+typedef struct eslist_elem eslist_T;
+struct eslist_elem
+{
+    int		saved_emsg_silent;	/* saved value of "emsg_silent" */
+    eslist_T	*next;			/* next element on the list */
+};
+
+/*
+ * For conditional commands a stack is kept of nested conditionals.
+ * When cs_idx < 0, there is no conditional command.
+ */
+#define CSTACK_LEN	50
+
+struct condstack
+{
+    short	cs_flags[CSTACK_LEN];	/* CSF_ flags */
+    char	cs_pending[CSTACK_LEN];	/* CSTP_: what's pending in ":finally"*/
+    union {
+	void	*csp_rv[CSTACK_LEN];	/* return typeval for pending return */
+	void	*csp_ex[CSTACK_LEN];	/* exception for pending throw */
+    }		cs_pend;
+    void	*cs_forinfo[CSTACK_LEN]; /* info used by ":for" */
+    int		cs_line[CSTACK_LEN];	/* line nr of ":while"/":for" line */
+    int		cs_idx;			/* current entry, or -1 if none */
+    int		cs_looplevel;		/* nr of nested ":while"s and ":for"s */
+    int		cs_trylevel;		/* nr of nested ":try"s */
+    eslist_T	*cs_emsg_silent_list;	/* saved values of "emsg_silent" */
+    char	cs_lflags;		/* loop flags: CSL_ flags */
+};
+# define cs_rettv	cs_pend.csp_rv
+# define cs_exception	cs_pend.csp_ex
+
+/* There is no CSF_IF, the lack of CSF_WHILE, CSF_FOR and CSF_TRY means ":if"
+ * was used. */
+# define CSF_TRUE	0x0001	/* condition was TRUE */
+# define CSF_ACTIVE	0x0002	/* current state is active */
+# define CSF_ELSE	0x0004	/* ":else" has been passed */
+# define CSF_WHILE	0x0008	/* is a ":while" */
+# define CSF_FOR	0x0010	/* is a ":for" */
+
+# define CSF_TRY	0x0100	/* is a ":try" */
+# define CSF_FINALLY	0x0200	/* ":finally" has been passed */
+# define CSF_THROWN	0x0400	/* exception thrown to this try conditional */
+# define CSF_CAUGHT	0x0800  /* exception caught by this try conditional */
+# define CSF_SILENT	0x1000	/* "emsg_silent" reset by ":try" */
+/* Note that CSF_ELSE is only used when CSF_TRY and CSF_WHILE are unset
+ * (an ":if"), and CSF_SILENT is only used when CSF_TRY is set. */
+
+/*
+ * What's pending for being reactivated at the ":endtry" of this try
+ * conditional:
+ */
+# define CSTP_NONE	0	/* nothing pending in ":finally" clause */
+# define CSTP_ERROR	1	/* an error is pending */
+# define CSTP_INTERRUPT	2	/* an interrupt is pending */
+# define CSTP_THROW	4	/* a throw is pending */
+# define CSTP_BREAK	8	/* ":break" is pending */
+# define CSTP_CONTINUE	16	/* ":continue" is pending */
+# define CSTP_RETURN	24	/* ":return" is pending */
+# define CSTP_FINISH	32	/* ":finish" is pending */
+
+/*
+ * Flags for the cs_lflags item in struct condstack.
+ */
+# define CSL_HAD_LOOP	 1	/* just found ":while" or ":for" */
+# define CSL_HAD_ENDLOOP 2	/* just found ":endwhile" or ":endfor" */
+# define CSL_HAD_CONT	 4	/* just found ":continue" */
+# define CSL_HAD_FINA	 8	/* just found ":finally" */
+
+/*
+ * A list of error messages that can be converted to an exception.  "throw_msg"
+ * is only set in the first element of the list.  Usually, it points to the
+ * original message stored in that element, but sometimes it points to a later
+ * message in the list.  See cause_errthrow() below.
+ */
+struct msglist
+{
+    char_u		*msg;		/* original message */
+    char_u		*throw_msg;	/* msg to throw: usually original one */
+    struct msglist	*next;		/* next of several messages in a row */
+};
+
+/*
+ * The exception types.
+ */
+typedef enum
+{
+    ET_USER,		// exception caused by ":throw" command
+    ET_ERROR,		// error exception
+    ET_INTERRUPT,	// interrupt exception triggered by Ctrl-C
+} except_type_T;
+
+/*
+ * Structure describing an exception.
+ * (don't use "struct exception", it's used by the math library).
+ */
+typedef struct vim_exception except_T;
+struct vim_exception
+{
+    except_type_T	type;		/* exception type */
+    char_u		*value;		/* exception value */
+    struct msglist	*messages;	/* message(s) causing error exception */
+    char_u		*throw_name;	/* name of the throw point */
+    linenr_T		throw_lnum;	/* line number of the throw point */
+    except_T		*caught;	/* next exception on the caught stack */
+};
+
+/*
+ * Structure to save the error/interrupt/exception state between calls to
+ * enter_cleanup() and leave_cleanup().  Must be allocated as an automatic
+ * variable by the (common) caller of these functions.
+ */
+typedef struct cleanup_stuff cleanup_T;
+struct cleanup_stuff
+{
+    int pending;		/* error/interrupt/exception state */
+    except_T *exception;	/* exception value */
+};
+
+#ifdef FEAT_SYN_HL
+/* struct passed to in_id_list() */
+struct sp_syn
+{
+    int		inc_tag;	/* ":syn include" unique tag */
+    short	id;		/* highlight group ID of item */
+    short	*cont_in_list;	/* cont.in group IDs, if non-zero */
+};
+
+/*
+ * Each keyword has one keyentry, which is linked in a hash list.
+ */
+typedef struct keyentry keyentry_T;
+
+struct keyentry
+{
+    keyentry_T	*ke_next;	/* next entry with identical "keyword[]" */
+    struct sp_syn k_syn;	/* struct passed to in_id_list() */
+    short	*next_list;	/* ID list for next match (if non-zero) */
+    int		flags;
+    int		k_char;		/* conceal substitute character */
+    char_u	keyword[1];	/* actually longer */
+};
+
+/*
+ * Struct used to store one state of the state stack.
+ */
+typedef struct buf_state
+{
+    int		    bs_idx;	 /* index of pattern */
+    int		    bs_flags;	 /* flags for pattern */
+#ifdef FEAT_CONCEAL
+    int		    bs_seqnr;	 /* stores si_seqnr */
+    int		    bs_cchar;	 /* stores si_cchar */
+#endif
+    reg_extmatch_T *bs_extmatch; /* external matches from start pattern */
+} bufstate_T;
+
+/*
+ * syn_state contains the syntax state stack for the start of one line.
+ * Used by b_sst_array[].
+ */
+typedef struct syn_state synstate_T;
+
+struct syn_state
+{
+    synstate_T	*sst_next;	/* next entry in used or free list */
+    linenr_T	sst_lnum;	/* line number for this state */
+    union
+    {
+	bufstate_T	sst_stack[SST_FIX_STATES]; /* short state stack */
+	garray_T	sst_ga;	/* growarray for long state stack */
+    } sst_union;
+    int		sst_next_flags;	/* flags for sst_next_list */
+    int		sst_stacksize;	/* number of states on the stack */
+    short	*sst_next_list;	/* "nextgroup" list in this state
+				 * (this is a copy, don't free it! */
+    disptick_T	sst_tick;	/* tick when last displayed */
+    linenr_T	sst_change_lnum;/* when non-zero, change in this line
+				 * may have made the state invalid */
+};
+#endif /* FEAT_SYN_HL */
+
+/*
+ * Structure shared between syntax.c, screen.c and gui_x11.c.
+ */
+typedef struct attr_entry
+{
+    short	    ae_attr;		/* HL_BOLD, etc. */
+    union
+    {
+	struct
+	{
+	    char_u	    *start;	/* start escape sequence */
+	    char_u	    *stop;	/* stop escape sequence */
+	} term;
+	struct
+	{
+	    /* These colors need to be > 8 bits to hold 256. */
+	    short_u	    fg_color;	/* foreground color number */
+	    short_u	    bg_color;	/* background color number */
+# ifdef FEAT_TERMGUICOLORS
+	    guicolor_T	    fg_rgb;	/* foreground color RGB */
+	    guicolor_T	    bg_rgb;	/* background color RGB */
+# endif
+	} cterm;
+# ifdef FEAT_GUI
+	struct
+	{
+	    guicolor_T	    fg_color;	/* foreground color handle */
+	    guicolor_T	    bg_color;	/* background color handle */
+	    guicolor_T	    sp_color;	/* special color handle */
+	    GuiFont	    font;	/* font handle */
+#  ifdef FEAT_XFONTSET
+	    GuiFontset	    fontset;	/* fontset handle */
+#  endif
+	} gui;
+# endif
+    } ae_u;
+} attrentry_T;
+
+#ifdef USE_ICONV
+# ifdef HAVE_ICONV_H
+#  include <iconv.h>
+# else
+#  if defined(MACOS_X)
+#   include <sys/errno.h>
+#   ifndef EILSEQ
+#    define EILSEQ ENOENT /* Early MacOS X does not have EILSEQ */
+#   endif
+typedef struct _iconv_t *iconv_t;
+#  else
+#   include <errno.h>
+#  endif
+typedef void *iconv_t;
+# endif
+#endif
+
+/*
+ * Used for the typeahead buffer: typebuf.
+ */
+typedef struct
+{
+    char_u	*tb_buf;	/* buffer for typed characters */
+    char_u	*tb_noremap;	/* mapping flags for characters in tb_buf[] */
+    int		tb_buflen;	/* size of tb_buf[] */
+    int		tb_off;		/* current position in tb_buf[] */
+    int		tb_len;		/* number of valid bytes in tb_buf[] */
+    int		tb_maplen;	/* nr of mapped bytes in tb_buf[] */
+    int		tb_silent;	/* nr of silently mapped bytes in tb_buf[] */
+    int		tb_no_abbr_cnt; /* nr of bytes without abbrev. in tb_buf[] */
+    int		tb_change_cnt;	/* nr of time tb_buf was changed; never zero */
+} typebuf_T;
+
+/* Struct to hold the saved typeahead for save_typeahead(). */
+typedef struct
+{
+    typebuf_T		save_typebuf;
+    int			typebuf_valid;	    /* TRUE when save_typebuf valid */
+    int			old_char;
+    int			old_mod_mask;
+    buffheader_T	save_readbuf1;
+    buffheader_T	save_readbuf2;
+#ifdef USE_INPUT_BUF
+    char_u		*save_inputbuf;
+#endif
+} tasave_T;
+
+/*
+ * Used for conversion of terminal I/O and script files.
+ */
+typedef struct
+{
+    int		vc_type;	/* zero or one of the CONV_ values */
+    int		vc_factor;	/* max. expansion factor */
+# ifdef WIN3264
+    int		vc_cpfrom;	/* codepage to convert from (CONV_CODEPAGE) */
+    int		vc_cpto;	/* codepage to convert to (CONV_CODEPAGE) */
+# endif
+# ifdef USE_ICONV
+    iconv_t	vc_fd;		/* for CONV_ICONV */
+# endif
+    int		vc_fail;	/* fail for invalid char, don't use '?' */
+} vimconv_T;
+
+/*
+ * Structure used for reading from the viminfo file.
+ */
+typedef struct
+{
+    char_u	*vir_line;	/* text of the current line */
+    FILE	*vir_fd;	/* file descriptor */
+#ifdef FEAT_MBYTE
+    vimconv_T	vir_conv;	/* encoding conversion */
+#endif
+    int		vir_version;	/* viminfo version detected or -1 */
+    garray_T	vir_barlines;	/* lines starting with | */
+} vir_T;
+
+#define CONV_NONE		0
+#define CONV_TO_UTF8		1
+#define CONV_9_TO_UTF8		2
+#define CONV_TO_LATIN1		3
+#define CONV_TO_LATIN9		4
+#define CONV_ICONV		5
+#ifdef WIN3264
+# define CONV_CODEPAGE		10	/* codepage -> codepage */
+#endif
+#ifdef MACOS_X
+# define CONV_MAC_LATIN1	20
+# define CONV_LATIN1_MAC	21
+# define CONV_MAC_UTF8		22
+# define CONV_UTF8_MAC		23
+#endif
+
+/*
+ * Structure used for mappings and abbreviations.
+ */
+typedef struct mapblock mapblock_T;
+struct mapblock
+{
+    mapblock_T	*m_next;	/* next mapblock in list */
+    char_u	*m_keys;	/* mapped from, lhs */
+    char_u	*m_str;		/* mapped to, rhs */
+    char_u	*m_orig_str;	/* rhs as entered by the user */
+    int		m_keylen;	/* strlen(m_keys) */
+    int		m_mode;		/* valid mode */
+    int		m_noremap;	/* if non-zero no re-mapping for m_str */
+    char	m_silent;	/* <silent> used, don't echo commands */
+    char	m_nowait;	/* <nowait> used */
+#ifdef FEAT_EVAL
+    char	m_expr;		/* <expr> used, m_str is an expression */
+    scid_T	m_script_ID;	/* ID of script where map was defined */
+#endif
+};
+
+/*
+ * Used for highlighting in the status line.
+ */
+struct stl_hlrec
+{
+    char_u	*start;
+    int		userhl;		/* 0: no HL, 1-9: User HL, < 0 for syn ID */
+};
+
+
+/*
+ * Syntax items - usually buffer-specific.
+ */
+
+/* Item for a hashtable.  "hi_key" can be one of three values:
+ * NULL:	   Never been used
+ * HI_KEY_REMOVED: Entry was removed
+ * Otherwise:	   Used item, pointer to the actual key; this usually is
+ *		   inside the item, subtract an offset to locate the item.
+ *		   This reduces the size of hashitem by 1/3.
+ */
+typedef struct hashitem_S
+{
+    long_u	hi_hash;	/* cached hash number of hi_key */
+    char_u	*hi_key;
+} hashitem_T;
+
+/* The address of "hash_removed" is used as a magic number for hi_key to
+ * indicate a removed item. */
+#define HI_KEY_REMOVED &hash_removed
+#define HASHITEM_EMPTY(hi) ((hi)->hi_key == NULL || (hi)->hi_key == &hash_removed)
+
+/* Initial size for a hashtable.  Our items are relatively small and growing
+ * is expensive, thus use 16 as a start.  Must be a power of 2. */
+#define HT_INIT_SIZE 16
+
+typedef struct hashtable_S
+{
+    long_u	ht_mask;	/* mask used for hash value (nr of items in
+				 * array is "ht_mask" + 1) */
+    long_u	ht_used;	/* number of items used */
+    long_u	ht_filled;	/* number of items used + removed */
+    int		ht_locked;	/* counter for hash_lock() */
+    int		ht_error;	/* when set growing failed, can't add more
+				   items before growing works */
+    hashitem_T	*ht_array;	/* points to the array, allocated when it's
+				   not "ht_smallarray" */
+    hashitem_T	ht_smallarray[HT_INIT_SIZE];   /* initial array */
+} hashtab_T;
+
+typedef long_u hash_T;		/* Type for hi_hash */
+
+
+#ifdef FEAT_NUM64
+/* Use 64-bit Number. */
+# ifdef WIN3264
+#  ifdef PROTO
+typedef long		    varnumber_T;
+typedef unsigned long	    uvarnumber_T;
+#define VARNUM_MIN	    LONG_MIN
+#define VARNUM_MAX	    LONG_MAX
+#define UVARNUM_MAX	    ULONG_MAX
+#  else
+typedef __int64		    varnumber_T;
+typedef unsigned __int64    uvarnumber_T;
+#define VARNUM_MIN	    _I64_MIN
+#define VARNUM_MAX	    _I64_MAX
+#define UVARNUM_MAX	    _UI64_MAX
+#  endif
+# elif defined(HAVE_STDINT_H)
+typedef int64_t		    varnumber_T;
+typedef uint64_t	    uvarnumber_T;
+#define VARNUM_MIN	    INT64_MIN
+#define VARNUM_MAX	    INT64_MAX
+#define UVARNUM_MAX	    UINT64_MAX
+# else
+typedef long		    varnumber_T;
+typedef unsigned long	    uvarnumber_T;
+#define VARNUM_MIN	    LONG_MIN
+#define VARNUM_MAX	    LONG_MAX
+#define UVARNUM_MAX	    ULONG_MAX
+# endif
+#else
+/* Use 32-bit Number. */
+# if VIM_SIZEOF_INT <= 3	/* use long if int is smaller than 32 bits */
+typedef long		    varnumber_T;
+typedef unsigned long	    uvarnumber_T;
+#define VARNUM_MIN	    LONG_MIN
+#define VARNUM_MAX	    LONG_MAX
+#define UVARNUM_MAX	    ULONG_MAX
+# else
+typedef int		    varnumber_T;
+typedef unsigned int	    uvarnumber_T;
+#define VARNUM_MIN	    INT_MIN
+#define VARNUM_MAX	    INT_MAX
+#define UVARNUM_MAX	    UINT_MAX
+# endif
+#endif
+
+typedef double	float_T;
+
+typedef struct listvar_S list_T;
+typedef struct dictvar_S dict_T;
+typedef struct partial_S partial_T;
+
+typedef struct jobvar_S job_T;
+typedef struct readq_S readq_T;
+typedef struct writeq_S writeq_T;
+typedef struct jsonq_S jsonq_T;
+typedef struct cbq_S cbq_T;
+typedef struct channel_S channel_T;
+
+typedef enum
+{
+    VAR_UNKNOWN = 0,
+    VAR_NUMBER,	 // "v_number" is used
+    VAR_STRING,	 // "v_string" is used
+    VAR_FUNC,	 // "v_string" is function name
+    VAR_PARTIAL, // "v_partial" is used
+    VAR_LIST,	 // "v_list" is used
+    VAR_DICT,	 // "v_dict" is used
+    VAR_FLOAT,	 // "v_float" is used
+    VAR_SPECIAL, // "v_number" is used
+    VAR_JOB,	 // "v_job" is used
+    VAR_CHANNEL, // "v_channel" is used
+} vartype_T;
+
+/*
+ * Structure to hold an internal variable without a name.
+ */
+typedef struct
+{
+    vartype_T	v_type;
+    char	v_lock;	    /* see below: VAR_LOCKED, VAR_FIXED */
+    union
+    {
+	varnumber_T	v_number;	/* number value */
+#ifdef FEAT_FLOAT
+	float_T		v_float;	/* floating number value */
+#endif
+	char_u		*v_string;	/* string value (can be NULL!) */
+	list_T		*v_list;	/* list value (can be NULL!) */
+	dict_T		*v_dict;	/* dict value (can be NULL!) */
+	partial_T	*v_partial;	/* closure: function with args */
+#ifdef FEAT_JOB_CHANNEL
+	job_T		*v_job;		/* job value (can be NULL!) */
+	channel_T	*v_channel;	/* channel value (can be NULL!) */
+#endif
+    }		vval;
+} typval_T;
+
+/* Values for "dv_scope". */
+#define VAR_SCOPE     1	/* a:, v:, s:, etc. scope dictionaries */
+#define VAR_DEF_SCOPE 2	/* l:, g: scope dictionaries: here funcrefs are not
+			   allowed to mask existing functions */
+
+/* Values for "v_lock". */
+#define VAR_LOCKED  1	/* locked with lock(), can use unlock() */
+#define VAR_FIXED   2	/* locked forever */
+
+/*
+ * Structure to hold an item of a list: an internal variable without a name.
+ */
+typedef struct listitem_S listitem_T;
+
+struct listitem_S
+{
+    listitem_T	*li_next;	/* next item in list */
+    listitem_T	*li_prev;	/* previous item in list */
+    typval_T	li_tv;		/* type and value of the variable */
+};
+
+/*
+ * Struct used by those that are using an item in a list.
+ */
+typedef struct listwatch_S listwatch_T;
+
+struct listwatch_S
+{
+    listitem_T		*lw_item;	/* item being watched */
+    listwatch_T		*lw_next;	/* next watcher */
+};
+
+/*
+ * Structure to hold info about a list.
+ * Order of members is optimized to reduce padding.
+ */
+struct listvar_S
+{
+    listitem_T	*lv_first;	/* first item, NULL if none */
+    listitem_T	*lv_last;	/* last item, NULL if none */
+    listwatch_T	*lv_watch;	/* first watcher, NULL if none */
+    listitem_T	*lv_idx_item;	/* when not NULL item at index "lv_idx" */
+    list_T	*lv_copylist;	/* copied list used by deepcopy() */
+    list_T	*lv_used_next;	/* next list in used lists list */
+    list_T	*lv_used_prev;	/* previous list in used lists list */
+    int		lv_refcount;	/* reference count */
+    int		lv_len;		/* number of items */
+    int		lv_idx;		/* cached index of an item */
+    int		lv_copyID;	/* ID used by deepcopy() */
+    char	lv_lock;	/* zero, VAR_LOCKED, VAR_FIXED */
+};
+
+/*
+ * Static list with 10 items.  Use init_static_list() to initialize.
+ */
+typedef struct {
+    list_T	sl_list;	/* must be first */
+    listitem_T	sl_items[10];
+} staticList10_T;
+
+/*
+ * Structure to hold an item of a Dictionary.
+ * Also used for a variable.
+ * The key is copied into "di_key" to avoid an extra alloc/free for it.
+ */
+struct dictitem_S
+{
+    typval_T	di_tv;		/* type and value of the variable */
+    char_u	di_flags;	/* flags (only used for variable) */
+    char_u	di_key[1];	/* key (actually longer!) */
+};
+typedef struct dictitem_S dictitem_T;
+
+/* A dictitem with a 16 character key (plus NUL). */
+struct dictitem16_S
+{
+    typval_T	di_tv;		/* type and value of the variable */
+    char_u	di_flags;	/* flags (only used for variable) */
+    char_u	di_key[17];	/* key */
+};
+typedef struct dictitem16_S dictitem16_T;
+
+#define DI_FLAGS_RO	1  /* "di_flags" value: read-only variable */
+#define DI_FLAGS_RO_SBX 2  /* "di_flags" value: read-only in the sandbox */
+#define DI_FLAGS_FIX	4  /* "di_flags" value: fixed: no :unlet or remove() */
+#define DI_FLAGS_LOCK	8  /* "di_flags" value: locked variable */
+#define DI_FLAGS_ALLOC	16 /* "di_flags" value: separately allocated */
+
+/*
+ * Structure to hold info about a Dictionary.
+ */
+struct dictvar_S
+{
+    char	dv_lock;	/* zero, VAR_LOCKED, VAR_FIXED */
+    char	dv_scope;	/* zero, VAR_SCOPE, VAR_DEF_SCOPE */
+    int		dv_refcount;	/* reference count */
+    int		dv_copyID;	/* ID used by deepcopy() */
+    hashtab_T	dv_hashtab;	/* hashtab that refers to the items */
+    dict_T	*dv_copydict;	/* copied dict used by deepcopy() */
+    dict_T	*dv_used_next;	/* next dict in used dicts list */
+    dict_T	*dv_used_prev;	/* previous dict in used dicts list */
+};
+
+#if defined(FEAT_EVAL) || defined(PROTO)
+typedef struct funccall_S funccall_T;
+
+/*
+ * Structure to hold info for a user function.
+ */
+typedef struct
+{
+    int		uf_varargs;	/* variable nr of arguments */
+    int		uf_flags;
+    int		uf_calls;	/* nr of active calls */
+    int		uf_cleared;	/* func_clear() was already called */
+    garray_T	uf_args;	/* arguments */
+    garray_T	uf_lines;	/* function lines */
+#ifdef FEAT_PROFILE
+    int		uf_profiling;	/* TRUE when func is being profiled */
+    int		uf_prof_initialized;
+    /* profiling the function as a whole */
+    int		uf_tm_count;	/* nr of calls */
+    proftime_T	uf_tm_total;	/* time spent in function + children */
+    proftime_T	uf_tm_self;	/* time spent in function itself */
+    proftime_T	uf_tm_children;	/* time spent in children this call */
+    /* profiling the function per line */
+    int		*uf_tml_count;	/* nr of times line was executed */
+    proftime_T	*uf_tml_total;	/* time spent in a line + children */
+    proftime_T	*uf_tml_self;	/* time spent in a line itself */
+    proftime_T	uf_tml_start;	/* start time for current line */
+    proftime_T	uf_tml_children; /* time spent in children for this line */
+    proftime_T	uf_tml_wait;	/* start wait time for current line */
+    int		uf_tml_idx;	/* index of line being timed; -1 if none */
+    int		uf_tml_execed;	/* line being timed was executed */
+#endif
+    scid_T	uf_script_ID;	/* ID of script where function was defined,
+				   used for s: variables */
+    int		uf_refcount;	/* reference count, see func_name_refcount() */
+    funccall_T	*uf_scoped;	/* l: local variables for closure */
+    char_u	uf_name[1];	/* name of function (actually longer); can
+				   start with <SNR>123_ (<SNR> is K_SPECIAL
+				   KS_EXTRA KE_SNR) */
+} ufunc_T;
+
+#define MAX_FUNC_ARGS	20	/* maximum number of function arguments */
+#define VAR_SHORT_LEN	20	/* short variable name length */
+#define FIXVAR_CNT	12	/* number of fixed variables */
+
+/* structure to hold info for a function that is currently being executed. */
+struct funccall_S
+{
+    ufunc_T	*func;		/* function being called */
+    int		linenr;		/* next line to be executed */
+    int		returned;	/* ":return" used */
+    struct			/* fixed variables for arguments */
+    {
+	dictitem_T	var;		/* variable (without room for name) */
+	char_u	room[VAR_SHORT_LEN];	/* room for the name */
+    } fixvar[FIXVAR_CNT];
+    dict_T	l_vars;		/* l: local function variables */
+    dictitem_T	l_vars_var;	/* variable for l: scope */
+    dict_T	l_avars;	/* a: argument variables */
+    dictitem_T	l_avars_var;	/* variable for a: scope */
+    list_T	l_varlist;	/* list for a:000 */
+    listitem_T	l_listitems[MAX_FUNC_ARGS];	/* listitems for a:000 */
+    typval_T	*rettv;		/* return value */
+    linenr_T	breakpoint;	/* next line with breakpoint or zero */
+    int		dbg_tick;	/* debug_tick when breakpoint was set */
+    int		level;		/* top nesting level of executed function */
+#ifdef FEAT_PROFILE
+    proftime_T	prof_child;	/* time spent in a child */
+#endif
+    funccall_T	*caller;	/* calling function or NULL */
+
+    /* for closure */
+    int		fc_refcount;	/* number of user functions that reference this
+				 * funccal */
+    int		fc_copyID;	/* for garbage collection */
+    garray_T	fc_funcs;	/* list of ufunc_T* which keep a reference to
+				 * "func" */
+};
+
+/*
+ * Struct used by trans_function_name()
+ */
+typedef struct
+{
+    dict_T	*fd_dict;	/* Dictionary used */
+    char_u	*fd_newkey;	/* new key in "dict" in allocated memory */
+    dictitem_T	*fd_di;		/* Dictionary item used */
+} funcdict_T;
+
+#else
+/* dummy typedefs for function prototypes */
+typedef struct
+{
+    int	    dummy;
+} ufunc_T;
+typedef struct
+{
+    int	    dummy;
+} funcdict_T;
+#endif
+
+struct partial_S
+{
+    int		pt_refcount;	/* reference count */
+    char_u	*pt_name;	/* function name; when NULL use
+				 * pt_func->uf_name */
+    ufunc_T	*pt_func;	/* function pointer; when NULL lookup function
+				 * with pt_name */
+    int		pt_auto;	/* when TRUE the partial was created for using
+				   dict.member in handle_subscript() */
+    int		pt_argc;	/* number of arguments */
+    typval_T	*pt_argv;	/* arguments in allocated array */
+    dict_T	*pt_dict;	/* dict for "self" */
+};
+
+/* Information returned by get_tty_info(). */
+typedef struct {
+    int backspace;	/* what the Backspace key produces */
+    int enter;		/* what the Enter key produces */
+    int interrupt;	/* interrupt character */
+    int nl_does_cr;	/* TRUE when a NL is expanded to CR-NL on output */
+} ttyinfo_T;
+
+/* Status of a job.  Order matters! */
+typedef enum
+{
+    JOB_FAILED,
+    JOB_STARTED,
+    JOB_ENDED,	    // detected job done
+    JOB_FINISHED,   // job done and cleanup done
+} jobstatus_T;
+
+/*
+ * Structure to hold info about a Job.
+ */
+struct jobvar_S
+{
+    job_T	*jv_next;
+    job_T	*jv_prev;
+#ifdef UNIX
+    pid_t	jv_pid;
+#endif
+#ifdef WIN32
+    PROCESS_INFORMATION	jv_proc_info;
+    HANDLE		jv_job_object;
+#endif
+    char_u	*jv_tty_in;	/* controlling tty input, allocated */
+    char_u	*jv_tty_out;	/* controlling tty output, allocated */
+    jobstatus_T	jv_status;
+    char_u	*jv_stoponexit; /* allocated */
+    int		jv_exitval;
+    char_u	*jv_exit_cb;	/* allocated */
+    partial_T	*jv_exit_partial;
+
+    buf_T	*jv_in_buf;	/* buffer from "in-name" */
+
+    int		jv_refcount;	/* reference count */
+    int		jv_copyID;
+
+    channel_T	*jv_channel;	/* channel for I/O, reference counted */
+    char	**jv_argv;	/* command line used to start the job */
+};
+
+/*
+ * Structures to hold info about a Channel.
+ */
+struct readq_S
+{
+    char_u	*rq_buffer;
+    long_u	rq_buflen;
+    readq_T	*rq_next;
+    readq_T	*rq_prev;
+};
+
+struct writeq_S
+{
+    garray_T	wq_ga;
+    writeq_T	*wq_next;
+    writeq_T	*wq_prev;
+};
+
+struct jsonq_S
+{
+    typval_T	*jq_value;
+    jsonq_T	*jq_next;
+    jsonq_T	*jq_prev;
+    int		jq_no_callback; /* TRUE when no callback was found */
+};
+
+struct cbq_S
+{
+    char_u	*cq_callback;
+    partial_T	*cq_partial;
+    int		cq_seq_nr;
+    cbq_T	*cq_next;
+    cbq_T	*cq_prev;
+};
+
+/* mode for a channel */
+typedef enum
+{
+    MODE_NL = 0,
+    MODE_RAW,
+    MODE_JSON,
+    MODE_JS,
+} ch_mode_T;
+
+typedef enum {
+    JIO_PIPE,	    // default
+    JIO_NULL,
+    JIO_FILE,
+    JIO_BUFFER,
+    JIO_OUT
+} job_io_T;
+
+#define CH_PART_FD(part)	ch_part[part].ch_fd
+
+/* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
+ * are polled. */
+typedef enum {
+    PART_SOCK = 0,
+#define CH_SOCK_FD	CH_PART_FD(PART_SOCK)
+#ifdef FEAT_JOB_CHANNEL
+    PART_OUT,
+# define CH_OUT_FD	CH_PART_FD(PART_OUT)
+    PART_ERR,
+# define CH_ERR_FD	CH_PART_FD(PART_ERR)
+    PART_IN,
+# define CH_IN_FD	CH_PART_FD(PART_IN)
+#endif
+    PART_COUNT,
+} ch_part_T;
+
+#define INVALID_FD	(-1)
+
+/* The per-fd info for a channel. */
+typedef struct {
+    sock_T	ch_fd;	    /* socket/stdin/stdout/stderr, -1 if not used */
+
+# if defined(UNIX) && !defined(HAVE_SELECT)
+    int		ch_poll_idx;	/* used by channel_poll_setup() */
+# endif
+
+#ifdef FEAT_GUI_X11
+    XtInputId	ch_inputHandler; /* Cookie for input */
+#endif
+#ifdef FEAT_GUI_GTK
+    gint	ch_inputHandler; /* Cookie for input */
+#endif
+
+    ch_mode_T	ch_mode;
+    job_io_T	ch_io;
+    int		ch_timeout;	/* request timeout in msec */
+
+    readq_T	ch_head;	/* header for circular raw read queue */
+    jsonq_T	ch_json_head;	/* header for circular json read queue */
+    int		ch_block_id;	/* ID that channel_read_json_block() is
+				   waiting for */
+    /* When ch_wait_len is non-zero use ch_deadline to wait for incomplete
+     * message to be complete. The value is the length of the incomplete
+     * message when the deadline was set.  If it gets longer (something was
+     * received) the deadline is reset. */
+    size_t	ch_wait_len;
+#ifdef WIN32
+    DWORD	ch_deadline;
+#else
+    struct timeval ch_deadline;
+#endif
+    int		ch_block_write;	/* for testing: 0 when not used, -1 when write
+				 * does not block, 1 simulate blocking */
+    int		ch_nonblocking;	/* write() is non-blocking */
+    writeq_T	ch_writeque;	/* header for write queue */
+
+    cbq_T	ch_cb_head;	/* dummy node for per-request callbacks */
+    char_u	*ch_callback;	/* call when a msg is not handled */
+    partial_T	*ch_partial;
+
+    bufref_T	ch_bufref;	/* buffer to read from or write to */
+    int		ch_nomodifiable; /* TRUE when buffer can be 'nomodifiable' */
+    int		ch_nomod_error;	/* TRUE when e_modifiable was given */
+    int		ch_buf_append;	/* write appended lines instead top-bot */
+    linenr_T	ch_buf_top;	/* next line to send */
+    linenr_T	ch_buf_bot;	/* last line to send */
+} chanpart_T;
+
+struct channel_S {
+    channel_T	*ch_next;
+    channel_T	*ch_prev;
+
+    int		ch_id;		/* ID of the channel */
+    int		ch_last_msg_id;	/* ID of the last message */
+
+    chanpart_T	ch_part[PART_COUNT]; /* info for socket, out, err and in */
+    int		ch_write_text_mode; /* write buffer lines with CR, not NL */
+
+    char	*ch_hostname;	/* only for socket, allocated */
+    int		ch_port;	/* only for socket */
+
+    int		ch_to_be_closed; /* bitset of readable fds to be closed.
+				  * When all readable fds have been closed,
+				  * set to (1 << PART_COUNT). */
+    int		ch_to_be_freed; /* When TRUE channel must be freed when it's
+				 * safe to invoke callbacks. */
+    int		ch_error;	/* When TRUE an error was reported.  Avoids
+				 * giving pages full of error messages when
+				 * the other side has exited, only mention the
+				 * first error until the connection works
+				 * again. */
+
+    void	(*ch_nb_close_cb)(void);
+				/* callback for Netbeans when channel is
+				 * closed */
+
+#ifdef WIN32
+    int		ch_named_pipe;	/* using named pipe instead of pty */
+#endif
+    char_u	*ch_callback;	/* call when any msg is not handled */
+    partial_T	*ch_partial;
+    char_u	*ch_close_cb;	/* call when channel is closed */
+    partial_T	*ch_close_partial;
+    int		ch_drop_never;
+    int		ch_keep_open;	/* do not close on read error */
+
+    job_T	*ch_job;	/* Job that uses this channel; this does not
+				 * count as a reference to avoid a circular
+				 * reference, the job refers to the channel. */
+    int		ch_job_killed;	/* TRUE when there was a job and it was killed
+				 * or we know it died. */
+
+    int		ch_refcount;	/* reference count */
+    int		ch_copyID;
+};
+
+#define JO_MODE		    0x0001	/* channel mode */
+#define JO_IN_MODE	    0x0002	/* stdin mode */
+#define JO_OUT_MODE	    0x0004	/* stdout mode */
+#define JO_ERR_MODE	    0x0008	/* stderr mode */
+#define JO_CALLBACK	    0x0010	/* channel callback */
+#define JO_OUT_CALLBACK	    0x0020	/* stdout callback */
+#define JO_ERR_CALLBACK	    0x0040	/* stderr callback */
+#define JO_CLOSE_CALLBACK   0x0080	/* "close_cb" */
+#define JO_WAITTIME	    0x0100	/* only for ch_open() */
+#define JO_TIMEOUT	    0x0200	/* all timeouts */
+#define JO_OUT_TIMEOUT	    0x0400	/* stdout timeouts */
+#define JO_ERR_TIMEOUT	    0x0800	/* stderr timeouts */
+#define JO_PART		    0x1000	/* "part" */
+#define JO_ID		    0x2000	/* "id" */
+#define JO_STOPONEXIT	    0x4000	/* "stoponexit" */
+#define JO_EXIT_CB	    0x8000	/* "exit_cb" */
+#define JO_OUT_IO	    0x10000	/* "out_io" */
+#define JO_ERR_IO	    0x20000	/* "err_io" (JO_OUT_IO << 1) */
+#define JO_IN_IO	    0x40000	/* "in_io" (JO_OUT_IO << 2) */
+#define JO_OUT_NAME	    0x80000	/* "out_name" */
+#define JO_ERR_NAME	    0x100000	/* "err_name" (JO_OUT_NAME << 1) */
+#define JO_IN_NAME	    0x200000	/* "in_name" (JO_OUT_NAME << 2) */
+#define JO_IN_TOP	    0x400000	/* "in_top" */
+#define JO_IN_BOT	    0x800000	/* "in_bot" */
+#define JO_OUT_BUF	    0x1000000	/* "out_buf" */
+#define JO_ERR_BUF	    0x2000000	/* "err_buf" (JO_OUT_BUF << 1) */
+#define JO_IN_BUF	    0x4000000	/* "in_buf" (JO_OUT_BUF << 2) */
+#define JO_CHANNEL	    0x8000000	/* "channel" */
+#define JO_BLOCK_WRITE	    0x10000000	/* "block_write" */
+#define JO_OUT_MODIFIABLE   0x20000000	/* "out_modifiable" */
+#define JO_ERR_MODIFIABLE   0x40000000	/* "err_modifiable" (JO_OUT_ << 1) */
+#define JO_ALL		    0x7fffffff
+
+#define JO2_OUT_MSG	    0x0001	/* "out_msg" */
+#define JO2_ERR_MSG	    0x0002	/* "err_msg" (JO_OUT_ << 1) */
+#define JO2_TERM_NAME	    0x0004	/* "term_name" */
+#define JO2_TERM_FINISH	    0x0008	/* "term_finish" */
+#define JO2_ENV		    0x0010	/* "env" */
+#define JO2_CWD		    0x0020	/* "cwd" */
+#define JO2_TERM_ROWS	    0x0040	/* "term_rows" */
+#define JO2_TERM_COLS	    0x0080	/* "term_cols" */
+#define JO2_VERTICAL	    0x0100	/* "vertical" */
+#define JO2_CURWIN	    0x0200	/* "curwin" */
+#define JO2_HIDDEN	    0x0400	/* "hidden" */
+#define JO2_TERM_OPENCMD    0x0800	/* "term_opencmd" */
+#define JO2_EOF_CHARS	    0x1000	/* "eof_chars" */
+#define JO2_NORESTORE	    0x2000	/* "norestore" */
+#define JO2_TERM_KILL	    0x4000	/* "term_kill" */
+#define JO2_ANSI_COLORS	    0x8000	/* "ansi_colors" */
+
+#define JO_MODE_ALL	(JO_MODE + JO_IN_MODE + JO_OUT_MODE + JO_ERR_MODE)
+#define JO_CB_ALL \
+    (JO_CALLBACK + JO_OUT_CALLBACK + JO_ERR_CALLBACK + JO_CLOSE_CALLBACK)
+#define JO_TIMEOUT_ALL	(JO_TIMEOUT + JO_OUT_TIMEOUT + JO_ERR_TIMEOUT)
+
+/*
+ * Options for job and channel commands.
+ */
+typedef struct
+{
+    int		jo_set;		/* JO_ bits for values that were set */
+    int		jo_set2;	/* JO2_ bits for values that were set */
+
+    ch_mode_T	jo_mode;
+    ch_mode_T	jo_in_mode;
+    ch_mode_T	jo_out_mode;
+    ch_mode_T	jo_err_mode;
+
+    job_io_T	jo_io[4];	/* PART_OUT, PART_ERR, PART_IN */
+    char_u	jo_io_name_buf[4][NUMBUFLEN];
+    char_u	*jo_io_name[4];	/* not allocated! */
+    int		jo_io_buf[4];
+    int		jo_pty;
+    int		jo_modifiable[4];
+    int		jo_message[4];
+    channel_T	*jo_channel;
+
+    linenr_T	jo_in_top;
+    linenr_T	jo_in_bot;
+
+    char_u	*jo_callback;	/* not allocated! */
+    partial_T	*jo_partial;	/* not referenced! */
+    char_u	*jo_out_cb;	/* not allocated! */
+    partial_T	*jo_out_partial; /* not referenced! */
+    char_u	*jo_err_cb;	/* not allocated! */
+    partial_T	*jo_err_partial; /* not referenced! */
+    char_u	*jo_close_cb;	/* not allocated! */
+    partial_T	*jo_close_partial; /* not referenced! */
+    char_u	*jo_exit_cb;	/* not allocated! */
+    partial_T	*jo_exit_partial; /* not referenced! */
+    int		jo_drop_never;
+    int		jo_waittime;
+    int		jo_timeout;
+    int		jo_out_timeout;
+    int		jo_err_timeout;
+    int		jo_block_write;	/* for testing only */
+    int		jo_part;
+    int		jo_id;
+    char_u	jo_soe_buf[NUMBUFLEN];
+    char_u	*jo_stoponexit;
+    dict_T	*jo_env;	/* environment variables */
+    char_u	jo_cwd_buf[NUMBUFLEN];
+    char_u	*jo_cwd;
+
+#ifdef FEAT_TERMINAL
+    /* when non-zero run the job in a terminal window of this size */
+    int		jo_term_rows;
+    int		jo_term_cols;
+    int		jo_vertical;
+    int		jo_curwin;
+    int		jo_hidden;
+    int		jo_term_norestore;
+    char_u	*jo_term_name;
+    char_u	*jo_term_opencmd;
+    int		jo_term_finish;
+    char_u	*jo_eof_chars;
+    char_u	*jo_term_kill;
+# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)
+    long_u	jo_ansi_colors[16];
+# endif
+#endif
+} jobopt_T;
+
+
+/* structure used for explicit stack while garbage collecting hash tables */
+typedef struct ht_stack_S
+{
+    hashtab_T		*ht;
+    struct ht_stack_S	*prev;
+} ht_stack_T;
+
+/* structure used for explicit stack while garbage collecting lists */
+typedef struct list_stack_S
+{
+    list_T		*list;
+    struct list_stack_S	*prev;
+} list_stack_T;
+
+/* values for b_syn_spell: what to do with toplevel text */
+#define SYNSPL_DEFAULT	0	/* spell check if @Spell not defined */
+#define SYNSPL_TOP	1	/* spell check toplevel text */
+#define SYNSPL_NOTOP	2	/* don't spell check toplevel text */
+
+/* avoid #ifdefs for when b_spell is not available */
+#ifdef FEAT_SPELL
+# define B_SPELL(buf)  ((buf)->b_spell)
+#else
+# define B_SPELL(buf)  (0)
+#endif
+
+#ifdef FEAT_QUICKFIX
+typedef struct qf_info_S qf_info_T;
+#endif
+
+#ifdef FEAT_PROFILE
+/*
+ * Used for :syntime: timing of executing a syntax pattern.
+ */
+typedef struct {
+    proftime_T	total;		/* total time used */
+    proftime_T	slowest;	/* time of slowest call */
+    long	count;		/* nr of times used */
+    long	match;		/* nr of times matched */
+} syn_time_T;
+#endif
+
+#ifdef FEAT_CRYPT
+/*
+ * Structure to hold the type of encryption and the state of encryption or
+ * decryption.
+ */
+typedef struct {
+    int	    method_nr;
+    void    *method_state;  /* method-specific state information */
+} cryptstate_T;
+
+/* values for method_nr */
+# define CRYPT_M_ZIP	0
+# define CRYPT_M_BF	1
+# define CRYPT_M_BF2	2
+# define CRYPT_M_COUNT	3 /* number of crypt methods */
+#endif
+
+
+/*
+ * These are items normally related to a buffer.  But when using ":ownsyntax"
+ * a window may have its own instance.
+ */
+typedef struct {
+#ifdef FEAT_SYN_HL
+    hashtab_T	b_keywtab;		/* syntax keywords hash table */
+    hashtab_T	b_keywtab_ic;		/* idem, ignore case */
+    int		b_syn_error;		/* TRUE when error occurred in HL */
+# ifdef FEAT_RELTIME
+    int		b_syn_slow;		/* TRUE when 'redrawtime' reached */
+# endif
+    int		b_syn_ic;		/* ignore case for :syn cmds */
+    int		b_syn_spell;		/* SYNSPL_ values */
+    garray_T	b_syn_patterns;		/* table for syntax patterns */
+    garray_T	b_syn_clusters;		/* table for syntax clusters */
+    int		b_spell_cluster_id;	/* @Spell cluster ID or 0 */
+    int		b_nospell_cluster_id;	/* @NoSpell cluster ID or 0 */
+    int		b_syn_containedin;	/* TRUE when there is an item with a
+					   "containedin" argument */
+    int		b_syn_sync_flags;	/* flags about how to sync */
+    short	b_syn_sync_id;		/* group to sync on */
+    long	b_syn_sync_minlines;	/* minimal sync lines offset */
+    long	b_syn_sync_maxlines;	/* maximal sync lines offset */
+    long	b_syn_sync_linebreaks;	/* offset for multi-line pattern */
+    char_u	*b_syn_linecont_pat;	/* line continuation pattern */
+    regprog_T	*b_syn_linecont_prog;	/* line continuation program */
+#ifdef FEAT_PROFILE
+    syn_time_T  b_syn_linecont_time;
+#endif
+    int		b_syn_linecont_ic;	/* ignore-case flag for above */
+    int		b_syn_topgrp;		/* for ":syntax include" */
+# ifdef FEAT_CONCEAL
+    int		b_syn_conceal;		/* auto-conceal for :syn cmds */
+# endif
+# ifdef FEAT_FOLDING
+    int		b_syn_folditems;	/* number of patterns with the HL_FOLD
+					   flag set */
+# endif
+    /*
+     * b_sst_array[] contains the state stack for a number of lines, for the
+     * start of that line (col == 0).  This avoids having to recompute the
+     * syntax state too often.
+     * b_sst_array[] is allocated to hold the state for all displayed lines,
+     * and states for 1 out of about 20 other lines.
+     * b_sst_array	pointer to an array of synstate_T
+     * b_sst_len	number of entries in b_sst_array[]
+     * b_sst_first	pointer to first used entry in b_sst_array[] or NULL
+     * b_sst_firstfree	pointer to first free entry in b_sst_array[] or NULL
+     * b_sst_freecount	number of free entries in b_sst_array[]
+     * b_sst_check_lnum	entries after this lnum need to be checked for
+     *			validity (MAXLNUM means no check needed)
+     */
+    synstate_T	*b_sst_array;
+    int		b_sst_len;
+    synstate_T	*b_sst_first;
+    synstate_T	*b_sst_firstfree;
+    int		b_sst_freecount;
+    linenr_T	b_sst_check_lnum;
+    short_u	b_sst_lasttick;	/* last display tick */
+#endif /* FEAT_SYN_HL */
+
+#ifdef FEAT_SPELL
+    /* for spell checking */
+    garray_T	b_langp;	/* list of pointers to slang_T, see spell.c */
+    char_u	b_spell_ismw[256];/* flags: is midword char */
+# ifdef FEAT_MBYTE
+    char_u	*b_spell_ismw_mb; /* multi-byte midword chars */
+# endif
+    char_u	*b_p_spc;	/* 'spellcapcheck' */
+    regprog_T	*b_cap_prog;	/* program for 'spellcapcheck' */
+    char_u	*b_p_spf;	/* 'spellfile' */
+    char_u	*b_p_spl;	/* 'spelllang' */
+# ifdef FEAT_MBYTE
+    int		b_cjk;		/* all CJK letters as OK */
+# endif
+#endif
+#if !defined(FEAT_SYN_HL) && !defined(FEAT_SPELL)
+    int		dummy;
+#endif
+    char_u	b_syn_chartab[32];	/* syntax iskeyword option */
+    char_u	*b_syn_isk;		/* iskeyword option */
+} synblock_T;
+
+
+/*
+ * buffer: structure that holds information about one file
+ *
+ * Several windows can share a single Buffer
+ * A buffer is unallocated if there is no memfile for it.
+ * A buffer is new if the associated file has never been loaded yet.
+ */
+
+struct file_buffer
+{
+    memline_T	b_ml;		/* associated memline (also contains line
+				   count) */
+
+    buf_T	*b_next;	/* links in list of buffers */
+    buf_T	*b_prev;
+
+    int		b_nwindows;	/* nr of windows open on this buffer */
+
+    int		b_flags;	/* various BF_ flags */
+    int		b_locked;	/* Buffer is being closed or referenced, don't
+				   let autocommands wipe it out. */
+
+    /*
+     * b_ffname has the full path of the file (NULL for no name).
+     * b_sfname is the name as the user typed it (or NULL).
+     * b_fname is the same as b_sfname, unless ":cd" has been done,
+     *		then it is the same as b_ffname (NULL for no name).
+     */
+    char_u	*b_ffname;	/* full path file name */
+    char_u	*b_sfname;	/* short file name */
+    char_u	*b_fname;	/* current file name */
+
+#ifdef UNIX
+    int		b_dev_valid;	/* TRUE when b_dev has a valid number */
+    dev_t	b_dev;		/* device number */
+    ino_t	b_ino;		/* inode number */
+#endif
+#ifdef FEAT_CW_EDITOR
+    FSSpec	b_FSSpec;	/* MacOS File Identification */
+#endif
+#ifdef VMS
+    char	 b_fab_rfm;	/* Record format    */
+    char	 b_fab_rat;	/* Record attribute */
+    unsigned int b_fab_mrs;	/* Max record size  */
+#endif
+    int		b_fnum;		/* buffer number for this file. */
+    char_u	b_key[VIM_SIZEOF_INT * 2 + 1];
+				/* key used for buf_hashtab, holds b_fnum as
+				   hex string */
+
+    int		b_changed;	/* 'modified': Set to TRUE if something in the
+				   file has been changed and not written out. */
+    dictitem16_T b_ct_di;	/* holds the b:changedtick value in
+				   b_ct_di.di_tv.vval.v_number;
+				   incremented for each change, also for undo */
+#define CHANGEDTICK(buf) ((buf)->b_ct_di.di_tv.vval.v_number)
+
+    varnumber_T	b_last_changedtick; /* b:changedtick when TextChanged or
+				       TextChangedI was last triggered. */
+#ifdef FEAT_INS_EXPAND
+    varnumber_T	b_last_changedtick_pum; /* b:changedtick when TextChangedP was
+					   last triggered. */
+#endif
+
+    int		b_saving;	/* Set to TRUE if we are in the middle of
+				   saving the buffer. */
+
+    /*
+     * Changes to a buffer require updating of the display.  To minimize the
+     * work, remember changes made and update everything at once.
+     */
+    int		b_mod_set;	/* TRUE when there are changes since the last
+				   time the display was updated */
+    linenr_T	b_mod_top;	/* topmost lnum that was changed */
+    linenr_T	b_mod_bot;	/* lnum below last changed line, AFTER the
+				   change */
+    long	b_mod_xlines;	/* number of extra buffer lines inserted;
+				   negative when lines were deleted */
+
+    wininfo_T	*b_wininfo;	/* list of last used info for each window */
+
+    long	b_mtime;	/* last change time of original file */
+    long	b_mtime_read;	/* last change time when reading */
+    off_T	b_orig_size;	/* size of original file in bytes */
+    int		b_orig_mode;	/* mode of original file */
+#ifdef FEAT_VIMINFO
+    time_T	b_last_used;	/* time when the buffer was last used; used
+				 * for viminfo */
+#endif
+
+    pos_T	b_namedm[NMARKS]; /* current named marks (mark.c) */
+
+    /* These variables are set when VIsual_active becomes FALSE */
+    visualinfo_T b_visual;
+#ifdef FEAT_EVAL
+    int		b_visual_mode_eval;  /* b_visual.vi_mode for visualmode() */
+#endif
+
+    pos_T	b_last_cursor;	/* cursor position when last unloading this
+				   buffer */
+    pos_T	b_last_insert;	/* where Insert mode was left */
+    pos_T	b_last_change;	/* position of last change: '. mark */
+
+#ifdef FEAT_JUMPLIST
+    /*
+     * the changelist contains old change positions
+     */
+    pos_T	b_changelist[JUMPLISTSIZE];
+    int		b_changelistlen;	/* number of active entries */
+    int		b_new_change;		/* set by u_savecommon() */
+#endif
+
+    /*
+     * Character table, only used in charset.c for 'iskeyword'
+     * 32 bytes of 8 bits: 1 bit per character 0-255.
+     */
+    char_u	b_chartab[32];
+
+#ifdef FEAT_LOCALMAP
+    /* Table used for mappings local to a buffer. */
+    mapblock_T	*(b_maphash[256]);
+
+    /* First abbreviation local to a buffer. */
+    mapblock_T	*b_first_abbr;
+#endif
+#ifdef FEAT_USR_CMDS
+    /* User commands local to the buffer. */
+    garray_T	b_ucmds;
+#endif
+    /*
+     * start and end of an operator, also used for '[ and ']
+     */
+    pos_T	b_op_start;
+    pos_T	b_op_start_orig;  /* used for Insstart_orig */
+    pos_T	b_op_end;
+
+#ifdef FEAT_VIMINFO
+    int		b_marks_read;	/* Have we read viminfo marks yet? */
+#endif
+
+    /*
+     * The following only used in undo.c.
+     */
+    u_header_T	*b_u_oldhead;	/* pointer to oldest header */
+    u_header_T	*b_u_newhead;	/* pointer to newest header; may not be valid
+				   if b_u_curhead is not NULL */
+    u_header_T	*b_u_curhead;	/* pointer to current header */
+    int		b_u_numhead;	/* current number of headers */
+    int		b_u_synced;	/* entry lists are synced */
+    long	b_u_seq_last;	/* last used undo sequence number */
+    long	b_u_save_nr_last; /* counter for last file write */
+    long	b_u_seq_cur;	/* hu_seq of header below which we are now */
+    time_T	b_u_time_cur;	/* uh_time of header below which we are now */
+    long	b_u_save_nr_cur; /* file write nr after which we are now */
+
+    /*
+     * variables for "U" command in undo.c
+     */
+    char_u	*b_u_line_ptr;	/* saved line for "U" command */
+    linenr_T	b_u_line_lnum;	/* line number of line in u_line */
+    colnr_T	b_u_line_colnr;	/* optional column number */
+
+#ifdef FEAT_INS_EXPAND
+    int		b_scanned;	/* ^N/^P have scanned this buffer */
+#endif
+
+    /* flags for use of ":lmap" and IM control */
+    long	b_p_iminsert;	/* input mode for insert */
+    long	b_p_imsearch;	/* input mode for search */
+#define B_IMODE_USE_INSERT -1	/*	Use b_p_iminsert value for search */
+#define B_IMODE_NONE 0		/*	Input via none */
+#define B_IMODE_LMAP 1		/*	Input via langmap */
+#define B_IMODE_IM 2		/*	Input via input method */
+#define B_IMODE_LAST 2
+
+#ifdef FEAT_KEYMAP
+    short	b_kmap_state;	/* using "lmap" mappings */
+# define KEYMAP_INIT	1	/* 'keymap' was set, call keymap_init() */
+# define KEYMAP_LOADED	2	/* 'keymap' mappings have been loaded */
+    garray_T	b_kmap_ga;	/* the keymap table */
+#endif
+
+    /*
+     * Options local to a buffer.
+     * They are here because their value depends on the type of file
+     * or contents of the file being edited.
+     */
+    int		b_p_initialized;	/* set when options initialized */
+
+#ifdef FEAT_EVAL
+    int		b_p_scriptID[BV_COUNT];	/* SIDs for buffer-local options */
+#endif
+
+    int		b_p_ai;		/* 'autoindent' */
+    int		b_p_ai_nopaste;	/* b_p_ai saved for paste mode */
+    char_u	*b_p_bkc;	/* 'backupcopy' */
+    unsigned	b_bkc_flags;    /* flags for 'backupcopy' */
+    int		b_p_ci;		/* 'copyindent' */
+    int		b_p_bin;	/* 'binary' */
+#ifdef FEAT_MBYTE
+    int		b_p_bomb;	/* 'bomb' */
+#endif
+    char_u	*b_p_bh;	/* 'bufhidden' */
+    char_u	*b_p_bt;	/* 'buftype' */
+#ifdef FEAT_QUICKFIX
+#define BUF_HAS_QF_ENTRY 1
+#define BUF_HAS_LL_ENTRY 2
+    int		b_has_qf_entry;
+#endif
+    int		b_p_bl;		/* 'buflisted' */
+#ifdef FEAT_CINDENT
+    int		b_p_cin;	/* 'cindent' */
+    char_u	*b_p_cino;	/* 'cinoptions' */
+    char_u	*b_p_cink;	/* 'cinkeys' */
+#endif
+#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
+    char_u	*b_p_cinw;	/* 'cinwords' */
+#endif
+#ifdef FEAT_COMMENTS
+    char_u	*b_p_com;	/* 'comments' */
+#endif
+#ifdef FEAT_FOLDING
+    char_u	*b_p_cms;	/* 'commentstring' */
+#endif
+#ifdef FEAT_INS_EXPAND
+    char_u	*b_p_cpt;	/* 'complete' */
+#endif
+#ifdef FEAT_COMPL_FUNC
+    char_u	*b_p_cfu;	/* 'completefunc' */
+    char_u	*b_p_ofu;	/* 'omnifunc' */
+#endif
+    int		b_p_eol;	/* 'endofline' */
+    int		b_p_fixeol;	/* 'fixendofline' */
+    int		b_p_et;		/* 'expandtab' */
+    int		b_p_et_nobin;	/* b_p_et saved for binary mode */
+    int	        b_p_et_nopaste; /* b_p_et saved for paste mode */
+#ifdef FEAT_MBYTE
+    char_u	*b_p_fenc;	/* 'fileencoding' */
+#endif
+    char_u	*b_p_ff;	/* 'fileformat' */
+    char_u	*b_p_ft;	/* 'filetype' */
+    char_u	*b_p_fo;	/* 'formatoptions' */
+    char_u	*b_p_flp;	/* 'formatlistpat' */
+    int		b_p_inf;	/* 'infercase' */
+    char_u	*b_p_isk;	/* 'iskeyword' */
+#ifdef FEAT_FIND_ID
+    char_u	*b_p_def;	/* 'define' local value */
+    char_u	*b_p_inc;	/* 'include' */
+# ifdef FEAT_EVAL
+    char_u	*b_p_inex;	/* 'includeexpr' */
+    long_u	b_p_inex_flags;	/* flags for 'includeexpr' */
+# endif
+#endif
+#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
+    char_u	*b_p_inde;	/* 'indentexpr' */
+    long_u	b_p_inde_flags;	/* flags for 'indentexpr' */
+    char_u	*b_p_indk;	/* 'indentkeys' */
+#endif
+    char_u	*b_p_fp;	/* 'formatprg' */
+#if defined(FEAT_EVAL)
+    char_u	*b_p_fex;	/* 'formatexpr' */
+    long_u	b_p_fex_flags;	/* flags for 'formatexpr' */
+#endif
+#ifdef FEAT_CRYPT
+    char_u	*b_p_key;	/* 'key' */
+#endif
+    char_u	*b_p_kp;	/* 'keywordprg' */
+#ifdef FEAT_LISP
+    int		b_p_lisp;	/* 'lisp' */
+#endif
+#ifdef FEAT_MBYTE
+    char_u	*b_p_menc;	/* 'makeencoding' */
+#endif
+    char_u	*b_p_mps;	/* 'matchpairs' */
+    int		b_p_ml;		/* 'modeline' */
+    int		b_p_ml_nobin;	/* b_p_ml saved for binary mode */
+    int		b_p_ma;		/* 'modifiable' */
+    char_u	*b_p_nf;	/* 'nrformats' */
+    int		b_p_pi;		/* 'preserveindent' */
+#ifdef FEAT_TEXTOBJ
+    char_u	*b_p_qe;	/* 'quoteescape' */
+#endif
+    int		b_p_ro;		/* 'readonly' */
+    long	b_p_sw;		/* 'shiftwidth' */
+    int		b_p_sn;		/* 'shortname' */
+#ifdef FEAT_SMARTINDENT
+    int		b_p_si;		/* 'smartindent' */
+#endif
+    long	b_p_sts;	/* 'softtabstop' */
+    long	b_p_sts_nopaste; /* b_p_sts saved for paste mode */
+#ifdef FEAT_SEARCHPATH
+    char_u	*b_p_sua;	/* 'suffixesadd' */
+#endif
+    int		b_p_swf;	/* 'swapfile' */
+#ifdef FEAT_SYN_HL
+    long	b_p_smc;	/* 'synmaxcol' */
+    char_u	*b_p_syn;	/* 'syntax' */
+#endif
+    long	b_p_ts;		/* 'tabstop' */
+    int		b_p_tx;		/* 'textmode' */
+    long	b_p_tw;		/* 'textwidth' */
+    long	b_p_tw_nobin;	/* b_p_tw saved for binary mode */
+    long	b_p_tw_nopaste;	/* b_p_tw saved for paste mode */
+    long	b_p_wm;		/* 'wrapmargin' */
+    long	b_p_wm_nobin;	/* b_p_wm saved for binary mode */
+    long	b_p_wm_nopaste;	/* b_p_wm saved for paste mode */
+#ifdef FEAT_VARTABS
+    char_u	*b_p_vsts;	/* 'varsofttabstop' */
+    int		*b_p_vsts_array;   /* 'varsofttabstop' in internal format */
+    char_u	*b_p_vsts_nopaste; /* b_p_vsts saved for paste mode */
+    char_u	*b_p_vts;	/* 'vartabstop' */
+    int		*b_p_vts_array;	/* 'vartabstop' in internal format */
+#endif
+#ifdef FEAT_KEYMAP
+    char_u	*b_p_keymap;	/* 'keymap' */
+#endif
+
+    /* local values for options which are normally global */
+#ifdef FEAT_QUICKFIX
+    char_u	*b_p_gp;	/* 'grepprg' local value */
+    char_u	*b_p_mp;	/* 'makeprg' local value */
+    char_u	*b_p_efm;	/* 'errorformat' local value */
+#endif
+    char_u	*b_p_ep;	/* 'equalprg' local value */
+    char_u	*b_p_path;	/* 'path' local value */
+    int		b_p_ar;		/* 'autoread' local value */
+    char_u	*b_p_tags;	/* 'tags' local value */
+    char_u	*b_p_tc;	/* 'tagcase' local value */
+    unsigned	b_tc_flags;     /* flags for 'tagcase' */
+#ifdef FEAT_INS_EXPAND
+    char_u	*b_p_dict;	/* 'dictionary' local value */
+    char_u	*b_p_tsr;	/* 'thesaurus' local value */
+#endif
+    long	b_p_ul;		/* 'undolevels' local value */
+#ifdef FEAT_PERSISTENT_UNDO
+    int		b_p_udf;	/* 'undofile' */
+#endif
+#ifdef FEAT_LISP
+    char_u	*b_p_lw;	/* 'lispwords' local value */
+#endif
+#ifdef FEAT_TERMINAL
+    long	b_p_twsl;	/* 'termwinscroll' */
+#endif
+
+    /* end of buffer options */
+
+#ifdef FEAT_CINDENT
+    /* values set from b_p_cino */
+    int		b_ind_level;
+    int		b_ind_open_imag;
+    int		b_ind_no_brace;
+    int		b_ind_first_open;
+    int		b_ind_open_extra;
+    int		b_ind_close_extra;
+    int		b_ind_open_left_imag;
+    int		b_ind_jump_label;
+    int		b_ind_case;
+    int		b_ind_case_code;
+    int		b_ind_case_break;
+    int		b_ind_param;
+    int		b_ind_func_type;
+    int		b_ind_comment;
+    int		b_ind_in_comment;
+    int		b_ind_in_comment2;
+    int		b_ind_cpp_baseclass;
+    int		b_ind_continuation;
+    int		b_ind_unclosed;
+    int		b_ind_unclosed2;
+    int		b_ind_unclosed_noignore;
+    int		b_ind_unclosed_wrapped;
+    int		b_ind_unclosed_whiteok;
+    int		b_ind_matching_paren;
+    int		b_ind_paren_prev;
+    int		b_ind_maxparen;
+    int		b_ind_maxcomment;
+    int		b_ind_scopedecl;
+    int		b_ind_scopedecl_code;
+    int		b_ind_java;
+    int		b_ind_js;
+    int		b_ind_keep_case_label;
+    int		b_ind_hash_comment;
+    int		b_ind_cpp_namespace;
+    int		b_ind_if_for_while;
+    int		b_ind_cpp_extern_c;
+#endif
+
+    linenr_T	b_no_eol_lnum;	/* non-zero lnum when last line of next binary
+				 * write should not have an end-of-line */
+
+    int		b_start_eol;	/* last line had eol when it was read */
+    int		b_start_ffc;	/* first char of 'ff' when edit started */
+#ifdef FEAT_MBYTE
+    char_u	*b_start_fenc;	/* 'fileencoding' when edit started or NULL */
+    int		b_bad_char;	/* "++bad=" argument when edit started or 0 */
+    int		b_start_bomb;	/* 'bomb' when it was read */
+#endif
+
+#ifdef FEAT_EVAL
+    dictitem_T	b_bufvar;	/* variable for "b:" Dictionary */
+    dict_T	*b_vars;	/* internal variables, local to buffer */
+#endif
+
+#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)
+    char_u	*b_p_bexpr;	/* 'balloonexpr' local value */
+    long_u	b_p_bexpr_flags;/* flags for 'balloonexpr' */
+#endif
+#ifdef FEAT_CRYPT
+    char_u	*b_p_cm;	/* 'cryptmethod' */
+#endif
+
+    /* When a buffer is created, it starts without a swap file.  b_may_swap is
+     * then set to indicate that a swap file may be opened later.  It is reset
+     * if a swap file could not be opened.
+     */
+    int		b_may_swap;
+    int		b_did_warn;	/* Set to 1 if user has been warned on first
+				   change of a read-only file */
+
+    /* Two special kinds of buffers:
+     * help buffer  - used for help files, won't use a swap file.
+     * spell buffer - used for spell info, never displayed and doesn't have a
+     *		      file name.
+     */
+    int		b_help;		/* TRUE for help file buffer (when set b_p_bt
+				   is "help") */
+#ifdef FEAT_SPELL
+    int		b_spell;	/* TRUE for a spell file buffer, most fields
+				   are not used!  Use the B_SPELL macro to
+				   access b_spell without #ifdef. */
+#endif
+
+    int		b_shortname;	/* this file has an 8.3 file name */
+
+#ifdef FEAT_JOB_CHANNEL
+    char_u	*b_prompt_text;	     // set by prompt_setprompt()
+    char_u	*b_prompt_callback;  // set by prompt_setcallback()
+    partial_T	*b_prompt_partial;   // set by prompt_setcallback()
+    char_u	*b_prompt_interrupt;   // set by prompt_setinterrupt()
+    partial_T	*b_prompt_int_partial; // set by prompt_setinterrupt()
+    int		b_prompt_insert;     // value for restart_edit when entering
+				     // a prompt buffer window.
+#endif
+#ifdef FEAT_MZSCHEME
+    void	*b_mzscheme_ref; /* The MzScheme reference to this buffer */
+#endif
+
+#ifdef FEAT_PERL
+    void	*b_perl_private;
+#endif
+
+#ifdef FEAT_PYTHON
+    void	*b_python_ref;	/* The Python reference to this buffer */
+#endif
+
+#ifdef FEAT_PYTHON3
+    void	*b_python3_ref;	/* The Python3 reference to this buffer */
+#endif
+
+#ifdef FEAT_TCL
+    void	*b_tcl_ref;
+#endif
+
+#ifdef FEAT_RUBY
+    void	*b_ruby_ref;
+#endif
+
+#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
+    synblock_T	b_s;		/* Info related to syntax highlighting.  w_s
+				 * normally points to this, but some windows
+				 * may use a different synblock_T. */
+#endif
+
+#ifdef FEAT_SIGNS
+    signlist_T	*b_signlist;	/* list of signs to draw */
+# ifdef FEAT_NETBEANS_INTG
+    int		b_has_sign_column; /* Flag that is set when a first sign is
+				    * added and remains set until the end of
+				    * the netbeans session. */
+# endif
+#endif
+
+#ifdef FEAT_NETBEANS_INTG
+    int		b_netbeans_file;    /* TRUE when buffer is owned by NetBeans */
+    int		b_was_netbeans_file;/* TRUE if b_netbeans_file was once set */
+#endif
+#ifdef FEAT_JOB_CHANNEL
+    int		b_write_to_channel; /* TRUE when appended lines are written to
+				     * a channel. */
+#endif
+
+#ifdef FEAT_CRYPT
+    cryptstate_T *b_cryptstate;	/* Encryption state while reading or writing
+				 * the file. NULL when not using encryption. */
+#endif
+    int		b_mapped_ctrl_c; /* modes where CTRL-C is mapped */
+
+#ifdef FEAT_TERMINAL
+    term_T	*b_term;	/* When not NULL this buffer is for a terminal
+				 * window. */
+#endif
+
+}; /* file_buffer */
+
+
+#ifdef FEAT_DIFF
+/*
+ * Stuff for diff mode.
+ */
+# define DB_COUNT 8	/* up to eight buffers can be diff'ed */
+
+/*
+ * Each diffblock defines where a block of lines starts in each of the buffers
+ * and how many lines it occupies in that buffer.  When the lines are missing
+ * in the buffer the df_count[] is zero.  This is all counted in
+ * buffer lines.
+ * There is always at least one unchanged line in between the diffs.
+ * Otherwise it would have been included in the diff above or below it.
+ * df_lnum[] + df_count[] is the lnum below the change.  When in one buffer
+ * lines have been inserted, in the other buffer df_lnum[] is the line below
+ * the insertion and df_count[] is zero.  When appending lines at the end of
+ * the buffer, df_lnum[] is one beyond the end!
+ * This is using a linked list, because the number of differences is expected
+ * to be reasonable small.  The list is sorted on lnum.
+ */
+typedef struct diffblock_S diff_T;
+struct diffblock_S
+{
+    diff_T	*df_next;
+    linenr_T	df_lnum[DB_COUNT];	/* line number in buffer */
+    linenr_T	df_count[DB_COUNT];	/* nr of inserted/changed lines */
+};
+#endif
+
+#define SNAP_HELP_IDX	0
+#define SNAP_AUCMD_IDX 1
+#define SNAP_COUNT	2
+
+/*
+ * Tab pages point to the top frame of each tab page.
+ * Note: Most values are NOT valid for the current tab page!  Use "curwin",
+ * "firstwin", etc. for that.  "tp_topframe" is always valid and can be
+ * compared against "topframe" to find the current tab page.
+ */
+typedef struct tabpage_S tabpage_T;
+struct tabpage_S
+{
+    tabpage_T	    *tp_next;	    /* next tabpage or NULL */
+    frame_T	    *tp_topframe;   /* topframe for the windows */
+    win_T	    *tp_curwin;	    /* current window in this Tab page */
+    win_T	    *tp_prevwin;    /* previous window in this Tab page */
+    win_T	    *tp_firstwin;   /* first window in this Tab page */
+    win_T	    *tp_lastwin;    /* last window in this Tab page */
+    long	    tp_old_Rows;    /* Rows when Tab page was left */
+    long	    tp_old_Columns; /* Columns when Tab page was left */
+    long	    tp_ch_used;	    /* value of 'cmdheight' when frame size
+				       was set */
+#ifdef FEAT_GUI
+    int		    tp_prev_which_scrollbars[3];
+				    /* previous value of which_scrollbars */
+#endif
+#ifdef FEAT_DIFF
+    diff_T	    *tp_first_diff;
+    buf_T	    *(tp_diffbuf[DB_COUNT]);
+    int		    tp_diff_invalid;	/* list of diffs is outdated */
+#endif
+    frame_T	    *(tp_snapshot[SNAP_COUNT]);  /* window layout snapshots */
+#ifdef FEAT_EVAL
+    dictitem_T	    tp_winvar;	    /* variable for "t:" Dictionary */
+    dict_T	    *tp_vars;	    /* internal variables, local to tab page */
+#endif
+
+#ifdef FEAT_PYTHON
+    void	    *tp_python_ref;	/* The Python value for this tab page */
+#endif
+
+#ifdef FEAT_PYTHON3
+    void	    *tp_python3_ref;	/* The Python value for this tab page */
+#endif
+};
+
+/*
+ * Structure to cache info for displayed lines in w_lines[].
+ * Each logical line has one entry.
+ * The entry tells how the logical line is currently displayed in the window.
+ * This is updated when displaying the window.
+ * When the display is changed (e.g., when clearing the screen) w_lines_valid
+ * is changed to exclude invalid entries.
+ * When making changes to the buffer, wl_valid is reset to indicate wl_size
+ * may not reflect what is actually in the buffer.  When wl_valid is FALSE,
+ * the entries can only be used to count the number of displayed lines used.
+ * wl_lnum and wl_lastlnum are invalid too.
+ */
+typedef struct w_line
+{
+    linenr_T	wl_lnum;	/* buffer line number for logical line */
+    short_u	wl_size;	/* height in screen lines */
+    char	wl_valid;	/* TRUE values are valid for text in buffer */
+#ifdef FEAT_FOLDING
+    char	wl_folded;	/* TRUE when this is a range of folded lines */
+    linenr_T	wl_lastlnum;	/* last buffer line number for logical line */
+#endif
+} wline_T;
+
+/*
+ * Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
+ * or row (FR_ROW) layout or is a leaf, which has a window.
+ */
+struct frame_S
+{
+    char	fr_layout;	/* FR_LEAF, FR_COL or FR_ROW */
+    int		fr_width;
+    int		fr_newwidth;	/* new width used in win_equal_rec() */
+    int		fr_height;
+    int		fr_newheight;	/* new height used in win_equal_rec() */
+    frame_T	*fr_parent;	/* containing frame or NULL */
+    frame_T	*fr_next;	/* frame right or below in same parent, NULL
+				   for first */
+    frame_T	*fr_prev;	/* frame left or above in same parent, NULL
+				   for last */
+    /* fr_child and fr_win are mutually exclusive */
+    frame_T	*fr_child;	/* first contained frame */
+    win_T	*fr_win;	/* window that fills this frame */
+};
+
+#define FR_LEAF	0	/* frame is a leaf */
+#define FR_ROW	1	/* frame with a row of windows */
+#define FR_COL	2	/* frame with a column of windows */
+
+/*
+ * Struct used for highlighting 'hlsearch' matches, matches defined by
+ * ":match" and matches defined by match functions.
+ * For 'hlsearch' there is one pattern for all windows.  For ":match" and the
+ * match functions there is a different pattern for each window.
+ */
+typedef struct
+{
+    regmmatch_T	rm;	/* points to the regexp program; contains last found
+			   match (may continue in next line) */
+    buf_T	*buf;	/* the buffer to search for a match */
+    linenr_T	lnum;	/* the line to search for a match */
+    int		attr;	/* attributes to be used for a match */
+    int		attr_cur; /* attributes currently active in win_line() */
+    linenr_T	first_lnum;	/* first lnum to search for multi-line pat */
+    colnr_T	startcol; /* in win_line() points to char where HL starts */
+    colnr_T	endcol;	 /* in win_line() points to char where HL ends */
+    int		is_addpos;	/* position specified directly by
+				   matchaddpos(). TRUE/FALSE */
+#ifdef FEAT_RELTIME
+    proftime_T	tm;	/* for a time limit */
+#endif
+} match_T;
+
+/* number of positions supported by matchaddpos() */
+#define MAXPOSMATCH 8
+
+/*
+ * Same as lpos_T, but with additional field len.
+ */
+typedef struct
+{
+    linenr_T	lnum;	/* line number */
+    colnr_T	col;	/* column number */
+    int		len;	/* length: 0 - to the end of line */
+} llpos_T;
+
+/*
+ * posmatch_T provides an array for storing match items for matchaddpos()
+ * function.
+ */
+typedef struct posmatch posmatch_T;
+struct posmatch
+{
+    llpos_T	pos[MAXPOSMATCH];	/* array of positions */
+    int		cur;			/* internal position counter */
+    linenr_T	toplnum;		/* top buffer line */
+    linenr_T	botlnum;		/* bottom buffer line */
+};
+
+/*
+ * matchitem_T provides a linked list for storing match items for ":match" and
+ * the match functions.
+ */
+typedef struct matchitem matchitem_T;
+struct matchitem
+{
+    matchitem_T	*next;
+    int		id;	    /* match ID */
+    int		priority;   /* match priority */
+    char_u	*pattern;   /* pattern to highlight */
+    int		hlg_id;	    /* highlight group ID */
+    regmmatch_T	match;	    /* regexp program for pattern */
+    posmatch_T	pos;	    /* position matches */
+    match_T	hl;	    /* struct for doing the actual highlighting */
+#ifdef FEAT_CONCEAL
+    int		conceal_char; /* cchar for Conceal highlighting */
+#endif
+};
+
+#ifdef FEAT_MENU
+typedef struct {
+    int		wb_startcol;
+    int		wb_endcol;
+    vimmenu_T	*wb_menu;
+} winbar_item_T;
+#endif
+
+/*
+ * Structure which contains all information that belongs to a window
+ *
+ * All row numbers are relative to the start of the window, except w_winrow.
+ */
+struct window_S
+{
+    int		w_id;		    /* unique window ID */
+
+    buf_T	*w_buffer;	    /* buffer we are a window into (used
+				       often, keep it the first item!) */
+
+#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
+    synblock_T	*w_s;		    /* for :ownsyntax */
+#endif
+
+    win_T	*w_prev;	    /* link to previous window */
+    win_T	*w_next;	    /* link to next window */
+    int		w_closing;	    /* window is being closed, don't let
+				       autocommands close it too. */
+
+    frame_T	*w_frame;	    /* frame containing this window */
+
+    pos_T	w_cursor;	    /* cursor position in buffer */
+
+    colnr_T	w_curswant;	    /* The column we'd like to be at.  This is
+				       used to try to stay in the same column
+				       for up/down cursor motions. */
+
+    int		w_set_curswant;	    /* If set, then update w_curswant the next
+				       time through cursupdate() to the
+				       current virtual column */
+
+    /*
+     * the next seven are used to update the visual part
+     */
+    char	w_old_visual_mode;  /* last known VIsual_mode */
+    linenr_T	w_old_cursor_lnum;  /* last known end of visual part */
+    colnr_T	w_old_cursor_fcol;  /* first column for block visual part */
+    colnr_T	w_old_cursor_lcol;  /* last column for block visual part */
+    linenr_T	w_old_visual_lnum;  /* last known start of visual part */
+    colnr_T	w_old_visual_col;   /* last known start of visual part */
+    colnr_T	w_old_curswant;	    /* last known value of Curswant */
+
+    /*
+     * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
+     * displaying the buffer.
+     */
+    linenr_T	w_topline;	    /* buffer line number of the line at the
+				       top of the window */
+    char	w_topline_was_set;  /* flag set to TRUE when topline is set,
+				       e.g. by winrestview() */
+#ifdef FEAT_DIFF
+    int		w_topfill;	    /* number of filler lines above w_topline */
+    int		w_old_topfill;	    /* w_topfill at last redraw */
+    int		w_botfill;	    /* TRUE when filler lines are actually
+				       below w_topline (at end of file) */
+    int		w_old_botfill;	    /* w_botfill at last redraw */
+#endif
+    colnr_T	w_leftcol;	    /* window column number of the left most
+				       character in the window; used when
+				       'wrap' is off */
+    colnr_T	w_skipcol;	    /* starting column when a single line
+				       doesn't fit in the window */
+
+    /*
+     * Layout of the window in the screen.
+     * May need to add "msg_scrolled" to "w_winrow" in rare situations.
+     */
+    int		w_winrow;	    /* first row of window in screen */
+    int		w_height;	    /* number of rows in window, excluding
+				       status/command/winbar line(s) */
+    int		w_status_height;    /* number of status lines (0 or 1) */
+    int		w_wincol;	    /* Leftmost column of window in screen. */
+    int		w_width;	    /* Width of window, excluding separation. */
+    int		w_vsep_width;	    /* Number of separator columns (0 or 1). */
+
+    /*
+     * === start of cached values ====
+     */
+    /*
+     * Recomputing is minimized by storing the result of computations.
+     * Use functions in screen.c to check if they are valid and to update.
+     * w_valid is a bitfield of flags, which indicate if specific values are
+     * valid or need to be recomputed.	See screen.c for values.
+     */
+    int		w_valid;
+    pos_T	w_valid_cursor;	    /* last known position of w_cursor, used
+				       to adjust w_valid */
+    colnr_T	w_valid_leftcol;    /* last known w_leftcol */
+
+    /*
+     * w_cline_height is the number of physical lines taken by the buffer line
+     * that the cursor is on.  We use this to avoid extra calls to plines().
+     */
+    int		w_cline_height;	    /* current size of cursor line */
+#ifdef FEAT_FOLDING
+    int		w_cline_folded;	    /* cursor line is folded */
+#endif
+
+    int		w_cline_row;	    /* starting row of the cursor line */
+
+    colnr_T	w_virtcol;	    /* column number of the cursor in the
+				       buffer line, as opposed to the column
+				       number we're at on the screen.  This
+				       makes a difference on lines which span
+				       more than one screen line or when
+				       w_leftcol is non-zero */
+
+    /*
+     * w_wrow and w_wcol specify the cursor position in the window.
+     * This is related to positions in the window, not in the display or
+     * buffer, thus w_wrow is relative to w_winrow.
+     */
+    int		w_wrow, w_wcol;	    /* cursor position in window */
+
+    linenr_T	w_botline;	    /* number of the line below the bottom of
+				       the window */
+    int		w_empty_rows;	    /* number of ~ rows in window */
+#ifdef FEAT_DIFF
+    int		w_filler_rows;	    /* number of filler rows at the end of the
+				       window */
+#endif
+
+    /*
+     * Info about the lines currently in the window is remembered to avoid
+     * recomputing it every time.  The allocated size of w_lines[] is Rows.
+     * Only the w_lines_valid entries are actually valid.
+     * When the display is up-to-date w_lines[0].wl_lnum is equal to w_topline
+     * and w_lines[w_lines_valid - 1].wl_lnum is equal to w_botline.
+     * Between changing text and updating the display w_lines[] represents
+     * what is currently displayed.  wl_valid is reset to indicated this.
+     * This is used for efficient redrawing.
+     */
+    int		w_lines_valid;	    /* number of valid entries */
+    wline_T	*w_lines;
+
+#ifdef FEAT_FOLDING
+    garray_T	w_folds;	    /* array of nested folds */
+    char	w_fold_manual;	    /* when TRUE: some folds are opened/closed
+				       manually */
+    char	w_foldinvalid;	    /* when TRUE: folding needs to be
+				       recomputed */
+#endif
+#ifdef FEAT_LINEBREAK
+    int		w_nrwidth;	    /* width of 'number' and 'relativenumber'
+				       column being used */
+#endif
+
+    /*
+     * === end of cached values ===
+     */
+
+    int		w_redr_type;	    /* type of redraw to be performed on win */
+    int		w_upd_rows;	    /* number of window lines to update when
+				       w_redr_type is REDRAW_TOP */
+    linenr_T	w_redraw_top;	    /* when != 0: first line needing redraw */
+    linenr_T	w_redraw_bot;	    /* when != 0: last line needing redraw */
+    int		w_redr_status;	    /* if TRUE status line must be redrawn */
+
+#ifdef FEAT_CMDL_INFO
+    /* remember what is shown in the ruler for this window (if 'ruler' set) */
+    pos_T	w_ru_cursor;	    /* cursor position shown in ruler */
+    colnr_T	w_ru_virtcol;	    /* virtcol shown in ruler */
+    linenr_T	w_ru_topline;	    /* topline shown in ruler */
+    linenr_T	w_ru_line_count;    /* line count used for ruler */
+# ifdef FEAT_DIFF
+    int		w_ru_topfill;	    /* topfill shown in ruler */
+# endif
+    char	w_ru_empty;	    /* TRUE if ruler shows 0-1 (empty line) */
+#endif
+
+    int		w_alt_fnum;	    /* alternate file (for # and CTRL-^) */
+
+    alist_T	*w_alist;	    /* pointer to arglist for this window */
+    int		w_arg_idx;	    /* current index in argument list (can be
+				       out of range!) */
+    int		w_arg_idx_invalid;  /* editing another file than w_arg_idx */
+
+    char_u	*w_localdir;	    /* absolute path of local directory or
+				       NULL */
+#ifdef FEAT_MENU
+    vimmenu_T	*w_winbar;	    /* The root of the WinBar menu hierarchy. */
+    winbar_item_T *w_winbar_items;  /* list of items in the WinBar */
+    int		w_winbar_height;    /* 1 if there is a window toolbar */
+#endif
+
+    /*
+     * Options local to a window.
+     * They are local because they influence the layout of the window or
+     * depend on the window layout.
+     * There are two values: w_onebuf_opt is local to the buffer currently in
+     * this window, w_allbuf_opt is for all buffers in this window.
+     */
+    winopt_T	w_onebuf_opt;
+    winopt_T	w_allbuf_opt;
+
+    /* A few options have local flags for P_INSECURE. */
+#ifdef FEAT_STL_OPT
+    long_u	w_p_stl_flags;	    /* flags for 'statusline' */
+#endif
+#ifdef FEAT_EVAL
+    long_u	w_p_fde_flags;	    /* flags for 'foldexpr' */
+    long_u	w_p_fdt_flags;	    /* flags for 'foldtext' */
+#endif
+#ifdef FEAT_SYN_HL
+    int		*w_p_cc_cols;	    /* array of columns to highlight or NULL */
+#endif
+#ifdef FEAT_LINEBREAK
+    int		w_p_brimin;	    /* minimum width for breakindent */
+    int		w_p_brishift;	    /* additional shift for breakindent */
+    int		w_p_brisbr;	    /* sbr in 'briopt' */
+#endif
+
+    /* transform a pointer to a "onebuf" option into a "allbuf" option */
+#define GLOBAL_WO(p)	((char *)p + sizeof(winopt_T))
+
+    long	w_scbind_pos;
+
+#ifdef FEAT_EVAL
+    dictitem_T	w_winvar;	/* variable for "w:" Dictionary */
+    dict_T	*w_vars;	/* internal variables, local to window */
+#endif
+
+#if defined(FEAT_RIGHTLEFT) && defined(FEAT_FKMAP)
+    int		w_farsi;	/* for the window dependent Farsi functions */
+#endif
+
+    /*
+     * The w_prev_pcmark field is used to check whether we really did jump to
+     * a new line after setting the w_pcmark.  If not, then we revert to
+     * using the previous w_pcmark.
+     */
+    pos_T	w_pcmark;	/* previous context mark */
+    pos_T	w_prev_pcmark;	/* previous w_pcmark */
+
+#ifdef FEAT_JUMPLIST
+    /*
+     * the jumplist contains old cursor positions
+     */
+    xfmark_T	w_jumplist[JUMPLISTSIZE];
+    int		w_jumplistlen;		/* number of active entries */
+    int		w_jumplistidx;		/* current position */
+
+    int		w_changelistidx;	/* current position in b_changelist */
+#endif
+
+#ifdef FEAT_SEARCH_EXTRA
+    matchitem_T	*w_match_head;		/* head of match list */
+    int		w_next_match_id;	/* next match ID */
+#endif
+
+    /*
+     * the tagstack grows from 0 upwards:
+     * entry 0: older
+     * entry 1: newer
+     * entry 2: newest
+     */
+    taggy_T	w_tagstack[TAGSTACKSIZE];	/* the tag stack */
+    int		w_tagstackidx;		/* idx just below active entry */
+    int		w_tagstacklen;		/* number of tags on stack */
+
+    /*
+     * w_fraction is the fractional row of the cursor within the window, from
+     * 0 at the top row to FRACTION_MULT at the last row.
+     * w_prev_fraction_row was the actual cursor row when w_fraction was last
+     * calculated.
+     */
+    int		w_fraction;
+    int		w_prev_fraction_row;
+
+#ifdef FEAT_GUI
+    scrollbar_T	w_scrollbars[2];	/* vert. Scrollbars for this window */
+#endif
+#ifdef FEAT_LINEBREAK
+    linenr_T	w_nrwidth_line_count;	/* line count when ml_nrwidth_width
+					 * was computed. */
+    long	w_nuw_cached;		/* 'numberwidth' option cached */
+    int		w_nrwidth_width;	/* nr of chars to print line count. */
+#endif
+
+#ifdef FEAT_QUICKFIX
+    qf_info_T	*w_llist;		/* Location list for this window */
+    /*
+     * Location list reference used in the location list window.
+     * In a non-location list window, w_llist_ref is NULL.
+     */
+    qf_info_T	*w_llist_ref;
+#endif
+
+
+#ifdef FEAT_MZSCHEME
+    void	*w_mzscheme_ref;	/* The MzScheme value for this window */
+#endif
+
+#ifdef FEAT_PERL
+    void	*w_perl_private;
+#endif
+
+#ifdef FEAT_PYTHON
+    void	*w_python_ref;		/* The Python value for this window */
+#endif
+
+#ifdef FEAT_PYTHON3
+    void	*w_python3_ref;		/* The Python value for this window */
+#endif
+
+#ifdef FEAT_TCL
+    void	*w_tcl_ref;
+#endif
+
+#ifdef FEAT_RUBY
+    void	*w_ruby_ref;
+#endif
+};
+
+/*
+ * Arguments for operators.
+ */
+typedef struct oparg_S
+{
+    int		op_type;	/* current pending operator type */
+    int		regname;	/* register to use for the operator */
+    int		motion_type;	/* type of the current cursor motion */
+    int		motion_force;	/* force motion type: 'v', 'V' or CTRL-V */
+    int		use_reg_one;	/* TRUE if delete uses reg 1 even when not
+				   linewise */
+    int		inclusive;	/* TRUE if char motion is inclusive (only
+				   valid when motion_type is MCHAR */
+    int		end_adjusted;	/* backuped b_op_end one char (only used by
+				   do_format()) */
+    pos_T	start;		/* start of the operator */
+    pos_T	end;		/* end of the operator */
+    pos_T	cursor_start;	/* cursor position before motion for "gw" */
+
+    long	line_count;	/* number of lines from op_start to op_end
+				   (inclusive) */
+    int		empty;		/* op_start and op_end the same (only used by
+				   do_change()) */
+    int		is_VIsual;	/* operator on Visual area */
+    int		block_mode;	/* current operator is Visual block mode */
+    colnr_T	start_vcol;	/* start col for block mode operator */
+    colnr_T	end_vcol;	/* end col for block mode operator */
+    long	prev_opcount;	/* ca.opcount saved for K_CURSORHOLD */
+    long	prev_count0;	/* ca.count0 saved for K_CURSORHOLD */
+} oparg_T;
+
+/*
+ * Arguments for Normal mode commands.
+ */
+typedef struct cmdarg_S
+{
+    oparg_T	*oap;		/* Operator arguments */
+    int		prechar;	/* prefix character (optional, always 'g') */
+    int		cmdchar;	/* command character */
+    int		nchar;		/* next command character (optional) */
+#ifdef FEAT_MBYTE
+    int		ncharC1;	/* first composing character (optional) */
+    int		ncharC2;	/* second composing character (optional) */
+#endif
+    int		extra_char;	/* yet another character (optional) */
+    long	opcount;	/* count before an operator */
+    long	count0;		/* count before command, default 0 */
+    long	count1;		/* count before command, default 1 */
+    int		arg;		/* extra argument from nv_cmds[] */
+    int		retval;		/* return: CA_* values */
+    char_u	*searchbuf;	/* return: pointer to search pattern or NULL */
+} cmdarg_T;
+
+/* values for retval: */
+#define CA_COMMAND_BUSY	    1	/* skip restarting edit() once */
+#define CA_NO_ADJ_OP_END    2	/* don't adjust operator end */
+
+#ifdef CURSOR_SHAPE
+/*
+ * struct to store values from 'guicursor' and 'mouseshape'
+ */
+/* Indexes in shape_table[] */
+#define SHAPE_IDX_N	0	/* Normal mode */
+#define SHAPE_IDX_V	1	/* Visual mode */
+#define SHAPE_IDX_I	2	/* Insert mode */
+#define SHAPE_IDX_R	3	/* Replace mode */
+#define SHAPE_IDX_C	4	/* Command line Normal mode */
+#define SHAPE_IDX_CI	5	/* Command line Insert mode */
+#define SHAPE_IDX_CR	6	/* Command line Replace mode */
+#define SHAPE_IDX_O	7	/* Operator-pending mode */
+#define SHAPE_IDX_VE	8	/* Visual mode with 'selection' exclusive */
+#define SHAPE_IDX_CLINE	9	/* On command line */
+#define SHAPE_IDX_STATUS 10	/* A status line */
+#define SHAPE_IDX_SDRAG 11	/* dragging a status line */
+#define SHAPE_IDX_VSEP	12	/* A vertical separator line */
+#define SHAPE_IDX_VDRAG 13	/* dragging a vertical separator line */
+#define SHAPE_IDX_MORE	14	/* Hit-return or More */
+#define SHAPE_IDX_MOREL	15	/* Hit-return or More in last line */
+#define SHAPE_IDX_SM	16	/* showing matching paren */
+#define SHAPE_IDX_COUNT	17
+
+#define SHAPE_BLOCK	0	/* block cursor */
+#define SHAPE_HOR	1	/* horizontal bar cursor */
+#define SHAPE_VER	2	/* vertical bar cursor */
+
+#define MSHAPE_NUMBERED	1000	/* offset for shapes identified by number */
+#define MSHAPE_HIDE	1	/* hide mouse pointer */
+
+#define SHAPE_MOUSE	1	/* used for mouse pointer shape */
+#define SHAPE_CURSOR	2	/* used for text cursor shape */
+
+typedef struct cursor_entry
+{
+    int		shape;		/* one of the SHAPE_ defines */
+    int		mshape;		/* one of the MSHAPE defines */
+    int		percentage;	/* percentage of cell for bar */
+    long	blinkwait;	/* blinking, wait time before blinking starts */
+    long	blinkon;	/* blinking, on time */
+    long	blinkoff;	/* blinking, off time */
+    int		id;		/* highlight group ID */
+    int		id_lm;		/* highlight group ID for :lmap mode */
+    char	*name;		/* mode name (fixed) */
+    char	used_for;	/* SHAPE_MOUSE and/or SHAPE_CURSOR */
+} cursorentry_T;
+#endif /* CURSOR_SHAPE */
+
+#ifdef FEAT_MENU
+
+/* Indices into vimmenu_T->strings[] and vimmenu_T->noremap[] for each mode */
+#define MENU_INDEX_INVALID	-1
+#define MENU_INDEX_NORMAL	0
+#define MENU_INDEX_VISUAL	1
+#define MENU_INDEX_SELECT	2
+#define MENU_INDEX_OP_PENDING	3
+#define MENU_INDEX_INSERT	4
+#define MENU_INDEX_CMDLINE	5
+#define MENU_INDEX_TIP		6
+#define MENU_MODES		7
+
+/* Menu modes */
+#define MENU_NORMAL_MODE	(1 << MENU_INDEX_NORMAL)
+#define MENU_VISUAL_MODE	(1 << MENU_INDEX_VISUAL)
+#define MENU_SELECT_MODE	(1 << MENU_INDEX_SELECT)
+#define MENU_OP_PENDING_MODE	(1 << MENU_INDEX_OP_PENDING)
+#define MENU_INSERT_MODE	(1 << MENU_INDEX_INSERT)
+#define MENU_CMDLINE_MODE	(1 << MENU_INDEX_CMDLINE)
+#define MENU_TIP_MODE		(1 << MENU_INDEX_TIP)
+#define MENU_ALL_MODES		((1 << MENU_INDEX_TIP) - 1)
+/*note MENU_INDEX_TIP is not a 'real' mode*/
+
+/* Start a menu name with this to not include it on the main menu bar */
+#define MNU_HIDDEN_CHAR		']'
+
+struct VimMenu
+{
+    int		modes;		    /* Which modes is this menu visible for? */
+    int		enabled;	    /* for which modes the menu is enabled */
+    char_u	*name;		    /* Name of menu, possibly translated */
+    char_u	*dname;		    /* Displayed Name ("name" without '&') */
+#ifdef FEAT_MULTI_LANG
+    char_u	*en_name;	    /* "name" untranslated, NULL when "name"
+				     * was not translated */
+    char_u	*en_dname;	    /* "dname" untranslated, NULL when "dname"
+				     * was not translated */
+#endif
+    int		mnemonic;	    /* mnemonic key (after '&') */
+    char_u	*actext;	    /* accelerator text (after TAB) */
+    int		priority;	    /* Menu order priority */
+#ifdef FEAT_GUI
+    void	(*cb)(vimmenu_T *);	    /* Call-back routine */
+#endif
+#ifdef FEAT_TOOLBAR
+    char_u	*iconfile;	    /* name of file for icon or NULL */
+    int		iconidx;	    /* icon index (-1 if not set) */
+    int		icon_builtin;	    /* icon names is BuiltIn{nr} */
+#endif
+    char_u	*strings[MENU_MODES]; /* Mapped string for each mode */
+    int		noremap[MENU_MODES]; /* A REMAP_ flag for each mode */
+    char	silent[MENU_MODES]; /* A silent flag for each mode */
+    vimmenu_T	*children;	    /* Children of sub-menu */
+    vimmenu_T	*parent;	    /* Parent of menu */
+    vimmenu_T	*next;		    /* Next item in menu */
+#ifdef FEAT_GUI_X11
+    Widget	id;		    /* Manage this to enable item */
+    Widget	submenu_id;	    /* If this is submenu, add children here */
+#endif
+#ifdef FEAT_GUI_GTK
+    GtkWidget	*id;		    /* Manage this to enable item */
+    GtkWidget	*submenu_id;	    /* If this is submenu, add children here */
+# if defined(GTK_CHECK_VERSION) && !GTK_CHECK_VERSION(3,4,0)
+    GtkWidget	*tearoff_handle;
+# endif
+    GtkWidget   *label;		    /* Used by "set wak=" code. */
+#endif
+#ifdef FEAT_GUI_MOTIF
+    int		sensitive;	    /* turn button on/off */
+    char	**xpm;		    /* pixmap data */
+    char	*xpm_fname;	    /* file with pixmap data */
+#endif
+#ifdef FEAT_GUI_ATHENA
+    Pixmap	image;		    /* Toolbar image */
+#endif
+#ifdef FEAT_BEVAL_TIP
+    BalloonEval *tip;		    /* tooltip for this menu item */
+#endif
+#ifdef FEAT_GUI_W32
+    UINT	id;		    /* Id of menu item */
+    HMENU	submenu_id;	    /* If this is submenu, add children here */
+    HWND	tearoff_handle;	    /* hWnd of tearoff if created */
+#endif
+#ifdef FEAT_GUI_MAC
+/*  MenuHandle	id; */
+/*  short	index;	*/	    /* the item index within the father menu */
+    short	menu_id;	    /* the menu id to which this item belong */
+    short	submenu_id;	    /* the menu id of the children (could be
+				       get through some tricks) */
+    MenuHandle	menu_handle;
+    MenuHandle	submenu_handle;
+#endif
+#ifdef FEAT_GUI_PHOTON
+    PtWidget_t	*id;
+    PtWidget_t	*submenu_id;
+#endif
+};
+#else
+/* For generating prototypes when FEAT_MENU isn't defined. */
+typedef int vimmenu_T;
+
+#endif /* FEAT_MENU */
+
+/*
+ * Struct to save values in before executing autocommands for a buffer that is
+ * not the current buffer.
+ */
+typedef struct
+{
+    buf_T	*save_curbuf;	/* saved curbuf */
+    int		use_aucmd_win;	/* using aucmd_win */
+    win_T	*save_curwin;	/* saved curwin */
+    win_T	*new_curwin;	/* new curwin */
+    bufref_T	new_curbuf;	/* new curbuf */
+    char_u	*globaldir;	/* saved value of globaldir */
+} aco_save_T;
+
+/*
+ * Generic option table item, only used for printer at the moment.
+ */
+typedef struct
+{
+    const char	*name;
+    int		hasnum;
+    long	number;
+    char_u	*string;	/* points into option string */
+    int		strlen;
+    int		present;
+} option_table_T;
+
+/*
+ * Structure to hold printing color and font attributes.
+ */
+typedef struct
+{
+    long_u	fg_color;
+    long_u	bg_color;
+    int		bold;
+    int		italic;
+    int		underline;
+    int		undercurl;
+} prt_text_attr_T;
+
+/*
+ * Structure passed back to the generic printer code.
+ */
+typedef struct
+{
+    int		n_collated_copies;
+    int		n_uncollated_copies;
+    int		duplex;
+    int		chars_per_line;
+    int		lines_per_page;
+    int		has_color;
+    prt_text_attr_T number;
+#ifdef FEAT_SYN_HL
+    int		modec;
+    int		do_syntax;
+#endif
+    int		user_abort;
+    char_u	*jobname;
+#ifdef FEAT_POSTSCRIPT
+    char_u	*outfile;
+    char_u	*arguments;
+#endif
+} prt_settings_T;
+
+#define PRINT_NUMBER_WIDTH 8
+
+/*
+ * Used for popup menu items.
+ */
+typedef struct
+{
+    char_u	*pum_text;	/* main menu text */
+    char_u	*pum_kind;	/* extra kind text (may be truncated) */
+    char_u	*pum_extra;	/* extra menu text (may be truncated) */
+    char_u	*pum_info;	/* extra info */
+} pumitem_T;
+
+/*
+ * Structure used for get_tagfname().
+ */
+typedef struct
+{
+    char_u	*tn_tags;	/* value of 'tags' when starting */
+    char_u	*tn_np;		/* current position in tn_tags */
+    int		tn_did_filefind_init;
+    int		tn_hf_idx;
+    void	*tn_search_ctx;
+} tagname_T;
+
+/*
+ * Array indexes used for cptext argument of ins_compl_add().
+ */
+#define CPT_ABBR	0	/* "abbr" */
+#define CPT_MENU	1	/* "menu" */
+#define CPT_KIND	2	/* "kind" */
+#define CPT_INFO	3	/* "info" */
+#define CPT_USER_DATA	4	/* "user data" */
+#define CPT_COUNT	5	/* Number of entries */
+
+typedef struct {
+  UINT32_T total[2];
+  UINT32_T state[8];
+  char_u   buffer[64];
+} context_sha256_T;
+
+/*
+ * types for expressions.
+ */
+typedef enum
+{
+    TYPE_UNKNOWN = 0,
+    TYPE_EQUAL,		// ==
+    TYPE_NEQUAL,	// !=
+    TYPE_GREATER,	// >
+    TYPE_GEQUAL,	// >=
+    TYPE_SMALLER,	// <
+    TYPE_SEQUAL,	// <=
+    TYPE_MATCH,		// =~
+    TYPE_NOMATCH,	// !~
+} exptype_T;
+
+/*
+ * Structure used for reading in json_decode().
+ */
+struct js_reader
+{
+    char_u	*js_buf;	/* text to be decoded */
+    char_u	*js_end;	/* NUL in js_buf */
+    int		js_used;	/* bytes used from js_buf */
+    int		(*js_fill)(struct js_reader *);
+				/* function to fill the buffer or NULL;
+                                 * return TRUE when the buffer was filled */
+    void	*js_cookie;	/* can be used by js_fill */
+    int		js_cookie_arg;	/* can be used by js_fill */
+};
+typedef struct js_reader js_read_T;
+
+typedef struct timer_S timer_T;
+struct timer_S
+{
+    long	tr_id;
+#ifdef FEAT_TIMERS
+    timer_T	*tr_next;
+    timer_T	*tr_prev;
+    proftime_T	tr_due;		    /* when the callback is to be invoked */
+    char	tr_firing;	    /* when TRUE callback is being called */
+    char	tr_paused;	    /* when TRUE callback is not invoked */
+    int		tr_repeat;	    /* number of times to repeat, -1 forever */
+    long	tr_interval;	    /* msec */
+    char_u	*tr_callback;	    /* allocated */
+    partial_T	*tr_partial;
+    int		tr_emsg_count;
+#endif
+};
+
+/* Maximum number of commands from + or -c arguments. */
+#define MAX_ARG_CMDS 10
+
+/* values for "window_layout" */
+#define WIN_HOR	    1	    /* "-o" horizontally split windows */
+#define	WIN_VER	    2	    /* "-O" vertically split windows */
+#define	WIN_TABS    3	    /* "-p" windows on tab pages */
+
+/* Struct for various parameters passed between main() and other functions. */
+typedef struct
+{
+    int		argc;
+    char	**argv;
+
+    char_u	*fname;			/* first file to edit */
+
+    int		evim_mode;		/* started as "evim" */
+    char_u	*use_vimrc;		/* vimrc from -u argument */
+    int		clean;			/* --clean argument */
+
+    int		n_commands;		     /* no. of commands from + or -c */
+    char_u	*commands[MAX_ARG_CMDS];     /* commands from + or -c arg. */
+    char_u	cmds_tofree[MAX_ARG_CMDS];   /* commands that need free() */
+    int		n_pre_commands;		     /* no. of commands from --cmd */
+    char_u	*pre_commands[MAX_ARG_CMDS]; /* commands from --cmd argument */
+
+    int		edit_type;		/* type of editing to do */
+    char_u	*tagname;		/* tag from -t argument */
+#ifdef FEAT_QUICKFIX
+    char_u	*use_ef;		/* 'errorfile' from -q argument */
+#endif
+
+    int		want_full_screen;
+    int		not_a_term;		/* no warning for missing term? */
+    int		tty_fail;		/* exit if not a tty */
+    char_u	*term;			/* specified terminal name */
+#ifdef FEAT_CRYPT
+    int		ask_for_key;		/* -x argument */
+#endif
+    int		no_swap_file;		/* "-n" argument used */
+#ifdef FEAT_EVAL
+    int		use_debug_break_level;
+#endif
+    int		window_count;		/* number of windows to use */
+    int		window_layout;		/* 0, WIN_HOR, WIN_VER or WIN_TABS */
+
+#ifdef FEAT_CLIENTSERVER
+    int		serverArg;		/* TRUE when argument for a server */
+    char_u	*serverName_arg;	/* cmdline arg for server name */
+    char_u	*serverStr;		/* remote server command */
+    char_u	*serverStrEnc;		/* encoding of serverStr */
+    char_u	*servername;		/* allocated name for our server */
+#endif
+#if !defined(UNIX)
+# define EXPAND_FILENAMES
+    int		literal;		/* don't expand file names */
+#endif
+#ifdef MSWIN
+    int		full_path;		/* file name argument was full path */
+#endif
+#ifdef FEAT_DIFF
+    int		diff_mode;		/* start with 'diff' set */
+#endif
+} mparm_T;
+
+/*
+ * Structure returned by get_lval() and used by set_var_lval().
+ * For a plain name:
+ *	"name"	    points to the variable name.
+ *	"exp_name"  is NULL.
+ *	"tv"	    is NULL
+ * For a magic braces name:
+ *	"name"	    points to the expanded variable name.
+ *	"exp_name"  is non-NULL, to be freed later.
+ *	"tv"	    is NULL
+ * For an index in a list:
+ *	"name"	    points to the (expanded) variable name.
+ *	"exp_name"  NULL or non-NULL, to be freed later.
+ *	"tv"	    points to the (first) list item value
+ *	"li"	    points to the (first) list item
+ *	"range", "n1", "n2" and "empty2" indicate what items are used.
+ * For an existing Dict item:
+ *	"name"	    points to the (expanded) variable name.
+ *	"exp_name"  NULL or non-NULL, to be freed later.
+ *	"tv"	    points to the dict item value
+ *	"newkey"    is NULL
+ * For a non-existing Dict item:
+ *	"name"	    points to the (expanded) variable name.
+ *	"exp_name"  NULL or non-NULL, to be freed later.
+ *	"tv"	    points to the Dictionary typval_T
+ *	"newkey"    is the key for the new item.
+ */
+typedef struct lval_S
+{
+    char_u	*ll_name;	/* start of variable name (can be NULL) */
+    char_u	*ll_exp_name;	/* NULL or expanded name in allocated memory. */
+    typval_T	*ll_tv;		/* Typeval of item being used.  If "newkey"
+				   isn't NULL it's the Dict to which to add
+				   the item. */
+    listitem_T	*ll_li;		/* The list item or NULL. */
+    list_T	*ll_list;	/* The list or NULL. */
+    int		ll_range;	/* TRUE when a [i:j] range was used */
+    long	ll_n1;		/* First index for list */
+    long	ll_n2;		/* Second index for list range */
+    int		ll_empty2;	/* Second index is empty: [i:] */
+    dict_T	*ll_dict;	/* The Dictionary or NULL */
+    dictitem_T	*ll_di;		/* The dictitem or NULL */
+    char_u	*ll_newkey;	/* New key for Dict in alloc. mem or NULL. */
+} lval_T;
+
+/* Structure used to save the current state.  Used when executing Normal mode
+ * commands while in any other mode. */
+typedef struct {
+    int		save_msg_scroll;
+    int		save_restart_edit;
+    int		save_msg_didout;
+    int		save_State;
+    int		save_insertmode;
+    int		save_finish_op;
+    int		save_opcount;
+    tasave_T	tabuf;
+} save_state_T;
+
+typedef struct {
+    varnumber_T vv_prevcount;
+    varnumber_T vv_count;
+    varnumber_T vv_count1;
+} vimvars_save_T;
diff --git a/src/ui.c b/src/ui.c
index 8e3f0de..076e218 100644
--- a/src/ui.c
+++ b/src/ui.c
@@ -3205,7 +3205,7 @@ mouse_find_win(int *rowp, int *colp UNUSED)
 }
 
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MAC) \
-	|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
+	|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_HAIKU) || defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_TERM_POPUP_MENU) \
 	|| defined(PROTO)
 /*
@@ -3253,7 +3253,7 @@ get_fpos_of_mouse(pos_T *mpos)
 
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MAC) \
 	|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_BEVAL) \
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_HAIKU) || defined(FEAT_BEVAL) \
 	|| defined(FEAT_TERM_POPUP_MENU) || defined(PROTO)
 /*
  * Convert a virtual (screen) column to a character column.
diff --git a/src/version.c b/src/version.c
index 790cd76..ebefea9 100644
--- a/src/version.c
+++ b/src/version.c
@@ -1816,6 +1816,9 @@ list_version(void)
     MSG_PUTS(_("with X11-Athena GUI."));
 #    endif
 #   else
+#    ifdef FEAT_GUI_HAIKU
+    MSG_PUTS(_("with Haiku GUI."));
+#    else
 #     ifdef FEAT_GUI_PHOTON
     MSG_PUTS(_("with Photon GUI."));
 #     else
@@ -1830,6 +1833,7 @@ list_version(void)
 #	 else
 #	 endif
 #	endif
+#       endif
 #      endif
 #    endif
 #   endif
diff --git a/b/src/version.c.orig b/src/version.c.orig
new file mode 100644
index 0000000..790cd76
--- /dev/null
+++ b/src/version.c.orig
@@ -0,0 +1,2154 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved		by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+#include "vim.h"
+
+#ifdef AMIGA
+# include <time.h>	/* for time() */
+#endif
+
+/*
+ * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)
+ * It has been changed beyond recognition since then.
+ *
+ * Differences between version 7.4 and 8.x can be found with ":help version8".
+ * Differences between version 6.4 and 7.x can be found with ":help version7".
+ * Differences between version 5.8 and 6.x can be found with ":help version6".
+ * Differences between version 4.x and 5.x can be found with ":help version5".
+ * Differences between version 3.0 and 4.x can be found with ":help version4".
+ * All the remarks about older versions have been removed, they are not very
+ * interesting.
+ */
+
+#include "version.h"
+
+char		*Version = VIM_VERSION_SHORT;
+static char	*mediumVersion = VIM_VERSION_MEDIUM;
+
+#if defined(HAVE_DATE_TIME) || defined(PROTO)
+# if (defined(VMS) && defined(VAXC)) || defined(PROTO)
+char	longVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)
+						      + sizeof(__TIME__) + 3];
+
+    void
+init_longVersion(void)
+{
+    /*
+     * Construct the long version string.  Necessary because
+     * VAX C can't catenate strings in the preprocessor.
+     */
+    strcpy(longVersion, VIM_VERSION_LONG_DATE);
+    strcat(longVersion, __DATE__);
+    strcat(longVersion, " ");
+    strcat(longVersion, __TIME__);
+    strcat(longVersion, ")");
+}
+
+# else
+    void
+init_longVersion(void)
+{
+    char *date_time = __DATE__ " " __TIME__;
+    char *msg = _("%s (%s, compiled %s)");
+    size_t len = strlen(msg)
+		+ strlen(VIM_VERSION_LONG_ONLY)
+		+ strlen(VIM_VERSION_DATE_ONLY)
+		+ strlen(date_time);
+
+    longVersion = (char *)alloc((unsigned)len);
+    if (longVersion == NULL)
+	longVersion = VIM_VERSION_LONG;
+    else
+	vim_snprintf(longVersion, len, msg,
+		      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);
+}
+# endif
+#else
+char	*longVersion = VIM_VERSION_LONG;
+
+    void
+init_longVersion(void)
+{
+    // nothing to do
+}
+#endif
+
+static void list_features(void);
+
+static char *(features[]) =
+{
+#ifdef HAVE_ACL
+	"+acl",
+#else
+	"-acl",
+#endif
+#ifdef AMIGA		/* only for Amiga systems */
+# ifdef FEAT_ARP
+	"+ARP",
+# else
+	"-ARP",
+# endif
+#endif
+#ifdef FEAT_ARABIC
+	"+arabic",
+#else
+	"-arabic",
+#endif
+	"+autocmd",
+#ifdef FEAT_AUTOCHDIR
+       "+autochdir",
+#else
+       "-autochdir",
+#endif
+#ifdef FEAT_AUTOSERVERNAME
+	"+autoservername",
+#else
+	"-autoservername",
+#endif
+#ifdef FEAT_BEVAL_GUI
+	"+balloon_eval",
+#else
+	"-balloon_eval",
+#endif
+#ifdef FEAT_BEVAL_TERM
+	"+balloon_eval_term",
+#else
+	"-balloon_eval_term",
+#endif
+#ifdef FEAT_BROWSE
+	"+browse",
+#else
+	"-browse",
+#endif
+#ifdef NO_BUILTIN_TCAPS
+	"-builtin_terms",
+#endif
+#ifdef SOME_BUILTIN_TCAPS
+	"+builtin_terms",
+#endif
+#ifdef ALL_BUILTIN_TCAPS
+	"++builtin_terms",
+#endif
+#ifdef FEAT_BYTEOFF
+	"+byte_offset",
+#else
+	"-byte_offset",
+#endif
+#ifdef FEAT_JOB_CHANNEL
+	"+channel",
+#else
+	"-channel",
+#endif
+#ifdef FEAT_CINDENT
+	"+cindent",
+#else
+	"-cindent",
+#endif
+#ifdef FEAT_CLIENTSERVER
+	"+clientserver",
+#else
+	"-clientserver",
+#endif
+#ifdef FEAT_CLIPBOARD
+	"+clipboard",
+#else
+	"-clipboard",
+#endif
+#ifdef FEAT_CMDL_COMPL
+	"+cmdline_compl",
+#else
+	"-cmdline_compl",
+#endif
+#ifdef FEAT_CMDHIST
+	"+cmdline_hist",
+#else
+	"-cmdline_hist",
+#endif
+#ifdef FEAT_CMDL_INFO
+	"+cmdline_info",
+#else
+	"-cmdline_info",
+#endif
+#ifdef FEAT_COMMENTS
+	"+comments",
+#else
+	"-comments",
+#endif
+#ifdef FEAT_CONCEAL
+	"+conceal",
+#else
+	"-conceal",
+#endif
+#ifdef FEAT_CRYPT
+	"+cryptv",
+#else
+	"-cryptv",
+#endif
+#ifdef FEAT_CSCOPE
+	"+cscope",
+#else
+	"-cscope",
+#endif
+	"+cursorbind",
+#ifdef CURSOR_SHAPE
+	"+cursorshape",
+#else
+	"-cursorshape",
+#endif
+#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)
+	"+dialog_con_gui",
+#else
+# if defined(FEAT_CON_DIALOG)
+	"+dialog_con",
+# else
+#  if defined(FEAT_GUI_DIALOG)
+	"+dialog_gui",
+#  else
+	"-dialog",
+#  endif
+# endif
+#endif
+#ifdef FEAT_DIFF
+	"+diff",
+#else
+	"-diff",
+#endif
+#ifdef FEAT_DIGRAPHS
+	"+digraphs",
+#else
+	"-digraphs",
+#endif
+#ifdef FEAT_GUI_W32
+# ifdef FEAT_DIRECTX
+	"+directx",
+# else
+	"-directx",
+# endif
+#endif
+#ifdef FEAT_DND
+	"+dnd",
+#else
+	"-dnd",
+#endif
+#ifdef EBCDIC
+	"+ebcdic",
+#else
+	"-ebcdic",
+#endif
+#ifdef FEAT_EMACS_TAGS
+	"+emacs_tags",
+#else
+	"-emacs_tags",
+#endif
+#ifdef FEAT_EVAL
+	"+eval",
+#else
+	"-eval",
+#endif
+	"+ex_extra",
+#ifdef FEAT_SEARCH_EXTRA
+	"+extra_search",
+#else
+	"-extra_search",
+#endif
+#ifdef FEAT_FKMAP
+	"+farsi",
+#else
+	"-farsi",
+#endif
+#ifdef FEAT_SEARCHPATH
+	"+file_in_path",
+#else
+	"-file_in_path",
+#endif
+#ifdef FEAT_FIND_ID
+	"+find_in_path",
+#else
+	"-find_in_path",
+#endif
+#ifdef FEAT_FLOAT
+	"+float",
+#else
+	"-float",
+#endif
+#ifdef FEAT_FOLDING
+	"+folding",
+#else
+	"-folding",
+#endif
+#ifdef FEAT_FOOTER
+	"+footer",
+#else
+	"-footer",
+#endif
+	    /* only interesting on Unix systems */
+#if !defined(USE_SYSTEM) && defined(UNIX)
+	"+fork()",
+#endif
+#ifdef FEAT_GETTEXT
+# ifdef DYNAMIC_GETTEXT
+	"+gettext/dyn",
+# else
+	"+gettext",
+# endif
+#else
+	"-gettext",
+#endif
+#ifdef FEAT_HANGULIN
+	"+hangul_input",
+#else
+	"-hangul_input",
+#endif
+#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)
+# ifdef DYNAMIC_ICONV
+	"+iconv/dyn",
+# else
+	"+iconv",
+# endif
+#else
+	"-iconv",
+#endif
+#ifdef FEAT_INS_EXPAND
+	"+insert_expand",
+#else
+	"-insert_expand",
+#endif
+#ifdef FEAT_JOB_CHANNEL
+	"+job",
+#else
+	"-job",
+#endif
+#ifdef FEAT_JUMPLIST
+	"+jumplist",
+#else
+	"-jumplist",
+#endif
+#ifdef FEAT_KEYMAP
+	"+keymap",
+#else
+	"-keymap",
+#endif
+#ifdef FEAT_EVAL
+	"+lambda",
+#else
+	"-lambda",
+#endif
+#ifdef FEAT_LANGMAP
+	"+langmap",
+#else
+	"-langmap",
+#endif
+#ifdef FEAT_LIBCALL
+	"+libcall",
+#else
+	"-libcall",
+#endif
+#ifdef FEAT_LINEBREAK
+	"+linebreak",
+#else
+	"-linebreak",
+#endif
+#ifdef FEAT_LISP
+	"+lispindent",
+#else
+	"-lispindent",
+#endif
+	"+listcmds",
+#ifdef FEAT_LOCALMAP
+	"+localmap",
+#else
+	"-localmap",
+#endif
+#ifdef FEAT_LUA
+# ifdef DYNAMIC_LUA
+	"+lua/dyn",
+# else
+	"+lua",
+# endif
+#else
+	"-lua",
+#endif
+#ifdef FEAT_MENU
+	"+menu",
+#else
+	"-menu",
+#endif
+#ifdef FEAT_SESSION
+	"+mksession",
+#else
+	"-mksession",
+#endif
+#ifdef FEAT_MODIFY_FNAME
+	"+modify_fname",
+#else
+	"-modify_fname",
+#endif
+#ifdef FEAT_MOUSE
+	"+mouse",
+#  ifdef FEAT_MOUSESHAPE
+	"+mouseshape",
+#  else
+	"-mouseshape",
+#  endif
+# else
+	"-mouse",
+#endif
+
+#if defined(UNIX) || defined(VMS)
+# ifdef FEAT_MOUSE_DEC
+	"+mouse_dec",
+# else
+	"-mouse_dec",
+# endif
+# ifdef FEAT_MOUSE_GPM
+	"+mouse_gpm",
+# else
+	"-mouse_gpm",
+# endif
+# ifdef FEAT_MOUSE_JSB
+	"+mouse_jsbterm",
+# else
+	"-mouse_jsbterm",
+# endif
+# ifdef FEAT_MOUSE_NET
+	"+mouse_netterm",
+# else
+	"-mouse_netterm",
+# endif
+#endif
+
+#ifdef __QNX__
+# ifdef FEAT_MOUSE_PTERM
+	"+mouse_pterm",
+# else
+	"-mouse_pterm",
+# endif
+#endif
+
+#if defined(UNIX) || defined(VMS)
+# ifdef FEAT_MOUSE_SGR
+	"+mouse_sgr",
+# else
+	"-mouse_sgr",
+# endif
+# ifdef FEAT_SYSMOUSE
+	"+mouse_sysmouse",
+# else
+	"-mouse_sysmouse",
+# endif
+# ifdef FEAT_MOUSE_URXVT
+	"+mouse_urxvt",
+# else
+	"-mouse_urxvt",
+# endif
+# ifdef FEAT_MOUSE_XTERM
+	"+mouse_xterm",
+# else
+	"-mouse_xterm",
+# endif
+#endif
+
+#ifdef FEAT_MBYTE_IME
+# ifdef DYNAMIC_IME
+	"+multi_byte_ime/dyn",
+# else
+	"+multi_byte_ime",
+# endif
+#else
+# ifdef FEAT_MBYTE
+	"+multi_byte",
+# else
+	"-multi_byte",
+# endif
+#endif
+#ifdef FEAT_MULTI_LANG
+	"+multi_lang",
+#else
+	"-multi_lang",
+#endif
+#ifdef FEAT_MZSCHEME
+# ifdef DYNAMIC_MZSCHEME
+	"+mzscheme/dyn",
+# else
+	"+mzscheme",
+# endif
+#else
+	"-mzscheme",
+#endif
+#ifdef FEAT_NETBEANS_INTG
+	"+netbeans_intg",
+#else
+	"-netbeans_intg",
+#endif
+#ifdef FEAT_NUM64
+	"+num64",
+#else
+	"-num64",
+#endif
+#ifdef FEAT_GUI_W32
+# ifdef FEAT_OLE
+	"+ole",
+# else
+	"-ole",
+# endif
+#endif
+#ifdef FEAT_EVAL
+	"+packages",
+#else
+	"-packages",
+#endif
+#ifdef FEAT_PATH_EXTRA
+	"+path_extra",
+#else
+	"-path_extra",
+#endif
+#ifdef FEAT_PERL
+# ifdef DYNAMIC_PERL
+	"+perl/dyn",
+# else
+	"+perl",
+# endif
+#else
+	"-perl",
+#endif
+#ifdef FEAT_PERSISTENT_UNDO
+	"+persistent_undo",
+#else
+	"-persistent_undo",
+#endif
+#ifdef FEAT_PRINTER
+# ifdef FEAT_POSTSCRIPT
+	"+postscript",
+# else
+	"-postscript",
+# endif
+	"+printer",
+#else
+	"-printer",
+#endif
+#ifdef FEAT_PROFILE
+	"+profile",
+#else
+	"-profile",
+#endif
+#ifdef FEAT_PYTHON
+# ifdef DYNAMIC_PYTHON
+	"+python/dyn",
+# else
+	"+python",
+# endif
+#else
+	"-python",
+#endif
+#ifdef FEAT_PYTHON3
+# ifdef DYNAMIC_PYTHON3
+	"+python3/dyn",
+# else
+	"+python3",
+# endif
+#else
+	"-python3",
+#endif
+#ifdef FEAT_QUICKFIX
+	"+quickfix",
+#else
+	"-quickfix",
+#endif
+#ifdef FEAT_RELTIME
+	"+reltime",
+#else
+	"-reltime",
+#endif
+#ifdef FEAT_RIGHTLEFT
+	"+rightleft",
+#else
+	"-rightleft",
+#endif
+#ifdef FEAT_RUBY
+# ifdef DYNAMIC_RUBY
+	"+ruby/dyn",
+# else
+	"+ruby",
+# endif
+#else
+	"-ruby",
+#endif
+	"+scrollbind",
+#ifdef FEAT_SIGNS
+	"+signs",
+#else
+	"-signs",
+#endif
+#ifdef FEAT_SMARTINDENT
+	"+smartindent",
+#else
+	"-smartindent",
+#endif
+#ifdef STARTUPTIME
+	"+startuptime",
+#else
+	"-startuptime",
+#endif
+#ifdef FEAT_STL_OPT
+	"+statusline",
+#else
+	"-statusline",
+#endif
+#ifdef FEAT_SUN_WORKSHOP
+	"+sun_workshop",
+#else
+	"-sun_workshop",
+#endif
+#ifdef FEAT_SYN_HL
+	"+syntax",
+#else
+	"-syntax",
+#endif
+	    /* only interesting on Unix systems */
+#if defined(USE_SYSTEM) && defined(UNIX)
+	"+system()",
+#endif
+#ifdef FEAT_TAG_BINS
+	"+tag_binary",
+#else
+	"-tag_binary",
+#endif
+#ifdef FEAT_TAG_OLDSTATIC
+	"+tag_old_static",
+#else
+	"-tag_old_static",
+#endif
+#ifdef FEAT_TAG_ANYWHITE
+	"+tag_any_white",
+#else
+	"-tag_any_white",
+#endif
+#ifdef FEAT_TCL
+# ifdef DYNAMIC_TCL
+	"+tcl/dyn",
+# else
+	"+tcl",
+# endif
+#else
+	"-tcl",
+#endif
+#ifdef FEAT_TERMGUICOLORS
+	"+termguicolors",
+#else
+	"-termguicolors",
+#endif
+#ifdef FEAT_TERMINAL
+	"+terminal",
+#else
+	"-terminal",
+#endif
+#if defined(UNIX)
+/* only Unix can have terminfo instead of termcap */
+# ifdef TERMINFO
+	"+terminfo",
+# else
+	"-terminfo",
+# endif
+#else		    /* unix always includes termcap support */
+# ifdef HAVE_TGETENT
+	"+tgetent",
+# else
+	"-tgetent",
+# endif
+#endif
+#ifdef FEAT_TERMRESPONSE
+	"+termresponse",
+#else
+	"-termresponse",
+#endif
+#ifdef FEAT_TEXTOBJ
+	"+textobjects",
+#else
+	"-textobjects",
+#endif
+#ifdef FEAT_TIMERS
+	"+timers",
+#else
+	"-timers",
+#endif
+#ifdef FEAT_TITLE
+	"+title",
+#else
+	"-title",
+#endif
+#ifdef FEAT_TOOLBAR
+	"+toolbar",
+#else
+	"-toolbar",
+#endif
+#ifdef FEAT_USR_CMDS
+	"+user_commands",
+#else
+	"-user_commands",
+#endif
+#ifdef FEAT_VARTABS
+	"+vartabs",
+#else
+	"-vartabs",
+#endif
+	"+vertsplit",
+#ifdef FEAT_VIRTUALEDIT
+	"+virtualedit",
+#else
+	"-virtualedit",
+#endif
+	"+visual",
+#ifdef FEAT_VISUALEXTRA
+	"+visualextra",
+#else
+	"-visualextra",
+#endif
+#ifdef FEAT_VIMINFO
+	"+viminfo",
+#else
+	"-viminfo",
+#endif
+	"+vreplace",
+#ifdef WIN3264
+# ifdef FEAT_VTP
+	"+vtp",
+# else
+	"-vtp",
+# endif
+#endif
+#ifdef FEAT_WILDIGN
+	"+wildignore",
+#else
+	"-wildignore",
+#endif
+#ifdef FEAT_WILDMENU
+	"+wildmenu",
+#else
+	"-wildmenu",
+#endif
+	"+windows",
+#ifdef FEAT_WRITEBACKUP
+	"+writebackup",
+#else
+	"-writebackup",
+#endif
+#if defined(UNIX) || defined(VMS)
+# ifdef FEAT_X11
+	"+X11",
+# else
+	"-X11",
+# endif
+#endif
+#ifdef FEAT_XFONTSET
+	"+xfontset",
+#else
+	"-xfontset",
+#endif
+#ifdef FEAT_XIM
+	"+xim",
+#else
+	"-xim",
+#endif
+#ifdef WIN3264
+# ifdef FEAT_XPM_W32
+	"+xpm_w32",
+# else
+	"-xpm_w32",
+# endif
+#else
+# ifdef HAVE_XPM
+	"+xpm",
+# else
+	"-xpm",
+# endif
+#endif
+#if defined(UNIX) || defined(VMS)
+# ifdef USE_XSMP_INTERACT
+	"+xsmp_interact",
+# else
+#  ifdef USE_XSMP
+	"+xsmp",
+#  else
+	"-xsmp",
+#  endif
+# endif
+# ifdef FEAT_XCLIPBOARD
+	"+xterm_clipboard",
+# else
+	"-xterm_clipboard",
+# endif
+#endif
+#ifdef FEAT_XTERM_SAVE
+	"+xterm_save",
+#else
+	"-xterm_save",
+#endif
+	NULL
+};
+
+static int included_patches[] =
+{   /* Add new patch number below this line */
+/**/
+    347,
+/**/
+    346,
+/**/
+    345,
+/**/
+    344,
+/**/
+    343,
+/**/
+    342,
+/**/
+    341,
+/**/
+    340,
+/**/
+    339,
+/**/
+    338,
+/**/
+    337,
+/**/
+    336,
+/**/
+    335,
+/**/
+    334,
+/**/
+    333,
+/**/
+    332,
+/**/
+    331,
+/**/
+    330,
+/**/
+    329,
+/**/
+    328,
+/**/
+    327,
+/**/
+    326,
+/**/
+    325,
+/**/
+    324,
+/**/
+    323,
+/**/
+    322,
+/**/
+    321,
+/**/
+    320,
+/**/
+    319,
+/**/
+    318,
+/**/
+    317,
+/**/
+    316,
+/**/
+    315,
+/**/
+    314,
+/**/
+    313,
+/**/
+    312,
+/**/
+    311,
+/**/
+    310,
+/**/
+    309,
+/**/
+    308,
+/**/
+    307,
+/**/
+    306,
+/**/
+    305,
+/**/
+    304,
+/**/
+    303,
+/**/
+    302,
+/**/
+    301,
+/**/
+    300,
+/**/
+    299,
+/**/
+    298,
+/**/
+    297,
+/**/
+    296,
+/**/
+    295,
+/**/
+    294,
+/**/
+    293,
+/**/
+    292,
+/**/
+    291,
+/**/
+    290,
+/**/
+    289,
+/**/
+    288,
+/**/
+    287,
+/**/
+    286,
+/**/
+    285,
+/**/
+    284,
+/**/
+    283,
+/**/
+    282,
+/**/
+    281,
+/**/
+    280,
+/**/
+    279,
+/**/
+    278,
+/**/
+    277,
+/**/
+    276,
+/**/
+    275,
+/**/
+    274,
+/**/
+    273,
+/**/
+    272,
+/**/
+    271,
+/**/
+    270,
+/**/
+    269,
+/**/
+    268,
+/**/
+    267,
+/**/
+    266,
+/**/
+    265,
+/**/
+    264,
+/**/
+    263,
+/**/
+    262,
+/**/
+    261,
+/**/
+    260,
+/**/
+    259,
+/**/
+    258,
+/**/
+    257,
+/**/
+    256,
+/**/
+    255,
+/**/
+    254,
+/**/
+    253,
+/**/
+    252,
+/**/
+    251,
+/**/
+    250,
+/**/
+    249,
+/**/
+    248,
+/**/
+    247,
+/**/
+    246,
+/**/
+    245,
+/**/
+    244,
+/**/
+    243,
+/**/
+    242,
+/**/
+    241,
+/**/
+    240,
+/**/
+    239,
+/**/
+    238,
+/**/
+    237,
+/**/
+    236,
+/**/
+    235,
+/**/
+    234,
+/**/
+    233,
+/**/
+    232,
+/**/
+    231,
+/**/
+    230,
+/**/
+    229,
+/**/
+    228,
+/**/
+    227,
+/**/
+    226,
+/**/
+    225,
+/**/
+    224,
+/**/
+    223,
+/**/
+    222,
+/**/
+    221,
+/**/
+    220,
+/**/
+    219,
+/**/
+    218,
+/**/
+    217,
+/**/
+    216,
+/**/
+    215,
+/**/
+    214,
+/**/
+    213,
+/**/
+    212,
+/**/
+    211,
+/**/
+    210,
+/**/
+    209,
+/**/
+    208,
+/**/
+    207,
+/**/
+    206,
+/**/
+    205,
+/**/
+    204,
+/**/
+    203,
+/**/
+    202,
+/**/
+    201,
+/**/
+    200,
+/**/
+    199,
+/**/
+    198,
+/**/
+    197,
+/**/
+    196,
+/**/
+    195,
+/**/
+    194,
+/**/
+    193,
+/**/
+    192,
+/**/
+    191,
+/**/
+    190,
+/**/
+    189,
+/**/
+    188,
+/**/
+    187,
+/**/
+    186,
+/**/
+    185,
+/**/
+    184,
+/**/
+    183,
+/**/
+    182,
+/**/
+    181,
+/**/
+    180,
+/**/
+    179,
+/**/
+    178,
+/**/
+    177,
+/**/
+    176,
+/**/
+    175,
+/**/
+    174,
+/**/
+    173,
+/**/
+    172,
+/**/
+    171,
+/**/
+    170,
+/**/
+    169,
+/**/
+    168,
+/**/
+    167,
+/**/
+    166,
+/**/
+    165,
+/**/
+    164,
+/**/
+    163,
+/**/
+    162,
+/**/
+    161,
+/**/
+    160,
+/**/
+    159,
+/**/
+    158,
+/**/
+    157,
+/**/
+    156,
+/**/
+    155,
+/**/
+    154,
+/**/
+    153,
+/**/
+    152,
+/**/
+    151,
+/**/
+    150,
+/**/
+    149,
+/**/
+    148,
+/**/
+    147,
+/**/
+    146,
+/**/
+    145,
+/**/
+    144,
+/**/
+    143,
+/**/
+    142,
+/**/
+    141,
+/**/
+    140,
+/**/
+    139,
+/**/
+    138,
+/**/
+    137,
+/**/
+    136,
+/**/
+    135,
+/**/
+    134,
+/**/
+    133,
+/**/
+    132,
+/**/
+    131,
+/**/
+    130,
+/**/
+    129,
+/**/
+    128,
+/**/
+    127,
+/**/
+    126,
+/**/
+    125,
+/**/
+    124,
+/**/
+    123,
+/**/
+    122,
+/**/
+    121,
+/**/
+    120,
+/**/
+    119,
+/**/
+    118,
+/**/
+    117,
+/**/
+    116,
+/**/
+    115,
+/**/
+    114,
+/**/
+    113,
+/**/
+    112,
+/**/
+    111,
+/**/
+    110,
+/**/
+    109,
+/**/
+    108,
+/**/
+    107,
+/**/
+    106,
+/**/
+    105,
+/**/
+    104,
+/**/
+    103,
+/**/
+    102,
+/**/
+    101,
+/**/
+    100,
+/**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    93,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    89,
+/**/
+    88,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    74,
+/**/
+    73,
+/**/
+    72,
+/**/
+    71,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    65,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    57,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    45,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    32,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    27,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    5,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
+    0
+};
+
+/*
+ * Place to put a short description when adding a feature with a patch.
+ * Keep it short, e.g.,: "relative numbers", "persistent undo".
+ * Also add a comment marker to separate the lines.
+ * See the official Vim patches for the diff format: It must use a context of
+ * one line only.  Create it by hand or use "diff -C2" and edit the patch.
+ */
+static char *(extra_patches[]) =
+{   /* Add your patch description below this line */
+/**/
+    NULL
+};
+
+    int
+highest_patch(void)
+{
+    int		i;
+    int		h = 0;
+
+    for (i = 0; included_patches[i] != 0; ++i)
+	if (included_patches[i] > h)
+	    h = included_patches[i];
+    return h;
+}
+
+#if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Return TRUE if patch "n" has been included.
+ */
+    int
+has_patch(int n)
+{
+    int		i;
+
+    for (i = 0; included_patches[i] != 0; ++i)
+	if (included_patches[i] == n)
+	    return TRUE;
+    return FALSE;
+}
+#endif
+
+    void
+ex_version(exarg_T *eap)
+{
+    /*
+     * Ignore a ":version 9.99" command.
+     */
+    if (*eap->arg == NUL)
+    {
+	msg_putchar('\n');
+	list_version();
+    }
+}
+
+/*
+ * Output a string for the version message.  If it's going to wrap, output a
+ * newline, unless the message is too long to fit on the screen anyway.
+ * When "wrap" is TRUE wrap the string in [].
+ */
+    static void
+version_msg_wrap(char_u *s, int wrap)
+{
+    int		len = (int)vim_strsize(s) + (wrap ? 2 : 0);
+
+    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns
+								&& *s != '\n')
+	msg_putchar('\n');
+    if (!got_int)
+    {
+	if (wrap)
+	    MSG_PUTS("[");
+	MSG_PUTS(s);
+	if (wrap)
+	    MSG_PUTS("]");
+    }
+}
+
+    static void
+version_msg(char *s)
+{
+    version_msg_wrap((char_u *)s, FALSE);
+}
+
+/*
+ * List all features aligned in columns, dictionary style.
+ */
+    static void
+list_features(void)
+{
+    list_in_columns((char_u **)features, -1, -1);
+}
+
+/*
+ * List string items nicely aligned in columns.
+ * When "size" is < 0 then the last entry is marked with NULL.
+ * The entry with index "current" is inclosed in [].
+ */
+    void
+list_in_columns(char_u **items, int size, int current)
+{
+    int		i;
+    int		ncol;
+    int		nrow;
+    int		item_count = 0;
+    int		width = 0;
+
+    /* Find the length of the longest item, use that + 1 as the column
+     * width. */
+    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)
+    {
+	int l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);
+
+	if (l > width)
+	    width = l;
+	++item_count;
+    }
+    width += 1;
+
+    if (Columns < width)
+    {
+	/* Not enough screen columns - show one per line */
+	for (i = 0; items[i] != NULL; ++i)
+	{
+	    version_msg_wrap(items[i], i == current);
+	    if (msg_col > 0)
+		msg_putchar('\n');
+	}
+	return;
+    }
+
+    /* The rightmost column doesn't need a separator.
+     * Sacrifice it to fit in one more column if possible. */
+    ncol = (int) (Columns + 1) / width;
+    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);
+
+    /* i counts columns then rows.  idx counts rows then columns. */
+    for (i = 0; !got_int && i < nrow * ncol; ++i)
+    {
+	int idx = (i / ncol) + (i % ncol) * nrow;
+
+	if (idx < item_count)
+	{
+	    int last_col = (i + 1) % ncol == 0;
+
+	    if (idx == current)
+		msg_putchar('[');
+	    msg_puts(items[idx]);
+	    if (idx == current)
+		msg_putchar(']');
+	    if (last_col)
+	    {
+		if (msg_col > 0)
+		    msg_putchar('\n');
+	    }
+	    else
+	    {
+		while (msg_col % width)
+		    msg_putchar(' ');
+	    }
+	}
+	else
+	{
+	    if (msg_col > 0)
+		msg_putchar('\n');
+	}
+    }
+}
+
+    void
+list_version(void)
+{
+    int		i;
+    int		first;
+    char	*s = "";
+
+    /*
+     * When adding features here, don't forget to update the list of
+     * internal variables in eval.c!
+     */
+    init_longVersion();
+    MSG(longVersion);
+#ifdef WIN3264
+# ifdef FEAT_GUI_W32
+#  ifdef _WIN64
+    MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
+#  else
+    MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
+#  endif
+# ifdef FEAT_OLE
+    MSG_PUTS(_(" with OLE support"));
+# endif
+# else
+#  ifdef _WIN64
+    MSG_PUTS(_("\nMS-Windows 64-bit console version"));
+#  else
+    MSG_PUTS(_("\nMS-Windows 32-bit console version"));
+#  endif
+# endif
+#endif
+#if defined(MACOS_X)
+# if defined(MACOS_X_DARWIN)
+    MSG_PUTS(_("\nmacOS version"));
+# else
+    MSG_PUTS(_("\nmacOS version w/o darwin feat."));
+# endif
+#endif
+
+#ifdef VMS
+    MSG_PUTS(_("\nOpenVMS version"));
+# ifdef HAVE_PATHDEF
+    if (*compiled_arch != NUL)
+    {
+	MSG_PUTS(" - ");
+	MSG_PUTS(compiled_arch);
+    }
+# endif
+
+#endif
+
+    /* Print the list of patch numbers if there is at least one. */
+    /* Print a range when patches are consecutive: "1-10, 12, 15-40, 42-45" */
+    if (included_patches[0] != 0)
+    {
+	MSG_PUTS(_("\nIncluded patches: "));
+	first = -1;
+	/* find last one */
+	for (i = 0; included_patches[i] != 0; ++i)
+	    ;
+	while (--i >= 0)
+	{
+	    if (first < 0)
+		first = included_patches[i];
+	    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)
+	    {
+		MSG_PUTS(s);
+		s = ", ";
+		msg_outnum((long)first);
+		if (first != included_patches[i])
+		{
+		    MSG_PUTS("-");
+		    msg_outnum((long)included_patches[i]);
+		}
+		first = -1;
+	    }
+	}
+    }
+
+    /* Print the list of extra patch descriptions if there is at least one. */
+    if (extra_patches[0] != NULL)
+    {
+	MSG_PUTS(_("\nExtra patches: "));
+	s = "";
+	for (i = 0; extra_patches[i] != NULL; ++i)
+	{
+	    MSG_PUTS(s);
+	    s = ", ";
+	    MSG_PUTS(extra_patches[i]);
+	}
+    }
+
+#ifdef MODIFIED_BY
+    MSG_PUTS("\n");
+    MSG_PUTS(_("Modified by "));
+    MSG_PUTS(MODIFIED_BY);
+#endif
+
+#ifdef HAVE_PATHDEF
+    if (*compiled_user != NUL || *compiled_sys != NUL)
+    {
+	MSG_PUTS(_("\nCompiled "));
+	if (*compiled_user != NUL)
+	{
+	    MSG_PUTS(_("by "));
+	    MSG_PUTS(compiled_user);
+	}
+	if (*compiled_sys != NUL)
+	{
+	    MSG_PUTS("@");
+	    MSG_PUTS(compiled_sys);
+	}
+    }
+#endif
+
+#ifdef FEAT_HUGE
+    MSG_PUTS(_("\nHuge version "));
+#else
+# ifdef FEAT_BIG
+    MSG_PUTS(_("\nBig version "));
+# else
+#  ifdef FEAT_NORMAL
+    MSG_PUTS(_("\nNormal version "));
+#  else
+#   ifdef FEAT_SMALL
+    MSG_PUTS(_("\nSmall version "));
+#   else
+    MSG_PUTS(_("\nTiny version "));
+#   endif
+#  endif
+# endif
+#endif
+#ifndef FEAT_GUI
+    MSG_PUTS(_("without GUI."));
+#else
+# ifdef FEAT_GUI_GTK
+#  ifdef USE_GTK3
+    MSG_PUTS(_("with GTK3 GUI."));
+#  else
+#   ifdef FEAT_GUI_GNOME
+     MSG_PUTS(_("with GTK2-GNOME GUI."));
+#   else
+     MSG_PUTS(_("with GTK2 GUI."));
+#   endif
+# endif
+# else
+#  ifdef FEAT_GUI_MOTIF
+    MSG_PUTS(_("with X11-Motif GUI."));
+#  else
+#   ifdef FEAT_GUI_ATHENA
+#    ifdef FEAT_GUI_NEXTAW
+    MSG_PUTS(_("with X11-neXtaw GUI."));
+#    else
+    MSG_PUTS(_("with X11-Athena GUI."));
+#    endif
+#   else
+#     ifdef FEAT_GUI_PHOTON
+    MSG_PUTS(_("with Photon GUI."));
+#     else
+#      if defined(MSWIN)
+    MSG_PUTS(_("with GUI."));
+#      else
+#	if defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON
+    MSG_PUTS(_("with Carbon GUI."));
+#	else
+#	 if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX
+    MSG_PUTS(_("with Cocoa GUI."));
+#	 else
+#	 endif
+#	endif
+#      endif
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+    version_msg(_("  Features included (+) or not (-):\n"));
+
+    list_features();
+
+#ifdef SYS_VIMRC_FILE
+    version_msg(_("   system vimrc file: \""));
+    version_msg(SYS_VIMRC_FILE);
+    version_msg("\"\n");
+#endif
+#ifdef USR_VIMRC_FILE
+    version_msg(_("     user vimrc file: \""));
+    version_msg(USR_VIMRC_FILE);
+    version_msg("\"\n");
+#endif
+#ifdef USR_VIMRC_FILE2
+    version_msg(_(" 2nd user vimrc file: \""));
+    version_msg(USR_VIMRC_FILE2);
+    version_msg("\"\n");
+#endif
+#ifdef USR_VIMRC_FILE3
+    version_msg(_(" 3rd user vimrc file: \""));
+    version_msg(USR_VIMRC_FILE3);
+    version_msg("\"\n");
+#endif
+#ifdef USR_EXRC_FILE
+    version_msg(_("      user exrc file: \""));
+    version_msg(USR_EXRC_FILE);
+    version_msg("\"\n");
+#endif
+#ifdef USR_EXRC_FILE2
+    version_msg(_("  2nd user exrc file: \""));
+    version_msg(USR_EXRC_FILE2);
+    version_msg("\"\n");
+#endif
+#ifdef FEAT_GUI
+# ifdef SYS_GVIMRC_FILE
+    version_msg(_("  system gvimrc file: \""));
+    version_msg(SYS_GVIMRC_FILE);
+    version_msg("\"\n");
+# endif
+    version_msg(_("    user gvimrc file: \""));
+    version_msg(USR_GVIMRC_FILE);
+    version_msg("\"\n");
+# ifdef USR_GVIMRC_FILE2
+    version_msg(_("2nd user gvimrc file: \""));
+    version_msg(USR_GVIMRC_FILE2);
+    version_msg("\"\n");
+# endif
+# ifdef USR_GVIMRC_FILE3
+    version_msg(_("3rd user gvimrc file: \""));
+    version_msg(USR_GVIMRC_FILE3);
+    version_msg("\"\n");
+# endif
+#endif
+    version_msg(_("       defaults file: \""));
+    version_msg(VIM_DEFAULTS_FILE);
+    version_msg("\"\n");
+#ifdef FEAT_GUI
+# ifdef SYS_MENU_FILE
+    version_msg(_("    system menu file: \""));
+    version_msg(SYS_MENU_FILE);
+    version_msg("\"\n");
+# endif
+#endif
+#ifdef HAVE_PATHDEF
+    if (*default_vim_dir != NUL)
+    {
+	version_msg(_("  fall-back for $VIM: \""));
+	version_msg((char *)default_vim_dir);
+	version_msg("\"\n");
+    }
+    if (*default_vimruntime_dir != NUL)
+    {
+	version_msg(_(" f-b for $VIMRUNTIME: \""));
+	version_msg((char *)default_vimruntime_dir);
+	version_msg("\"\n");
+    }
+    version_msg(_("Compilation: "));
+    version_msg((char *)all_cflags);
+    version_msg("\n");
+#ifdef VMS
+    if (*compiler_version != NUL)
+    {
+	version_msg(_("Compiler: "));
+	version_msg((char *)compiler_version);
+	version_msg("\n");
+    }
+#endif
+    version_msg(_("Linking: "));
+    version_msg((char *)all_lflags);
+#endif
+#ifdef DEBUG
+    version_msg("\n");
+    version_msg(_("  DEBUG BUILD"));
+#endif
+}
+
+static void do_intro_line(int row, char_u *mesg, int add_version, int attr);
+
+/*
+ * Show the intro message when not editing a file.
+ */
+    void
+maybe_intro_message(void)
+{
+    if (BUFEMPTY()
+	    && curbuf->b_fname == NULL
+	    && firstwin->w_next == NULL
+	    && vim_strchr(p_shm, SHM_INTRO) == NULL)
+	intro_message(FALSE);
+}
+
+/*
+ * Give an introductory message about Vim.
+ * Only used when starting Vim on an empty file, without a file name.
+ * Or with the ":intro" command (for Sven :-).
+ */
+    void
+intro_message(
+    int		colon)		/* TRUE for ":intro" */
+{
+    int		i;
+    int		row;
+    int		blanklines;
+    int		sponsor;
+    char	*p;
+    static char	*(lines[]) =
+    {
+	N_("VIM - Vi IMproved"),
+	"",
+	N_("version "),
+	N_("by Bram Moolenaar et al."),
+#ifdef MODIFIED_BY
+	" ",
+#endif
+	N_("Vim is open source and freely distributable"),
+	"",
+	N_("Help poor children in Uganda!"),
+	N_("type  :help iccf<Enter>       for information "),
+	"",
+	N_("type  :q<Enter>               to exit         "),
+	N_("type  :help<Enter>  or  <F1>  for on-line help"),
+	N_("type  :help version8<Enter>   for version info"),
+	NULL,
+	"",
+	N_("Running in Vi compatible mode"),
+	N_("type  :set nocp<Enter>        for Vim defaults"),
+	N_("type  :help cp-default<Enter> for info on this"),
+    };
+#ifdef FEAT_GUI
+    static char	*(gui_lines[]) =
+    {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+#ifdef MODIFIED_BY
+	NULL,
+#endif
+	NULL,
+	NULL,
+	NULL,
+	N_("menu  Help->Orphans           for information    "),
+	NULL,
+	N_("Running modeless, typed text is inserted"),
+	N_("menu  Edit->Global Settings->Toggle Insert Mode  "),
+	N_("                              for two modes      "),
+	NULL,
+	NULL,
+	NULL,
+	N_("menu  Edit->Global Settings->Toggle Vi Compatible"),
+	N_("                              for Vim defaults   "),
+    };
+#endif
+
+    /* blanklines = screen height - # message lines */
+    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);
+    if (!p_cp)
+	blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
+
+    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */
+    if (p_ls > 1)
+	blanklines -= Rows - topframe->fr_height;
+    if (blanklines < 0)
+	blanklines = 0;
+
+    /* Show the sponsor and register message one out of four times, the Uganda
+     * message two out of four times. */
+    sponsor = (int)time(NULL);
+    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);
+
+    /* start displaying the message lines after half of the blank lines */
+    row = blanklines / 2;
+    if ((row >= 2 && Columns >= 50) || colon)
+    {
+	for (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)
+	{
+	    p = lines[i];
+#ifdef FEAT_GUI
+	    if (p_im && gui.in_use && gui_lines[i] != NULL)
+		p = gui_lines[i];
+#endif
+	    if (p == NULL)
+	    {
+		if (!p_cp)
+		    break;
+		continue;
+	    }
+	    if (sponsor != 0)
+	    {
+		if (strstr(p, "children") != NULL)
+		    p = sponsor < 0
+			? N_("Sponsor Vim development!")
+			: N_("Become a registered Vim user!");
+		else if (strstr(p, "iccf") != NULL)
+		    p = sponsor < 0
+			? N_("type  :help sponsor<Enter>    for information ")
+			: N_("type  :help register<Enter>   for information ");
+		else if (strstr(p, "Orphans") != NULL)
+		    p = N_("menu  Help->Sponsor/Register  for information    ");
+	    }
+	    if (*p != NUL)
+		do_intro_line(row, (char_u *)_(p), i == 2, 0);
+	    ++row;
+	}
+    }
+
+    /* Make the wait-return message appear just below the text. */
+    if (colon)
+	msg_row = row;
+}
+
+    static void
+do_intro_line(
+    int		row,
+    char_u	*mesg,
+    int		add_version,
+    int		attr)
+{
+    char_u	vers[20];
+    int		col;
+    char_u	*p;
+    int		l;
+    int		clen;
+#ifdef MODIFIED_BY
+# define MODBY_LEN 150
+    char_u	modby[MODBY_LEN];
+
+    if (*mesg == ' ')
+    {
+	vim_strncpy(modby, (char_u *)_("Modified by "), MODBY_LEN - 1);
+	l = (int)STRLEN(modby);
+	vim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);
+	mesg = modby;
+    }
+#endif
+
+    /* Center the message horizontally. */
+    col = vim_strsize(mesg);
+    if (add_version)
+    {
+	STRCPY(vers, mediumVersion);
+	if (highest_patch())
+	{
+	    /* Check for 9.9x or 9.9xx, alpha/beta version */
+	    if (isalpha((int)vers[3]))
+	    {
+		int len = (isalpha((int)vers[4])) ? 5 : 4;
+		sprintf((char *)vers + len, ".%d%s", highest_patch(),
+							 mediumVersion + len);
+	    }
+	    else
+		sprintf((char *)vers + 3, ".%d", highest_patch());
+	}
+	col += (int)STRLEN(vers);
+    }
+    col = (Columns - col) / 2;
+    if (col < 0)
+	col = 0;
+
+    /* Split up in parts to highlight <> items differently. */
+    for (p = mesg; *p != NUL; p += l)
+    {
+	clen = 0;
+	for (l = 0; p[l] != NUL
+			 && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)
+	{
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+	    {
+		clen += ptr2cells(p + l);
+		l += (*mb_ptr2len)(p + l) - 1;
+	    }
+	    else
+#endif
+		clen += byte2cells(p[l]);
+	}
+	screen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);
+	col += clen;
+    }
+
+    /* Add the version number to the version line. */
+    if (add_version)
+	screen_puts(vers, row, col, 0);
+}
+
+/*
+ * ":intro": clear screen, display intro screen and wait for return.
+ */
+    void
+ex_intro(exarg_T *eap UNUSED)
+{
+    screenclear();
+    intro_message(TRUE);
+    wait_return(TRUE);
+}
diff --git a/src/vim.h b/src/vim.h
index ece5414..3048866 100644
--- a/src/vim.h
+++ b/src/vim.h
@@ -107,6 +107,7 @@ typedef double _Float128;
     || defined(FEAT_GUI_ATHENA) \
     || defined(FEAT_GUI_MAC) \
     || defined(FEAT_GUI_W32) \
+    || defined(FEAT_GUI_HAIKU) \
     || defined(FEAT_GUI_PHOTON)
 # define FEAT_GUI_ENABLED  /* also defined with NO_X11_INCLUDES */
 # if !defined(FEAT_GUI) && !defined(NO_X11_INCLUDES)
@@ -241,6 +242,11 @@ typedef double _Float128;
 # include "os_beos.h"
 #endif
 
+#ifdef __HAIKU__
+# include "os_haiku.h"
+# define __ARGS(x)  x
+#endif
+
 #if (defined(UNIX) || defined(VMS)) \
 	&& (!defined(MACOS_X) || defined(HAVE_CONFIG_H))
 # include "os_unix.h"	    /* bring lots of system header files */
@@ -2076,6 +2082,9 @@ typedef struct VimClipboard
     int_u	format;		/* Vim's own special clipboard format */
     int_u	format_raw;	/* Vim's raw text clipboard format */
 # endif
+# ifdef FEAT_GUI_HAIKU
+				/* no clipboard at the moment. TODO???? */
+# endif
 } VimClipboard;
 #else
 typedef int VimClipboard;	/* This is required for the prototypes. */
@@ -2120,7 +2129,7 @@ typedef enum {
  * been seen at that stage.  But it must be before globals.h, where error_ga
  * is declared. */
 #if !defined(FEAT_GUI_W32) && !defined(FEAT_GUI_X11) \
-	&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC) && !defined(PROTO)
+	&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC) && !defined(PROTO) && !defined(FEAT_GUI_HAIKU)
 # define mch_errmsg(str)	fprintf(stderr, "%s", (str))
 # define display_errors()	fflush(stderr)
 # define mch_msg(str)		printf("%s", (str))
diff --git a/b/src/vim.h.orig b/src/vim.h.orig
new file mode 100644
index 0000000..ece5414
--- /dev/null
+++ b/src/vim.h.orig
@@ -0,0 +1,2602 @@
+/* vi:set ts=8 sts=4 sw=4 noet:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+#ifndef VIM__H
+# define VIM__H
+
+#ifdef PROTO
+/* cproto runs into trouble when this type is missing */
+typedef double _Float128;
+#endif
+
+/* use fastcall for Borland, when compiling for Win32 */
+#if defined(__BORLANDC__) && defined(WIN32) && !defined(DEBUG)
+#if defined(FEAT_PERL) || \
+    defined(FEAT_PYTHON) || \
+    defined(FEAT_PYTHON3) || \
+    defined(FEAT_RUBY) || \
+    defined(FEAT_TCL) || \
+    defined(FEAT_MZSCHEME) || \
+    defined(DYNAMIC_GETTEXT) || \
+    defined(DYNAMIC_ICONV) || \
+    defined(DYNAMIC_IME) || \
+    defined(XPM)
+  #pragma option -pc
+# else
+  #pragma option -pr
+# endif
+#endif
+
+#if defined(WIN32) || defined(_WIN64)
+# include "vimio.h"
+#endif
+
+/* ============ the header file puzzle (ca. 50-100 pieces) ========= */
+
+#ifdef HAVE_CONFIG_H	/* GNU autoconf (or something else) was here */
+# include "auto/config.h"
+# define HAVE_PATHDEF
+
+/*
+ * Check if configure correctly managed to find sizeof(int).  If this failed,
+ * it becomes zero.  This is likely a problem of not being able to run the
+ * test program.  Other items from configure may also be wrong then!
+ */
+# if (VIM_SIZEOF_INT == 0)
+    Error: configure did not run properly.  Check auto/config.log.
+# endif
+
+/*
+ * Cygwin may have fchdir() in a newer release, but in most versions it
+ * doesn't work well and avoiding it keeps the binary backward compatible.
+ */
+# if defined(__CYGWIN32__) && defined(HAVE_FCHDIR)
+#  undef HAVE_FCHDIR
+# endif
+
+/* We may need to define the uint32_t on non-Unix system, but using the same
+ * identifier causes conflicts.  Therefore use UINT32_T. */
+# define UINT32_TYPEDEF uint32_t
+#endif
+
+#if !defined(UINT32_TYPEDEF)
+# if defined(uint32_t)  /* this doesn't catch typedefs, unfortunately */
+#  define UINT32_TYPEDEF uint32_t
+# else
+  /* Fall back to assuming unsigned int is 32 bit.  If this is wrong then the
+   * test in blowfish.c will fail. */
+#  define UINT32_TYPEDEF unsigned int
+# endif
+#endif
+
+/* user ID of root is usually zero, but not for everybody */
+#ifdef __TANDEM
+# ifndef _TANDEM_SOURCE
+#  define _TANDEM_SOURCE
+# endif
+# include <floss.h>
+# define ROOT_UID 65535
+# define OLDXAW
+# if (_TANDEM_ARCH_ == 2 && __H_Series_RVU >= 621)
+#  define SA_ONSTACK_COMPATIBILITY
+# endif
+#else
+# define ROOT_UID 0
+#endif
+
+/*
+ * MACOS_X	    compiling for Mac OS X
+ * MACOS_X_DARWIN   integrating the darwin feature into MACOS_X
+ */
+#if defined(MACOS_X_DARWIN) && !defined(MACOS_X)
+# define MACOS_X
+#endif
+/* Unless made through the Makefile enforce GUI on Mac */
+#if defined(MACOS_X) && !defined(HAVE_CONFIG_H)
+# define UNIX
+# define FEAT_GUI_MAC
+#endif
+
+#if defined(FEAT_GUI_MOTIF) \
+    || defined(FEAT_GUI_GTK) \
+    || defined(FEAT_GUI_ATHENA) \
+    || defined(FEAT_GUI_MAC) \
+    || defined(FEAT_GUI_W32) \
+    || defined(FEAT_GUI_PHOTON)
+# define FEAT_GUI_ENABLED  /* also defined with NO_X11_INCLUDES */
+# if !defined(FEAT_GUI) && !defined(NO_X11_INCLUDES)
+#  define FEAT_GUI
+# endif
+#endif
+
+/* Check support for rendering options */
+#ifdef FEAT_GUI
+# if defined(FEAT_DIRECTX)
+#  define FEAT_RENDER_OPTIONS
+# endif
+#endif
+
+/* Visual Studio 2005 has 'deprecated' many of the standard CRT functions */
+#if _MSC_VER >= 1400
+# define _CRT_SECURE_NO_DEPRECATE
+# define _CRT_NONSTDC_NO_DEPRECATE
+#endif
+
+#if defined(FEAT_GUI_W32)
+# define FEAT_GUI_MSWIN
+#endif
+#if defined(WIN32) || defined(_WIN64)
+# define MSWIN
+#endif
+/* Practically everything is common to both Win32 and Win64 */
+#if defined(WIN32) || defined(_WIN64)
+# define WIN3264
+#endif
+
+/*
+ * VIM_SIZEOF_INT is used in feature.h, and the system-specific included files
+ * need items from feature.h.  Therefore define VIM_SIZEOF_INT here.
+ */
+#ifdef WIN3264
+# define VIM_SIZEOF_INT 4
+#endif
+
+#ifdef AMIGA
+  /* Be conservative about sizeof(int). It could be 4 too. */
+# ifndef FEAT_GUI_GTK	/* avoid problems when generating prototypes */
+#  ifdef __GNUC__
+#   define VIM_SIZEOF_INT	4
+#  else
+#   define VIM_SIZEOF_INT	2
+#  endif
+# endif
+#endif
+#if defined(MACOS_X) && !defined(HAVE_CONFIG_H)
+#  define VIM_SIZEOF_INT __SIZEOF_INT__
+#endif
+
+/*
+ * #defines for optionals and features
+ * Also defines FEAT_TINY, FEAT_SMALL, etc. when FEAT_HUGE is defined.
+ */
+#include "feature.h"
+
+#if defined(MACOS_X_DARWIN)
+# if defined(FEAT_SMALL) && !defined(FEAT_CLIPBOARD)
+#  define FEAT_CLIPBOARD
+# endif
+# if defined(FEAT_SMALL) && !defined(FEAT_MOUSE)
+#  define FEAT_MOUSE
+# endif
+#endif
+
+/* +x11 is only enabled when it's both available and wanted. */
+#if defined(HAVE_X11) && defined(WANT_X11)
+# define FEAT_X11
+#endif
+
+#ifdef NO_X11_INCLUDES
+    /* In os_mac_conv.c and os_macosx.m NO_X11_INCLUDES is defined to avoid
+     * X11 headers.  Disable all X11 related things to avoid conflicts. */
+# ifdef FEAT_X11
+#  undef FEAT_X11
+# endif
+# ifdef FEAT_GUI_X11
+#  undef FEAT_GUI_X11
+# endif
+# ifdef FEAT_XCLIPBOARD
+#  undef FEAT_XCLIPBOARD
+# endif
+# ifdef FEAT_GUI_MOTIF
+#  undef FEAT_GUI_MOTIF
+# endif
+# ifdef FEAT_GUI_ATHENA
+#  undef FEAT_GUI_ATHENA
+# endif
+# ifdef FEAT_GUI_GTK
+#  undef FEAT_GUI_GTK
+# endif
+# ifdef FEAT_BEVAL_TIP
+#  undef FEAT_BEVAL_TIP
+# endif
+# ifdef FEAT_XIM
+#  undef FEAT_XIM
+# endif
+# ifdef FEAT_CLIENTSERVER
+#  undef FEAT_CLIENTSERVER
+# endif
+#endif
+
+/* The Mac conversion stuff doesn't work under X11. */
+#if defined(FEAT_MBYTE) && defined(MACOS_X_DARWIN)
+# define MACOS_CONVERT
+#endif
+
+/* Can't use "PACKAGE" here, conflicts with a Perl include file. */
+#ifndef VIMPACKAGE
+# define VIMPACKAGE	"vim"
+#endif
+
+/*
+ * Find out if function definitions should include argument types
+ */
+#ifdef AZTEC_C
+# include <functions.h>
+#endif
+
+#ifdef SASC
+# include <clib/exec_protos.h>
+#endif
+
+#ifdef _DCC
+# include <clib/exec_protos.h>
+#endif
+
+#ifdef __BEOS__
+# include "os_beos.h"
+#endif
+
+#if (defined(UNIX) || defined(VMS)) \
+	&& (!defined(MACOS_X) || defined(HAVE_CONFIG_H))
+# include "os_unix.h"	    /* bring lots of system header files */
+#endif
+
+/* Mark unused function arguments with UNUSED, so that gcc -Wunused-parameter
+ * can be used to check for mistakes. */
+#ifdef HAVE_ATTRIBUTE_UNUSED
+# define UNUSED __attribute__((unused))
+#else
+# define UNUSED
+#endif
+
+/* Used to check for "sun", "__sun" is used by newer compilers. */
+#if defined(__sun)
+# define SUN_SYSTEM
+#endif
+
+/* if we're compiling in C++ (currently only KVim), the system
+ * headers must have the correct prototypes or nothing will build.
+ * conversely, our prototypes might clash due to throw() specifiers and
+ * cause compilation failures even though the headers are correct.  For
+ * a concrete example, gcc-3.2 enforces exception specifications, and
+ * glibc-2.2.5 has them in their system headers.
+ */
+#if !defined(__cplusplus) && defined(UNIX) \
+  && !defined(MACOS_X) /* MACOS_X doesn't yet support osdef.h */
+# include "auto/osdef.h"	/* bring missing declarations in */
+#endif
+
+#ifdef AMIGA
+# include "os_amiga.h"
+#endif
+
+#ifdef WIN3264
+# include "os_win32.h"
+#endif
+
+#ifdef __MINT__
+# include "os_mint.h"
+#endif
+
+#if defined(MACOS_X)
+# include "os_mac.h"
+#endif
+
+#ifdef __QNX__
+# include "os_qnx.h"
+#endif
+
+#ifdef FEAT_SUN_WORKSHOP
+# include "workshop.h"
+#endif
+
+#ifdef X_LOCALE
+# include <X11/Xlocale.h>
+#else
+# ifdef HAVE_LOCALE_H
+#  include <locale.h>
+# endif
+#endif
+
+/*
+ * Maximum length of a path (for non-unix systems) Make it a bit long, to stay
+ * on the safe side.  But not too long to put on the stack.
+ */
+#ifndef MAXPATHL
+# ifdef MAXPATHLEN
+#  define MAXPATHL  MAXPATHLEN
+# else
+#  define MAXPATHL  256
+# endif
+#endif
+#ifdef BACKSLASH_IN_FILENAME
+# define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`%#'\"|!<")
+#else
+# ifdef VMS
+    /* VMS allows a lot of characters in the file name */
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'\"|!")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'|!()&")
+# else
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
+# endif
+#endif
+
+/* length of a buffer to store a number in ASCII (64 bits binary + NUL) */
+#define NUMBUFLEN 65
+
+/* flags for vim_str2nr() */
+#define STR2NR_BIN 1
+#define STR2NR_OCT 2
+#define STR2NR_HEX 4
+#define STR2NR_ALL (STR2NR_BIN + STR2NR_OCT + STR2NR_HEX)
+#define STR2NR_FORCE 8 /* only when ONE of the above is used */
+
+/*
+ * Shorthand for unsigned variables. Many systems, but not all, have u_char
+ * already defined, so we use char_u to avoid trouble.
+ */
+typedef unsigned char	char_u;
+typedef unsigned short	short_u;
+typedef unsigned int	int_u;
+/* Make sure long_u is big enough to hold a pointer.
+ * On Win64, longs are 32 bits and pointers are 64 bits.
+ * For printf() and scanf(), we need to take care of long_u specifically. */
+#ifdef _WIN64
+typedef unsigned __int64	long_u;
+typedef		 __int64	long_i;
+# define SCANF_HEX_LONG_U       "%Ix"
+# define SCANF_DECIMAL_LONG_U   "%Iu"
+# define PRINTF_HEX_LONG_U      "0x%Ix"
+#else
+  /* Microsoft-specific. The __w64 keyword should be specified on any typedefs
+   * that change size between 32-bit and 64-bit platforms.  For any such type,
+   * __w64 should appear only on the 32-bit definition of the typedef.
+   * Define __w64 as an empty token for everything but MSVC 7.x or later.
+   */
+# if !defined(_MSC_VER)	|| (_MSC_VER < 1300)
+#  define __w64
+# endif
+typedef unsigned long __w64	long_u;
+typedef		 long __w64     long_i;
+# define SCANF_HEX_LONG_U       "%lx"
+# define SCANF_DECIMAL_LONG_U   "%lu"
+# define PRINTF_HEX_LONG_U      "0x%lx"
+#endif
+#define PRINTF_DECIMAL_LONG_U SCANF_DECIMAL_LONG_U
+
+/*
+ * Only systems which use configure will have SIZEOF_OFF_T and VIM_SIZEOF_LONG
+ * defined, which is ok since those are the same systems which can have
+ * varying sizes for off_t.  The other systems will continue to use "%ld" to
+ * print off_t since off_t is simply a typedef to long for them.
+ */
+#if defined(SIZEOF_OFF_T) && (SIZEOF_OFF_T > VIM_SIZEOF_LONG)
+# define LONG_LONG_OFF_T
+#endif
+
+/*
+ * We use 64-bit file functions here, if available.  E.g. ftello() returns
+ * off_t instead of long, which helps if long is 32 bit and off_t is 64 bit.
+ * We assume that when fseeko() is available then ftello() is too.
+ * Note that Windows has different function names.
+ */
+#if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)
+typedef __int64 off_T;
+# ifdef __MINGW32__
+#  define vim_lseek lseek64
+#  define vim_fseek fseeko64
+#  define vim_ftell ftello64
+# else
+#  define vim_lseek _lseeki64
+#  define vim_fseek _fseeki64
+#  define vim_ftell _ftelli64
+# endif
+#else
+# ifdef PROTO
+typedef long off_T;
+# else
+typedef off_t off_T;
+# endif
+# ifdef HAVE_FSEEKO
+#  define vim_lseek lseek
+#  define vim_ftell ftello
+#  define vim_fseek fseeko
+# else
+#  define vim_lseek lseek
+#  define vim_ftell ftell
+#  define vim_fseek(a, b, c)	fseek(a, (long)b, c)
+# endif
+#endif
+
+/*
+ * The characters and attributes cached for the screen.
+ */
+typedef char_u schar_T;
+typedef unsigned short sattr_T;
+#define MAX_TYPENR 65535
+
+/*
+ * The u8char_T can hold one decoded UTF-8 character.
+ * We normally use 32 bits now, since some Asian characters don't fit in 16
+ * bits.  u8char_T is only used for displaying, it could be 16 bits to save
+ * memory.
+ */
+#ifdef FEAT_MBYTE
+# ifdef UNICODE16
+typedef unsigned short u8char_T;    /* short should be 16 bits */
+# else
+#  if VIM_SIZEOF_INT >= 4
+typedef unsigned int u8char_T;	    /* int is 32 bits */
+#  else
+typedef unsigned long u8char_T;	    /* long should be 32 bits or more */
+#  endif
+# endif
+#endif
+
+#ifndef UNIX		    /* For Unix this is included in os_unix.h */
+# include <stdio.h>
+# include <ctype.h>
+#endif
+
+#include "ascii.h"
+#include "keymap.h"
+#include "term.h"
+#include "macros.h"
+
+#ifdef LATTICE
+# include <sys/types.h>
+# include <sys/stat.h>
+#endif
+#ifdef _DCC
+# include <sys/stat.h>
+#endif
+#if defined(MSWIN)
+# include <sys/stat.h>
+#endif
+
+#if defined(HAVE_ERRNO_H) \
+	|| defined(WIN32) || defined(_WIN64)
+# include <errno.h>
+#endif
+
+/* for INT_MAX et al. */
+#include <limits.h>
+
+/*
+ * Allow other (non-unix) systems to configure themselves now
+ * These are also in os_unix.h, because osdef.sh needs them there.
+ */
+#ifndef UNIX
+/* Note: Some systems need both string.h and strings.h (Savage).  If the
+ * system can't handle this, define NO_STRINGS_WITH_STRING_H. */
+# ifdef HAVE_STRING_H
+#  include <string.h>
+# endif
+# if defined(HAVE_STRINGS_H) && !defined(NO_STRINGS_WITH_STRING_H)
+#  include <strings.h>
+# endif
+# ifdef HAVE_STAT_H
+#  include <stat.h>
+# endif
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif /* NON-UNIX */
+
+#include <assert.h>
+
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_WCTYPE_H
+# include <wctype.h>
+#endif
+#include <stdarg.h>
+
+/* for offsetof() */
+#include <stddef.h>
+
+#if defined(HAVE_SYS_SELECT_H) && \
+	(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))
+# include <sys/select.h>
+#endif
+
+#ifndef HAVE_SELECT
+# ifdef HAVE_SYS_POLL_H
+#  include <sys/poll.h>
+# elif defined(WIN32)
+#  define HAVE_SELECT
+# else
+#  ifdef HAVE_POLL_H
+#   include <poll.h>
+#  endif
+# endif
+#endif
+
+/* ================ end of the header file puzzle =============== */
+
+/*
+ * For dynamically loaded imm library. Currently, only for Win32.
+ */
+#ifdef DYNAMIC_IME
+# ifndef FEAT_MBYTE_IME
+#  define FEAT_MBYTE_IME
+# endif
+#endif
+
+/*
+ * For dynamically loaded gettext library.  Currently, only for Win32.
+ */
+#ifdef DYNAMIC_GETTEXT
+# ifndef FEAT_GETTEXT
+#  define FEAT_GETTEXT
+# endif
+/* These are in os_win32.c */
+extern char *(*dyn_libintl_gettext)(const char *msgid);
+extern char *(*dyn_libintl_ngettext)(const char *msgid, const char *msgid_plural, unsigned long n);
+extern char *(*dyn_libintl_bindtextdomain)(const char *domainname, const char *dirname);
+extern char *(*dyn_libintl_bind_textdomain_codeset)(const char *domainname, const char *codeset);
+extern char *(*dyn_libintl_textdomain)(const char *domainname);
+extern int (*dyn_libintl_putenv)(const char *envstring);
+#endif
+
+
+/*
+ * The _() stuff is for using gettext().  It is a no-op when libintl.h is not
+ * found or the +multilang feature is disabled.
+ * Use NGETTEXT(single, multi, number) to get plural behavior:
+ * - single - message for singular form
+ * - multi  - message for plural form
+ * - number - the count
+ */
+#ifdef FEAT_GETTEXT
+# ifdef DYNAMIC_GETTEXT
+#  define _(x) (*dyn_libintl_gettext)((char *)(x))
+#  define NGETTEXT(x, xs, n) (*dyn_libintl_ngettext)((char *)(x), (char *)(xs), (n))
+#  define N_(x) x
+#  define bindtextdomain(domain, dir) (*dyn_libintl_bindtextdomain)((domain), (dir))
+#  define bind_textdomain_codeset(domain, codeset) (*dyn_libintl_bind_textdomain_codeset)((domain), (codeset))
+#  if !defined(HAVE_BIND_TEXTDOMAIN_CODESET)
+#   define HAVE_BIND_TEXTDOMAIN_CODESET 1
+#  endif
+#  define textdomain(domain) (*dyn_libintl_textdomain)(domain)
+#  define libintl_putenv(envstring) (*dyn_libintl_putenv)(envstring)
+#  define libintl_wputenv(envstring) (*dyn_libintl_wputenv)(envstring)
+# else
+#  include <libintl.h>
+#  define _(x) gettext((char *)(x))
+#  define NGETTEXT(x, xs, n) ngettext((x), (xs), (n))
+#  ifdef gettext_noop
+#   define N_(x) gettext_noop(x)
+#  else
+#   define N_(x) x
+#  endif
+# endif
+#else
+# define _(x) ((char *)(x))
+# define NGETTEXT(x, xs, n) (((n) == 1) ? (char *)(x) : (char *)(xs))
+# define N_(x) x
+# ifdef bindtextdomain
+#  undef bindtextdomain
+# endif
+# define bindtextdomain(x, y) /* empty */
+# ifdef bind_textdomain_codeset
+#  undef bind_textdomain_codeset
+# endif
+# define bind_textdomain_codeset(x, y) /* empty */
+# ifdef textdomain
+#  undef textdomain
+# endif
+# define textdomain(x) /* empty */
+#endif
+
+/*
+ * flags for update_screen()
+ * The higher the value, the higher the priority
+ */
+#define VALID_NO_UPDATE		 5  /* no new changes, keep the command line if
+				       possible */
+#define VALID			10  /* buffer not changed, or changes marked
+				       with b_mod_* */
+#define INVERTED		20  /* redisplay inverted part that changed */
+#define INVERTED_ALL		25  /* redisplay whole inverted part */
+#define REDRAW_TOP		30  /* display first w_upd_rows screen lines */
+#define SOME_VALID		35  /* like NOT_VALID but may scroll */
+#define NOT_VALID		40  /* buffer needs complete redraw */
+#define CLEAR			50  /* screen messed up, clear it */
+
+/*
+ * Flags for w_valid.
+ * These are set when something in a window structure becomes invalid, except
+ * when the cursor is moved.  Call check_cursor_moved() before testing one of
+ * the flags.
+ * These are reset when that thing has been updated and is valid again.
+ *
+ * Every function that invalidates one of these must call one of the
+ * invalidate_* functions.
+ *
+ * w_valid is supposed to be used only in screen.c.  From other files, use the
+ * functions that set or reset the flags.
+ *
+ * VALID_BOTLINE    VALID_BOTLINE_AP
+ *     on		on		w_botline valid
+ *     off		on		w_botline approximated
+ *     off		off		w_botline not valid
+ *     on		off		not possible
+ */
+#define VALID_WROW	0x01	/* w_wrow (window row) is valid */
+#define VALID_WCOL	0x02	/* w_wcol (window col) is valid */
+#define VALID_VIRTCOL	0x04	/* w_virtcol (file col) is valid */
+#define VALID_CHEIGHT	0x08	/* w_cline_height and w_cline_folded valid */
+#define VALID_CROW	0x10	/* w_cline_row is valid */
+#define VALID_BOTLINE	0x20	/* w_botine and w_empty_rows are valid */
+#define VALID_BOTLINE_AP 0x40	/* w_botine is approximated */
+#define VALID_TOPLINE	0x80	/* w_topline is valid (for cursor position) */
+
+/*
+ * Terminal highlighting attribute bits.
+ * Attributes above HL_ALL are used for syntax highlighting.
+ */
+#define HL_NORMAL		0x00
+#define HL_INVERSE		0x01
+#define HL_BOLD			0x02
+#define HL_ITALIC		0x04
+#define HL_UNDERLINE		0x08
+#define HL_UNDERCURL		0x10
+#define HL_STANDOUT		0x20
+#define HL_NOCOMBINE		0x40
+#define HL_STRIKETHROUGH	0x80
+#define HL_ALL			0xff
+
+/* special attribute addition: Put message in history */
+#define MSG_HIST		0x1000
+
+/*
+ * values for State
+ *
+ * The lower bits up to 0x20 are used to distinguish normal/visual/op_pending
+ * and cmdline/insert+replace mode.  This is used for mapping.  If none of
+ * these bits are set, no mapping is done.
+ * The upper bits are used to distinguish between other states.
+ */
+#define NORMAL		0x01	/* Normal mode, command expected */
+#define VISUAL		0x02	/* Visual mode - use get_real_state() */
+#define OP_PENDING	0x04	/* Normal mode, operator is pending - use
+				   get_real_state() */
+#define CMDLINE		0x08	/* Editing command line */
+#define INSERT		0x10	/* Insert mode */
+#define LANGMAP		0x20	/* Language mapping, can be combined with
+				   INSERT and CMDLINE */
+
+#define REPLACE_FLAG	0x40	/* Replace mode flag */
+#define REPLACE		(REPLACE_FLAG + INSERT)
+#define VREPLACE_FLAG	0x80	/* Virtual-replace mode flag */
+#define VREPLACE	(REPLACE_FLAG + VREPLACE_FLAG + INSERT)
+#define LREPLACE	(REPLACE_FLAG + LANGMAP)
+
+#define NORMAL_BUSY	(0x100 + NORMAL) /* Normal mode, busy with a command */
+#define HITRETURN	(0x200 + NORMAL) /* waiting for return or command */
+#define ASKMORE		0x300	/* Asking if you want --more-- */
+#define SETWSIZE	0x400	/* window size has changed */
+#define ABBREV		0x500	/* abbreviation instead of mapping */
+#define EXTERNCMD	0x600	/* executing an external command */
+#define SHOWMATCH	(0x700 + INSERT) /* show matching paren */
+#define CONFIRM		0x800	/* ":confirm" prompt */
+#define SELECTMODE	0x1000	/* Select mode, only for mappings */
+#define TERMINAL        0x2000  /* Terminal mode */
+
+/* all mode bits used for mapping */
+#define MAP_ALL_MODES	(0x3f | SELECTMODE | TERMINAL)
+
+/* directions */
+#define FORWARD			1
+#define BACKWARD		(-1)
+#define FORWARD_FILE		3
+#define BACKWARD_FILE		(-3)
+
+/* return values for functions */
+#if !(defined(OK) && (OK == 1))
+/* OK already defined to 1 in MacOS X curses, skip this */
+# define OK			1
+#endif
+#define FAIL			0
+#define NOTDONE			2   /* not OK or FAIL but skipped */
+
+/* flags for b_flags */
+#define BF_RECOVERED	0x01	/* buffer has been recovered */
+#define BF_CHECK_RO	0x02	/* need to check readonly when loading file
+				   into buffer (set by ":e", may be reset by
+				   ":buf" */
+#define BF_NEVERLOADED	0x04	/* file has never been loaded into buffer,
+				   many variables still need to be set */
+#define BF_NOTEDITED	0x08	/* Set when file name is changed after
+				   starting to edit, reset when file is
+				   written out. */
+#define BF_NEW		0x10	/* file didn't exist when editing started */
+#define BF_NEW_W	0x20	/* Warned for BF_NEW and file created */
+#define BF_READERR	0x40	/* got errors while reading the file */
+#define BF_DUMMY	0x80	/* dummy buffer, only used internally */
+#define BF_PRESERVED	0x100	/* ":preserve" was used */
+
+/* Mask to check for flags that prevent normal writing */
+#define BF_WRITE_MASK	(BF_NOTEDITED + BF_NEW + BF_READERR)
+
+/*
+ * values for xp_context when doing command line completion
+ */
+#define EXPAND_UNSUCCESSFUL	(-2)
+#define EXPAND_OK		(-1)
+#define EXPAND_NOTHING		0
+#define EXPAND_COMMANDS		1
+#define EXPAND_FILES		2
+#define EXPAND_DIRECTORIES	3
+#define EXPAND_SETTINGS		4
+#define EXPAND_BOOL_SETTINGS	5
+#define EXPAND_TAGS		6
+#define EXPAND_OLD_SETTING	7
+#define EXPAND_HELP		8
+#define EXPAND_BUFFERS		9
+#define EXPAND_EVENTS		10
+#define EXPAND_MENUS		11
+#define EXPAND_SYNTAX		12
+#define EXPAND_HIGHLIGHT	13
+#define EXPAND_AUGROUP		14
+#define EXPAND_USER_VARS	15
+#define EXPAND_MAPPINGS		16
+#define EXPAND_TAGS_LISTFILES	17
+#define EXPAND_FUNCTIONS	18
+#define EXPAND_USER_FUNC	19
+#define EXPAND_EXPRESSION	20
+#define EXPAND_MENUNAMES	21
+#define EXPAND_USER_COMMANDS	22
+#define EXPAND_USER_CMD_FLAGS	23
+#define EXPAND_USER_NARGS	24
+#define EXPAND_USER_COMPLETE	25
+#define EXPAND_ENV_VARS		26
+#define EXPAND_LANGUAGE		27
+#define EXPAND_COLORS		28
+#define EXPAND_COMPILER		29
+#define EXPAND_USER_DEFINED	30
+#define EXPAND_USER_LIST	31
+#define EXPAND_SHELLCMD		32
+#define EXPAND_CSCOPE		33
+#define EXPAND_SIGN		34
+#define EXPAND_PROFILE		35
+#define EXPAND_BEHAVE		36
+#define EXPAND_FILETYPE		37
+#define EXPAND_FILES_IN_PATH	38
+#define EXPAND_OWNSYNTAX	39
+#define EXPAND_LOCALES		40
+#define EXPAND_HISTORY		41
+#define EXPAND_USER		42
+#define EXPAND_SYNTIME		43
+#define EXPAND_USER_ADDR_TYPE	44
+#define EXPAND_PACKADD		45
+#define EXPAND_MESSAGES		46
+#define EXPAND_MAPCLEAR		47
+#define EXPAND_ARGLIST		48
+
+/* Values for exmode_active (0 is no exmode) */
+#define EXMODE_NORMAL		1
+#define EXMODE_VIM		2
+
+/* Values for nextwild() and ExpandOne().  See ExpandOne() for meaning. */
+#define WILD_FREE		1
+#define WILD_EXPAND_FREE	2
+#define WILD_EXPAND_KEEP	3
+#define WILD_NEXT		4
+#define WILD_PREV		5
+#define WILD_ALL		6
+#define WILD_LONGEST		7
+#define WILD_ALL_KEEP		8
+
+#define WILD_LIST_NOTFOUND	0x01
+#define WILD_HOME_REPLACE	0x02
+#define WILD_USE_NL		0x04
+#define WILD_NO_BEEP		0x08
+#define WILD_ADD_SLASH		0x10
+#define WILD_KEEP_ALL		0x20
+#define WILD_SILENT		0x40
+#define WILD_ESCAPE		0x80
+#define WILD_ICASE		0x100
+#define WILD_ALLLINKS		0x200
+
+/* Flags for expand_wildcards() */
+#define EW_DIR		0x01	/* include directory names */
+#define EW_FILE		0x02	/* include file names */
+#define EW_NOTFOUND	0x04	/* include not found names */
+#define EW_ADDSLASH	0x08	/* append slash to directory name */
+#define EW_KEEPALL	0x10	/* keep all matches */
+#define EW_SILENT	0x20	/* don't print "1 returned" from shell */
+#define EW_EXEC		0x40	/* executable files */
+#define EW_PATH		0x80	/* search in 'path' too */
+#define EW_ICASE	0x100	/* ignore case */
+#define EW_NOERROR	0x200	/* no error for bad regexp */
+#define EW_NOTWILD	0x400	/* add match with literal name if exists */
+#define EW_KEEPDOLLAR	0x800	/* do not escape $, $var is expanded */
+/* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND
+ * is used when executing commands and EW_SILENT for interactive expanding. */
+#define EW_ALLLINKS	0x1000	/* also links not pointing to existing file */
+#define EW_SHELLCMD	0x2000	/* called from expand_shellcmd(), don't check
+				 * if executable is in $PATH */
+#define EW_DODOT	0x4000	/* also files starting with a dot */
+#define EW_EMPTYOK	0x8000	/* no matches is not an error */
+
+/* Flags for find_file_*() functions. */
+#define FINDFILE_FILE	0	/* only files */
+#define FINDFILE_DIR	1	/* only directories */
+#define FINDFILE_BOTH	2	/* files and directories */
+
+#define W_ENDCOL(wp)	(wp->w_wincol + wp->w_width)
+#ifdef FEAT_MENU
+# define W_WINROW(wp)	(wp->w_winrow + wp->w_winbar_height)
+#else
+# define W_WINROW(wp)	(wp->w_winrow)
+#endif
+
+#ifdef NO_EXPANDPATH
+# define gen_expand_wildcards mch_expand_wildcards
+#endif
+
+/* Values for the find_pattern_in_path() function args 'type' and 'action': */
+#define FIND_ANY	1
+#define FIND_DEFINE	2
+#define CHECK_PATH	3
+
+#define ACTION_SHOW	1
+#define ACTION_GOTO	2
+#define ACTION_SPLIT	3
+#define ACTION_SHOW_ALL	4
+#ifdef FEAT_INS_EXPAND
+# define ACTION_EXPAND	5
+#endif
+
+#ifdef FEAT_SYN_HL
+# define SST_MIN_ENTRIES 150	/* minimal size for state stack array */
+# define SST_MAX_ENTRIES 1000	/* maximal size for state stack array */
+# define SST_FIX_STATES	 7	/* size of sst_stack[]. */
+# define SST_DIST	 16	/* normal distance between entries */
+# define SST_INVALID	(synstate_T *)-1	/* invalid syn_state pointer */
+
+# define HL_CONTAINED	0x01	/* not used on toplevel */
+# define HL_TRANSP	0x02	/* has no highlighting	*/
+# define HL_ONELINE	0x04	/* match within one line only */
+# define HL_HAS_EOL	0x08	/* end pattern that matches with $ */
+# define HL_SYNC_HERE	0x10	/* sync point after this item (syncing only) */
+# define HL_SYNC_THERE	0x20	/* sync point at current line (syncing only) */
+# define HL_MATCH	0x40	/* use match ID instead of item ID */
+# define HL_SKIPNL	0x80	/* nextgroup can skip newlines */
+# define HL_SKIPWHITE	0x100	/* nextgroup can skip white space */
+# define HL_SKIPEMPTY	0x200	/* nextgroup can skip empty lines */
+# define HL_KEEPEND	0x400	/* end match always kept */
+# define HL_EXCLUDENL	0x800	/* exclude NL from match */
+# define HL_DISPLAY	0x1000	/* only used for displaying, not syncing */
+# define HL_FOLD	0x2000	/* define fold */
+# define HL_EXTEND	0x4000	/* ignore a keepend */
+# define HL_MATCHCONT	0x8000	/* match continued from previous line */
+# define HL_TRANS_CONT	0x10000 /* transparent item without contains arg */
+# define HL_CONCEAL	0x20000 /* can be concealed */
+# define HL_CONCEALENDS	0x40000 /* can be concealed */
+#endif
+
+/* Values for 'options' argument in do_search() and searchit() */
+#define SEARCH_REV    0x01  /* go in reverse of previous dir. */
+#define SEARCH_ECHO   0x02  /* echo the search command and handle options */
+#define SEARCH_MSG    0x0c  /* give messages (yes, it's not 0x04) */
+#define SEARCH_NFMSG  0x08  /* give all messages except not found */
+#define SEARCH_OPT    0x10  /* interpret optional flags */
+#define SEARCH_HIS    0x20  /* put search pattern in history */
+#define SEARCH_END    0x40  /* put cursor at end of match */
+#define SEARCH_NOOF   0x80  /* don't add offset to position */
+#define SEARCH_START 0x100  /* start search without col offset */
+#define SEARCH_MARK  0x200  /* set previous context mark */
+#define SEARCH_KEEP  0x400  /* keep previous search pattern */
+#define SEARCH_PEEK  0x800  /* peek for typed char, cancel search */
+#define SEARCH_COL  0x1000  /* start at specified column instead of zero */
+
+/* Values for find_ident_under_cursor() */
+#define FIND_IDENT	1	/* find identifier (word) */
+#define FIND_STRING	2	/* find any string (WORD) */
+#define FIND_EVAL	4	/* include "->", "[]" and "." */
+
+/* Values for file_name_in_line() */
+#define FNAME_MESS	1	/* give error message */
+#define FNAME_EXP	2	/* expand to path */
+#define FNAME_HYP	4	/* check for hypertext link */
+#define FNAME_INCL	8	/* apply 'includeexpr' */
+#define FNAME_REL	16	/* ".." and "./" are relative to the (current)
+				   file instead of the current directory */
+#define FNAME_UNESC	32	/* remove backslashes used for escaping */
+
+/* Values for buflist_getfile() */
+#define GETF_SETMARK	0x01	/* set pcmark before jumping */
+#define GETF_ALT	0x02	/* jumping to alternate file (not buf num) */
+#define GETF_SWITCH	0x04	/* respect 'switchbuf' settings when jumping */
+
+/* Return values of getfile() */
+#define GETFILE_ERROR	    1	/* normal error */
+#define GETFILE_NOT_WRITTEN 2	/* "not written" error */
+#define GETFILE_SAME_FILE   0	/* success, same file */
+#define GETFILE_OPEN_OTHER -1	/* success, opened another file */
+#define GETFILE_UNUSED	    8
+#define GETFILE_SUCCESS(x)  ((x) <= 0)
+
+/* Values for buflist_new() flags */
+#define BLN_CURBUF	1	/* may re-use curbuf for new buffer */
+#define BLN_LISTED	2	/* put new buffer in buffer list */
+#define BLN_DUMMY	4	/* allocating dummy buffer */
+#define BLN_NEW		8	/* create a new buffer */
+#define BLN_NOOPT	16	/* don't copy options to existing buffer */
+#define BLN_DUMMY_OK	32	/* also find an existing dummy buffer */
+
+/* Values for in_cinkeys() */
+#define KEY_OPEN_FORW	0x101
+#define KEY_OPEN_BACK	0x102
+#define KEY_COMPLETE	0x103	/* end of completion */
+
+/* Values for "noremap" argument of ins_typebuf().  Also used for
+ * map->m_noremap and menu->noremap[]. */
+#define REMAP_YES	0	/* allow remapping */
+#define REMAP_NONE	-1	/* no remapping */
+#define REMAP_SCRIPT	-2	/* remap script-local mappings only */
+#define REMAP_SKIP	-3	/* no remapping for first char */
+
+/* Values for mch_call_shell() second argument */
+#define SHELL_FILTER	1	/* filtering text */
+#define SHELL_EXPAND	2	/* expanding wildcards */
+#define SHELL_COOKED	4	/* set term to cooked mode */
+#define SHELL_DOOUT	8	/* redirecting output */
+#define SHELL_SILENT	16	/* don't print error returned by command */
+#define SHELL_READ	32	/* read lines and insert into buffer */
+#define SHELL_WRITE	64	/* write lines from buffer */
+
+/* Values returned by mch_nodetype() */
+#define NODE_NORMAL	0	/* file or directory, check with mch_isdir()*/
+#define NODE_WRITABLE	1	/* something we can write to (character
+				   device, fifo, socket, ..) */
+#define NODE_OTHER	2	/* non-writable thing (e.g., block device) */
+
+/* Values for readfile() flags */
+#define READ_NEW	0x01	/* read a file into a new buffer */
+#define READ_FILTER	0x02	/* read filter output */
+#define READ_STDIN	0x04	/* read from stdin */
+#define READ_BUFFER	0x08	/* read from curbuf (converting stdin) */
+#define READ_DUMMY	0x10	/* reading into a dummy buffer */
+#define READ_KEEP_UNDO	0x20	/* keep undo info */
+#define READ_FIFO	0x40	/* read from fifo or socket */
+
+/* Values for change_indent() */
+#define INDENT_SET	1	/* set indent */
+#define INDENT_INC	2	/* increase indent */
+#define INDENT_DEC	3	/* decrease indent */
+
+/* Values for flags argument for findmatchlimit() */
+#define FM_BACKWARD	0x01	/* search backwards */
+#define FM_FORWARD	0x02	/* search forwards */
+#define FM_BLOCKSTOP	0x04	/* stop at start/end of block */
+#define FM_SKIPCOMM	0x08	/* skip comments */
+
+/* Values for action argument for do_buffer() */
+#define DOBUF_GOTO	0	/* go to specified buffer */
+#define DOBUF_SPLIT	1	/* split window and go to specified buffer */
+#define DOBUF_UNLOAD	2	/* unload specified buffer(s) */
+#define DOBUF_DEL	3	/* delete specified buffer(s) from buflist */
+#define DOBUF_WIPE	4	/* delete specified buffer(s) really */
+
+/* Values for start argument for do_buffer() */
+#define DOBUF_CURRENT	0	/* "count" buffer from current buffer */
+#define DOBUF_FIRST	1	/* "count" buffer from first buffer */
+#define DOBUF_LAST	2	/* "count" buffer from last buffer */
+#define DOBUF_MOD	3	/* "count" mod. buffer from current buffer */
+
+/* Values for sub_cmd and which_pat argument for search_regcomp() */
+/* Also used for which_pat argument for searchit() */
+#define RE_SEARCH	0	/* save/use pat in/from search_pattern */
+#define RE_SUBST	1	/* save/use pat in/from subst_pattern */
+#define RE_BOTH		2	/* save pat in both patterns */
+#define RE_LAST		2	/* use last used pattern if "pat" is NULL */
+
+/* Second argument for vim_regcomp(). */
+#define RE_MAGIC	1	/* 'magic' option */
+#define RE_STRING	2	/* match in string instead of buffer text */
+#define RE_STRICT	4	/* don't allow [abc] without ] */
+#define RE_AUTO		8	/* automatic engine selection */
+
+#ifdef FEAT_SYN_HL
+/* values for reg_do_extmatch */
+# define REX_SET	1	/* to allow \z\(...\), */
+# define REX_USE	2	/* to allow \z\1 et al. */
+# define REX_ALL	(REX_SET | REX_USE)
+#endif
+
+/* Return values for fullpathcmp() */
+/* Note: can use (fullpathcmp() & FPC_SAME) to check for equal files */
+#define FPC_SAME	1	/* both exist and are the same file. */
+#define FPC_DIFF	2	/* both exist and are different files. */
+#define FPC_NOTX	4	/* both don't exist. */
+#define FPC_DIFFX	6	/* one of them doesn't exist. */
+#define FPC_SAMEX	7	/* both don't exist and file names are same. */
+
+/* flags for do_ecmd() */
+#define ECMD_HIDE	0x01	/* don't free the current buffer */
+#define ECMD_SET_HELP	0x02	/* set b_help flag of (new) buffer before
+				   opening file */
+#define ECMD_OLDBUF	0x04	/* use existing buffer if it exists */
+#define ECMD_FORCEIT	0x08	/* ! used in Ex command */
+#define ECMD_ADDBUF	0x10	/* don't edit, just add to buffer list */
+
+/* for lnum argument in do_ecmd() */
+#define ECMD_LASTL	(linenr_T)0	/* use last position in loaded file */
+#define ECMD_LAST	(linenr_T)-1	/* use last position in all files */
+#define ECMD_ONE	(linenr_T)1	/* use first line */
+
+/* flags for do_cmdline() */
+#define DOCMD_VERBOSE	0x01	/* included command in error message */
+#define DOCMD_NOWAIT	0x02	/* don't call wait_return() and friends */
+#define DOCMD_REPEAT	0x04	/* repeat exec. until getline() returns NULL */
+#define DOCMD_KEYTYPED	0x08	/* don't reset KeyTyped */
+#define DOCMD_EXCRESET	0x10	/* reset exception environment (for debugging)*/
+#define DOCMD_KEEPLINE  0x20	/* keep typed line for repeating with "." */
+
+/* flags for beginline() */
+#define BL_WHITE	1	/* cursor on first non-white in the line */
+#define BL_SOL		2	/* use 'sol' option */
+#define BL_FIX		4	/* don't leave cursor on a NUL */
+
+/* flags for mf_sync() */
+#define MFS_ALL		1	/* also sync blocks with negative numbers */
+#define MFS_STOP	2	/* stop syncing when a character is available */
+#define MFS_FLUSH	4	/* flushed file to disk */
+#define MFS_ZERO	8	/* only write block 0 */
+
+/* flags for buf_copy_options() */
+#define BCO_ENTER	1	/* going to enter the buffer */
+#define BCO_ALWAYS	2	/* always copy the options */
+#define BCO_NOHELP	4	/* don't touch the help related options */
+
+/* flags for do_put() */
+#define PUT_FIXINDENT	1	/* make indent look nice */
+#define PUT_CURSEND	2	/* leave cursor after end of new text */
+#define PUT_CURSLINE	4	/* leave cursor on last line of new text */
+#define PUT_LINE	8	/* put register as lines */
+#define PUT_LINE_SPLIT	16	/* split line for linewise register */
+#define PUT_LINE_FORWARD 32	/* put linewise register below Visual sel. */
+
+/* flags for set_indent() */
+#define SIN_CHANGED	1	/* call changed_bytes() when line changed */
+#define SIN_INSERT	2	/* insert indent before existing text */
+#define SIN_UNDO	4	/* save line for undo before changing it */
+
+/* flags for insertchar() */
+#define INSCHAR_FORMAT	1	/* force formatting */
+#define INSCHAR_DO_COM	2	/* format comments */
+#define INSCHAR_CTRLV	4	/* char typed just after CTRL-V */
+#define INSCHAR_NO_FEX	8	/* don't use 'formatexpr' */
+#define INSCHAR_COM_LIST 16	/* format comments with list/2nd line indent */
+
+/* flags for open_line() */
+#define OPENLINE_DELSPACES  1	/* delete spaces after cursor */
+#define OPENLINE_DO_COM	    2	/* format comments */
+#define OPENLINE_KEEPTRAIL  4	/* keep trailing spaces */
+#define OPENLINE_MARKFIX    8	/* fix mark positions */
+#define OPENLINE_COM_LIST  16	/* format comments with list/2nd line indent */
+
+/*
+ * There are five history tables:
+ */
+#define HIST_CMD	0	/* colon commands */
+#define HIST_SEARCH	1	/* search commands */
+#define HIST_EXPR	2	/* expressions (from entering = register) */
+#define HIST_INPUT	3	/* input() lines */
+#define HIST_DEBUG	4	/* debug commands */
+#define HIST_COUNT	5	/* number of history tables */
+
+/* The type numbers are fixed for backwards compatibility. */
+#define BARTYPE_VERSION 1
+#define BARTYPE_HISTORY 2
+#define BARTYPE_REGISTER 3
+#define BARTYPE_MARK 4
+
+#define VIMINFO_VERSION 4
+#define VIMINFO_VERSION_WITH_HISTORY 2
+#define VIMINFO_VERSION_WITH_REGISTERS 3
+#define VIMINFO_VERSION_WITH_MARKS 4
+
+typedef enum {
+    BVAL_NR,
+    BVAL_STRING,
+    BVAL_EMPTY
+} btype_T;
+
+typedef struct {
+    btype_T	bv_type;
+    long	bv_nr;
+    char_u	*bv_string;
+    int		bv_len;		/* length of bv_string */
+    int		bv_allocated;	/* bv_string was allocated */
+} bval_T;
+
+/*
+ * Values for do_tag().
+ */
+#define DT_TAG		1	/* jump to newer position or same tag again */
+#define DT_POP		2	/* jump to older position */
+#define DT_NEXT		3	/* jump to next match of same tag */
+#define DT_PREV		4	/* jump to previous match of same tag */
+#define DT_FIRST	5	/* jump to first match of same tag */
+#define DT_LAST		6	/* jump to first match of same tag */
+#define DT_SELECT	7	/* jump to selection from list */
+#define DT_HELP		8	/* like DT_TAG, but no wildcards */
+#define DT_JUMP		9	/* jump to new tag or selection from list */
+#define DT_CSCOPE	10	/* cscope find command (like tjump) */
+#define DT_LTAG		11	/* tag using location list */
+#define DT_FREE		99	/* free cached matches */
+
+/*
+ * flags for find_tags().
+ */
+#define TAG_HELP	1	/* only search for help tags */
+#define TAG_NAMES	2	/* only return name of tag */
+#define	TAG_REGEXP	4	/* use tag pattern as regexp */
+#define	TAG_NOIC	8	/* don't always ignore case */
+#ifdef FEAT_CSCOPE
+# define TAG_CSCOPE	16	/* cscope tag */
+#endif
+#define TAG_VERBOSE	32	/* message verbosity */
+#define TAG_INS_COMP	64	/* Currently doing insert completion */
+#define TAG_KEEP_LANG	128	/* keep current language */
+
+#define TAG_MANY	300	/* When finding many tags (for completion),
+				   find up to this many tags */
+
+/*
+ * Types of dialogs passed to do_vim_dialog().
+ */
+#define VIM_GENERIC	0
+#define VIM_ERROR	1
+#define VIM_WARNING	2
+#define VIM_INFO	3
+#define VIM_QUESTION	4
+#define VIM_LAST_TYPE	4	/* sentinel value */
+
+/*
+ * Return values for functions like gui_yesnocancel()
+ */
+#define VIM_YES		2
+#define VIM_NO		3
+#define VIM_CANCEL	4
+#define VIM_ALL		5
+#define VIM_DISCARDALL  6
+
+/*
+ * arguments for win_split()
+ */
+#define WSP_ROOM	1	/* require enough room */
+#define WSP_VERT	2	/* split vertically */
+#define WSP_TOP		4	/* window at top-left of shell */
+#define WSP_BOT		8	/* window at bottom-right of shell */
+#define WSP_HELP	16	/* creating the help window */
+#define WSP_BELOW	32	/* put new window below/right */
+#define WSP_ABOVE	64	/* put new window above/left */
+#define WSP_NEWLOC	128	/* don't copy location list */
+
+/*
+ * arguments for gui_set_shellsize()
+ */
+#define RESIZE_VERT	1	/* resize vertically */
+#define RESIZE_HOR	2	/* resize horizontally */
+#define RESIZE_BOTH	15	/* resize in both directions */
+
+/*
+ * flags for check_changed()
+ */
+#define CCGD_AW		1	/* do autowrite if buffer was changed */
+#define CCGD_MULTWIN	2	/* check also when several wins for the buf */
+#define CCGD_FORCEIT	4	/* ! used */
+#define CCGD_ALLBUF	8	/* may write all buffers */
+#define CCGD_EXCMD	16	/* may suggest using ! */
+
+/*
+ * "flags" values for option-setting functions.
+ * When OPT_GLOBAL and OPT_LOCAL are both missing, set both local and global
+ * values, get local value.
+ */
+#define OPT_FREE	1	/* free old value if it was allocated */
+#define OPT_GLOBAL	2	/* use global value */
+#define OPT_LOCAL	4	/* use local value */
+#define OPT_MODELINE	8	/* option in modeline */
+#define OPT_WINONLY	16	/* only set window-local options */
+#define OPT_NOWIN	32	/* don't set window-local options */
+
+/* Magic chars used in confirm dialog strings */
+#define DLG_BUTTON_SEP	'\n'
+#define DLG_HOTKEY_CHAR	'&'
+
+/* Values for "starting" */
+#define NO_SCREEN	2	/* no screen updating yet */
+#define NO_BUFFERS	1	/* not all buffers loaded yet */
+/*			0	   not starting anymore */
+
+/* Values for swap_exists_action: what to do when swap file already exists */
+#define SEA_NONE	0	/* don't use dialog */
+#define SEA_DIALOG	1	/* use dialog when possible */
+#define SEA_QUIT	2	/* quit editing the file */
+#define SEA_RECOVER	3	/* recover the file */
+
+/*
+ * Minimal size for block 0 of a swap file.
+ * NOTE: This depends on size of struct block0! It's not done with a sizeof(),
+ * because struct block0 is defined in memline.c (Sorry).
+ * The maximal block size is arbitrary.
+ */
+#define MIN_SWAP_PAGE_SIZE 1048
+#define MAX_SWAP_PAGE_SIZE 50000
+
+/* Special values for current_SID. */
+#define SID_MODELINE	-1	/* when using a modeline */
+#define SID_CMDARG	-2	/* for "--cmd" argument */
+#define SID_CARG	-3	/* for "-c" argument */
+#define SID_ENV		-4	/* for sourcing environment variable */
+#define SID_ERROR	-5	/* option was reset because of an error */
+#define SID_NONE	-6	/* don't set scriptID */
+
+/*
+ * Events for autocommands.
+ */
+enum auto_event
+{
+    EVENT_BUFADD = 0,		/* after adding a buffer to the buffer list */
+    EVENT_BUFDELETE,		/* deleting a buffer from the buffer list */
+    EVENT_BUFENTER,		/* after entering a buffer */
+    EVENT_BUFFILEPOST,		/* after renaming a buffer */
+    EVENT_BUFFILEPRE,		/* before renaming a buffer */
+    EVENT_BUFHIDDEN,		/* just after buffer becomes hidden */
+    EVENT_BUFLEAVE,		/* before leaving a buffer */
+    EVENT_BUFNEW,		/* after creating any buffer */
+    EVENT_BUFNEWFILE,		/* when creating a buffer for a new file */
+    EVENT_BUFREADCMD,		/* read buffer using command */
+    EVENT_BUFREADPOST,		/* after reading a buffer */
+    EVENT_BUFREADPRE,		/* before reading a buffer */
+    EVENT_BUFUNLOAD,		/* just before unloading a buffer */
+    EVENT_BUFWINENTER,		/* after showing a buffer in a window */
+    EVENT_BUFWINLEAVE,		/* just after buffer removed from window */
+    EVENT_BUFWIPEOUT,		/* just before really deleting a buffer */
+    EVENT_BUFWRITECMD,		/* write buffer using command */
+    EVENT_BUFWRITEPOST,		/* after writing a buffer */
+    EVENT_BUFWRITEPRE,		/* before writing a buffer */
+    EVENT_CMDLINECHANGED,	/* command line was modified*/
+    EVENT_CMDLINEENTER,		/* after entering the command line */
+    EVENT_CMDLINELEAVE,		/* before leaving the command line */
+    EVENT_CMDUNDEFINED,		/* command undefined */
+    EVENT_CMDWINENTER,		/* after entering the cmdline window */
+    EVENT_CMDWINLEAVE,		/* before leaving the cmdline window */
+    EVENT_COLORSCHEME,		/* after loading a colorscheme */
+    EVENT_COLORSCHEMEPRE,	/* before loading a colorscheme */
+    EVENT_COMPLETEDONE,		/* after finishing insert complete */
+    EVENT_CURSORHOLD,		/* cursor in same position for a while */
+    EVENT_CURSORHOLDI,		/* idem, in Insert mode */
+    EVENT_CURSORMOVED,		/* cursor was moved */
+    EVENT_CURSORMOVEDI,		/* cursor was moved in Insert mode */
+    EVENT_DIRCHANGED,		/* after user changed directory */
+    EVENT_ENCODINGCHANGED,	/* after changing the 'encoding' option */
+    EVENT_EXITPRE,		/* before exiting */
+    EVENT_FILEAPPENDCMD,	/* append to a file using command */
+    EVENT_FILEAPPENDPOST,	/* after appending to a file */
+    EVENT_FILEAPPENDPRE,	/* before appending to a file */
+    EVENT_FILECHANGEDRO,	/* before first change to read-only file */
+    EVENT_FILECHANGEDSHELL,	/* after shell command that changed file */
+    EVENT_FILECHANGEDSHELLPOST,	/* after (not) reloading changed file */
+    EVENT_FILEREADCMD,		/* read from a file using command */
+    EVENT_FILEREADPOST,		/* after reading a file */
+    EVENT_FILEREADPRE,		/* before reading a file */
+    EVENT_FILETYPE,		/* new file type detected (user defined) */
+    EVENT_FILEWRITECMD,		/* write to a file using command */
+    EVENT_FILEWRITEPOST,	/* after writing a file */
+    EVENT_FILEWRITEPRE,		/* before writing a file */
+    EVENT_FILTERREADPOST,	/* after reading from a filter */
+    EVENT_FILTERREADPRE,	/* before reading from a filter */
+    EVENT_FILTERWRITEPOST,	/* after writing to a filter */
+    EVENT_FILTERWRITEPRE,	/* before writing to a filter */
+    EVENT_FOCUSGAINED,		/* got the focus */
+    EVENT_FOCUSLOST,		/* lost the focus to another app */
+    EVENT_FUNCUNDEFINED,	/* if calling a function which doesn't exist */
+    EVENT_GUIENTER,		/* after starting the GUI */
+    EVENT_GUIFAILED,		/* after starting the GUI failed */
+    EVENT_INSERTCHANGE,		/* when changing Insert/Replace mode */
+    EVENT_INSERTCHARPRE,	/* before inserting a char */
+    EVENT_INSERTENTER,		/* when entering Insert mode */
+    EVENT_INSERTLEAVE,		/* when leaving Insert mode */
+    EVENT_MENUPOPUP,		/* just before popup menu is displayed */
+    EVENT_OPTIONSET,		/* option was set */
+    EVENT_QUICKFIXCMDPOST,	/* after :make, :grep etc. */
+    EVENT_QUICKFIXCMDPRE,	/* before :make, :grep etc. */
+    EVENT_QUITPRE,		/* before :quit */
+    EVENT_REMOTEREPLY,		/* upon string reception from a remote vim */
+    EVENT_SESSIONLOADPOST,	/* after loading a session file */
+    EVENT_SHELLCMDPOST,		/* after ":!cmd" */
+    EVENT_SHELLFILTERPOST,	/* after ":1,2!cmd", ":w !cmd", ":r !cmd". */
+    EVENT_SOURCECMD,		/* sourcing a Vim script using command */
+    EVENT_SOURCEPRE,		/* before sourcing a Vim script */
+    EVENT_SPELLFILEMISSING,	/* spell file missing */
+    EVENT_STDINREADPOST,	/* after reading from stdin */
+    EVENT_STDINREADPRE,		/* before reading from stdin */
+    EVENT_SWAPEXISTS,		/* found existing swap file */
+    EVENT_SYNTAX,		/* syntax selected */
+    EVENT_TABCLOSED,		/* after closing a tab page */
+    EVENT_TABENTER,		/* after entering a tab page */
+    EVENT_TABLEAVE,		/* before leaving a tab page */
+    EVENT_TABNEW,		/* when entering a new tab page */
+    EVENT_TERMCHANGED,		/* after changing 'term' */
+    EVENT_TERMINALOPEN,		/* after a terminal buffer was created */
+    EVENT_TERMRESPONSE,		/* after setting "v:termresponse" */
+    EVENT_TEXTCHANGED,		/* text was modified not in Insert mode */
+    EVENT_TEXTCHANGEDI,         /* text was modified in Insert mode */
+    EVENT_TEXTCHANGEDP,         /* TextChangedI with popup menu visible */
+    EVENT_TEXTYANKPOST,		/* after some text was yanked */
+    EVENT_USER,			/* user defined autocommand */
+    EVENT_VIMENTER,		/* after starting Vim */
+    EVENT_VIMLEAVE,		/* before exiting Vim */
+    EVENT_VIMLEAVEPRE,		/* before exiting Vim and writing .viminfo */
+    EVENT_VIMRESIZED,		/* after Vim window was resized */
+    EVENT_WINENTER,		/* after entering a window */
+    EVENT_WINLEAVE,		/* before leaving a window */
+    EVENT_WINNEW,		/* when entering a new window */
+
+    NUM_EVENTS			/* MUST be the last one */
+};
+
+typedef enum auto_event event_T;
+
+/*
+ * Values for index in highlight_attr[].
+ * When making changes, also update HL_FLAGS below!  And update the default
+ * value of 'highlight' in option.c.
+ */
+typedef enum
+{
+    HLF_8 = 0	    /* Meta & special keys listed with ":map", text that is
+		       displayed different from what it is */
+    , HLF_EOB	    /* after the last line in the buffer */
+    , HLF_AT	    /* @ characters at end of screen, characters that
+		       don't really exist in the text */
+    , HLF_D	    /* directories in CTRL-D listing */
+    , HLF_E	    /* error messages */
+    , HLF_H	    /* obsolete, ignored */
+    , HLF_I	    /* incremental search */
+    , HLF_L	    /* last search string */
+    , HLF_M	    /* "--More--" message */
+    , HLF_CM	    /* Mode (e.g., "-- INSERT --") */
+    , HLF_N	    /* line number for ":number" and ":#" commands */
+    , HLF_CLN	    /* current line number */
+    , HLF_R	    /* return to continue message and yes/no questions */
+    , HLF_S	    /* status lines */
+    , HLF_SNC	    /* status lines of not-current windows */
+    , HLF_C	    /* column to separate vertically split windows */
+    , HLF_T	    /* Titles for output from ":set all", ":autocmd" etc. */
+    , HLF_V	    /* Visual mode */
+    , HLF_VNC	    /* Visual mode, autoselecting and not clipboard owner */
+    , HLF_W	    /* warning messages */
+    , HLF_WM	    /* Wildmenu highlight */
+    , HLF_FL	    /* Folded line */
+    , HLF_FC	    /* Fold column */
+    , HLF_ADD	    /* Added diff line */
+    , HLF_CHD	    /* Changed diff line */
+    , HLF_DED	    /* Deleted diff line */
+    , HLF_TXD	    /* Text Changed in diff line */
+    , HLF_CONCEAL   /* Concealed text */
+    , HLF_SC	    /* Sign column */
+    , HLF_SPB	    /* SpellBad */
+    , HLF_SPC	    /* SpellCap */
+    , HLF_SPR	    /* SpellRare */
+    , HLF_SPL	    /* SpellLocal */
+    , HLF_PNI	    /* popup menu normal item */
+    , HLF_PSI	    /* popup menu selected item */
+    , HLF_PSB	    /* popup menu scrollbar */
+    , HLF_PST	    /* popup menu scrollbar thumb */
+    , HLF_TP	    /* tabpage line */
+    , HLF_TPS	    /* tabpage line selected */
+    , HLF_TPF	    /* tabpage line filler */
+    , HLF_CUC	    /* 'cursorcolumn' */
+    , HLF_CUL	    /* 'cursorline' */
+    , HLF_MC	    /* 'colorcolumn' */
+    , HLF_QFL	    /* quickfix window line currently selected */
+    , HLF_ST	    /* status lines of terminal windows */
+    , HLF_STNC	    /* status lines of not-current terminal windows */
+    , HLF_COUNT	    /* MUST be the last one */
+} hlf_T;
+
+/* The HL_FLAGS must be in the same order as the HLF_ enums!
+ * When changing this also adjust the default for 'highlight'. */
+#define HL_FLAGS {'8', '~', '@', 'd', 'e', 'h', 'i', 'l', 'm', 'M', \
+		  'n', 'N', 'r', 's', 'S', 'c', 't', 'v', 'V', 'w', 'W', \
+		  'f', 'F', 'A', 'C', 'D', 'T', '-', '>', \
+		  'B', 'P', 'R', 'L', \
+		  '+', '=', 'x', 'X', '*', '#', '_', '!', '.', 'o', 'q', \
+		  'z', 'Z'}
+
+/*
+ * Boolean constants
+ */
+#ifndef TRUE
+# define FALSE	0	    /* note: this is an int, not a long! */
+# define TRUE	1
+#endif
+
+#define MAYBE	2	    /* sometimes used for a variant on TRUE */
+
+#ifndef UINT32_T
+typedef UINT32_TYPEDEF UINT32_T;
+#endif
+
+/*
+ * Operator IDs; The order must correspond to opchars[] in ops.c!
+ */
+#define OP_NOP		0	/* no pending operation */
+#define OP_DELETE	1	/* "d"  delete operator */
+#define OP_YANK		2	/* "y"  yank operator */
+#define OP_CHANGE	3	/* "c"  change operator */
+#define OP_LSHIFT	4	/* "<"  left shift operator */
+#define OP_RSHIFT	5	/* ">"  right shift operator */
+#define OP_FILTER	6	/* "!"  filter operator */
+#define OP_TILDE	7	/* "g~" switch case operator */
+#define OP_INDENT	8	/* "="  indent operator */
+#define OP_FORMAT	9	/* "gq" format operator */
+#define OP_COLON	10	/* ":"  colon operator */
+#define OP_UPPER	11	/* "gU" make upper case operator */
+#define OP_LOWER	12	/* "gu" make lower case operator */
+#define OP_JOIN		13	/* "J"  join operator, only for Visual mode */
+#define OP_JOIN_NS	14	/* "gJ"  join operator, only for Visual mode */
+#define OP_ROT13	15	/* "g?" rot-13 encoding */
+#define OP_REPLACE	16	/* "r"  replace chars, only for Visual mode */
+#define OP_INSERT	17	/* "I"  Insert column, only for Visual mode */
+#define OP_APPEND	18	/* "A"  Append column, only for Visual mode */
+#define OP_FOLD		19	/* "zf" define a fold */
+#define OP_FOLDOPEN	20	/* "zo" open folds */
+#define OP_FOLDOPENREC	21	/* "zO" open folds recursively */
+#define OP_FOLDCLOSE	22	/* "zc" close folds */
+#define OP_FOLDCLOSEREC	23	/* "zC" close folds recursively */
+#define OP_FOLDDEL	24	/* "zd" delete folds */
+#define OP_FOLDDELREC	25	/* "zD" delete folds recursively */
+#define OP_FORMAT2	26	/* "gw" format operator, keeps cursor pos */
+#define OP_FUNCTION	27	/* "g@" call 'operatorfunc' */
+#define OP_NR_ADD	28	/* "<C-A>" Add to the number or alphabetic
+				   character (OP_ADD conflicts with Perl) */
+#define OP_NR_SUB	29	/* "<C-X>" Subtract from the number or
+				   alphabetic character */
+
+/*
+ * Motion types, used for operators and for yank/delete registers.
+ */
+#define MCHAR	0		/* character-wise movement/register */
+#define MLINE	1		/* line-wise movement/register */
+#define MBLOCK	2		/* block-wise register */
+
+#define MAUTO	0xff		/* Decide between MLINE/MCHAR */
+
+/*
+ * Minimum screen size
+ */
+#define MIN_COLUMNS	12	/* minimal columns for screen */
+#define MIN_LINES	2	/* minimal lines for screen */
+#define STATUS_HEIGHT	1	/* height of a status line under a window */
+#ifdef FEAT_MENU		/* height of a status line under a window */
+# define WINBAR_HEIGHT(wp)	(wp)->w_winbar_height
+# define VISIBLE_HEIGHT(wp)	((wp)->w_height + (wp)->w_winbar_height)
+#else
+# define WINBAR_HEIGHT(wp)	0
+# define VISIBLE_HEIGHT(wp)	(wp)->w_height
+#endif
+#define QF_WINHEIGHT	10	/* default height for quickfix window */
+
+/*
+ * Buffer sizes
+ */
+#ifndef CMDBUFFSIZE
+# define CMDBUFFSIZE	256	/* size of the command processing buffer */
+#endif
+
+#define LSIZE	    512		/* max. size of a line in the tags file */
+
+#define IOSIZE	   (1024+1)	/* file i/o and sprintf buffer size */
+
+#define DIALOG_MSG_SIZE 1000	/* buffer size for dialog_msg() */
+
+#ifdef FEAT_MBYTE
+# define MSG_BUF_LEN 480	/* length of buffer for small messages */
+# define MSG_BUF_CLEN  (MSG_BUF_LEN / 6)    /* cell length (worst case: utf-8
+					       takes 6 bytes for one cell) */
+#else
+# define MSG_BUF_LEN 80		/* length of buffer for small messages */
+# define MSG_BUF_CLEN  MSG_BUF_LEN	    /* cell length */
+#endif
+
+#define FOLD_TEXT_LEN  51	/* buffer size for get_foldtext() */
+
+/* Size of the buffer used for tgetent().  Unfortunately this is largely
+ * undocumented, some systems use 1024.  Using a buffer that is too small
+ * causes a buffer overrun and a crash.  Use the maximum known value to stay
+ * on the safe side. */
+#define TBUFSZ 2048		/* buffer size for termcap entry */
+
+/*
+ * Maximum length of key sequence to be mapped.
+ * Must be able to hold an Amiga resize report.
+ */
+#define MAXMAPLEN   50
+
+/* Size in bytes of the hash used in the undo file. */
+#define UNDO_HASH_SIZE 32
+
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+
+#ifdef BINARY_FILE_IO
+# define WRITEBIN   "wb"	/* no CR-LF translation */
+# define READBIN    "rb"
+# define APPENDBIN  "ab"
+#else
+# define WRITEBIN   "w"
+# define READBIN    "r"
+# define APPENDBIN  "a"
+#endif
+
+/*
+ * EMX doesn't have a global way of making open() use binary I/O.
+ * Use O_BINARY for all open() calls.
+ */
+#if defined(__CYGWIN32__)
+# define O_EXTRA    O_BINARY
+#else
+# define O_EXTRA    0
+#endif
+
+#ifndef O_NOFOLLOW
+# define O_NOFOLLOW 0
+#endif
+
+#ifndef W_OK
+# define W_OK 2		/* for systems that don't have W_OK in unistd.h */
+#endif
+#ifndef R_OK
+# define R_OK 4		/* for systems that don't have R_OK in unistd.h */
+#endif
+
+/*
+ * defines to avoid typecasts from (char_u *) to (char *) and back
+ * (vim_strchr() and vim_strrchr() are now in alloc.c)
+ */
+#define STRLEN(s)	    strlen((char *)(s))
+#define STRCPY(d, s)	    strcpy((char *)(d), (char *)(s))
+#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))
+#define STRCMP(d, s)	    strcmp((char *)(d), (char *)(s))
+#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))
+#ifdef HAVE_STRCASECMP
+# define STRICMP(d, s)	    strcasecmp((char *)(d), (char *)(s))
+#else
+# ifdef HAVE_STRICMP
+#  define STRICMP(d, s)	    stricmp((char *)(d), (char *)(s))
+# else
+#  define STRICMP(d, s)	    vim_stricmp((char *)(d), (char *)(s))
+# endif
+#endif
+
+/* Like strcpy() but allows overlapped source and destination. */
+#define STRMOVE(d, s)	    mch_memmove((d), (s), STRLEN(s) + 1)
+
+#ifdef HAVE_STRNCASECMP
+# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))
+#else
+# ifdef HAVE_STRNICMP
+#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))
+# else
+#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))
+# endif
+#endif
+
+#ifdef FEAT_MBYTE
+/* We need to call mb_stricmp() even when we aren't dealing with a multi-byte
+ * encoding because mb_stricmp() takes care of all ascii and non-ascii
+ * encodings, including characters with umlauts in latin1, etc., while
+ * STRICMP() only handles the system locale version, which often does not
+ * handle non-ascii properly. */
+
+# define MB_STRICMP(d, s)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL)
+# define MB_STRNICMP(d, s, n)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n))
+#else
+# define MB_STRICMP(d, s)	STRICMP((d), (s))
+# define MB_STRNICMP(d, s, n)	STRNICMP((d), (s), (n))
+#endif
+
+#define STRCAT(d, s)	    strcat((char *)(d), (char *)(s))
+#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))
+
+#ifdef HAVE_STRPBRK
+# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))
+#endif
+
+#define MSG(s)			    msg((char_u *)(s))
+#define MSG_ATTR(s, attr)	    msg_attr((char_u *)(s), (attr))
+#define EMSG(s)			    emsg((char_u *)(s))
+#define EMSG2(s, p)		    emsg2((char_u *)(s), (char_u *)(p))
+#define EMSG3(s, p, q)		    emsg3((char_u *)(s), (char_u *)(p), (char_u *)(q))
+#define EMSGN(s, n)		    emsgn((char_u *)(s), (long)(n))
+#define EMSGU(s, n)		    emsgu((char_u *)(s), (long_u)(n))
+#define IEMSG(s)		    iemsg((char_u *)(s))
+#define IEMSG2(s, p)		    iemsg2((char_u *)(s), (char_u *)(p))
+#define IEMSGN(s, n)		    iemsgn((char_u *)(s), (long)(n))
+#define OUT_STR(s)		    out_str((char_u *)(s))
+#define OUT_STR_NF(s)		    out_str_nf((char_u *)(s))
+#define MSG_PUTS(s)		    msg_puts((char_u *)(s))
+#define MSG_PUTS_ATTR(s, a)	    msg_puts_attr((char_u *)(s), (a))
+#define MSG_PUTS_TITLE(s)	    msg_puts_title((char_u *)(s))
+#define MSG_PUTS_LONG(s)	    msg_puts_long_attr((char_u *)(s), 0)
+#define MSG_PUTS_LONG_ATTR(s, a)    msg_puts_long_attr((char_u *)(s), (a))
+
+#ifdef FEAT_GUI
+# ifdef FEAT_TERMGUICOLORS
+#  define GUI_FUNCTION(f)	    (gui.in_use ? gui_##f : termgui_##f)
+#  define GUI_FUNCTION2(f, pixel)   (gui.in_use \
+				    ?  ((pixel) != INVALCOLOR \
+					? gui_##f((pixel)) \
+					: INVALCOLOR) \
+				    : termgui_##f((pixel)))
+#  define USE_24BIT		    (gui.in_use || p_tgc)
+# else
+#  define GUI_FUNCTION(f)	    gui_##f
+#  define GUI_FUNCTION2(f,pixel)    ((pixel) != INVALCOLOR \
+				     ? gui_##f((pixel)) \
+				     : INVALCOLOR)
+#  define USE_24BIT		    gui.in_use
+# endif
+#else
+# ifdef FEAT_TERMGUICOLORS
+#  define GUI_FUNCTION(f)	    termgui_##f
+#  define GUI_FUNCTION2(f, pixel)   termgui_##f((pixel))
+#  define USE_24BIT		    p_tgc
+# endif
+#endif
+#ifdef FEAT_TERMGUICOLORS
+# define IS_CTERM		    (t_colors > 1 || p_tgc)
+#else
+# define IS_CTERM		    (t_colors > 1)
+#endif
+#ifdef GUI_FUNCTION
+# define GUI_MCH_GET_RGB	    GUI_FUNCTION(mch_get_rgb)
+# define GUI_MCH_GET_RGB2(pixel)    GUI_FUNCTION2(mch_get_rgb, (pixel))
+# define GUI_MCH_GET_COLOR	    GUI_FUNCTION(mch_get_color)
+# define GUI_GET_COLOR		    GUI_FUNCTION(get_color)
+#endif
+
+/* Prefer using emsg3(), because perror() may send the output to the wrong
+ * destination and mess up the screen. */
+#ifdef HAVE_STRERROR
+# define PERROR(msg)		    (void)emsg3((char_u *)"%s: %s", (char_u *)msg, (char_u *)strerror(errno))
+#else
+# define PERROR(msg)		    do_perror(msg)
+#endif
+
+typedef long	linenr_T;		/* line number type */
+typedef int	colnr_T;		/* column number type */
+typedef unsigned short disptick_T;	/* display tick type */
+
+#define MAXLNUM (0x7fffffffL)		/* maximum (invalid) line number */
+
+/*
+ * Well, you won't believe it, but some S/390 machines ("host", now also known
+ * as zServer) use 31 bit pointers. There are also some newer machines, that
+ * use 64 bit pointers. I don't know how to distinguish between 31 and 64 bit
+ * machines, so the best way is to assume 31 bits whenever we detect OS/390
+ * Unix.
+ * With this we restrict the maximum line length to 1073741823. I guess this is
+ * not a real problem. BTW:  Longer lines are split.
+ */
+#if VIM_SIZEOF_INT >= 4
+# ifdef __MVS__
+#  define MAXCOL (0x3fffffffL)		/* maximum column number, 30 bits */
+# else
+#  define MAXCOL (0x7fffffffL)		/* maximum column number, 31 bits */
+# endif
+#else
+# define MAXCOL	(0x7fff)		/* maximum column number, 15 bits */
+#endif
+
+#define SHOWCMD_COLS 10			/* columns needed by shown command */
+#define STL_MAX_ITEM 80			/* max nr of %<flag> in statusline */
+
+typedef void	    *vim_acl_T;		/* dummy to pass an ACL to a function */
+
+#ifndef mch_memmove
+# define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (size_t)(len))
+#endif
+
+/*
+ * fnamecmp() is used to compare file names.
+ * On some systems case in a file name does not matter, on others it does.
+ * (this does not account for maximum name lengths and things like "../dir",
+ * thus it is not 100% accurate!)
+ */
+#define fnamecmp(x, y) vim_fnamecmp((char_u *)(x), (char_u *)(y))
+#define fnamencmp(x, y, n) vim_fnamencmp((char_u *)(x), (char_u *)(y), (size_t)(n))
+
+#ifdef HAVE_MEMSET
+# define vim_memset(ptr, c, size)   memset((ptr), (c), (size))
+#else
+void *vim_memset(void *, int, size_t);
+#endif
+
+#if defined(UNIX) || defined(FEAT_GUI) || defined(VMS) \
+	|| defined(FEAT_CLIENTSERVER)
+# define USE_INPUT_BUF
+#endif
+
+#ifndef EINTR
+# define read_eintr(fd, buf, count) vim_read((fd), (buf), (count))
+# define write_eintr(fd, buf, count) vim_write((fd), (buf), (count))
+#endif
+
+#ifdef MSWIN
+/* On MS-Windows the third argument isn't size_t.  This matters for Win64,
+ * where sizeof(size_t)==8, not 4 */
+# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (unsigned int)(count))
+# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (unsigned int)(count))
+#else
+# define vim_read(fd, buf, count)   read((fd), (char *)(buf), (size_t) (count))
+# define vim_write(fd, buf, count)  write((fd), (char *)(buf), (size_t) (count))
+#endif
+
+/*
+ * Enums need a typecast to be used as array index (for Ultrix).
+ */
+#define HL_ATTR(n)	highlight_attr[(int)(n)]
+#define TERM_STR(n)	term_strings[(int)(n)]
+
+/*
+ * EXTERN is only defined in main.c.  That's where global variables are
+ * actually defined and initialized.
+ */
+#ifndef EXTERN
+# define EXTERN extern
+# define INIT(x)
+#else
+# ifndef INIT
+#  define INIT(x) x
+#  define DO_INIT
+#  define COMMA ,
+# endif
+#endif
+
+#ifdef FEAT_MBYTE
+# define MAX_MCO	6	/* maximum value for 'maxcombine' */
+
+/* Maximum number of bytes in a multi-byte character.  It can be one 32-bit
+ * character of up to 6 bytes, or one 16-bit character of up to three bytes
+ * plus six following composing characters of three bytes each. */
+# define MB_MAXBYTES	21
+#else
+# define MB_MAXBYTES	1
+#endif
+
+#if (defined(FEAT_PROFILE) || defined(FEAT_RELTIME)) && !defined(PROTO)
+# ifdef WIN3264
+typedef LARGE_INTEGER proftime_T;
+# else
+typedef struct timeval proftime_T;
+# endif
+#else
+typedef int proftime_T;	    /* dummy for function prototypes */
+#endif
+
+/*
+ * When compiling with 32 bit Perl time_t is 32 bits in the Perl code but 64
+ * bits elsewhere.  That causes memory corruption.  Define time_T and use it
+ * for global variables to avoid that.
+ */
+#ifdef PROTO
+typedef long  time_T;
+#else
+# ifdef WIN3264
+typedef __time64_t  time_T;
+# else
+typedef time_t	    time_T;
+# endif
+#endif
+
+#ifdef _WIN64
+typedef __int64 sock_T;
+#else
+typedef int sock_T;
+#endif
+
+/* Include option.h before structs.h, because the number of window-local and
+ * buffer-local options is used there. */
+#include "option.h"	/* options and default values */
+
+#include "beval.h"	/* BalloonEval */
+
+/* Note that gui.h is included by structs.h */
+
+#include "structs.h"	/* defines many structures */
+
+#include "alloc.h"
+
+/* Values for "do_profiling". */
+#define PROF_NONE	0	/* profiling not started */
+#define PROF_YES	1	/* profiling busy */
+#define PROF_PAUSED	2	/* profiling paused */
+
+#ifdef FEAT_MOUSE
+
+/* Codes for mouse button events in lower three bits: */
+# define MOUSE_LEFT	0x00
+# define MOUSE_MIDDLE	0x01
+# define MOUSE_RIGHT	0x02
+# define MOUSE_RELEASE	0x03
+
+/* bit masks for modifiers: */
+# define MOUSE_SHIFT	0x04
+# define MOUSE_ALT	0x08
+# define MOUSE_CTRL	0x10
+
+/* mouse buttons that are handled like a key press (GUI only) */
+/* Note that the scroll wheel keys are inverted: MOUSE_5 scrolls lines up but
+ * the result of this is that the window moves down, similarly MOUSE_6 scrolls
+ * columns left but the window moves right. */
+# define MOUSE_4	0x100	/* scroll wheel down */
+# define MOUSE_5	0x200	/* scroll wheel up */
+
+# define MOUSE_X1	0x300 /* Mouse-button X1 (6th) */
+# define MOUSE_X2	0x400 /* Mouse-button X2 */
+
+# define MOUSE_6	0x500	/* scroll wheel left */
+# define MOUSE_7	0x600	/* scroll wheel right */
+
+/* 0x20 is reserved by xterm */
+# define MOUSE_DRAG_XTERM   0x40
+
+# define MOUSE_DRAG	(0x40 | MOUSE_RELEASE)
+
+/* Lowest button code for using the mouse wheel (xterm only) */
+# define MOUSEWHEEL_LOW		0x60
+
+# define MOUSE_CLICK_MASK	0x03
+
+# define NUM_MOUSE_CLICKS(code) \
+    (((unsigned)((code) & 0xC0) >> 6) + 1)
+
+# define SET_NUM_MOUSE_CLICKS(code, num) \
+    (code) = ((code) & 0x3f) | ((((num) - 1) & 3) << 6)
+
+/* Added to mouse column for GUI when 'mousefocus' wants to give focus to a
+ * window by simulating a click on its status line.  We could use up to 128 *
+ * 128 = 16384 columns, now it's reduced to 10000. */
+# define MOUSE_COLOFF 10000
+
+/*
+ * jump_to_mouse() returns one of first four these values, possibly with
+ * some of the other three added.
+ */
+# define IN_UNKNOWN		0
+# define IN_BUFFER		1
+# define IN_STATUS_LINE		2	/* on status or command line */
+# define IN_SEP_LINE		4	/* on vertical separator line */
+# define IN_OTHER_WIN		8	/* in other window but can't go there */
+# define CURSOR_MOVED		0x100
+# define MOUSE_FOLD_CLOSE	0x200	/* clicked on '-' in fold column */
+# define MOUSE_FOLD_OPEN	0x400	/* clicked on '+' in fold column */
+# define MOUSE_WINBAR		0x800	/* in window toolbar */
+
+/* flags for jump_to_mouse() */
+# define MOUSE_FOCUS		0x01	/* need to stay in this window */
+# define MOUSE_MAY_VIS		0x02	/* may start Visual mode */
+# define MOUSE_DID_MOVE		0x04	/* only act when mouse has moved */
+# define MOUSE_SETPOS		0x08	/* only set current mouse position */
+# define MOUSE_MAY_STOP_VIS	0x10	/* may stop Visual mode */
+# define MOUSE_RELEASED		0x20	/* button was released */
+
+# if defined(UNIX) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+#  define CHECK_DOUBLE_CLICK 1	/* Checking for double clicks ourselves. */
+# endif
+
+#endif /* FEAT_MOUSE */
+
+/* defines for eval_vars() */
+#define VALID_PATH		1
+#define VALID_HEAD		2
+
+/* Defines for Vim variables.  These must match vimvars[] in eval.c! */
+#define VV_COUNT	0
+#define VV_COUNT1	1
+#define VV_PREVCOUNT	2
+#define VV_ERRMSG	3
+#define VV_WARNINGMSG	4
+#define VV_STATUSMSG	5
+#define VV_SHELL_ERROR	6
+#define VV_THIS_SESSION	7
+#define VV_VERSION	8
+#define VV_LNUM		9
+#define VV_TERMRESPONSE	10
+#define VV_FNAME	11
+#define VV_LANG		12
+#define VV_LC_TIME	13
+#define VV_CTYPE	14
+#define VV_CC_FROM	15
+#define VV_CC_TO	16
+#define VV_FNAME_IN	17
+#define VV_FNAME_OUT	18
+#define VV_FNAME_NEW	19
+#define VV_FNAME_DIFF	20
+#define VV_CMDARG	21
+#define VV_FOLDSTART	22
+#define VV_FOLDEND	23
+#define VV_FOLDDASHES	24
+#define VV_FOLDLEVEL	25
+#define VV_PROGNAME	26
+#define VV_SEND_SERVER	27
+#define VV_DYING	28
+#define VV_EXCEPTION	29
+#define VV_THROWPOINT	30
+#define VV_REG		31
+#define VV_CMDBANG	32
+#define VV_INSERTMODE	33
+#define VV_VAL		34
+#define VV_KEY		35
+#define VV_PROFILING	36
+#define VV_FCS_REASON	37
+#define VV_FCS_CHOICE	38
+#define VV_BEVAL_BUFNR	39
+#define VV_BEVAL_WINNR	40
+#define VV_BEVAL_WINID	41
+#define VV_BEVAL_LNUM	42
+#define VV_BEVAL_COL	43
+#define VV_BEVAL_TEXT	44
+#define VV_SCROLLSTART	45
+#define VV_SWAPNAME	46
+#define VV_SWAPCHOICE	47
+#define VV_SWAPCOMMAND	48
+#define VV_CHAR		49
+#define VV_MOUSE_WIN	50
+#define VV_MOUSE_WINID	51
+#define VV_MOUSE_LNUM   52
+#define VV_MOUSE_COL	53
+#define VV_OP		54
+#define VV_SEARCHFORWARD 55
+#define VV_HLSEARCH	56
+#define VV_OLDFILES	57
+#define VV_WINDOWID	58
+#define VV_PROGPATH	59
+#define VV_COMPLETED_ITEM 60
+#define VV_OPTION_NEW   61
+#define VV_OPTION_OLD   62
+#define VV_OPTION_TYPE  63
+#define VV_ERRORS	64
+#define VV_FALSE	65
+#define VV_TRUE		66
+#define VV_NULL		67
+#define VV_NONE		68
+#define VV_VIM_DID_ENTER 69
+#define VV_TESTING	70
+#define VV_TYPE_NUMBER	71
+#define VV_TYPE_STRING	72
+#define VV_TYPE_FUNC	73
+#define VV_TYPE_LIST	74
+#define VV_TYPE_DICT	75
+#define VV_TYPE_FLOAT	76
+#define VV_TYPE_BOOL	77
+#define VV_TYPE_NONE	78
+#define VV_TYPE_JOB	79
+#define VV_TYPE_CHANNEL	80
+#define VV_TERMRFGRESP	81
+#define VV_TERMRBGRESP	82
+#define VV_TERMU7RESP	83
+#define VV_TERMSTYLERESP 84
+#define VV_TERMBLINKRESP 85
+#define VV_EVENT	86
+#define VV_LEN		87	/* number of v: vars */
+
+/* used for v_number in VAR_SPECIAL */
+#define VVAL_FALSE	0L
+#define VVAL_TRUE	1L
+#define VVAL_NONE	2L
+#define VVAL_NULL	3L
+
+/* Type values for type(). */
+#define VAR_TYPE_NUMBER	    0
+#define VAR_TYPE_STRING	    1
+#define VAR_TYPE_FUNC	    2
+#define VAR_TYPE_LIST	    3
+#define VAR_TYPE_DICT	    4
+#define VAR_TYPE_FLOAT	    5
+#define VAR_TYPE_BOOL	    6
+#define VAR_TYPE_NONE	    7
+#define VAR_TYPE_JOB	    8
+#define VAR_TYPE_CHANNEL    9
+
+#ifdef FEAT_CLIPBOARD
+
+/* VIM_ATOM_NAME is the older Vim-specific selection type for X11.  Still
+ * supported for when a mix of Vim versions is used. VIMENC_ATOM_NAME includes
+ * the encoding to support Vims using different 'encoding' values. */
+# define VIM_ATOM_NAME "_VIM_TEXT"
+# define VIMENC_ATOM_NAME "_VIMENC_TEXT"
+
+/* Selection states for modeless selection */
+# define SELECT_CLEARED		0
+# define SELECT_IN_PROGRESS	1
+# define SELECT_DONE		2
+
+# define SELECT_MODE_CHAR	0
+# define SELECT_MODE_WORD	1
+# define SELECT_MODE_LINE	2
+
+# ifdef FEAT_GUI_W32
+#  ifdef FEAT_OLE
+#   define WM_OLE (WM_APP+0)
+#  endif
+# endif
+
+/* Info about selected text */
+typedef struct VimClipboard
+{
+    int		available;	/* Is clipboard available? */
+    int		owned;		/* Flag: do we own the selection? */
+    pos_T	start;		/* Start of selected area */
+    pos_T	end;		/* End of selected area */
+    int		vmode;		/* Visual mode character */
+
+    /* Fields for selection that doesn't use Visual mode */
+    short_u	origin_row;
+    short_u	origin_start_col;
+    short_u	origin_end_col;
+    short_u	word_start_col;
+    short_u	word_end_col;
+
+    pos_T	prev;		/* Previous position */
+    short_u	state;		/* Current selection state */
+    short_u	mode;		/* Select by char, word, or line. */
+
+# if defined(FEAT_GUI_X11) || defined(FEAT_XCLIPBOARD)
+    Atom	sel_atom;	/* PRIMARY/CLIPBOARD selection ID */
+# endif
+
+# ifdef FEAT_GUI_GTK
+    GdkAtom     gtk_sel_atom;	/* PRIMARY/CLIPBOARD selection ID */
+# endif
+
+# if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)
+    int_u	format;		/* Vim's own special clipboard format */
+    int_u	format_raw;	/* Vim's raw text clipboard format */
+# endif
+} VimClipboard;
+#else
+typedef int VimClipboard;	/* This is required for the prototypes. */
+#endif
+
+/* Use 64-bit stat structure if available. */
+#if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)
+# define HAVE_STAT64
+typedef struct _stat64 stat_T;
+#else
+typedef struct stat stat_T;
+#endif
+
+#if defined(__GNUC__) && !defined(__MINGW32__)
+# define USE_PRINTF_FORMAT_ATTRIBUTE
+#endif
+
+typedef enum
+{
+    ASSERT_EQUAL,
+    ASSERT_NOTEQUAL,
+    ASSERT_MATCH,
+    ASSERT_NOTMATCH,
+    ASSERT_OTHER
+} assert_type_T;
+
+/* Mode for bracketed_paste(). */
+typedef enum {
+    PASTE_INSERT,	/* insert mode */
+    PASTE_CMDLINE,	/* command line */
+    PASTE_EX,		/* ex mode line */
+    PASTE_ONE_CHAR	/* return first character */
+} paste_mode_T;
+
+#include "ex_cmds.h"	    /* Ex command defines */
+#include "spell.h"	    /* spell checking stuff */
+
+#include "proto.h"	    /* function prototypes */
+
+/* This has to go after the include of proto.h, as proto/gui.pro declares
+ * functions of these names. The declarations would break if the defines had
+ * been seen at that stage.  But it must be before globals.h, where error_ga
+ * is declared. */
+#if !defined(FEAT_GUI_W32) && !defined(FEAT_GUI_X11) \
+	&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC) && !defined(PROTO)
+# define mch_errmsg(str)	fprintf(stderr, "%s", (str))
+# define display_errors()	fflush(stderr)
+# define mch_msg(str)		printf("%s", (str))
+#else
+# define USE_MCH_ERRMSG
+#endif
+
+# if defined(FEAT_MBYTE) && defined(FEAT_EVAL) \
+	&& (!defined(FEAT_GUI_W32) \
+	     || !(defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME))) \
+	&& !(defined(FEAT_GUI_MAC) && defined(MACOS_CONVERT))
+/* Whether IME is supported by im_get_status() defined in mbyte.c.
+ * For Win32 GUI it's in gui_w32.c when FEAT_MBYTE_IME or GLOBAL_IME is defined.
+ * for Mac it is in gui_mac.c for the GUI or in os_mac_conv.c when
+ * MACOS_CONVERT is defined. */
+# define IME_WITHOUT_XIM
+#endif
+
+#if defined(FEAT_MBYTE) && (defined(FEAT_XIM) \
+	|| defined(IME_WITHOUT_XIM) \
+	|| (defined(FEAT_GUI_W32) \
+	    && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME))) \
+	|| defined(FEAT_GUI_MAC))
+/* im_set_active() is available */
+# define HAVE_INPUT_METHOD
+#endif
+
+#ifndef FEAT_MBYTE
+# define after_pathsep(b, p)	vim_ispathsep(*((p) - 1))
+# define transchar_byte(c)	transchar(c)
+#endif
+
+#ifndef FEAT_LINEBREAK
+/* Without the 'numberwidth' option line numbers are always 7 chars. */
+# define number_width(x) 7
+#endif
+
+/* This must come after including proto.h.
+ * For VMS this is defined in macros.h. */
+#if !(defined(FEAT_MBYTE) && defined(WIN3264)) && !defined(VMS)
+# define mch_open(n, m, p)	open((n), (m), (p))
+# define mch_fopen(n, p)	fopen((n), (p))
+#endif
+
+#include "globals.h"	    /* global variables and messages */
+
+#ifndef FEAT_VIRTUALEDIT
+# define getvvcol(w, p, s, c, e) getvcol((w), (p), (s), (c), (e))
+# define virtual_active() FALSE
+# define virtual_op FALSE
+#endif
+
+/*
+ * If console dialog not supported, but GUI dialog is, use the GUI one.
+ */
+#if defined(FEAT_GUI_DIALOG) && !defined(FEAT_CON_DIALOG)
+# define do_dialog gui_mch_dialog
+#endif
+
+/*
+ * Default filters for gui_mch_browse().
+ * The filters are almost system independent.  Except for the difference
+ * between "*" and "*.*" for MSDOS-like systems.
+ * NOTE: Motif only uses the very first pattern.  Therefore
+ * BROWSE_FILTER_DEFAULT should start with a "*" pattern.
+ */
+#ifdef FEAT_BROWSE
+# ifdef BACKSLASH_IN_FILENAME
+#  define BROWSE_FILTER_MACROS \
+	(char_u *)N_("Vim macro files (*.vim)\t*.vim\nAll Files (*.*)\t*.*\n")
+#  define BROWSE_FILTER_ALL_FILES (char_u *)N_("All Files (*.*)\t*.*\n")
+#  define BROWSE_FILTER_DEFAULT \
+	(char_u *)N_("All Files (*.*)\t*.*\nC source (*.c, *.h)\t*.c;*.h\nC++ source (*.cpp, *.hpp)\t*.cpp;*.hpp\nVB code (*.bas, *.frm)\t*.bas;*.frm\nVim files (*.vim, _vimrc, _gvimrc)\t*.vim;_vimrc;_gvimrc\n")
+# else
+#  define BROWSE_FILTER_MACROS \
+	(char_u *)N_("Vim macro files (*.vim)\t*.vim\nAll Files (*)\t*\n")
+#  define BROWSE_FILTER_ALL_FILES (char_u *)N_("All Files (*)\t*\n")
+#  define BROWSE_FILTER_DEFAULT \
+	(char_u *)N_("All Files (*)\t*\nC source (*.c, *.h)\t*.c;*.h\nC++ source (*.cpp, *.hpp)\t*.cpp;*.hpp\nVim files (*.vim, _vimrc, _gvimrc)\t*.vim;_vimrc;_gvimrc\n")
+# endif
+# define BROWSE_SAVE 1	    /* flag for do_browse() */
+# define BROWSE_DIR 2	    /* flag for do_browse() */
+#endif
+
+/* stop using fastcall for Borland */
+#if defined(__BORLANDC__) && defined(WIN32) && !defined(DEBUG)
+ #pragma option -p.
+#endif
+
+#ifdef _MSC_VER
+/* Avoid useless warning "conversion from X to Y of greater size". */
+ #pragma warning(disable : 4312)
+/* Avoid warning for old style function declarators */
+ #pragma warning(disable : 4131)
+/* Avoid warning for conversion to type with smaller range */
+ #pragma warning(disable : 4244)
+/* Avoid warning for conversion to larger size */
+ #pragma warning(disable : 4306)
+/* Avoid warning for unreferenced formal parameter */
+ #pragma warning(disable : 4100)
+/* Avoid warning for differs in indirection to slightly different base type */
+ #pragma warning(disable : 4057)
+/* Avoid warning for constant conditional expression */
+ #pragma warning(disable : 4127)
+/* Avoid warning for assignment within conditional */
+ #pragma warning(disable : 4706)
+#endif
+
+/* Note: a NULL argument for vim_realloc() is not portable, don't use it. */
+#if defined(MEM_PROFILE)
+# define vim_realloc(ptr, size)  mem_realloc((ptr), (size))
+#else
+# define vim_realloc(ptr, size)  realloc((ptr), (size))
+#endif
+
+/*
+ * The following macros stop display/event loop nesting at the wrong time.
+ */
+#ifdef ALT_X_INPUT
+# define ALT_INPUT_LOCK_OFF	suppress_alternate_input = FALSE
+# define ALT_INPUT_LOCK_ON	suppress_alternate_input = TRUE
+#endif
+
+#ifdef FEAT_MBYTE
+/*
+ * Return byte length of character that starts with byte "b".
+ * Returns 1 for a single-byte character.
+ * MB_BYTE2LEN_CHECK() can be used to count a special key as one byte.
+ * Don't call MB_BYTE2LEN(b) with b < 0 or b > 255!
+ */
+# define MB_BYTE2LEN(b)		mb_bytelen_tab[b]
+# define MB_BYTE2LEN_CHECK(b)	(((b) < 0 || (b) > 255) ? 1 : mb_bytelen_tab[b])
+#endif
+
+#if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT)
+/* properties used in enc_canon_table[] (first three mutually exclusive) */
+# define ENC_8BIT	0x01
+# define ENC_DBCS	0x02
+# define ENC_UNICODE	0x04
+
+# define ENC_ENDIAN_B	0x10	    /* Unicode: Big endian */
+# define ENC_ENDIAN_L	0x20	    /* Unicode: Little endian */
+
+# define ENC_2BYTE	0x40	    /* Unicode: UCS-2 */
+# define ENC_4BYTE	0x80	    /* Unicode: UCS-4 */
+# define ENC_2WORD	0x100	    /* Unicode: UTF-16 */
+
+# define ENC_LATIN1	0x200	    /* Latin1 */
+# define ENC_LATIN9	0x400	    /* Latin9 */
+# define ENC_MACROMAN	0x800	    /* Mac Roman (not Macro Man! :-) */
+#endif
+
+#ifdef FEAT_MBYTE
+# ifdef USE_ICONV
+#  ifndef EILSEQ
+#   define EILSEQ 123
+#  endif
+#  ifdef DYNAMIC_ICONV
+/* On Win32 iconv.dll is dynamically loaded. */
+#   define ICONV_ERRNO (*iconv_errno())
+#   define ICONV_E2BIG  7
+#   define ICONV_EINVAL 22
+#   define ICONV_EILSEQ 42
+#  else
+#   define ICONV_ERRNO errno
+#   define ICONV_E2BIG  E2BIG
+#   define ICONV_EINVAL EINVAL
+#   define ICONV_EILSEQ EILSEQ
+#  endif
+# endif
+
+#endif
+
+
+#define SIGN_BYTE 1	    /* byte value used where sign is displayed;
+			       attribute value is sign type */
+
+#ifdef FEAT_NETBEANS_INTG
+# define MULTISIGN_BYTE 2   /* byte value used where sign is displayed if
+			       multiple signs exist on the line */
+#endif
+
+#if defined(FEAT_GUI) && defined(FEAT_XCLIPBOARD)
+# ifdef FEAT_GUI_GTK
+   /* Avoid using a global variable for the X display.  It's ugly
+    * and is likely to cause trouble in multihead environments. */
+#  define X_DISPLAY	((gui.in_use) ? gui_mch_get_display() : xterm_dpy)
+# else
+#  define X_DISPLAY	(gui.in_use ? gui.dpy : xterm_dpy)
+# endif
+#else
+# ifdef FEAT_GUI
+#  ifdef FEAT_GUI_GTK
+#   define X_DISPLAY	((gui.in_use) ? gui_mch_get_display() : (Display *)NULL)
+#  else
+#   define X_DISPLAY	gui.dpy
+#  endif
+# else
+#  define X_DISPLAY	xterm_dpy
+# endif
+#endif
+
+#if defined(FEAT_BROWSE) && defined(GTK_CHECK_VERSION)
+# if GTK_CHECK_VERSION(2,4,0)
+#  define USE_FILE_CHOOSER
+# endif
+#endif
+
+#ifndef FEAT_NETBEANS_INTG
+# undef NBDEBUG
+#endif
+#ifdef NBDEBUG /* Netbeans debugging. */
+# include "nbdebug.h"
+#else
+# define nbdebug(a)
+#endif
+
+#ifdef IN_PERL_FILE
+  /*
+   * Avoid clashes between Perl and Vim namespace.
+   */
+# undef NORMAL
+# undef STRLEN
+# undef FF
+# undef OP_DELETE
+# undef OP_JOIN
+# ifdef __BORLANDC__
+#  define NOPROTO 1
+# endif
+  /* remove MAX and MIN, included by glib.h, redefined by sys/param.h */
+# ifdef MAX
+#  undef MAX
+# endif
+# ifdef MIN
+#  undef MIN
+# endif
+  /* We use _() for gettext(), Perl uses it for function prototypes... */
+# ifdef _
+#  undef _
+# endif
+# ifdef DEBUG
+#  undef DEBUG
+# endif
+# ifdef _DEBUG
+#  undef _DEBUG
+# endif
+# ifdef instr
+#  undef instr
+# endif
+  /* bool may cause trouble on some old versions of Mac OS X but is required
+   * on a few other systems and for Perl */
+# if (defined(MACOS_X) && !defined(MAC_OS_X_VERSION_10_6)) \
+				       && defined(bool) && !defined(FEAT_PERL)
+#  undef bool
+# endif
+
+# ifdef __BORLANDC__
+  /* Borland has the structure stati64 but not _stati64 */
+#  define _stati64 stati64
+# endif
+#endif
+
+/* values for vim_handle_signal() that are not a signal */
+#define SIGNAL_BLOCK	-1
+#define SIGNAL_UNBLOCK  -2
+#if !defined(UNIX) && !defined(VMS)
+# define vim_handle_signal(x) 0
+#endif
+
+/* flags for skip_vimgrep_pat() */
+#define VGR_GLOBAL	1
+#define VGR_NOJUMP	2
+
+/* behavior for bad character, "++bad=" argument */
+#define BAD_REPLACE	'?'	/* replace it with '?' (default) */
+#define BAD_KEEP	-1	/* leave it */
+#define BAD_DROP	-2	/* erase it */
+
+/* last argument for do_source() */
+#define DOSO_NONE	0
+#define DOSO_VIMRC	1	/* loading vimrc file */
+#define DOSO_GVIMRC	2	/* loading gvimrc file */
+
+/* flags for read_viminfo() and children */
+#define VIF_WANT_INFO		1	/* load non-mark info */
+#define VIF_WANT_MARKS		2	/* load file marks */
+#define VIF_FORCEIT		4	/* overwrite info already read */
+#define VIF_GET_OLDFILES	8	/* load v:oldfiles */
+
+/* flags for buf_freeall() */
+#define BFA_DEL		1	/* buffer is going to be deleted */
+#define BFA_WIPE	2	/* buffer is going to be wiped out */
+#define BFA_KEEP_UNDO	4	/* do not free undo information */
+
+/* direction for nv_mousescroll() and ins_mousescroll() */
+#define MSCR_DOWN	0	/* DOWN must be FALSE */
+#define MSCR_UP		1
+#define MSCR_LEFT	-1
+#define MSCR_RIGHT	-2
+
+#define KEYLEN_PART_KEY -1	/* keylen value for incomplete key-code */
+#define KEYLEN_PART_MAP -2	/* keylen value for incomplete mapping */
+#define KEYLEN_REMOVED  9999	/* keylen value for removed sequence */
+
+/* Return values from win32_fileinfo(). */
+#define FILEINFO_OK	     0
+#define FILEINFO_ENC_FAIL    1	/* enc_to_utf16() failed */
+#define FILEINFO_READ_FAIL   2	/* CreateFile() failed */
+#define FILEINFO_INFO_FAIL   3	/* GetFileInformationByHandle() failed */
+
+/* Return value from get_option_value_strict */
+#define SOPT_BOOL	0x01	/* Boolean option */
+#define SOPT_NUM	0x02	/* Number option */
+#define SOPT_STRING	0x04	/* String option */
+#define SOPT_GLOBAL	0x08	/* Option has global value */
+#define SOPT_WIN	0x10	/* Option has window-local value */
+#define SOPT_BUF	0x20	/* Option has buffer-local value */
+#define SOPT_UNSET	0x40	/* Option does not have local value set */
+
+/* Option types for various functions in option.c */
+#define SREQ_GLOBAL	0	/* Request global option */
+#define SREQ_WIN	1	/* Request window-local option */
+#define SREQ_BUF	2	/* Request buffer-local option */
+
+/* Flags for get_reg_contents */
+#define GREG_NO_EXPR	1	/* Do not allow expression register */
+#define GREG_EXPR_SRC	2	/* Return expression itself for "=" register */
+#define GREG_LIST	4	/* Return list */
+
+/* Character used as separated in autoload function/variable names. */
+#define AUTOLOAD_CHAR '#'
+
+#ifdef FEAT_JOB_CHANNEL
+# define MAX_OPEN_CHANNELS 10
+#else
+# define MAX_OPEN_CHANNELS 0
+#endif
+
+/* Options for json_encode() and json_decode. */
+#define JSON_JS		1   /* use JS instead of JSON */
+#define JSON_NO_NONE	2   /* v:none item not allowed */
+#define JSON_NL		4   /* append a NL */
+
+/* Used for flags of do_in_path() */
+#define DIP_ALL	    0x01	/* all matches, not just the first one */
+#define DIP_DIR	    0x02	/* find directories instead of files. */
+#define DIP_ERR	    0x04	/* give an error message when none found. */
+#define DIP_START   0x08	/* also use "start" directory in 'packpath' */
+#define DIP_OPT	    0x10	/* also use "opt" directory in 'packpath' */
+#define DIP_NORTP   0x20	/* do not use 'runtimepath' */
+#define DIP_NOAFTER 0x40	/* skip "after" directories */
+#define DIP_AFTER   0x80	/* only use "after" directories */
+
+/* Lowest number used for window ID. Cannot have this many windows. */
+#define LOWEST_WIN_ID 1000
+
+/* Used by the garbage collector. */
+#define COPYID_INC 2
+#define COPYID_MASK (~0x1)
+
+/* Values for trans_function_name() argument: */
+#define TFN_INT		1	/* internal function name OK */
+#define TFN_QUIET	2	/* no error messages */
+#define TFN_NO_AUTOLOAD	4	/* do not use script autoloading */
+#define TFN_NO_DEREF	8	/* do not dereference a Funcref */
+#define TFN_READ_ONLY	16	/* will not change the var */
+
+/* Values for get_lval() flags argument: */
+#define GLV_QUIET	TFN_QUIET	/* no error messages */
+#define GLV_NO_AUTOLOAD	TFN_NO_AUTOLOAD	/* do not use script autoloading */
+#define GLV_READ_ONLY	TFN_READ_ONLY	/* will not change the var */
+
+#define DO_NOT_FREE_CNT 99999	/* refcount for dict or list that should not
+				   be freed. */
+
+/* errors for when calling a function */
+#define ERROR_UNKNOWN	0
+#define ERROR_TOOMANY	1
+#define ERROR_TOOFEW	2
+#define ERROR_SCRIPT	3
+#define ERROR_DICT	4
+#define ERROR_NONE	5
+#define ERROR_OTHER	6
+#define ERROR_DELETED	7
+
+/* flags for find_name_end() */
+#define FNE_INCL_BR	1	/* include [] in name */
+#define FNE_CHECK_START	2	/* check name starts with valid character */
+
+/* BSD is supposed to cover FreeBSD and similar systems. */
+#if (defined(SUN_SYSTEM) || defined(BSD) || defined(__FreeBSD_kernel__)) \
+	&& (defined(S_ISCHR) || defined(S_IFCHR))
+# define OPEN_CHR_FILES
+#endif
+
+/* stat macros */
+#ifndef S_ISDIR
+# ifdef S_IFDIR
+#  define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
+# else
+#  define S_ISDIR(m)	0
+# endif
+#endif
+#ifndef S_ISREG
+# ifdef S_IFREG
+#  define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
+# else
+#  define S_ISREG(m)	0
+# endif
+#endif
+#ifndef S_ISBLK
+# ifdef S_IFBLK
+#  define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
+# else
+#  define S_ISBLK(m)	0
+# endif
+#endif
+#ifndef S_ISSOCK
+# ifdef S_IFSOCK
+#  define S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)
+# else
+#  define S_ISSOCK(m)	0
+# endif
+#endif
+#ifndef S_ISFIFO
+# ifdef S_IFIFO
+#  define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
+# else
+#  define S_ISFIFO(m)	0
+# endif
+#endif
+#ifndef S_ISCHR
+# ifdef S_IFCHR
+#  define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
+# else
+#  define S_ISCHR(m)	0
+# endif
+#endif
+#ifndef S_ISLNK
+# ifdef S_IFLNK
+#  define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
+# else
+#  define S_ISLNK(m)	0
+# endif
+#endif
+
+#if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+# define ELAPSED_TIMEVAL
+# define ELAPSED_INIT(v) gettimeofday(&v, NULL)
+# define ELAPSED_FUNC(v) elapsed(&v)
+# define ELAPSED_TYPE struct timeval
+    long elapsed(struct timeval *start_tv);
+#else
+# if defined(WIN32)
+#  define ELAPSED_TICKCOUNT
+#  define ELAPSED_INIT(v) v = GetTickCount()
+#  define ELAPSED_FUNC(v) elapsed(v)
+#  define ELAPSED_TYPE DWORD
+#   ifndef PROTO
+     long elapsed(DWORD start_tick);
+#   endif
+# endif
+#endif
+
+/* Replacement for nchar used by nv_replace(). */
+#define REPLACE_CR_NCHAR    -1
+#define REPLACE_NL_NCHAR    -2
+
+/* flags for term_start() */
+#define TERM_START_NOJOB	1
+#define TERM_START_FORCEIT	2
+#define TERM_START_SYSTEM	4
+
+// Used for icon/title save and restore.
+#define SAVE_RESTORE_TITLE	1
+#define SAVE_RESTORE_ICON	2
+#define SAVE_RESTORE_BOTH	(SAVE_RESTORE_TITLE | SAVE_RESTORE_ICON)
+
+#endif /* VIM__H */
