From a360f4b065a6e6f8d5054bb81c7db520f6b974c5 Mon Sep 17 00:00:00 2001
From: "Roger B. Dannenberg" <rbd@cs.cmu.edu>
Date: Tue, 1 Mar 2022 16:56:40 -0500
Subject: Adding missing file to repo


diff --git a/pm_test/pmlist.c b/pm_test/pmlist.c
new file mode 100644
index 0000000..5e3d1db
--- /dev/null
+++ b/pm_test/pmlist.c
@@ -0,0 +1,63 @@
+/* pmlist.c -- list portmidi devices and numbers
+ *
+ * This program lists devices. When you type return, it
+ * restarts portmidi and lists devices again. It is mainly
+ * a test for shutting down and restarting.
+ *
+ * Roger B. Dannenberg, Feb 2022
+ */
+
+#include "portmidi.h"
+#include "porttime.h"
+#include "stdlib.h"
+#include "stdio.h"
+#include "string.h"
+#include "assert.h"
+
+#define DEVICE_INFO NULL
+#define DRIVER_INFO NULL
+#define TIME_START Pt_Start(1, 0, 0) /* timer started w/millisecond accuracy */
+
+#define STRING_MAX 80 /* used for console input */
+
+void show_usage()
+{
+    printf("Usage: pmlist [-h]\n        -h means help.\n"
+           "    Type return to rescan and list devices, q<ret> to quit\n");
+}
+
+
+int main(int argc, char *argv[])
+{
+    if (argc > 1) {
+        show_usage();
+        exit(0);
+    }
+
+    while (1) {
+        char input[STRING_MAX];
+        const char *deflt;
+        const char *in_or_out;
+        int default_in, default_out, i;
+
+        // Pm_Initialize();
+        /* list device information */
+        default_in = Pm_GetDefaultInputDeviceID();
+        default_out = Pm_GetDefaultOutputDeviceID();
+        for (i = 0; i < Pm_CountDevices(); i++) {
+            const PmDeviceInfo *info = Pm_GetDeviceInfo(i);
+            printf("%d: %s, %s", i, info->interf, info->name);
+            deflt = "";
+            if (i == default_out || i == default_in) {
+                deflt = "default ";
+            }
+            in_or_out = (info->input ? "input" : "output");
+            printf(" (%s%s)\n", deflt, in_or_out);
+        }
+        if (fgets(input, STRING_MAX, stdin) && input[0] == 'q') {
+            return 0;
+        }
+        Pm_Terminate();
+    }
+    return 0;
+}
-- 
2.36.1


From f0487e3bcfad4af73b2ebffd254e4aaeb732fec6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joachim=20Mairb=C3=B6ck?= <j.mairboeck@gmail.com>
Date: Sat, 6 Aug 2022 21:22:46 +0200
Subject: fix build on Haiku


diff --git a/pm_test/CMakeLists.txt b/pm_test/CMakeLists.txt
index 5011311..c04b6e8 100644
--- a/pm_test/CMakeLists.txt
+++ b/pm_test/CMakeLists.txt
@@ -14,6 +14,10 @@ endif(APPLE)
 #   endif()
 # endif(WIN32)
 
+if(HAIKU)
+  add_compile_options(-fPIC)
+endif()
+
 macro(add_test name)
   add_executable(${name} ${name}.c)
   target_link_libraries(${name} PRIVATE portmidi)
-- 
2.36.1


From e5c17d1864112bf9625772d6011833d5ad8687f3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joachim=20Mairb=C3=B6ck?= <j.mairboeck@gmail.com>
Date: Sat, 6 Aug 2022 19:56:47 +0200
Subject: gcc2 fixes


diff --git a/pm_common/pminternal.h b/pm_common/pminternal.h
index b8af9c9..d28f5fb 100755
--- a/pm_common/pminternal.h
+++ b/pm_common/pminternal.h
@@ -175,8 +175,7 @@ void pm_read_short(PmInternal *midi, PmEvent *event);
 #define success_poll pm_success_fn
 
 #define MIDI_REALTIME_MASK 0xf8
-#define is_real_time(msg) \
-    ((Pm_MessageStatus(msg) & MIDI_REALTIME_MASK) == MIDI_REALTIME_MASK)
+#define is_real_time(msg) ((Pm_MessageStatus(msg) & MIDI_REALTIME_MASK) == MIDI_REALTIME_MASK)
 
 int pm_find_default_device(char *pattern, int is_input);
 
diff --git a/pm_common/portmidi.c b/pm_common/portmidi.c
index 9e0ce98..7b7cebe 100755
--- a/pm_common/portmidi.c
+++ b/pm_common/portmidi.c
@@ -841,6 +841,7 @@ PmError pm_create_internal(PmInternal **stream, PmDeviceID device_id,
                            int is_input, int latency, PmTimeProcPtr time_proc,
                            void *time_info, int buffer_size)
 {
+    PmInternal *midi;
     if (device_id < 0 || device_id >= pm_descriptor_len) {
        return pmInvalidDeviceId;
     }
@@ -848,7 +849,7 @@ PmError pm_create_internal(PmInternal **stream, PmDeviceID device_id,
         latency = 0;
     }
     /* create portMidi internal data */
-    PmInternal *midi = (PmInternal *) pm_alloc(sizeof(PmInternal)); 
+    midi = (PmInternal *) pm_alloc(sizeof(PmInternal)); 
     *stream = midi;
     if (!midi) {
         return pmInsufficientMemory;
diff --git a/pm_test/fast.c b/pm_test/fast.c
index b3290c0..102697e 100644
--- a/pm_test/fast.c
+++ b/pm_test/fast.c
@@ -75,15 +75,20 @@ void fast_test()
     char line[STRING_MAX];
     int pause = FALSE;  /* pause if this is a virtual output port */
     PmError err = pmNoError;
+    /* output buffer size should be a little more than
+       msgrate * latency / 1000. PortMidi will guarantee
+       a minimum of latency / 2 */
+    int buffer_size = msgrate * latency / 900;
+    PmTimestamp start, now;
+    int msgcnt = 0;
+    int polling_count = 0;
+    int pitch = 60;
+    int printtime = 1000;
 
     /* It is recommended to start timer before PortMidi */
     TIME_START;
 
     /* open output device */
-    /* output buffer size should be a little more than
-       msgrate * latency / 1000. PortMidi will guarantee
-       a minimum of latency / 2 */
-    int buffer_size = msgrate * latency / 900;
     if (deviceno == Pm_CountDevices()) {
         deviceno = Pm_CreateVirtualOutput("fast", NULL, DEVICE_INFO);
         if (deviceno >= 0) {
@@ -110,7 +115,7 @@ void fast_test()
         while (getchar() != '\n') ;
     }
     /* wait a sec after printing previous line */
-    PmTimestamp start = get_time(NULL) + 1000;
+    start = get_time(NULL) + 1000;
     while (start > get_time(NULL)) {
         Sleep(10);
     }
@@ -118,11 +123,7 @@ void fast_test()
     fflush(stdout); /* make sure message goes to console */
 
     /* every 10ms send on/off pairs at timestamps set to current time */
-    PmTimestamp now = get_time(NULL);
-    int msgcnt = 0;
-    int polling_count = 0;
-    int pitch = 60;
-    int printtime = 1000;
+    now = get_time(NULL);
     /* if expired_timestamps, we want to send timestamps that have
      * expired. They should be sent immediately, but there's a suggestion
      * that negative delay might cause problems in the ALSA implementation
diff --git a/pm_test/fastrcv.c b/pm_test/fastrcv.c
index d751c70..daee40c 100644
--- a/pm_test/fastrcv.c
+++ b/pm_test/fastrcv.c
@@ -84,6 +84,16 @@ void fastrcv_test()
     PmStream * midi;
     PmError status, length;
     PmEvent buffer[1];
+    PmTimestamp start;
+    /* every 10ms read all messages, keep counts */
+    /* every 1000ms, print report */
+    int msgcnt = 0;
+    /* expect repeating sequence of 60 through 71, alternating on/off */
+    int expected_pitch = 60;
+    int expected_on = TRUE;
+    int report_time;
+    PmTimestamp last_timestamp = -1;
+    PmTimestamp last_delta = -1;
 
     /* It is recommended to start timer before PortMidi */
     TIME_START;
@@ -101,20 +111,12 @@ void fastrcv_test()
     printf("Midi Input opened.\n");
 
     /* wait a sec after printing previous line */
-    PmTimestamp start = Pt_Time() + 1000;
+    start = Pt_Time() + 1000;
     while (start > Pt_Time()) {
         Sleep(10);
     }
 
-    /* every 10ms read all messages, keep counts */
-    /* every 1000ms, print report */
-    int msgcnt = 0;
-    /* expect repeating sequence of 60 through 71, alternating on/off */
-    int expected_pitch = 60;
-    int expected_on = TRUE;
-    int report_time = Pt_Time() + 1000;  /* report every 1s */
-    PmTimestamp last_timestamp = -1;
-    PmTimestamp last_delta = -1;
+    report_time = Pt_Time() + 1000;  /* report every 1s */
     while (TRUE) {
         PmTimestamp now = Pt_Time();
         status = Pm_Poll(midi);
diff --git a/pm_test/midithru.c b/pm_test/midithru.c
index 36d201f..eba4356 100755
--- a/pm_test/midithru.c
+++ b/pm_test/midithru.c
@@ -316,8 +316,9 @@ void initialize(int input, int output, int virtual)
                       NULL /* time info */,
                       0 /* Latency */);
     } else { /* send to virtual port */
+        int id;
         printf("Opening virtual output device \"midithru\"\n");
-        int id = Pm_CreateVirtualOutput("midithru", NULL, NULL);
+        id = Pm_CreateVirtualOutput("midithru", NULL, NULL);
         if (id < 0) checkerror(id);  /* error reporting */
         checkerror(Pm_OpenOutput(&midi_out, id, NULL, OUT_QUEUE_SIZE,
                                  &midithru_time_proc, NULL, 0));
@@ -342,8 +343,9 @@ void initialize(int input, int output, int virtual)
                      &midithru_time_proc,
                      NULL /* time info */);
     } else { /* receive from virtual port */
+        int id;
         printf("Opening virtual input device \"midithru\"\n");
-        int id = Pm_CreateVirtualInput("midithru", NULL, NULL);
+        id = Pm_CreateVirtualInput("midithru", NULL, NULL);
         if (id < 0) checkerror(id);  /* error reporting */
         checkerror(Pm_OpenInput(&midi_in, id, NULL, 0,
                                 &midithru_time_proc, NULL));
diff --git a/pm_test/recvvirtual.c b/pm_test/recvvirtual.c
index 26c6fa6..8ac97be 100644
--- a/pm_test/recvvirtual.c
+++ b/pm_test/recvvirtual.c
@@ -45,13 +45,15 @@ void main_test_input(int num)
     PmStream *midi;
     PmError status, length;
     PmEvent buffer[1];
+    int id;
+    int i = 0; /* count messages as they arrive */
     /* It is recommended to start timer before Midi; otherwise, PortMidi may
        start the timer with its (default) parameters
      */
     TIME_START;
 
     /* create a virtual input device */
-    int id = checkerror(Pm_CreateVirtualInput("portmidi", NULL, DRIVER_INFO));
+    id = checkerror(Pm_CreateVirtualInput("portmidi", NULL, DRIVER_INFO));
     checkerror(Pm_OpenInput(&midi, id, NULL, 0, NULL, NULL));
 
     printf("Midi Input opened. Reading %d Midi messages...\n", num);
@@ -62,7 +64,6 @@ void main_test_input(int num)
         Pm_Read(midi, buffer, 1);
     }
     /* now start paying attention to messages */
-    int i = 0; /* count messages as they arrive */
     while (i < num) {
         status = Pm_Poll(midi);
         if (status == TRUE) {
diff --git a/pm_test/sendvirtual.c b/pm_test/sendvirtual.c
index 2b74b7f..14c6e9e 100644
--- a/pm_test/sendvirtual.c
+++ b/pm_test/sendvirtual.c
@@ -62,6 +62,7 @@ void main_test_output(int num)
     PmEvent buffer[1];
     PmTimestamp timestamp;
     int pitch = 60;
+    int id;
 
     /* It is recommended to start timer before Midi; otherwise, PortMidi may
        start the timer with its (default) parameters
@@ -69,7 +70,7 @@ void main_test_output(int num)
     TIME_START;
 
     /* create a virtual output device */
-    int id = checkerror(Pm_CreateVirtualOutput("portmidi", NULL, DEVICE_INFO));
+    id = checkerror(Pm_CreateVirtualOutput("portmidi", NULL, DEVICE_INFO));
     checkerror(Pm_OpenOutput(&midi, id, DRIVER_INFO, OUTPUT_BUFFER_SIZE,
                              TIME_PROC, TIME_INFO, latency));
 
diff --git a/pm_test/testio.c b/pm_test/testio.c
index 97387b5..c71ae08 100755
--- a/pm_test/testio.c
+++ b/pm_test/testio.c
@@ -156,6 +156,8 @@ void main_test_output(int isochronous_test)
     Pm_Write(midi, buffer, 1);
 
     if (isochronous_test) { // play 4 notes per sec for 20s 
+        int count;
+        PmTimestamp start;
         if (latency < 100) {
             printf("Warning: latency < 100, but this test sends messages"
                    " at times that are jittered by up to 100ms, so you"
@@ -163,15 +165,15 @@ void main_test_output(int isochronous_test)
         }
         printf("Starting in 1s..."); fflush(stdout);
         Pt_Sleep(1000);
-        int count;
-        PmTimestamp start = Pt_Time();
+        start = Pt_Time();
         for (count = 0; count < 80; count++) {
+            PmTimestamp next_time;
             buffer[0].timestamp = start + count * 250;
             buffer[0].message = Pm_Message(0x90, 69, 100);
             buffer[1].timestamp = start + count * 250 + 200;
             buffer[1].message = Pm_Message(0x90, 69, 0);
             Pm_Write(midi, buffer, 2);
-            PmTimestamp next_time = start + (count + 1) * 250;
+            next_time = start + (count + 1) * 250;
             // sleep for a random time up to 100ms to add jitter to
             // the times at which we send messages. PortMidi timing
             // should remove the jitter if latency > 100
diff --git a/pm_test/virttest.c b/pm_test/virttest.c
index ba8b502..1aeb09b 100644
--- a/pm_test/virttest.c
+++ b/pm_test/virttest.c
@@ -167,7 +167,8 @@ void check_ports(int cnt, int in_id, char in_stat,
 
 void devices_list()
 {
-    for (int i = 0; i < Pm_CountDevices(); i++) {
+    int i;
+    for (i = 0; i < Pm_CountDevices(); i++) {
         const PmDeviceInfo *info = Pm_GetDeviceInfo(i);
         if (info) {
             printf("%d: %s %s %s %s\n", i, info->name,
@@ -189,12 +190,13 @@ void test2()
     PmTimestamp timestamp;
     int pitch = 60;
     int device_count = 0;
+    int i;
 
     printf("This must be virttest instance #2\n");
 
     /* find and open portmidi in and out */
     device_count = Pm_CountDevices();
-    for (int i = 0; i < device_count; i++) {
+    for (i = 0; i < device_count; i++) {
         const PmDeviceInfo *info = Pm_GetDeviceInfo(i);
         if (info && strcmp(info->name, "portmidi") == 0) {
             if (info->input) {
@@ -326,8 +328,8 @@ void test()
 
 int main(int argc, char *argv[])
 {
-    show_usage();
     int i;
+    show_usage();
     for (i = 0; i < 3; i++) {
         test();
     }    
-- 
2.36.1


From ff2ccbf76008b39ff5e0e02256dbaa7cd1f43397 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joachim=20Mairb=C3=B6ck?= <j.mairboeck@gmail.com>
Date: Sun, 7 Aug 2022 13:33:49 +0200
Subject: portmidi Haiku backend (part 1, just a stub for now)


diff --git a/pm_common/CMakeLists.txt b/pm_common/CMakeLists.txt
index 8c55f1f..c83c9f5 100644
--- a/pm_common/CMakeLists.txt
+++ b/pm_common/CMakeLists.txt
@@ -98,6 +98,12 @@ if(UNIX AND APPLE)
       ${COREFOUNDATION_LIBRARY} ${COREMIDI_LIBRARY} ${CORESERVICES_LIBRARY})
   # set to CMake default; is this right?:
   set_target_properties(portmidi PROPERTIES MACOSX_RPATH ON)
+elseif(HAIKU)
+  set(PM_LIB_PRIVATE_SRC
+      ${PMDIR}/porttime/pthaiku.cpp
+      ${PMDIR}/pm_haiku/pmhaiku.cpp)
+  set(PM_NEEDED_LIBS be PARENT_SCOPE)
+  target_link_libraries(portmidi PRIVATE be)
 elseif(UNIX)
   target_compile_definitions(portmidi PRIVATE ${LINUX_FLAGS})
   set(PM_LIB_PRIVATE_SRC
diff --git a/pm_haiku/pmhaiku.cpp b/pm_haiku/pmhaiku.cpp
new file mode 100644
index 0000000..5c64c5c
--- /dev/null
+++ b/pm_haiku/pmhaiku.cpp
@@ -0,0 +1,138 @@
+/* pmhaiku.cpp -- PortMidi os-dependent code */
+
+#include <stdlib.h>
+#include "portmidi.h"
+#include "pmutil.h"
+#include "pminternal.h"
+
+namespace {
+    PmTimestamp synchronize(pm_internal_struct *midi) {
+        return 0;
+    }
+
+    PmError in_open(pm_internal_struct *midi, void *driverInfo) {
+        return pmNoError;
+    }
+
+    PmError in_abort(pm_internal_struct *midi) {
+        return pmNoError;
+    }
+
+    PmError in_close(pm_internal_struct *midi) {
+        return pmNoError;
+    }
+
+    PmError out_open(pm_internal_struct *midi, void *driverInfo) {
+        return pmNoError;
+    }
+
+    PmError out_abort(pm_internal_struct *midi) {
+        return pmNoError;
+    }
+
+    PmError out_close(pm_internal_struct *midi) {
+        return pmNoError;
+    }
+
+    PmError write_short(pm_internal_struct *midi, PmEvent *buffer) {
+        return pmNoError;
+    }
+
+    PmError begin_sysex(pm_internal_struct *midi, PmTimestamp timestamp) {
+        return pmNoError;
+    }
+
+    PmError end_sysex(pm_internal_struct *midi, PmTimestamp timestamp) {
+        return pmNoError;
+    }
+
+    PmError write_byte(pm_internal_struct *midi, unsigned char byte, PmTimestamp timestamp) {
+        return pmNoError;
+    }
+
+    PmError write_realtime(pm_internal_struct *midi, PmEvent *buffer) {
+        return pmNoError;
+    }
+
+    PmError write_flush(pm_internal_struct *midi, PmTimestamp timestamp) {
+        return pmNoError;
+    }
+
+    unsigned int check_host_error(pm_internal_struct *midi) {
+        return 0;
+    }
+
+    pm_fns_node pm_in_dictionary = {
+        none_write_short,
+        none_sysex,
+        none_sysex,
+        none_write_byte,
+        none_write_short,
+        none_write_flush,
+        synchronize,
+        in_open,
+        in_abort,
+        in_close,
+        success_poll,
+        check_host_error
+    };
+
+    pm_fns_node pm_out_dictionary = {
+        write_short,
+        begin_sysex,
+        end_sysex,
+        write_byte,
+        write_realtime,
+        write_flush,
+        synchronize,
+        out_open,
+        out_abort,
+        out_close,
+        none_poll,
+        check_host_error
+    };
+
+
+    PmError create_virtual(int is_input, const char* name, void* driverInfo) {
+        return pmNoError;
+    }
+
+    PmError delete_virtual(PmDeviceID id) {
+        return pmNoError;
+    }
+}
+
+extern "C" {
+    void pm_init() {
+        pm_add_interf(const_cast<char*>("Haiku MIDI kit"), create_virtual, delete_virtual);
+        pm_add_device(const_cast<char*>("Haiku MIDI kit Input"), "", 1, 0, NULL, &pm_in_dictionary);
+        pm_add_device(const_cast<char*>("Haiku MIDI kit Output"), "", 0, 0, NULL, &pm_out_dictionary);
+    }
+
+
+    void pm_term() {
+        // TODO: implement
+    }
+
+
+    PmDeviceID Pm_GetDefaultInputDeviceID() {
+        // TODO: implement
+        return pmNoDevice; 
+    }
+
+
+    PmDeviceID Pm_GetDefaultOutputDeviceID() {
+        // TODO: implement
+        return pmNoDevice;
+    }
+
+
+    void *pm_alloc(size_t s) {
+        return malloc(s); 
+    }
+
+
+    void pm_free(void *ptr) { 
+         free(ptr); 
+    }
+}
diff --git a/porttime/pthaiku.cpp b/porttime/pthaiku.cpp
new file mode 100644
index 0000000..4078632
--- /dev/null
+++ b/porttime/pthaiku.cpp
@@ -0,0 +1,87 @@
+// pthaiku.cpp - portable timer implementation for Haiku
+
+#include "porttime.h"
+#include <Looper.h>
+#include <MessageRunner.h>
+#include <OS.h>
+
+namespace {
+    const uint32 timerMessage = 'PTTM';
+
+    struct TimerLooper : BLooper {
+        TimerLooper() : BLooper() {
+        }
+
+        virtual void MessageReceived(BMessage *message)
+        {
+            PtCallback *callback;
+            void *userData;
+            if (message->what == timerMessage && message->FindPointer("callback", (void**)&callback) == B_OK && message->FindPointer("userData", &userData) == B_OK) {
+                (*callback)(Pt_Time(), userData);
+            }
+            BLooper::MessageReceived(message);
+        }
+    };
+
+    bool time_started_flag = false;
+    bigtime_t time_offset;
+    TimerLooper *timerLooper;
+    BMessageRunner *timerRunner;
+}
+
+extern "C" {
+    PtError Pt_Start(int resolution, PtCallback *callback, void *userData)
+    {
+        if (time_started_flag) return ptAlreadyStarted;
+        time_offset = system_time();
+        if (callback) {
+            timerLooper = new TimerLooper;
+            timerLooper->Run();
+            BMessenger target(timerLooper);
+		    BMessage message(timerMessage);
+            message.AddPointer("callback", (void*)callback);
+            message.AddPointer("userData", userData);
+            bigtime_t interval = resolution * 1000;
+            timerRunner = new BMessageRunner(target, &message, interval);
+		    if(timerRunner->InitCheck() != B_OK) {
+                delete timerRunner;
+                timerRunner = NULL;
+                timerLooper->PostMessage(B_QUIT_REQUESTED);
+                timerLooper = NULL;
+                return ptHostError;
+            }
+        }
+        time_started_flag = true;
+        return ptNoError;
+    }
+
+
+    PtError Pt_Stop()
+    {
+        if (!time_started_flag) return ptAlreadyStopped;
+        time_started_flag = false;
+        delete timerRunner;
+        timerRunner = NULL;
+        timerLooper->PostMessage(B_QUIT_REQUESTED);
+        timerLooper = NULL;
+        return ptNoError;
+    }
+
+
+    int Pt_Started()
+    {
+        return time_started_flag;
+    }
+
+
+    PtTimestamp Pt_Time()
+    {
+        return (system_time() - time_offset) / 1000;
+    }
+
+
+    void Pt_Sleep(int32_t duration)
+    {
+        snooze(duration * 1000);
+    }
+}
-- 
2.36.1

