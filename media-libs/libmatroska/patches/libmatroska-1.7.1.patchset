From d1d37bad4b90a57e5f06ebe0bc6ca5d450c220be Mon Sep 17 00:00:00 2001
From: robxnano <89391914+robxnano@users.noreply.github.com>
Date: Fri, 14 Jul 2023 14:15:59 +0100
Subject: [PATCH] Use C++ std int types and remove C headers

Cherry-picked from libmatroska development branch.
---
 CMakeLists.txt             |   7 +--
 matroska/FileKax.h         |  36 ++++++-------
 matroska/KaxBlock.h        |  68 +++++++++++------------
 matroska/KaxBlockData.h    |   2 +-
 matroska/KaxCluster.h      |  29 +++++-----
 matroska/KaxCues.h         |  10 ++--
 matroska/KaxCuesData.h     |  18 +++----
 matroska/KaxSeekHead.h     |   2 +-
 matroska/KaxSegment.h      |   6 +--
 matroska/KaxTracks.h       |   8 +--
 matroska/KaxTypes.h        |  55 ++++++++++++++++++-
 matroska/c/libmatroska.h   |   6 +--
 matroska/c/libmatroska_t.h |  66 +----------------------
 src/FileKax.cpp            |  34 ++++++------
 src/KaxBlock.cpp           | 107 +++++++++++++++++++------------------
 src/KaxBlockData.cpp       |   2 +-
 src/KaxCluster.cpp         |  34 ++++++------
 src/KaxCues.cpp            |  12 ++---
 src/KaxCuesData.cpp        |  28 +++++-----
 src/KaxSeekHead.cpp        |   4 +-
 src/KaxSegment.cpp         |   6 +--
 test/ebml/test0.cpp        |   4 +-
 test/mux/test6.cpp         |   8 +--
 test/mux/test8.cpp         |  54 +++++++++----------
 24 files changed, 297 insertions(+), 309 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8fed3ca..326e707 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -58,11 +58,7 @@ set(libmatroska_PUBLIC_HEADERS
   matroska/KaxTypes.h
   matroska/KaxVersion.h)
 
-set (libmatroska_C_PUBLIC_HEADERS
-  matroska/c/libmatroska.h
-  matroska/c/libmatroska_t.h)
-
-add_library(matroska ${libmatroska_SOURCES} ${libmatroska_PUBLIC_HEADERS} ${libmatroska_C_PUBLIC_HEADERS})
+add_library(matroska ${libmatroska_SOURCES} ${libmatroska_PUBLIC_HEADERS})
 target_link_libraries(matroska PUBLIC EBML::ebml)
 set_target_properties(matroska PROPERTIES
   VERSION 7.0.0
@@ -98,7 +94,6 @@ install(TARGETS matroska
   LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
 
 install(FILES ${libmatroska_PUBLIC_HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/matroska)
-install(FILES ${libmatroska_C_PUBLIC_HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/matroska/c)
 install(FILES ${CMAKE_CURRENT_BINARY_DIR}/matroska_export.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/matroska)
 
 if(NOT DISABLE_PKGCONFIG)
diff --git a/matroska/FileKax.h b/matroska/FileKax.h
index b234720..b172301 100644
--- a/matroska/FileKax.h
+++ b/matroska/FileKax.h
@@ -64,23 +64,23 @@ class MATROSKA_DLL_API FileMatroska {
     ~FileMatroska() = default;
 #ifdef OLD
   filepos_t RenderHead(const std::string & aEncoderApp);
-  uint32 ReadHead();
-  uint32 ReadTracks();
-  uint32 ReadCodec();
-  void Close(const uint32 aTimeLength);
+  std::uint32_t ReadHead();
+  std::uint32_t ReadTracks();
+  std::uint32_t ReadCodec();
+  void Close(const std::uint32_t aTimeLength);
 
   inline void type_SetInfo(const std::string & aStr) {myMainHeader.type_SetInfo(aStr);}
   inline void type_SetAds(const std::string & aStr) {myMainHeader.type_SetAds(aStr);}
   inline void type_SetSize(const std::string & aStr) {myMainHeader.type_SetSize(aStr);}
-  inline void type_SetSize(uint64 aSize) {myMainHeader.type_SetSize(aSize);}
+  inline void type_SetSize(std::uint64_t aSize) {myMainHeader.type_SetSize(aSize);}
 
-  inline uint8 GetTrackNumber() const { return myTracks.size(); }
+  inline std::uint8_t GetTrackNumber() const { return myTracks.size(); }
 
   void track_SetName(Track * aTrack, const std::string & aName);
   void track_SetLaced(Track * aTrack, bool bLaced = true);
 
   Track * CreateTrack(const track_type aType);
-  inline Track * GetTrack(const uint8 aTrackNb) const
+  inline Track * GetTrack(const std::uint8_t aTrackNb) const
   {
       if (aTrackNb > myTracks.size())
     return NULL;
@@ -101,13 +101,13 @@ class MATROSKA_DLL_API FileMatroska {
   /*!
       \return wether the frame has been added or not
   */
-  bool AddFrame(Track * aTrack, const uint32 aTimecode, const binary *aFrame, const uint32 aFrameSize,
+  bool AddFrame(Track * aTrack, const std::uint32_t aTimecode, const binary *aFrame, const std::uint32_t aFrameSize,
          bool aKeyFrame = true, bool aBFrame = false);
 
   /*!
       \return wether the frame has been read or not
   */
-  bool ReadFrame(Track * & aTrack, uint32 & aTimecode, const binary * & aFrame, uint32 & aFrameSize,
+  bool ReadFrame(Track * & aTrack, std::uint32_t & aTimecode, const binary * & aFrame, std::uint32_t & aFrameSize,
          bool & aKeyFrame, bool & aBFrame);
 
   /*
@@ -115,33 +115,33 @@ class MATROSKA_DLL_API FileMatroska {
   */
   void Flush();
 
-  void SetMaxClusterSize(const uint32 value);
-  void SetMinClusterSize(const uint32 value) {myMinClusterSize = value;}
+  void SetMaxClusterSize(const std::uint32_t value);
+  void SetMinClusterSize(const std::uint32_t value) {myMinClusterSize = value;}
 
     protected:
   MainHeader myMainHeader;
 
   std::vector<Track *> myTracks;
-  std::vector<uint8> mySelectedTracks;
+  std::vector<std::uint8_t> mySelectedTracks;
 
 //  Track *findTrack(Track * aTrack) const;
 
   Cluster  myCurrWriteCluster; /// \todo merge with the write one ?
-  uint32   myReadBlockNumber;
+  std::uint32_t   myReadBlockNumber;
   Cluster  myCurrReadCluster;
   binary * myCurrReadBlock;      ///< The buffer containing the current read block
-  uint32   myCurrReadBlockSize;  ///< The size of the buffer containing the current read block
-  uint8    myCurrReadBlockTrack; ///< The track number of the current track to read
+  std::uint32_t   myCurrReadBlockSize;  ///< The size of the buffer containing the current read block
+  std::uint8_t    myCurrReadBlockTrack; ///< The track number of the current track to read
 
-  uint32 myMaxClusterSize;
-  uint32 myMinClusterSize;
+  std::uint32_t myMaxClusterSize;
+  std::uint32_t myMinClusterSize;
 
   StreamInfo myStreamInfo;
 
   CodecHeader myCodecHeader;
 
   inline bool IsMyTrack(const Track * aTrack) const;
-  inline bool IsReadingTrack(const uint8 aTrackNum) const;
+  inline bool IsReadingTrack(const std::uint8_t aTrackNum) const;
 #endif // OLD
   IOCallback & myFile;
 
diff --git a/matroska/KaxBlock.h b/matroska/KaxBlock.h
index 14d7a55..25b7fc3 100644
--- a/matroska/KaxBlock.h
+++ b/matroska/KaxBlock.h
@@ -55,13 +55,13 @@ class KaxBlockBlob;
 class MATROSKA_DLL_API DataBuffer {
   protected:
     binary  *myBuffer{nullptr};
-    uint32   mySize;
+    std::uint32_t   mySize;
     bool     bValidValue{true};
     bool     (*myFreeBuffer)(const DataBuffer & aBuffer); // method to free the internal buffer
     bool     bInternalBuffer;
 
   public:
-    DataBuffer(binary * aBuffer, uint32 aSize, bool (*aFreeBuffer)(const DataBuffer & aBuffer) = nullptr, bool _bInternalBuffer = false)
+    DataBuffer(binary * aBuffer, std::uint32_t aSize, bool (*aFreeBuffer)(const DataBuffer & aBuffer) = nullptr, bool _bInternalBuffer = false)
       :mySize(aSize)
       ,myFreeBuffer(aFreeBuffer)
       ,bInternalBuffer(_bInternalBuffer)
@@ -80,9 +80,9 @@ class MATROSKA_DLL_API DataBuffer {
 
     virtual ~DataBuffer() = default;
     virtual binary * Buffer() {assert(bValidValue); return myBuffer;}
-    virtual uint32   & Size() {return mySize;};
+    virtual std::uint32_t   & Size() {return mySize;};
     virtual const binary * Buffer() const {assert(bValidValue); return myBuffer;}
-    virtual uint32   Size()   const {return mySize;};
+    virtual std::uint32_t   Size()   const {return mySize;};
     bool    FreeBuffer(const DataBuffer & aBuffer) {
       bool bResult = true;
       if (myBuffer != nullptr && bValidValue) {
@@ -102,7 +102,7 @@ class MATROSKA_DLL_API DataBuffer {
 
 class MATROSKA_DLL_API SimpleDataBuffer : public DataBuffer {
   public:
-    SimpleDataBuffer(binary * aBuffer, uint32 aSize, uint32 aOffset, bool (*aFreeBuffer)(const DataBuffer & aBuffer) = myFreeBuffer)
+    SimpleDataBuffer(binary * aBuffer, std::uint32_t aSize, std::uint32_t aOffset, bool (*aFreeBuffer)(const DataBuffer & aBuffer) = myFreeBuffer)
       :DataBuffer(aBuffer + aOffset, aSize, aFreeBuffer)
       ,Offset(aOffset)
       ,BaseBuffer(aBuffer)
@@ -112,7 +112,7 @@ class MATROSKA_DLL_API SimpleDataBuffer : public DataBuffer {
     DataBuffer * Clone() override {return new SimpleDataBuffer(*this);}
 
   protected:
-    uint32 Offset;
+    std::uint32_t Offset;
     binary * BaseBuffer;
 
     static bool myFreeBuffer(const DataBuffer & aBuffer)
@@ -131,7 +131,7 @@ class MATROSKA_DLL_API SimpleDataBuffer : public DataBuffer {
 * /
 class MATROSKA_DLL_API NotSoSimpleDataBuffer : public SimpleDataBuffer {
   public:
-    NotSoSimpleDataBuffer(binary * aBuffer, uint32 aSize, uint32 aOffset)
+    NotSoSimpleDataBuffer(binary * aBuffer, std::uint32_t aSize, std::uint32_t aOffset)
       :SimpleDataBuffer(new binary[aSize - aOffset], aSize, 0)
     {
       memcpy(BaseBuffer, aBuffer + aOffset, aSize - aOffset);
@@ -146,17 +146,17 @@ DECLARE_MKX_MASTER(KaxBlockGroup)
     /*!
       \brief Addition of a frame without references
     */
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, LacingType lacing = LACING_AUTO);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, LacingType lacing = LACING_AUTO);
     /*!
       \brief Addition of a frame with a backward reference (P frame)
     */
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, LacingType lacing = LACING_AUTO);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, LacingType lacing = LACING_AUTO);
 
     /*!
       \brief Addition of a frame with a backward+forward reference (B frame)
     */
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing = LACING_AUTO);
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, const KaxBlockBlob * PastBlock, const KaxBlockBlob * ForwBlock, LacingType lacing = LACING_AUTO);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing = LACING_AUTO);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, const KaxBlockBlob * PastBlock, const KaxBlockBlob * ForwBlock, LacingType lacing = LACING_AUTO);
 
     void SetParent(KaxCluster & aParentCluster);
 
@@ -167,21 +167,21 @@ DECLARE_MKX_MASTER(KaxBlockGroup)
     /*!
       \brief Set the duration of the contained frame(s) (for the total number of frames)
     */
-    void SetBlockDuration(uint64 TimeLength);
-    bool GetBlockDuration(uint64 &TheTimecode) const;
+    void SetBlockDuration(std::uint64_t TimeLength);
+    bool GetBlockDuration(std::uint64_t &TheTimecode) const;
 
     /*!
       \return the global timecode of this Block (not just the delta to the Cluster)
     */
-    uint64 GlobalTimecode() const;
-    uint64 GlobalTimecodeScale() const {
+    std::uint64_t GlobalTimecode() const;
+    std::uint64_t GlobalTimecodeScale() const {
       assert(ParentTrack != nullptr);
       return ParentTrack->GlobalTimecodeScale();
     }
 
-    uint16 TrackNumber() const;
+    std::uint16_t TrackNumber() const;
 
-    uint64 ClusterPosition() const;
+    std::uint64_t ClusterPosition() const;
 
     /*!
       \return the number of references to other frames
@@ -211,11 +211,11 @@ class MATROSKA_DLL_API KaxInternalBlock : public EbmlBinary {
     ~KaxInternalBlock() override;
     bool ValidateSize() const override;
 
-    uint16 TrackNum() const {return TrackNumber;}
+    std::uint16_t TrackNum() const {return TrackNumber;}
     /*!
       \todo !!!! This method needs to be changes !
     */
-    uint64 GlobalTimecode() const {return Timecode;}
+    std::uint64_t GlobalTimecode() const {return Timecode;}
 
     /*!
       \note override this function to generate the Data/Size on the fly, unlike the usual binary elements
@@ -227,12 +227,12 @@ class MATROSKA_DLL_API KaxInternalBlock : public EbmlBinary {
       \brief Only read the head of the Block (not internal data)
       \note convenient when you are parsing the file quickly
     */
-    uint64 ReadInternalHead(IOCallback & input);
+    std::uint64_t ReadInternalHead(IOCallback & input);
 
     unsigned int NumberFrames() const { return SizeList.size();}
     DataBuffer & GetBuffer(unsigned int iIndex) {return *myBuffers[iIndex];}
 
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, LacingType lacing = LACING_AUTO, bool invisible = false);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, LacingType lacing = LACING_AUTO, bool invisible = false);
 
     /*!
       \brief release all the frames of all Blocks
@@ -251,35 +251,35 @@ class MATROSKA_DLL_API KaxInternalBlock : public EbmlBinary {
       \return the position in the stream for a given frame
       \note return -1 if the position doesn't exist
     */
-    int64 GetDataPosition(size_t FrameNumber = 0);
+    std::int64_t GetDataPosition(size_t FrameNumber = 0);
 
     /*!
       \param FrameNumber 0 for the first frame
       \return the size of a given frame
       \note return -1 if the position doesn't exist
     */
-    int64 GetFrameSize(size_t FrameNumber = 0);
+    std::int64_t GetFrameSize(size_t FrameNumber = 0);
 
     bool IsInvisible() const { return mInvisible; }
 
-    uint64 ClusterPosition() const;
+    std::uint64_t ClusterPosition() const;
 
     /*!
      * \return Get the timestamp as written in the Block (not scaled).
      * \since LIBMATROSKA_VERSION >= 0x010700
      */
-    int16 GetRelativeTimestamp() const { return LocalTimecode; }
+    std::int16_t GetRelativeTimestamp() const { return LocalTimecode; }
 
   protected:
     std::vector<DataBuffer *> myBuffers;
-    std::vector<int32>        SizeList;
-    uint64                    Timecode; // temporary timecode of the first frame, non scaled
-    int16                     LocalTimecode;
+    std::vector<std::int32_t>        SizeList;
+    std::uint64_t                    Timecode; // temporary timecode of the first frame, non scaled
+    std::int16_t                     LocalTimecode;
     bool                      bLocalTimecodeUsed{false};
-    uint16                    TrackNumber;
+    std::uint16_t                    TrackNumber;
     LacingType                mLacing{LACING_AUTO};
     bool                      mInvisible{false};
-    uint64                    FirstFrameLocation;
+    std::uint64_t                    FirstFrameLocation;
 
     KaxCluster               *ParentCluster{nullptr};
     bool                      bIsSimple;
@@ -335,10 +335,10 @@ public:
 
   void SetBlockGroup( KaxBlockGroup &BlockRef );
 
-  void SetBlockDuration(uint64 TimeLength);
+  void SetBlockDuration(std::uint64_t TimeLength);
 
   void SetParent(KaxCluster & aParentCluster);
-  bool AddFrameAuto(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, LacingType lacing = LACING_AUTO, const KaxBlockBlob * PastBlock = nullptr, const KaxBlockBlob * ForwBlock = nullptr);
+  bool AddFrameAuto(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, LacingType lacing = LACING_AUTO, const KaxBlockBlob * PastBlock = nullptr, const KaxBlockBlob * ForwBlock = nullptr);
 
   bool IsSimpleBlock() const {return bUseSimpleBlock;}
 
@@ -369,8 +369,8 @@ DECLARE_MKX_BINARY_CONS(KaxBlockVirtual)
     filepos_t ReadData(IOCallback & input, ScopeMode ReadFully = SCOPE_ALL_DATA) override;
 
   protected:
-    uint64 Timecode; // temporary timecode of the first frame if there are more than one
-    uint16 TrackNumber;
+    std::uint64_t Timecode; // temporary timecode of the first frame if there are more than one
+    std::uint16_t TrackNumber;
     binary DataBlock[5];
 
     const KaxCluster * ParentCluster{nullptr};
diff --git a/matroska/KaxBlockData.h b/matroska/KaxBlockData.h
index 534bd09..8f69337 100644
--- a/matroska/KaxBlockData.h
+++ b/matroska/KaxBlockData.h
@@ -59,7 +59,7 @@ DECLARE_MKX_SINTEGER_CONS(KaxReferenceBlock)
     void SetReferencedBlock(const KaxBlockBlob * aRefdBlock);
     void SetReferencedBlock(const KaxBlockGroup & aRefdBlock);
     void SetParentBlock(const KaxBlockGroup & aParentBlock) {ParentBlock = &aParentBlock;}
-    void SetReferencedTimecode(int64 refTimecode) {*static_cast<EbmlSInteger*>(this) = refTimecode; bTimecodeSet = true;};
+    void SetReferencedTimecode(std::int64_t refTimecode) {*static_cast<EbmlSInteger*>(this) = refTimecode; bTimecodeSet = true;};
 
   protected:
     const KaxBlockBlob * RefdBlock{nullptr};
diff --git a/matroska/KaxCluster.h b/matroska/KaxCluster.h
index eb89d88..8eabef1 100644
--- a/matroska/KaxCluster.h
+++ b/matroska/KaxCluster.h
@@ -55,20 +55,20 @@ DECLARE_MKX_MASTER_CONS(KaxCluster)
 
       \param timecode the timecode is expressed in nanoseconds, relative to the beggining of the Segment
     */
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, LacingType lacing = LACING_AUTO);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, LacingType lacing = LACING_AUTO);
     /*!
       \brief Addition of a frame with a backward reference (P frame)
       \param timecode the timecode is expressed in nanoseconds, relative to the beggining of the Segment
 
     */
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, LacingType lacing = LACING_AUTO);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, LacingType lacing = LACING_AUTO);
 
     /*!
       \brief Addition of a frame with a backward+forward reference (B frame)
       \param timecode the timecode is expressed in nanoseconds, relative to the beggining of the Segment
 
     */
-    bool AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing = LACING_AUTO);
+    bool AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing = LACING_AUTO);
 
     /*!
       \brief Render the data to the stream and retrieve the position of BlockGroups for later cue entries
@@ -78,7 +78,7 @@ DECLARE_MKX_MASTER_CONS(KaxCluster)
     /*!
       \return the global timecode of this Cluster
     */
-    uint64 GlobalTimecode() const;
+    std::uint64_t GlobalTimecode() const;
 
     KaxBlockGroup & GetNewBlock();
 
@@ -91,11 +91,11 @@ DECLARE_MKX_MASTER_CONS(KaxCluster)
     /*!
       \brief return the position offset compared to the beggining of the Segment
     */
-    uint64 GetPosition() const;
+    std::uint64_t GetPosition() const;
 
     void SetParent(const KaxSegment & aParentSegment) {ParentSegment = &aParentSegment;}
 
-    void SetPreviousTimecode(uint64 aPreviousTimecode, int64 aTimecodeScale) {
+    void SetPreviousTimecode(std::uint64_t aPreviousTimecode, std::int64_t aTimecodeScale) {
       bPreviousTimecodeIsSet = true;
       PreviousTimecode = aPreviousTimecode;
       SetGlobalTimecodeScale(aTimecodeScale);
@@ -105,21 +105,21 @@ DECLARE_MKX_MASTER_CONS(KaxCluster)
       \note dirty hack to get the mandatory data back after reading
       \todo there should be a better way to get mandatory data
     */
-    void InitTimecode(uint64 aTimecode, int64 aTimecodeScale) {
+    void InitTimecode(std::uint64_t aTimecode, std::int64_t aTimecodeScale) {
       SetGlobalTimecodeScale(aTimecodeScale);
       MinTimecode = MaxTimecode = PreviousTimecode = aTimecode * TimecodeScale;
       bFirstFrameInside = bPreviousTimecodeIsSet = true;
     }
 
-    int16 GetBlockLocalTimecode(uint64 GlobalTimecode) const;
+    std::int16_t GetBlockLocalTimecode(std::uint64_t GlobalTimecode) const;
 
-    uint64 GetBlockGlobalTimecode(int16 LocalTimecode);
+    std::uint64_t GetBlockGlobalTimecode(std::int16_t LocalTimecode);
 
-    void SetGlobalTimecodeScale(uint64 aGlobalTimecodeScale) {
+    void SetGlobalTimecodeScale(std::uint64_t aGlobalTimecodeScale) {
       TimecodeScale = aGlobalTimecodeScale;
       bTimecodeScaleIsSet = true;
     }
-    uint64 GlobalTimecodeScale() const {
+    std::uint64_t GlobalTimecodeScale() const {
       assert(bTimecodeScaleIsSet);
       return TimecodeScale;
     }
@@ -140,8 +140,8 @@ DECLARE_MKX_MASTER_CONS(KaxCluster)
     KaxBlockGroup    * currentNewBlock{nullptr};
     const KaxSegment * ParentSegment{nullptr};
 
-    uint64 MinTimecode, MaxTimecode, PreviousTimecode;
-    int64  TimecodeScale;
+    std::uint64_t MinTimecode, MaxTimecode, PreviousTimecode;
+    std::int64_t  TimecodeScale;
 
     bool   bFirstFrameInside{false}; // used to speed research
     bool   bPreviousTimecodeIsSet{false};
@@ -151,9 +151,10 @@ DECLARE_MKX_MASTER_CONS(KaxCluster)
     /*!
       \note method used internally
     */
-    bool AddFrameInternal(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup * PastBlock, const KaxBlockGroup * ForwBlock, LacingType lacing);
+    bool AddFrameInternal(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup * PastBlock, const KaxBlockGroup * ForwBlock, LacingType lacing);
 };
 
 } // namespace libmatroska
 
 #endif // LIBMATROSKA_CLUSTER_H
+
diff --git a/matroska/KaxCues.h b/matroska/KaxCues.h
index 90c6dba..a6478e5 100644
--- a/matroska/KaxCues.h
+++ b/matroska/KaxCues.h
@@ -68,14 +68,14 @@ DECLARE_MKX_MASTER(KaxCues)
       return EbmlMaster::Render(output, bSaveDefault);
     }
 
-    uint64 GetTimecodePosition(uint64 aTimecode) const;
-    const KaxCuePoint * GetTimecodePoint(uint64 aTimecode) const;
+    std::uint64_t GetTimecodePosition(std::uint64_t aTimecode) const;
+    const KaxCuePoint * GetTimecodePoint(std::uint64_t aTimecode) const;
 
-    void SetGlobalTimecodeScale(uint64 aGlobalTimecodeScale) {
+    void SetGlobalTimecodeScale(std::uint64_t aGlobalTimecodeScale) {
       mGlobalTimecodeScale = aGlobalTimecodeScale;
       bGlobalTimecodeScaleIsSet = true;
     }
-    uint64 GlobalTimecodeScale() const {
+    std::uint64_t GlobalTimecodeScale() const {
       assert(bGlobalTimecodeScaleIsSet);
       return mGlobalTimecodeScale;
     }
@@ -83,7 +83,7 @@ DECLARE_MKX_MASTER(KaxCues)
   protected:
     std::vector<const KaxBlockBlob *> myTempReferences;
     bool   bGlobalTimecodeScaleIsSet;
-    uint64 mGlobalTimecodeScale;
+    std::uint64_t mGlobalTimecodeScale;
 };
 
 } // namespace libmatroska
diff --git a/matroska/KaxCuesData.h b/matroska/KaxCuesData.h
index 144d4db..abd095f 100644
--- a/matroska/KaxCuesData.h
+++ b/matroska/KaxCuesData.h
@@ -50,27 +50,27 @@ class KaxSimpleBlock;
 
 DECLARE_MKX_MASTER(KaxCuePoint)
   public:
-    void PositionSet(const KaxBlockGroup & BlockReference, uint64 GlobalTimecodeScale);
-    void PositionSet(const KaxBlockBlob & BlobReference, uint64 GlobalTimecodeScale);
-    void PositionSet(const KaxSimpleBlock & BlockReference, uint64 GlobalTimecodeScale);
-    void PositionSet(const KaxInternalBlock & BlockReference, const KaxBlockGroup *BlockGroup, uint64 GlobalTimecodeScale);
+    void PositionSet(const KaxBlockGroup & BlockReference, std::uint64_t GlobalTimecodeScale);
+    void PositionSet(const KaxBlockBlob & BlobReference, std::uint64_t GlobalTimecodeScale);
+    void PositionSet(const KaxSimpleBlock & BlockReference, std::uint64_t GlobalTimecodeScale);
+    void PositionSet(const KaxInternalBlock & BlockReference, const KaxBlockGroup *BlockGroup, std::uint64_t GlobalTimecodeScale);
 
     bool IsSmallerThan(const EbmlElement *Cmp) const override;
 
     const KaxCueTrackPositions * GetSeekPosition() const;
-    bool Timecode(uint64 & aTimecode, uint64 GlobalTimecodeScale) const;
+    bool Timecode(std::uint64_t & aTimecode, std::uint64_t GlobalTimecodeScale) const;
 };
 
 DECLARE_MKX_MASTER(KaxCueTrackPositions)
   public:
-    uint64 ClusterPosition() const;
-    uint16 TrackNumber() const;
+    std::uint64_t ClusterPosition() const;
+    std::uint16_t TrackNumber() const;
 };
 
 DECLARE_MKX_MASTER(KaxCueReference)
   public:
-    void AddReference(const KaxBlockGroup & BlockReferenced, uint64 GlobalTimecodeScale);
-    void AddReference(const KaxBlockBlob & BlockReferenced, uint64 GlobalTimecodeScale);
+    void AddReference(const KaxBlockGroup & BlockReferenced, std::uint64_t GlobalTimecodeScale);
+    void AddReference(const KaxBlockBlob & BlockReferenced, std::uint64_t GlobalTimecodeScale);
 };
 
 } // namespace libmatroska
diff --git a/matroska/KaxSeekHead.h b/matroska/KaxSeekHead.h
index f21fdcd..823d549 100644
--- a/matroska/KaxSeekHead.h
+++ b/matroska/KaxSeekHead.h
@@ -49,7 +49,7 @@ class KaxSegment;
 
 DECLARE_MKX_MASTER(KaxSeek)
   public:
-    int64 Location() const;
+    std::int64_t Location() const;
     bool IsEbmlId(const EbmlId & aId) const;
     bool IsEbmlId(const KaxSeek & aPoint) const;
 };
diff --git a/matroska/KaxSegment.h b/matroska/KaxSegment.h
index 112d61d..68dcfb1 100644
--- a/matroska/KaxSegment.h
+++ b/matroska/KaxSegment.h
@@ -48,13 +48,13 @@ DECLARE_MKX_MASTER_CONS(KaxSegment)
     /*!
       \brief give the position of the element in the segment
     */
-    uint64 GetRelativePosition(const EbmlElement & Elt) const;
-    uint64 GetRelativePosition(uint64 aGlobalPosition) const;
+    std::uint64_t GetRelativePosition(const EbmlElement & Elt) const;
+    std::uint64_t GetRelativePosition(std::uint64_t aGlobalPosition) const;
 
     /*!
       \brief give the position of the element in the file
     */
-    uint64 GetGlobalPosition(uint64 aRelativePosition) const;
+    std::uint64_t GetGlobalPosition(std::uint64_t aRelativePosition) const;
 };
 
 } // namespace libmatroska
diff --git a/matroska/KaxTracks.h b/matroska/KaxTracks.h
index 3c20b9b..7a34f8c 100644
--- a/matroska/KaxTracks.h
+++ b/matroska/KaxTracks.h
@@ -56,21 +56,21 @@ DECLARE_MKX_MASTER(KaxTrackEntry)
     */
     inline bool LacingEnabled() const {
       auto myLacing = static_cast<KaxTrackFlagLacing *>(FindFirstElt(EBML_INFO(KaxTrackFlagLacing)));
-      return((myLacing == nullptr) || (static_cast<uint8>(*myLacing) != 0));
+      return((myLacing == nullptr) || (static_cast<std::uint8_t>(*myLacing) != 0));
     }
 
-    void SetGlobalTimecodeScale(uint64 aGlobalTimecodeScale) {
+    void SetGlobalTimecodeScale(std::uint64_t aGlobalTimecodeScale) {
       mGlobalTimecodeScale = aGlobalTimecodeScale;
       bGlobalTimecodeScaleIsSet = true;
     }
-    uint64 GlobalTimecodeScale() const {
+    std::uint64_t GlobalTimecodeScale() const {
       assert(bGlobalTimecodeScaleIsSet);
       return mGlobalTimecodeScale;
     }
 
   protected:
     bool   bGlobalTimecodeScaleIsSet{false};
-    uint64 mGlobalTimecodeScale;
+    std::uint64_t mGlobalTimecodeScale;
 };
 
 } // namespace libmatroska
diff --git a/matroska/KaxTypes.h b/matroska/KaxTypes.h
index 95c7185..3a6bac6 100644
--- a/matroska/KaxTypes.h
+++ b/matroska/KaxTypes.h
@@ -36,7 +36,60 @@
 
 #include "matroska/KaxConfig.h"
 #include "ebml/EbmlTypes.h"
-#include "matroska/c/libmatroska_t.h"
+
+/*!
+    \enum track_type
+*/
+typedef enum track_type {
+    track_video       = 0x01, ///< Rectangle-shaped non-transparent pictures aka video
+    track_audio       = 0x02, ///< Anything you can hear
+    track_complex     = 0x03, ///< Audio and video in same track, used by DV
+
+    track_logo        = 0x10, ///< Overlay-pictures, displayed over video
+    track_subtitle    = 0x11, ///< Text-subtitles. One track contains one language and only one track can be active (player-side configuration)
+    track_buttons     = 0x12, ///< Buttons meta-infos.
+
+    track_control     = 0x20  ///< Control-codes for menus and other stuff
+} track_type;
+
+/*!
+    \enum matroska_error_t
+    \brief a callback that the library use to inform of errors happening
+    \note this should be used by the libmatroska internals
+*/
+typedef enum {
+  error_null_pointer  ///< NULL pointer where something else is expected
+} matroska_error_t;
+
+typedef void *matroska_stream;
+
+/*!
+    \var void* matroska_id
+    \brief UID used to access an Matroska file instance
+*/
+typedef void* matroska_id;
+/*!
+    \var void* matroska_track
+    \brief UID used to access a track
+*/
+typedef void* matroska_track;
+/*!
+    \var char* c_string
+    \brief C-String, ie a buffer with characters terminated by \0
+*/
+typedef char* c_string;
+/*!
+    \var unsigned int matroska_file_mode
+    \brief A bit buffer, each bit representing a value for the file opening
+    \todo replace the unsigned int by a sized type (8 or 16 bits)
+*/
+typedef char * matroska_file_mode;
+/*!
+    \var void (*matroska_error_callback)(matroska_error_t error_code, char* error_message)
+    \brief a callback that the library use to inform of errors happening
+*/
+typedef void (*matroska_error_callback)(matroska_error_t error_code, char* error_message);
+
 
 namespace libmatroska {
 
diff --git a/matroska/c/libmatroska.h b/matroska/c/libmatroska.h
index 53eb668..961e97c 100644
--- a/matroska/c/libmatroska.h
+++ b/matroska/c/libmatroska.h
@@ -92,16 +92,16 @@ matroska_id matroska_open_url(c_string string);
 */
 void MATROSKA_EXPORT matroska_close(matroska_id id);
 
-void MATROSKA_EXPORT matroska_end(matroska_id id, uint32 totaltime);
+void MATROSKA_EXPORT matroska_end(matroska_id id, std::uint32_t totaltime);
 
 matroska_track MATROSKA_EXPORT matroska_create_track(matroska_id id, enum track_type type);
 
 void MATROSKA_EXPORT matroska_read_head(matroska_id id);
 void MATROSKA_EXPORT matroska_read_tracks(matroska_id id);
 
-uint8 MATROSKA_EXPORT matroska_get_number_track(matroska_id id);
+std::uint8_t MATROSKA_EXPORT matroska_get_number_track(matroska_id id);
 
-matroska_track MATROSKA_EXPORT matroska_get_track(matroska_id id, uint8 track_index);
+matroska_track MATROSKA_EXPORT matroska_get_track(matroska_id id, std::uint8_t track_index);
 
 void MATROSKA_EXPORT matroska_get_track_info(matroska_id id, matroska_track track, track_info * infos);
 
diff --git a/matroska/c/libmatroska_t.h b/matroska/c/libmatroska_t.h
index 1772933..1d97745 100644
--- a/matroska/c/libmatroska_t.h
+++ b/matroska/c/libmatroska_t.h
@@ -36,73 +36,11 @@
     \brief Misc type definitions for the C API of libmatroska
 
     \note These types should be compiler/language independant (just platform dependant)
-    \todo recover the sized types (uint16, int32, etc) here too (or maybe here only)
+    \todo recover the sized types (std::uint16_t, std::int32_t, etc) here too (or maybe here only)
 */
 
 #ifndef _LIBMATROSKA_T_H_INCLUDED_
 #define _LIBMATROSKA_T_H_INCLUDED_
 
-#include "ebml/c/libebml_t.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*!
-    \enum track_type
-*/
-typedef enum track_type {
-    track_video       = 0x01, ///< Rectangle-shaped non-transparent pictures aka video
-    track_audio       = 0x02, ///< Anything you can hear
-    track_complex     = 0x03, ///< Audio and video in same track, used by DV
-
-    track_logo        = 0x10, ///< Overlay-pictures, displayed over video
-    track_subtitle    = 0x11, ///< Text-subtitles. One track contains one language and only one track can be active (player-side configuration)
-    track_buttons     = 0x12, ///< Buttons meta-infos.
-
-    track_control     = 0x20  ///< Control-codes for menus and other stuff
-} track_type;
-
-/*!
-    \enum matroska_error_t
-    \brief a callback that the library use to inform of errors happening
-    \note this should be used by the libmatroska internals
-*/
-typedef enum {
-  error_null_pointer  ///< NULL pointer where something else is expected
-} matroska_error_t;
-
-typedef void *matroska_stream;
-
-/*!
-    \var void* matroska_id
-    \brief UID used to access an Matroska file instance
-*/
-typedef void* matroska_id;
-/*!
-    \var void* matroska_track
-    \brief UID used to access a track
-*/
-typedef void* matroska_track;
-/*!
-    \var char* c_string
-    \brief C-String, ie a buffer with characters terminated by \0
-*/
-typedef char* c_string;
-/*!
-    \var unsigned int matroska_file_mode
-    \brief A bit buffer, each bit representing a value for the file opening
-    \todo replace the unsigned int by a sized type (8 or 16 bits)
-*/
-typedef char * matroska_file_mode;
-/*!
-    \var void (*matroska_error_callback)(matroska_error_t error_code, char* error_message)
-    \brief a callback that the library use to inform of errors happening
-*/
-typedef void (*matroska_error_callback)(matroska_error_t error_code, char* error_message);
-
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* _LIBMATROSKA_T_H_INCLUDED_ */
+
diff --git a/src/FileKax.cpp b/src/FileKax.cpp
index 4f11874..ac7be12 100644
--- a/src/FileKax.cpp
+++ b/src/FileKax.cpp
@@ -79,13 +79,13 @@ FileMatroska::FileMatroska(IOCallback & output)
 } */
 
 #ifdef OLD
-void FileMatroska::SetMaxClusterSize(const uint32 value)
+void FileMatroska::SetMaxClusterSize(const std::uint32_t value)
 {
   myMaxClusterSize = value;
   myCurrWriteCluster.setMaxSize(value);
 }
 
-void FileMatroska::Close(const uint32 aTimeLength)
+void FileMatroska::Close(const std::uint32_t aTimeLength)
 {
   Flush();
 
@@ -97,7 +97,7 @@ void FileMatroska::Close(const uint32 aTimeLength)
   myFile.setFilePointer(0,seek_beginning);
 
   // get the Track-entry size
-  uint32 track_entries_size = 0;
+  std::uint32_t track_entries_size = 0;
   for (auto&& myTrack : myTracks) {
     track_entries_size += myTrack->default_size();
   }
@@ -117,7 +117,7 @@ void FileMatroska::Close(const uint32 aTimeLength)
 filepos_t FileMatroska::RenderHead(const std::string & aEncoderApp)
 {
   try {
-    uint32 track_entries_size = 0;
+    std::uint32_t track_entries_size = 0;
     for (auto&& myTrack : myTracks) {
       track_entries_size += myTrack->default_size();
     }
@@ -189,7 +189,7 @@ void FileMatroska::track_SetLaced(Track * aTrack, bool bLaced)
   }
 }
 
-bool FileMatroska::AddFrame(Track * aTrack, const uint32 aTimecode, const binary *aFrame, const uint32 aFrameSize,
+bool FileMatroska::AddFrame(Track * aTrack, const std::uint32_t aTimecode, const binary *aFrame, const std::uint32_t aFrameSize,
                             bool aKeyFrame, bool aBFrame)
 {
   try {
@@ -200,7 +200,7 @@ bool FileMatroska::AddFrame(Track * aTrack, const uint32 aTimecode, const binary
       if (aTrack->AddFrame(aTimecode, aFrame, aFrameSize, aKeyFrame, aBFrame)) {
         while (!aTrack->SerialiseBlock(myCurrWriteCluster)) {
           /// \todo handle errors
-          uint32 aNbBlock;
+          std::uint32_t aNbBlock;
           myStreamInfo.ClusterSize += myCurrWriteCluster.Render(myFile, aNbBlock);
           myStreamInfo.NumberBlock += aNbBlock;
           myCurrWriteCluster.Flush();
@@ -217,15 +217,15 @@ bool FileMatroska::AddFrame(Track * aTrack, const uint32 aTimecode, const binary
 
 void FileMatroska::Flush()
 {
-  uint32 aNbBlock;
+  std::uint32_t aNbBlock;
   myStreamInfo.ClusterSize += myCurrWriteCluster.Render(myFile,aNbBlock);
   myStreamInfo.NumberBlock += aNbBlock;
 }
 
-uint32 FileMatroska::ReadHead()
+std::uint32_t FileMatroska::ReadHead()
 {
   try {
-    uint32 result = myMainHeader.Read(myFile, myStreamInfo);
+    std::uint32_t result = myMainHeader.Read(myFile, myStreamInfo);
 
     return result;
   }
@@ -234,18 +234,18 @@ uint32 FileMatroska::ReadHead()
   }
 }
 
-uint32 FileMatroska::ReadTracks()
+std::uint32_t FileMatroska::ReadTracks()
 {
   try {
-    uint32 result = 0;
+    std::uint32_t result = 0;
 
     // seek to the start of the Track Entries
     myFile.setFilePointer(myStreamInfo.TrackEntryPosition);
     // get the number of Track Entries
-    uint8 TrackNumber = myStreamInfo.TrackEntriesSize / myStreamInfo.TrackEntrySize;
+    std::uint8_t TrackNumber = myStreamInfo.TrackEntriesSize / myStreamInfo.TrackEntrySize;
     // read all the Track Entries
     myTracks.clear();
-    for (uint8 TrackIdx = 0; TrackIdx<TrackNumber; TrackIdx ++) {
+    for (std::uint8_t TrackIdx = 0; TrackIdx<TrackNumber; TrackIdx ++) {
       Track * tmpTrack = Track::ReadEntry(myFile, TrackIdx+1, myStreamInfo);
       if (tmpTrack == NULL)
         throw 0;
@@ -260,13 +260,13 @@ uint32 FileMatroska::ReadTracks()
   }
 }
 
-uint32 FileMatroska::ReadCodec()
+std::uint32_t FileMatroska::ReadCodec()
 {
   try {
     // seek to the start of the Track Entries
     myFile.setFilePointer(myStreamInfo.CodecEntryPosition);
 
-    uint32 result = CodecHeader::Read(myFile, myTracks);
+    std::uint32_t result = CodecHeader::Read(myFile, myTracks);
 
     return result;
   }
@@ -302,7 +302,7 @@ void FileMatroska::SelectReadingTrack(Track * aTrack, bool select)
   }
 }
 
-inline bool FileMatroska::IsReadingTrack(const uint8 aTrackNumber) const
+inline bool FileMatroska::IsReadingTrack(const std::uint8_t aTrackNumber) const
 {
   return std::any_of(mySelectedTracks.begin(), mySelectedTracks.end(), [=](int track){ return track >= aTrackNumber; })
 }
@@ -351,7 +351,7 @@ void FileMatroska::Track_SetInfo_Video(Track * aTrack, const TrackInfoVideo & aT
 /*!
   \todo exit when there is no Block left
 */
-bool FileMatroska::ReadFrame(Track * & aTrack, uint32 & aTimecode, const binary * & aFrame, uint32 & aFrameSize,
+bool FileMatroska::ReadFrame(Track * & aTrack, std::uint32_t & aTimecode, const binary * & aFrame, std::uint32_t & aFrameSize,
                              bool & aKeyFrame, bool & aBFrame)
 {
   if (myCurrReadBlockTrack == 0) {
diff --git a/src/KaxBlock.cpp b/src/KaxBlock.cpp
index 62b0947..5cebef0 100644
--- a/src/KaxBlock.cpp
+++ b/src/KaxBlock.cpp
@@ -108,13 +108,13 @@ KaxBlockGroup::KaxBlockGroup(EBML_EXTRA_DEF)
   \todo hardcoded limit of the number of frames in a lace should be a parameter
   \return true if more frames can be added to this Block
 */
-bool KaxInternalBlock::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, LacingType lacing, bool invisible)
+bool KaxInternalBlock::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, LacingType lacing, bool invisible)
 {
   SetValueIsSet();
   if (myBuffers.empty()) {
     // first frame
     Timecode = timecode;
-    TrackNumber = static_cast<uint64>(track.TrackNumber());
+    TrackNumber = static_cast<std::uint64_t>(track.TrackNumber());
     mInvisible = invisible;
     mLacing = lacing;
   }
@@ -152,7 +152,7 @@ LacingType KaxInternalBlock::GetBestLacingType() const {
   }
   EbmlLacingSize += CodedSizeLength(myBuffers[0]->Size(), 0, IsFiniteSize());
   for (i = 1; i < static_cast<int>(myBuffers.size()) - 1; i++)
-    EbmlLacingSize += CodedSizeLengthSigned(static_cast<int64>(myBuffers[i]->Size()) - static_cast<int64>(myBuffers[i - 1]->Size()), 0);
+    EbmlLacingSize += CodedSizeLengthSigned(static_cast<std::int64_t>(myBuffers[i]->Size()) - static_cast<std::int64_t>(myBuffers[i - 1]->Size()), 0);
   if (SameSize)
     return LACING_FIXED;
   if (XiphLacingSize < EbmlLacingSize)
@@ -191,7 +191,7 @@ filepos_t KaxInternalBlock::UpdateSize(bool /* bSaveDefault */, bool /* bForceRe
         case LACING_EBML:
           SetSize_(GetSize() + myBuffers[0]->Size() + CodedSizeLength(myBuffers[0]->Size(), 0, IsFiniteSize()));
           for (i=1; i<myBuffers.size()-1; i++) {
-            SetSize_(GetSize() + myBuffers[i]->Size() + CodedSizeLengthSigned(static_cast<int64>(myBuffers[i]->Size()) - static_cast<int64>(myBuffers[i-1]->Size()), 0));
+            SetSize_(GetSize() + myBuffers[i]->Size() + CodedSizeLengthSigned(static_cast<std::int64_t>(myBuffers[i]->Size()) - static_cast<std::int64_t>(myBuffers[i-1]->Size()), 0));
           }
           break;
         case LACING_FIXED:
@@ -251,7 +251,7 @@ filepos_t KaxBlockVirtual::UpdateSize(bool /* bSaveDefault */, bool /* bForceRen
   }
 
   assert(ParentCluster != nullptr);
-  const int16 ActualTimecode = ParentCluster->GetBlockLocalTimecode(Timecode);
+  const std::int16_t ActualTimecode = ParentCluster->GetBlockLocalTimecode(Timecode);
   const auto b16 = big_int16(ActualTimecode);
   b16.Fill(cursor);
   cursor += 2;
@@ -294,7 +294,7 @@ filepos_t KaxInternalBlock::RenderData(IOCallback & output, bool /* bForceRender
     }
 
     assert(ParentCluster != nullptr);
-    const int16 ActualTimecode = ParentCluster->GetBlockLocalTimecode(Timecode);
+    const std::int16_t ActualTimecode = ParentCluster->GetBlockLocalTimecode(Timecode);
     const auto b16 = big_int16(ActualTimecode);
     b16.Fill(cursor);
     cursor += 2;
@@ -345,7 +345,7 @@ filepos_t KaxInternalBlock::RenderData(IOCallback & output, bool /* bForceRender
         // set the size of each member in the lace
         for (i=0; i<myBuffers.size()-1; i++) {
           tmpValue = 0xFF;
-          uint16 tmpSize = myBuffers[i]->Size();
+          std::uint16_t tmpSize = myBuffers[i]->Size();
           while (tmpSize >= 0xFF) {
             output.writeFully(&tmpValue, 1);
             SetSize_(GetSize() + 1);
@@ -361,7 +361,7 @@ filepos_t KaxInternalBlock::RenderData(IOCallback & output, bool /* bForceRender
         tmpValue = myBuffers.size()-1;
         output.writeFully(&tmpValue, 1);
         {
-          int64 _Size;
+          std::int64_t _Size;
           int _CodedSize;
           binary _FinalHead[8]; // 64 bits max coded size
 
@@ -376,7 +376,7 @@ filepos_t KaxInternalBlock::RenderData(IOCallback & output, bool /* bForceRender
 
           // set the size of each member in the lace
           for (i=1; i<myBuffers.size()-1; i++) {
-            _Size = static_cast<int64>(myBuffers[i]->Size()) - static_cast<int64>(myBuffers[i-1]->Size());
+            _Size = static_cast<std::int64_t>(myBuffers[i]->Size()) - static_cast<std::int64_t>(myBuffers[i-1]->Size());
             _CodedSize = CodedSizeLengthSigned(_Size, 0);
             CodedValueLengthSigned(_Size, _CodedSize, _FinalHead);
             output.writeFully(_FinalHead, _CodedSize);
@@ -405,10 +405,10 @@ filepos_t KaxInternalBlock::RenderData(IOCallback & output, bool /* bForceRender
   return GetSize();
 }
 
-uint64 KaxInternalBlock::ReadInternalHead(IOCallback & input)
+std::uint64_t KaxInternalBlock::ReadInternalHead(IOCallback & input)
 {
   binary Buffer[5], *cursor = Buffer;
-  uint64 Result = input.read(cursor, 4);
+  std::uint64_t Result = input.read(cursor, 4);
   if (Result != 4)
     return Result;
 
@@ -431,7 +431,7 @@ uint64 KaxInternalBlock::ReadInternalHead(IOCallback & input)
   big_int16 b16;
   b16.Eval(cursor);
   assert(ParentCluster != nullptr);
-  Timecode = ParentCluster->GetBlockGlobalTimecode(static_cast<int16>(b16));
+  Timecode = ParentCluster->GetBlockGlobalTimecode(static_cast<std::int16_t>(b16));
   bLocalTimecodeUsed = false;
   cursor += 2;
 
@@ -458,7 +458,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
       binary *const BufferStart = EbmlBinary::GetBuffer();
 
       SafeReadIOCallback Mem(*this);
-      uint8 BlockHeadSize = 4;
+      std::uint8_t BlockHeadSize = 4;
 
       // update internal values
       TrackNumber = Mem.GetUInt8();
@@ -475,10 +475,10 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
         TrackNumber &= 0x7F;
       }
 
-      LocalTimecode = static_cast<int16>(Mem.GetUInt16BE());
+      LocalTimecode = static_cast<std::int16_t>(Mem.GetUInt16BE());
       bLocalTimecodeUsed = true;
 
-      const uint8 Flags = Mem.GetUInt8();
+      const std::uint8_t Flags = Mem.GetUInt8();
       if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {
         bIsKeyframe = (Flags & 0x80) != 0;
         bIsDiscardable = (Flags & 0x01) != 0;
@@ -495,13 +495,13 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
         SizeList[0] = GetSize() - BlockHeadSize;
       } else {
         // read the number of frames in the lace
-        uint32 LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame
-        const uint8 FrameNum = Mem.GetUInt8(); // number of frames in the lace - 1
+        std::uint32_t LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame
+        const std::uint8_t FrameNum = Mem.GetUInt8(); // number of frames in the lace - 1
         // read the list of frame sizes
-        uint8 Index;
-        int32 FrameSize;
-        uint32 SizeRead;
-        uint64 SizeUnknown;
+        std::uint8_t Index;
+        std::int32_t FrameSize;
+        std::uint32_t SizeRead;
+        std::uint64_t SizeUnknown;
 
         SizeList.resize(FrameNum + 1);
 
@@ -510,7 +510,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
             for (Index=0; Index<FrameNum; Index++) {
               // get the size of the frame
               FrameSize = 0;
-              uint8 Value;
+              std::uint8_t Value;
               do {
                 Value = Mem.GetUInt8();
                 FrameSize += Value;
@@ -524,7 +524,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
           case LACING_EBML:
             SizeRead = LastBufferSize;
             FrameSize = ReadCodedSizeValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
-            if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))
+            if (!FrameSize || (static_cast<std::uint32_t>(FrameSize + SizeRead) > LastBufferSize))
               throw SafeReadIOCallback::EndOfStreamX(SizeRead);
             SizeList[0] = FrameSize;
             Mem.Skip(SizeRead);
@@ -534,7 +534,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
               // get the size of the frame
               SizeRead = LastBufferSize;
               FrameSize += ReadCodedSizeSignedValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
-              if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))
+              if (!FrameSize || (static_cast<std::uint32_t>(FrameSize + SizeRead) > LastBufferSize))
                 throw SafeReadIOCallback::EndOfStreamX(SizeRead);
               SizeList[Index] = FrameSize;
               Mem.Skip(SizeRead);
@@ -583,7 +583,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
         throw SafeReadIOCallback::EndOfStreamX(0);
       binary *cursor = _TempHead;
       binary *_tmpBuf;
-      uint8 BlockHeadSize = 4;
+      std::uint8_t BlockHeadSize = 4;
 
       // update internal values
       TrackNumber = *cursor++;
@@ -602,7 +602,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
 
       big_int16 b16;
       b16.Eval(cursor);
-      LocalTimecode = static_cast<int16>(b16);
+      LocalTimecode = static_cast<std::int16_t>(b16);
       bLocalTimecodeUsed = true;
       cursor += 2;
 
@@ -623,14 +623,14 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
       // put all Frames in the list
       if (mLacing != LACING_NONE) {
         // read the number of frames in the lace
-        const uint32 TotalLacedSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame
-        uint32 LastBufferSize = TotalLacedSize;
-        const uint8 FrameNum = _TempHead[0]; // number of frames in the lace - 1
+        const std::uint32_t TotalLacedSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame
+        std::uint32_t LastBufferSize = TotalLacedSize;
+        const std::uint8_t FrameNum = _TempHead[0]; // number of frames in the lace - 1
         // read the list of frame sizes
-        uint8 Index;
-        uint32 FrameSize;
-        uint32 SizeRead;
-        uint64 SizeUnknown;
+        std::uint8_t Index;
+        std::uint32_t FrameSize;
+        std::uint32_t SizeRead;
+        std::uint64_t SizeUnknown;
 
         SizeList.resize(FrameNum + 1);
 
@@ -641,7 +641,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
               FrameSize = 0;
               do {
                 Result += input.read(_TempHead, 1);
-                FrameSize += static_cast<uint8>(_TempHead[0]);
+                FrameSize += static_cast<std::uint8_t>(_TempHead[0]);
                 if (FrameSize > TotalLacedSize)
                   throw SafeReadIOCallback::EndOfStreamX(0);
                 LastBufferSize--;
@@ -719,7 +719,7 @@ filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
   return Result;
 }
 
-bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, LacingType lacing)
+bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, LacingType lacing)
 {
   auto & theBlock = GetChild<KaxBlock>(*this);
   assert(ParentCluster != nullptr);
@@ -728,7 +728,7 @@ bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataB
   return theBlock.AddFrame(track, timecode, buffer, lacing);
 }
 
-bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, LacingType lacing)
+bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, LacingType lacing)
 {
   //  assert(past_timecode < 0);
 
@@ -745,7 +745,7 @@ bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataB
   return bRes;
 }
 
-bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing)
+bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing)
 {
   //  assert(past_timecode < 0);
 
@@ -768,7 +768,7 @@ bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataB
   return bRes;
 }
 
-bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, const KaxBlockBlob * PastBlock, const KaxBlockBlob * ForwBlock, LacingType lacing)
+bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, const KaxBlockBlob * PastBlock, const KaxBlockBlob * ForwBlock, LacingType lacing)
 {
   auto & theBlock = GetChild<KaxBlock>(*this);
   assert(ParentCluster != nullptr);
@@ -794,26 +794,26 @@ bool KaxBlockGroup::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataB
 /*!
   \todo we may cache the reference to the timecode block
 */
-uint64 KaxBlockGroup::GlobalTimecode() const
+std::uint64_t KaxBlockGroup::GlobalTimecode() const
 {
   assert(ParentCluster != nullptr); // impossible otherwise
   auto MyBlock = static_cast<KaxBlock *>(this->FindElt(EBML_INFO(KaxBlock)));
   return MyBlock->GlobalTimecode();
 }
 
-uint16 KaxBlockGroup::TrackNumber() const
+std::uint16_t KaxBlockGroup::TrackNumber() const
 {
   auto MyBlock = static_cast<KaxBlock *>(this->FindElt(EBML_INFO(KaxBlock)));
   return MyBlock->TrackNum();
 }
 
-uint64 KaxBlockGroup::ClusterPosition() const
+std::uint64_t KaxBlockGroup::ClusterPosition() const
 {
   assert(ParentCluster != nullptr); // impossible otherwise
   return ParentCluster->GetPosition();
 }
 
-uint64 KaxInternalBlock::ClusterPosition() const
+std::uint64_t KaxInternalBlock::ClusterPosition() const
 {
   assert(ParentCluster != nullptr); // impossible otherwise
   return ParentCluster->GetPosition();
@@ -864,15 +864,15 @@ void KaxInternalBlock::ReleaseFrames()
   }
 }
 
-void KaxBlockGroup::SetBlockDuration(uint64 TimeLength)
+void KaxBlockGroup::SetBlockDuration(std::uint64_t TimeLength)
 {
   assert(ParentTrack != nullptr);
-  const int64 scale = ParentTrack->GlobalTimecodeScale();
+  const std::int64_t scale = ParentTrack->GlobalTimecodeScale();
   const auto& myDuration = static_cast<KaxBlockDuration *>(FindFirstElt(EBML_INFO(KaxBlockDuration), true));
-  *(static_cast<EbmlUInteger *>(myDuration)) = TimeLength / static_cast<uint64>(scale);
+  *(static_cast<EbmlUInteger *>(myDuration)) = TimeLength / static_cast<std::uint64_t>(scale);
 }
 
-bool KaxBlockGroup::GetBlockDuration(uint64 &TheTimecode) const
+bool KaxBlockGroup::GetBlockDuration(std::uint64_t &TheTimecode) const
 {
   auto myDuration = static_cast<KaxBlockDuration *>(FindElt(EBML_INFO(KaxBlockDuration)));
   if (myDuration == nullptr) {
@@ -880,7 +880,7 @@ bool KaxBlockGroup::GetBlockDuration(uint64 &TheTimecode) const
   }
 
   assert(ParentTrack != nullptr);
-  TheTimecode = static_cast<uint64>(*myDuration) * ParentTrack->GlobalTimecodeScale();
+  TheTimecode = static_cast<std::uint64_t>(*myDuration) * ParentTrack->GlobalTimecodeScale();
   return true;
 }
 
@@ -908,9 +908,9 @@ void KaxInternalBlock::SetParent(KaxCluster & aParentCluster)
   }
 }
 
-int64 KaxInternalBlock::GetDataPosition(size_t FrameNumber)
+std::int64_t KaxInternalBlock::GetDataPosition(size_t FrameNumber)
 {
-  int64 _Result = -1;
+  std::int64_t _Result = -1;
 
   if (ValueIsSet() && FrameNumber < SizeList.size()) {
     _Result = FirstFrameLocation;
@@ -924,9 +924,9 @@ int64 KaxInternalBlock::GetDataPosition(size_t FrameNumber)
   return _Result;
 }
 
-int64 KaxInternalBlock::GetFrameSize(size_t FrameNumber)
+std::int64_t KaxInternalBlock::GetFrameSize(size_t FrameNumber)
 {
-  int64 _Result = -1;
+  std::int64_t _Result = -1;
 
   if (/*bValueIsSet &&*/ FrameNumber < SizeList.size()) {
     _Result = SizeList[FrameNumber];
@@ -972,7 +972,7 @@ KaxBlockBlob::operator KaxSimpleBlock &()
   return *Block.simpleblock;
 }
 
-bool KaxBlockBlob::AddFrameAuto(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, LacingType lacing, const KaxBlockBlob * PastBlock, const KaxBlockBlob * ForwBlock)
+bool KaxBlockBlob::AddFrameAuto(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, LacingType lacing, const KaxBlockBlob * PastBlock, const KaxBlockBlob * ForwBlock)
 {
   bool bResult = false;
   if ((SimpleBlockMode == BLOCK_BLOB_ALWAYS_SIMPLE) || (SimpleBlockMode == BLOCK_BLOB_SIMPLE_AUTO && PastBlock == nullptr && ForwBlock == nullptr)) {
@@ -1007,7 +1007,7 @@ void KaxBlockBlob::SetParent(KaxCluster & aParentCluster)
   ParentCluster = &aParentCluster;
 }
 
-void KaxBlockBlob::SetBlockDuration(uint64 TimeLength)
+void KaxBlockBlob::SetBlockDuration(std::uint64_t TimeLength)
 {
   if (ReplaceSimpleByGroup())
     Block.group->SetBlockDuration(TimeLength);
@@ -1056,3 +1056,4 @@ filepos_t KaxBlockVirtual::ReadData(IOCallback & input, ScopeMode /* ReadFully *
 }
 
 } // namespace libmatroska
+
diff --git a/src/KaxBlockData.cpp b/src/KaxBlockData.cpp
index bc4072f..98d4b18 100644
--- a/src/KaxBlockData.cpp
+++ b/src/KaxBlockData.cpp
@@ -78,7 +78,7 @@ filepos_t KaxReferenceBlock::UpdateSize(bool bSaveDefault, bool bForceRender)
     assert(ParentBlock != nullptr);
 
     const KaxInternalBlock &block = *RefdBlock;
-    *static_cast<EbmlSInteger*>(this) = (static_cast<int64>(block.GlobalTimecode()) - static_cast<int64>(ParentBlock->GlobalTimecode())) / static_cast<int64>(ParentBlock->GlobalTimecodeScale());
+    *static_cast<EbmlSInteger*>(this) = (static_cast<std::int64_t>(block.GlobalTimecode()) - static_cast<std::int64_t>(ParentBlock->GlobalTimecode())) / static_cast<std::int64_t>(ParentBlock->GlobalTimecodeScale());
   }
   return EbmlSInteger::UpdateSize(bSaveDefault, bForceRender);
 }
diff --git a/src/KaxCluster.cpp b/src/KaxCluster.cpp
index b372669..a089198 100644
--- a/src/KaxCluster.cpp
+++ b/src/KaxCluster.cpp
@@ -67,7 +67,7 @@ bool KaxCluster::AddBlockBlob(KaxBlockBlob * NewBlob)
   return true;
 }
 
-bool KaxCluster::AddFrameInternal(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup * PastBlock, const KaxBlockGroup * ForwBlock, LacingType lacing)
+bool KaxCluster::AddFrameInternal(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup * PastBlock, const KaxBlockGroup * ForwBlock, LacingType lacing)
 {
   if (!bFirstFrameInside) {
     bFirstFrameInside = true;
@@ -86,7 +86,7 @@ bool KaxCluster::AddFrameInternal(const KaxTrackEntry & track, uint64 timecode,
   }
 
   // force creation of a new block
-  if (currentNewBlock == nullptr || static_cast<uint32>(track.TrackNumber()) != static_cast<uint32>(currentNewBlock->TrackNumber()) || PastBlock != nullptr || ForwBlock != nullptr) {
+  if (currentNewBlock == nullptr || static_cast<std::uint32_t>(track.TrackNumber()) != static_cast<std::uint32_t>(currentNewBlock->TrackNumber()) || PastBlock != nullptr || ForwBlock != nullptr) {
     KaxBlockGroup & aNewBlock = GetNewBlock();
     MyNewBlock = currentNewBlock = &aNewBlock;
   }
@@ -118,19 +118,19 @@ bool KaxCluster::AddFrameInternal(const KaxTrackEntry & track, uint64 timecode,
   return false;
 }
 
-bool KaxCluster::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, LacingType lacing)
+bool KaxCluster::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, LacingType lacing)
 {
   assert(Blobs.empty()); // mutually exclusive for the moment
   return AddFrameInternal(track, timecode, buffer, MyNewBlock, nullptr, nullptr, lacing);
 }
 
-bool KaxCluster::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, LacingType lacing)
+bool KaxCluster::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, LacingType lacing)
 {
   assert(Blobs.empty()); // mutually exclusive for the moment
   return AddFrameInternal(track, timecode, buffer, MyNewBlock, &PastBlock, nullptr, lacing);
 }
 
-bool KaxCluster::AddFrame(const KaxTrackEntry & track, uint64 timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing)
+bool KaxCluster::AddFrame(const KaxTrackEntry & track, std::uint64_t timecode, DataBuffer & buffer, KaxBlockGroup * & MyNewBlock, const KaxBlockGroup & PastBlock, const KaxBlockGroup & ForwBlock, LacingType lacing)
 {
   assert(Blobs.empty()); // mutually exclusive for the moment
   return AddFrameInternal(track, timecode, buffer, MyNewBlock, &PastBlock, &ForwBlock, lacing);
@@ -158,7 +158,7 @@ filepos_t KaxCluster::Render(IOCallback & output, KaxCues & CueToUpdate, bool bS
       for (auto&& Trk : *MyTracks) {
         if (EbmlId(*Trk) == EBML_ID(KaxTrackEntry)) {
           auto entry = static_cast<KaxTrackEntry *>(Trk);
-          auto tracknum = static_cast<uint32>(entry->TrackNumber());
+          auto tracknum = static_cast<std::uint32_t>(entry->TrackNumber());
           auto track = std::find_if(ElementList.begin(), ElementList.end(), [=](EbmlElement *element)
               { return EbmlId(*element) == EBML_ID(KaxBlockGroup) && static_cast<KaxBlockGroup *>(element)->TrackNumber() == tracknum;  });
           // the track wasn't found in this cluster
@@ -196,7 +196,7 @@ filepos_t KaxCluster::Render(IOCallback & output, KaxCues & CueToUpdate, bool bS
       for (auto&& Trk : *MyTracks) {
         if (EbmlId(*Trk) == EBML_ID(KaxTrackEntry)) {
           auto entry = static_cast<KaxTrackEntry *>(Trk);
-          auto tracknum = static_cast<uint32>(entry->TrackNumber());
+          auto tracknum = static_cast<std::uint32_t>(entry->TrackNumber());
           for (Index = 0; Index<Blobs.size(); Index++) {
             if (static_cast<KaxInternalBlock&>(*Blobs[Index]).TrackNum() == tracknum)
               break; // this track is used
@@ -228,10 +228,10 @@ filepos_t KaxCluster::Render(IOCallback & output, KaxCues & CueToUpdate, bool bS
 /*!
   \todo automatically choose valid timecode for the Cluster based on the previous cluster timecode (must be incremental)
 */
-uint64 KaxCluster::GlobalTimecode() const
+std::uint64_t KaxCluster::GlobalTimecode() const
 {
   assert(bPreviousTimecodeIsSet);
-  uint64 result = MinTimecode;
+  std::uint64_t result = MinTimecode;
 
   if (result < PreviousTimecode)
     result = PreviousTimecode + 1;
@@ -243,23 +243,23 @@ uint64 KaxCluster::GlobalTimecode() const
   \brief retrieve the relative
   \todo !!! We need a way to know the TimecodeScale
 */
-int16 KaxCluster::GetBlockLocalTimecode(uint64 aGlobalTimecode) const
+std::int16_t KaxCluster::GetBlockLocalTimecode(std::uint64_t aGlobalTimecode) const
 {
-  const int64 TimecodeDelay = (static_cast<int64>(aGlobalTimecode) - static_cast<int64>(GlobalTimecode())) / static_cast<int64>(GlobalTimecodeScale());
-  assert(TimecodeDelay >= int16(0x8000) && TimecodeDelay <= int16(0x7FFF));
-  return static_cast<int16>(TimecodeDelay);
+  const std::int64_t TimecodeDelay = (static_cast<std::int64_t>(aGlobalTimecode) - static_cast<std::int64_t>(GlobalTimecode())) / static_cast<std::int64_t>(GlobalTimecodeScale());
+  assert(TimecodeDelay >= std::int16_t(0x8000) && TimecodeDelay <= std::int16_t(0x7FFF));
+  return static_cast<std::int16_t>(TimecodeDelay);
 }
 
-uint64 KaxCluster::GetBlockGlobalTimecode(int16 LocalTimecode)
+std::uint64_t KaxCluster::GetBlockGlobalTimecode(std::int16_t LocalTimecode)
 {
   if (!bFirstFrameInside) {
     auto Timecode = static_cast<KaxClusterTimecode *>(this->FindElt(EBML_INFO(KaxClusterTimecode)));
     assert (bFirstFrameInside); // use the InitTimecode() hack for now
-    MinTimecode = MaxTimecode = PreviousTimecode = static_cast<uint64>(*static_cast<EbmlUInteger *>(Timecode));
+    MinTimecode = MaxTimecode = PreviousTimecode = static_cast<std::uint64_t>(*static_cast<EbmlUInteger *>(Timecode));
     bFirstFrameInside = true;
     bPreviousTimecodeIsSet = true;
   }
-  return static_cast<int64>(LocalTimecode * GlobalTimecodeScale()) + GlobalTimecode();
+  return static_cast<std::int64_t>(LocalTimecode * GlobalTimecodeScale()) + GlobalTimecode();
 }
 
 KaxBlockGroup & KaxCluster::GetNewBlock()
@@ -278,7 +278,7 @@ void KaxCluster::ReleaseFrames()
   }
 }
 
-uint64 KaxCluster::GetPosition() const
+std::uint64_t KaxCluster::GetPosition() const
 {
   assert(ParentSegment != nullptr);
   return ParentSegment->GetRelativePosition(*this);
diff --git a/src/KaxCues.cpp b/src/KaxCues.cpp
index bdaf359..3f3fbf3 100644
--- a/src/KaxCues.cpp
+++ b/src/KaxCues.cpp
@@ -111,12 +111,12 @@ void KaxCues::PositionSet(const KaxBlockGroup & BlockRef)
 /*!
   \warning Assume that the list has been sorted (Sort())
 */
-const KaxCuePoint * KaxCues::GetTimecodePoint(uint64 aTimecode) const
+const KaxCuePoint * KaxCues::GetTimecodePoint(std::uint64_t aTimecode) const
 {
-  const uint64 TimecodeToLocate = aTimecode / GlobalTimecodeScale();
+  const std::uint64_t TimecodeToLocate = aTimecode / GlobalTimecodeScale();
   const KaxCuePoint * aPointPrev = nullptr;
-  uint64 aPrevTime = 0;
-  uint64 aNextTime = EBML_PRETTYLONGINT(0xFFFFFFFFFFFF);
+  std::uint64_t aPrevTime = 0;
+  std::uint64_t aNextTime = EBML_PRETTYLONGINT(0xFFFFFFFFFFFF);
 
   EBML_MASTER_CONST_ITERATOR Itr;
   for (Itr = begin(); Itr != end(); ++Itr) {
@@ -125,7 +125,7 @@ const KaxCuePoint * KaxCues::GetTimecodePoint(uint64 aTimecode) const
       // check the tile
       auto aTime = static_cast<const KaxCueTime *>(tmp->FindFirstElt(EBML_INFO(KaxCueTime)));
       if (aTime != nullptr) {
-        auto _Time = static_cast<uint64>(*aTime);
+        auto _Time = static_cast<std::uint64_t>(*aTime);
         if (_Time > aPrevTime && _Time < TimecodeToLocate) {
           aPrevTime = _Time;
           aPointPrev = tmp;
@@ -140,7 +140,7 @@ const KaxCuePoint * KaxCues::GetTimecodePoint(uint64 aTimecode) const
   return aPointPrev;
 }
 
-uint64 KaxCues::GetTimecodePosition(uint64 aTimecode) const
+std::uint64_t KaxCues::GetTimecodePosition(std::uint64_t aTimecode) const
 {
   const KaxCuePoint * const aPoint = GetTimecodePoint(aTimecode);
   if (aPoint == nullptr)
diff --git a/src/KaxCuesData.cpp b/src/KaxCuesData.cpp
index e95c180..05e0b3e 100644
--- a/src/KaxCuesData.cpp
+++ b/src/KaxCuesData.cpp
@@ -47,7 +47,7 @@ namespace libmatroska {
   \todo handle codec state checking
   \todo remove duplicate references (reference to 2 frames that each reference the same frame)
 */
-void KaxCuePoint::PositionSet(const KaxBlockGroup & BlockReference, uint64 GlobalTimecodeScale)
+void KaxCuePoint::PositionSet(const KaxBlockGroup & BlockReference, std::uint64_t GlobalTimecodeScale)
 {
   // fill me
   auto & NewTime = GetChild<KaxCueTime>(*this);
@@ -78,7 +78,7 @@ void KaxCuePoint::PositionSet(const KaxBlockGroup & BlockReference, uint64 Globa
   SetValueIsSet();
 }
 
-void KaxCuePoint::PositionSet(const KaxBlockBlob & BlobReference, uint64 GlobalTimecodeScale)
+void KaxCuePoint::PositionSet(const KaxBlockBlob & BlobReference, std::uint64_t GlobalTimecodeScale)
 {
   const KaxInternalBlock &BlockReference = BlobReference;
   const KaxBlockGroup *BlockGroupPointer = nullptr;
@@ -90,12 +90,12 @@ void KaxCuePoint::PositionSet(const KaxBlockBlob & BlobReference, uint64 GlobalT
   PositionSet(BlockReference, BlockGroupPointer, GlobalTimecodeScale);
 }
 
-void KaxCuePoint::PositionSet(const KaxSimpleBlock & BlockReference, uint64 GlobalTimecodeScale)
+void KaxCuePoint::PositionSet(const KaxSimpleBlock & BlockReference, std::uint64_t GlobalTimecodeScale)
 {
   PositionSet(BlockReference, nullptr, GlobalTimecodeScale);
 }
 
-void KaxCuePoint::PositionSet(const KaxInternalBlock & BlockReference, const KaxBlockGroup *BlockGroup, uint64 GlobalTimecodeScale)
+void KaxCuePoint::PositionSet(const KaxInternalBlock & BlockReference, const KaxBlockGroup *BlockGroup, std::uint64_t GlobalTimecodeScale)
 {
   // fill me
   auto & NewTime = GetChild<KaxCueTime>(*this);
@@ -133,7 +133,7 @@ void KaxCuePoint::PositionSet(const KaxInternalBlock & BlockReference, const Kax
 /*!
   \todo handle codec state checking
 */
-void KaxCueReference::AddReference(const KaxBlockBlob & BlockReference, uint64 GlobalTimecodeScale)
+void KaxCueReference::AddReference(const KaxBlockBlob & BlockReference, std::uint64_t GlobalTimecodeScale)
 {
   const KaxInternalBlock & theBlock = BlockReference;
   auto & NewTime = GetChild<KaxCueRefTime>(*this);
@@ -193,12 +193,12 @@ bool KaxCuePoint::IsSmallerThan(const EbmlElement * Cmp) const
   return false;
 }
 
-bool KaxCuePoint::Timecode(uint64 & aTimecode, uint64 GlobalTimecodeScale) const
+bool KaxCuePoint::Timecode(std::uint64_t & aTimecode, std::uint64_t GlobalTimecodeScale) const
 {
   auto aTime = static_cast<const KaxCueTime *>(FindFirstElt(EBML_INFO(KaxCueTime)));
   if (aTime == nullptr)
     return false;
-  aTimecode = static_cast<uint64>(*aTime) * GlobalTimecodeScale;
+  aTimecode = static_cast<std::uint64_t>(*aTime) * GlobalTimecodeScale;
   return true;
 }
 
@@ -208,13 +208,13 @@ bool KaxCuePoint::Timecode(uint64 & aTimecode, uint64 GlobalTimecodeScale) const
 const KaxCueTrackPositions * KaxCuePoint::GetSeekPosition() const
 {
   const KaxCueTrackPositions * result = nullptr;
-  uint64 aPosition = EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFFF);
+  std::uint64_t aPosition = EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFFF);
   // find the position of the "earlier" Cluster
   auto aPoss = static_cast<const KaxCueTrackPositions *>(FindFirstElt(EBML_INFO(KaxCueTrackPositions)));
   while (aPoss != nullptr) {
     auto aPos = static_cast<const KaxCueClusterPosition *>(aPoss->FindFirstElt(EBML_INFO(KaxCueClusterPosition)));
-    if (aPos != nullptr && static_cast<uint64>(*aPos) < aPosition) {
-      aPosition = static_cast<uint64>(*aPos);
+    if (aPos != nullptr && static_cast<std::uint64_t>(*aPos) < aPosition) {
+      aPosition = static_cast<std::uint64_t>(*aPos);
       result = aPoss;
     }
 
@@ -223,22 +223,22 @@ const KaxCueTrackPositions * KaxCuePoint::GetSeekPosition() const
   return result;
 }
 
-uint64 KaxCueTrackPositions::ClusterPosition() const
+std::uint64_t KaxCueTrackPositions::ClusterPosition() const
 {
   auto aPos = static_cast<const KaxCueClusterPosition *>(FindFirstElt(EBML_INFO(KaxCueClusterPosition)));
   if (aPos == nullptr)
     return 0;
 
-  return static_cast<uint64>(*aPos);
+  return static_cast<std::uint64_t>(*aPos);
 }
 
-uint16 KaxCueTrackPositions::TrackNumber() const
+std::uint16_t KaxCueTrackPositions::TrackNumber() const
 {
   auto aTrack = static_cast<const KaxCueTrack *>(FindFirstElt(EBML_INFO(KaxCueTrack)));
   if (aTrack == nullptr)
     return 0;
 
-  return static_cast<uint16>(*aTrack);
+  return static_cast<std::uint16_t>(*aTrack);
 }
 
 
diff --git a/src/KaxSeekHead.cpp b/src/KaxSeekHead.cpp
index 2b5d911..8cc9e2b 100644
--- a/src/KaxSeekHead.cpp
+++ b/src/KaxSeekHead.cpp
@@ -109,12 +109,12 @@ KaxSeek * KaxSeekHead::FindNextOf(const KaxSeek &aPrev) const
   return nullptr;
 }
 
-int64 KaxSeek::Location() const
+std::int64_t KaxSeek::Location() const
 {
   auto aPos = static_cast<KaxSeekPosition*>(FindFirstElt(EBML_INFO(KaxSeekPosition)));
   if (aPos == nullptr)
     return 0;
-  return static_cast<uint64>(*aPos);
+  return static_cast<std::uint64_t>(*aPos);
 }
 
 bool KaxSeek::IsEbmlId(const EbmlId & aId) const
diff --git a/src/KaxSegment.cpp b/src/KaxSegment.cpp
index c98c64a..67bbf27 100644
--- a/src/KaxSegment.cpp
+++ b/src/KaxSegment.cpp
@@ -66,17 +66,17 @@ KaxSegment::KaxSegment(const KaxSegment & ElementToClone)
 }
 
 
-uint64 KaxSegment::GetRelativePosition(uint64 aGlobalPosition) const
+std::uint64_t KaxSegment::GetRelativePosition(std::uint64_t aGlobalPosition) const
 {
   return aGlobalPosition - GetElementPosition() - HeadSize();
 }
 
-uint64 KaxSegment::GetRelativePosition(const EbmlElement & Elt) const
+std::uint64_t KaxSegment::GetRelativePosition(const EbmlElement & Elt) const
 {
   return GetRelativePosition(Elt.GetElementPosition());
 }
 
-uint64 KaxSegment::GetGlobalPosition(uint64 aRelativePosition) const
+std::uint64_t KaxSegment::GetGlobalPosition(std::uint64_t aRelativePosition) const
 {
   return aRelativePosition + GetElementPosition() + HeadSize();
 }
diff --git a/test/ebml/test0.cpp b/test/ebml/test0.cpp
index ac94fe7..d9159f5 100644
--- a/test/ebml/test0.cpp
+++ b/test/ebml/test0.cpp
@@ -261,10 +261,10 @@ int main(void)
       switch (SemanticList[i].Type)
       {
         case EBML_U_INTEGER:
-          printf(" : %d", uint32(*(EbmlUInteger*)EvaledElementLevel0));
+          printf(" : %d", std::uint32_t(*(EbmlUInteger*)EvaledElementLevel0));
           break;
         case EBML_S_INTEGER:
-          printf(" : %d", int32(*(EbmlSInteger*)EvaledElementLevel0));
+          printf(" : %d", std::int32_t(*(EbmlSInteger*)EvaledElementLevel0));
           break;
         case EBML_BINARY:
           printf(" : binary data, size = %ld", (*(EbmlBinary*)EvaledElementLevel0).GetSize());
diff --git a/test/mux/test6.cpp b/test/mux/test6.cpp
index 1076621..f36685d 100644
--- a/test/mux/test6.cpp
+++ b/test/mux/test6.cpp
@@ -60,7 +60,7 @@ unsigned int BIN_FILE_SIZE = 15000;
 unsigned int TXT_FILE_SIZE = 3000;
 const unsigned int BIN_FRAME_SIZE = 1500;
 const unsigned int TXT_FRAME_SIZE = 200;
-const uint64  TIMECODE_SCALE = 1000000;
+const std::uint64_t  TIMECODE_SCALE = 1000000;
 
 const bool bWriteDefaultValues = false;
 
@@ -93,7 +93,7 @@ int main(int argc, char **argv)
     KaxSegment FileSegment;
 
     // size is unknown and will always be, we can render it right away
-    uint64 SegmentSize = FileSegment.WriteHead(out_file, 5, bWriteDefaultValues);
+    std::uint64_t SegmentSize = FileSegment.WriteHead(out_file, 5, bWriteDefaultValues);
 
     KaxTracks & MyTracks = GetChild<KaxTracks>(FileSegment);
 
@@ -200,7 +200,7 @@ int main(int argc, char **argv)
     KaxVideoPixelWidth & MyTrack2PWidth = GetChild<KaxVideoPixelWidth>(MyTrack2Video);
     *(static_cast<EbmlUInteger *>(&MyTrack2PWidth)) = 320;
 
-    uint64 TrackSize = MyTracks.Render(out_file, bWriteDefaultValues);
+    std::uint64_t TrackSize = MyTracks.Render(out_file, bWriteDefaultValues);
 
     KaxTracks * pMyTracks2 = static_cast<KaxTracks *>(MyTracks.Clone());
 //    KaxTracks * pMyTracks2 = new KaxTracks(MyTracks);
@@ -278,7 +278,7 @@ int main(int argc, char **argv)
     // - write the cluster(s)
     // - seek back in the file and write the cue entry over the empty element
 
-    uint64 ClusterSize = Clust1.Render(out_file, AllCues, bWriteDefaultValues);
+    std::uint64_t ClusterSize = Clust1.Render(out_file, AllCues, bWriteDefaultValues);
     Clust1.ReleaseFrames();
     MetaSeek.IndexThis(Clust1, FileSegment);
 
diff --git a/test/mux/test8.cpp b/test/mux/test8.cpp
index 46c1f78..ea47543 100644
--- a/test/mux/test8.cpp
+++ b/test/mux/test8.cpp
@@ -107,7 +107,7 @@ int main(int argc, char **argv)
   KaxSeekHead *MetaSeek;
   KaxChapters *Chapters;
   KaxTags *AllTags;
-  uint64 TimecodeScale = 1000000;
+  std::uint64_t TimecodeScale = 1000000;
 
   // find the segment to read
   ElementLevel0 = aStream.FindNextID(KaxSegment::ClassInfos, 0xFFFFFFFFL);
@@ -162,7 +162,7 @@ int main(int argc, char **argv)
                 if (EbmlId(*ElementLevel3) == KaxTrackNumber::ClassInfos.GlobalId) {
                   KaxTrackNumber & TrackNum = *static_cast<KaxTrackNumber*>(ElementLevel3);
                   TrackNum.ReadData(aStream.I_O());
-                  printf("Track # %d\n", uint8(TrackNum));
+                  printf("Track # %d\n", std::uint8_t(TrackNum));
                 }
 
                 // Track type
@@ -170,7 +170,7 @@ int main(int argc, char **argv)
                   KaxTrackType & TrackType = *static_cast<KaxTrackType*>(ElementLevel3);
                   TrackType.ReadData(aStream.I_O());
                   printf("Track type : ");
-                  switch(uint8(TrackType))
+                  switch(std::uint8_t(TrackType))
                   {
                   case track_audio:
                     printf("Audio");
@@ -252,8 +252,8 @@ int main(int argc, char **argv)
             if (EbmlId(*ElementLevel2) == KaxTimecodeScale::ClassInfos.GlobalId) {
               KaxTimecodeScale *TimeScale = static_cast<KaxTimecodeScale*>(ElementLevel2);
               TimeScale->ReadData(aStream.I_O());
-              printf("Timecode Scale %d\n", uint32(*TimeScale));
-              TimecodeScale = uint64(*TimeScale);
+              printf("Timecode Scale %d\n", std::uint32_t(*TimeScale));
+              TimecodeScale = std::uint64_t(*TimeScale);
             } else if (EbmlId(*ElementLevel2) == KaxDuration::ClassInfos.GlobalId) {
               printf("Segment duration\n");
             } else if (EbmlId(*ElementLevel2) == KaxDateUTC::ClassInfos.GlobalId) {
@@ -298,10 +298,10 @@ int main(int argc, char **argv)
           printf("\n- Segment Clusters found\n");
           SegmentCluster = static_cast<KaxCluster *>(ElementLevel1);
 //          SegmentCluster->ClearElement();
-          uint32 ClusterTimecode;
+          std::uint32_t ClusterTimecode;
           EbmlCrc32 *pChecksum = NULL;
-          uint32 SizeInCrc;
-          uint64 CrcPositionStart = 0;
+          std::uint32_t SizeInCrc;
+          std::uint64_t CrcPositionStart = 0;
 
 #ifdef MEMORY_READ // read the Cluster in memory and then extract elements from memory
           SegmentCluster->Read(aStream, KaxCluster::ClassInfos.Context, UpperElementLevel, ElementLevel2, bAllowDummy);
@@ -330,7 +330,7 @@ int main(int argc, char **argv)
               printf("Cluster timecode found\n");
               KaxClusterTimecode & ClusterTime = *static_cast<KaxClusterTimecode*>(ElementLevel2);
               ClusterTime.ReadData(aStream.I_O());
-              ClusterTimecode = uint32(ClusterTime);
+              ClusterTimecode = std::uint32_t(ClusterTime);
               SegmentCluster->InitTimecode(ClusterTimecode, TimecodeScale);
             } else  if (EbmlId(*ElementLevel2) == KaxBlockGroup::ClassInfos.GlobalId) {
               printf("Block Group found\n");
@@ -350,11 +350,11 @@ int main(int argc, char **argv)
               }
               KaxBlockDuration * BlockDuration = static_cast<KaxBlockDuration *>(aBlockGroup.FindElt(KaxBlockDuration::ClassInfos));
               if (BlockDuration != NULL) {
-                printf("  Block Duration %d scaled ticks : %ld ns\n", uint32(*BlockDuration), uint32(*BlockDuration) * TimecodeScale);
+                printf("  Block Duration %d scaled ticks : %ld ns\n", std::uint32_t(*BlockDuration), std::uint32_t(*BlockDuration) * TimecodeScale);
               }
               KaxReferenceBlock * RefTime = static_cast<KaxReferenceBlock *>(aBlockGroup.FindElt(KaxReferenceBlock::ClassInfos));
               if (RefTime != NULL) {
-                printf("  Reference frame at scaled (%d) timecode %ld\n", int32(*RefTime), int32(int64(*RefTime) * TimecodeScale));
+                printf("  Reference frame at scaled (%d) timecode %ld\n", std::int32_t(*RefTime), std::int32_t(std::int64_t(*RefTime) * TimecodeScale));
               }
 #else // TEST_BLOCKGROUP_READ
               // read the data we care about in matroska
@@ -392,11 +392,11 @@ int main(int argc, char **argv)
                 } else if (EbmlId(*ElementLevel3) == KaxReferenceBlock::ClassInfos.GlobalId) {
                   KaxReferenceBlock & RefTime = *static_cast<KaxReferenceBlock*>(ElementLevel3);
                   RefTime.ReadData(aStream.I_O());
-                  printf("  Reference frame at scaled (%d) timecode %ld\n", int32(RefTime), int32(int64(RefTime) * TimecodeScale));
+                  printf("  Reference frame at scaled (%d) timecode %ld\n", std::int32_t(RefTime), std::int32_t(std::int64_t(RefTime) * TimecodeScale));
                 } else if (EbmlId(*ElementLevel3) == KaxBlockDuration::ClassInfos.GlobalId) {
                   KaxBlockDuration & BlockDuration = *static_cast<KaxBlockDuration*>(ElementLevel3);
                   BlockDuration.ReadData(aStream.I_O());
-                  printf("  Block Duration %d scaled ticks : %ld ns\n", uint32(BlockDuration), uint32(BlockDuration) * TimecodeScale);
+                  printf("  Block Duration %d scaled ticks : %ld ns\n", std::uint32_t(BlockDuration), std::uint32_t(BlockDuration) * TimecodeScale);
                 }
                 if (UpperElementLevel > 0) {
                   UpperElementLevel--;
@@ -437,8 +437,8 @@ int main(int argc, char **argv)
 #endif // not MEMORY_READ
           if (pChecksum != NULL) {
             EbmlCrc32 ComputedChecksum;
-            uint64 CurrPosition = aStream.I_O().getFilePointer();
-            uint64 CrcPositionEnd = ElementLevel2->GetElementPosition();
+            std::uint64_t CurrPosition = aStream.I_O().getFilePointer();
+            std::uint64_t CrcPositionEnd = ElementLevel2->GetElementPosition();
             binary *SupposedBufferInCrc = new binary [CrcPositionEnd - CrcPositionStart];
             aStream.I_O().setFilePointer(CrcPositionStart);
             aStream.I_O().readFully(SupposedBufferInCrc, CrcPositionEnd - CrcPositionStart);
@@ -477,7 +477,7 @@ int main(int argc, char **argv)
               for (Index1 = 0; Index1<CuePoint.ListSize() ;Index1++) {
                 if (CuePoint[Index1]->Generic().GlobalId == KaxCueTime::ClassInfos.GlobalId) {
                   KaxCueTime & CueTime = *static_cast<KaxCueTime *>(CuePoint[Index1]);
-                  printf("  Time %ld\n", uint64(CueTime) * TimecodeScale);
+                  printf("  Time %ld\n", std::uint64_t(CueTime) * TimecodeScale);
                 } else if (CuePoint[Index1]->Generic().GlobalId == KaxCueTrackPositions::ClassInfos.GlobalId) {
                   KaxCueTrackPositions & CuePos = *static_cast<KaxCueTrackPositions *>(CuePoint[Index1]);
                   printf("  Positions\n");
@@ -486,10 +486,10 @@ int main(int argc, char **argv)
                   for (Index2 = 0; Index2<CuePos.ListSize() ;Index2++) {
                     if (CuePos[Index2]->Generic().GlobalId == KaxCueTrack::ClassInfos.GlobalId) {
                       KaxCueTrack & CueTrack = *static_cast<KaxCueTrack *>(CuePos[Index2]);
-                      printf("   Track %d\n", uint16(CueTrack));
+                      printf("   Track %d\n", std::uint16_t(CueTrack));
                     } else if (CuePos[Index2]->Generic().GlobalId == KaxCueClusterPosition::ClassInfos.GlobalId) {
                       KaxCueClusterPosition & CuePoss = *static_cast<KaxCueClusterPosition *>(CuePos[Index2]);
-                      printf("   Cluster position %d\n", uint64(CuePoss));
+                      printf("   Cluster position %d\n", std::uint64_t(CuePoss));
                     } else if (CuePos[Index2]->Generic().GlobalId == KaxCueReference::ClassInfos.GlobalId) {
                       KaxCueReference & CueRefs = *static_cast<KaxCueReference *>(CuePos[Index2]);
                       printf("   Reference\n");
@@ -498,10 +498,10 @@ int main(int argc, char **argv)
                       for (Index3 = 0; Index3<CueRefs.ListSize() ;Index3++) {
                         if (CueRefs[Index3]->Generic().GlobalId == KaxCueRefTime::ClassInfos.GlobalId) {
                           KaxCueRefTime & CueTime = *static_cast<KaxCueRefTime *>(CueRefs[Index3]);
-                          printf("    Time %d\n", uint32(CueTime));
+                          printf("    Time %d\n", std::uint32_t(CueTime));
                         } else if (CueRefs[Index3]->Generic().GlobalId == KaxCueRefCluster::ClassInfos.GlobalId) {
                           KaxCueRefCluster & CueClust = *static_cast<KaxCueRefCluster *>(CueRefs[Index3]);
-                          printf("    Cluster position %d\n", uint64(CueClust));
+                          printf("    Cluster position %d\n", std::uint64_t(CueClust));
                         } else {
                           printf("    - found %s\n", CueRefs[Index3]->Generic().DebugName);
                         }
@@ -545,7 +545,7 @@ int main(int argc, char **argv)
                   printf("\n");
                 } else if (SeekPoint[Index1]->Generic().GlobalId == KaxSeekPosition::ClassInfos.GlobalId) {
                   KaxSeekPosition * SeekPos = static_cast<KaxSeekPosition *>(SeekPoint[Index1]);
-                  printf("    Seek position %d\n", uint32(*SeekPos));
+                  printf("    Seek position %d\n", std::uint32_t(*SeekPos));
                 }
               }
             }
@@ -573,11 +573,11 @@ int main(int argc, char **argv)
                   unsigned int Index3;
                   for (Index3 = 0; Index3<aChapterAtom.ListSize() ;Index3++) {
                     if (aChapterAtom[Index3]->Generic().GlobalId == KaxChapterUID::ClassInfos.GlobalId) {
-                      printf("      Chapter UID 0x%08x\n", uint32(*static_cast<EbmlUInteger *>(aChapterAtom[Index3])) );
+                      printf("      Chapter UID 0x%08x\n", std::uint32_t(*static_cast<EbmlUInteger *>(aChapterAtom[Index3])) );
                     } else if (aChapterAtom[Index3]->Generic().GlobalId == KaxChapterTimeStart::ClassInfos.GlobalId) {
-                      printf("      Time Start %d\n", uint32(*static_cast<EbmlUInteger *>(aChapterAtom[Index3])) );
+                      printf("      Time Start %d\n", std::uint32_t(*static_cast<EbmlUInteger *>(aChapterAtom[Index3])) );
                     } else if (aChapterAtom[Index3]->Generic().GlobalId == KaxChapterTimeEnd::ClassInfos.GlobalId) {
-                      printf("      Time End %d ns\n", uint32(*static_cast<EbmlUInteger *>(aChapterAtom[Index3])) );
+                      printf("      Time End %d ns\n", std::uint32_t(*static_cast<EbmlUInteger *>(aChapterAtom[Index3])) );
                     } else if (aChapterAtom[Index3]->Generic().GlobalId == KaxChapterTrack::ClassInfos.GlobalId) {
                       printf("      Track list\n");
                     } else if (aChapterAtom[Index3]->Generic().GlobalId == KaxChapterDisplay::ClassInfos.GlobalId) {
@@ -749,7 +749,7 @@ int main(int argc, char **argv)
   }
 
 #ifdef OLD
-  uint8 TrackNumber = MuxedFile.GetTrackNumber();
+  std::uint8_t TrackNumber = MuxedFile.GetTrackNumber();
 
   TrackInfo *Tracks = new TrackInfo[TrackNumber];
   TrackInfoAudio aAudioTrack;
@@ -795,9 +795,9 @@ int main(int argc, char **argv)
   StdIOCallback Output_file3("out-vide.bin", MODE_CREATE);
 
   Track * TrackRead;
-  uint32 timecode; // not used yet
+  std::uint32_t timecode; // not used yet
   binary *aFrame;
-  uint32 aFrameSize;
+  std::uint32_t aFrameSize;
   while (MuxedFile.ReadFrame(TrackRead, timecode, aFrame, aFrameSize))
   {
       if (TrackRead == track1)
-- 
2.41.0

