From 23ae5c691964ebcbfc2e55be95c19afc23448ce4 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Wed, 1 Jun 2016 10:54:45 +0200
Subject: Haiku patch


diff --git a/CMakeLists.txt b/CMakeLists.txt
index 61f9a36..6a4c598 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -125,14 +125,23 @@ ELSE (WIN32)
             SET(CMAKE_CXX_FLAGS " ${CMAKE_CXX_FLAGS} -flax-vector-conversions -std=c++0x")
 		
         ELSE (APPLE)
-			SET_PROPERTY(GLOBAL PROPERTY JUCE_LINUX "JUCE_LINUX")
-            SET(EXTENSION "cpp")
+        	IF   (HAIKU)
+				SET_PROPERTY(GLOBAL PROPERTY JUCE_HAIKU "JUCE_HAIKU")
+	            SET(EXTENSION "cpp")
+	            
+				INCLUDE_DIRECTORIES(/system/develop/headers/freetype2)
+				ADD_DEFINITIONS(-DHAIKU)
+				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES curl freetype)
+			ELSE (HAIKU)
+			    SET_PROPERTY(GLOBAL PROPERTY JUCE_LINUX "JUCE_LINUX")
+            	SET(EXTENSION "cpp")
             
-			FIND_PACKAGE(X11 REQUIRED)
-			INCLUDE_DIRECTORIES(${X11_INCLUDE_DIR})
-			INCLUDE_DIRECTORIES(/usr/include/freetype2)
-			ADD_DEFINITIONS(-DLINUX)
-			SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES ${X11_LIBRARIES} asound freetype Xinerama)
+				FIND_PACKAGE(X11 REQUIRED)
+				INCLUDE_DIRECTORIES(${X11_INCLUDE_DIR})
+				INCLUDE_DIRECTORIES(/usr/include/freetype2)
+				ADD_DEFINITIONS(-DLINUX)
+				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES ${X11_LIBRARIES} asound freetype Xinerama)
+			ENDIF(HAIKU)
 		ENDIF(APPLE)
 	ENDIF(UNIX)
 ENDIF(WIN32)
diff --git a/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp b/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
index 2bc3c6a..6c1fd00 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
+++ b/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
@@ -215,6 +215,14 @@ namespace juce
   #include "native/juce_android_OpenSL.cpp"
  #endif
 
+//==============================================================================
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Midi.cpp"
+
+ #if JUCE_USE_CDREADER
+  #include "native/juce_linux_AudioCDReader.cpp"
+ #endif
+
 #endif
 
 #if ! JUCE_SYSTEMAUDIOVOL_IMPLEMENTED
diff --git a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h
index 0c5a5b6..807b58e 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h
+++ b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h
@@ -122,7 +122,7 @@ public:
     static MidiInput* openDevice (int deviceIndex,
                                   MidiInputCallback* callback);
 
-   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || DOXYGEN
+   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || JUCE_HAIKU || DOXYGEN
     /** This will try to create a new midi input device (Not available on Windows).
 
         This will attempt to create a new midi input device with the specified name,
diff --git a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h
index c908263..286673a 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h
+++ b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h
@@ -67,7 +67,7 @@ public:
     static MidiOutput* openDevice (int deviceIndex);
 
 
-   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || DOXYGEN
+   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || JUCE_HAIKU || DOXYGEN
     /** This will try to create a new midi output device (Not available on Windows).
 
         This will attempt to create a new midi output device that other apps can connect
diff --git a/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Midi.cpp b/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Midi.cpp
new file mode 100644
index 0000000..f1d2e5b
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Midi.cpp
@@ -0,0 +1,40 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+StringArray MidiOutput::getDevices()                                { return StringArray(); }
+int MidiOutput::getDefaultDeviceIndex()                             { return 0; }
+MidiOutput* MidiOutput::openDevice (int)                            { return nullptr; }
+MidiOutput* MidiOutput::createNewDevice (const String&)             { return nullptr; }
+MidiOutput::~MidiOutput()   {}
+void MidiOutput::sendMessageNow (const MidiMessage&)    {}
+
+MidiInput::MidiInput (const String& nm) : name (nm), internal (nullptr)  {}
+MidiInput::~MidiInput() {}
+void MidiInput::start() {}
+void MidiInput::stop()  {}
+int MidiInput::getDefaultDeviceIndex()      { return 0; }
+StringArray MidiInput::getDevices()         { return StringArray(); }
+MidiInput* MidiInput::openDevice (int, MidiInputCallback*)                  { return nullptr; }
+MidiInput* MidiInput::createNewDevice (const String&, MidiInputCallback*)   { return nullptr; }
+
diff --git a/JuceLibraryCode/modules/juce_core/juce_core.cpp b/JuceLibraryCode/modules/juce_core/juce_core.cpp
index d5ad930..6a3d89b 100644
--- a/JuceLibraryCode/modules/juce_core/juce_core.cpp
+++ b/JuceLibraryCode/modules/juce_core/juce_core.cpp
@@ -97,7 +97,7 @@
  #include <net/if.h>
  #include <sys/ioctl.h>
 
- #if ! JUCE_ANDROID
+ #if ! JUCE_ANDROID && ! JUCE_HAIKU
   #include <execinfo.h>
  #endif
 #endif
@@ -111,6 +111,16 @@
  #include <android/log.h>
 #endif
 
+#if JUCE_HAIKU
+ #include <dirent.h>
+ #include <errno.h>
+ #include <fnmatch.h>
+ #include <sys/sockio.h>
+ #include <sys/mman.h>
+ #include <dlfcn.h>
+ #include <curl/curl.h>
+#endif
+
 //==============================================================================
 #ifndef    JUCE_STANDALONE_APPLICATION
  JUCE_COMPILER_WARNING ("Please re-save your Introjucer project with the latest Introjucer version to avoid this warning")
@@ -229,6 +239,12 @@ namespace juce
 #include "native/juce_android_SystemStats.cpp"
 #include "native/juce_android_Threads.cpp"
 
+//==============================================================================
+#elif JUCE_HAIKU
+#include "native/juce_linux_CommonFile.cpp"
+#include "native/juce_curl_Network.cpp"
+#include "native/juce_haiku_Files.cpp"
+#include "native/juce_haiku_SystemStats.cpp"
 #endif
 
 #include "threads/juce_ChildProcess.cpp"
diff --git a/JuceLibraryCode/modules/juce_core/native/juce_haiku_Files.cpp b/JuceLibraryCode/modules/juce_core/native/juce_haiku_Files.cpp
new file mode 100644
index 0000000..1be608f
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_core/native/juce_haiku_Files.cpp
@@ -0,0 +1,215 @@
+/*
+  ==============================================================================
+
+   This file is part of the juce_core module of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission to use, copy, modify, and/or distribute this software for any purpose with
+   or without fee is hereby granted, provided that the above copyright notice and this
+   permission notice appear in all copies.
+
+   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
+   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
+   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ------------------------------------------------------------------------------
+
+   NOTE! This permissive ISC license applies ONLY to files within the juce_core module!
+   All other JUCE modules are covered by a dual GPL/commercial license, so if you are
+   using any other modules, be sure to check that you also comply with their license.
+
+   For more details, visit www.juce.com
+
+  ==============================================================================
+*/
+
+bool File::isOnCDRomDrive() const
+{
+	return false;
+}
+
+bool File::isOnHardDisk() const
+{
+    return true;
+}
+
+bool File::isOnRemovableDrive() const
+{
+    return false;
+}
+
+String File::getVersion() const
+{
+    return String(); // xxx not yet implemented
+}
+
+//==============================================================================
+static File resolveXDGFolder (const char* const type, const char* const fallbackFolder)
+{
+    StringArray confLines;
+    File ("~/.config/user-dirs.dirs").readLines (confLines);
+
+    for (int i = 0; i < confLines.size(); ++i)
+    {
+        const String line (confLines[i].trimStart());
+
+        if (line.startsWith (type))
+        {
+            // eg. resolve XDG_MUSIC_DIR="$HOME/Music" to /home/user/Music
+            const File f (line.replace ("$HOME", File ("~").getFullPathName())
+                              .fromFirstOccurrenceOf ("=", false, false)
+                              .trim().unquoted());
+
+            if (f.isDirectory())
+                return f;
+        }
+    }
+
+    return File (fallbackFolder);
+}
+
+const char* const* juce_argv = nullptr;
+int juce_argc = 0;
+
+File File::getSpecialLocation (const SpecialLocationType type)
+{
+    switch (type)
+    {
+        case userHomeDirectory:
+        {
+            if (const char* homeDir = getenv ("HOME"))
+                return File (CharPointer_UTF8 (homeDir));
+
+            if (struct passwd* const pw = getpwuid (getuid()))
+                return File (CharPointer_UTF8 (pw->pw_dir));
+
+            return File();
+        }
+
+        case userDocumentsDirectory:          return resolveXDGFolder ("XDG_DOCUMENTS_DIR", "~");
+        case userMusicDirectory:              return resolveXDGFolder ("XDG_MUSIC_DIR",     "~");
+        case userMoviesDirectory:             return resolveXDGFolder ("XDG_VIDEOS_DIR",    "~");
+        case userPicturesDirectory:           return resolveXDGFolder ("XDG_PICTURES_DIR",  "~");
+        case userDesktopDirectory:            return resolveXDGFolder ("XDG_DESKTOP_DIR",   "~/Desktop");
+        case userApplicationDataDirectory:    return resolveXDGFolder ("XDG_CONFIG_HOME",   "~");
+        case commonDocumentsDirectory:
+        case commonApplicationDataDirectory:  return File ("/var");
+        case globalApplicationsDirectory:     return File ("/usr");
+
+        case tempDirectory:
+        {
+            File tmp ("/var/tmp");
+
+            if (! tmp.isDirectory())
+            {
+                tmp = "/tmp";
+
+                if (! tmp.isDirectory())
+                    tmp = File::getCurrentWorkingDirectory();
+            }
+
+            return tmp;
+        }
+
+        case invokedExecutableFile:
+            if (juce_argv != nullptr && juce_argc > 0)
+                return File (CharPointer_UTF8 (juce_argv[0]));
+            // deliberate fall-through...
+
+        case currentExecutableFile:
+        case currentApplicationFile:
+           #if ! JUCE_STANDALONE_APPLICATION
+            return juce_getExecutableFile();
+           #endif
+            // deliberate fall-through if this is not a shared-library
+
+        case hostApplicationPath:
+        {
+            const File f ("/proc/self/exe");
+            return f.isLink() ? f.getLinkedTarget() : juce_getExecutableFile();
+        }
+
+        default:
+            jassertfalse; // unknown type?
+            break;
+    }
+
+    return File();
+}
+
+//==============================================================================
+bool File::moveToTrash() const
+{
+    if (! exists())
+        return true;
+
+    File trashCan ("~/.Trash");
+
+    if (! trashCan.isDirectory())
+        trashCan = "~/.local/share/Trash/files";
+
+    if (! trashCan.isDirectory())
+        return false;
+
+    return moveFileTo (trashCan.getNonexistentChildFile (getFileNameWithoutExtension(),
+                                                         getFileExtension()));
+}
+
+//==============================================================================
+static bool isFileExecutable (const String& filename)
+{
+    juce_statStruct info;
+
+    return juce_stat (filename, info)
+            && S_ISREG (info.st_mode)
+            && access (filename.toUTF8(), X_OK) == 0;
+}
+
+bool Process::openDocument (const String& fileName, const String& parameters)
+{
+    String cmdString (fileName.replace (" ", "\\ ",false));
+    cmdString << " " << parameters;
+
+    if (URL::isProbablyAWebsiteURL (fileName)
+         || cmdString.startsWithIgnoreCase ("file:")
+         || URL::isProbablyAnEmailAddress (fileName)
+         || File::createFileWithoutCheckingPath (fileName).isDirectory()
+         || ! isFileExecutable (fileName))
+    {
+        // create a command that tries to launch a bunch of likely browsers
+        static const char* const browserNames[] = { "xdg-open", "/etc/alternatives/x-www-browser", "firefox", "mozilla",
+                                                    "google-chrome", "chromium-browser", "opera", "konqueror" };
+        StringArray cmdLines;
+
+        for (int i = 0; i < numElementsInArray (browserNames); ++i)
+            cmdLines.add (String (browserNames[i]) + " " + cmdString.trim().quoted());
+
+        cmdString = cmdLines.joinIntoString (" || ");
+    }
+
+    const char* const argv[4] = { "/bin/sh", "-c", cmdString.toUTF8(), 0 };
+
+    const int cpid = fork();
+
+    if (cpid == 0)
+    {
+        setsid();
+
+        // Child process
+        execve (argv[0], (char**) argv, environ);
+        exit (0);
+    }
+
+    return cpid >= 0;
+}
+
+void File::revealToUser() const
+{
+    if (isDirectory())
+        startAsProcess();
+    else if (getParentDirectory().exists())
+        getParentDirectory().startAsProcess();
+}
diff --git a/JuceLibraryCode/modules/juce_core/native/juce_haiku_SystemStats.cpp b/JuceLibraryCode/modules/juce_core/native/juce_haiku_SystemStats.cpp
new file mode 100644
index 0000000..f6acd11
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_core/native/juce_haiku_SystemStats.cpp
@@ -0,0 +1,142 @@
+/*
+  ==============================================================================
+
+   This file is part of the juce_core module of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission to use, copy, modify, and/or distribute this software for any purpose with
+   or without fee is hereby granted, provided that the above copyright notice and this
+   permission notice appear in all copies.
+
+   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
+   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
+   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ------------------------------------------------------------------------------
+
+   NOTE! This permissive ISC license applies ONLY to files within the juce_core module!
+   All other JUCE modules are covered by a dual GPL/commercial license, so if you are
+   using any other modules, be sure to check that you also comply with their license.
+
+   For more details, visit www.juce.com
+
+  ==============================================================================
+*/
+
+void Logger::outputDebugString (const String& text)
+{
+    std::cerr << text << std::endl;
+}
+
+//==============================================================================
+SystemStats::OperatingSystemType SystemStats::getOperatingSystemType()
+{
+    return Haiku;
+}
+
+String SystemStats::getOperatingSystemName()
+{
+    return "Haiku";
+}
+
+bool SystemStats::isOperatingSystem64Bit()
+{
+   #if JUCE_64BIT
+    return true;
+   #else
+    //xxx not sure how to find this out?..
+    return false;
+   #endif
+}
+
+int SystemStats::getMemorySizeInMegabytes()
+{
+    // TODO
+    return 0;
+}
+
+int SystemStats::getPageSize()
+{
+    return (int) sysconf (_SC_PAGESIZE);
+}
+
+//==============================================================================
+String SystemStats::getLogonName()
+{
+    if (const char* user = getenv ("USER"))
+        return CharPointer_UTF8 (user);
+
+    if (struct passwd* const pw = getpwuid (getuid()))
+        return CharPointer_UTF8 (pw->pw_name);
+
+    return String();
+}
+
+String SystemStats::getFullUserName()
+{
+    return getLogonName();
+}
+
+String SystemStats::getComputerName()
+{
+    char name [256] = { 0 };
+    if (gethostname (name, sizeof (name) - 1) == 0)
+        return name;
+
+    return String();
+}
+
+String SystemStats::getUserLanguage()    { return "en"; }
+String SystemStats::getUserRegion()      { return "US"; }
+String SystemStats::getDisplayLanguage() { return "en_US"; }
+
+//==============================================================================
+void CPUInformation::initialise() noexcept
+{
+    // TODO
+    /*hasMMX   = flags.contains ("mmx");
+    hasSSE   = flags.contains ("sse");
+    hasSSE2  = flags.contains ("sse2");
+    hasSSE3  = flags.contains ("sse3");
+    has3DNow = flags.contains ("3dnow");
+    hasSSSE3 = flags.contains ("ssse3");
+    hasAVX   = flags.contains ("avx");
+
+    numCpus = LinuxStatsHelpers::getCpuInfo ("processor").getIntValue() + 1; */
+}
+
+
+uint32 juce_millisecondsSinceStartup() noexcept
+{
+    timespec t;
+    clock_gettime (CLOCK_MONOTONIC, &t);
+
+    return t.tv_sec * 1000 + t.tv_nsec / 1000000;
+}
+
+int64 Time::getHighResolutionTicks() noexcept
+{
+    timespec t;
+    clock_gettime (CLOCK_MONOTONIC, &t);
+
+    return (t.tv_sec * (int64) 1000000) + (t.tv_nsec / 1000);
+}
+
+int64 Time::getHighResolutionTicksPerSecond() noexcept
+{
+    return 1000000;  // (microseconds)
+}
+
+double Time::getMillisecondCounterHiRes() noexcept
+{
+    return getHighResolutionTicks() * 0.001;
+}
+
+bool Time::setSystemTimeToThisTime() const
+{
+    jassertfalse;
+    return false;
+}
diff --git a/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h b/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h
index b6fff48..0bfab03 100644
--- a/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h
+++ b/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h
@@ -209,6 +209,7 @@ namespace
                  && JUCE_STAT (fileName.toUTF8(), &info) == 0;
     }
 
+#ifndef __HAIKU__
     // if this file doesn't exist, find a parent of it that does..
     bool juce_doStatFS (File f, struct statfs& result)
     {
@@ -222,6 +223,7 @@ namespace
 
         return statfs (f.getFullPathName().toUTF8(), &result) == 0;
     }
+#endif
 
    #if (JUCE_MAC && MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5) || JUCE_IOS
     static int64 getCreationTime (const juce_statStruct& s) noexcept     { return (int64) s.st_birthtime; }
@@ -353,11 +355,19 @@ bool File::setFileTimesInternal (int64 modificationTime, int64 accessTime, int64
 
     if ((modificationTime != 0 || accessTime != 0) && juce_stat (fullPath, info))
     {
+#ifdef __HAIKU__
+        struct timespec times[2];
+        times[0].tv_sec  = accessTime != 0       ? (time_t) (accessTime / 1000)       : info.st_atime;
+        times[1].tv_sec = modificationTime != 0 ? (time_t) (modificationTime / 1000) : info.st_mtime;
+
+        return utimensat (AT_FDCWD, fullPath.toUTF8(), times, 0) == 0;
+#else
         struct utimbuf times;
         times.actime  = accessTime != 0       ? (time_t) (accessTime / 1000)       : info.st_atime;
         times.modtime = modificationTime != 0 ? (time_t) (modificationTime / 1000) : info.st_mtime;
 
         return utime (fullPath.toUTF8(), &times) == 0;
+#endif
     }
 
     return false;
@@ -559,7 +569,11 @@ void MemoryMappedFile::openInternal (const File& file, AccessMode mode)
         if (m != MAP_FAILED)
         {
             address = m;
+#ifdef __HAIKU__
+            posix_madvise (m, (size_t) range.getLength(), POSIX_MADV_SEQUENTIAL);
+#else
             madvise (m, (size_t) range.getLength(), MADV_SEQUENTIAL);
+#endif
         }
         else
         {
@@ -608,19 +622,21 @@ File juce_getExecutableFile()
 //==============================================================================
 int64 File::getBytesFreeOnVolume() const
 {
+#ifndef __HAIKU__
     struct statfs buf;
     if (juce_doStatFS (*this, buf))
         return (int64) buf.f_bsize * (int64) buf.f_bavail; // Note: this returns space available to non-super user
-
+#endif
     return 0;
 }
 
 int64 File::getVolumeTotalSize() const
 {
+#ifndef __HAIKU__
     struct statfs buf;
     if (juce_doStatFS (*this, buf))
         return (int64) buf.f_bsize * (int64) buf.f_blocks;
-
+#endif
     return 0;
 }
 
diff --git a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp
index 65bb117..383ade9 100644
--- a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp
+++ b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp
@@ -100,7 +100,7 @@ String SystemStats::getStackBacktrace()
 {
     String result;
 
-   #if JUCE_ANDROID || JUCE_MINGW
+   #if JUCE_ANDROID || JUCE_MINGW || JUCE_HAIKU
     jassertfalse; // sorry, not implemented yet!
 
    #elif JUCE_WINDOWS
diff --git a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h
index 540bf73..e246b6c 100644
--- a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h
+++ b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h
@@ -56,6 +56,7 @@ public:
         Linux           = 0x0400,
         Android         = 0x0800,
         iOS             = 0x1000,
+        Haiku           = 0x2000,
 
         MacOSX_10_4     = MacOSX | 4,
         MacOSX_10_5     = MacOSX | 5,
diff --git a/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h b/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h
index 75e363f..f69f96a 100644
--- a/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h
+++ b/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h
@@ -66,6 +66,8 @@
   #endif
 #elif defined (__FreeBSD__)
   #define       JUCE_BSD 1
+#elif defined (__HAIKU__)
+  #define       JUCE_HAIKU 1
 #else
   #error "Unknown platform!"
 #endif
@@ -140,7 +142,7 @@
 #endif
 
 //==============================================================================
-#if JUCE_LINUX || JUCE_ANDROID
+#if JUCE_LINUX || JUCE_ANDROID || JUCE_HAIKU
 
   #ifdef _DEBUG
     #define JUCE_DEBUG 1
diff --git a/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp b/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp
index bd14b66..dfee386 100644
--- a/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp
+++ b/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp
@@ -82,7 +82,7 @@ File PropertiesFile::Options::getDefaultFile() const
     if (folderName.isNotEmpty())
         dir = dir.getChildFile (folderName);
 
-   #elif JUCE_LINUX || JUCE_ANDROID
+   #elif JUCE_LINUX || JUCE_ANDROID || JUCE_HAIKU
     const File dir (File (commonToAllUsers ? "/var" : "~")
                      .getChildFile (folderName.isNotEmpty() ? folderName
                                                             : ("." + applicationName)));
diff --git a/JuceLibraryCode/modules/juce_events/juce_events.cpp b/JuceLibraryCode/modules/juce_events/juce_events.cpp
index 53069c4..04a7e1c 100644
--- a/JuceLibraryCode/modules/juce_events/juce_events.cpp
+++ b/JuceLibraryCode/modules/juce_events/juce_events.cpp
@@ -98,6 +98,9 @@ namespace juce
  #include "../juce_core/native/juce_android_JNIHelpers.h"
  #include "native/juce_android_Messaging.cpp"
 
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Messaging.cpp"
+
 #endif
 
 }
diff --git a/JuceLibraryCode/modules/juce_events/native/juce_haiku_Messaging.cpp b/JuceLibraryCode/modules/juce_events/native/juce_haiku_Messaging.cpp
new file mode 100644
index 0000000..075b84b
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_events/native/juce_haiku_Messaging.cpp
@@ -0,0 +1,56 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+#if JUCE_DEBUG && ! defined (JUCE_DEBUG_XERRORS)
+ #define JUCE_DEBUG_XERRORS 1
+#endif
+
+//==============================================================================
+void MessageManager::doPlatformSpecificInitialisation()
+{
+    // TODO
+}
+
+void MessageManager::doPlatformSpecificShutdown()
+{
+	// TODO
+}
+
+bool MessageManager::postMessageToSystemQueue (MessageManager::MessageBase* const message)
+{
+    // TODO
+    return true;
+}
+
+void MessageManager::broadcastMessage (const String& /* value */)
+{
+    /* TODO */
+}
+
+// this function expects that it will NEVER be called simultaneously for two concurrent threads
+bool MessageManager::dispatchNextMessageOnSystemQueue (bool returnIfNoPendingMessages)
+{
+    // TODO
+    return false;
+}
diff --git a/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp b/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp
index 4299852..d45ba9c 100644
--- a/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp
+++ b/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp
@@ -133,7 +133,7 @@ int NativeImageType::getTypeID() const
     return 1;
 }
 
-#if JUCE_WINDOWS || JUCE_LINUX
+#if JUCE_WINDOWS || JUCE_LINUX || JUCE_HAIKU
 ImagePixelData::Ptr NativeImageType::create (Image::PixelFormat format, int width, int height, bool clearImage) const
 {
     return new SoftwarePixelData (format, width, height, clearImage);
diff --git a/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp b/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp
index 2d5a096..c795793 100644
--- a/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp
+++ b/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp
@@ -73,6 +73,11 @@
  #ifndef JUCE_USE_FREETYPE
   #define JUCE_USE_FREETYPE 1
  #endif
+
+#elif JUCE_HAIKU
+ #ifndef JUCE_USE_FREETYPE
+  #define JUCE_USE_FREETYPE 1
+ #endif
 #endif
 
 #if JUCE_USE_FREETYPE
@@ -153,6 +158,9 @@ namespace juce
  #include "native/juce_android_GraphicsContext.cpp"
  #include "native/juce_android_Fonts.cpp"
 
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Fonts.cpp"
+
 #endif
 }
 
diff --git a/JuceLibraryCode/modules/juce_graphics/native/juce_haiku_Fonts.cpp b/JuceLibraryCode/modules/juce_graphics/native/juce_haiku_Fonts.cpp
new file mode 100644
index 0000000..39dd384
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_graphics/native/juce_haiku_Fonts.cpp
@@ -0,0 +1,180 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+StringArray FTTypefaceList::getDefaultFontDirectories()
+{
+    StringArray fontDirs;
+
+    fontDirs.addTokens (String (CharPointer_UTF8 (getenv ("JUCE_FONT_PATH"))), ";,", "");
+    fontDirs.removeEmptyStrings (true);
+
+    if (fontDirs.size() == 0)
+    {
+        const ScopedPointer<XmlElement> fontsInfo (XmlDocument::parse (File ("/etc/fonts/fonts.conf")));
+
+        if (fontsInfo != nullptr)
+        {
+            forEachXmlChildElementWithTagName (*fontsInfo, e, "dir")
+            {
+                String fontPath (e->getAllSubText().trim());
+
+                if (fontPath.isNotEmpty())
+                {
+                    if (e->getStringAttribute ("prefix") == "xdg")
+                    {
+                        String xdgDataHome (SystemStats::getEnvironmentVariable ("XDG_DATA_HOME", String()));
+
+                        if (xdgDataHome.trimStart().isEmpty())
+                            xdgDataHome = "~/.local/share";
+
+                        fontPath = File (xdgDataHome).getChildFile (fontPath).getFullPathName();
+                    }
+
+                    fontDirs.add (fontPath);
+                }
+            }
+        }
+    }
+
+    if (fontDirs.size() == 0)
+        fontDirs.add ("/usr/X11R6/lib/X11/fonts");
+
+    fontDirs.removeDuplicates (false);
+    return fontDirs;
+}
+
+Typeface::Ptr Typeface::createSystemTypefaceFor (const Font& font)
+{
+    return new FreeTypeTypeface (font);
+}
+
+Typeface::Ptr Typeface::createSystemTypefaceFor (const void* data, size_t dataSize)
+{
+    return new FreeTypeTypeface (data, dataSize);
+}
+
+void Typeface::scanFolderForFonts (const File& folder)
+{
+    FTTypefaceList::getInstance()->scanFontPaths (StringArray (folder.getFullPathName()));
+}
+
+StringArray Font::findAllTypefaceNames()
+{
+    return FTTypefaceList::getInstance()->findAllFamilyNames();
+}
+
+StringArray Font::findAllTypefaceStyles (const String& family)
+{
+    return FTTypefaceList::getInstance()->findAllTypefaceStyles (family);
+}
+
+bool TextLayout::createNativeLayout (const AttributedString&)
+{
+    return false;
+}
+
+//==============================================================================
+struct DefaultFontNames
+{
+    DefaultFontNames()
+        : defaultSans  (getDefaultSansSerifFontName()),
+          defaultSerif (getDefaultSerifFontName()),
+          defaultFixed (getDefaultMonospacedFontName())
+    {
+    }
+
+    String getRealFontName (const String& faceName) const
+    {
+        if (faceName == Font::getDefaultSansSerifFontName())    return defaultSans;
+        if (faceName == Font::getDefaultSerifFontName())        return defaultSerif;
+        if (faceName == Font::getDefaultMonospacedFontName())   return defaultFixed;
+
+        return faceName;
+    }
+
+    String defaultSans, defaultSerif, defaultFixed;
+
+private:
+    static String pickBestFont (const StringArray& names, const char* const* choicesArray)
+    {
+        const StringArray choices (choicesArray);
+
+        for (int j = 0; j < choices.size(); ++j)
+            if (names.contains (choices[j], true))
+                return choices[j];
+
+        for (int j = 0; j < choices.size(); ++j)
+            for (int i = 0; i < names.size(); ++i)
+                if (names[i].startsWithIgnoreCase (choices[j]))
+                    return names[i];
+
+        for (int j = 0; j < choices.size(); ++j)
+            for (int i = 0; i < names.size(); ++i)
+                if (names[i].containsIgnoreCase (choices[j]))
+                    return names[i];
+
+        return names[0];
+    }
+
+    static String getDefaultSansSerifFontName()
+    {
+        StringArray allFonts;
+        FTTypefaceList::getInstance()->getSansSerifNames (allFonts);
+
+        static const char* targets[] = { "Verdana", "Bitstream Vera Sans", "Luxi Sans",
+                                         "Liberation Sans", "DejaVu Sans", "Sans", nullptr };
+        return pickBestFont (allFonts, targets);
+    }
+
+    static String getDefaultSerifFontName()
+    {
+        StringArray allFonts;
+        FTTypefaceList::getInstance()->getSerifNames (allFonts);
+
+        static const char* targets[] = { "Bitstream Vera Serif", "Times", "Nimbus Roman",
+                                         "Liberation Serif", "DejaVu Serif", "Serif", nullptr };
+        return pickBestFont (allFonts, targets);
+    }
+
+    static String getDefaultMonospacedFontName()
+    {
+        StringArray allFonts;
+        FTTypefaceList::getInstance()->getMonospacedNames (allFonts);
+
+        static const char* targets[] = { "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Sans Mono",
+                                         "Liberation Mono", "Courier", "DejaVu Mono", "Mono", nullptr };
+        return pickBestFont (allFonts, targets);
+    }
+
+    JUCE_DECLARE_NON_COPYABLE (DefaultFontNames)
+};
+
+Typeface::Ptr Font::getDefaultTypefaceForFont (const Font& font)
+{
+    static DefaultFontNames defaultNames;
+
+    Font f (font);
+    f.setTypefaceName (defaultNames.getRealFontName (font.getTypefaceName()));
+    return Typeface::createSystemTypefaceFor (f);
+}
diff --git a/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp b/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp
index 00eea12..bc697e7 100644
--- a/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp
+++ b/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp
@@ -297,6 +297,11 @@ extern bool juce_areThereAnyAlwaysOnTopWindows();
  #include "native/juce_android_Windowing.cpp"
  #include "native/juce_android_FileChooser.cpp"
 
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Clipboard.cpp"
+ #include "native/juce_haiku_Windowing.cpp"
+ #include "native/juce_haiku_FileChooser.cpp"
+
 #endif
 
 }
diff --git a/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Clipboard.cpp b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Clipboard.cpp
new file mode 100644
index 0000000..be683df
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Clipboard.cpp
@@ -0,0 +1,38 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+//==============================================================================
+void SystemClipboard::copyTextToClipboard (const String& clipText)
+{
+    // TODO
+}
+
+String SystemClipboard::getTextFromClipboard()
+{
+    String content;
+
+    // TODO
+
+    return content;
+}
diff --git a/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_FileChooser.cpp b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_FileChooser.cpp
new file mode 100644
index 0000000..351020c
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_FileChooser.cpp
@@ -0,0 +1,48 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+bool FileChooser::isPlatformDialogAvailable()
+{
+   #if JUCE_DISABLE_NATIVE_FILECHOOSERS
+    return false;
+   #else
+    return true;
+   #endif
+}
+
+void FileChooser::showPlatformDialog (Array<File>& results,
+                                      const String& title, const File& file, const String& filters,
+                                      bool isDirectory, bool /* selectsFiles */,
+                                      bool isSave, bool /* warnAboutOverwritingExistingFiles */,
+                                      bool selectMultipleFiles, FilePreviewComponent*)
+{
+    const File previousWorkingDirectory (File::getCurrentWorkingDirectory());
+
+    StringArray args;
+    String separator;
+    
+    // TODO
+
+    previousWorkingDirectory.setAsCurrentWorkingDirectory();
+}
diff --git a/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Windowing.cpp b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Windowing.cpp
new file mode 100644
index 0000000..b5c0a4d
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Windowing.cpp
@@ -0,0 +1,544 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+
+
+//==============================================================================
+static int numAlwaysOnTopPeers = 0;
+
+bool juce_areThereAnyAlwaysOnTopWindows()
+{
+    return numAlwaysOnTopPeers > 0;
+}
+
+//==============================================================================
+class HaikuComponentPeer  : public ComponentPeer
+{
+public:
+    HaikuComponentPeer (Component& comp, const int windowStyleFlags)
+        : ComponentPeer (comp, windowStyleFlags),
+          fullScreen (false), mapped (false),
+          depth (0),
+          isAlwaysOnTop (comp.isAlwaysOnTop()),
+          currentScaleFactor (1.0)
+    {
+        // it's dangerous to create a window on a thread other than the message thread..
+        jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());
+
+        if (isAlwaysOnTop)
+            ++numAlwaysOnTopPeers;
+
+        
+        setTitle (component.getName());
+    }
+
+    ~HaikuComponentPeer()
+    {
+        // it's dangerous to delete a window on a thread other than the message thread..
+        jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());
+
+        if (isAlwaysOnTop)
+            --numAlwaysOnTopPeers;
+    }
+
+    //==============================================================================
+    void* getNativeHandle() const override
+    {
+        return (void*) NULL;
+    }
+
+
+    void setVisible (bool shouldBeVisible) override
+    {
+        // TODO
+    }
+
+    void setTitle (const String& title) override
+    {
+        // TODO
+    }
+
+    void setBounds (const Rectangle<int>& newBounds, bool isNowFullScreen) override
+    {
+        if (fullScreen && ! isNowFullScreen)
+        {
+        	// TODO
+        }
+
+        fullScreen = isNowFullScreen;
+
+        // TODO
+    }
+
+    Rectangle<int> getBounds() const override          { return bounds; }
+
+    Point<float> localToGlobal (Point<float> relativePosition) override
+    {
+        return relativePosition + bounds.getPosition().toFloat();
+    }
+
+    Point<float> globalToLocal (Point<float> screenPosition) override
+    {
+        return screenPosition - bounds.getPosition().toFloat();
+    }
+
+    void setAlpha (float /* newAlpha */) override
+    {
+        //xxx todo!
+    }
+
+    StringArray getAvailableRenderingEngines() override
+    {
+        return StringArray ("Software Renderer");
+    }
+
+    void setMinimised (bool shouldBeMinimised) override
+    {
+        if (shouldBeMinimised)
+        {
+            // TODO
+        }
+        else
+        {
+            setVisible (true);
+        }
+    }
+
+    bool isMinimised() const override
+    {
+    	// TODO
+        return false;
+    }
+
+    void setFullScreen (const bool shouldBeFullScreen) override
+    {
+        Rectangle<int> r (lastNonFullscreenBounds); // (get a copy of this before de-minimising)
+
+        setMinimised (false);
+
+        if (fullScreen != shouldBeFullScreen)
+        {
+            // TODO
+            component.repaint();
+        }
+    }
+
+    bool isFullScreen() const override
+    {
+        return fullScreen;
+    }
+
+    bool isFrontWindow() const
+    {
+    	// TODO
+        return false;
+    }
+
+    bool contains (Point<int> localPos, bool trueIfInAChildWindow) const override
+    {
+        // TODO
+		return false;
+    }
+
+    BorderSize<int> getFrameSize() const override
+    {
+        return BorderSize<int>();
+    }
+
+    bool setAlwaysOnTop (bool /* alwaysOnTop */) override
+    {
+        return false;
+    }
+
+    void toFront (bool makeActive) override
+    {
+        if (makeActive)
+        {
+            setVisible (true);
+        }
+        // TODO
+        handleBroughtToFront();
+    }
+
+    void toBehind (ComponentPeer* other) override
+    {
+        if (HaikuComponentPeer* const otherPeer = dynamic_cast<HaikuComponentPeer*> (other))
+        {
+            setMinimised (false);
+			// TODO
+        }
+        else
+            jassertfalse; // wrong type of window?
+    }
+
+    bool isFocused() const override
+    {
+		return true;
+    }
+
+    void grabFocus() override
+    {
+    }
+
+    void textInputRequired (Point<int>, TextInputTarget&) override {}
+
+	void repaint (const Rectangle<int>& area) override
+    {
+        // TODO
+    }
+
+    void performAnyPendingRepaintsNow() override
+    {
+        // TODO
+    }
+
+    void setIcon (const Image& newIcon) override
+    {
+    	// TODO
+    }
+    
+    //==============================================================================
+    double getCurrentScale() noexcept
+    {
+        return currentScaleFactor;
+    }
+
+
+    //==============================================================================
+    bool dontRepaint;
+
+	static ModifierKeys currentModifiers;
+    static bool isActiveApplication;
+
+private:
+
+    Rectangle<int> bounds;
+    Image taskbarImage;
+    bool fullScreen, mapped;
+    int depth;
+    BorderSize<int> windowBorder;
+    bool isAlwaysOnTop;
+    double currentScaleFactor;
+    enum { KeyPressEventType = 2 };
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HaikuComponentPeer)
+};
+
+ModifierKeys HaikuComponentPeer::currentModifiers;
+bool HaikuComponentPeer::isActiveApplication = false;
+
+//==============================================================================
+JUCE_API bool JUCE_CALLTYPE Process::isForegroundProcess()
+{
+    return HaikuComponentPeer::isActiveApplication;
+}
+
+JUCE_API void JUCE_CALLTYPE Process::makeForegroundProcess() {}
+JUCE_API void JUCE_CALLTYPE Process::hide() {}
+
+//==============================================================================
+bool KeyPress::isKeyCurrentlyDown (const int keyCode)
+{
+    // TODO
+    return false;
+}
+
+void ModifierKeys::updateCurrentModifiers() noexcept
+{
+    currentModifiers = HaikuComponentPeer::currentModifiers;
+}
+
+ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
+{
+	// TODO
+    return HaikuComponentPeer::currentModifiers;
+}
+
+
+//==============================================================================
+void Desktop::setKioskComponent (Component* comp, bool enableOrDisable, bool /* allowMenusAndBars */)
+{
+    if (enableOrDisable)
+        comp->setBounds (getDisplays().getMainDisplay().totalArea);
+}
+
+//==============================================================================
+ComponentPeer* Component::createNewPeer (int styleFlags, void* nativeWindowToAttachTo)
+{
+    return new HaikuComponentPeer (*this, styleFlags);
+}
+
+//==============================================================================
+void Desktop::Displays::findDisplays (float masterScale)
+{
+}
+
+//==============================================================================
+bool MouseInputSource::SourceList::addSource()
+{
+    if (sources.size() == 0)
+    {
+        addSource (0, true);
+        return true;
+    }
+
+    return false;
+}
+
+bool Desktop::canUseSemiTransparentWindows() noexcept
+{
+    return false;
+}
+
+Point<float> MouseInputSource::getCurrentRawMousePosition()
+{
+    // TODO
+    return Point<float>();
+}
+
+void MouseInputSource::setRawMousePosition (Point<float> newPosition)
+{
+		// TODO
+}
+
+double Desktop::getDefaultMasterScale()
+{
+    return 1.0;
+}
+
+Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
+{
+    return upright;
+}
+
+//==============================================================================
+static bool screenSaverAllowed = true;
+
+void Desktop::setScreenSaverEnabled (const bool isEnabled)
+{
+    if (screenSaverAllowed != isEnabled)
+    {
+        screenSaverAllowed = isEnabled;
+
+        // TODO
+    }
+}
+
+bool Desktop::isScreenSaverEnabled()
+{
+    return screenSaverAllowed;
+}
+
+//==============================================================================
+void* CustomMouseCursorInfo::create() const
+{
+    // TODO
+    return NULL;
+}
+
+void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool)
+{
+    if (cursorHandle != nullptr)
+    {
+    }
+}
+
+void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)
+{
+    // TODO
+    return NULL;
+}
+
+void MouseCursor::showInWindow (ComponentPeer* peer) const
+{
+    if (HaikuComponentPeer* const lp = dynamic_cast<HaikuComponentPeer*> (peer))
+    {
+    	// TODO
+    }
+}
+
+void MouseCursor::showInAllWindows() const
+{
+    for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
+        showInWindow (ComponentPeer::getPeer (i));
+}
+
+//==============================================================================
+Image juce_createIconForFile (const File& /* file */)
+{
+    return Image::null;
+}
+
+//==============================================================================
+bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMoveFiles)
+{
+    if (files.size() == 0)
+        return false;
+
+    if (MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource(0))
+        if (Component* sourceComp = draggingSource->getComponentUnderMouse())
+            if (HaikuComponentPeer* const lp = dynamic_cast<HaikuComponentPeer*> (sourceComp->getPeer())) {
+                // TODO
+                return false;
+            }
+
+    // This method must be called in response to a component's mouseDown or mouseDrag event!
+    jassertfalse;
+    return false;
+}
+
+bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
+{
+    if (text.isEmpty())
+        return false;
+
+    if (MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource(0))
+        if (Component* sourceComp = draggingSource->getComponentUnderMouse())
+            if (HaikuComponentPeer* const lp = dynamic_cast<HaikuComponentPeer*> (sourceComp->getPeer())) {
+            	// TODO
+                return false; 
+            }
+
+    // This method must be called in response to a component's mouseDown or mouseDrag event!
+    jassertfalse;
+    return false;
+}
+
+//==============================================================================
+void LookAndFeel::playAlertSound()
+{
+    std::cout << "\a" << std::flush;
+}
+//==============================================================================
+Rectangle<int> juce_HaikuScaledToPhysicalBounds(ComponentPeer* peer, const Rectangle<int>& bounds)
+{
+    Rectangle<int> retval = bounds;
+
+    if (HaikuComponentPeer* haikuPeer = dynamic_cast<HaikuComponentPeer*> (peer))
+        retval *= haikuPeer->getCurrentScale();
+
+    return retval;
+}
+
+void juce_HaikuAddRepaintListener (ComponentPeer* peer, Component* dummy)
+{
+}
+
+void juce_HaikuRemoveRepaintListener (ComponentPeer* peer, Component* dummy)
+{
+}
+
+//==============================================================================
+#if JUCE_MODAL_LOOPS_PERMITTED
+void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
+                                                     const String& title, const String& message,
+                                                     Component* /* associatedComponent */)
+{
+    AlertWindow::showMessageBox (iconType, title, message);
+}
+#endif
+
+void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
+                                                          const String& title, const String& message,
+                                                          Component* associatedComponent,
+                                                          ModalComponentManager::Callback* callback)
+{
+    AlertWindow::showMessageBoxAsync (iconType, title, message, String::empty, associatedComponent, callback);
+}
+
+bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
+                                                      const String& title, const String& message,
+                                                      Component* associatedComponent,
+                                                      ModalComponentManager::Callback* callback)
+{
+    return AlertWindow::showOkCancelBox (iconType, title, message, String::empty, String::empty,
+                                         associatedComponent, callback);
+}
+
+int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
+                                                        const String& title, const String& message,
+                                                        Component* associatedComponent,
+                                                        ModalComponentManager::Callback* callback)
+{
+    return AlertWindow::showYesNoCancelBox (iconType, title, message,
+                                            String::empty, String::empty, String::empty,
+                                            associatedComponent, callback);
+}
+
+//==============================================================================
+const int extendedKeyModifier       = 0x10000;
+
+const int KeyPress::spaceKey        = ' ';
+const int KeyPress::returnKey       = 66;
+const int KeyPress::escapeKey       = 4;
+const int KeyPress::backspaceKey    = 67;
+const int KeyPress::leftKey         = extendedKeyModifier + 1;
+const int KeyPress::rightKey        = extendedKeyModifier + 2;
+const int KeyPress::upKey           = extendedKeyModifier + 3;
+const int KeyPress::downKey         = extendedKeyModifier + 4;
+const int KeyPress::pageUpKey       = extendedKeyModifier + 5;
+const int KeyPress::pageDownKey     = extendedKeyModifier + 6;
+const int KeyPress::endKey          = extendedKeyModifier + 7;
+const int KeyPress::homeKey         = extendedKeyModifier + 8;
+const int KeyPress::deleteKey       = extendedKeyModifier + 9;
+const int KeyPress::insertKey       = -1;
+const int KeyPress::tabKey          = 61;
+const int KeyPress::F1Key           = extendedKeyModifier + 10;
+const int KeyPress::F2Key           = extendedKeyModifier + 11;
+const int KeyPress::F3Key           = extendedKeyModifier + 12;
+const int KeyPress::F4Key           = extendedKeyModifier + 13;
+const int KeyPress::F5Key           = extendedKeyModifier + 14;
+const int KeyPress::F6Key           = extendedKeyModifier + 16;
+const int KeyPress::F7Key           = extendedKeyModifier + 17;
+const int KeyPress::F8Key           = extendedKeyModifier + 18;
+const int KeyPress::F9Key           = extendedKeyModifier + 19;
+const int KeyPress::F10Key          = extendedKeyModifier + 20;
+const int KeyPress::F11Key          = extendedKeyModifier + 21;
+const int KeyPress::F12Key          = extendedKeyModifier + 22;
+const int KeyPress::F13Key          = extendedKeyModifier + 23;
+const int KeyPress::F14Key          = extendedKeyModifier + 24;
+const int KeyPress::F15Key          = extendedKeyModifier + 25;
+const int KeyPress::F16Key          = extendedKeyModifier + 26;
+const int KeyPress::numberPad0      = extendedKeyModifier + 27;
+const int KeyPress::numberPad1      = extendedKeyModifier + 28;
+const int KeyPress::numberPad2      = extendedKeyModifier + 29;
+const int KeyPress::numberPad3      = extendedKeyModifier + 30;
+const int KeyPress::numberPad4      = extendedKeyModifier + 31;
+const int KeyPress::numberPad5      = extendedKeyModifier + 32;
+const int KeyPress::numberPad6      = extendedKeyModifier + 33;
+const int KeyPress::numberPad7      = extendedKeyModifier + 34;
+const int KeyPress::numberPad8      = extendedKeyModifier + 35;
+const int KeyPress::numberPad9      = extendedKeyModifier + 36;
+const int KeyPress::numberPadAdd            = extendedKeyModifier + 37;
+const int KeyPress::numberPadSubtract       = extendedKeyModifier + 38;
+const int KeyPress::numberPadMultiply       = extendedKeyModifier + 39;
+const int KeyPress::numberPadDivide         = extendedKeyModifier + 40;
+const int KeyPress::numberPadSeparator      = extendedKeyModifier + 41;
+const int KeyPress::numberPadDecimalPoint   = extendedKeyModifier + 42;
+const int KeyPress::numberPadEquals         = extendedKeyModifier + 43;
+const int KeyPress::numberPadDelete         = extendedKeyModifier + 44;
+const int KeyPress::playKey         = extendedKeyModifier + 45;
+const int KeyPress::stopKey         = extendedKeyModifier + 46;
+const int KeyPress::fastForwardKey  = extendedKeyModifier + 47;
+const int KeyPress::rewindKey       = extendedKeyModifier + 48;
-- 
2.10.2

