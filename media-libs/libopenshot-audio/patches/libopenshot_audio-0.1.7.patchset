From 7be5a99aed08e2008d4a8568c5c7f874206985a0 Mon Sep 17 00:00:00 2001
From: Leorize <alaviss@users.noreply.github.com>
Date: Tue, 28 Aug 2018 16:43:43 +0700
Subject: cmake: uses GNUInstallDirs

This allows customizing various installation folders.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e0e2433..8ea6d2f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,28 +6,29 @@
 #
 # Copyright (c) 2008-2016 OpenShot Studios, LLC
 # <http://www.openshotstudios.com/>. This file is part of
-# OpenShot Audio Library (libopenshot-audio), an open-source project dedicated 
-# to delivering high quality audio editing and playback solutions to the 
+# OpenShot Audio Library (libopenshot-audio), an open-source project dedicated
+# to delivering high quality audio editing and playback solutions to the
 # world. For more information visit <http://www.openshot.org/>.
 #
-# OpenShot Audio Library (libopenshot-audio) is free software: you can 
-# redistribute it and/or modify it under the terms of the GNU General Public 
+# OpenShot Audio Library (libopenshot-audio) is free software: you can
+# redistribute it and/or modify it under the terms of the GNU General Public
 # License as published by the Free Software Foundation, either version 3 of the
 # License, or (at your option) any later version.
 #
 # OpenShot Audio Library (libopenshot-audio) is distributed in the hope that it
-# will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
-# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General 
+# will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 # Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with OpenShot Audio Library. If not, see <http://www.gnu.org/licenses/>.
 ################################################################################
 
-cmake_minimum_required(VERSION 2.8)
+cmake_minimum_required(VERSION 2.8.5)
 
 ################ ADD CMAKE MODULES ##################
 set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/Modules")
+include(GNUInstallDirs)
 
 ################ GET VERSION INFORMATION FROM VERSION.H ##################
 MESSAGE("--------------------------------------------------------------")
@@ -89,7 +90,7 @@ IF (WIN32)
 		MESSAGE("AISO_SDK_DIR NOT FOUND")
 		ADD_DEFINITIONS(-DJUCE_ASIO=0)
 	ENDIF (AISO_SDK_DIR)
-    
+
 	ADD_DEFINITIONS(-DDONT_AUTOLINK_TO_JUCE_LIBRARY)
 	SET(CMAKE_CXX_FLAGS " ${CMAKE_CXX_FLAGS} -std=c++0x")
 
@@ -118,16 +119,16 @@ ELSE (WIN32)
             SET_PROPERTY(GLOBAL PROPERTY JUCE_MAC "JUCE_MAC")
             ADD_DEFINITIONS(-DNDEBUG)
             SET(EXTENSION "mm")
-            
+
             SET(JUCE_PLATFORM_SPECIFIC_DIR build/macosx/platform_specific_code)
             SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES "-framework Carbon -framework Cocoa -framework CoreFoundation -framework CoreAudio -framework CoreMidi -framework IOKit -framework AGL -framework AudioToolbox -framework QuartzCore -lobjc -framework Accelerate")
-		
+
             SET(CMAKE_CXX_FLAGS " ${CMAKE_CXX_FLAGS} -flax-vector-conversions -std=c++0x")
-		
+
         ELSE (APPLE)
 			SET_PROPERTY(GLOBAL PROPERTY JUCE_LINUX "JUCE_LINUX")
             SET(EXTENSION "cpp")
-            
+
 			FIND_PACKAGE(X11 REQUIRED)
 			INCLUDE_DIRECTORIES(${X11_INCLUDE_DIR})
 			INCLUDE_DIRECTORIES(/usr/include/freetype2)
@@ -166,7 +167,7 @@ set_target_properties(openshot-audio
 			PROPERTIES
 			VERSION ${PROJECT_VERSION}
 			SOVERSION ${SO_VERSION}
-			INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/lib")
+			INSTALL_NAME_DIR ${CMAKE_INSTALL_LIBDIR})
 
 set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
 find_package(Threads REQUIRED)
@@ -179,13 +180,10 @@ TARGET_LINK_LIBRARIES(openshot-audio
 # PROCESS SUB-DIRECTORIES
 add_subdirectory(src)
 
-# Determine correct lib folder
-set(LIB_INSTALL_DIR lib${LIB_SUFFIX}) 
-
 # Install Files
-INSTALL(FILES ${CMAKE_CURRENT_SOURCE_DIR}/JuceLibraryCode/JuceHeader.h DESTINATION include/libopenshot-audio)
-INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/JuceLibraryCode DESTINATION include/libopenshot-audio FILES_MATCHING PATTERN "*.h")
-INSTALL(TARGETS openshot-audio DESTINATION ${LIB_INSTALL_DIR})
+INSTALL(FILES ${CMAKE_CURRENT_SOURCE_DIR}/JuceLibraryCode/JuceHeader.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/libopenshot-audio)
+INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/JuceLibraryCode DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/libopenshot-audio FILES_MATCHING PATTERN "*.h")
+INSTALL(TARGETS openshot-audio DESTINATION ${CMAKE_INSTALL_LIBDIR})
 
 ################### DOCUMENTATION ###################
 # Find Doxygen (used for documentation)
@@ -193,7 +191,7 @@ include(cmake/Modules/UseDoxygen.cmake)
 
 # Install Doxygen html documentation
 file(GLOB_RECURSE doc_files ${CMAKE_CURRENT_BINARY_DIR}/doc/html/*.*)
-INSTALL(FILES ${doc_files} DESTINATION share/doc/libopenshot-audio)
+INSTALL(FILES ${doc_files} DESTINATION ${CMAKE_INSTALL_DOCDIR}/libopenshot-audio)
 
 # Install manpage
-INSTALL(FILES ${CMAKE_CURRENT_SOURCE_DIR}/doc/openshot-audio-test-sound.1 DESTINATION share/man/man1)
+INSTALL(FILES ${CMAKE_CURRENT_SOURCE_DIR}/doc/openshot-audio-test-sound.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index a5ee15a..0a9f423 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -30,4 +30,4 @@ add_executable(openshot-audio-test-sound Main.cpp)
 target_link_libraries(openshot-audio-test-sound openshot-audio)
 
 # Install Test Executable
-INSTALL(TARGETS openshot-audio-test-sound DESTINATION bin)
\ No newline at end of file
+INSTALL(TARGETS openshot-audio-test-sound DESTINATION ${CMAKE_INSTALL_BINDIR})
-- 
2.16.4


From 0f75001590c7cd8bb2f968d46fcaa4c188bc8e32 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Thu, 30 Aug 2018 00:22:13 +0700
Subject: Haiku patch


diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8ea6d2f..5c7e5f6 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -126,14 +126,23 @@ ELSE (WIN32)
             SET(CMAKE_CXX_FLAGS " ${CMAKE_CXX_FLAGS} -flax-vector-conversions -std=c++0x")
 
         ELSE (APPLE)
-			SET_PROPERTY(GLOBAL PROPERTY JUCE_LINUX "JUCE_LINUX")
-            SET(EXTENSION "cpp")
-
-			FIND_PACKAGE(X11 REQUIRED)
-			INCLUDE_DIRECTORIES(${X11_INCLUDE_DIR})
-			INCLUDE_DIRECTORIES(/usr/include/freetype2)
-			ADD_DEFINITIONS(-DLINUX)
-			SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES ${X11_LIBRARIES} asound freetype Xinerama)
+			IF   (HAIKU)
+				SET_PROPERTY(GLOBAL PROPERTY JUCE_HAIKU "JUCE_HAIKU")
+				SET(EXTENSION "cpp")
+				FIND_PACKAGE(Freetype REQUIRED)
+				INCLUDE_DIRECTORIES(${FREETYPE_INCLUDE_DIRS})
+				ADD_DEFINITIONS(-DHAIKU)
+				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES curl ${FREETYPE_LIBRARIES})
+			ELSE (HAIKU)
+				SET_PROPERTY(GLOBAL PROPERTY JUCE_LINUX "JUCE_LINUX")
+				SET(EXTENSION "cpp")
+
+				FIND_PACKAGE(X11 REQUIRED)
+				INCLUDE_DIRECTORIES(${X11_INCLUDE_DIR})
+				INCLUDE_DIRECTORIES(/usr/include/freetype2)
+				ADD_DEFINITIONS(-DLINUX)
+				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES ${X11_LIBRARIES} asound freetype Xinerama)
+			ENDIF(HAIKU)
 		ENDIF(APPLE)
 	ENDIF(UNIX)
 ENDIF(WIN32)
diff --git a/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp b/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
index 2bc3c6a..6c1fd00 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
+++ b/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
@@ -215,6 +215,14 @@ namespace juce
   #include "native/juce_android_OpenSL.cpp"
  #endif
 
+//==============================================================================
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Midi.cpp"
+
+ #if JUCE_USE_CDREADER
+  #include "native/juce_linux_AudioCDReader.cpp"
+ #endif
+
 #endif
 
 #if ! JUCE_SYSTEMAUDIOVOL_IMPLEMENTED
diff --git a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h
index 0c5a5b6..807b58e 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h
+++ b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiInput.h
@@ -122,7 +122,7 @@ public:
     static MidiInput* openDevice (int deviceIndex,
                                   MidiInputCallback* callback);
 
-   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || DOXYGEN
+   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || JUCE_HAIKU || DOXYGEN
     /** This will try to create a new midi input device (Not available on Windows).
 
         This will attempt to create a new midi input device with the specified name,
diff --git a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h
index c908263..286673a 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h
+++ b/JuceLibraryCode/modules/juce_audio_devices/midi_io/juce_MidiOutput.h
@@ -67,7 +67,7 @@ public:
     static MidiOutput* openDevice (int deviceIndex);
 
 
-   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || DOXYGEN
+   #if JUCE_LINUX || JUCE_MAC || JUCE_IOS || JUCE_HAIKU || DOXYGEN
     /** This will try to create a new midi output device (Not available on Windows).
 
         This will attempt to create a new midi output device that other apps can connect
diff --git a/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Midi.cpp b/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Midi.cpp
new file mode 100644
index 0000000..f1d2e5b
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Midi.cpp
@@ -0,0 +1,40 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+StringArray MidiOutput::getDevices()                                { return StringArray(); }
+int MidiOutput::getDefaultDeviceIndex()                             { return 0; }
+MidiOutput* MidiOutput::openDevice (int)                            { return nullptr; }
+MidiOutput* MidiOutput::createNewDevice (const String&)             { return nullptr; }
+MidiOutput::~MidiOutput()   {}
+void MidiOutput::sendMessageNow (const MidiMessage&)    {}
+
+MidiInput::MidiInput (const String& nm) : name (nm), internal (nullptr)  {}
+MidiInput::~MidiInput() {}
+void MidiInput::start() {}
+void MidiInput::stop()  {}
+int MidiInput::getDefaultDeviceIndex()      { return 0; }
+StringArray MidiInput::getDevices()         { return StringArray(); }
+MidiInput* MidiInput::openDevice (int, MidiInputCallback*)                  { return nullptr; }
+MidiInput* MidiInput::createNewDevice (const String&, MidiInputCallback*)   { return nullptr; }
+
diff --git a/JuceLibraryCode/modules/juce_core/juce_core.cpp b/JuceLibraryCode/modules/juce_core/juce_core.cpp
index d5ad930..6a3d89b 100644
--- a/JuceLibraryCode/modules/juce_core/juce_core.cpp
+++ b/JuceLibraryCode/modules/juce_core/juce_core.cpp
@@ -97,7 +97,7 @@
  #include <net/if.h>
  #include <sys/ioctl.h>
 
- #if ! JUCE_ANDROID
+ #if ! JUCE_ANDROID && ! JUCE_HAIKU
   #include <execinfo.h>
  #endif
 #endif
@@ -111,6 +111,16 @@
  #include <android/log.h>
 #endif
 
+#if JUCE_HAIKU
+ #include <dirent.h>
+ #include <errno.h>
+ #include <fnmatch.h>
+ #include <sys/sockio.h>
+ #include <sys/mman.h>
+ #include <dlfcn.h>
+ #include <curl/curl.h>
+#endif
+
 //==============================================================================
 #ifndef    JUCE_STANDALONE_APPLICATION
  JUCE_COMPILER_WARNING ("Please re-save your Introjucer project with the latest Introjucer version to avoid this warning")
@@ -229,6 +239,12 @@ namespace juce
 #include "native/juce_android_SystemStats.cpp"
 #include "native/juce_android_Threads.cpp"
 
+//==============================================================================
+#elif JUCE_HAIKU
+#include "native/juce_linux_CommonFile.cpp"
+#include "native/juce_curl_Network.cpp"
+#include "native/juce_haiku_Files.cpp"
+#include "native/juce_haiku_SystemStats.cpp"
 #endif
 
 #include "threads/juce_ChildProcess.cpp"
diff --git a/JuceLibraryCode/modules/juce_core/native/juce_haiku_Files.cpp b/JuceLibraryCode/modules/juce_core/native/juce_haiku_Files.cpp
new file mode 100644
index 0000000..1be608f
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_core/native/juce_haiku_Files.cpp
@@ -0,0 +1,215 @@
+/*
+  ==============================================================================
+
+   This file is part of the juce_core module of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission to use, copy, modify, and/or distribute this software for any purpose with
+   or without fee is hereby granted, provided that the above copyright notice and this
+   permission notice appear in all copies.
+
+   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
+   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
+   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ------------------------------------------------------------------------------
+
+   NOTE! This permissive ISC license applies ONLY to files within the juce_core module!
+   All other JUCE modules are covered by a dual GPL/commercial license, so if you are
+   using any other modules, be sure to check that you also comply with their license.
+
+   For more details, visit www.juce.com
+
+  ==============================================================================
+*/
+
+bool File::isOnCDRomDrive() const
+{
+	return false;
+}
+
+bool File::isOnHardDisk() const
+{
+    return true;
+}
+
+bool File::isOnRemovableDrive() const
+{
+    return false;
+}
+
+String File::getVersion() const
+{
+    return String(); // xxx not yet implemented
+}
+
+//==============================================================================
+static File resolveXDGFolder (const char* const type, const char* const fallbackFolder)
+{
+    StringArray confLines;
+    File ("~/.config/user-dirs.dirs").readLines (confLines);
+
+    for (int i = 0; i < confLines.size(); ++i)
+    {
+        const String line (confLines[i].trimStart());
+
+        if (line.startsWith (type))
+        {
+            // eg. resolve XDG_MUSIC_DIR="$HOME/Music" to /home/user/Music
+            const File f (line.replace ("$HOME", File ("~").getFullPathName())
+                              .fromFirstOccurrenceOf ("=", false, false)
+                              .trim().unquoted());
+
+            if (f.isDirectory())
+                return f;
+        }
+    }
+
+    return File (fallbackFolder);
+}
+
+const char* const* juce_argv = nullptr;
+int juce_argc = 0;
+
+File File::getSpecialLocation (const SpecialLocationType type)
+{
+    switch (type)
+    {
+        case userHomeDirectory:
+        {
+            if (const char* homeDir = getenv ("HOME"))
+                return File (CharPointer_UTF8 (homeDir));
+
+            if (struct passwd* const pw = getpwuid (getuid()))
+                return File (CharPointer_UTF8 (pw->pw_dir));
+
+            return File();
+        }
+
+        case userDocumentsDirectory:          return resolveXDGFolder ("XDG_DOCUMENTS_DIR", "~");
+        case userMusicDirectory:              return resolveXDGFolder ("XDG_MUSIC_DIR",     "~");
+        case userMoviesDirectory:             return resolveXDGFolder ("XDG_VIDEOS_DIR",    "~");
+        case userPicturesDirectory:           return resolveXDGFolder ("XDG_PICTURES_DIR",  "~");
+        case userDesktopDirectory:            return resolveXDGFolder ("XDG_DESKTOP_DIR",   "~/Desktop");
+        case userApplicationDataDirectory:    return resolveXDGFolder ("XDG_CONFIG_HOME",   "~");
+        case commonDocumentsDirectory:
+        case commonApplicationDataDirectory:  return File ("/var");
+        case globalApplicationsDirectory:     return File ("/usr");
+
+        case tempDirectory:
+        {
+            File tmp ("/var/tmp");
+
+            if (! tmp.isDirectory())
+            {
+                tmp = "/tmp";
+
+                if (! tmp.isDirectory())
+                    tmp = File::getCurrentWorkingDirectory();
+            }
+
+            return tmp;
+        }
+
+        case invokedExecutableFile:
+            if (juce_argv != nullptr && juce_argc > 0)
+                return File (CharPointer_UTF8 (juce_argv[0]));
+            // deliberate fall-through...
+
+        case currentExecutableFile:
+        case currentApplicationFile:
+           #if ! JUCE_STANDALONE_APPLICATION
+            return juce_getExecutableFile();
+           #endif
+            // deliberate fall-through if this is not a shared-library
+
+        case hostApplicationPath:
+        {
+            const File f ("/proc/self/exe");
+            return f.isLink() ? f.getLinkedTarget() : juce_getExecutableFile();
+        }
+
+        default:
+            jassertfalse; // unknown type?
+            break;
+    }
+
+    return File();
+}
+
+//==============================================================================
+bool File::moveToTrash() const
+{
+    if (! exists())
+        return true;
+
+    File trashCan ("~/.Trash");
+
+    if (! trashCan.isDirectory())
+        trashCan = "~/.local/share/Trash/files";
+
+    if (! trashCan.isDirectory())
+        return false;
+
+    return moveFileTo (trashCan.getNonexistentChildFile (getFileNameWithoutExtension(),
+                                                         getFileExtension()));
+}
+
+//==============================================================================
+static bool isFileExecutable (const String& filename)
+{
+    juce_statStruct info;
+
+    return juce_stat (filename, info)
+            && S_ISREG (info.st_mode)
+            && access (filename.toUTF8(), X_OK) == 0;
+}
+
+bool Process::openDocument (const String& fileName, const String& parameters)
+{
+    String cmdString (fileName.replace (" ", "\\ ",false));
+    cmdString << " " << parameters;
+
+    if (URL::isProbablyAWebsiteURL (fileName)
+         || cmdString.startsWithIgnoreCase ("file:")
+         || URL::isProbablyAnEmailAddress (fileName)
+         || File::createFileWithoutCheckingPath (fileName).isDirectory()
+         || ! isFileExecutable (fileName))
+    {
+        // create a command that tries to launch a bunch of likely browsers
+        static const char* const browserNames[] = { "xdg-open", "/etc/alternatives/x-www-browser", "firefox", "mozilla",
+                                                    "google-chrome", "chromium-browser", "opera", "konqueror" };
+        StringArray cmdLines;
+
+        for (int i = 0; i < numElementsInArray (browserNames); ++i)
+            cmdLines.add (String (browserNames[i]) + " " + cmdString.trim().quoted());
+
+        cmdString = cmdLines.joinIntoString (" || ");
+    }
+
+    const char* const argv[4] = { "/bin/sh", "-c", cmdString.toUTF8(), 0 };
+
+    const int cpid = fork();
+
+    if (cpid == 0)
+    {
+        setsid();
+
+        // Child process
+        execve (argv[0], (char**) argv, environ);
+        exit (0);
+    }
+
+    return cpid >= 0;
+}
+
+void File::revealToUser() const
+{
+    if (isDirectory())
+        startAsProcess();
+    else if (getParentDirectory().exists())
+        getParentDirectory().startAsProcess();
+}
diff --git a/JuceLibraryCode/modules/juce_core/native/juce_haiku_SystemStats.cpp b/JuceLibraryCode/modules/juce_core/native/juce_haiku_SystemStats.cpp
new file mode 100644
index 0000000..f6acd11
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_core/native/juce_haiku_SystemStats.cpp
@@ -0,0 +1,142 @@
+/*
+  ==============================================================================
+
+   This file is part of the juce_core module of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission to use, copy, modify, and/or distribute this software for any purpose with
+   or without fee is hereby granted, provided that the above copyright notice and this
+   permission notice appear in all copies.
+
+   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
+   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
+   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ------------------------------------------------------------------------------
+
+   NOTE! This permissive ISC license applies ONLY to files within the juce_core module!
+   All other JUCE modules are covered by a dual GPL/commercial license, so if you are
+   using any other modules, be sure to check that you also comply with their license.
+
+   For more details, visit www.juce.com
+
+  ==============================================================================
+*/
+
+void Logger::outputDebugString (const String& text)
+{
+    std::cerr << text << std::endl;
+}
+
+//==============================================================================
+SystemStats::OperatingSystemType SystemStats::getOperatingSystemType()
+{
+    return Haiku;
+}
+
+String SystemStats::getOperatingSystemName()
+{
+    return "Haiku";
+}
+
+bool SystemStats::isOperatingSystem64Bit()
+{
+   #if JUCE_64BIT
+    return true;
+   #else
+    //xxx not sure how to find this out?..
+    return false;
+   #endif
+}
+
+int SystemStats::getMemorySizeInMegabytes()
+{
+    // TODO
+    return 0;
+}
+
+int SystemStats::getPageSize()
+{
+    return (int) sysconf (_SC_PAGESIZE);
+}
+
+//==============================================================================
+String SystemStats::getLogonName()
+{
+    if (const char* user = getenv ("USER"))
+        return CharPointer_UTF8 (user);
+
+    if (struct passwd* const pw = getpwuid (getuid()))
+        return CharPointer_UTF8 (pw->pw_name);
+
+    return String();
+}
+
+String SystemStats::getFullUserName()
+{
+    return getLogonName();
+}
+
+String SystemStats::getComputerName()
+{
+    char name [256] = { 0 };
+    if (gethostname (name, sizeof (name) - 1) == 0)
+        return name;
+
+    return String();
+}
+
+String SystemStats::getUserLanguage()    { return "en"; }
+String SystemStats::getUserRegion()      { return "US"; }
+String SystemStats::getDisplayLanguage() { return "en_US"; }
+
+//==============================================================================
+void CPUInformation::initialise() noexcept
+{
+    // TODO
+    /*hasMMX   = flags.contains ("mmx");
+    hasSSE   = flags.contains ("sse");
+    hasSSE2  = flags.contains ("sse2");
+    hasSSE3  = flags.contains ("sse3");
+    has3DNow = flags.contains ("3dnow");
+    hasSSSE3 = flags.contains ("ssse3");
+    hasAVX   = flags.contains ("avx");
+
+    numCpus = LinuxStatsHelpers::getCpuInfo ("processor").getIntValue() + 1; */
+}
+
+
+uint32 juce_millisecondsSinceStartup() noexcept
+{
+    timespec t;
+    clock_gettime (CLOCK_MONOTONIC, &t);
+
+    return t.tv_sec * 1000 + t.tv_nsec / 1000000;
+}
+
+int64 Time::getHighResolutionTicks() noexcept
+{
+    timespec t;
+    clock_gettime (CLOCK_MONOTONIC, &t);
+
+    return (t.tv_sec * (int64) 1000000) + (t.tv_nsec / 1000);
+}
+
+int64 Time::getHighResolutionTicksPerSecond() noexcept
+{
+    return 1000000;  // (microseconds)
+}
+
+double Time::getMillisecondCounterHiRes() noexcept
+{
+    return getHighResolutionTicks() * 0.001;
+}
+
+bool Time::setSystemTimeToThisTime() const
+{
+    jassertfalse;
+    return false;
+}
diff --git a/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h b/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h
index b6fff48..0bfab03 100644
--- a/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h
+++ b/JuceLibraryCode/modules/juce_core/native/juce_posix_SharedCode.h
@@ -209,6 +209,7 @@ namespace
                  && JUCE_STAT (fileName.toUTF8(), &info) == 0;
     }
 
+#ifndef __HAIKU__
     // if this file doesn't exist, find a parent of it that does..
     bool juce_doStatFS (File f, struct statfs& result)
     {
@@ -222,6 +223,7 @@ namespace
 
         return statfs (f.getFullPathName().toUTF8(), &result) == 0;
     }
+#endif
 
    #if (JUCE_MAC && MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5) || JUCE_IOS
     static int64 getCreationTime (const juce_statStruct& s) noexcept     { return (int64) s.st_birthtime; }
@@ -353,11 +355,19 @@ bool File::setFileTimesInternal (int64 modificationTime, int64 accessTime, int64
 
     if ((modificationTime != 0 || accessTime != 0) && juce_stat (fullPath, info))
     {
+#ifdef __HAIKU__
+        struct timespec times[2];
+        times[0].tv_sec  = accessTime != 0       ? (time_t) (accessTime / 1000)       : info.st_atime;
+        times[1].tv_sec = modificationTime != 0 ? (time_t) (modificationTime / 1000) : info.st_mtime;
+
+        return utimensat (AT_FDCWD, fullPath.toUTF8(), times, 0) == 0;
+#else
         struct utimbuf times;
         times.actime  = accessTime != 0       ? (time_t) (accessTime / 1000)       : info.st_atime;
         times.modtime = modificationTime != 0 ? (time_t) (modificationTime / 1000) : info.st_mtime;
 
         return utime (fullPath.toUTF8(), &times) == 0;
+#endif
     }
 
     return false;
@@ -559,7 +569,11 @@ void MemoryMappedFile::openInternal (const File& file, AccessMode mode)
         if (m != MAP_FAILED)
         {
             address = m;
+#ifdef __HAIKU__
+            posix_madvise (m, (size_t) range.getLength(), POSIX_MADV_SEQUENTIAL);
+#else
             madvise (m, (size_t) range.getLength(), MADV_SEQUENTIAL);
+#endif
         }
         else
         {
@@ -608,19 +622,21 @@ File juce_getExecutableFile()
 //==============================================================================
 int64 File::getBytesFreeOnVolume() const
 {
+#ifndef __HAIKU__
     struct statfs buf;
     if (juce_doStatFS (*this, buf))
         return (int64) buf.f_bsize * (int64) buf.f_bavail; // Note: this returns space available to non-super user
-
+#endif
     return 0;
 }
 
 int64 File::getVolumeTotalSize() const
 {
+#ifndef __HAIKU__
     struct statfs buf;
     if (juce_doStatFS (*this, buf))
         return (int64) buf.f_bsize * (int64) buf.f_blocks;
-
+#endif
     return 0;
 }
 
diff --git a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp
index 65bb117..383ade9 100644
--- a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp
+++ b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.cpp
@@ -100,7 +100,7 @@ String SystemStats::getStackBacktrace()
 {
     String result;
 
-   #if JUCE_ANDROID || JUCE_MINGW
+   #if JUCE_ANDROID || JUCE_MINGW || JUCE_HAIKU
     jassertfalse; // sorry, not implemented yet!
 
    #elif JUCE_WINDOWS
diff --git a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h
index 540bf73..e246b6c 100644
--- a/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h
+++ b/JuceLibraryCode/modules/juce_core/system/juce_SystemStats.h
@@ -56,6 +56,7 @@ public:
         Linux           = 0x0400,
         Android         = 0x0800,
         iOS             = 0x1000,
+        Haiku           = 0x2000,
 
         MacOSX_10_4     = MacOSX | 4,
         MacOSX_10_5     = MacOSX | 5,
diff --git a/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h b/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h
index 75e363f..f69f96a 100644
--- a/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h
+++ b/JuceLibraryCode/modules/juce_core/system/juce_TargetPlatform.h
@@ -66,6 +66,8 @@
   #endif
 #elif defined (__FreeBSD__)
   #define       JUCE_BSD 1
+#elif defined (__HAIKU__)
+  #define       JUCE_HAIKU 1
 #else
   #error "Unknown platform!"
 #endif
@@ -140,7 +142,7 @@
 #endif
 
 //==============================================================================
-#if JUCE_LINUX || JUCE_ANDROID
+#if JUCE_LINUX || JUCE_ANDROID || JUCE_HAIKU
 
   #ifdef _DEBUG
     #define JUCE_DEBUG 1
diff --git a/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp b/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp
index bd14b66..dfee386 100644
--- a/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp
+++ b/JuceLibraryCode/modules/juce_data_structures/app_properties/juce_PropertiesFile.cpp
@@ -82,7 +82,7 @@ File PropertiesFile::Options::getDefaultFile() const
     if (folderName.isNotEmpty())
         dir = dir.getChildFile (folderName);
 
-   #elif JUCE_LINUX || JUCE_ANDROID
+   #elif JUCE_LINUX || JUCE_ANDROID || JUCE_HAIKU
     const File dir (File (commonToAllUsers ? "/var" : "~")
                      .getChildFile (folderName.isNotEmpty() ? folderName
                                                             : ("." + applicationName)));
diff --git a/JuceLibraryCode/modules/juce_events/juce_events.cpp b/JuceLibraryCode/modules/juce_events/juce_events.cpp
index 53069c4..04a7e1c 100644
--- a/JuceLibraryCode/modules/juce_events/juce_events.cpp
+++ b/JuceLibraryCode/modules/juce_events/juce_events.cpp
@@ -98,6 +98,9 @@ namespace juce
  #include "../juce_core/native/juce_android_JNIHelpers.h"
  #include "native/juce_android_Messaging.cpp"
 
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Messaging.cpp"
+
 #endif
 
 }
diff --git a/JuceLibraryCode/modules/juce_events/native/juce_haiku_Messaging.cpp b/JuceLibraryCode/modules/juce_events/native/juce_haiku_Messaging.cpp
new file mode 100644
index 0000000..075b84b
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_events/native/juce_haiku_Messaging.cpp
@@ -0,0 +1,56 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+#if JUCE_DEBUG && ! defined (JUCE_DEBUG_XERRORS)
+ #define JUCE_DEBUG_XERRORS 1
+#endif
+
+//==============================================================================
+void MessageManager::doPlatformSpecificInitialisation()
+{
+    // TODO
+}
+
+void MessageManager::doPlatformSpecificShutdown()
+{
+	// TODO
+}
+
+bool MessageManager::postMessageToSystemQueue (MessageManager::MessageBase* const message)
+{
+    // TODO
+    return true;
+}
+
+void MessageManager::broadcastMessage (const String& /* value */)
+{
+    /* TODO */
+}
+
+// this function expects that it will NEVER be called simultaneously for two concurrent threads
+bool MessageManager::dispatchNextMessageOnSystemQueue (bool returnIfNoPendingMessages)
+{
+    // TODO
+    return false;
+}
diff --git a/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp b/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp
index 4299852..d45ba9c 100644
--- a/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp
+++ b/JuceLibraryCode/modules/juce_graphics/images/juce_Image.cpp
@@ -133,7 +133,7 @@ int NativeImageType::getTypeID() const
     return 1;
 }
 
-#if JUCE_WINDOWS || JUCE_LINUX
+#if JUCE_WINDOWS || JUCE_LINUX || JUCE_HAIKU
 ImagePixelData::Ptr NativeImageType::create (Image::PixelFormat format, int width, int height, bool clearImage) const
 {
     return new SoftwarePixelData (format, width, height, clearImage);
diff --git a/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp b/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp
index 2d5a096..c795793 100644
--- a/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp
+++ b/JuceLibraryCode/modules/juce_graphics/juce_graphics.cpp
@@ -73,6 +73,11 @@
  #ifndef JUCE_USE_FREETYPE
   #define JUCE_USE_FREETYPE 1
  #endif
+
+#elif JUCE_HAIKU
+ #ifndef JUCE_USE_FREETYPE
+  #define JUCE_USE_FREETYPE 1
+ #endif
 #endif
 
 #if JUCE_USE_FREETYPE
@@ -153,6 +158,9 @@ namespace juce
  #include "native/juce_android_GraphicsContext.cpp"
  #include "native/juce_android_Fonts.cpp"
 
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Fonts.cpp"
+
 #endif
 }
 
diff --git a/JuceLibraryCode/modules/juce_graphics/native/juce_haiku_Fonts.cpp b/JuceLibraryCode/modules/juce_graphics/native/juce_haiku_Fonts.cpp
new file mode 100644
index 0000000..39dd384
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_graphics/native/juce_haiku_Fonts.cpp
@@ -0,0 +1,180 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+StringArray FTTypefaceList::getDefaultFontDirectories()
+{
+    StringArray fontDirs;
+
+    fontDirs.addTokens (String (CharPointer_UTF8 (getenv ("JUCE_FONT_PATH"))), ";,", "");
+    fontDirs.removeEmptyStrings (true);
+
+    if (fontDirs.size() == 0)
+    {
+        const ScopedPointer<XmlElement> fontsInfo (XmlDocument::parse (File ("/etc/fonts/fonts.conf")));
+
+        if (fontsInfo != nullptr)
+        {
+            forEachXmlChildElementWithTagName (*fontsInfo, e, "dir")
+            {
+                String fontPath (e->getAllSubText().trim());
+
+                if (fontPath.isNotEmpty())
+                {
+                    if (e->getStringAttribute ("prefix") == "xdg")
+                    {
+                        String xdgDataHome (SystemStats::getEnvironmentVariable ("XDG_DATA_HOME", String()));
+
+                        if (xdgDataHome.trimStart().isEmpty())
+                            xdgDataHome = "~/.local/share";
+
+                        fontPath = File (xdgDataHome).getChildFile (fontPath).getFullPathName();
+                    }
+
+                    fontDirs.add (fontPath);
+                }
+            }
+        }
+    }
+
+    if (fontDirs.size() == 0)
+        fontDirs.add ("/usr/X11R6/lib/X11/fonts");
+
+    fontDirs.removeDuplicates (false);
+    return fontDirs;
+}
+
+Typeface::Ptr Typeface::createSystemTypefaceFor (const Font& font)
+{
+    return new FreeTypeTypeface (font);
+}
+
+Typeface::Ptr Typeface::createSystemTypefaceFor (const void* data, size_t dataSize)
+{
+    return new FreeTypeTypeface (data, dataSize);
+}
+
+void Typeface::scanFolderForFonts (const File& folder)
+{
+    FTTypefaceList::getInstance()->scanFontPaths (StringArray (folder.getFullPathName()));
+}
+
+StringArray Font::findAllTypefaceNames()
+{
+    return FTTypefaceList::getInstance()->findAllFamilyNames();
+}
+
+StringArray Font::findAllTypefaceStyles (const String& family)
+{
+    return FTTypefaceList::getInstance()->findAllTypefaceStyles (family);
+}
+
+bool TextLayout::createNativeLayout (const AttributedString&)
+{
+    return false;
+}
+
+//==============================================================================
+struct DefaultFontNames
+{
+    DefaultFontNames()
+        : defaultSans  (getDefaultSansSerifFontName()),
+          defaultSerif (getDefaultSerifFontName()),
+          defaultFixed (getDefaultMonospacedFontName())
+    {
+    }
+
+    String getRealFontName (const String& faceName) const
+    {
+        if (faceName == Font::getDefaultSansSerifFontName())    return defaultSans;
+        if (faceName == Font::getDefaultSerifFontName())        return defaultSerif;
+        if (faceName == Font::getDefaultMonospacedFontName())   return defaultFixed;
+
+        return faceName;
+    }
+
+    String defaultSans, defaultSerif, defaultFixed;
+
+private:
+    static String pickBestFont (const StringArray& names, const char* const* choicesArray)
+    {
+        const StringArray choices (choicesArray);
+
+        for (int j = 0; j < choices.size(); ++j)
+            if (names.contains (choices[j], true))
+                return choices[j];
+
+        for (int j = 0; j < choices.size(); ++j)
+            for (int i = 0; i < names.size(); ++i)
+                if (names[i].startsWithIgnoreCase (choices[j]))
+                    return names[i];
+
+        for (int j = 0; j < choices.size(); ++j)
+            for (int i = 0; i < names.size(); ++i)
+                if (names[i].containsIgnoreCase (choices[j]))
+                    return names[i];
+
+        return names[0];
+    }
+
+    static String getDefaultSansSerifFontName()
+    {
+        StringArray allFonts;
+        FTTypefaceList::getInstance()->getSansSerifNames (allFonts);
+
+        static const char* targets[] = { "Verdana", "Bitstream Vera Sans", "Luxi Sans",
+                                         "Liberation Sans", "DejaVu Sans", "Sans", nullptr };
+        return pickBestFont (allFonts, targets);
+    }
+
+    static String getDefaultSerifFontName()
+    {
+        StringArray allFonts;
+        FTTypefaceList::getInstance()->getSerifNames (allFonts);
+
+        static const char* targets[] = { "Bitstream Vera Serif", "Times", "Nimbus Roman",
+                                         "Liberation Serif", "DejaVu Serif", "Serif", nullptr };
+        return pickBestFont (allFonts, targets);
+    }
+
+    static String getDefaultMonospacedFontName()
+    {
+        StringArray allFonts;
+        FTTypefaceList::getInstance()->getMonospacedNames (allFonts);
+
+        static const char* targets[] = { "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Sans Mono",
+                                         "Liberation Mono", "Courier", "DejaVu Mono", "Mono", nullptr };
+        return pickBestFont (allFonts, targets);
+    }
+
+    JUCE_DECLARE_NON_COPYABLE (DefaultFontNames)
+};
+
+Typeface::Ptr Font::getDefaultTypefaceForFont (const Font& font)
+{
+    static DefaultFontNames defaultNames;
+
+    Font f (font);
+    f.setTypefaceName (defaultNames.getRealFontName (font.getTypefaceName()));
+    return Typeface::createSystemTypefaceFor (f);
+}
diff --git a/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp b/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp
index 00eea12..bc697e7 100644
--- a/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp
+++ b/JuceLibraryCode/modules/juce_gui_basics/juce_gui_basics.cpp
@@ -297,6 +297,11 @@ extern bool juce_areThereAnyAlwaysOnTopWindows();
  #include "native/juce_android_Windowing.cpp"
  #include "native/juce_android_FileChooser.cpp"
 
+#elif JUCE_HAIKU
+ #include "native/juce_haiku_Clipboard.cpp"
+ #include "native/juce_haiku_Windowing.cpp"
+ #include "native/juce_haiku_FileChooser.cpp"
+
 #endif
 
 }
diff --git a/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Clipboard.cpp b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Clipboard.cpp
new file mode 100644
index 0000000..be683df
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Clipboard.cpp
@@ -0,0 +1,38 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+//==============================================================================
+void SystemClipboard::copyTextToClipboard (const String& clipText)
+{
+    // TODO
+}
+
+String SystemClipboard::getTextFromClipboard()
+{
+    String content;
+
+    // TODO
+
+    return content;
+}
diff --git a/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_FileChooser.cpp b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_FileChooser.cpp
new file mode 100644
index 0000000..351020c
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_FileChooser.cpp
@@ -0,0 +1,48 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+bool FileChooser::isPlatformDialogAvailable()
+{
+   #if JUCE_DISABLE_NATIVE_FILECHOOSERS
+    return false;
+   #else
+    return true;
+   #endif
+}
+
+void FileChooser::showPlatformDialog (Array<File>& results,
+                                      const String& title, const File& file, const String& filters,
+                                      bool isDirectory, bool /* selectsFiles */,
+                                      bool isSave, bool /* warnAboutOverwritingExistingFiles */,
+                                      bool selectMultipleFiles, FilePreviewComponent*)
+{
+    const File previousWorkingDirectory (File::getCurrentWorkingDirectory());
+
+    StringArray args;
+    String separator;
+    
+    // TODO
+
+    previousWorkingDirectory.setAsCurrentWorkingDirectory();
+}
diff --git a/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Windowing.cpp b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Windowing.cpp
new file mode 100644
index 0000000..b5c0a4d
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_gui_basics/native/juce_haiku_Windowing.cpp
@@ -0,0 +1,544 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2015 - ROLI Ltd.
+
+   Permission is granted to use this software under the terms of either:
+   a) the GPL v2 (or any later version)
+   b) the Affero GPL v3
+
+   Details of these licenses can be found at: www.gnu.org/licenses
+
+   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   ------------------------------------------------------------------------------
+
+   To release a closed-source product which uses JUCE, commercial licenses are
+   available: visit www.juce.com for more information.
+
+  ==============================================================================
+*/
+
+
+
+//==============================================================================
+static int numAlwaysOnTopPeers = 0;
+
+bool juce_areThereAnyAlwaysOnTopWindows()
+{
+    return numAlwaysOnTopPeers > 0;
+}
+
+//==============================================================================
+class HaikuComponentPeer  : public ComponentPeer
+{
+public:
+    HaikuComponentPeer (Component& comp, const int windowStyleFlags)
+        : ComponentPeer (comp, windowStyleFlags),
+          fullScreen (false), mapped (false),
+          depth (0),
+          isAlwaysOnTop (comp.isAlwaysOnTop()),
+          currentScaleFactor (1.0)
+    {
+        // it's dangerous to create a window on a thread other than the message thread..
+        jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());
+
+        if (isAlwaysOnTop)
+            ++numAlwaysOnTopPeers;
+
+        
+        setTitle (component.getName());
+    }
+
+    ~HaikuComponentPeer()
+    {
+        // it's dangerous to delete a window on a thread other than the message thread..
+        jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());
+
+        if (isAlwaysOnTop)
+            --numAlwaysOnTopPeers;
+    }
+
+    //==============================================================================
+    void* getNativeHandle() const override
+    {
+        return (void*) NULL;
+    }
+
+
+    void setVisible (bool shouldBeVisible) override
+    {
+        // TODO
+    }
+
+    void setTitle (const String& title) override
+    {
+        // TODO
+    }
+
+    void setBounds (const Rectangle<int>& newBounds, bool isNowFullScreen) override
+    {
+        if (fullScreen && ! isNowFullScreen)
+        {
+        	// TODO
+        }
+
+        fullScreen = isNowFullScreen;
+
+        // TODO
+    }
+
+    Rectangle<int> getBounds() const override          { return bounds; }
+
+    Point<float> localToGlobal (Point<float> relativePosition) override
+    {
+        return relativePosition + bounds.getPosition().toFloat();
+    }
+
+    Point<float> globalToLocal (Point<float> screenPosition) override
+    {
+        return screenPosition - bounds.getPosition().toFloat();
+    }
+
+    void setAlpha (float /* newAlpha */) override
+    {
+        //xxx todo!
+    }
+
+    StringArray getAvailableRenderingEngines() override
+    {
+        return StringArray ("Software Renderer");
+    }
+
+    void setMinimised (bool shouldBeMinimised) override
+    {
+        if (shouldBeMinimised)
+        {
+            // TODO
+        }
+        else
+        {
+            setVisible (true);
+        }
+    }
+
+    bool isMinimised() const override
+    {
+    	// TODO
+        return false;
+    }
+
+    void setFullScreen (const bool shouldBeFullScreen) override
+    {
+        Rectangle<int> r (lastNonFullscreenBounds); // (get a copy of this before de-minimising)
+
+        setMinimised (false);
+
+        if (fullScreen != shouldBeFullScreen)
+        {
+            // TODO
+            component.repaint();
+        }
+    }
+
+    bool isFullScreen() const override
+    {
+        return fullScreen;
+    }
+
+    bool isFrontWindow() const
+    {
+    	// TODO
+        return false;
+    }
+
+    bool contains (Point<int> localPos, bool trueIfInAChildWindow) const override
+    {
+        // TODO
+		return false;
+    }
+
+    BorderSize<int> getFrameSize() const override
+    {
+        return BorderSize<int>();
+    }
+
+    bool setAlwaysOnTop (bool /* alwaysOnTop */) override
+    {
+        return false;
+    }
+
+    void toFront (bool makeActive) override
+    {
+        if (makeActive)
+        {
+            setVisible (true);
+        }
+        // TODO
+        handleBroughtToFront();
+    }
+
+    void toBehind (ComponentPeer* other) override
+    {
+        if (HaikuComponentPeer* const otherPeer = dynamic_cast<HaikuComponentPeer*> (other))
+        {
+            setMinimised (false);
+			// TODO
+        }
+        else
+            jassertfalse; // wrong type of window?
+    }
+
+    bool isFocused() const override
+    {
+		return true;
+    }
+
+    void grabFocus() override
+    {
+    }
+
+    void textInputRequired (Point<int>, TextInputTarget&) override {}
+
+	void repaint (const Rectangle<int>& area) override
+    {
+        // TODO
+    }
+
+    void performAnyPendingRepaintsNow() override
+    {
+        // TODO
+    }
+
+    void setIcon (const Image& newIcon) override
+    {
+    	// TODO
+    }
+    
+    //==============================================================================
+    double getCurrentScale() noexcept
+    {
+        return currentScaleFactor;
+    }
+
+
+    //==============================================================================
+    bool dontRepaint;
+
+	static ModifierKeys currentModifiers;
+    static bool isActiveApplication;
+
+private:
+
+    Rectangle<int> bounds;
+    Image taskbarImage;
+    bool fullScreen, mapped;
+    int depth;
+    BorderSize<int> windowBorder;
+    bool isAlwaysOnTop;
+    double currentScaleFactor;
+    enum { KeyPressEventType = 2 };
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HaikuComponentPeer)
+};
+
+ModifierKeys HaikuComponentPeer::currentModifiers;
+bool HaikuComponentPeer::isActiveApplication = false;
+
+//==============================================================================
+JUCE_API bool JUCE_CALLTYPE Process::isForegroundProcess()
+{
+    return HaikuComponentPeer::isActiveApplication;
+}
+
+JUCE_API void JUCE_CALLTYPE Process::makeForegroundProcess() {}
+JUCE_API void JUCE_CALLTYPE Process::hide() {}
+
+//==============================================================================
+bool KeyPress::isKeyCurrentlyDown (const int keyCode)
+{
+    // TODO
+    return false;
+}
+
+void ModifierKeys::updateCurrentModifiers() noexcept
+{
+    currentModifiers = HaikuComponentPeer::currentModifiers;
+}
+
+ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
+{
+	// TODO
+    return HaikuComponentPeer::currentModifiers;
+}
+
+
+//==============================================================================
+void Desktop::setKioskComponent (Component* comp, bool enableOrDisable, bool /* allowMenusAndBars */)
+{
+    if (enableOrDisable)
+        comp->setBounds (getDisplays().getMainDisplay().totalArea);
+}
+
+//==============================================================================
+ComponentPeer* Component::createNewPeer (int styleFlags, void* nativeWindowToAttachTo)
+{
+    return new HaikuComponentPeer (*this, styleFlags);
+}
+
+//==============================================================================
+void Desktop::Displays::findDisplays (float masterScale)
+{
+}
+
+//==============================================================================
+bool MouseInputSource::SourceList::addSource()
+{
+    if (sources.size() == 0)
+    {
+        addSource (0, true);
+        return true;
+    }
+
+    return false;
+}
+
+bool Desktop::canUseSemiTransparentWindows() noexcept
+{
+    return false;
+}
+
+Point<float> MouseInputSource::getCurrentRawMousePosition()
+{
+    // TODO
+    return Point<float>();
+}
+
+void MouseInputSource::setRawMousePosition (Point<float> newPosition)
+{
+		// TODO
+}
+
+double Desktop::getDefaultMasterScale()
+{
+    return 1.0;
+}
+
+Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
+{
+    return upright;
+}
+
+//==============================================================================
+static bool screenSaverAllowed = true;
+
+void Desktop::setScreenSaverEnabled (const bool isEnabled)
+{
+    if (screenSaverAllowed != isEnabled)
+    {
+        screenSaverAllowed = isEnabled;
+
+        // TODO
+    }
+}
+
+bool Desktop::isScreenSaverEnabled()
+{
+    return screenSaverAllowed;
+}
+
+//==============================================================================
+void* CustomMouseCursorInfo::create() const
+{
+    // TODO
+    return NULL;
+}
+
+void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool)
+{
+    if (cursorHandle != nullptr)
+    {
+    }
+}
+
+void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)
+{
+    // TODO
+    return NULL;
+}
+
+void MouseCursor::showInWindow (ComponentPeer* peer) const
+{
+    if (HaikuComponentPeer* const lp = dynamic_cast<HaikuComponentPeer*> (peer))
+    {
+    	// TODO
+    }
+}
+
+void MouseCursor::showInAllWindows() const
+{
+    for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
+        showInWindow (ComponentPeer::getPeer (i));
+}
+
+//==============================================================================
+Image juce_createIconForFile (const File& /* file */)
+{
+    return Image::null;
+}
+
+//==============================================================================
+bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMoveFiles)
+{
+    if (files.size() == 0)
+        return false;
+
+    if (MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource(0))
+        if (Component* sourceComp = draggingSource->getComponentUnderMouse())
+            if (HaikuComponentPeer* const lp = dynamic_cast<HaikuComponentPeer*> (sourceComp->getPeer())) {
+                // TODO
+                return false;
+            }
+
+    // This method must be called in response to a component's mouseDown or mouseDrag event!
+    jassertfalse;
+    return false;
+}
+
+bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
+{
+    if (text.isEmpty())
+        return false;
+
+    if (MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource(0))
+        if (Component* sourceComp = draggingSource->getComponentUnderMouse())
+            if (HaikuComponentPeer* const lp = dynamic_cast<HaikuComponentPeer*> (sourceComp->getPeer())) {
+            	// TODO
+                return false; 
+            }
+
+    // This method must be called in response to a component's mouseDown or mouseDrag event!
+    jassertfalse;
+    return false;
+}
+
+//==============================================================================
+void LookAndFeel::playAlertSound()
+{
+    std::cout << "\a" << std::flush;
+}
+//==============================================================================
+Rectangle<int> juce_HaikuScaledToPhysicalBounds(ComponentPeer* peer, const Rectangle<int>& bounds)
+{
+    Rectangle<int> retval = bounds;
+
+    if (HaikuComponentPeer* haikuPeer = dynamic_cast<HaikuComponentPeer*> (peer))
+        retval *= haikuPeer->getCurrentScale();
+
+    return retval;
+}
+
+void juce_HaikuAddRepaintListener (ComponentPeer* peer, Component* dummy)
+{
+}
+
+void juce_HaikuRemoveRepaintListener (ComponentPeer* peer, Component* dummy)
+{
+}
+
+//==============================================================================
+#if JUCE_MODAL_LOOPS_PERMITTED
+void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
+                                                     const String& title, const String& message,
+                                                     Component* /* associatedComponent */)
+{
+    AlertWindow::showMessageBox (iconType, title, message);
+}
+#endif
+
+void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
+                                                          const String& title, const String& message,
+                                                          Component* associatedComponent,
+                                                          ModalComponentManager::Callback* callback)
+{
+    AlertWindow::showMessageBoxAsync (iconType, title, message, String::empty, associatedComponent, callback);
+}
+
+bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
+                                                      const String& title, const String& message,
+                                                      Component* associatedComponent,
+                                                      ModalComponentManager::Callback* callback)
+{
+    return AlertWindow::showOkCancelBox (iconType, title, message, String::empty, String::empty,
+                                         associatedComponent, callback);
+}
+
+int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
+                                                        const String& title, const String& message,
+                                                        Component* associatedComponent,
+                                                        ModalComponentManager::Callback* callback)
+{
+    return AlertWindow::showYesNoCancelBox (iconType, title, message,
+                                            String::empty, String::empty, String::empty,
+                                            associatedComponent, callback);
+}
+
+//==============================================================================
+const int extendedKeyModifier       = 0x10000;
+
+const int KeyPress::spaceKey        = ' ';
+const int KeyPress::returnKey       = 66;
+const int KeyPress::escapeKey       = 4;
+const int KeyPress::backspaceKey    = 67;
+const int KeyPress::leftKey         = extendedKeyModifier + 1;
+const int KeyPress::rightKey        = extendedKeyModifier + 2;
+const int KeyPress::upKey           = extendedKeyModifier + 3;
+const int KeyPress::downKey         = extendedKeyModifier + 4;
+const int KeyPress::pageUpKey       = extendedKeyModifier + 5;
+const int KeyPress::pageDownKey     = extendedKeyModifier + 6;
+const int KeyPress::endKey          = extendedKeyModifier + 7;
+const int KeyPress::homeKey         = extendedKeyModifier + 8;
+const int KeyPress::deleteKey       = extendedKeyModifier + 9;
+const int KeyPress::insertKey       = -1;
+const int KeyPress::tabKey          = 61;
+const int KeyPress::F1Key           = extendedKeyModifier + 10;
+const int KeyPress::F2Key           = extendedKeyModifier + 11;
+const int KeyPress::F3Key           = extendedKeyModifier + 12;
+const int KeyPress::F4Key           = extendedKeyModifier + 13;
+const int KeyPress::F5Key           = extendedKeyModifier + 14;
+const int KeyPress::F6Key           = extendedKeyModifier + 16;
+const int KeyPress::F7Key           = extendedKeyModifier + 17;
+const int KeyPress::F8Key           = extendedKeyModifier + 18;
+const int KeyPress::F9Key           = extendedKeyModifier + 19;
+const int KeyPress::F10Key          = extendedKeyModifier + 20;
+const int KeyPress::F11Key          = extendedKeyModifier + 21;
+const int KeyPress::F12Key          = extendedKeyModifier + 22;
+const int KeyPress::F13Key          = extendedKeyModifier + 23;
+const int KeyPress::F14Key          = extendedKeyModifier + 24;
+const int KeyPress::F15Key          = extendedKeyModifier + 25;
+const int KeyPress::F16Key          = extendedKeyModifier + 26;
+const int KeyPress::numberPad0      = extendedKeyModifier + 27;
+const int KeyPress::numberPad1      = extendedKeyModifier + 28;
+const int KeyPress::numberPad2      = extendedKeyModifier + 29;
+const int KeyPress::numberPad3      = extendedKeyModifier + 30;
+const int KeyPress::numberPad4      = extendedKeyModifier + 31;
+const int KeyPress::numberPad5      = extendedKeyModifier + 32;
+const int KeyPress::numberPad6      = extendedKeyModifier + 33;
+const int KeyPress::numberPad7      = extendedKeyModifier + 34;
+const int KeyPress::numberPad8      = extendedKeyModifier + 35;
+const int KeyPress::numberPad9      = extendedKeyModifier + 36;
+const int KeyPress::numberPadAdd            = extendedKeyModifier + 37;
+const int KeyPress::numberPadSubtract       = extendedKeyModifier + 38;
+const int KeyPress::numberPadMultiply       = extendedKeyModifier + 39;
+const int KeyPress::numberPadDivide         = extendedKeyModifier + 40;
+const int KeyPress::numberPadSeparator      = extendedKeyModifier + 41;
+const int KeyPress::numberPadDecimalPoint   = extendedKeyModifier + 42;
+const int KeyPress::numberPadEquals         = extendedKeyModifier + 43;
+const int KeyPress::numberPadDelete         = extendedKeyModifier + 44;
+const int KeyPress::playKey         = extendedKeyModifier + 45;
+const int KeyPress::stopKey         = extendedKeyModifier + 46;
+const int KeyPress::fastForwardKey  = extendedKeyModifier + 47;
+const int KeyPress::rewindKey       = extendedKeyModifier + 48;
-- 
2.16.4


From 0850e5250726d5f4e19dfa5433c585d54b0b6b15 Mon Sep 17 00:00:00 2001
From: Leorize <alaviss@users.noreply.github.com>
Date: Thu, 30 Aug 2018 15:20:04 +0700
Subject: cmake: fix documentation installation

The glob approach used prior to this commit only works if
the documentation has been generated **before** cmake was run.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5c7e5f6..0c0e4e9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -199,8 +199,7 @@ INSTALL(TARGETS openshot-audio DESTINATION ${CMAKE_INSTALL_LIBDIR})
 include(cmake/Modules/UseDoxygen.cmake)
 
 # Install Doxygen html documentation
-file(GLOB_RECURSE doc_files ${CMAKE_CURRENT_BINARY_DIR}/doc/html/*.*)
-INSTALL(FILES ${doc_files} DESTINATION ${CMAKE_INSTALL_DOCDIR}/libopenshot-audio)
+INSTALL(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc/html/ DESTINATION ${CMAKE_INSTALL_DOCDIR}/libopenshot-audio OPTIONAL)
 
 # Install manpage
 INSTALL(FILES ${CMAKE_CURRENT_SOURCE_DIR}/doc/openshot-audio-test-sound.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
-- 
2.16.4


From 97b33acd27b7f49443eef6542b90101b959b4e5c Mon Sep 17 00:00:00 2001
From: Leorize <alaviss@users.noreply.github.com>
Date: Thu, 30 Aug 2018 10:37:53 +0700
Subject: haiku: uses native libraries


diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0c0e4e9..c6669e1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -129,10 +129,14 @@ ELSE (WIN32)
 			IF   (HAIKU)
 				SET_PROPERTY(GLOBAL PROPERTY JUCE_HAIKU "JUCE_HAIKU")
 				SET(EXTENSION "cpp")
+				FIND_PACKAGE(CURL REQUIRED)
 				FIND_PACKAGE(Freetype REQUIRED)
+				FIND_PACKAGE(PNG REQUIRED)
 				INCLUDE_DIRECTORIES(${FREETYPE_INCLUDE_DIRS})
 				ADD_DEFINITIONS(-DHAIKU)
-				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES curl ${FREETYPE_LIBRARIES})
+				ADD_DEFINITIONS(${PNG_DEFINITIONS})
+				ADD_DEFINITIONS(-DJUCE_INCLUDE_PNGLIB_CODE=0)
+				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES ${CURL_LIBRARIES} ${FREETYPE_LIBRARIES} ${PNG_LIBRARIES})
 			ELSE (HAIKU)
 				SET_PROPERTY(GLOBAL PROPERTY JUCE_LINUX "JUCE_LINUX")
 				SET(EXTENSION "cpp")
-- 
2.16.4


From cf2c33e039c39cf27d75b1559d7915749516f563 Mon Sep 17 00:00:00 2001
From: Ghislain Antony Vaillant <ghisvail@gmail.com>
Date: Thu, 15 Dec 2016 19:39:01 +0000
Subject: Fix build with libpng16


diff --git a/JuceLibraryCode/modules/juce_graphics/image_formats/juce_PNGLoader.cpp b/JuceLibraryCode/modules/juce_graphics/image_formats/juce_PNGLoader.cpp
index fa3b887..fe382b6 100644
--- a/JuceLibraryCode/modules/juce_graphics/image_formats/juce_PNGLoader.cpp
+++ b/JuceLibraryCode/modules/juce_graphics/image_formats/juce_PNGLoader.cpp
@@ -396,8 +396,12 @@ Image PNGImageFormat::decodeImage (InputStream& in)
 
             png_set_add_alpha (pngReadStruct, 0xff, PNG_FILLER_AFTER);
 
+            png_bytep trans_alpha;
+            int num_trans;
+            png_get_tRNS(pngReadStruct, pngInfoStruct, &trans_alpha, &num_trans, NULL);
+
             bool hasAlphaChan = (colorType & PNG_COLOR_MASK_ALPHA) != 0
-                                  || pngInfoStruct->num_trans > 0;
+                                  || num_trans > 0;
 
             // Load the image into a temp buffer in the pnglib format..
             const size_t lineStride = width * 4;
-- 
2.16.4


From 7d47f592cd7bb31749daa5529351825fbe4e6651 Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Fri, 7 Sep 2018 20:46:02 +1000
Subject: Add Haiku audio output module


diff --git a/CMakeLists.txt b/CMakeLists.txt
index c6669e1..6ef07a7 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -136,7 +136,7 @@ ELSE (WIN32)
 				ADD_DEFINITIONS(-DHAIKU)
 				ADD_DEFINITIONS(${PNG_DEFINITIONS})
 				ADD_DEFINITIONS(-DJUCE_INCLUDE_PNGLIB_CODE=0)
-				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES ${CURL_LIBRARIES} ${FREETYPE_LIBRARIES} ${PNG_LIBRARIES})
+				SET(JUCE_PLATFORM_SPECIFIC_LIBRARIES ${CURL_LIBRARIES} ${FREETYPE_LIBRARIES} ${PNG_LIBRARIES} -lbe -lmedia)
 			ELSE (HAIKU)
 				SET_PROPERTY(GLOBAL PROPERTY JUCE_LINUX "JUCE_LINUX")
 				SET(EXTENSION "cpp")
diff --git a/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioDeviceManager.cpp b/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioDeviceManager.cpp
index 25451fe..b946db1 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioDeviceManager.cpp
+++ b/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioDeviceManager.cpp
@@ -163,6 +163,7 @@ void AudioDeviceManager::createAudioDeviceTypes (OwnedArray<AudioIODeviceType>&
     addIfNotNull (list, AudioIODeviceType::createAudioIODeviceType_JACK());
     addIfNotNull (list, AudioIODeviceType::createAudioIODeviceType_OpenSLES());
     addIfNotNull (list, AudioIODeviceType::createAudioIODeviceType_Android());
+    addIfNotNull (list, AudioIODeviceType::createAudioIODeviceType_Haiku());
 }
 
 void AudioDeviceManager::addAudioDeviceType (AudioIODeviceType* newDeviceType)
diff --git a/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.cpp b/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.cpp
index 0df87eb..cced450 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.cpp
+++ b/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.cpp
@@ -76,3 +76,7 @@ AudioIODeviceType* AudioIODeviceType::createAudioIODeviceType_Android()
 #if ! (JUCE_ANDROID && JUCE_USE_ANDROID_OPENSLES)
 AudioIODeviceType* AudioIODeviceType::createAudioIODeviceType_OpenSLES()        { return nullptr; }
 #endif
+
+#if ! JUCE_HAIKU
+AudioIODeviceType* AudioIODeviceType::createAudioIODeviceType_Haiku()         { return nullptr; }
+#endif
diff --git a/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.h b/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.h
index 73b8afc..a90430a 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.h
+++ b/JuceLibraryCode/modules/juce_audio_devices/audio_io/juce_AudioIODeviceType.h
@@ -164,6 +164,8 @@ public:
     static AudioIODeviceType* createAudioIODeviceType_Android();
     /** Creates an Android OpenSLES device type if it's available on this platform, or returns null. */
     static AudioIODeviceType* createAudioIODeviceType_OpenSLES();
+    /** Creates an Haiku device type if it's available on this platform, or returns null. */
+    static AudioIODeviceType* createAudioIODeviceType_Haiku();
 
 protected:
     explicit AudioIODeviceType (const String& typeName);
diff --git a/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp b/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
index 6c1fd00..ef8b8df 100644
--- a/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
+++ b/JuceLibraryCode/modules/juce_audio_devices/juce_audio_devices.cpp
@@ -92,6 +92,10 @@
   #include <imapierror.h>
  #endif
 
+//==============================================================================
+#elif JUCE_HAIKU
+#include <OS.h>
+#include <SoundPlayer.h>
 //==============================================================================
 #elif JUCE_LINUX
  #if JUCE_ALSA
@@ -218,6 +222,7 @@ namespace juce
 //==============================================================================
 #elif JUCE_HAIKU
  #include "native/juce_haiku_Midi.cpp"
+ #include "native/juce_haiku_Audio.cpp"
 
  #if JUCE_USE_CDREADER
   #include "native/juce_linux_AudioCDReader.cpp"
diff --git a/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Audio.cpp b/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Audio.cpp
new file mode 100644
index 0000000..55f7b0b
--- /dev/null
+++ b/JuceLibraryCode/modules/juce_audio_devices/native/juce_haiku_Audio.cpp
@@ -0,0 +1,284 @@
+/* Haiku audio output module for JUCE library.
+(c) 2018 Gerasim Troeglazov (3dEyes**)*/
+
+#define BUFFER_SIZE 		1024
+#define AUDIO_TYPE			int16
+#define AUDIO_RATE			44100
+#define AUDIO_IN_CHANNELS	1
+#define AUDIO_OUT_CHANNELS	2
+#define AUDIO_BYTES			sizeof(AUDIO_TYPE)
+#define AUDIO_BITS			(AUDIO_BYTES * 8)
+
+const char* const haikuAudioTypeName = "MediaKit Audio";
+
+class HaikuAudioIODevice  : public AudioIODevice
+{
+public:
+	HaikuAudioIODevice(const String& deviceName)
+		: AudioIODevice(deviceName, haikuAudioTypeName),
+		soundPlayer(NULL),
+		callback(nullptr),
+		inputChannelBuffer(1, 1),
+		outputChannelBuffer(1, 1)
+	{
+	}
+
+	~HaikuAudioIODevice()
+	{
+		close();
+	}
+
+	StringArray getOutputChannelNames() override
+	{
+		StringArray s;
+		s.add("Left");
+		s.add("Right");
+		return s;
+	}
+
+	StringArray getInputChannelNames() override
+	{
+		StringArray s;
+		return s;
+	}
+
+	Array<double> getAvailableSampleRates() override
+	{
+		Array<double> r;
+		r.add((double)AUDIO_RATE);
+		return r;
+	}
+
+	Array<int> getAvailableBufferSizes() override
+	{
+		Array<int> b;
+		b.add(BUFFER_SIZE);
+		return b;
+	}
+
+    int getDefaultBufferSize() override
+    {
+		return BUFFER_SIZE;
+	}
+
+	String open(const BigInteger& inputChannels,
+		const BigInteger& outputChannels,
+		double requestedSampleRate,
+		int bufferSize) override
+	{
+		close();
+
+		if ((int) requestedSampleRate != AUDIO_RATE)
+			return "Sample rate not allowed";
+
+		lastError.clear();
+
+		media_raw_audio_format mediaKitFormat = {
+			(float)AUDIO_RATE,
+			(uint32)AUDIO_OUT_CHANNELS,
+			media_raw_audio_format::B_AUDIO_SHORT,
+			B_MEDIA_LITTLE_ENDIAN,
+			(uint32)BUFFER_SIZE * AUDIO_OUT_CHANNELS * AUDIO_BYTES
+		};
+
+		inputChannelBuffer.setSize (AUDIO_IN_CHANNELS, BUFFER_SIZE);
+		inputChannelBuffer.clear();
+		outputChannelBuffer.setSize (AUDIO_OUT_CHANNELS, BUFFER_SIZE);
+		outputChannelBuffer.clear();
+
+		soundPlayer = new BSoundPlayer(&mediaKitFormat, "OpenShot", \
+			processCallback, NULL, (void*)this);
+
+		if (soundPlayer->InitCheck() != B_OK) {
+			delete soundPlayer;
+			soundPlayer = nullptr;
+			lastError = "BSoundPlayer not initialized";
+		}
+
+		return lastError;
+	}
+
+	void close() override
+	{
+		if (soundPlayer != nullptr) {
+			soundPlayer->SetHasData(false);
+			soundPlayer->Stop();
+			delete soundPlayer;
+			soundPlayer = nullptr;
+		}
+	}
+
+	int getOutputLatencyInSamples() override
+	{
+		return 0;
+	}
+	
+	int getInputLatencyInSamples() override
+	{
+		return 0;
+	}
+
+	bool isOpen() override
+	{
+		if (soundPlayer == nullptr)
+			return false;
+		if (soundPlayer->InitCheck() != B_OK)
+			return false;
+		return true;
+	}
+
+	int getCurrentBufferSizeSamples() override
+	{
+		return BUFFER_SIZE;
+	}
+    
+	int getCurrentBitDepth() override
+	{
+		return AUDIO_BITS;
+	}
+	
+	double getCurrentSampleRate() override
+	{
+		return AUDIO_RATE;
+	}
+
+	BigInteger getActiveOutputChannels() const override
+	{
+		return AUDIO_OUT_CHANNELS;
+	}
+	
+	BigInteger getActiveInputChannels() const override
+	{
+		return AUDIO_IN_CHANNELS;
+	}
+	
+	String getLastError() override
+	{
+		return lastError;
+	}
+
+	bool isPlaying() override
+	{
+		if (soundPlayer == nullptr)
+			return false;
+		return soundPlayer->HasData();
+	}
+
+	void start(AudioIODeviceCallback* newCallback) override
+	{
+		if (soundPlayer != nullptr && callback != newCallback) {
+			if (newCallback != nullptr)newCallback->audioDeviceAboutToStart (this);
+			const ScopedLock sl (callbackLock);
+			callback = newCallback;
+		}
+		soundPlayer->Start();
+		soundPlayer->SetHasData(true);
+	}
+
+	void stop() override
+	{
+		soundPlayer->SetHasData(false);
+		soundPlayer->Stop();
+
+		outputChannelBuffer.clear();
+
+		if (soundPlayer != nullptr) {
+			AudioIODeviceCallback* lastCallback;
+            {
+				const ScopedLock sl (callbackLock);
+				lastCallback = callback;
+				callback = nullptr;
+			}
+			if (lastCallback != nullptr)
+				lastCallback->audioDeviceStopped();
+		}
+	}
+
+private:
+	void process (void *buffer, size_t len)
+	{
+		int16 *destBuffer = (int16*)buffer;
+		size_t numSamples = len / (AUDIO_OUT_CHANNELS * AUDIO_BYTES);
+		{
+			const ScopedLock sl (callbackLock);
+			if (callback != nullptr) {
+				callback->audioDeviceIOCallback (inputChannelBuffer.getArrayOfReadPointers(), AUDIO_IN_CHANNELS,
+					outputChannelBuffer.getArrayOfWritePointers(), AUDIO_OUT_CHANNELS, numSamples);
+			} else {
+				outputChannelBuffer.clear();
+			}
+		}
+		for (int i = 0; i < AUDIO_OUT_CHANNELS; ++i) {
+			typedef AudioData::Pointer <AudioData::Int16,   AudioData::LittleEndian, AudioData::Interleaved, AudioData::NonConst> DstSampleType;
+			typedef AudioData::Pointer <AudioData::Float32, AudioData::NativeEndian, AudioData::NonInterleaved, AudioData::Const> SrcSampleType;
+			DstSampleType dstData (destBuffer + i, AUDIO_OUT_CHANNELS);
+			SrcSampleType srcData (outputChannelBuffer.getReadPointer (i, 0));
+			dstData.convertSamples (srcData, numSamples);
+		}
+	}
+
+	static void processCallback(void *cookie, void *buffer, size_t len, const media_raw_audio_format &format)
+	{
+		if (cookie != nullptr)
+			((HaikuAudioIODevice*) cookie)->process (buffer, len);
+		else
+			zeromem(buffer, len);
+	}
+	
+    AudioSampleBuffer inputChannelBuffer, outputChannelBuffer;
+	String lastError;
+	AudioIODeviceCallback* callback;
+	CriticalSection callbackLock;
+	BSoundPlayer *soundPlayer;
+
+	JUCE_DECLARE_NON_COPYABLE (HaikuAudioIODevice)
+};
+
+
+class HaikuAudioIODeviceType  : public AudioIODeviceType
+{
+public:
+	HaikuAudioIODeviceType() : AudioIODeviceType (haikuAudioTypeName) {}
+
+	void scanForDevices() {}
+
+	StringArray getDeviceNames (bool wantInputNames) const
+	{
+		return StringArray (haikuAudioTypeName);
+	}
+    
+	int getDefaultDeviceIndex (bool forInput) const
+	{
+		return 0;
+	}
+
+	int getIndexOfDevice (AudioIODevice* device, bool asInput) const
+	{
+		return (device != nullptr && !asInput) ? 0 : -1;
+	}
+	
+	bool hasSeparateInputsAndOutputs() const
+	{
+		return true;
+	}
+
+	AudioIODevice* createDevice (const String& outputDeviceName, const String& inputDeviceName)
+	{
+		ScopedPointer<HaikuAudioIODevice> dev;
+        if (outputDeviceName.isNotEmpty() || inputDeviceName.isNotEmpty()) {
+			dev = new HaikuAudioIODevice (outputDeviceName.isNotEmpty() ? outputDeviceName : inputDeviceName);
+			if (dev->getCurrentSampleRate() <= 0 || dev->getDefaultBufferSize() <= 0)
+				dev = nullptr;
+		}
+		return dev.release();
+	}
+
+private:
+	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HaikuAudioIODeviceType)
+};
+
+
+AudioIODeviceType* AudioIODeviceType::createAudioIODeviceType_Haiku()
+{
+	return new HaikuAudioIODeviceType();
+}
-- 
2.16.4

