From 05c171f45be2a08ec76355bd240051f15b0527ee Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Thu, 30 Jan 2020 04:01:58 +0900
Subject: libsdl2: Remove BDirectWindow, fix OpenGL handling.

* BDirectWindow changed to BWindow.
* Implemented fullscreen.
* Introduced view for non-OpenGL drawing.
* Drawing thread removed, window thread is used instead.
* Use BGLView as OpenGL context. Implement proper context switching and OpenGL
  locking. Only one context per window is supported. BGLView should be not
  deleted when window is closed, it deleted when deleting context.

diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index 56b1fa0..b8b9939 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -198,6 +198,10 @@ public:
     }
 
 #if SDL_VIDEO_OPENGL
+    BGLView *GetCurrentContext() {
+        return _current_context;
+    }
+    
     void SetCurrentContext(BGLView *newContext) {
         if(_current_context)
             _current_context->UnlockGL();
@@ -234,25 +238,22 @@ private:
         }
         win = GetSDLWindow(winID);
 
-		// Simple relative mode support for mouse.
-		if (SDL_GetMouse()->relative_mode) {
-			int winWidth, winHeight, winPosX, winPosY;
-			SDL_GetWindowSize(win, &winWidth, &winHeight);
-			SDL_GetWindowPosition(win, &winPosX, &winPosY);
-			int dx = x - (winWidth / 2);
-			int dy = y - (winHeight / 2);
-			SDL_SendMouseMotion(win, 0, SDL_GetMouse()->relative_mode, dx, dy);
-			set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
-			if (!be_app->IsCursorHidden())
-				be_app->HideCursor();
-		} else {
-			SDL_SendMouseMotion(win, 0, 0, x, y);
-			if (SDL_ShowCursor(-1) && be_app->IsCursorHidden())
-				be_app->ShowCursor();
-		}
-
-        /* Tell the application that the mouse passed over, redraw needed */
-        HAIKU_UpdateWindowFramebuffer(NULL,win,NULL,-1);
+        // Simple relative mode support for mouse.
+        if (SDL_GetMouse()->relative_mode) {
+            int winWidth, winHeight, winPosX, winPosY;
+            SDL_GetWindowSize(win, &winWidth, &winHeight);
+            SDL_GetWindowPosition(win, &winPosX, &winPosY);
+            int dx = x - (winWidth / 2);
+            int dy = y - (winHeight / 2);
+            SDL_SendMouseMotion(win, 0, SDL_GetMouse()->relative_mode, dx, dy);
+            set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
+            if (!be_app->IsCursorHidden())
+                be_app->HideCursor();
+        } else {
+            SDL_SendMouseMotion(win, 0, 0, x, y);
+            if (SDL_ShowCursor(-1) && be_app->IsCursorHidden())
+                be_app->ShowCursor();
+        }
     }
 
     void _HandleMouseButton(BMessage *msg) {
diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index dc6e442..2e947a1 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -39,7 +39,6 @@ extern "C" {
 #include <AppKit.h>
 #include <Cursor.h>
 #include <InterfaceKit.h>
-#include <game/DirectWindow.h>
 #if SDL_VIDEO_OPENGL
 #include <opengl/GLView.h>
 #endif
@@ -58,19 +57,47 @@ enum WinCommands {
     BWIN_SET_TITLE,
     BWIN_SET_BORDERED,
     BWIN_SET_RESIZABLE,
-    BWIN_FULLSCREEN
+    BWIN_FULLSCREEN,
+    BWIN_UPDATE_FRAMEBUFFER
 };
 
+// non-OpenGL framebuffer view
+class SDL_BView: public BView
+{
+public:
+    SDL_BView(BRect frame, const char* name, uint32 resizingMode)
+        : BView(frame, name, resizingMode, B_WILL_DRAW),
+        fBitmap(NULL)
+    {
+    }
+
+    void Draw(BRect dirty)
+    {
+        if (fBitmap != NULL)
+            DrawBitmap(fBitmap, B_ORIGIN);
+    }
+
+    void SetBitmap(BBitmap *bitmap)
+    {
+        fBitmap = bitmap;
+    }
+
+private:
+    BBitmap *fBitmap;
+};
 
-class SDL_BWin:public BDirectWindow
+class SDL_BWin: public BWindow
 {
   public:
     /* Constructor/Destructor */
     SDL_BWin(BRect bounds, window_look look, uint32 flags)
-        : BDirectWindow(bounds, "Untitled", look, B_NORMAL_WINDOW_FEEL, flags)
+        : BWindow(bounds, "Untitled", look, B_NORMAL_WINDOW_FEEL, flags)
     {
         _last_buttons = 0;
 
+        _cur_view = NULL;
+        _SDL_View = NULL;
+
 #if SDL_VIDEO_OPENGL
         _SDL_GLView = NULL;
         _gl_type = 0;
@@ -79,59 +106,88 @@ class SDL_BWin:public BDirectWindow
         _inhibit_resize = false;
         _mouse_focused = false;
         _prev_frame = NULL;
+        _fullscreen = NULL;
 
         /* Handle framebuffer stuff */
-        _connected = _connection_disabled = false;
-        _buffer_created = _buffer_dirty = false;
-        _trash_window_buffer = false;
         _buffer_locker = new BLocker();
         _bitmap = NULL;
-        _clips = NULL;
-        _num_clips = 0;
-
-#ifdef DRAWTHREAD
-        _draw_thread_id = spawn_thread(HAIKU_DrawThread, "drawing_thread",
-                            B_NORMAL_PRIORITY, (void*) this);
-        resume_thread(_draw_thread_id);
-#endif
     }
 
     virtual ~ SDL_BWin()
     {
         Lock();
-        _connection_disabled = true;
-        int32 result;
+        
+        if (_SDL_View != NULL && _SDL_View != _cur_view) {
+            delete _SDL_View;
+            _SDL_View = NULL;
+        }
 
 #if SDL_VIDEO_OPENGL
         if (_SDL_GLView) {
-            _SDL_GLView->UnlockGL();
-            RemoveChild(_SDL_GLView);   /* Why was this outside the if
-                                            statement before? */
+            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            if (_SDL_GLView == _cur_view)
+                RemoveChild(_SDL_GLView);
+            _SDL_GLView = NULL;
+            // _SDL_GLView deleted by HAIKU_GL_DeleteContext
         }
 
 #endif
         Unlock();
-#if SDL_VIDEO_OPENGL
-        if (_SDL_GLView) {
-            delete _SDL_GLView;
-        }
-#endif
 
         delete _prev_frame;
 
         /* Clean up framebuffer stuff */
         _buffer_locker->Lock();
-#ifdef DRAWTHREAD
-        wait_for_thread(_draw_thread_id, &result);
-#endif
-        SDL_free(_clips);
         delete _buffer_locker;
     }
+    
+    void SetCurrentView(BView *view)
+    {
+        if (_cur_view != view) {
+            if (_cur_view != NULL)
+                RemoveChild(_cur_view);
+            _cur_view = view;
+            if (_cur_view != NULL)
+                AddChild(_cur_view);
+        }
+    }
+
+    void UpdateCurrentView()
+    {
+        if (_SDL_GLView != NULL) {
+            SetCurrentView(_SDL_GLView);
+        } else if (_SDL_View != NULL) {
+            SetCurrentView(_SDL_View);
+        } else {
+            SetCurrentView(NULL);
+        }
+    }
+
+    SDL_BView *CreateView() {
+        Lock();
+        if (_SDL_View == NULL) {
+            _SDL_View = new SDL_BView(Bounds(), "SDL View", B_FOLLOW_ALL_SIDES);
+            UpdateCurrentView();
+        }
+        Unlock();
+        return _SDL_View;
+    }
 
+    void RemoveView() {
+        Lock();
+        if(_SDL_View != NULL) {
+            SDL_BView *oldView = _SDL_View;
+            _SDL_View = NULL;
+            UpdateCurrentView();
+            delete oldView;
+        }
+        Unlock();
+    }
 
     /* * * * * OpenGL functionality * * * * */
 #if SDL_VIDEO_OPENGL
-    virtual BGLView *CreateGLView(Uint32 gl_flags) {
+    BGLView *CreateGLView(Uint32 gl_flags) {
         Lock();
         if (_SDL_GLView == NULL) {
             _SDL_GLView = new BGLView(Bounds(), "SDL GLView",
@@ -139,92 +195,29 @@ class SDL_BWin:public BDirectWindow
                                      (B_WILL_DRAW | B_FRAME_EVENTS),
                                      gl_flags);
             _gl_type = gl_flags;
+            UpdateCurrentView();
         }
-        AddChild(_SDL_GLView);
-        _SDL_GLView->EnableDirectMode(false); /* Disable direct mode */
-        _SDL_GLView->LockGL();  /* "New" GLViews are created */
         Unlock();
-        return (_SDL_GLView);
+        return _SDL_GLView;
     }
 
-    virtual void RemoveGLView() {
+    void RemoveGLView() {
         Lock();
-        if(_SDL_GLView) {
-            _SDL_GLView->UnlockGL();
-            RemoveChild(_SDL_GLView);
+        if(_SDL_GLView != NULL) {
+            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            _SDL_GLView = NULL;
+            UpdateCurrentView();
+            // _SDL_GLView deleted by HAIKU_GL_DeleteContext
         }
         Unlock();
     }
 
-    virtual void SwapBuffers(void) {
-        _SDL_GLView->UnlockGL();
-        _SDL_GLView->LockGL();
+    void SwapBuffers(void) {
         _SDL_GLView->SwapBuffers();
     }
 #endif
 
-    /* * * * * Framebuffering* * * * */
-    virtual void DirectConnected(direct_buffer_info *info) {
-        if(!_connected && _connection_disabled) {
-            return;
-        }
-
-        /* Determine if the pixel buffer is usable after this update */
-        _trash_window_buffer =      _trash_window_buffer
-                                || ((info->buffer_state & B_BUFFER_RESIZED)
-                                || (info->buffer_state & B_BUFFER_RESET)
-                                || (info->driver_state == B_MODE_CHANGED));
-        LockBuffer();
-
-        switch(info->buffer_state & B_DIRECT_MODE_MASK) {
-        case B_DIRECT_START:
-            _connected = true;
-
-        case B_DIRECT_MODIFY:
-            if (info->clip_list_count > _num_clips)
-            {
-                if(_clips) {
-                    SDL_free(_clips);
-                    _clips = NULL;
-                }
-            }
-
-            _num_clips = info->clip_list_count;
-            if (_clips == NULL)
-                _clips = (clipping_rect *)SDL_malloc(_num_clips*sizeof(clipping_rect));
-            if(_clips) {
-                SDL_memcpy(_clips, info->clip_list,
-                    _num_clips*sizeof(clipping_rect));
-
-                _bits = (uint8*) info->bits;
-                _row_bytes = info->bytes_per_row;
-                _bounds = info->window_bounds;
-                _bytes_per_px = info->bits_per_pixel / 8;
-                _buffer_dirty = true;
-            }
-            break;
-
-        case B_DIRECT_STOP:
-            _connected = false;
-            break;
-        }
-#if SDL_VIDEO_OPENGL
-        if(_SDL_GLView) {
-            _SDL_GLView->DirectConnected(info);
-        }
-#endif
-
-
-        /* Call the base object directconnected */
-        BDirectWindow::DirectConnected(info);
-
-        UnlockBuffer();
-
-    }
-
-
-
-
     /* * * * * Event sending * * * * */
     /* Hook functions */
     virtual void FrameMoved(BPoint origin) {
@@ -235,10 +228,10 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
 
         /* Perform normal hook operations */
-        BDirectWindow::FrameMoved(origin);
+        BWindow::FrameMoved(origin);
     }
 
-    virtual void FrameResized(float width, float height) {
+    void FrameResized(float width, float height) {
         /* Post a message to the BApp so that it can handle the window event */
         BMessage msg(BAPP_WINDOW_RESIZED);
 
@@ -247,10 +240,10 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
 
         /* Perform normal hook operations */
-        BDirectWindow::FrameResized(width, height);
+        BWindow::FrameResized(width, height);
     }
 
-    virtual bool QuitRequested() {
+    bool QuitRequested() {
         BMessage msg(BAPP_WINDOW_CLOSE_REQUESTED);
         _PostWindowEvent(msg);
 
@@ -258,13 +251,13 @@ class SDL_BWin:public BDirectWindow
         return false;
     }
 
-    virtual void WindowActivated(bool active) {
+    void WindowActivated(bool active) {
         BMessage msg(BAPP_KEYBOARD_FOCUS);  /* Mouse focus sold separately */
         msg.AddBool("focusGained", active);
         _PostWindowEvent(msg);
     }
 
-    virtual void Zoom(BPoint origin,
+    void Zoom(BPoint origin,
                 float width,
                 float height) {
         BMessage msg(BAPP_MAXIMIZE);    /* Closest thing to maximization Haiku has */
@@ -275,13 +268,13 @@ class SDL_BWin:public BDirectWindow
             _prev_frame = new BRect(Frame());
 
         /* Perform normal hook operations */
-        BDirectWindow::Zoom(origin, width, height);
+        BWindow::Zoom(origin, width, height);
     }
 
     /* Member functions */
-    virtual void Show() {
+    void Show() {
         while(IsHidden()) {
-            BDirectWindow::Show();
+            BWindow::Show();
         }
         _shown = true;
 
@@ -289,25 +282,33 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
     }
 
-    virtual void Hide() {
-        BDirectWindow::Hide();
+    void Hide() {
+        BWindow::Hide();
         _shown = false;
 
         BMessage msg(BAPP_HIDE);
         _PostWindowEvent(msg);
     }
 
-    virtual void Minimize(bool minimize) {
-        BDirectWindow::Minimize(minimize);
+    void Minimize(bool minimize) {
+        BWindow::Minimize(minimize);
         int32 minState = (minimize ? BAPP_MINIMIZE : BAPP_RESTORE);
 
         BMessage msg(minState);
         _PostWindowEvent(msg);
     }
 
+    void ScreenChanged(BRect screenFrame, color_space depth)
+    {
+        if (_fullscreen) {
+            MoveTo(screenFrame.left, screenFrame.top);
+            ResizeTo(screenFrame.Width(), screenFrame.Height());
+        }
+    }
+
 
     /* BView message interruption */
-    virtual void DispatchMessage(BMessage * msg, BHandler * target)
+    void DispatchMessage(BMessage * msg, BHandler * target)
     {
         BPoint where;   /* Used by mouse moved */
         int32 buttons;  /* Used for mouse button events */
@@ -356,7 +357,7 @@ class SDL_BWin:public BDirectWindow
                 }
             }
             break;
-            
+
         case B_UNMAPPED_KEY_DOWN:      /* modifier keys are unmapped */
             if (msg->FindInt32("key", &key) == B_OK) {
                 _KeyEvent((SDL_Scancode)key, NULL, 0, SDL_PRESSED);
@@ -376,15 +377,15 @@ class SDL_BWin:public BDirectWindow
                - CTRL+Q to close window (and other shortcuts)
                - PrintScreen to make screenshot into /boot/home
                - etc.. */
-            /* BDirectWindow::DispatchMessage(msg, target); */
+            /* BWindow::DispatchMessage(msg, target); */
             break;
         }
 
-        BDirectWindow::DispatchMessage(msg, target);
+        BWindow::DispatchMessage(msg, target);
     }
 
     /* Handle command messages */
-    virtual void MessageReceived(BMessage* message) {
+    void MessageReceived(BMessage* message) {
         switch (message->what) {
             /* Handle commands from SDL */
             case BWIN_SET_TITLE:
@@ -396,12 +397,18 @@ class SDL_BWin:public BDirectWindow
             case BWIN_RESIZE_WINDOW:
                 _ResizeTo(message);
                 break;
-            case BWIN_SET_BORDERED:
-                _SetBordered(message);
+            case BWIN_SET_BORDERED: {
+                bool bEnabled;
+                if (message->FindBool("window-border", &bEnabled) == B_OK)
+                    _SetBordered(bEnabled);
                 break;
-            case BWIN_SET_RESIZABLE:
-                _SetResizable(message);
+            }
+            case BWIN_SET_RESIZABLE: {
+                bool bEnabled;
+                if (message->FindBool("window-resizable", &bEnabled) == B_OK)
+                    _SetResizable(bEnabled);
                 break;
+            }
             case BWIN_SHOW_WINDOW:
                 Show();
                 break;
@@ -417,12 +424,31 @@ class SDL_BWin:public BDirectWindow
             case BWIN_RESTORE_WINDOW:
                 _Restore();
                 break;
-            case BWIN_FULLSCREEN:
-                _SetFullScreen(message);
+            case BWIN_FULLSCREEN: {
+                bool fullscreen;
+                if (message->FindBool("fullscreen", &fullscreen) == B_OK)
+                    _SetFullScreen(fullscreen);
                 break;
+            }
+            case BWIN_UPDATE_FRAMEBUFFER: {
+                BMessage* pendingMessage;
+                while ((pendingMessage
+                                = MessageQueue()->FindMessage(BWIN_UPDATE_FRAMEBUFFER, 0))) {
+                        MessageQueue()->RemoveMessage(pendingMessage);
+                        delete pendingMessage;
+                }
+                if (_bitmap != NULL) {
+                    if (_SDL_View != NULL && _cur_view == _SDL_View)
+                        _SDL_View->Draw(Bounds());
+                    else if (_SDL_GLView != NULL && _cur_view == _SDL_GLView) {
+                        _SDL_GLView->CopyPixelsIn(_bitmap, B_ORIGIN);
+                    }
+                }
+                break;
+            }
             default:
                 /* Perform normal message handling */
-                BDirectWindow::MessageReceived(message);
+                BWindow::MessageReceived(message);
                 break;
         }
 
@@ -433,19 +459,9 @@ class SDL_BWin:public BDirectWindow
     /* Accessor methods */
     bool IsShown() { return _shown; }
     int32 GetID() { return _id; }
-    uint32 GetRowBytes() { return _row_bytes; }
-    int32 GetFbX() { return _bounds.left; }
-    int32 GetFbY() { return _bounds.top; }
-    bool ConnectionEnabled() { return !_connection_disabled; }
-    bool Connected() { return _connected; }
-    clipping_rect *GetClips() { return _clips; }
-    int32 GetNumClips() { return _num_clips; }
-    uint8* GetBufferPx() { return _bits; }
-    int32 GetBytesPerPx() { return _bytes_per_px; }
-    bool CanTrashWindowBuffer() { return _trash_window_buffer; }
-    bool BufferExists() { return _buffer_created; }
-    bool BufferIsDirty() { return _buffer_dirty; }
     BBitmap *GetBitmap() { return _bitmap; }
+    BView *GetCurView() { return _cur_view; }
+    SDL_BView *GetView() { return _SDL_View; }
 #if SDL_VIDEO_OPENGL
     BGLView *GetGLView() { return _SDL_GLView; }
     Uint32 GetGLType() { return _gl_type; }
@@ -453,12 +469,9 @@ class SDL_BWin:public BDirectWindow
 
     /* Setter methods */
     void SetID(int32 id) { _id = id; }
-    void SetBufferExists(bool bufferExists) { _buffer_created = bufferExists; }
     void LockBuffer() { _buffer_locker->Lock(); }
     void UnlockBuffer() { _buffer_locker->Unlock(); }
-    void SetBufferDirty(bool bufferDirty) { _buffer_dirty = bufferDirty; }
-    void SetTrashBuffer(bool trash) { _trash_window_buffer = trash;     }
-    void SetBitmap(BBitmap *bitmap) { _bitmap = bitmap; }
+    void SetBitmap(BBitmap *bitmap) { _bitmap = bitmap; if (_SDL_View != NULL) _SDL_View->SetBitmap(bitmap); }
 
 
 private:
@@ -564,7 +577,10 @@ private:
         ) {
             return;
         }
-        MoveTo(x, y);
+        if (_fullscreen)
+            _non_fullscreen_frame.OffsetTo(x, y);
+        else
+            MoveTo(x, y);
     }
 
     void _ResizeTo(BMessage *msg) {
@@ -575,26 +591,29 @@ private:
         ) {
             return;
         }
-        ResizeTo(w, h);
+        if (_fullscreen) {
+            _non_fullscreen_frame.right = _non_fullscreen_frame.left + w;
+            _non_fullscreen_frame.bottom = _non_fullscreen_frame.top + h;
+        } else
+            ResizeTo(w, h);
     }
 
-    void _SetBordered(BMessage *msg) {
-        bool bEnabled;
-        if(msg->FindBool("window-border", &bEnabled) != B_OK) {
-            return;
-        }
-        SetLook(bEnabled ? B_TITLED_WINDOW_LOOK : B_NO_BORDER_WINDOW_LOOK);
+    void _SetBordered(bool bEnabled) {
+        if (_fullscreen)
+            _bordered = bEnabled;
+        else
+            SetLook(bEnabled ? B_TITLED_WINDOW_LOOK : B_NO_BORDER_WINDOW_LOOK);
     }
 
-    void _SetResizable(BMessage *msg) {
-        bool bEnabled;
-        if(msg->FindBool("window-resizable", &bEnabled) != B_OK) {
-            return;
-        }
-        if (bEnabled) {
-            SetFlags(Flags() & ~(B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
-        } else {
-            SetFlags(Flags() | (B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+    void _SetResizable(bool bEnabled) {
+        if (_fullscreen)
+            _resizable = bEnabled;
+        else {
+            if (bEnabled) {
+                SetFlags(Flags() & ~(B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+            } else {
+                SetFlags(Flags() | (B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+            }
         }
     }
 
@@ -603,23 +622,42 @@ private:
             Minimize(false);
         } else if(IsHidden()) {
             Show();
+        } else if (_fullscreen) {
+
         } else if(_prev_frame != NULL) {    /* Zoomed */
             MoveTo(_prev_frame->left, _prev_frame->top);
             ResizeTo(_prev_frame->Width(), _prev_frame->Height());
         }
     }
 
-    void _SetFullScreen(BMessage *msg) {
-        bool fullscreen;
-        if(
-            msg->FindBool("fullscreen", &fullscreen) != B_OK
-        ) {
-            return;
+    void _SetFullScreen(bool fullscreen) {
+        if (fullscreen != _fullscreen) {
+            if (fullscreen) {
+                BScreen screen(this);
+                BRect screenFrame = screen.Frame();
+                printf("screen frame: "); screenFrame.PrintToStream(); printf("\n");
+                _bordered = Look() != B_NO_BORDER_WINDOW_LOOK;
+                _resizable = !(Flags() & B_NOT_RESIZABLE);
+                _non_fullscreen_frame = Frame();
+                _SetBordered(false);
+                _SetResizable(false);
+                MoveTo(screenFrame.left, screenFrame.top);
+                ResizeTo(screenFrame.Width(), screenFrame.Height());
+                _fullscreen = fullscreen;
+            } else {
+                _fullscreen = fullscreen;
+                MoveTo(_non_fullscreen_frame.left, _non_fullscreen_frame.top);
+                ResizeTo(_non_fullscreen_frame.Width(), _non_fullscreen_frame.Height());
+                _SetBordered(_bordered);
+                _SetResizable(_resizable);
+            }
         }
-        SetFullScreen(fullscreen);
     }
 
     /* Members */
+
+    BView* _cur_view;
+    SDL_BView* _SDL_View;
 #if SDL_VIDEO_OPENGL
     BGLView * _SDL_GLView;
     Uint32 _gl_type;
@@ -632,23 +670,15 @@ private:
     bool  _inhibit_resize;
 
     BRect *_prev_frame; /* Previous position and size of the window */
+    bool _fullscreen;
+    // valid only if fullscreen
+    BRect _non_fullscreen_frame;
+    bool _bordered;
+    bool _resizable;
 
     /* Framebuffer members */
-    bool            _connected,
-                    _connection_disabled,
-                    _buffer_created,
-                    _buffer_dirty,
-                    _trash_window_buffer;
-    uint8          *_bits;
-    uint32          _row_bytes;
-    clipping_rect   _bounds;
-    BLocker        *_buffer_locker;
-    clipping_rect  *_clips;
-    uint32          _num_clips;
-    int32           _bytes_per_px;
-    thread_id       _draw_thread_id;
-
-    BBitmap        *_bitmap;
+    BLocker *_buffer_locker;
+    BBitmap *_bitmap;
 };
 
 
diff --git a/src/video/haiku/SDL_bframebuffer.cc b/src/video/haiku/SDL_bframebuffer.cc
index c1017eb..9712319 100644
--- a/src/video/haiku/SDL_bframebuffer.cc
+++ b/src/video/haiku/SDL_bframebuffer.cc
@@ -35,10 +35,6 @@
 extern "C" {
 #endif
 
-#ifndef DRAWTHREAD
-static int32 HAIKU_UpdateOnce(SDL_Window *window);
-#endif
-
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
     return ((SDL_BWin*)(window->driverdata));
 }
@@ -56,11 +52,11 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
         return -1;
     }
 
-    while(!bwin->Connected()) { snooze(100); }
-    
     /* Make sure we have exclusive access to frame buffer data */
     bwin->LockBuffer();
 
+    bwin->CreateView();
+
     /* format */
     display_mode bmode;
     bscreen.GetMode(&bmode);
@@ -76,7 +72,7 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
     bitmap = new BBitmap(bwin->Bounds(), (color_space)bmode.space,
             false,    /* Views not accepted */
             true);    /* Contiguous memory required */
-            
+
     if(bitmap->InitCheck() != B_OK) {
         delete bitmap;
         return SDL_SetError("Could not initialize back buffer!");
@@ -84,15 +80,13 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
 
 
     bwin->SetBitmap(bitmap);
-    
+
     /* Set the pixel pointer */
     *pixels = bitmap->Bits();
 
     /* pitch = width of window, in bytes */
     *pitch = bitmap->BytesPerRow();
 
-    bwin->SetBufferExists(true);
-    bwin->SetTrashBuffer(false);
     bwin->UnlockBuffer();
     return 0;
 }
@@ -106,149 +100,25 @@ int HAIKU_UpdateWindowFramebuffer(_THIS, SDL_Window * window,
 
     SDL_BWin *bwin = _ToBeWin(window);
 
-#ifdef DRAWTHREAD    
-    bwin->LockBuffer();
-    bwin->SetBufferDirty(true);
-    bwin->UnlockBuffer();
-#else
-    bwin->SetBufferDirty(true);
-    HAIKU_UpdateOnce(window);
-#endif
+    bwin->PostMessage(BWIN_UPDATE_FRAMEBUFFER);
 
     return 0;
 }
 
-int32 HAIKU_DrawThread(void *data) {
-    SDL_BWin *bwin = (SDL_BWin*)data;
-    
-    BScreen bscreen;
-    if(!bscreen.IsValid()) {
-        return -1;
-    }
-
-    while(bwin->ConnectionEnabled()) {
-        if( bwin->Connected() && bwin->BufferExists() && bwin->BufferIsDirty() ) {
-            bwin->LockBuffer();
-            BBitmap *bitmap = NULL;
-            bitmap = bwin->GetBitmap();
-            int32 windowPitch = bitmap->BytesPerRow();
-            int32 bufferPitch = bwin->GetRowBytes();
-            uint8 *windowpx;
-            uint8 *bufferpx;
-
-            int32 BPP = bwin->GetBytesPerPx();
-            int32 windowSub = bwin->GetFbX() * BPP +
-                          bwin->GetFbY() * windowPitch;
-            clipping_rect *clips = bwin->GetClips();
-            int32 numClips = bwin->GetNumClips();
-            int i, y;
-
-            /* Blit each clipping rectangle */
-            bscreen.WaitForRetrace();
-            for(i = 0; i < numClips; ++i) {
-                /* Get addresses of the start of each clipping rectangle */
-                int32 width = clips[i].right - clips[i].left + 1;
-                int32 height = clips[i].bottom - clips[i].top + 1;
-                bufferpx = bwin->GetBufferPx() + 
-                    clips[i].top * bufferPitch + clips[i].left * BPP;
-                windowpx = (uint8*)bitmap->Bits() + 
-                    clips[i].top * windowPitch + clips[i].left * BPP -
-                    windowSub;
-
-                /* Copy each row of pixels from the window buffer into the frame
-                   buffer */
-                for(y = 0; y < height; ++y)
-                {
-
-                    if(bwin->CanTrashWindowBuffer()) {
-                        goto escape;    /* Break out before the buffer is killed */
-                    }
-
-                    memcpy(bufferpx, windowpx, width * BPP);
-                    bufferpx += bufferPitch;
-                    windowpx += windowPitch;
-                }
-            }
-
-            bwin->SetBufferDirty(false);
-escape:
-            bwin->UnlockBuffer();
-        } else {
-            snooze(16000);
-        }
-    }
-    
-    return B_OK;
-}
-
 void HAIKU_DestroyWindowFramebuffer(_THIS, SDL_Window * window) {
     SDL_BWin *bwin = _ToBeWin(window);
-    
+
     bwin->LockBuffer();
-    
+
     /* Free and clear the window buffer */
     BBitmap *bitmap = bwin->GetBitmap();
     delete bitmap;
     bwin->SetBitmap(NULL);
-    bwin->SetBufferExists(false);
-    bwin->UnlockBuffer();
-}
 
+    bwin->RemoveView();
 
-/*
- * TODO:
- * This was written to test if certain errors were caused by threading issues.
- * The specific issues have since become rare enough that they may have been
- * solved, but I doubt it- they were pretty sporadic before now.
- */
-#ifndef DRAWTHREAD
-static int32 HAIKU_UpdateOnce(SDL_Window *window) {
-    SDL_BWin *bwin = _ToBeWin(window);
-    BScreen bscreen;
-    if(!bscreen.IsValid()) {
-        return -1;
-    }
-
-    if(bwin->ConnectionEnabled() && bwin->Connected()) {
-        bwin->LockBuffer();
-        int32 windowPitch = window->surface->pitch;
-        int32 bufferPitch = bwin->GetRowBytes();
-        uint8 *windowpx;
-        uint8 *bufferpx;
-
-        int32 BPP = bwin->GetBytesPerPx();
-        uint8 *windowBaseAddress = (uint8*)window->surface->pixels;
-        int32 windowSub = bwin->GetFbX() * BPP +
-                          bwin->GetFbY() * windowPitch;
-        clipping_rect *clips = bwin->GetClips();
-        int32 numClips = bwin->GetNumClips();
-        int i, y;
-
-        /* Blit each clipping rectangle */
-        bscreen.WaitForRetrace();
-        for(i = 0; i < numClips; ++i) {
-            /* Get addresses of the start of each clipping rectangle */
-            int32 width = clips[i].right - clips[i].left + 1;
-            int32 height = clips[i].bottom - clips[i].top + 1;
-            bufferpx = bwin->GetBufferPx() + 
-                clips[i].top * bufferPitch + clips[i].left * BPP;
-            windowpx = windowBaseAddress + 
-                clips[i].top * windowPitch + clips[i].left * BPP - windowSub;
-
-            /* Copy each row of pixels from the window buffer into the frame
-               buffer */
-            for(y = 0; y < height; ++y)
-            {
-                memcpy(bufferpx, windowpx, width * BPP);
-                bufferpx += bufferPitch;
-                windowpx += windowPitch;
-            }
-        }
-        bwin->UnlockBuffer();
-    }
-    return 0;
+    bwin->UnlockBuffer();
 }
-#endif
 
 #ifdef __cplusplus
 }
diff --git a/src/video/haiku/SDL_bopengl.cc b/src/video/haiku/SDL_bopengl.cc
index e221177..c88cb37 100644
--- a/src/video/haiku/SDL_bopengl.cc
+++ b/src/video/haiku/SDL_bopengl.cc
@@ -84,16 +84,21 @@ void *HAIKU_GL_GetProcAddress(_THIS, const char *proc)
 }
 
 
-
-
 int HAIKU_GL_SwapWindow(_THIS, SDL_Window * window) {
     _ToBeWin(window)->SwapBuffers();
     return 0;
 }
 
 int HAIKU_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context) {
-    SDL_BWin* win = (SDL_BWin*)context;
-    _GetBeApp()->SetCurrentContext(win ? win->GetGLView() : NULL);
+    BGLView* glView = (BGLView*)context;
+    // printf("HAIKU_GL_MakeCurrent(%llx), win = %llx, thread = %d\n", (uint64)context, (uint64)window, find_thread(NULL));
+    if (glView != NULL) {
+        if ((glView->Window() == NULL) || (window == NULL) || (_ToBeWin(window)->GetGLView() != glView)) {
+            SDL_SetError("MakeCurrent failed");
+            return -1;
+        }
+    }
+    _GetBeApp()->SetCurrentContext(glView);
     return 0;
 }
 
@@ -102,6 +107,11 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
     /* FIXME: Not sure what flags should be included here; may want to have
        most of them */
     SDL_BWin *bwin = _ToBeWin(window);
+    // printf("HAIKU_GL_CreateContext, win = %llx, thread = %d\n", (uint64)window, find_thread(NULL));
+    if (bwin->GetGLView() != NULL) {
+        SDL_SetError("Context already creaded");
+        return NULL;
+    }
     Uint32 gl_flags = BGL_RGB;
     if (_this->gl_config.alpha_size) {
         gl_flags |= BGL_ALPHA;
@@ -123,13 +133,23 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
             _this->gl_config.accum_alpha_size) {
         gl_flags |= BGL_ACCUM;
     }
+    if (_this->gl_config.share_with_current_context) {
+        gl_flags |= BGL_SHARE_CONTEXT;
+    }
     bwin->CreateGLView(gl_flags);
-    return (SDL_GLContext)(bwin);
+    _GetBeApp()->SetCurrentContext(bwin->GetGLView());
+    return (SDL_GLContext)(bwin->GetGLView());
 }
 
 void HAIKU_GL_DeleteContext(_THIS, SDL_GLContext context) {
-    /* Currently, automatically unlocks the view */
-    ((SDL_BWin*)context)->RemoveGLView();
+    // printf("HAIKU_GL_DeleteContext(%llx), thread = %d\n", (uint64)context, find_thread(NULL));
+    BGLView* glView = (BGLView*)context;
+    SDL_BWin *bwin = (SDL_BWin*)glView->Window();
+    if (bwin == NULL) {
+        delete glView;
+    } else {
+        bwin->RemoveGLView();
+    }
 }
 
 
-- 
2.30.2


From 4ef52eb6914e58a27852f54ccc0bafc30e749bef Mon Sep 17 00:00:00 2001
From: Augustin Cavalier <waddlesplash@gmail.com>
Date: Tue, 11 Jan 2022 17:15:28 -0500
Subject: RelativeMouseMode: B_KEYBOARD_EVENTS is not needed.


diff --git a/src/video/haiku/SDL_bvideo.cc b/src/video/haiku/SDL_bvideo.cc
index 77259f9..5551e92 100644
--- a/src/video/haiku/SDL_bvideo.cc
+++ b/src/video/haiku/SDL_bvideo.cc
@@ -222,7 +222,7 @@ HAIKU_SetRelativeMouseMode(SDL_bool enabled)
 
 	bewin->Lock();
 	if (enabled)
-		_SDL_GLView->SetEventMask(B_POINTER_EVENTS | B_KEYBOARD_EVENTS, B_NO_POINTER_HISTORY);
+		_SDL_GLView->SetEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);
 	else
 		_SDL_GLView->SetEventMask(0, 0);
 	bewin->Unlock();
-- 
2.30.2


From 6f207f42d1fb2e5757c8da43f38871853e0a23ed Mon Sep 17 00:00:00 2001
From: Pascal Abresch <nep@packageloss.eu>
Date: Mon, 15 Nov 2021 16:32:58 +0100
Subject: Implement SDL_SendDropFile for opening files with RefsReceived


diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index b8b9939..215f836 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -21,6 +21,7 @@
 #ifndef SDL_BAPP_H
 #define SDL_BAPP_H
 
+#include <Path.h>
 #include <InterfaceKit.h>
 #include <LocaleRoster.h>
 #if SDL_VIDEO_OPENGL
@@ -93,6 +94,15 @@ public:
     }
 
 
+	virtual void RefsReceived(BMessage* message) {
+		char filePath[512];
+		entry_ref entryRef;
+		for (int32 i = 0; message->FindRef("refs", i, &entryRef) == B_OK; i++) {
+			BPath referencePath = BPath(&entryRef);
+			SDL_SendDropFile(NULL, referencePath.Path());
+		}
+		return;
+	}
 
         /* Event-handling functions */
     virtual void MessageReceived(BMessage* message) {
@@ -301,7 +311,7 @@ private:
         }
         HAIKU_SetKeyState(scancode, state);
         SDL_SendKeyboardKey(state, HAIKU_GetScancodeFromBeKey(scancode));
-        
+
         if (state == SDL_PRESSED && SDL_EventState(SDL_TEXTINPUT, SDL_QUERY)) {
             const int8 *keyUtf8;
             ssize_t count;
-- 
2.30.2


From 149b1ae3ea1399ea7de0b390c246291bbea7d975 Mon Sep 17 00:00:00 2001
From: Pascal Abresch <nep@packageloss.eu>
Date: Sat, 4 Dec 2021 10:08:01 +0100
Subject: SDL2: implement minimum window size for Haiku


diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index 2e947a1..1ac5171 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -58,7 +58,8 @@ enum WinCommands {
     BWIN_SET_BORDERED,
     BWIN_SET_RESIZABLE,
     BWIN_FULLSCREEN,
-    BWIN_UPDATE_FRAMEBUFFER
+    BWIN_UPDATE_FRAMEBUFFER,
+    BWIN_MINIMUM_SIZE_WINDOW
 };
 
 // non-OpenGL framebuffer view
@@ -430,6 +431,9 @@ class SDL_BWin: public BWindow
                     _SetFullScreen(fullscreen);
                 break;
             }
+            case BWIN_MINIMUM_SIZE_WINDOW:
+                _SetMinimumSize(message);
+                break;
             case BWIN_UPDATE_FRAMEBUFFER: {
                 BMessage* pendingMessage;
                 while ((pendingMessage
@@ -617,6 +621,24 @@ private:
         }
     }
 
+    void _SetMinimumSize(BMessage *msg) {
+        float maxHeight;
+        float maxWidth;
+        float _;
+        int32 minHeight;
+        int32 minWidth;
+
+        // This is a bit convoluted, we only want to set the minimum not the maximum
+        // But there is no direct call to do that, so store the maximum size beforehand
+        GetSizeLimits(&_, &maxWidth, &_, &maxHeight);
+        if (msg->FindInt32("window-w", &minWidth) != B_OK)
+            return;
+        if (msg->FindInt32("window-h", &minHeight) != B_OK)
+            return;
+        SetSizeLimits((float)minWidth, maxWidth, (float)minHeight, maxHeight);
+        UpdateSizeLimits();
+    }
+
     void _Restore() {
         if(IsMinimized()) {
             Minimize(false);
diff --git a/src/video/haiku/SDL_bvideo.cc b/src/video/haiku/SDL_bvideo.cc
index 5551e92..ca9dcad 100644
--- a/src/video/haiku/SDL_bvideo.cc
+++ b/src/video/haiku/SDL_bvideo.cc
@@ -94,6 +94,7 @@ HAIKU_CreateDevice(int devindex)
     device->SetWindowGammaRamp = HAIKU_SetWindowGammaRamp;
     device->GetWindowGammaRamp = HAIKU_GetWindowGammaRamp;
     device->SetWindowMouseGrab = HAIKU_SetWindowMouseGrab;
+    device->SetWindowMinimumSize = HAIKU_SetWindowMinimumSize;
     device->DestroyWindow = HAIKU_DestroyWindow;
     device->GetWindowWMInfo = HAIKU_GetWindowWMInfo;
     device->CreateWindowFramebuffer = HAIKU_CreateWindowFramebuffer;
diff --git a/src/video/haiku/SDL_bwindow.cc b/src/video/haiku/SDL_bwindow.cc
index 57aba17..587affa 100644
--- a/src/video/haiku/SDL_bwindow.cc
+++ b/src/video/haiku/SDL_bwindow.cc
@@ -205,6 +205,13 @@ int HAIKU_GetWindowGammaRamp(_THIS, SDL_Window * window, Uint16 * ramp) {
 }
 
 
+void HAIKU_SetWindowMinimumSize(_THIS, SDL_Window * window){
+    BMessage msg(BWIN_MINIMUM_SIZE_WINDOW);
+    msg.AddInt32("window-w", window->w -1);
+    msg.AddInt32("window-h", window->h -1);
+    _ToBeWin(window)->PostMessage(&msg);
+}
+
 void HAIKU_SetWindowMouseGrab(_THIS, SDL_Window * window, SDL_bool grabbed) {
     /* TODO: Implement this! */
 }
diff --git a/src/video/haiku/SDL_bwindow.h b/src/video/haiku/SDL_bwindow.h
index 1d6a3c5..58a85d8 100644
--- a/src/video/haiku/SDL_bwindow.h
+++ b/src/video/haiku/SDL_bwindow.h
@@ -32,6 +32,7 @@ extern void HAIKU_SetWindowTitle(_THIS, SDL_Window * window);
 extern void HAIKU_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon);
 extern void HAIKU_SetWindowPosition(_THIS, SDL_Window * window);
 extern void HAIKU_SetWindowSize(_THIS, SDL_Window * window);
+extern void HAIKU_SetWindowMinimumSize(_THIS, SDL_Window * window);
 extern void HAIKU_ShowWindow(_THIS, SDL_Window * window);
 extern void HAIKU_HideWindow(_THIS, SDL_Window * window);
 extern void HAIKU_RaiseWindow(_THIS, SDL_Window * window);
-- 
2.30.2


From 3f46b5af458225ade3396a916634afc01cc1e912 Mon Sep 17 00:00:00 2001
From: Augustin Cavalier <waddlesplash@gmail.com>
Date: Tue, 11 Jan 2022 17:45:29 -0500
Subject: Only expect BGL_SHARE_CONTEXT on __GNUC__ > 3.


diff --git a/src/video/haiku/SDL_bopengl.cc b/src/video/haiku/SDL_bopengl.cc
index c88cb37..0c7a704 100644
--- a/src/video/haiku/SDL_bopengl.cc
+++ b/src/video/haiku/SDL_bopengl.cc
@@ -133,9 +133,11 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
             _this->gl_config.accum_alpha_size) {
         gl_flags |= BGL_ACCUM;
     }
+#if __GNUC__ > 3
     if (_this->gl_config.share_with_current_context) {
         gl_flags |= BGL_SHARE_CONTEXT;
     }
+#endif
     bwin->CreateGLView(gl_flags);
     _GetBeApp()->SetCurrentContext(bwin->GetGLView());
     return (SDL_GLContext)(bwin->GetGLView());
-- 
2.30.2


From 2e8f679de3a93db589b0bdb06956c24b3969bf40 Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Wed, 12 Jan 2022 11:59:06 +1000
Subject: Workaround for gcc2


diff --git a/src/stdlib/SDL_string.c b/src/stdlib/SDL_string.c
index 12cc2da..bc46aec 100644
--- a/src/stdlib/SDL_string.c
+++ b/src/stdlib/SDL_string.c
@@ -34,6 +34,10 @@
 #define va_copy(dst, src)   dst = src
 #endif
 
+#if __GNUC__ == 2
+#define va_copy(to, from)   __va_copy(to, from)
+#endif
+
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOL) || !defined(HAVE_STRTOUL) || !defined(HAVE_STRTOD) || !defined(HAVE_STRTOLL) || !defined(HAVE_STRTOULL)
 #define SDL_isupperhex(X)   (((X) >= 'A') && ((X) <= 'F'))
 #define SDL_islowerhex(X)   (((X) >= 'a') && ((X) <= 'f'))
-- 
2.30.2


From 03a86351cd3d9078e7e0eec44e448e3552b3db80 Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Sun, 12 Dec 2021 10:07:47 +1000
Subject: Add bitmap cursor support


diff --git a/src/video/haiku/SDL_bvideo.cc b/src/video/haiku/SDL_bvideo.cc
index ca9dcad..1ac3201 100644
--- a/src/video/haiku/SDL_bvideo.cc
+++ b/src/video/haiku/SDL_bvideo.cc
@@ -191,6 +191,31 @@ HAIKU_FreeCursor(SDL_Cursor * cursor)
     SDL_free(cursor);
 }
 
+static SDL_Cursor *
+HAIKU_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
+{
+    SDL_Cursor *cursor;
+    SDL_Surface *converted;
+
+    converted = SDL_ConvertSurfaceFormat(surface, SDL_PIXELFORMAT_ARGB8888, 0);
+    if (!converted) {
+        return NULL;
+    }
+
+	BBitmap *cursorBitmap = new BBitmap(BRect(0, 0, surface->w - 1, surface->h - 1), B_RGBA32);
+	cursorBitmap->SetBits(converted->pixels, converted->h * converted->pitch, 0, B_RGBA32);
+    SDL_FreeSurface(converted);
+
+    cursor = (SDL_Cursor *) SDL_calloc(1, sizeof(*cursor));
+    if (cursor) {
+        cursor->driverdata = (void *)new BCursor(cursorBitmap, BPoint(hot_x, hot_y));
+    } else {
+        return NULL;
+    }
+
+    return cursor;
+}
+
 static int HAIKU_ShowCursor(SDL_Cursor *cursor)
 {
 	SDL_Mouse *mouse = SDL_GetMouse();
@@ -236,6 +261,7 @@ static void HAIKU_MouseInit(_THIS)
 	SDL_Mouse *mouse = SDL_GetMouse();
 	if (!mouse)
 		return;
+	mouse->CreateCursor = HAIKU_CreateCursor;
 	mouse->CreateSystemCursor = HAIKU_CreateSystemCursor;
 	mouse->ShowCursor = HAIKU_ShowCursor;
 	mouse->FreeCursor = HAIKU_FreeCursor;
-- 
2.30.2


From ab6dfb1b1f57e780cab134a67db3600c4e350a5e Mon Sep 17 00:00:00 2001
From: Ivan Holmes <ivan@ivanholmes.co.uk>
Date: Sat, 7 May 2022 22:10:49 +0100
Subject: Move stuff to devicedata


diff --git a/src/audio/haiku/SDL_haikuaudio.cc b/src/audio/haiku/SDL_haikuaudio.cc
index 82da478..47c8837 100644
--- a/src/audio/haiku/SDL_haikuaudio.cc
+++ b/src/audio/haiku/SDL_haikuaudio.cc
@@ -220,7 +220,7 @@ static int
 HAIKUAUDIO_Init(SDL_AudioDriverImpl * impl)
 {
     /* Initialize the Be Application, if it's not already started */
-    if (SDL_InitBeApp() < 0) {
+    if (SDL_InitBeApp(NULL) < 0) {
         return 0;
     }
 
diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index 215f836..9f9b288 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -42,6 +42,7 @@ extern "C" {
 /* Local includes */
 #include "../../events/SDL_events_c.h"
 #include "../../video/haiku/SDL_bframebuffer.h"
+#include "../../video/haiku/SDL_bvideo.h"
 
 #ifdef __cplusplus
 }
@@ -82,13 +83,13 @@ enum ToSDL {
 /* Create a descendant of BApplication */
 class SDL_BApp : public BApplication {
 public:
-    SDL_BApp(const char* signature) :
-        BApplication(signature) {
-#if SDL_VIDEO_OPENGL
-        _current_context = NULL;
-#endif
-    }
-
+    SDL_BApp(const char* signature, void* driverdata) :
+        BApplication(signature)
+        {
+        	driverdata = (SDL_VideoData *) driverdata;
+        }
+        
+    SDL_VideoData *driverdata;
 
     virtual ~SDL_BApp() {
     }
@@ -178,60 +179,17 @@ public:
         }
     }
 
-    /* Window creation/destruction methods */
-    int32 GetID(SDL_Window *win) {
-        int32 i;
-        for(i = 0; i < _GetNumWindowSlots(); ++i) {
-            if( GetSDLWindow(i) == NULL ) {
-                _SetSDLWindow(win, i);
-                return i;
-            }
-        }
-
-        /* Expand the vector if all slots are full */
-        if( i == _GetNumWindowSlots() ) {
-            _PushBackWindow(win);
-            return i;
-        }
-
-        /* TODO: error handling */
-        return 0;
-    }
-
-    /* FIXME: Bad coding practice, but I can't include SDL_BWin.h here.  Is
-       there another way to do this? */
-    void ClearID(SDL_BWin *bwin); /* Defined in SDL_BeApp.cc */
-
-
-    SDL_Window *GetSDLWindow(int32 winID) {
-        return _window_map[winID];
-    }
-
-#if SDL_VIDEO_OPENGL
-    BGLView *GetCurrentContext() {
-        return _current_context;
-    }
-    
-    void SetCurrentContext(BGLView *newContext) {
-        if(_current_context)
-            _current_context->UnlockGL();
-        _current_context = newContext;
-        if (_current_context)
-            _current_context->LockGL();
-    }
-#endif
-
 private:
     /* Event management */
     void _HandleBasicWindowEvent(BMessage *msg, int32 sdlEventType) {
         SDL_Window *win;
         int32 winID;
         if(
-            !_GetWinID(msg, &winID)
+            !driverdata->_GetWinID(msg, &winID)
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
         SDL_SendWindowEvent(win, sdlEventType, 0, 0);
     }
 
@@ -240,13 +198,13 @@ private:
         int32 winID;
         int32 x = 0, y = 0;
         if(
-            !_GetWinID(msg, &winID) ||
+            !driverdata->_GetWinID(msg, &winID) ||
             msg->FindInt32("x", &x) != B_OK || /* x movement */
             msg->FindInt32("y", &y) != B_OK    /* y movement */
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
 
         // Simple relative mode support for mouse.
         if (SDL_GetMouse()->relative_mode) {
@@ -271,13 +229,13 @@ private:
         int32 winID;
         int32 button, state;    /* left/middle/right, pressed/released */
         if(
-            !_GetWinID(msg, &winID) ||
+            !driverdata->_GetWinID(msg, &winID) ||
             msg->FindInt32("button-id", &button) != B_OK ||
             msg->FindInt32("button-state", &state) != B_OK
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
         SDL_SendMouseButton(win, 0, state, button);
     }
 
@@ -286,13 +244,13 @@ private:
         int32 winID;
         int32 xTicks, yTicks;
         if(
-            !_GetWinID(msg, &winID) ||
+            !driverdata->_GetWinID(msg, &winID) ||
             msg->FindInt32("xticks", &xTicks) != B_OK ||
             msg->FindInt32("yticks", &yTicks) != B_OK
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
         SDL_SendMouseWheel(win, 0, xTicks, -yTicks, SDL_MOUSEWHEEL_NORMAL);
     }
 
@@ -329,12 +287,12 @@ private:
         int32 winID;
         bool bSetFocus; /* If false, lose focus */
         if(
-            !_GetWinID(msg, &winID) ||
+            !driverdata->_GetWinID(msg, &winID) ||
             msg->FindBool("focusGained", &bSetFocus) != B_OK
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
         if(bSetFocus) {
             SDL_SetMouseFocus(win);
         } else if(SDL_GetMouseFocus() == win) {
@@ -348,12 +306,12 @@ private:
         int32 winID;
         bool bSetFocus; /* If false, lose focus */
         if(
-            !_GetWinID(msg, &winID) ||
+            !driverdata->_GetWinID(msg, &winID) ||
             msg->FindBool("focusGained", &bSetFocus) != B_OK
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
         if(bSetFocus) {
             SDL_SetKeyboardFocus(win);
         } else if(SDL_GetKeyboardFocus() == win) {
@@ -368,13 +326,13 @@ private:
         int32 xPos, yPos;
         /* Get the window id and new x/y position of the window */
         if(
-            !_GetWinID(msg, &winID) ||
+            !driverdata->_GetWinID(msg, &winID) ||
             msg->FindInt32("window-x", &xPos) != B_OK ||
             msg->FindInt32("window-y", &yPos) != B_OK
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
         SDL_SendWindowEvent(win, SDL_WINDOWEVENT_MOVED, xPos, yPos);
     }
 
@@ -384,48 +342,16 @@ private:
         int32 w, h;
         /* Get the window id ]and new x/y position of the window */
         if(
-            !_GetWinID(msg, &winID) ||
+            !driverdata->_GetWinID(msg, &winID) ||
             msg->FindInt32("window-w", &w) != B_OK ||
             msg->FindInt32("window-h", &h) != B_OK
         ) {
             return;
         }
-        win = GetSDLWindow(winID);
+        win = driverdata->GetSDLWindow(winID);
         SDL_SendWindowEvent(win, SDL_WINDOWEVENT_RESIZED, w, h);
     }
-
-    bool _GetWinID(BMessage *msg, int32 *winID) {
-        return msg->FindInt32("window-id", winID) == B_OK;
-    }
-
-
-
-    /* Vector functions: Wraps vector stuff in case we need to change
-       implementation */
-    void _SetSDLWindow(SDL_Window *win, int32 winID) {
-        _window_map[winID] = win;
-    }
-
-    int32 _GetNumWindowSlots() {
-        return _window_map.size();
-    }
-
-
-    void _PopBackWindow() {
-        _window_map.pop_back();
-    }
-
-    void _PushBackWindow(SDL_Window *win) {
-        _window_map.push_back(win);
-    }
-
-
-    /* Members */
-    std::vector<SDL_Window*> _window_map; /* Keeps track of SDL_Windows by index-id */
-
-#if SDL_VIDEO_OPENGL
-    BGLView      *_current_context;
-#endif
+    
 };
 
 #endif
diff --git a/src/main/haiku/SDL_BeApp.cc b/src/main/haiku/SDL_BeApp.cc
index a5e1428..a3b6bb3 100644
--- a/src/main/haiku/SDL_BeApp.cc
+++ b/src/main/haiku/SDL_BeApp.cc
@@ -52,7 +52,7 @@ static SDL_Thread *SDL_AppThread = NULL;
 const char *signature = "application/x-SDL-executable";
 
 static int
-StartBeApp(void *unused)
+StartBeApp(void* devicedata)
 {
     BApplication *App;
 
@@ -71,7 +71,7 @@ StartBeApp(void *unused)
         }
     }
 
-    App = new SDL_BApp(signature);
+    App = new SDL_BApp(signature, devicedata);
 
     App->Run();
     delete App;
@@ -80,11 +80,11 @@ StartBeApp(void *unused)
 
 /* Initialize the Be Application, if it's not already started */
 int
-SDL_InitBeApp(void)
+SDL_InitBeApp(void* devicedata)
 {
     /* Create the BApplication that handles appserver interaction */
-    if (SDL_BeAppActive <= 0) {
-        SDL_AppThread = SDL_CreateThreadInternal(StartBeApp, "SDLApplication", 0, NULL);
+    if (SDL_BeAppActive <= 0 && !be_app) {
+        SDL_AppThread = SDL_CreateThreadInternal(StartBeApp, "SDLApplication", 0, devicedata);
         if (SDL_AppThread == NULL) {
             return SDL_SetError("Couldn't create BApplication thread");
         }
@@ -143,16 +143,6 @@ SDL_QuitBeApp(void)
 }
 #endif
 
-/* SDL_BApp functions */
-void SDL_BApp::ClearID(SDL_BWin *bwin) {
-    _SetSDLWindow(NULL, bwin->GetID());
-    int32 i = _GetNumWindowSlots() - 1;
-    while(i >= 0 && GetSDLWindow(i) == NULL) {
-        _PopBackWindow();
-        --i;
-    }
-}
-
 #endif /* __HAIKU__ */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/main/haiku/SDL_BeApp.h b/src/main/haiku/SDL_BeApp.h
index 5b74466..c263e4a 100644
--- a/src/main/haiku/SDL_BeApp.h
+++ b/src/main/haiku/SDL_BeApp.h
@@ -26,7 +26,7 @@ extern "C" {
 /* Handle the BeApp specific portions of the application */
 
 /* Initialize the Be Application, if it's not already started */
-extern int SDL_InitBeApp(void);
+extern int SDL_InitBeApp(void* devicedata);
 
 /* Quit the Be Application, if there's nothing left to do */
 extern void SDL_QuitBeApp(void);
diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index 1ac5171..a1f60d3 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -125,8 +125,8 @@ class SDL_BWin: public BWindow
 
 #if SDL_VIDEO_OPENGL
         if (_SDL_GLView) {
-            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
-                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            if (((SDL_BApp*)be_app)->driverdata->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->driverdata->SetCurrentContext(NULL);
             if (_SDL_GLView == _cur_view)
                 RemoveChild(_SDL_GLView);
             _SDL_GLView = NULL;
@@ -205,8 +205,8 @@ class SDL_BWin: public BWindow
     void RemoveGLView() {
         Lock();
         if(_SDL_GLView != NULL) {
-            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
-                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            if (((SDL_BApp*)be_app)->driverdata->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->driverdata->SetCurrentContext(NULL);
             _SDL_GLView = NULL;
             UpdateCurrentView();
             // _SDL_GLView deleted by HAIKU_GL_DeleteContext
diff --git a/src/video/haiku/SDL_bopengl.cc b/src/video/haiku/SDL_bopengl.cc
index 0c7a704..08b4ccc 100644
--- a/src/video/haiku/SDL_bopengl.cc
+++ b/src/video/haiku/SDL_bopengl.cc
@@ -98,7 +98,7 @@ int HAIKU_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context) {
             return -1;
         }
     }
-    _GetBeApp()->SetCurrentContext(glView);
+    _GetBeApp()->driverdata->SetCurrentContext(glView);
     return 0;
 }
 
@@ -139,7 +139,7 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
     }
 #endif
     bwin->CreateGLView(gl_flags);
-    _GetBeApp()->SetCurrentContext(bwin->GetGLView());
+    _GetBeApp()->driverdata->SetCurrentContext(bwin->GetGLView());
     return (SDL_GLContext)(bwin->GetGLView());
 }
 
diff --git a/src/video/haiku/SDL_bvideo.cc b/src/video/haiku/SDL_bvideo.cc
index 1ac3201..04b4d00 100644
--- a/src/video/haiku/SDL_bvideo.cc
+++ b/src/video/haiku/SDL_bvideo.cc
@@ -27,6 +27,16 @@
 #include "SDL_BWin.h"
 #include <Url.h>
 
+/* SDL_BApp functions */
+void SDL_VideoData::ClearID(SDL_BWin *bwin) {
+    _SetSDLWindow(NULL, bwin->GetID());
+    int32 i = _GetNumWindowSlots() - 1;
+    while(i >= 0 && GetSDLWindow(i) == NULL) {
+        _PopBackWindow();
+        --i;
+    }
+}
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -63,8 +73,7 @@ HAIKU_CreateDevice(int devindex)
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
 
-    device->driverdata = NULL; /* FIXME: Is this the cause of some of the
-                                  SDL_Quit() errors? */
+    device->driverdata = (SDL_VideoData *) new SDL_VideoData;
 
 /* TODO: Figure out if any initialization needs to go here */
 
@@ -137,7 +146,7 @@ VideoBootStrap HAIKU_bootstrap = {
 
 void HAIKU_DeleteDevice(SDL_VideoDevice * device)
 {
-    SDL_free(device->driverdata);
+    delete (SDL_VideoData *) device->driverdata;
     SDL_free(device);
 }
 
@@ -273,7 +282,7 @@ static void HAIKU_MouseInit(_THIS)
 int HAIKU_VideoInit(_THIS)
 {
     /* Initialize the Be Application for appserver interaction */
-    if (SDL_InitBeApp() < 0) {
+    if (SDL_InitBeApp(_this) < 0) {
         return -1;
     }
     
diff --git a/src/video/haiku/SDL_bvideo.h b/src/video/haiku/SDL_bvideo.h
index d0d7bfe..879a886 100644
--- a/src/video/haiku/SDL_bvideo.h
+++ b/src/video/haiku/SDL_bvideo.h
@@ -22,6 +22,66 @@
 #ifndef BVIDEO_H
 #define BVIDEO_H
 
+/* Forward declaration */
+class SDL_BWin;
+
+#include <vector>
+
+typedef struct SDL_VideoData {
+	std::vector<SDL_Window*> _window_map;
+	    /* Window creation/destruction methods */
+    int32 GetID(SDL_Window *win) {
+        int32 i;
+        for(i = 0; i < _GetNumWindowSlots(); ++i) {
+            if( GetSDLWindow(i) == NULL ) {
+                _SetSDLWindow(win, i);
+                return i;
+            }
+        }
+        /* Expand the vector if all slots are full */
+        if( i == _GetNumWindowSlots() ) {
+            _PushBackWindow(win);
+            return i;
+        }
+
+        /* TODO: error handling */
+        return 0;
+    }
+	void ClearID(SDL_BWin *bwin);
+    SDL_Window *GetSDLWindow(int32 winID) {
+        return _window_map[winID];
+    }
+	bool _GetWinID(BMessage *msg, int32 *winID) {
+        return msg->FindInt32("window-id", winID) == B_OK;
+    }
+	void _SetSDLWindow(SDL_Window *win, int32 winID) {
+        _window_map[winID] = win;
+    }
+	int32 _GetNumWindowSlots() {
+        return _window_map.size();
+    }
+	void _PopBackWindow() {
+        _window_map.pop_back();
+    }
+	void _PushBackWindow(SDL_Window *win) {
+        _window_map.push_back(win);
+    }
+#if SDL_VIDEO_OPENGL
+    BGLView *GetCurrentContext() {
+        return _current_context;
+    }
+    
+    void SetCurrentContext(BGLView *newContext) {
+        if(_current_context)
+            _current_context->UnlockGL();
+        _current_context = newContext;
+        if (_current_context)
+            _current_context->LockGL();
+    }
+	BGLView *_current_context;
+#endif
+} SDL_VideoData;
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -29,7 +89,6 @@ extern "C" {
 #include "../../main/haiku/SDL_BeApp.h"
 #include "../SDL_sysvideo.h"
 
-
 extern void HAIKU_VideoQuit(_THIS);
 extern int HAIKU_VideoInit(_THIS);
 extern void HAIKU_DeleteDevice(_THIS);
diff --git a/src/video/haiku/SDL_bwindow.cc b/src/video/haiku/SDL_bwindow.cc
index 587affa..ca18c62 100644
--- a/src/video/haiku/SDL_bwindow.cc
+++ b/src/video/haiku/SDL_bwindow.cc
@@ -71,7 +71,7 @@ static int _InitWindow(_THIS, SDL_Window *window) {
         return -1;
 
     window->driverdata = bwin;
-    int32 winID = _GetBeApp()->GetID(window);
+    int32 winID = _GetBeApp()->driverdata->GetID(window);
     bwin->SetID(winID);
 
     return 0;
@@ -218,7 +218,7 @@ void HAIKU_SetWindowMouseGrab(_THIS, SDL_Window * window, SDL_bool grabbed) {
 
 void HAIKU_DestroyWindow(_THIS, SDL_Window * window) {
     _ToBeWin(window)->LockLooper();    /* This MUST be locked */
-    _GetBeApp()->ClearID(_ToBeWin(window));
+    _GetBeApp()->driverdata->ClearID(_ToBeWin(window));
     _ToBeWin(window)->Quit();
     window->driverdata = NULL;
 }
-- 
2.30.2

