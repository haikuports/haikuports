From 685dac2b4113680d870bf15a07ed02855d868bec Mon Sep 17 00:00:00 2001
From: Leorize <leorize+oss@disroot.org>
Date: Wed, 17 Apr 2019 15:41:54 +0700
Subject: Add Haiku support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Patch by François Revol, updated for links 2.19

diff --git a/Makefile.am b/Makefile.am
index a335ed9..6c46f41 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -4,7 +4,7 @@
 
 man_MANS=links.1
 
-EXTRA_DIST=$(man_MANS) atheos.cpp BRAILLE_HOWTO KEYS SITES descrip.mms *.opt framebuffer-accelerator.patch gpm-1.20.0-smooth-cursor.patch libpng-1.2.18.patch mailcap.pl rebuild Links_logo.png Unicode/*.cp Unicode/[!C]* certs/[!C]* intl/[!C]* suffix/[!C]* graphics/*.c graphics/arrow.png graphics/gen graphics/font/bold/*.png graphics/font/monospaced/*.png graphics/font/normal/*.png graphics/font/system/*.png doc/links_cal/*.png doc/links_cal/*.html graphics/Makefile graphics/Fontmap graphics/clip.c graphics/links.xpm graphics/makefont graphics/pdf2html graphics/spacer.png pkg-config.m4 *.xpm *.ico *.rc mk-release-os2 mk-release-win mk-dos mk-dos83.cmd links.wis *.nsi
+EXTRA_DIST=$(man_MANS) atheos.cpp haiku.cpp BRAILLE_HOWTO KEYS SITES descrip.mms *.opt framebuffer-accelerator.patch gpm-1.20.0-smooth-cursor.patch libpng-1.2.18.patch mailcap.pl rebuild Links_logo.png Unicode/*.cp Unicode/[!C]* certs/[!C]* intl/[!C]* suffix/[!C]* graphics/*.c graphics/arrow.png graphics/gen graphics/font/bold/*.png graphics/font/monospaced/*.png graphics/font/normal/*.png graphics/font/system/*.png doc/links_cal/*.png doc/links_cal/*.html graphics/Makefile graphics/Fontmap graphics/clip.c graphics/links.xpm graphics/makefont graphics/pdf2html graphics/spacer.png pkg-config.m4 *.xpm *.ico *.rc mk-release-os2 mk-release-win mk-dos mk-dos83.cmd links.wis *.nsi
 # parser/gen parser/javascr.l parser/javascript.y
 
 bin_PROGRAMS=links
@@ -16,6 +16,17 @@ if JAVASCRIPT
 links_LDADD=builtin.o context.o ipret.o javascr.o javascript.o md5.o md5hl.o ns.o pomocny.o regexp.o
 endif
 
+if HAIKU_GR
+links_LDADD=haiku.o -lbe -lstdc++
+EXTRA_links_DEPENDENCIES=links-haiku.rsrc
+# automake will not let us touch the binary after link
+# and install will not copy the attributes anyway... so do it after install
+install-exec-hook:
+	xres -o $(DESTDIR)$(bindir)/links$(EXEEXT) links-haiku.rsrc
+	mimeset $(DESTDIR)$(bindir)/links$(EXEEXT)
+else
+endif
+
 links_SOURCES=af_unix.c auth.c beos.c bfu.c block.c bookmark.c cache.c charsets.c compress.c connect.c cookies.c data.c default.c dip.c directfb.c dither.c dns.c dos.c drivers.c error.c file.c finger.c fn_impl.c fontconf.c font_inc.c framebuf.c freetype.c ftp.c gif.c grx.c hpux.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c jpeg.c jsint.c kbd.c language.c listedit.c lru.c mailto.c main.c memory.c menu.c objreq.c os_dep.c pmshell.c png.c sched.c select.c session.c smb.c string.c suffix.c svg.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c vms.c x.c xbm.c beos.h bits.h cfg.h codepage.h com-defs.h config-vms.h dfb_cur.h hpux.h language.h links.h os_dep.h os_depx.h setup.h arrow.inc certs.inc codepage.inc entity.inc fbcommon.inc language.inc links_ic.inc locase.inc suffix.inc suffix_x.inc uni_7b.inc upcase.inc vpipe.inc
 # builtin.c context.c ipret.c javascr.c javascript.c md5.c md5hl.c ns.c pomocny.c regexp.c md5.h ns.h struct.h tree.h typy.h ipret.h javascript.h builtin.h builtin_keys.h
 
@@ -32,6 +43,12 @@ CXXFLAGS=@CXXFLAGS@
 atheos.o: $(srcdir)/atheos.cpp
 	$(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c $(srcdir)/atheos.cpp
 
+haiku.o: haiku.cpp
+	$(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -o $@ -c $<
+
+links-haiku.rsrc: links-haiku.rdef
+	rc -o $@ $<
+
 datadir = $(prefix)/@DATADIRNAME@
 LIBS = @LIBS@
 
diff --git a/acconfig.h b/acconfig.h
index 488eb01..c48267f 100644
--- a/acconfig.h
+++ b/acconfig.h
@@ -220,6 +220,9 @@
 /* */
 #undef GRDRV_ATHEOS
 
+/* */
+#undef GRDRV_HAIKU
+
 /* */
 #undef GRDRV_GRX
 
diff --git a/beos.c b/beos.c
index 4c55e63..20db96e 100644
--- a/beos.c
+++ b/beos.c
@@ -3,7 +3,7 @@
  * This file is a part of the Links program, released under GPL
  */
 
-#if defined(__BEOS__) || defined(__HAIKU__)
+#if defined(__BEOS__)
 
 #include "com-defs.h"
 
diff --git a/cfg.h b/cfg.h
index 6889fff..2b683d4 100644
--- a/cfg.h
+++ b/cfg.h
@@ -69,9 +69,9 @@
 #define volatile
 #endif
 
-#if defined(HAVE_RESTRICT)
+#if defined(HAVE_RESTRICT) && !defined(__cplusplus)
 #define my_restrict	restrict
-#elif defined(HAVE___RESTRICT)
+#elif defined(HAVE___RESTRICT) && !defined(__cplusplus)
 #define my_restrict	__restrict
 #else
 #define my_restrict
diff --git a/configure.in b/configure.in
index bc719a6..021a31c 100644
--- a/configure.in
+++ b/configure.in
@@ -18,7 +18,7 @@ export CFLAGS
 export LDFLAGS
 export LIBS
 
-AM_CONFIG_HEADER(config.h)
+AC_CONFIG_HEADER(config.h)
 
 dnl Checks for programs.
 AC_PROG_CC
@@ -784,6 +784,7 @@ if test "$ac_cv_have_beginthread" = yes; then
 	AC_DEFINE(HAVE_BEGINTHREAD)
 fi
 AC_CHECK_HEADERS(atheos/threads.h)
+AC_CHECK_HEADERS(kernel/OS.h)
 AC_HAVE_FUNCS(spawn_thread resume_thread)
 
 AC_HAVE_FUNCS(MouOpen _read_kbd)
@@ -976,6 +977,7 @@ fi
 
 
 cf_have_atheos=no
+cf_have_haiku=no
 
 if test "$cf_use_graphics" != no; then
 	AC_DEFINE(G)
@@ -1025,6 +1027,7 @@ dnl AC_ARG_WITH(sdl, [  --without-sdl           compile without SDL graphics dri
 AC_ARG_WITH(pmshell, [  --without-pmshell       compile without PMShell graphics driver],[if test "$withval" = no; then disable_pmshell=yes; else disable_pmshell=no; fi])
 AC_ARG_WITH(windows, [  --without-windows       compile without Windows graphics driver],[if test "$withval" = no; then disable_windows=yes; else disable_windows=no; fi])
 AC_ARG_WITH(atheos, [  --without-atheos        compile without Atheos graphics driver],[if test "$withval" = no; then disable_atheos=yes; else disable_atheos; fi])
+AC_ARG_WITH(haiku, [  --without-haiku         compile without Haiku/BeOS graphics driver],[if test "$withval" = no; then disable_haiku=yes; else disable_haiku=no; fi])
 AC_ARG_WITH(grx, [  --without-grx           compile without DOS GRX graphics driver],[if test "$withval" = no; then disable_grx=yes; else disable_grx; fi])
 
 	drivers=""
@@ -1252,6 +1255,31 @@ if test "$disable_atheos" != yes; then
 	fi
 fi
 
+if test "$disable_haiku" != yes ; then
+	old_ext="$ac_ext"
+	ac_ext=cpp
+	AC_CHECK_HEADERS(interface/View.h)
+	AC_CHECK_HEADERS(interface/Window.h)
+	AC_CHECK_HEADERS(interface/Screen.h)
+	AC_CHECK_HEADERS(interface/Bitmap.h)
+	AC_CHECK_HEADERS(support/Locker.h)
+	AC_CHECK_HEADERS(app/Application.h)
+	ac_ext="$old_ext"
+
+	if test "$ac_cv_header_kernel_OS_h" = yes &&
+	   test "$ac_cv_header_interface_View_h" = yes &&
+	   test "$ac_cv_header_interface_Window_h" = yes &&
+	   test "$ac_cv_header_interface_Screen_h" = yes &&
+	   test "$ac_cv_header_interface_Bitmap_h" = yes &&
+	   test "$ac_cv_header_support_Locker_h" = yes &&
+	   test "$ac_cv_header_app_Application_h" = yes; then
+		AC_PROG_CXX
+		AC_DEFINE(GRDRV_HAIKU)
+		drivers="$drivers HAIKU"
+		cf_have_haiku=yes
+	fi
+fi
+
 if test "$disable_grx" != yes -a "$ac_cv_have_djgpp" = yes; then
 	LIBS_X="$LIBS"
 	AC_CHECK_HEADERS(grx20.h)
@@ -1421,6 +1449,7 @@ fi
 AM_CONDITIONAL(JAVASCRIPT, test "$cf_use_javascript" = yes)
 
 AM_CONDITIONAL(ATHEOS_GR, test "$cf_have_atheos" = yes)
+AM_CONDITIONAL(HAIKU_GR, test "$cf_have_haiku" = yes)
 
 test "$ac_cv_have_emx" = yes && LDFLAGS="$LDFLAGS -Zexe"
 
diff --git a/default.c b/default.c
index 10d7e38..5c41b63 100644
--- a/default.c
+++ b/default.c
@@ -750,7 +750,11 @@ skip_path_conv:;
 		}
 	}
 #endif
+#ifdef HAIKU
+	if (!home) home = os_get_home();
+#else
 	if (!home) home = stracpy(cast_uchar getenv("HOME"));
+#endif
 #ifdef WIN
 /* When we run in Cygwin without Cygwin environment, it reports home "/".
    Unfortunatelly, it can't write anything to that directory */
@@ -796,7 +800,7 @@ skip_path_conv:;
 		}
 	} else {
 		add_dot_links:
-#ifdef OPENVMS
+#if defined(OPENVMS) || defined(HAIKU)
 		add_to_strn(&home_links, cast_uchar "links");
 #else
 		add_to_strn(&home_links, cast_uchar ".links");
diff --git a/drivers.c b/drivers.c
index bf23d15..a00a722 100644
--- a/drivers.c
+++ b/drivers.c
@@ -31,6 +31,9 @@ extern struct graphics_driver pmshell_driver;
 #ifdef GRDRV_ATHEOS
 extern struct graphics_driver atheos_driver;
 #endif
+#ifdef GRDRV_HAIKU
+extern struct graphics_driver haiku_driver;
+#endif
 #ifdef GRDRV_GRX
 extern struct graphics_driver grx_driver;
 #endif
@@ -51,6 +54,9 @@ static struct graphics_driver *graphics_drivers[] = {
 #ifdef GRDRV_ATHEOS
 	&atheos_driver,
 #endif
+#ifdef GRDRV_HAIKU
+	&haiku_driver,
+#endif
 #ifndef SPAD
 #ifdef GRDRV_X
 	&x_driver,
diff --git a/haiku.cpp b/haiku.cpp
new file mode 100644
index 0000000..50eacdc
--- /dev/null
+++ b/haiku.cpp
@@ -0,0 +1,866 @@
+/* haiku.cpp
+ * (c) 2007 François Revol
+ * This file is a part of the Links program, released under GPL
+ */
+
+#if defined __BEOS__ || defined __HAIKU__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <kernel/OS.h>
+
+/*
+ * GUI code
+ */
+
+/*
+ * TODO:
+ * - BeOS doesn't handle BView::DrawBitmap() with RGB24, and links doesn't seem to handle RGB32,
+ *   so the colorspace is forced into 16bpp for now.
+ * - more paste handling ?
+ * - more DnD (maybe check if in menu or not and prepend "g" ?)
+ * - handle DnD of Net+ bookmarks
+ */
+
+#include "cfg.h"
+
+#ifdef GRDRV_HAIKU
+
+extern "C" {
+#include "links.h"
+}
+#undef B_ENTER
+
+#include <app/Application.h>
+#include <app/Clipboard.h>
+#include <interface/Bitmap.h>
+#include <interface/Region.h>
+#include <interface/Screen.h>
+#include <interface/View.h>
+#include <interface/Window.h>
+#include <storage/Entry.h>
+#include <storage/File.h>
+#include <storage/Path.h>
+#include <support/Locker.h>
+#include <support/String.h>
+
+//#define DBG(l...) fprintf(stderr, l);
+#define DBG(l...) {}
+
+/*
+#ifdef debug
+#undef debug
+#endif
+#define debug(x)
+#define fprintf(x, y)
+*/
+
+extern "C" struct graphics_driver haiku_driver;
+
+class LinksApplication : public BApplication {
+	public:
+	LinksApplication():BApplication("application/x-vnd.links"){}
+	virtual void RefsReceived(BMessage *message);
+	virtual bool QuitRequested();
+};
+
+class LinksView;
+
+class LinksWindow : public BWindow {
+	public:
+	LinksWindow(BRect r);
+	~LinksWindow();
+	virtual void FrameResized(float width, float height);
+	virtual bool QuitRequested();
+	int resized;
+	LinksView *view;
+};
+
+class LinksView : public BView {
+	public:
+	LinksView(LinksWindow *w);
+	~LinksView();
+	virtual void Draw(BRect r);
+	virtual void MouseDown(BPoint p);
+	virtual void MouseUp(BPoint p);
+	virtual void MouseMoved(BPoint p, uint32 transit, const BMessage *dragmsg);
+	virtual void KeyDown(const char *s, int32 numBytes);
+	virtual void MessageReceived(BMessage *msg);
+	LinksWindow *win;
+	struct graphics_device *dev;
+	void d_flush();
+	int flushing;
+	int last_x, last_y;
+};
+
+#define lv(dev) ((LinksView *)(dev)->driver_data)
+
+#define lock_dev(dev) do { if (!lv(dev)->win->Lock()) return; } while (0)
+#define lock_dev0(dev) do { if (!lv(dev)->win->Lock()) return 0; } while (0)
+#define unlock_dev(dev) do { lv(dev)->win->Unlock(); } while (0)
+
+void be_get_size(struct graphics_device *dev);
+
+#define detach_message(dev) \
+	BMessage *current = Looper()->DetachCurrentMessage(); \
+	if (current) { \
+		current->AddPointer("linksdev", dev); \
+	}
+
+#define pipe_message(dev) \
+	if (current) { \
+		write(wpipe, &current, sizeof(current)); \
+	}
+
+#define detach_and_pipe_message(dev) do { \
+	BMessage *current = Looper()->DetachCurrentMessage(); \
+	if (current) { \
+		current->AddPointer("linksdev", dev); \
+		write(wpipe, &current, sizeof(current)); \
+	} \
+} while (0)
+
+LinksApplication *be_links_app;
+BLocker *be_lock = NULL;
+
+int msg_pipe[2];
+
+thread_id be_app_thread_id;
+
+#define rpipe (msg_pipe[0])
+#define wpipe (msg_pipe[1])
+
+#define small_color (sizeof(rgb_color) <= sizeof(long))
+#define get_color32(c, rgb) rgb_color \
+	c((rgb_color){ \
+		static_cast<uint8>((rgb >> 16) & 255), \
+		static_cast<uint8>((rgb >> 8) & 255), \
+		static_cast<uint8>(rgb & 255), \
+		255})
+
+color_space be_cs_desktop, be_cs_bmp;
+
+int be_x_size, be_y_size;
+
+int be_win_x_size, be_win_y_size;
+int be_win_x_pos, be_win_y_pos;
+
+static BMessage *initial_refs_msg;
+
+void LinksApplication::RefsReceived(BMessage *message)
+{
+	entry_ref ref;
+	//if (!IsLaunching())
+	//	return;
+	BMessenger msgr(WindowAt(0));
+	BMessage *m = new BMessage(*message);
+	m->AddSpecifier("View", (int32)0);
+	//m->what = B_SIMPLE_DATA;
+	if (msgr.IsValid()) {
+		msgr.SendMessage(m);
+	} else
+		initial_refs_msg = m;
+}
+
+bool LinksApplication::QuitRequested()
+{
+	BApplication::QuitRequested();
+	//printf("qc: %ld\n", CountWindows());
+	return true;
+}
+
+LinksWindow::LinksWindow(BRect r):BWindow(r, "Links", B_DOCUMENT_WINDOW, 0)
+{
+	DBG("LINKSWINDOW\n");
+	resized = 0;
+	view = NULL;
+}
+
+LinksWindow::~LinksWindow()
+{
+	view = NULL;
+	DBG("~LINKSWINDOW\n");
+}
+
+void LinksWindow::FrameResized(float width, float height)
+{
+	resized = 1;
+}
+
+bool LinksWindow::QuitRequested()
+{
+	detach_and_pipe_message(view->dev);
+	return false;
+}
+
+void do_flush(void *p_dev)
+{
+	struct graphics_device *dev = (struct graphics_device *)p_dev;
+	LinksView *v = lv(dev);
+	v->win->Lock();
+	v->win->Flush();
+	v->win->Unlock();
+	v->flushing = 0;
+}
+
+LinksView::LinksView(LinksWindow *w):BView(w->Bounds(), "Links", B_FOLLOW_ALL, B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_NAVIGABLE)
+{
+	DBG("LINKSVIEW\n");
+	(win = w)->AddChild(this);
+	SetViewColor(B_TRANSPARENT_32_BIT);
+	MakeFocus();
+	w->view = this;
+	flushing = 0;
+	last_x = last_y = 0;
+}
+
+LinksView::~LinksView()
+{
+	win->view = NULL;
+	DBG("~LINKSVIEW\n");
+}
+
+void LinksView::d_flush()
+{
+	if (flushing) return;
+	register_bottom_half(do_flush, this->dev);
+	flushing = 1;
+}
+
+#undef select
+
+int be_loop_select(int n, fd_set *r, fd_set *w, fd_set *e, struct timeval *t)
+{
+	int v;
+	v = select(n, r, w, e, t);
+	check_bottom_halves();
+	return v;
+}
+
+void be_paste_string(struct graphics_device *dev, const char *str)
+{
+	unsigned char *s = (unsigned char *)str;
+	int c, i;
+	while (s && *s) {
+		GET_UTF_8(s, c);
+		if (dev) dev->keyboard_handler(dev, c, 0);
+	}
+}
+
+void be_get_event(void *dummy)
+{
+	BMessage *msg;
+	LinksView *view = NULL;
+	LinksWindow *win = NULL;
+	struct graphics_device *dev;
+	read(rpipe, &msg, sizeof(msg));
+	DBG("GETE\n");
+	if (!msg)
+		return;
+	if (msg->FindPointer("linksdev", (void **)&dev) < B_OK)
+		return;
+	if (dev) {
+		view = lv(dev);
+		if (view)
+			win = dynamic_cast<LinksWindow *>(view->Window());
+	}
+	switch (msg->what) {
+	case B_QUIT_REQUESTED:
+		if (dev)
+			dev->keyboard_handler(dev, KBD_CTRL_C, 0);
+		break;
+	case _UPDATE_:
+	{
+		BRect r;
+		if (msg->FindRect("updateRect", &r) < B_OK)
+			return;
+		struct rect rr;
+		rr.x1 = (int)r.left;
+		rr.x2 = (int)r.right + 1;
+		rr.y1 = (int)r.top;
+		rr.y2 = (int)r.bottom + 1;
+		/*DBG("paint: %d %d %d %d\n", rr.x1, rr.x2, rr.y1, rr.y2);*/
+		if (dev) {
+			if (!win->resized) dev->redraw_handler(dev, &rr);
+			else {
+				be_get_size(dev);
+				win->resized = 0;
+				dev->resize_handler(dev);
+			}
+		}
+		check_bottom_halves();
+	}
+		break;
+	case B_MOUSE_DOWN:
+	{
+		BPoint where;
+		int32 buttons;
+		int btn = B_LEFT;
+		if (msg->FindInt32("buttons", &buttons) != B_OK)
+			return;
+		if (msg->FindPoint("where", &where) != B_OK)
+			return;
+		if (buttons & B_PRIMARY_MOUSE_BUTTON)
+			btn = B_LEFT;
+		else if (buttons & B_SECONDARY_MOUSE_BUTTON)
+			btn = B_RIGHT;
+		else if (buttons & B_TERTIARY_MOUSE_BUTTON)
+			btn = B_MIDDLE;
+		else if (buttons & (B_TERTIARY_MOUSE_BUTTON << 1))
+			btn = B_FOURTH;
+		else if (buttons & (B_TERTIARY_MOUSE_BUTTON << 2))
+			btn = B_FIFTH;
+		else if (buttons & (B_TERTIARY_MOUSE_BUTTON << 3))
+			btn = B_SIXTH;
+		if (dev) dev->mouse_handler(dev, view->last_x = (int)where.x, view->last_y = (int)where.y, B_DOWN | btn);
+	}
+		break;
+	case B_MOUSE_UP:
+	{
+		BPoint where;
+		int32 buttons;
+		int btn = B_LEFT;
+		if (msg->FindInt32("buttons", &buttons) != B_OK)
+			return;
+		if (msg->FindPoint("where", &where) != B_OK)
+			return;
+		if (buttons & ~B_PRIMARY_MOUSE_BUTTON == 0)
+			btn = B_LEFT;
+		else if (buttons & ~B_SECONDARY_MOUSE_BUTTON == 0)
+			btn = B_RIGHT;
+		else if (buttons & ~B_TERTIARY_MOUSE_BUTTON == 0)
+			btn = B_MIDDLE;
+		else if (buttons & ~(B_TERTIARY_MOUSE_BUTTON << 1) == 0)
+			btn = B_FOURTH;
+		else if (buttons & ~(B_TERTIARY_MOUSE_BUTTON << 2) == 0)
+			btn = B_FIFTH;
+		else if (buttons & ~(B_TERTIARY_MOUSE_BUTTON << 3) == 0)
+			btn = B_SIXTH;
+		if (dev) dev->mouse_handler(dev, view->last_x = (int)where.x, view->last_y = (int)where.y, B_UP | btn);
+	}
+		break;
+	case B_MOUSE_MOVED:
+	{
+		BPoint where;
+		int32 buttons;
+		int btn = B_LEFT;
+		if (msg->FindInt32("buttons", &buttons) != B_OK)
+			return;
+		if (msg->FindPoint("where", &where) != B_OK)
+			return;
+		if (buttons & B_PRIMARY_MOUSE_BUTTON)
+			btn = B_LEFT;
+		else if (buttons & B_SECONDARY_MOUSE_BUTTON)
+			btn = B_RIGHT;
+		else if (buttons & B_TERTIARY_MOUSE_BUTTON)
+			btn = B_MIDDLE;
+		else if (buttons & (B_TERTIARY_MOUSE_BUTTON << 1))
+			btn = B_FOURTH;
+		else if (buttons & (B_TERTIARY_MOUSE_BUTTON << 2))
+			btn = B_FIFTH;
+		else if (buttons & (B_TERTIARY_MOUSE_BUTTON << 3))
+			btn = B_SIXTH;
+		if (dev) dev->mouse_handler(dev, view->last_x = (int)where.x, view->last_y = (int)where.y, !buttons ? B_MOVE : B_DRAG | btn);
+	}
+		break;
+	case B_KEY_DOWN:
+	{
+		int32 modifiers;
+		int32 numBytes;
+		const char *bytes;
+		int c;
+		int mods = 0;
+		if (msg->FindInt32("modifiers", &modifiers) != B_OK)
+			return;
+		if (msg->FindString("bytes", &bytes) != B_OK)
+			return;
+		unsigned char buf[4] = { 0, 0, 0, 0 };
+		unsigned char *ss;
+		if (modifiers & (B_LEFT_CONTROL_KEY | B_RIGHT_CONTROL_KEY | B_LEFT_COMMAND_KEY | B_RIGHT_COMMAND_KEY)) {
+			int32 raw;
+			if (msg->FindInt32("raw_char", &raw) != B_OK)
+				return;
+			buf[0] = (unsigned char)raw;
+			ss = buf;
+		} else
+			ss = (unsigned char *)bytes;
+
+		GET_UTF_8(ss, c);
+		switch (c) {
+			case B_BACKSPACE: c = KBD_BS; break;
+			case B_ENTER: c = KBD_ENTER; break;
+			case B_SPACE: c = ' '; break;
+			case B_TAB: c = KBD_TAB; break;
+			case B_ESCAPE: c = KBD_ESC; break;
+			case B_LEFT_ARROW: c = KBD_LEFT; break;
+			case B_RIGHT_ARROW: c = KBD_RIGHT; break;
+			case B_UP_ARROW: c = KBD_UP; break;
+			case B_DOWN_ARROW: c = KBD_DOWN; break;
+			case B_INSERT: c = KBD_INS; break;
+			case B_DELETE: c = KBD_DEL; break;
+			case B_HOME: c = KBD_HOME; break;
+			case B_END: c = KBD_END; break;
+			case B_PAGE_UP: c = KBD_PAGE_UP; break;
+			case B_PAGE_DOWN: c = KBD_PAGE_DOWN; break;
+			default: if (c < 32) c = 0;
+				 else modifiers &= ~(B_LEFT_SHIFT_KEY|B_RIGHT_SHIFT_KEY);
+				 break;
+		}
+		if (modifiers & (B_LEFT_SHIFT_KEY|B_RIGHT_SHIFT_KEY))
+			mods |= KBD_SHIFT;
+		if (modifiers & (B_LEFT_CONTROL_KEY|B_RIGHT_CONTROL_KEY))
+			mods |= KBD_CTRL;
+		if (modifiers & (B_LEFT_COMMAND_KEY|B_RIGHT_COMMAND_KEY))
+			mods |= KBD_ALT;
+		if (c) if (dev) dev->keyboard_handler(dev, c, mods);
+	}
+		break;
+	case B_MOUSE_WHEEL_CHANGED:
+	{
+		float delta_x, delta_y;
+		if (msg->FindFloat("be:wheel_delta_x", &delta_x) != B_OK)
+			delta_x = 0;
+		if (msg->FindFloat("be:wheel_delta_y", &delta_y) != B_OK)
+			delta_y = 0;
+		if (delta_y) if (dev) dev->mouse_handler(dev, view->last_x, view->last_y, B_MOVE | (delta_y > 0 ? B_WHEELDOWN : B_WHEELUP));
+		if (delta_x) if (dev) dev->mouse_handler(dev, view->last_x, view->last_y, B_MOVE | (delta_x < 0 ? B_WHEELLEFT : B_WHEELRIGHT));
+	}
+		break;
+	case B_PASTE:
+		if (be_clipboard->Lock()) {
+			BMessage *data = be_clipboard->Data();
+			if (data) {
+				const char *text_plain;
+				ssize_t len;
+				//data->PrintToStream();
+				if (data->FindData("text/plain", B_MIME_TYPE, (const void **)&text_plain, &len) == B_OK) {
+					be_paste_string(dev, text_plain);
+				}
+			}
+			be_clipboard->Unlock();
+		}
+		break;
+	case B_REFS_RECEIVED:
+		if (dev)
+			be_paste_string(dev, "\033\ng");
+		/* FALLTHROUGH */
+	case B_SIMPLE_DATA:
+	{
+		/* something got dropped */
+		entry_ref ref;
+		const char *text_plain;
+		ssize_t len;
+		//msg->PrintToStream();
+		/* try find a file path to paste */
+		if (msg->FindRef("refs", &ref) == B_OK) {
+			BPath path(&ref);
+			if (path.InitCheck() == B_OK) {
+				BFile f(path.Path(), B_READ_ONLY);
+				BString url;
+				if (f.InitCheck() == B_OK && f.ReadAttrString("META:url", &url) >= B_OK) {
+					be_paste_string(dev, url.String());
+				} else
+					be_paste_string(dev, path.Path());
+			}
+		} else if (msg->FindData("text/plain", B_MIME_TYPE, (const void **)&text_plain, &len) == B_OK) {
+			be_paste_string(dev, text_plain);
+		}
+	}
+		break;
+	default:
+		msg->PrintToStream();
+		break;
+	}
+	delete msg;
+}
+
+void be_get_size(struct graphics_device *dev)
+{
+	BRect r;
+	lock_dev(dev);
+	r = lv(dev)->Bounds();
+	unlock_dev(dev);
+	dev->size.x1 = dev->size.y1 = 0;
+	dev->size.x2 = (int)r.Width() + 1;
+	dev->size.y2 = (int)r.Height() + 1;
+}
+
+void LinksView::Draw(BRect r)
+{
+	detach_message(dev);
+	current->AddRect("updateRect", r);
+	pipe_message(dev);
+}
+
+
+void LinksView::MouseDown(BPoint p)
+{
+	detach_and_pipe_message(dev);
+}
+
+void LinksView::MouseUp(BPoint p)
+{
+	detach_and_pipe_message(dev);
+}
+
+void LinksView::MouseMoved(BPoint p, uint32 transit, const BMessage *dragmsg)
+{
+	detach_and_pipe_message(dev);
+}
+
+void LinksView::MessageReceived(BMessage *msg)
+{
+	switch (msg->what) {
+	case B_REFS_RECEIVED:
+	case B_MOUSE_WHEEL_CHANGED:
+	case B_PASTE:
+	case B_SIMPLE_DATA:
+		detach_and_pipe_message(dev);
+		break;
+	default:
+		BView::MessageReceived(msg);
+	}
+}
+
+void LinksView::KeyDown(const char *s, int32 numBytes)
+{
+	detach_and_pipe_message(dev);
+}
+
+int32 be_app_thread(void *p)
+{
+	be_links_app->Lock();
+	be_links_app->Run();
+	delete be_links_app;
+	return 0;
+}
+
+unsigned char *be_init_driver(unsigned char *param, unsigned char *display)
+{
+	be_links_app = new LinksApplication();
+	if (!be_links_app) {
+		return stracpy((unsigned char *)"Unable to allocate Application object.\n");
+	}
+	if (c_pipe(msg_pipe)) {
+		delete be_links_app;
+		return stracpy((unsigned char *)"Could not create pipe.\n");
+	}
+	fcntl(rpipe, F_SETFL, O_NONBLOCK);
+	fcntl(wpipe, F_SETFL, O_NONBLOCK);
+	set_handlers(rpipe, be_get_event, NULL, NULL);
+	be_app_thread_id = spawn_thread(be_app_thread, "links_app", B_NORMAL_PRIORITY, NULL);
+	resume_thread(be_app_thread_id);
+	be_links_app->Unlock();
+	be_cs_desktop = B_NO_COLOR_SPACE;
+	be_x_size = 640;
+	be_y_size = 480;
+	BScreen d;
+	if (d.IsValid()) {
+		be_cs_desktop = d.ColorSpace();
+		be_x_size = (int)d.Frame().Width() + 1;
+		be_y_size = (int)d.Frame().Height() + 1;
+	}
+	be_win_y_size = be_y_size * 9 / 10;
+	be_win_x_size = be_win_y_size;
+	/*
+	DBG("%d %d\n", be_x_size, be_y_size);
+	DBG("%d %d\n", be_win_x_size, be_win_y_size);
+	*/
+	be_win_y_pos = (be_y_size - be_win_y_size) / 2;
+	be_win_x_pos = be_x_size - be_win_x_size - be_win_y_pos;
+	if (/*be_cs_desktop == B_RGB32 ||*/ be_cs_desktop == B_RGB24 || be_cs_desktop == B_RGB16 || be_cs_desktop == B_RGB15)
+		be_cs_bmp = be_cs_desktop;
+	else if (be_cs_desktop == B_RGB32 || be_cs_desktop == B_RGBA32) be_cs_bmp = B_RGB24;
+	else be_cs_bmp = B_RGB15;
+	be_cs_bmp = B_RGB16; // XXX: DEBUG
+	switch (be_cs_bmp) {
+		case B_RGB24:
+			haiku_driver.depth = 0xc3;
+			break;
+		case B_RGB16:
+			haiku_driver.depth = 0x82;
+			break;
+		case B_RGB15:
+			haiku_driver.depth = 0x7a;
+			break;
+		default:
+			internal_error("unknown depth");
+	}
+	return NULL;
+}
+
+void be_shutdown_driver()
+{
+	status_t ret;
+	//debug((unsigned char *)"D");
+	close(rpipe);
+	close(wpipe);
+	set_handlers(rpipe, NULL, NULL, NULL);
+	//debug((unsigned char *)"DD");
+	be_links_app->PostMessage(B_QUIT_REQUESTED);
+	//debug((unsigned char *)"E");
+	wait_for_thread(be_app_thread_id, &ret);
+	//debug((unsigned char *)"F");
+}
+
+struct graphics_device *be_init_device()
+{
+	LinksView *view;
+	LinksWindow *win;
+	struct graphics_device *dev = (struct graphics_device *)mem_calloc(sizeof(struct graphics_device));
+	if (!dev) return NULL;
+	//dev->drv = &haiku_driver;
+	//debug((unsigned char *)"1");
+	win = new LinksWindow(BRect(be_win_x_pos, be_win_y_pos, be_win_x_pos + be_win_x_size, be_win_y_pos + be_win_y_size));
+	//debug((unsigned char *)"2");
+	if (!win) {
+		mem_free(dev);
+		return NULL;
+	}
+	//debug((unsigned char *)"3");
+	view = new LinksView(win);
+	if (!view) {
+		delete win;
+		mem_free(dev);
+		return NULL;
+	}
+	view->dev = dev;
+	dev->driver_data = view;
+	be_get_size(dev);
+	memcpy(&dev->clip, &dev->size, sizeof(struct rect));
+	//debug((unsigned char *)"4");
+	win->Show();
+	win->Lock();
+	view->MakeFocus();
+	win->Unlock();
+	//debug((unsigned char *)"5");
+	if (initial_refs_msg) {
+		BMessenger msgr(win);
+		if (msgr.IsValid()) {
+			msgr.SendMessage(initial_refs_msg);
+			initial_refs_msg = NULL;
+		}
+	}
+	return dev;
+}
+
+void be_shutdown_device(struct graphics_device *dev)
+{
+	LinksWindow *win = lv(dev)->win;
+	unregister_bottom_half(do_flush, dev);
+	lv(dev)->dev = NULL;
+	win->PostMessage(B_QUIT_REQUESTED);
+	mem_free(dev);
+}
+
+void be_set_title(struct graphics_device *dev, unsigned char *title)
+{
+	LinksWindow *win = lv(dev)->win;
+	lock_dev(dev);
+	win->SetTitle((const char *)title);
+	lv(dev)->d_flush();
+	unlock_dev(dev);
+}
+
+int be_get_empty_bitmap(struct bitmap *bmp)
+{
+	DBG("bmp\n");
+//DBG("bmp (%d, %d) cs %08x\n", bmp->x, bmp->y, be_cs_bmp);
+	BRect r(0, 0, bmp->x - 1, bmp->y - 1);
+	BBitmap *b = new BBitmap(r, /*B_RGB32*/be_cs_bmp);
+	if (!b) {
+		bmp->data = NULL;
+DBG("%s: error 1\n", __FUNCTION__);
+		return 0;
+	}
+	if (!b->IsValid()) {
+		bmp->data = NULL;
+		delete b;
+DBG("%s: error 2\n", __FUNCTION__);
+		return 0;
+	}
+	if (b->LockBits() < B_OK) {
+		bmp->data = NULL;
+		delete b;
+DBG("%s: error 3\n", __FUNCTION__);
+		return 0;
+	}
+	bmp->data = b->Bits();
+	bmp->skip = b->BytesPerRow();
+	bmp->flags = b;
+//DBG("bmp: data %p, skip %d, flags %p\n", bmp->data, bmp->skip, bmp->flags);
+	return 0;
+}
+
+void be_register_bitmap(struct bitmap *bmp)
+{
+	BBitmap *b = (BBitmap *)bmp->flags;
+	b->UnlockBits();
+}
+
+void *be_prepare_strip(struct bitmap *bmp, int top, int lines)
+{
+	DBG("preps\n");
+	BBitmap *b = (BBitmap *)bmp->flags;
+	if (b->LockBits() < B_OK)
+		return NULL;
+	bmp->data = b->Bits();
+	bmp->skip = b->BytesPerRow();
+	return ((char *)bmp->data) + bmp->skip * top;
+}
+
+void be_commit_strip(struct bitmap *bmp, int top, int lines)
+{
+	BBitmap *b = (BBitmap *)bmp->flags;
+	b->UnlockBits();
+}
+
+void be_unregister_bitmap(struct bitmap *bmp)
+{
+	DBG("unb\n");
+	BBitmap *b = (BBitmap *)bmp->flags;
+	delete b;
+}
+
+void be_draw_bitmap(struct graphics_device *dev, struct bitmap *bmp, int x, int y)
+{
+	DBG("drawb\n");
+	BBitmap *b = (BBitmap *)bmp->flags;
+	CLIP_DRAW_BITMAP
+	lock_dev(dev);
+	lv(dev)->DrawBitmap(b, b->Bounds(), BRect(x, y, x + bmp->x - 1, y + bmp->y - 1));
+	lv(dev)->d_flush();
+	unlock_dev(dev);
+}
+
+long be_get_color(int rgb)
+{
+	if (small_color) {
+		get_color32(c, rgb);
+		return *(long *)(void *)&c;
+	} else return rgb & 0xffffff;
+}
+
+void be_fill_area(struct graphics_device *dev, int x1, int y1, int x2, int y2, long color)
+{
+	DBG("fill\n");
+	CLIP_FILL_AREA
+	lock_dev(dev);
+	if (small_color)
+		lv(dev)->SetHighColor(*(rgb_color *)(void *)&color);
+	else
+		lv(dev)->SetHighColor(get_color32(, color));
+	lv(dev)->FillRect(BRect(x1, y1, x2 - 1, y2 - 1));
+	lv(dev)->d_flush();
+	unlock_dev(dev);
+}
+
+void be_draw_hline(struct graphics_device *dev, int x1, int y, int x2, long color)
+{
+	DBG("hline\n");
+	CLIP_DRAW_HLINE
+	lock_dev(dev);
+	if (small_color)
+		lv(dev)->SetHighColor(*(rgb_color *)(void *)&color);
+	else
+		lv(dev)->SetHighColor(get_color32(, color));
+	lv(dev)->StrokeLine(BPoint(x1, y), BPoint(x2 - 1, y));
+	lv(dev)->d_flush();
+	unlock_dev(dev);
+}
+
+void be_draw_vline(struct graphics_device *dev, int x, int y1, int y2, long color)
+{
+	DBG("vline\n");
+	CLIP_DRAW_VLINE
+	lock_dev(dev);
+	if (small_color)
+		lv(dev)->SetHighColor(*(rgb_color *)(void *)&color);
+	else
+		lv(dev)->SetHighColor(get_color32(, color));
+	lv(dev)->StrokeLine(BPoint(x, y1), BPoint(x, y2 - 1));
+	lv(dev)->d_flush();
+	unlock_dev(dev);
+}
+
+int be_scroll(struct graphics_device *dev, struct rect_set **ignore, int scx, int scy)
+{
+	DBG("scroll\n");
+	lock_dev0(dev);
+	lv(dev)->CopyBits(
+		BRect(	dev->clip.x1 - (scx < 0 ? scx : 0),
+			dev->clip.y1 - (scy < 0 ? scy : 0),
+			dev->clip.x2 - (scx >= 0 ? scx : 0) - 1,
+			dev->clip.y2 - (scy >= 0 ? scy : 0) - 1),
+		BRect(	dev->clip.x1 + (scx >= 0 ? scx : 0),
+			dev->clip.y1 + (scy >= 0 ? scy : 0),
+			dev->clip.x2 + (scx < 0 ? scx : 0) - 1,
+			dev->clip.y2 + (scy < 0 ? scy : 0) - 1)
+	);
+	lv(dev)->d_flush();
+	unlock_dev(dev);
+	return 1;
+}
+
+void be_set_clip_area(struct graphics_device *dev)
+{
+	DBG("setc\n");
+	lock_dev(dev);
+	BRegion clip(BRect(dev->clip.x1, dev->clip.y1, dev->clip.x2 - 1, dev->clip.y2 - 1));
+	lv(dev)->ConstrainClippingRegion(&clip);
+	unlock_dev(dev);
+}
+
+void be_flush(struct graphics_device *dev)
+{
+	unregister_bottom_half(do_flush, dev);
+	do_flush(dev);
+}
+
+struct graphics_driver haiku_driver = {
+	(unsigned char *)"haiku",
+	be_init_driver,
+	be_init_device,
+	be_shutdown_device,
+	be_shutdown_driver,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	be_get_empty_bitmap,
+	be_register_bitmap,
+	be_prepare_strip,
+	be_commit_strip,
+	be_unregister_bitmap,
+	be_draw_bitmap,
+	be_get_color,
+	be_fill_area,
+	be_draw_hline,
+	be_draw_vline,
+	be_scroll,
+	be_set_clip_area,
+	be_flush,
+	NULL,				/* block */
+	NULL,				/* unblock */
+	NULL,				/* set_palette */
+	NULL,				/* get_real_colors */
+	be_set_title,
+	NULL,				/* exec */
+	NULL,				/* set_clipboard_text */
+	NULL,				/* get_clipboard_text */
+	0,				/* depth */
+	0, 0,				/* size */
+	0,				/* flags */
+	NULL,				/* param */
+};
+
+#endif /* GRDRV_HAIKU */
+
+#endif
diff --git a/links-haiku.rdef b/links-haiku.rdef
new file mode 100644
index 0000000..b18b11c
--- /dev/null
+++ b/links-haiku.rdef
@@ -0,0 +1,125 @@
+/*
+** links-haiku.rdef
+**
+** Automatically generated by BResourceParser on
+** Thursday, December 13, 2007 at 23:46:45.
+**
+*/
+
+resource(1, "BEOS:APP_FLAGS") (#'APPF') $"01000000";
+
+resource(1, "BEOS:APP_VERSION") #'APPV' array {
+	$"02000000010000000000000000000000210000006C696E6B7320322E31707265"
+	$"3333000000000000000000000000000000000000000000000000000000000000"
+	$"00000000000000000000000000000000000000004C696E6B732062726F777365"
+	$"7220322E31707265333300000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000"
+};
+
+resource(101, "BEOS:L:STD_ICON") #'ICON' array {
+	$"2A2A2A2A2A2A2A2A2A2A2A2A2A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2A2A2A2A2A2A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2B2B2B2B2B2B2B2B2B2B2B2C0000363434343434343434343434343434"
+	$"2A2A2A3200000000000000000000000000363434343434343434343434343434"
+	$"2A2A2A2FF1313200000000000131310000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A30000000002B2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2A2A2A2A2A2A2A2F000000002A2A2C0000363434343434343434343434343434"
+	$"2C2C2C2C2C2C2C30000000002C2C2D0000373636363636363636363636363636"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"0000000000000000000000000000000000000000000000000000000000000000"
+	$"2222222222222226000000002222230000151A1A1A1A1A1A1A1A1A1A1A1A1A1A"
+	$"20202020202020250000000020202200001A3F3F3F3F3F3F3F3F3F3F3F3F3F3F"
+	$"20202020202020250000000020202200001A3F3F3F3F3F3F3F1501113F3F3F3F"
+	$"20202020202020250000000020202200001A3F3F3F3F3F3F3F0E00133F3F3F3F"
+	$"20202020202020250000000020202200001A3F3F3F3F3F3F3F0500163F3F3F3F"
+	$"20202020202020250000000020202200001A3F3F3F3F3F3F1A0000193F3F3F3F"
+	$"20202020202020250000000020202200001A3F3F3F3F3F3F0C00001B3F3F3F3F"
+	$"20202020202020250000000020202200001A3F3F3F3F3F190000001E3F3F3F3F"
+	$"20202020202020250000000020202200001A3F3F3F3F1A030000013F3F3F3F3F"
+	$"20202020202020270000000023202200001A3F1E170C00000000043F3F3F3F3F"
+	$"2020202628292900000000000029290000040300000000000000063F3F3F3F3F"
+	$"20202027292929292929292929292900000203030303030303030B3F3F3F3F3F"
+	$"20202020202020202020202020202200001A3F3F3F3F3F3F3F3F3F3F3F3F3F3F"
+	$"20202020202020202020202020202200001A3F3F3F3F3F3F3F3F3F3F3F3F3F3F"
+	$"20202020202020202020202020202200001A3F3F3F3F3F3F3F3F3F3F3F3F3F3F"
+};
+
+resource(101, "BEOS:M:STD_ICON") #'MICN' array {
+	$"2A2A2A2A2A2A2A303A34343434343434"
+	$"2A2C3030303030F73A34343434343434"
+	$"2A2B2D300000EB323A34343434343434"
+	$"2A2A2A2C00002A303A34343434343434"
+	$"2A2A2A2C00002A303A34343434343434"
+	$"2A2A2A2C00002A303A34343434343434"
+	$"2A2A2A2C00002A303A34343434343434"
+	$"303030310000F1333D3A3A3A3A3A3A3A"
+	$"2626262700002629050D0D0D0D0D0D0D"
+	$"20202022000020260D3F3F3F1D143F3F"
+	$"20202022000020260D3F3F3F140A3F3F"
+	$"20202022000020260D3F3F3F090D3F3F"
+	$"20202022000020260D3F3F16000F3F3F"
+	$"20222427000026280710090000123F3F"
+	$"202225252525252807111111111A3F3F"
+	$"20202020202020260D3F3F3F3F3F3F3F"
+};
+
+resource(101, "BEOS:ICON") #'VICN' array {
+	$"6E6369661305000200060237E670B8880E39469D39AE144A52234B0D2500C6D7"
+	$"F5FF6B94DD03EC6666020006023B2B47BB18653D0FA53D225148297046CA1900"
+	$"00FF00FFA9FF00020016023B2B47BB18653D0FA53D225148297046CA1900FFFF"
+	$"8A020006023B3049396B0ABA90833C646E4A101543299500FFFFFFFF52FF5202"
+	$"0016023B3049396B0ABA90833C646E4A101543299500FFFFC9020006023C71E3"
+	$"3A0C78BA15E43C7D2149055549455700E3EDFFFF9EC2FF020006023CD8653068"
+	$"26B065D13CD5A34A6E4A46E21900FFDCDCFFDA5858020006023A1DA6393F04BB"
+	$"B5BC3C6B074AEA364809110087CA05FF026802020016023C00913B1266BB9E06"
+	$"3C5B934A01F04914EC00FFFF4E03003CB00200060230B31E3A09B9BB024238A1"
+	$"2F4BAB534AFF0B00A3043CFFFFDCE603CD4D4D030D296402000602BD498B3E11"
+	$"59BF219BBE7D2F4BE71F4AB31300C13E3EFFE27A7A040174020016023F2938BB"
+	$"F60A3BA9823EEC25C40E6348C15D0099FF00020016023E8FA33A7B71BA9D783E"
+	$"B2C049F7BAC28CE500C8FF00130A06322E323E42464C3C4C2C3D260A04322E32"
+	$"3E424642350A04322E42354C2C3D260A04423542464C3C4C2C0A0338423C4D3C"
+	$"440A08335C395C41544F5C555C6051594D3E510A0422422252325A32490A0422"
+	$"4232493C402D3A0A043249325A3C503C400A043E424E495840493A0A043E524E"
+	$"5A4E493E420A1243C97243C375BF66C2A93F503C5133C4F03330342F3830382D"
+	$"2927292A2C2C2D2E2DC2F2B7B1C3BEB5E1C358B5E1C4AA0A042C252927382D3B"
+	$"2B0A04364B334D3E5241500A0442463F48434A46480A042A4727492B4B2E490A"
+	$"04382D38303B2E3B2B0A04434A4358465646480A04332F334D364B362D160A10"
+	$"01052020230A1001052022120A00010030103701178400040A0101012010370A"
+	$"0B01032010370A0E0104201D250A0101072020230A00010030101C0117840004"
+	$"0A02010A2004080A0C010320101C0A0801092004080A00010030283901178400"
+	$"040A0401012028390A0601022028390A0A01032028390A000100302A20011784"
+	$"00040A030101202A200A050102202A200A090103202A200A12040C0D0E0F000A"
+	$"0003101211000A11010B00"
+};
+
+resource(1, "BEOS:APP_SIG") (#'MIMS') "application/x-vnd.links";
+
+resource(1, "BEOS:FILE_TYPES") message {
+	"types" = "text/html",
+	"types" = "application/x-vnd.Be-bookmark",
+	"types" = "application/x-vnd.Be.URL.http"
+};
diff --git a/links.h b/links.h
index 7264a8b..d857c6f 100644
--- a/links.h
+++ b/links.h
@@ -1061,6 +1061,8 @@ void os_detach_console(void);
 int os_default_language(void);
 int os_default_charset(void);
 
+char *os_get_home(void);
+
 /* memory.c */
 
 #define SH_CHECK_QUOTA		0
diff --git a/os_dep.c b/os_dep.c
index 2305f3c..a9b6a64 100644
--- a/os_dep.c
+++ b/os_dep.c
@@ -29,6 +29,10 @@
 #include <pthread.h>
 #endif
 
+#ifdef HAIKU
+#include <FindDirectory.h>
+#endif
+
 #ifdef OS2
 
 #define INCL_MOU
@@ -518,7 +522,7 @@ void os_free_clipboard(void)
 
 /* Terminal size */
 
-#if defined(UNIX) || defined(OS2) || defined(WIN) || defined(INTERIX) || defined(BEOS) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD) || defined(OPENVMS)
+#if defined(UNIX) || defined(OS2) || defined(WIN) || defined(INTERIX) || defined(BEOS) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD) || defined(OPENVMS) || defined(HAIKU)
 static void (*terminal_resize_callback)(int, int);
 #endif
 
@@ -558,7 +562,7 @@ static void terminal_resize_poll(int x, int y)
 
 #endif
 
-#if defined(UNIX) || defined(OS2) || defined(WIN) || defined(INTERIX) || defined(BEOS) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD) || defined(OPENVMS)
+#if defined(UNIX) || defined(OS2) || defined(WIN) || defined(INTERIX) || defined(BEOS) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD) || defined(OPENVMS) || defined(HAIKU)
 
 #if defined(SIGWINCH) && !defined(OS2) && !defined(OPENVMS)
 static void sigwinch(void *s)
@@ -945,7 +949,7 @@ int is_xterm(void)
 	return xt;
 }
 
-#elif defined(BEOS) || defined(ATHEOS) || defined(DOS)
+#elif defined(BEOS) || defined(ATHEOS) || defined(DOS) || defined(HAIKU)
 
 int is_xterm(void)
 {
@@ -1112,6 +1116,12 @@ void init_os_terminal(void)
 		fatal_exit("Links doesn't work in detached session");
 	}
 #endif
+#ifdef HAIKU
+	if (getenv("TERM") == NULL) {
+		/* probably launched from Tracker or Deskbar, force graphics mode */
+		force_g = 1;
+	}
+#endif
 }
 
 #ifdef INTERIX
@@ -1313,7 +1323,7 @@ unsigned char *os_fixup_external_program(unsigned char *prog)
 #endif
 
 
-#if defined(UNIX) || defined(INTERIX) || defined(BEOS) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD) || defined(OPENVMS) || defined(DOS)
+#if defined(UNIX) || defined(INTERIX) || defined(BEOS) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD) || defined(OPENVMS) || defined(DOS) || defined(HAIKU)
 
 #if defined(BEOS) && defined(HAVE_SETPGID)
 
@@ -2081,7 +2091,7 @@ static uint32 bgat(void *t)
 
 #endif
 
-#if defined(UNIX) || defined(OS2) || defined(WIN) || defined(INTERIX) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD)
+#if defined(UNIX) || defined(OS2) || defined(WIN) || defined(INTERIX) || defined(RISCOS) || defined(ATHEOS) || defined(SPAD) || defined(HAIKU)
 
 void terminate_osdep(void)
 {
@@ -2098,7 +2108,7 @@ void unblock_stdin(void) {}
 
 #if defined(BEOS)
 
-#include <be/kernel/OS.h>
+#include <kernel/OS.h>
 
 static int thr_sem_init = 0;
 static sem_id thr_sem;
@@ -2891,6 +2901,13 @@ int get_system_env(void)
 	return 0;
 }
 
+#elif defined(HAIKU)
+
+int get_system_env(void)
+{
+	return ENV_BE;
+}
+
 #elif defined(WIN)
 
 int get_system_env(void)
@@ -3018,6 +3035,14 @@ static int open_in_new_be(struct terminal *term, unsigned char *exe, unsigned ch
 }
 #endif
 
+#ifdef HAIKU
+static int open_in_new_haiku(struct terminal *term, unsigned char *exe, unsigned char *param)
+{
+	exec_new_links(term, cast_uchar "Terminal", exe, param);
+	return 0;
+}
+#endif
+
 #ifdef G
 static int open_in_new_g(struct terminal *term, unsigned char *exe, unsigned char *param)
 {
@@ -3066,6 +3091,9 @@ static const struct {
 #ifdef BEOS
 	{ENV_BE, open_in_new_be, TEXT_(T_BEOS_TERMINAL), TEXT_(T_HK_BEOS_TERMINAL)},
 #endif
+#ifdef HAIKU
+	{ENV_BE, open_in_new_haiku, TEXT_(T_BEOS_TERMINAL), TEXT_(T_HK_BEOS_TERMINAL)},
+#endif
 #ifdef G
 	{ENV_G, open_in_new_g, TEXT_(T_WINDOW), TEXT_(T_HK_WINDOW)},
 #endif
@@ -3113,6 +3141,9 @@ int can_open_os_shell(int environment)
 #ifdef BEOS
 	if (!(environment & ENV_BE)) return 0;
 #endif
+#ifdef HAIKU
+	if (!(environment & ENV_BE)) return 0;
+#endif
 #ifdef G
 	if (F && drv->flags & GD_NO_OS_SHELL) return 0;
 #endif
@@ -3372,3 +3403,17 @@ int os_default_charset(void)
 }
 
 #endif
+
+char *os_get_home(void)
+{
+#ifdef HAIKU
+	char *result = cast_uchar mem_alloc(B_FILE_NAME_LENGTH);
+	if (find_directory(B_USER_SETTINGS_DIRECTORY, -1, 1, result, B_FILE_NAME_LENGTH) != B_OK) {
+		mem_free(result);
+		return NULL;
+	}
+	return result;
+#else
+	return NULL;
+#endif
+}
diff --git a/os_dep.h b/os_dep.h
index 668718b..ace6b4d 100644
--- a/os_dep.h
+++ b/os_dep.h
@@ -29,7 +29,7 @@
 #define WIN
 #elif defined(__INTERIX)
 #define INTERIX
-#elif defined(__BEOS__) || defined(__HAIKU__)
+#elif defined(__BEOS__)
 #define BEOS
 #elif defined(__riscos__)
 #define RISCOS
@@ -41,6 +41,8 @@
 #define OPENVMS
 #elif defined(__DJGPP)
 #define DOS
+#elif defined(__HAIKU__)
+#define HAIKU
 #else
 #define UNIX
 #endif
@@ -166,6 +168,25 @@ static inline int dir_sep(unsigned char x) { return x == '/'; }
 
 #include "beos.h"
 
+#elif defined(HAIKU)
+
+static inline int dir_sep(unsigned char x) { return x == '/'; }
+#define NEWLINE "\n"
+#define NO_ASYNC_LOOKUP /* async lookup works on BeOS but crashes the Haiku kernel */
+#define FS_UNIX_RIGHTS
+#define FS_UNIX_SOFTLINKS
+#define FS_UNIX_USERS
+/* TODO: allocate new SYS_* or replace SYS_BEOS */
+#define SYSTEM_ID SYS_BEOS
+#define SYSTEM_NAME "Haiku"
+#define DEFAULT_SHELL "/bin/sh"
+#define GETSHELL getenv("SHELL")
+#define NO_CTRL_Z
+#define SET_WINDOW_TITLE_UTF_8
+#define SHARED_CONFIG_DIR "/etc/"
+#define NO_FORK_ON_EXIT
+#define ASSOC_BLOCK
+
 #elif defined(RISCOS)
 
 static inline int dir_sep(unsigned char x) { return x == '/' || x == '\\'; }
diff --git a/os_depx.h b/os_depx.h
index c8f9db2..2fe6aa7 100644
--- a/os_depx.h
+++ b/os_depx.h
@@ -152,6 +152,10 @@ int bounced_write(int fd, const void *buf, size_t size);
 #endif
 #endif
 
+#ifdef HAIKU
+/* nothing so far */
+#endif
+
 #ifdef OPENVMS
 #if defined(__INITIAL_POINTER_SIZE)
 #if __INITIAL_POINTER_SIZE == 64
@@ -377,6 +381,9 @@ int vga_select(int n, fd_set *r, fd_set *w, fd_set *e, struct timeval *t);
 #elif defined(GRDRV_ATHEOS)
 #define loop_select ath_select
 int ath_select(int n, fd_set *r, fd_set *w, fd_set *e, struct timeval *t);
+#elif defined(GRDRV_HAIKU)
+#define loop_select be_loop_select
+int be_loop_select(int n, fd_set *r, fd_set *w, fd_set *e, struct timeval *t);
 #else
 #define loop_select select
 #endif
-- 
2.21.0

