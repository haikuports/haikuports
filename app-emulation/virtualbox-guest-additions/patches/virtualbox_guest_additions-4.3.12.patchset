From 7ecfc9a6fb10d5a6add5d8a2fe1724a3c5b7236d Mon Sep 17 00:00:00 2001
From: Sergei Reznikov <diver@gelios.net>
Date: Wed, 20 Dec 2017 12:07:29 +0300
Subject: Add Haiku support


diff --git a/Config.kmk b/Config.kmk
index 5cae164..ac714bb 100644
--- a/Config.kmk
+++ b/Config.kmk
@@ -1334,7 +1334,7 @@ ifndef VBOX_GCC_TOOL
   VBOX_GCC_TOOL := GXX4MACHO
  else ifeq ($(KBUILD_TARGET),haiku)
   # Haiku shouldn't pass '-r' to the linker by default
-  VBOX_GCC_TOOL := GXX3PLAIN
+  VBOX_GCC_TOOL := GXX2PLAIN
  else ifeq ($(KBUILD_TARGET),solaris)
   VBOX_GCC_TOOL := GXX3PLAIN
   VBOX_GCC32_TOOL := GXX3PLAIN
@@ -1475,8 +1475,14 @@ VBOX_GCC_WARN_PEDANTIC = -Wshadow $(VBOX_GCC_WARN) -Wno-long-long
 ifdef VBOX_WITH_MASOCHISTIC_WARNINGS
  VBOX_GCC_WARN_PEDANTIC += -Wunused-variable -Wunused-function -Wunused-label -Wunused-parameter
 endif
-VBOX_GCC_PEDANTIC_CXX ?= -pedantic -Wshadow $(VBOX_GCC_WARN_PEDANTIC) -Wno-long-long $(VBOX_GCC_Wno-delete-non-virtual-dtor)
-VBOX_GCC_PEDANTIC_C   ?= -pedantic -Wshadow $(VBOX_GCC_WARN_PEDANTIC) -Wno-long-long -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations -Werror-implicit-function-declaration
+VBOX_GCC_PEDANTIC_CXX ?= -Wshadow $(VBOX_GCC_WARN_PEDANTIC) -Wno-long-long $(VBOX_GCC_Wno-delete-non-virtual-dtor)
+VBOX_GCC_PEDANTIC_C   ?= -Wshadow $(VBOX_GCC_WARN_PEDANTIC) -Wno-long-long -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations -Werror-implicit-function-declaration
+ifeq ($(KBUILD_TARGET),haiku)
+ # gcc2 complains about 'volatile' undeclared
+ # TODO: filter out -pedantic
+ VBOX_GCC_PEDANTIC_CXX += -D__volatile__=
+ VBOX_GCC_PEDANTIC_C   += -D__volatile__=
+endif
 ifeq ($(KBUILD_TARGET),win)
  VBOX_C_CXX_FLAGS_NO_UNUSED_PARAMETERS = #-Wdxxxx
 else
@@ -2728,17 +2734,18 @@ ifeq ($(KBUILD_HOST),haiku)
   # @param 1  The file to add resources to.
   # @param 2  The resource files.
   # @param 3  The target name.
-define VBOX_HAIKU_XRES_SETVER_FN
-	$(if $(2),$(call MSG_TOOL,HaikuAddResources,$(3),$(2))
-	$(QUIET)$(VBOX_HAIKU_XRESTOOL) -o $(1) $(2),)
-	$(call MSG_TOOL,HaikuSetVersion,$(3))
-	$(QUIET)$(VBOX_HAIKU_SETVERSIONTOOL) $(1) \
+#define VBOX_HAIKU_XRES_SETVER_FN
+VBOX_HAIKU_XRES_SETVER_FN ?= \
+	$$(NLTAB)$(if $(2),$(call MSG_TOOL,HaikuAddResources,$(3),$(2))\
+	$$(NLTAB)$(QUIET)$(VBOX_HAIKU_XRESTOOL) -o $(1) $(2),)\
+	$$(NLTAB)$(call MSG_TOOL,HaikuSetVersion,$(3))\
+	$$(NLTAB)$(QUIET)$(VBOX_HAIKU_SETVERSIONTOOL) $(1) \
 		-app $(VBOX_VERSION_MAJOR) $(VBOX_VERSION_MINOR) $(VBOX_VERSION_BUILD) d $(VBOX_SVN_REV) \
 		-short "$(VBOX_PRODUCT)" \
-		-long "$(VBOX_PRODUCT) $(VBOX_VERSION_STRING) $(shell /bin/echo -e '\xC2\xA9')2009-$(VBOX_C_YEAR) $(VBOX_VENDOR)"
-	$(call MSG_TOOL,HaikuMimeSet,$(3))
-	$(QUIET)$(VBOX_HAIKU_MIMESETTOOL) -f $(1)
-endef
+		-long "$(VBOX_PRODUCT) $(VBOX_VERSION_STRING) $(shell /bin/echo -e '\xC2\xA9')2009-$(VBOX_C_YEAR) $(VBOX_VENDOR)"\
+	$$(NLTAB)$(call MSG_TOOL,HaikuMimeSet,$(3))\
+	$$(NLTAB)$(QUIET)$(VBOX_HAIKU_MIMESETTOOL) -f $(1)
+#endef
 
  VBOX_HAIKU_XRES_SETVER_CMDS  ?= $(if $(eq $(tool_do),LINK_PROGRAM),$(call VBOX_HAIKU_XRES_SETVER_FN,$(out),$($(target)_RSRCS),$(target)),)
 endif
@@ -3460,24 +3467,26 @@ endif # FreeBSD
 
 ifeq ($(KBUILD_TARGET),haiku)
 ## The Haiku include directories
-VBOX_HAIKU_SYS_INCS ?= /boot/develop/headers/os/kernel /boot/develop/headers/os/drivers
+VBOX_HAIKU_SYS_INCS ?= /system/develop/headers/os/kernel /system/develop/headers/os/drivers
 
 TEMPLATE_VBOXR0DRV_TOOL                = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXR0DRV_LDTOOL              = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXR0DRV_DEFS                = _KERNEL_MODE=1 _STRICT_STDC IN_RING0 IN_RT_R0
 TEMPLATE_VBOXR0DRV_INCS                = $(VBOX_HAIKU_SYS_INCS)
 #TODO: sort this out
-TEMPLATE_VBOXR0DRV_LDFLAGS             = -shared -no-undefined -dc -dy -nostdlib -rpath-link /boot/develop/lib/x86 --no-add-needed /boot/develop/lib/x86/_KERNEL_ --no-add-needed /boot/develop/lib/x86/haiku_version_glue.o
+TEMPLATE_VBOXR0DRV_LDFLAGS             = -shared -no-undefined -dc -dy -nostdlib -rpath-link /system/develop/lib --no-add-needed /system/develop/lib/_KERNEL_ --no-add-needed /system/develop/lib/haiku_version_glue.o
 TEMPLATE_VBOXR0DRV_CFLAGS              = -no-fpic \
 	$(VBOX_GCC_WARN) -Wstrict-prototypes $(VBOX_GCC_Wno-pointer-sign) -Wno-sign-compare \
 	$(VBOX_GCC_fno-stack-protector) $(VBOX_GCC_R0_OPT) $(VBOX_GCC_R0_FP) -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration
-TEMPLATE_VBOXR0DRV_CFLAGS.x86          = -mno-sse -mno-mmx -mno-sse2 -mno-3dnow
-TEMPLATE_VBOXR0DRV_CFLAGS.x86          = -m32 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow
+#TEMPLATE_VBOXR0DRV_CFLAGS.x86          = -mno-sse -mno-mmx -mno-sse2 -mno-3dnow
+#TEMPLATE_VBOXR0DRV_CFLAGS.x86          = -m32 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow
+TEMPLATE_VBOXR0DRV_CFLAGS.x86          = 
+
 TEMPLATE_VBOXR0DRV_CFLAGS.amd64        = -m64 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow \
 	-fno-reorder-blocks -ffreestanding -fno-asynchronous-unwind-tables -funit-at-a-time \
 	-Wno-sign-compare -Wdeclaration-after-statement
 TEMPLATE_VBOXR0DRV_CXXFLAGS           = -no-fpic -Wpointer-arith \
-	-Wshadow -Wuninitialized -Wunused-function -Wunused-label -Wunused-value -Wunused-variable \
+	-Wshadow -Wuninitialized \
 	-Wformat \
 	-O2 -nodefaultlibs -fno-omit-frame-pointer -fno-strict-aliasing -fno-common -fno-exceptions -fno-rtti
 TEMPLATE_VBOXR0DRV_CXXFLAGS.x86       = $(TEMPLATE_VBOXR0DRV_CFLAGS.x86) -fno-exceptions -fno-rtti
@@ -3580,7 +3589,9 @@ ifeq ($(KBUILD_TARGET),win)
 else # the gcc guys
 TEMPLATE_VBOXR3EXE_TOOL                = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXR3EXE_CXXFLAGS            = -g $(VBOX_GCC_pipe) $(VBOX_GCC_PEDANTIC_CXX) $(VBOX_GCC_Wno-variadic-macros) $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing $(VBOX_GCC_fvisibility-hidden) $(VBOX_GCC_fvisibility-inlines-hidden)
+ifneq ($(KBUILD_TARGET),haiku)
 TEMPLATE_VBOXR3EXE_CXXFLAGS.x86        = -m32
+endif
 TEMPLATE_VBOXR3EXE_CXXFLAGS.amd64      = -m64
 TEMPLATE_VBOXR3EXE_CXXFLAGS.sparc32    = -m32
 TEMPLATE_VBOXR3EXE_CXXFLAGS.sparc64    = -m64
@@ -3602,7 +3613,9 @@ TEMPLATE_VBOXR3EXE_OBJCXXFLAGS.x86     = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.x86)
 TEMPLATE_VBOXR3EXE_OBJCXXFLAGS.amd64   = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.amd64)
 TEMPLATE_VBOXR3EXE_OBJCXXFLAGS.debug   = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.debug)
 TEMPLATE_VBOXR3EXE_OBJCXXFLAGS.kprofile= $(TEMPLATE_VBOXR3EXE_CXXFLAGS.kprofile)
+ifneq ($(KBUILD_TARGET),haiku)
 TEMPLATE_VBOXR3EXE_LDFLAGS.x86         = -m32
+endif
 TEMPLATE_VBOXR3EXE_LDFLAGS.amd64       = -m64
 TEMPLATE_VBOXR3EXE_LDFLAGS.sparc32     = -m32
 TEMPLATE_VBOXR3EXE_LDFLAGS.sparc64     = -m64
@@ -3628,9 +3641,11 @@ TEMPLATE_VBOXR3EXE_LDFLAGS.darwin.x86  = -read_only_relocs suppress
    TEMPLATE_VBOXR3EXE_CXXFLAGS := $(filter-out -pedantic,$(TEMPLATE_VBOXR3EXE_CXXFLAGS)) -fdollars-in-identifiers # annoying gcc option precedence.
   endif
  else ifeq ($(KBUILD_TARGET),haiku)
-TEMPLATE_VBOXR3EXE_TOOL                = GXX3
+TEMPLATE_VBOXR3EXE_TOOL                = GXX2
 TEMPLATE_VBOXR3EXE_POST_CMDS          = $(VBOX_HAIKU_XRES_SETVER_CMDS)
-TEMPLATE_VBOXR3EXE_LIBS                = network iconv stdc++ supc++
+#TEMPLATE_VBOXR3EXE_POST_CMDS          = $(if $(eq $(tool_do),LINK_PROGRAM),$(call VBOX_HAIKU_XRES_SETVER_FN,$(out),$($(target)_RSRCS),$(target)),)
+#TEMPLATE_VBOXR3EXE_LIBS                = network iconv stdc++ supc++
+TEMPLATE_VBOXR3EXE_LIBS                = network iconv stdc++.r4
 TEMPLATE_VBOXR3EXE_LIBPATH            += \
 	/boot/common/lib
 # Haiku uses PIC by default...
@@ -4804,7 +4819,9 @@ else
 # (gcc of some kind )
 TEMPLATE_VBOXBLDPROG_TOOL                = GXX3
 TEMPLATE_VBOXBLDPROG_CFLAGS              = -g $(VBOX_GCC_pipe) $(VBOX_GCC_PEDANTIC_C) $(VBOX_GCC_Wno-variadic-macros)
-TEMPLATE_VBOXBLDPROG_CFLAGS.x86          = -m32
+ifneq ($(KBUILD_TARGET),haiku)
+TEMPLATE_VBoxBldProg_CFLAGS.x86          = -m32
+endif
 TEMPLATE_VBOXBLDPROG_CFLAGS.sparc32      = -m32
 TEMPLATE_VBOXBLDPROG_CFLAGS.amd64        = -m64
 TEMPLATE_VBOXBLDPROG_CFLAGS.sparc64      = -m64
@@ -4812,7 +4829,9 @@ TEMPLATE_VBOXBLDPROG_CFLAGS.release      = -O2 -fno-omit-frame-pointer -fno-stri
 TEMPLATE_VBOXBLDPROG_CFLAGS.profile      = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.profile)
 TEMPLATE_VBOXBLDPROG_CFLAGS.kprofile     = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.kprofile)
 TEMPLATE_VBOXBLDPROG_CXXFLAGS            = -g $(VBOX_GCC_pipe) $(VBOX_GCC_PEDANTIC_CXX) $(VBOX_GCC_Wno-variadic-macros)
-TEMPLATE_VBOXBLDPROG_CXXFLAGS.x86        = -m32
+ifneq ($(KBUILD_TARGET),haiku)
+TEMPLATE_VBoxBldProg_CXXFLAGS.x86        = -m32
+endif
 TEMPLATE_VBOXBLDPROG_CXXFLAGS.sparc32    = -m32
 TEMPLATE_VBOXBLDPROG_CXXFLAGS.amd64      = -m64
 TEMPLATE_VBOXBLDPROG_CXXFLAGS.sparc64    = -m64
@@ -4831,7 +4850,9 @@ TEMPLATE_VBOXBLDPROG_OBJCXXFLAGS.amd64   = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.amd64
 TEMPLATE_VBOXBLDPROG_OBJCXXFLAGS.release = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.release)
 TEMPLATE_VBOXBLDPROG_OBJCXXFLAGS.profile = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.profile)
 TEMPLATE_VBOXBLDPROG_OBJCXXFLAGS.kprofile= $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.kprofile)
-TEMPLATE_VBOXBLDPROG_LDFLAGS.x86         = -m32
+ifneq ($(KBUILD_TARGET),haiku)
+TEMPLATE_VBoxBldProg_LDFLAGS.x86         = -m32
+endif
 TEMPLATE_VBOXBLDPROG_LDFLAGS.sparc32     = -m32
 TEMPLATE_VBOXBLDPROG_LDFLAGS.amd64       = -m64
 TEMPLATE_VBOXBLDPROG_LDFLAGS.sparc64     = -m64
@@ -4873,7 +4894,7 @@ TEMPLATE_VBOXBLDPROG_LDFLAGS.darwin      = $(VBOX_DARWIN_DEF_SDK_LDFLAGS)
   endif
 TEMPLATE_VBOXBLDPROG_LIBS                =
  else ifeq ($(KBUILD_HOST),haiku)
-TEMPLATE_VBOXBLDPROG_TOOL                = GXX3
+TEMPLATE_VBOXBLDPROG_TOOL                = GXX2
 TEMPLATE_VBOXBLDPROG_LIBS                = network iconv
 TEMPLATE_VBOXBLDPROG_LIBPATH            += \
 	/boot/common/lib
diff --git a/configure b/configure
index 126e782..b4a3f25 100755
--- a/configure
+++ b/configure
@@ -417,6 +417,9 @@ check_gcc()
       elif [ $cc_maj -eq 4 -a $cc_min -eq 0 -a "$OS" = "darwin" ]; then
         log_success "found version $cc_ver"
       # gcc-4.0 is allowed for Darwin only
+      elif [ $cc_maj -eq 2 -a $cc_min -eq 95 -a "$OS" = "haiku" ]; then
+        log_success "found version $cc_ver (only for building guest additions)"
+      # gcc-2.95 is allowed for Haiku only; required to build guest additions
       elif [ $cc_maj -lt 3 \
              -o \( $cc_maj -eq 3 -a $cc_min -lt 2 \) \
              -o \( $cc_maj -eq 4 -a $cc_min -lt 1 -a "$OS" != "darwin" \) \
@@ -2597,6 +2600,12 @@ if [ $OSE -ge 1 ]; then
   else
     cnf_append "VBOX_WITH_LINUX_ADDITIONS" ""
   fi
+
+  if [ "$OS" = "haiku" ]; then
+    cnf_append "VBOX_WITH_HAIKU_ADDITIONS" "1"
+  else
+    cnf_append "VBOX_WITH_HAIKU_ADDITIONS" ""
+  fi
   echo >> $CNF
 fi
 
diff --git a/include/iprt/cdefs.h b/include/iprt/cdefs.h
index 744fd48..51a8f65 100644
--- a/include/iprt/cdefs.h
+++ b/include/iprt/cdefs.h
@@ -1142,7 +1142,7 @@
  * @param   type    The return type of the function declaration.
  * @remarks Use sparsely and with care. Don't use this macro on C++ methods.
  */
-#ifdef __GNUC__
+#if defined(__GNUC__) && (__GNUC__ >= 3)
 # define DECL_FORCE_INLINE(type)    __attribute__((__always_inline__)) DECLINLINE(type)
 #elif defined(_MSC_VER)
 # define DECL_FORCE_INLINE(type)    __forceinline type
diff --git a/include/iprt/cpp/autores.h b/include/iprt/cpp/autores.h
index 0edad23..217d555 100644
--- a/include/iprt/cpp/autores.h
+++ b/include/iprt/cpp/autores.h
@@ -51,7 +51,7 @@ inline T RTAutoResNil(void)
 }
 
 /** Specialisation of RTAutoResNil for RTFILE */
-template <>
+template <RTFILE>
 inline RTFILE RTAutoResNil(void)
 {
     return NIL_RTFILE;
diff --git a/include/iprt/types.h b/include/iprt/types.h
index 3c88ec2..f4382e8 100644
--- a/include/iprt/types.h
+++ b/include/iprt/types.h
@@ -149,6 +149,13 @@ RT_C_DECLS_END
 #  undef false
 #  undef true
 #  undef bool
+/*
+# elif defined(RT_OS_HAIKU)
+#warning HAIKU_B
+#  include <stdbool.h>
+#  include <stddef.h>
+#  include <sys/types.h>
+*/
 # else
 #  include <stddef.h>
 #  include <sys/types.h>
@@ -206,8 +213,13 @@ typedef uint8_t bool;
 #   ifndef __bool_true_false_are_defined
 typedef _Bool bool;
 #   endif
+#  elif defined(RT_OS_HAIKU)
+#   ifndef __bool_true_false_are_defined
+#    include <stdbool.h>
+typedef _Bool bool;
+#   endif
 #  else
-#   if (defined(RT_OS_DARWIN) || defined(RT_OS_HAIKU)) && (defined(_STDBOOL_H) || defined(__STDBOOL_H))
+#   if (defined(RT_OS_DARWIN) || defined(RT_OS_HAIKU)) && (defined(_STDBOOL_H) || defined(__STDBOOL_H) || defined(__STDBOOL_H__))
 #    undef bool
 #   endif
 typedef _Bool bool;
diff --git a/kBuild/tools/GCC2.kmk b/kBuild/tools/GCC2.kmk
new file mode 100644
index 0000000..3b64888
--- /dev/null
+++ b/kBuild/tools/GCC2.kmk
@@ -0,0 +1,352 @@
+# $Id: GCC2.kmk 2541 2011-08-03 09:51:30Z bird $
+## @file
+# kBuild Tool Config - Generic GCC v2.95.x or later Using The System GCC and Binutils.
+#
+
+#
+# Copyright (c) 2004-2010 knut st. osmundsen <bird-kBuild-spamx@anduin.net>
+#
+# This file is part of kBuild.
+#
+# kBuild is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# kBuild is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with kBuild; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+#
+# As a special exception you are granted permission to include this file, via
+# the kmk include directive, as you wish without this in itself causing the
+# resulting makefile, program or whatever to be covered by the GPL license.
+# This exception does not however invalidate any other reasons why the makefile,
+# program, whatever should not be covered the GPL.
+#
+#
+
+TOOL_GCC2 := Generic GCC v2.95.x or later Using The System GCC and Binutils.
+
+# Tool Specific Properties
+TOOL_GCC2_CC  ?= gcc$(HOSTSUFF_EXE)
+TOOL_GCC2_CXX ?= g++$(HOSTSUFF_EXE)
+TOOL_GCC2_AS  ?= gcc$(HOSTSUFF_EXE)
+ifeq ($(KBUILD_TARGET),solaris) ## @todo drop the MRI script!
+ TOOL_GCC2_AR ?= gar$(HOSTSUFF_EXE)
+else
+ TOOL_GCC2_AR ?= ar$(HOSTSUFF_EXE)
+endif
+ifeq ($(KBUILD_TARGET),os2)
+ TOOL_GCC2_AR_IMP ?= emximp$(HOSTSTUFF_EXE)
+else
+ TOOL_GCC2_AR_IMP ?= $(ECHO) not supported!
+endif
+TOOL_GCC2_LD ?= gcc$(HOSTSUFF_EXE)
+TOOL_GCC2_LD_SYSMOD ?= ld$(HOSTSUFF_EXE)
+ifndef TOOL_GCC2_LDFLAGS.$(KBUILD_TARGET)
+ TOOL_GCC2_LDFLAGS.dll ?= -shared
+else
+ TOOL_GCC2_LDFLAGS.dll ?= $(TOOL_GCC2_LDFLAGS.$(KBUILD_TARGET))
+endif
+TOOL_GCC2_LDFLAGS.sysmod ?= -r
+TOOL_GCC2_LD_SONAME ?= -Wl,-soname=$(firstword $($(1)_SONAME.$(KBUILD_TARGET).$(KBUILD_TYPE)) $($(1)_SONAME.$(KBUILD_TARGET)) $($(1)_SONAME.$(KBUILD_TYPE)) $($(1)_SONAME) $(notdir $(2)))
+ifeq ($(KBUILD_TARGET),os2)
+ TOOL_GCC2_LD_MAP ?= -Zmap=$(1)
+ TOOL_GCC2_LD_SYSMOD_MAP ?= -Zmap=$(1)
+else
+ TOOL_GCC2_LD_MAP ?=
+ TOOL_GCC2_LD_SYSMOD_MAP ?=
+endif
+if1of ($(KBUILD_HOST), solaris)
+ TOOL_GCC2_OBJCOPY ?= gobjcopy$(HOSTSUFF_EXE)
+else
+ TOOL_GCC2_OBJCOPY ?= objcopy$(HOSTSUFF_EXE)
+endif
+
+ifdef SLKRUNS
+ TOOL_GCC2_CC  += -fmessage-length=0
+ TOOL_GCC2_CXX += -fmessage-length=0
+endif
+
+# General Properties used by kBuild
+TOOL_GCC2_COBJSUFF         ?= .o
+TOOL_GCC2_CFLAGS           ?=
+TOOL_GCC2_CFLAGS.debug     ?= -g
+TOOL_GCC2_CFLAGS.profile   ?= -O2 #-g -pg
+TOOL_GCC2_CFLAGS.release   ?= -O2
+TOOL_GCC2_CINCS            ?=
+TOOL_GCC2_CDEFS            ?=
+
+TOOL_GCC2_CXXOBJSUFF       ?= .o
+TOOL_GCC2_CXXOBJSUFF       ?= .o
+TOOL_GCC2_CXXFLAGS         ?=
+TOOL_GCC2_CXXFLAGS.debug   ?= -g
+TOOL_GCC2_CXXFLAGS.profile ?= -O2 #-g -pg
+TOOL_GCC2_CXXFLAGS.release ?= -O2
+TOOL_GCC2_CXXINCS          ?=
+TOOL_GCC2_CXXDEFS          ?=
+
+TOOL_GCC2_ASFLAGS          ?= -x assembler-with-cpp
+TOOL_GCC2_ASFLAGS.debug    ?= -g
+TOOL_GCC2_ASFLAGS.profile  ?= -g
+TOOL_GCC2_ASOBJSUFF        ?= .o
+
+TOOL_GCC2_ARFLAGS          ?= cr
+TOOL_GCC2_ARLIBSUFF        ?= .a
+
+TOOL_GCC2_LDFLAGS          ?=
+TOOL_GCC2_LDFLAGS.debug    ?= -g
+TOOL_GCC2_LDFLAGS.profile  ?= -g
+
+
+## Compile C source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+#
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GCC2_COMPILE_C_DEPEND =
+TOOL_GCC2_COMPILE_C_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GCC2_COMPILE_C_USES_KOBJCACHE = 1
+TOOL_GCC2_COMPILE_C_OUTPUT = $(outbase).i
+define TOOL_GCC2_COMPILE_C_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).i\
+		$(TOOL_GCC2_CC) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GCC2_CC) -c\
+		$(flags) -fpreprocessed -x c\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GCC2_COMPILE_C_OUTPUT =
+define TOOL_GCC2_COMPILE_C_CMDS
+	$(QUIET)$(TOOL_GCC2_CC) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile C++ source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GCC2_COMPILE_CXX_DEPEND =
+TOOL_GCC2_COMPILE_CXX_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GCC2_COMPILE_CXX_USES_KOBJCACHE = 1
+TOOL_GCC2_COMPILE_CXX_OUTPUT = $(outbase).ii
+define TOOL_GCC2_COMPILE_CXX_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).ii\
+		$(TOOL_GCC2_CXX) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GCC2_CXX) -c\
+		$(flags) -fpreprocessed -x c++\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GCC2_COMPILE_CXX_OUTPUT =
+define TOOL_GCC2_COMPILE_CXX_CMDS
+	$(QUIET)$(TOOL_GCC2_CXX) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile Assembly source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)      Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+#
+TOOL_GCC2_COMPILE_AS_OUTPUT =
+TOOL_GCC2_COMPILE_AS_DEPEND =
+TOOL_GCC2_COMPILE_AS_DEPORD =
+define TOOL_GCC2_COMPILE_AS_CMDS
+	$(QUIET)$(TOOL_GCC2_AS) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Link library
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Library name.
+# @param    $(objs)     Object files to put in the library.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2_LINK_LIBRARY_OUTPUT = $(out).ar-script
+TOOL_GCC2_LINK_LIBRARY_OUTPUT_MAYBE = $(outbase).imp.a
+TOOL_GCC2_LINK_LIBRARY_DEPEND = $(othersrc)
+TOOL_GCC2_LINK_LIBRARY_DEPORD =
+define TOOL_GCC2_LINK_LIBRARY_CMDS
+	$(QUIET)$(APPEND) $(out).ar-script 'CREATE $(out)'
+	$(QUIET)$(APPEND) -n $(out).ar-script \
+		$(foreach o,$(objs), 'ADDMOD $(o)') \
+		$(foreach o,$(filter-out %.def %.imp,$(othersrc)), 'ADDLIB $(o)')
+	$(if $(filter %.def %.imp,$(othersrc))\
+		,$(TOOL_GCC2_AR_IMP) -o $(outbase).imp.a $(filter %.def %.imp,$(othersrc))\
+		 $(NL)$(TAB)$(QUIET)$(APPEND) $(out).ar-script 'ADDLIB $(outbase).imp.a')
+	$(QUIET)$(APPEND) $(out).ar-script 'SAVE'
+	$(QUIET)$(APPEND) $(out).ar-script 'END'
+	$(QUIET)$(REDIRECT) -rti $(out).ar-script -- $(TOOL_GCC2_AR) -M
+endef
+
+
+## Link program
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2_LINK_PROGRAM_OUTPUT =
+TOOL_GCC2_LINK_PROGRAM_OUTPUT_MAYBE = $(outbase).map
+TOOL_GCC2_LINK_PROGRAM_OUTPUT_DEBUG = $(outbase).debug
+TOOL_GCC2_LINK_PROGRAM_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_GCC2_LINK_PROGRAM_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GCC2_LINK_PROGRAM_DEPORD =
+define TOOL_GCC2_LINK_PROGRAM_CMDS
+	$(QUIET)$(TOOL_GCC2_LD) $(flags) -o $(out) $(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_GCC2_LD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(TOOL_GCC2_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(CHMOD) a-x $(outbase).debug
+	$(TOOL_GCC2_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
+
+## Link DLL
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2_LINK_DLL_OUTPUT =
+TOOL_GCC2_LINK_DLL_OUTPUT_MAYBE = $(outbase).map
+TOOL_GCC2_LINK_DLL_OUTPUT_DEBUG = $(outbase).debug
+TOOL_GCC2_LINK_DLL_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_GCC2_LINK_DLL_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GCC2_LINK_DLL_DEPORD =
+define TOOL_GCC2_LINK_DLL_CMDS
+	$(QUIET)$(TOOL_GCC2_LD) $(TOOL_GCC2_LDFLAGS.dll) $(flags) -o $(out)\
+		$(if $(filter-out win os2, $(KBUILD_TARGET)),$(call TOOL_GCC2_LD_SONAME,$(target),$(out)))\
+		$(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_GCC2_LD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(TOOL_GCC2_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(CHMOD) a-x $(outbase).debug
+	$(TOOL_GCC2_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
+
+## Link system module (windows aka driver, linux aka kernel module)
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		System module name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2_LINK_SYSMOD_OUTPUT =
+TOOL_GCC2_LINK_SYSMOD_OUTPUT_MAYBE = $(outbase).map
+TOOL_GCC2_LINK_SYSMOD_OUTPUT_DEBUG = $(outbase).debug
+TOOL_GCC2_LINK_SYSMOD_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_GCC2_LINK_SYSMOD_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GCC2_LINK_SYSMOD_DEPORD =
+define TOOL_GCC2_LINK_SYSMOD_CMDS
+	$(QUIET)$(TOOL_GCC2_LD_SYSMOD) $(TOOL_GCC2_LDFLAGS.sysmod) $(flags) -o $(out) $(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_GCC2_LD_SYSMOD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(TOOL_GCC2_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(CHMOD) a-x $(outbase).debug
+	$(TOOL_GCC2_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
diff --git a/kBuild/tools/GCC2PLAIN.kmk b/kBuild/tools/GCC2PLAIN.kmk
new file mode 100644
index 0000000..c63f35c
--- /dev/null
+++ b/kBuild/tools/GCC2PLAIN.kmk
@@ -0,0 +1,320 @@
+# $Id: GCC2PLAIN.kmk 2545 2011-09-13 19:09:05Z bird $
+## @file
+# kBuild Tool Config - Generic GCC v2.95.x or later Using The System GCC, any Unix Linker and Unix Archiver.
+#
+
+#
+# Copyright (c) 2004-2010 knut st. osmundsen <bird-kBuild-spamx@anduin.net>
+#
+# This file is part of kBuild.
+#
+# kBuild is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# kBuild is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with kBuild; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+#
+# As a special exception you are granted permission to include this file, via
+# the kmk include directive, as you wish without this in itself causing the
+# resulting makefile, program or whatever to be covered by the GPL license.
+# This exception does not however invalidate any other reasons why the makefile,
+# program, whatever should not be covered the GPL.
+#
+#
+
+TOOL_GCC2PLAIN := Generic GCC v2.95.x or later Using The System GCC, any Unix Linker and Unix Archiver.
+
+# Tool Specific Properties
+TOOL_GCC2PLAIN_CC  ?= gcc$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_CXX ?= g++$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_AS  ?= gcc$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_AR  ?= ar$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_RANLIB ?= ranlib$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_LD  ?= gcc$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_LD_SYSMOD ?= ld$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_LD_SYSMOD.os2 ?= g++$(HOSTSUFF_EXE)
+TOOL_GCC2PLAIN_LDFLAGS.dll.os2 ?= -Zdll
+TOOL_GCC2PLAIN_LDFLAGS.dll.darwin ?= -dynamiclib
+ifndef TOOL_GCC2PLAIN_LDFLAGS.$(KBUILD_TARGET)
+ TOOL_GCC2PLAIN_LDFLAGS.dll ?= -shared
+else
+ TOOL_GCC2PLAIN_LDFLAGS.dll ?= $(TOOL_GCC2PLAIN_LDFLAGS.$(KBUILD_TARGET))
+endif
+TOOL_GCC2PLAIN_LD_SONAME.darwin ?= $(NO_SUCH_VARIABLE)
+TOOL_GCC2PLAIN_LD_SONAME.os2 ?= $(NO_SUCH_VARIABLE)
+TOOL_GCC2PLAIN_LD_SONAME.solaris ?= -Wl,-h,$(firstword $($(1)_SONAME.$(KBUILD_TARGET).$(KBUILD_TYPE)) $($(1)_SONAME.$(KBUILD_TARGET)) $($(1)_SONAME.$(KBUILD_TYPE)) $($(1)_SONAME) $(notdir $(2)))
+TOOL_GCC2PLAIN_LD_SONAME.win ?= $(NO_SUCH_VARIABLE)
+ifndef TOOL_GCC2PLAIN_LD_SONAME.$(KBUILD_TARGET)
+ TOOL_GCC2PLAIN_LD_SONAME ?= -Wl,-soname=$(firstword $($(1)_SONAME.$(KBUILD_TARGET).$(KBUILD_TYPE)) $($(1)_SONAME.$(KBUILD_TARGET)) $($(1)_SONAME.$(KBUILD_TYPE)) $($(1)_SONAME) $(notdir $(2)))
+else
+ TOOL_GCC2PLAIN_LD_SONAME ?= $(TOOL_GCC2PLAIN_LD_SONAME.$(KBUILD_TARGET))
+endif
+ifdef SLKRUNS
+ TOOL_GCC2PLAIN_CC  += -fmessage-length=0
+ TOOL_GCC2PLAIN_CXX += -fmessage-length=0
+endif
+
+# General Properties used by kBuild
+TOOL_GCC2PLAIN_COBJSUFF         ?= .o
+TOOL_GCC2PLAIN_CFLAGS           ?=
+TOOL_GCC2PLAIN_CFLAGS.debug     ?= -g
+TOOL_GCC2PLAIN_CFLAGS.profile   ?= -O2 #-g -pg
+TOOL_GCC2PLAIN_CFLAGS.release   ?= -O2
+TOOL_GCC2PLAIN_CINCS            ?=
+TOOL_GCC2PLAIN_CDEFS            ?=
+
+TOOL_GCC2PLAIN_CXXOBJSUFF       ?= .o
+TOOL_GCC2PLAIN_CXXOBJSUFF       ?= .o
+TOOL_GCC2PLAIN_CXXFLAGS         ?=
+TOOL_GCC2PLAIN_CXXFLAGS.debug   ?= -g
+TOOL_GCC2PLAIN_CXXFLAGS.profile ?= -O2 #-g -pg
+TOOL_GCC2PLAIN_CXXFLAGS.release ?= -O2
+TOOL_GCC2PLAIN_CXXINCS          ?=
+TOOL_GCC2PLAIN_CXXDEFS          ?=
+
+TOOL_GCC2PLAIN_ASFLAGS          ?= -x assembler-with-cpp
+TOOL_GCC2PLAIN_ASFLAGS.debug    ?= -g
+TOOL_GCC2PLAIN_ASFLAGS.profile  ?= -g
+TOOL_GCC2PLAIN_ASOBJSUFF        ?= .o
+
+TOOL_GCC2PLAIN_ARFLAGS          ?= cr
+TOOL_GCC2PLAIN_ARLIBSUFF        ?= .a
+
+TOOL_GCC2PLAIN_LDFLAGS          ?=
+
+
+## Compile C source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+#
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GCC2PLAIN_COMPILE_C_DEPEND =
+TOOL_GCC2PLAIN_COMPILE_C_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GCC2PLAIN_COMPILE_C_USES_KOBJCACHE = 1
+TOOL_GCC2PLAIN_COMPILE_C_OUTPUT = $(outbase).i
+define TOOL_GCC2PLAIN_COMPILE_C_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).i\
+		$(TOOL_GCC2PLAIN_CC) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GCC2PLAIN_CC) -c\
+		$(flags) -fpreprocessed -x c\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GCC2PLAIN_COMPILE_C_OUTPUT =
+define TOOL_GCC2PLAIN_COMPILE_C_CMDS
+	$(QUIET)$(TOOL_GCC2PLAIN_CC) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile C++ source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GCC2PLAIN_COMPILE_CXX_DEPEND =
+TOOL_GCC2PLAIN_COMPILE_CXX_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GCC2PLAIN_COMPILE_CXX_USES_KOBJCACHE = 1
+TOOL_GCC2PLAIN_COMPILE_CXX_OUTPUT = $(outbase).ii
+define TOOL_GCC2PLAIN_COMPILE_CXX_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).ii\
+		$(TOOL_GCC2PLAIN_CXX) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GCC2PLAIN_CXX) -c\
+		$(flags) -fpreprocessed -x c++\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GCC2PLAIN_COMPILE_CXX_OUTPUT =
+define TOOL_GCC2PLAIN_COMPILE_CXX_CMDS
+	$(QUIET)$(TOOL_GCC2PLAIN_CXX) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile Assembly source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)      Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+#
+TOOL_GCC2PLAIN_COMPILE_AS_OUTPUT =
+TOOL_GCC2PLAIN_COMPILE_AS_DEPEND =
+TOOL_GCC2PLAIN_COMPILE_AS_DEPORD =
+define TOOL_GCC2PLAIN_COMPILE_AS_CMDS
+	$(QUIET)$(TOOL_GCC2PLAIN_AS) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Link library
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Library name.
+# @param    $(objs)     Object files to put in the library.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2PLAIN_LINK_LIBRARY_OUTPUT =
+TOOL_GCC2PLAIN_LINK_LIBRARY_DEPEND = $(othersrc)
+TOOL_GCC2PLAIN_LINK_LIBRARY_DEPORD =
+define TOOL_GCC2PLAIN_LINK_LIBRARY_CMDS
+	$(call xargs,$(QUIET)$(TOOL_GCC2PLAIN_AR) $(flags) $(out),$(objs))
+	$(foreach lib,$(othersrc)\
+		,$(NL)$(TAB)$(call MSG_AR_MERGE,$(target),$(out),$(lib)) \
+		$(NL)$(TAB)$(QUIET)$(RM_EXT) -f $(dir $(outbase))ar.tmp.dir/* \
+		$(NL)$(TAB)$(QUIET)$(MKDIR) -p $(dir $(outbase))/ar.tmp.dir/ \
+		$(NL)$(TAB)$(QUIET)(cd $(dir $(outbase))ar.tmp.dir/ \
+			&& $(TOOL_GCC2PLAIN_AR) x $(abspath $(lib)) \
+			&& $(TOOL_GCC2PLAIN_AR) $(flags) $(out) *) \
+		$(NL)$(TAB)$(QUIET)$(RM_EXT) -f $(dir $(outbase))/ar.tmp.dir/* \
+		$(NL)$(TAB)$(QUIET)$(RMDIR) $(dir $(outbase))ar.tmp.dir/)
+	$(QUIET)$(TOOL_GCC2PLAIN_RANLIB) $(out)
+endef
+
+
+## Link program
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2PLAIN_LINK_PROGRAM_OUTPUT =
+TOOL_GCC2PLAIN_LINK_PROGRAM_OUTPUT_MAYBE = $(outbase).map
+TOOL_GCC2PLAIN_LINK_PROGRAM_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GCC2PLAIN_LINK_PROGRAM_DEPORD =
+define TOOL_GCC2PLAIN_LINK_PROGRAM_CMDS
+	$(QUIET)$(TOOL_GCC2PLAIN_LD) $(flags) -o $(out) $(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))
+endef
+
+
+## Link DLL
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2PLAIN_LINK_DLL_OUTPUT =
+TOOL_GCC2PLAIN_LINK_DLL_OUTPUT_MAYBE = $(outbase).map
+TOOL_GCC2PLAIN_LINK_DLL_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GCC2PLAIN_LINK_DLL_DEPORD =
+define TOOL_GCC2PLAIN_LINK_DLL_CMDS
+	$(QUIET)$(TOOL_GCC2PLAIN_LD) $(TOOL_GCC2PLAIN_LDFLAGS.dll) $(flags) -o $(out)\
+		$(if $(filter-out win32 os2, $(KBUILD_TARGET)),$(call TOOL_GCC2PLAIN_LD_SONAME,$(target),$(out)))\
+		$(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))
+endef
+
+
+## Link system module (windows aka driver, linux aka kernel module)
+# This tool target might not work everywhere, but is provided for the
+# platforms where it works (Solaris, etc).
+#
+# @param    $(target)   Normalized main target name.
+# @param    $(out)      System module name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GCC2PLAIN_LINK_SYSMOD_OUTPUT =
+TOOL_GCC2PLAIN_LINK_SYSMOD_OUTPUT_MAYBE = $(outbase).map
+TOOL_GCC2PLAIN_LINK_SYSMOD_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GCC2PLAIN_LINK_SYSMOD_DEPORD =
+define TOOL_GCC2PLAIN_LINK_SYSMOD_CMDS
+	$(QUIET)$(if $(TOOL_GCC2PLAIN_LD_SYSMOD.$(bld_trg)),$(TOOL_GCC2PLAIN_LD_SYSMOD.$(bld_trg)),$(TOOL_GCC2PLAIN_LD_SYSMOD))\
+		$(TOOL_GCC2PLAIN_LDFLAGS_SYSMOD.$(bld_trg))  $(flags) -o $(out)\
+		$(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))
+endef
+
diff --git a/kBuild/tools/GXX2.kmk b/kBuild/tools/GXX2.kmk
new file mode 100644
index 0000000..012cb9c
--- /dev/null
+++ b/kBuild/tools/GXX2.kmk
@@ -0,0 +1,352 @@
+# $Id: GXX2.kmk 2541 2011-08-03 09:51:30Z bird $
+## @file
+# kBuild Tool Config - Generic GCC v2.95.x using the system GCC and Binutils, for building C++ code.
+#
+
+#
+# Copyright (c) 2004-2010 knut st. osmundsen <bird-kBuild-spamx@anduin.net>
+#
+# This file is part of kBuild.
+#
+# kBuild is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# kBuild is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with kBuild; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+#
+# As a special exception you are granted permission to include this file, via
+# the kmk include directive, as you wish without this in itself causing the
+# resulting makefile, program or whatever to be covered by the GPL license.
+# This exception does not however invalidate any other reasons why the makefile,
+# program, whatever should not be covered the GPL.
+#
+#
+
+TOOL_GXX2 := Generic GCC v2.95.x or later using the system GCC and Binutils, for building C++ code.
+
+# Tool Specific Properties
+TOOL_GXX2_CC  ?= gcc$(HOSTSUFF_EXE)
+TOOL_GXX2_CXX ?= g++$(HOSTSUFF_EXE)
+TOOL_GXX2_AS  ?= gcc$(HOSTSUFF_EXE)
+ifeq ($(KBUILD_TARGET),solaris)
+ TOOL_GXX2_AR ?= gar$(HOSTSUFF_EXE)
+else
+ TOOL_GXX2_AR ?= ar$(HOSTSUFF_EXE)
+endif
+ifeq ($(KBUILD_TARGET),os2)
+ TOOL_GXX2_AR_IMP ?= emximp$(HOSTSTUFF_EXE)
+else
+ TOOL_GXX2_AR_IMP ?= $(ECHO) not supported!
+endif
+TOOL_GXX2_LD ?= g++$(HOSTSUFF_EXE)
+TOOL_GXX2_LD_SYSMOD ?= ld$(HOSTSUFF_EXE)
+ifndef TOOL_GXX2_LDFLAGS.$(KBUILD_TARGET)
+ TOOL_GXX2_LDFLAGS.dll ?= -shared
+else
+ TOOL_GXX2_LDFLAGS.dll ?= $(TOOL_GXX2_LDFLAGS.$(KBUILD_TARGET))
+endif
+TOOL_GXX2_LDFLAGS.sysmod ?= -r
+TOOL_GXX2_LD_SONAME ?= -Wl,-soname=$(firstword $($(1)_SONAME.$(KBUILD_TARGET).$(KBUILD_TYPE)) $($(1)_SONAME.$(KBUILD_TARGET)) $($(1)_SONAME.$(KBUILD_TYPE)) $($(1)_SONAME) $(notdir $(2)))
+ifeq ($(KBUILD_TARGET),os2)
+ TOOL_GXX2_LD_MAP ?= -Zmap=$(1)
+ TOOL_GXX2_LD_SYSMOD_MAP ?= -Zmap=$(1)
+else
+ TOOL_GXX2_LD_MAP ?=
+ TOOL_GXX2_LD_SYSMOD_MAP ?=
+endif
+if1of ($(KBUILD_HOST), solaris)
+ TOOL_GXX2_OBJCOPY ?= gobjcopy$(HOSTSUFF_EXE)
+else
+ TOOL_GXX2_OBJCOPY ?= objcopy$(HOSTSUFF_EXE)
+endif
+
+ifdef SLKRUNS
+ TOOL_GXX2_CC  += -fmessage-length=0
+ TOOL_GXX2_CXX += -fmessage-length=0
+endif
+
+# General Properties used by kBuild
+TOOL_GXX2_COBJSUFF         ?= .o
+TOOL_GXX2_CFLAGS           ?=
+TOOL_GXX2_CFLAGS.debug     ?= -g
+TOOL_GXX2_CFLAGS.profile   ?= -O2 #-g -pg
+TOOL_GXX2_CFLAGS.release   ?= -O2
+TOOL_GXX2_CINCS            ?=
+TOOL_GXX2_CDEFS            ?=
+
+TOOL_GXX2_CXXOBJSUFF       ?= .o
+TOOL_GXX2_CXXOBJSUFF       ?= .o
+TOOL_GXX2_CXXFLAGS         ?=
+TOOL_GXX2_CXXFLAGS.debug   ?= -g
+TOOL_GXX2_CXXFLAGS.profile ?= -O2 #-g -pg
+TOOL_GXX2_CXXFLAGS.release ?= -O2
+TOOL_GXX2_CXXINCS          ?=
+TOOL_GXX2_CXXDEFS          ?=
+
+TOOL_GXX2_ASFLAGS          ?= -x assembler-with-cpp
+TOOL_GXX2_ASFLAGS.debug    ?= -g
+TOOL_GXX2_ASFLAGS.profile  ?= -g
+TOOL_GXX2_ASOBJSUFF        ?= .o
+
+TOOL_GXX2_ARFLAGS          ?= cr
+TOOL_GXX2_ARLIBSUFF        ?= .a
+
+TOOL_GXX2_LDFLAGS          ?=
+TOOL_GXX2_LDFLAGS.debug    ?= -g
+TOOL_GXX2_LDFLAGS.profile  ?= -g
+
+
+## Compile C source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+#
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GXX2_COMPILE_C_DEPEND =
+TOOL_GXX2_COMPILE_C_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GXX2_COMPILE_C_USES_KOBJCACHE = 1
+TOOL_GXX2_COMPILE_C_OUTPUT = $(outbase).i
+define TOOL_GXX2_COMPILE_C_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).i\
+		$(TOOL_GXX2_CC) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GXX2_CC) -c\
+		$(flags) -fpreprocessed -x c\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GXX2_COMPILE_C_OUTPUT =
+define TOOL_GXX2_COMPILE_C_CMDS
+	$(QUIET)$(TOOL_GXX2_CC) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile C++ source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GXX2_COMPILE_CXX_DEPEND =
+TOOL_GXX2_COMPILE_CXX_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GXX2_COMPILE_CXX_USES_KOBJCACHE = 1
+TOOL_GXX2_COMPILE_CXX_OUTPUT = $(outbase).ii
+define TOOL_GXX2_COMPILE_CXX_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).ii\
+		$(TOOL_GXX2_CXX) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GXX2_CXX) -c\
+		$(flags) -fpreprocessed -x c++\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GXX2_COMPILE_CXX_OUTPUT =
+define TOOL_GXX2_COMPILE_CXX_CMDS
+	$(QUIET)$(TOOL_GXX2_CXX) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile Assembly source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)      Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+#
+TOOL_GXX2_COMPILE_AS_OUTPUT =
+TOOL_GXX2_COMPILE_AS_DEPEND =
+TOOL_GXX2_COMPILE_AS_DEPORD =
+define TOOL_GXX2_COMPILE_AS_CMDS
+	$(QUIET)$(TOOL_GXX2_AS) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Link library
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Library name.
+# @param    $(objs)     Object files to put in the library.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2_LINK_LIBRARY_OUTPUT = $(out).ar-script
+TOOL_GXX2_LINK_LIBRARY_OUTPUT_MAYBE = $(outbase).imp.a
+TOOL_GXX2_LINK_LIBRARY_DEPEND = $(othersrc)
+TOOL_GXX2_LINK_LIBRARY_DEPORD =
+define TOOL_GXX2_LINK_LIBRARY_CMDS
+	$(QUIET)$(APPEND) $(out).ar-script 'CREATE $(out)'
+	$(QUIET)$(APPEND) -n $(out).ar-script \
+		$(foreach o,$(objs), 'ADDMOD $(o)') \
+		$(foreach o,$(filter-out %.def %.imp,$(othersrc)), 'ADDLIB $(o)')
+	$(if $(filter %.def %.imp,$(othersrc))\
+		,$(TOOL_GXX2_AR_IMP) -o $(outbase).imp.a $(filter %.def %.imp,$(othersrc))\
+		 $(NL)$(TAB)$(QUIET)$(APPEND) $(out).ar-script 'ADDLIB $(outbase).imp.a')
+	$(QUIET)$(APPEND) $(out).ar-script 'SAVE'
+	$(QUIET)$(APPEND) $(out).ar-script 'END'
+	$(QUIET)$(REDIRECT) -rti $(out).ar-script -- $(TOOL_GXX2_AR) -M
+endef
+
+
+## Link program
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2_LINK_PROGRAM_OUTPUT =
+TOOL_GXX2_LINK_PROGRAM_OUTPUT_MAYBE = $(outbase).map
+TOOL_GXX2_LINK_PROGRAM_OUTPUT_DEBUG = $(outbase).debug
+TOOL_GXX2_LINK_PROGRAM_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_GXX2_LINK_PROGRAM_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GXX2_LINK_PROGRAM_DEPORD =
+define TOOL_GXX2_LINK_PROGRAM_CMDS
+	$(QUIET)$(TOOL_GXX2_LD) $(flags) -o $(out) $(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_GXX2_LD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(TOOL_GXX2_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(CHMOD) a-x $(outbase).debug
+	$(TOOL_GXX2_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
+
+## Link DLL
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2_LINK_DLL_OUTPUT =
+TOOL_GXX2_LINK_DLL_OUTPUT_MAYBE = $(outbase).map
+TOOL_GXX2_LINK_DLL_OUTPUT_DEBUG = $(outbase).debug
+TOOL_GXX2_LINK_DLL_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_GXX2_LINK_DLL_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GXX2_LINK_DLL_DEPORD =
+define TOOL_GXX2_LINK_DLL_CMDS
+	$(QUIET)$(TOOL_GXX2_LD) $(TOOL_GXX2_LDFLAGS.dll) $(flags) -o $(out)\
+		$(if $(filter-out win os2, $(KBUILD_TARGET)),$(call TOOL_GXX2_LD_SONAME,$(target),$(out)))\
+		$(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_GXX2_LD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(TOOL_GXX2_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(CHMOD) a-x $(outbase).debug
+	$(TOOL_GXX2_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
+
+## Link system module (windows aka driver, linux aka kernel module)
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		System module name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2_LINK_SYSMOD_OUTPUT =
+TOOL_GXX2_LINK_SYSMOD_OUTPUT_MAYBE = $(outbase).map
+TOOL_GXX2_LINK_SYSMOD_OUTPUT_DEBUG = $(outbase).debug
+TOOL_GXX2_LINK_SYSMOD_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_GXX2_LINK_SYSMOD_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GXX2_LINK_SYSMOD_DEPORD =
+define TOOL_GXX2_LINK_SYSMOD_CMDS
+	$(QUIET)$(TOOL_GXX2_LD_SYSMOD) $(TOOL_GXX2_LDFLAGS.sysmod) $(flags) -o $(out) $(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_GXX2_LD_SYSMOD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(TOOL_GXX2_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(CHMOD) a-x $(outbase).debug
+	$(TOOL_GXX2_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
diff --git a/kBuild/tools/GXX2PLAIN.kmk b/kBuild/tools/GXX2PLAIN.kmk
new file mode 100644
index 0000000..2ab0b73
--- /dev/null
+++ b/kBuild/tools/GXX2PLAIN.kmk
@@ -0,0 +1,320 @@
+# $Id: GXX2PLAIN.kmk 2545 2011-09-13 19:09:05Z bird $
+## @file
+# kBuild Tool Config - Generic GCC v2.95.x or later using the system GCC, any Unix linker and Unix archiver to build C++ code.
+#
+
+#
+# Copyright (c) 2004-2010 knut st. osmundsen <bird-kBuild-spamx@anduin.net>
+#
+# This file is part of kBuild.
+#
+# kBuild is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# kBuild is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with kBuild; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+#
+# As a special exception you are granted permission to include this file, via
+# the kmk include directive, as you wish without this in itself causing the
+# resulting makefile, program or whatever to be covered by the GPL license.
+# This exception does not however invalidate any other reasons why the makefile,
+# program, whatever should not be covered the GPL.
+#
+#
+
+TOOL_GXX2PLAIN := Generic GCC v2.95.x or later using the system GCC, any Unix linker and Unix archiver to build C++ code.
+
+# Tool Specific Properties
+TOOL_GXX2PLAIN_CC  ?= gcc$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_CXX ?= g++$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_AS  ?= gcc$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_AR  ?= ar$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_RANLIB ?= ranlib$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_LD  ?= g++$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_LD_SYSMOD ?= ld$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_LD_SYSMOD.os2 ?= g++$(HOSTSUFF_EXE)
+TOOL_GXX2PLAIN_LDFLAGS.dll.os2 ?= -Zdll
+TOOL_GXX2PLAIN_LDFLAGS.dll.darwin ?= -dynamiclib
+ifndef TOOL_GXX2PLAIN_LDFLAGS.$(KBUILD_TARGET)
+ TOOL_GXX2PLAIN_LDFLAGS.dll ?= -shared
+else
+ TOOL_GXX2PLAIN_LDFLAGS.dll ?= $(TOOL_GXX2PLAIN_LDFLAGS.$(KBUILD_TARGET))
+endif
+TOOL_GXX2PLAIN_LD_SONAME.darwin ?= $(NO_SUCH_VARIABLE)
+TOOL_GXX2PLAIN_LD_SONAME.os2 ?= $(NO_SUCH_VARIABLE)
+TOOL_GXX2PLAIN_LD_SONAME.solaris ?= -Wl,-h,$(firstword $($(1)_SONAME.$(KBUILD_TARGET).$(KBUILD_TYPE)) $($(1)_SONAME.$(KBUILD_TARGET)) $($(1)_SONAME.$(KBUILD_TYPE)) $($(1)_SONAME) $(notdir $(2)))
+TOOL_GXX2PLAIN_LD_SONAME.win ?= $(NO_SUCH_VARIABLE)
+ifndef TOOL_GXX2PLAIN_LD_SONAME.$(KBUILD_TARGET)
+ TOOL_GXX2PLAIN_LD_SONAME ?= -Wl,-soname=$(firstword $($(1)_SONAME.$(KBUILD_TARGET).$(KBUILD_TYPE)) $($(1)_SONAME.$(KBUILD_TARGET)) $($(1)_SONAME.$(KBUILD_TYPE)) $($(1)_SONAME) $(notdir $(2)))
+else
+ TOOL_GXX2PLAIN_LD_SONAME ?= $(TOOL_GXX2PLAIN_LD_SONAME.$(KBUILD_TARGET))
+endif
+ifdef SLKRUNS
+ TOOL_GXX2PLAIN_CC  += -fmessage-length=0
+ TOOL_GXX2PLAIN_CXX += -fmessage-length=0
+endif
+
+# General Properties used by kBuild
+TOOL_GXX2PLAIN_COBJSUFF         ?= .o
+TOOL_GXX2PLAIN_CFLAGS           ?=
+TOOL_GXX2PLAIN_CFLAGS.debug     ?= -g
+TOOL_GXX2PLAIN_CFLAGS.profile   ?= -O2 #-g -pg
+TOOL_GXX2PLAIN_CFLAGS.release   ?= -O2
+TOOL_GXX2PLAIN_CINCS            ?=
+TOOL_GXX2PLAIN_CDEFS            ?=
+
+TOOL_GXX2PLAIN_CXXOBJSUFF       ?= .o
+TOOL_GXX2PLAIN_CXXOBJSUFF       ?= .o
+TOOL_GXX2PLAIN_CXXFLAGS         ?=
+TOOL_GXX2PLAIN_CXXFLAGS.debug   ?= -g
+TOOL_GXX2PLAIN_CXXFLAGS.profile ?= -O2 #-g -pg
+TOOL_GXX2PLAIN_CXXFLAGS.release ?= -O2
+TOOL_GXX2PLAIN_CXXINCS          ?=
+TOOL_GXX2PLAIN_CXXDEFS          ?=
+
+TOOL_GXX2PLAIN_ASFLAGS          ?= -x assembler-with-cpp
+TOOL_GXX2PLAIN_ASFLAGS.debug    ?= -g
+TOOL_GXX2PLAIN_ASFLAGS.profile  ?= -g
+TOOL_GXX2PLAIN_ASOBJSUFF        ?= .o
+
+TOOL_GXX2PLAIN_ARFLAGS          ?= cr
+TOOL_GXX2PLAIN_ARLIBSUFF        ?= .a
+
+TOOL_GXX2PLAIN_LDFLAGS          ?=
+
+
+## Compile C source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+#
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GXX2PLAIN_COMPILE_C_DEPEND =
+TOOL_GXX2PLAIN_COMPILE_C_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GXX2PLAIN_COMPILE_C_USES_KOBJCACHE = 1
+TOOL_GXX2PLAIN_COMPILE_C_OUTPUT = $(outbase).i
+define TOOL_GXX2PLAIN_COMPILE_C_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).i\
+		$(TOOL_GXX2PLAIN_CC) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GXX2PLAIN_CC) -c\
+		$(flags) -fpreprocessed -x c\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GXX2PLAIN_COMPILE_C_OUTPUT =
+define TOOL_GXX2PLAIN_COMPILE_C_CMDS
+	$(QUIET)$(TOOL_GXX2PLAIN_CC) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile C++ source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_GXX2PLAIN_COMPILE_CXX_DEPEND =
+TOOL_GXX2PLAIN_COMPILE_CXX_DEPORD =
+ifdef KBUILD_USE_KOBJCACHE
+TOOL_GXX2PLAIN_COMPILE_CXX_USES_KOBJCACHE = 1
+TOOL_GXX2PLAIN_COMPILE_CXX_OUTPUT = $(outbase).ii
+define TOOL_GXX2PLAIN_COMPILE_CXX_CMDS
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).ii\
+		$(TOOL_GXX2PLAIN_CXX) -E -o -\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_GXX2PLAIN_CXX) -c\
+		$(flags) -fpreprocessed -x c++\
+		-o $(obj)\
+		-
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+else # !KBUILD_USE_KOBJCACHE
+TOOL_GXX2PLAIN_COMPILE_CXX_OUTPUT =
+define TOOL_GXX2PLAIN_COMPILE_CXX_CMDS
+	$(QUIET)$(TOOL_GXX2PLAIN_CXX) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+endif # !KBUILD_USE_KOBJCACHE
+
+
+## Compile Assembly source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)      Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+#
+TOOL_GXX2PLAIN_COMPILE_AS_OUTPUT =
+TOOL_GXX2PLAIN_COMPILE_AS_DEPEND =
+TOOL_GXX2PLAIN_COMPILE_AS_DEPORD =
+define TOOL_GXX2PLAIN_COMPILE_AS_CMDS
+	$(QUIET)$(TOOL_GXX2PLAIN_AS) -c\
+		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
+		-Wp,-MD,$(dep)\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Link library
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Library name.
+# @param    $(objs)     Object files to put in the library.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2PLAIN_LINK_LIBRARY_OUTPUT =
+TOOL_GXX2PLAIN_LINK_LIBRARY_DEPEND = $(othersrc)
+TOOL_GXX2PLAIN_LINK_LIBRARY_DEPORD =
+define TOOL_GXX2PLAIN_LINK_LIBRARY_CMDS
+	$(call xargs,$(QUIET)$(TOOL_GXX2PLAIN_AR) $(flags) $(out),$(objs))
+	$(foreach lib,$(othersrc)\
+		,$(NL)$(TAB)$(call MSG_AR_MERGE,$(target),$(out),$(lib)) \
+		$(NL)$(TAB)$(QUIET)$(RM_EXT) -f $(dir $(outbase))ar.tmp.dir/* \
+		$(NL)$(TAB)$(QUIET)$(MKDIR) -p $(dir $(outbase))/ar.tmp.dir/ \
+		$(NL)$(TAB)$(QUIET)(cd $(dir $(outbase))ar.tmp.dir/ \
+			&& $(TOOL_GXX2PLAIN_AR) x $(abspath $(lib)) \
+			&& $(TOOL_GXX2PLAIN_AR) $(flags) $(out) *) \
+		$(NL)$(TAB)$(QUIET)$(RM_EXT) -f $(dir $(outbase))/ar.tmp.dir/* \
+		$(NL)$(TAB)$(QUIET)$(RMDIR) $(dir $(outbase))ar.tmp.dir/)
+	$(QUIET)$(TOOL_GXX2PLAIN_RANLIB) $(out)
+endef
+
+
+## Link program
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2PLAIN_LINK_PROGRAM_OUTPUT =
+TOOL_GXX2PLAIN_LINK_PROGRAM_OUTPUT_MAYBE = $(outbase).map
+TOOL_GXX2PLAIN_LINK_PROGRAM_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GXX2PLAIN_LINK_PROGRAM_DEPORD =
+define TOOL_GXX2PLAIN_LINK_PROGRAM_CMDS
+	$(QUIET)$(TOOL_GXX2PLAIN_LD) $(flags) -o $(out) $(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))
+endef
+
+
+## Link DLL
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2PLAIN_LINK_DLL_OUTPUT =
+TOOL_GXX2PLAIN_LINK_DLL_OUTPUT_MAYBE = $(outbase).map
+TOOL_GXX2PLAIN_LINK_DLL_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GXX2PLAIN_LINK_DLL_DEPORD =
+define TOOL_GXX2PLAIN_LINK_DLL_CMDS
+	$(QUIET)$(TOOL_GXX2PLAIN_LD) $(TOOL_GXX2PLAIN_LDFLAGS.dll) $(flags) -o $(out)\
+		$(if $(filter-out win32 os2, $(KBUILD_TARGET)),$(call TOOL_GXX2PLAIN_LD_SONAME,$(target),$(out)))\
+		$(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))
+endef
+
+
+## Link system module (windows aka driver, linux aka kernel module)
+# This tool target might not work everywhere, but is provided for the
+# platforms where it works (Solaris, etc).
+#
+# @param    $(target)   Normalized main target name.
+# @param    $(out)      System module name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_GXX2PLAIN_LINK_SYSMOD_OUTPUT =
+TOOL_GXX2PLAIN_LINK_SYSMOD_OUTPUT_MAYBE = $(outbase).map
+TOOL_GXX2PLAIN_LINK_SYSMOD_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_GXX2PLAIN_LINK_SYSMOD_DEPORD =
+define TOOL_GXX2PLAIN_LINK_SYSMOD_CMDS
+	$(QUIET)$(if $(TOOL_GXX2PLAIN_LD_SYSMOD.$(bld_trg)),$(TOOL_GXX2PLAIN_LD_SYSMOD.$(bld_trg)),$(TOOL_GXX2PLAIN_LD_SYSMOD))\
+		$(TOOL_GXX2PLAIN_LDFLAGS_SYSMOD.$(bld_trg)) $(flags) -o $(out) \
+		$(objs)\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))
+endef
+
diff --git a/src/VBox/Additions/common/VBoxGuest/VBoxDev-haiku.c b/src/VBox/Additions/common/VBoxGuest/VBoxDev-haiku.c
index 8216332..c17cbcd 100644
--- a/src/VBox/Additions/common/VBoxGuest/VBoxDev-haiku.c
+++ b/src/VBox/Additions/common/VBoxGuest/VBoxDev-haiku.c
@@ -191,11 +191,14 @@ static status_t VBoxGuestHaikuFree(void *cookie)
  */
 static status_t VBoxGuestHaikuIOCtl(void *cookie, uint32 op, void *data, size_t len)
 {
+    int rc = B_OK;
+    void *pvBuf = NULL;
+    size_t cbDataReturned;
+
     PVBOXGUESTSESSION pSession = (PVBOXGUESTSESSION)cookie;
+    dprintf(DRIVER_NAME ":VBoxGuestHaikuIOCtl cookie=%p op=0x%08x data=%p len=%lu)\n", cookie, op, data, len);
     Log((DRIVER_NAME ":VBoxGuestHaikuIOCtl cookie=%p op=0x%08x data=%p len=%lu)\n", cookie, op, data, len));
 
-    int rc = B_OK;
-
     /*
      * Validate the input.
      */
@@ -223,7 +226,6 @@ static status_t VBoxGuestHaikuIOCtl(void *cookie, uint32 op, void *data, size_t
     /*
      * Read the request.
      */
-    void *pvBuf = NULL;
     if (RT_LIKELY(len > 0))
     {
         pvBuf = RTMemTmpAlloc(len);
@@ -238,6 +240,7 @@ static status_t VBoxGuestHaikuIOCtl(void *cookie, uint32 op, void *data, size_t
         if (RT_UNLIKELY(rc < 0))
         {
             RTMemTmpFree(pvBuf);
+            dprintf(DRIVER_NAME ":VBoxGuestHaikuIOCtl: user_memcpy failed; pvBuf=%p data=%p op=%d. rc=%d\n", pvBuf, data, op, rc);
             LogRel((DRIVER_NAME ":VBoxGuestHaikuIOCtl: user_memcpy failed; pvBuf=%p data=%p op=%d. rc=%d\n", pvBuf, data, op, rc));
             return EFAULT;
         }
@@ -253,7 +256,6 @@ static status_t VBoxGuestHaikuIOCtl(void *cookie, uint32 op, void *data, size_t
     /*
      * Process the IOCtl.
      */
-    size_t cbDataReturned;
     rc = VBoxGuestCommonIOCtl(op, &g_DevExt, pSession, pvBuf, len, &cbDataReturned);
     if (RT_SUCCESS(rc))
     {
@@ -268,6 +270,7 @@ static status_t VBoxGuestHaikuIOCtl(void *cookie, uint32 op, void *data, size_t
             rc = user_memcpy(data, pvBuf, cbDataReturned);
             if (RT_UNLIKELY(rc < 0))
             {
+                dprintf(DRIVER_NAME ":VBoxGuestHaikuIOCtl: user_memcpy failed; pvBuf=%p pArg=%p Cmd=%lu. rc=%d\n", pvBuf, data, op, rc);
                 Log((DRIVER_NAME ":VBoxGuestHaikuIOCtl: user_memcpy failed; pvBuf=%p pArg=%p Cmd=%lu. rc=%d\n", pvBuf, data, op, rc));
                 rc = EFAULT;
             }
@@ -275,6 +278,7 @@ static status_t VBoxGuestHaikuIOCtl(void *cookie, uint32 op, void *data, size_t
     }
     else
     {
+        dprintf(DRIVER_NAME ":VBoxGuestHaikuIOCtl: VBoxGuestCommonIOCtl failed. rc=%d\n", rc);
         Log((DRIVER_NAME ":VBoxGuestHaikuIOCtl: VBoxGuestCommonIOCtl failed. rc=%d\n", rc));
         rc = EFAULT;
     }
@@ -297,6 +301,7 @@ static status_t VBoxGuestHaikuSelect(void *cookie, uint8 event, uint32 ref, sele
 {
     PVBOXGUESTSESSION pSession = (PVBOXGUESTSESSION)cookie;
     status_t err = B_OK;
+    uint32_t u32CurSeq;
 
     switch (event)
     {
@@ -308,7 +313,7 @@ static status_t VBoxGuestHaikuSelect(void *cookie, uint8 event, uint32 ref, sele
 
     RTSpinlockAcquire(g_DevExt.SessionSpinlock);
 
-    uint32_t u32CurSeq = ASMAtomicUoReadU32(&g_DevExt.u32MousePosChangedSeq);
+    u32CurSeq = ASMAtomicUoReadU32(&g_DevExt.u32MousePosChangedSeq);
     if (pSession->u32MousePosChangedSeq != u32CurSeq)
     {
         pSession->u32MousePosChangedSeq = u32CurSeq;
@@ -388,11 +393,12 @@ static status_t VBoxGuestHaikuWrite(void *cookie, off_t position, const void *da
 static status_t VBoxGuestHaikuRead(void *cookie, off_t position, void *data, size_t *numBytes)
 {
     PVBOXGUESTSESSION pSession = (PVBOXGUESTSESSION)cookie;
+    uint32_t u32CurSeq;
 
     if (*numBytes == 0)
         return B_OK;
 
-    uint32_t u32CurSeq = ASMAtomicUoReadU32(&g_DevExt.u32MousePosChangedSeq);
+    u32CurSeq = ASMAtomicUoReadU32(&g_DevExt.u32MousePosChangedSeq);
     if (pSession->u32MousePosChangedSeq != u32CurSeq)
     {
         pSession->u32MousePosChangedSeq = u32CurSeq;
diff --git a/src/VBox/Additions/common/VBoxGuest/VBoxGuest-haiku.c b/src/VBox/Additions/common/VBoxGuest/VBoxGuest-haiku.c
index 5aa3170..6a13751 100644
--- a/src/VBox/Additions/common/VBoxGuest/VBoxGuest-haiku.c
+++ b/src/VBox/Additions/common/VBoxGuest/VBoxGuest-haiku.c
@@ -69,6 +69,7 @@
 #include <iprt/heap.h>
 
 #define MODULE_NAME VBOXGUEST_MODULE_NAME
+#define DO_LOG 1
 
 /*
  * IRQ related functions.
@@ -302,9 +303,10 @@ static status_t VBoxGuestHaikuDetach(void)
  */
 static int32 VBoxGuestHaikuISR(void *pvState)
 {
+    bool fOurIRQ;
     LogFlow((MODULE_NAME ":VBoxGuestHaikuISR pvState=%p\n", pvState));
 
-    bool fOurIRQ = VBoxGuestCommonISR(&g_DevExt);
+    fOurIRQ = VBoxGuestCommonISR(&g_DevExt);
     if (fOurIRQ)
         return B_HANDLED_INTERRUPT;
     return B_UNHANDLED_INTERRUPT;
@@ -313,9 +315,10 @@ static int32 VBoxGuestHaikuISR(void *pvState)
 
 void VBoxGuestNativeISRMousePollEvent(PVBOXGUESTDEVEXT pDevExt)
 {
+    status_t err = B_OK;
+
     LogFlow((MODULE_NAME "::NativeISRMousePollEvent:\n"));
 
-    status_t err = B_OK;
     //dprintf(MODULE_NAME ": isr mouse\n");
 
     /*
diff --git a/src/VBox/Additions/haiku/SharedFolders/lock.h b/src/VBox/Additions/haiku/SharedFolders/lock.h
index c4cb31b..e652ceb 100644
--- a/src/VBox/Additions/haiku/SharedFolders/lock.h
+++ b/src/VBox/Additions/haiku/SharedFolders/lock.h
@@ -64,7 +64,7 @@ typedef struct rw_lock {
         const char*                             name;
         struct rw_lock_waiter*  waiters;
         thread_id                               holder;
-        vint32                                  count;
+        int32                                  count;
         int32                                   owner_count;
         int16                                   active_readers;
                                                                 // Only > 0 while a writer is waiting: number
diff --git a/src/VBox/Additions/haiku/SharedFolders/vboxsf.c b/src/VBox/Additions/haiku/SharedFolders/vboxsf.c
index edffcba..4327e4f 100644
--- a/src/VBox/Additions/haiku/SharedFolders/vboxsf.c
+++ b/src/VBox/Additions/haiku/SharedFolders/vboxsf.c
@@ -55,6 +55,7 @@ static fs_vnode_ops vboxsf_vnode_ops;
 
 status_t init_module(void)
 {
+	int rc;
 #if 0
     /* @todo enable this soon */
     int rc = get_module(VBOXGUEST_MODULE_NAME, (module_info **)&g_VBoxGuest);
@@ -98,7 +99,10 @@ status_t init_module(void)
         return B_ERROR;
     }
 
-    if (RT_FAILURE(vboxInit()))
+    rc = vboxInit();
+    dprintf("rc=%d\n", rc);
+    if (RT_FAILURE(rc))
+    //if (RT_FAILURE(vboxInit()))
     {
         dprintf("vboxInit failed\n");
         return B_ERROR;
@@ -136,6 +140,7 @@ void uninit_module(void)
 
 PSHFLSTRING make_shflstring(const char* const s)
 {
+    PSHFLSTRING rv;
     int len = strlen(s);
     if (len > 0xFFFE)
     {
@@ -143,7 +148,7 @@ PSHFLSTRING make_shflstring(const char* const s)
         return NULL;
     }
 
-    PSHFLSTRING rv = malloc(sizeof(SHFLSTRING) + len);
+    rv = malloc(sizeof(SHFLSTRING) + len);
     if (!rv)
         return NULL;
 
@@ -194,12 +199,14 @@ PSHFLSTRING concat_cstr_shflstring(const char* const s1, PSHFLSTRING s2)
 
 PSHFLSTRING build_path(vboxsf_vnode* dir, const char* const name)
 {
+    size_t len;
+    PSHFLSTRING rv;
     dprintf("*** build_path(%p, %p)\n", dir, name);
     if (!dir || !name)
         return NULL;
 
-    size_t len = dir->path->u16Length + strlen(name) + 1;
-    PSHFLSTRING rv = malloc(sizeof(SHFLSTRING) + len);
+    len = dir->path->u16Length + strlen(name) + 1;
+    rv = malloc(sizeof(SHFLSTRING) + len);
     if (rv)
     {
         strcpy(rv->String.utf8, dir->path->String.utf8);
@@ -214,6 +221,10 @@ PSHFLSTRING build_path(vboxsf_vnode* dir, const char* const name)
 
 status_t mount(fs_volume *volume, const char *device, uint32 flags, const char *args, ino_t *_rootVnodeID)
 {
+    PSHFLSTRING sharename;
+    vboxsf_volume* vbsfvolume;
+    int rv;
+
     if (device)
     {
         dprintf(FS_NAME ": trying to mount a real device as a vbox share is silly\n");
@@ -222,16 +233,17 @@ status_t mount(fs_volume *volume, const char *device, uint32 flags, const char *
 
     dprintf(FS_NAME ": mount(%s)\n", args);
 
-    PSHFLSTRING sharename = make_shflstring(args);
+    sharename = make_shflstring(args);
 
-    vboxsf_volume* vbsfvolume = malloc(sizeof(vboxsf_volume));
+    vbsfvolume = malloc(sizeof(vboxsf_volume));
     volume->private_volume = vbsfvolume;
-    int rv = vboxCallMapFolder(&g_clientHandle, sharename, &(vbsfvolume->map));
+    rv = vboxCallMapFolder(&g_clientHandle, sharename, &(vbsfvolume->map));
     free(sharename);
 
     if (rv == 0)
     {
         vboxsf_vnode* root_vnode;
+        status_t rs;
 
         PSHFLSTRING name = make_shflstring("");
         if (!name)
@@ -240,7 +252,7 @@ status_t mount(fs_volume *volume, const char *device, uint32 flags, const char *
             return B_NO_MEMORY;
         }
 
-        status_t rs = vboxsf_new_vnode(&vbsfvolume->map, name, name, &root_vnode);
+        rs = vboxsf_new_vnode(&vbsfvolume->map, name, name, &root_vnode);
         dprintf(FS_NAME ": allocated %p (path=%p name=%p)\n", root_vnode, root_vnode->path, root_vnode->name);
 
         if (rs != B_OK)
@@ -323,12 +335,13 @@ status_t vboxsf_open_dir(fs_volume* _volume, fs_vnode* _vnode, void** _cookie)
     vboxsf_volume* volume = _volume->private_volume;
     vboxsf_vnode* vnode = _vnode->private_node;
     SHFLCREATEPARMS params;
+    int rc;
 
     RT_ZERO(params);
     params.Handle = SHFL_HANDLE_NIL;
     params.CreateFlags = SHFL_CF_DIRECTORY | SHFL_CF_ACT_OPEN_IF_EXISTS | SHFL_CF_ACT_FAIL_IF_NEW | SHFL_CF_ACCESS_READ;
 
-    int rc = vboxCallCreate(&g_clientHandle, &volume->map, vnode->path, &params);
+    rc = vboxCallCreate(&g_clientHandle, &volume->map, vnode->path, &params);
     if (RT_SUCCESS(rc))
     {
         if (params.Result == SHFL_FILE_EXISTS && params.Handle != SHFL_HANDLE_NIL)
@@ -358,17 +371,23 @@ status_t vboxsf_open_dir(fs_volume* _volume, fs_vnode* _vnode, void** _cookie)
 status_t vboxsf_read_dir_1(vboxsf_volume* volume, vboxsf_vnode* vnode, vboxsf_dir_cookie* cookie,
     struct dirent* buffer, size_t bufferSize)
 {
+    PSHFLSTRING name1;
+    int rv;
+    vboxsf_vnode* new_vnode;
+    size_t size;
+
     dprintf("%p, %d, %p\n", cookie, cookie->has_more_files, cookie->buffer);
     if (!cookie->has_more_files)
         return B_ENTRY_NOT_FOUND;
 
     if (!cookie->buffer)
     {
+        int rc;
         cookie->buffer_length = 16384;
         cookie->buffer_start = cookie->buffer = malloc(cookie->buffer_length);
 
-        int rc = vboxCallDirInfo(&g_clientHandle, &volume->map, cookie->handle, cookie->path, 0, cookie->index,
-                                 &cookie->buffer_length, cookie->buffer, &cookie->num_files);
+        rc = vboxCallDirInfo(&g_clientHandle, &volume->map, cookie->handle, cookie->path, 0, cookie->index,
+                             &cookie->buffer_length, cookie->buffer, &cookie->num_files);
 
         if (rc != 0 && rc != VERR_NO_MORE_FILES)
         {
@@ -393,15 +412,14 @@ status_t vboxsf_read_dir_1(vboxsf_volume* volume, vboxsf_vnode* vnode, vboxsf_di
         return B_BUFFER_OVERFLOW;
     }
 
-    PSHFLSTRING name1 = clone_shflstring(&cookie->buffer->name);
+    name1 = clone_shflstring(&cookie->buffer->name);
     if (!name1)
     {
         dprintf(FS_NAME ": make_shflstring() failed\n");
         return B_NO_MEMORY;
     }
 
-    vboxsf_vnode* new_vnode;
-    int rv = vboxsf_new_vnode(&volume->map, build_path(vnode, name1->String.utf8), name1, &new_vnode);
+    rv = vboxsf_new_vnode(&volume->map, build_path(vnode, name1->String.utf8), name1, &new_vnode);
     if (rv != B_OK)
     {
         dprintf(FS_NAME ": vboxsf_new_vnode() failed\n");
@@ -415,7 +433,7 @@ status_t vboxsf_read_dir_1(vboxsf_volume* volume, vboxsf_vnode* vnode, vboxsf_di
     buffer->d_reclen = sizeof(struct dirent) + cookie->buffer->name.u16Length;
     strncpy(buffer->d_name, cookie->buffer->name.String.utf8, NAME_MAX);
 
-    size_t size = offsetof(SHFLDIRINFO, name.String) + cookie->buffer->name.u16Size;
+    size = offsetof(SHFLDIRINFO, name.String) + cookie->buffer->name.u16Size;
     cookie->buffer = ((void*)cookie->buffer + size);
     cookie->index++;
 
@@ -504,22 +522,24 @@ status_t vboxsf_read_fs_info(fs_volume* _volume, struct fs_info* info)
 
 status_t vboxsf_lookup(fs_volume* _volume, fs_vnode* dir, const char* name, ino_t* _id)
 {
-    dprintf(FS_NAME ": lookup %s\n", name);
     vboxsf_volume* volume = _volume->private_volume;
     SHFLCREATEPARMS params;
+    PSHFLSTRING path;
+    int rc;
+    dprintf(FS_NAME ": lookup %s\n", name);
 
     RT_ZERO(params);
     params.Handle = SHFL_HANDLE_NIL;
     params.CreateFlags = SHFL_CF_LOOKUP | SHFL_CF_ACT_FAIL_IF_NEW;
 
-    PSHFLSTRING path = build_path(dir->private_node, name);
+    path = build_path(dir->private_node, name);
     if (!path)
     {
         dprintf(FS_NAME ": make_shflstring() failed\n");
         return B_NO_MEMORY;
     }
 
-    int rc = vboxCallCreate(&g_clientHandle, &volume->map, path, &params);
+    rc = vboxCallCreate(&g_clientHandle, &volume->map, path, &params);
     if (RT_SUCCESS(rc))
     {
         if (params.Result == SHFL_FILE_EXISTS)
@@ -600,11 +620,12 @@ status_t vboxsf_open(fs_volume* _volume, fs_vnode* _vnode, int openMode, void**
 {
     vboxsf_volume* volume = _volume->private_volume;
     vboxsf_vnode* vnode = _vnode->private_node;
+    SHFLCREATEPARMS params;
+    int rc;
+    vboxsf_file_cookie* cookie;
 
     dprintf(FS_NAME ": open %s (mode=%x)\n", vnode->path->String.utf8, openMode);
 
-    SHFLCREATEPARMS params;
-
     RT_ZERO(params);
     params.Handle = SHFL_HANDLE_NIL;
 
@@ -637,14 +658,14 @@ status_t vboxsf_open(fs_volume* _volume, fs_vnode* _vnode, int openMode, void**
             params.CreateFlags |= SHFL_CF_ACT_OPEN_IF_EXISTS;
     }
 
-    int rc = vboxCallCreate(&g_clientHandle, &volume->map, vnode->path, &params);
+    rc = vboxCallCreate(&g_clientHandle, &volume->map, vnode->path, &params);
     if (!RT_SUCCESS(rc))
     {
         dprintf("vboxCallCreate returned %d\n", rc);
         return vbox_err_to_haiku_err(rc);
     }
 
-    vboxsf_file_cookie* cookie = malloc(sizeof(vboxsf_file_cookie));
+    cookie = malloc(sizeof(vboxsf_file_cookie));
     if (!cookie)
     {
         dprintf("couldn't allocate file cookie\n");
@@ -665,6 +686,9 @@ status_t vboxsf_create(fs_volume* _volume, fs_vnode* _dir, const char *name, int
     vboxsf_volume* volume = _volume->private_volume;
 
     SHFLCREATEPARMS params;
+    PSHFLSTRING path;
+    int rc;
+    vboxsf_file_cookie* cookie;
 
     RT_ZERO(params);
     params.Handle = SHFL_HANDLE_NIL;
@@ -698,8 +722,8 @@ status_t vboxsf_create(fs_volume* _volume, fs_vnode* _dir, const char *name, int
             params.CreateFlags |= SHFL_CF_ACT_OPEN_IF_EXISTS;
     }
 
-    PSHFLSTRING path = build_path(_dir->private_node, name);
-    int rc = vboxCallCreate(&g_clientHandle, &volume->map, path, &params);
+    path = build_path(_dir->private_node, name);
+    rc = vboxCallCreate(&g_clientHandle, &volume->map, path, &params);
 
     if (!RT_SUCCESS(rc))
     {
@@ -708,7 +732,7 @@ status_t vboxsf_create(fs_volume* _volume, fs_vnode* _dir, const char *name, int
         return vbox_err_to_haiku_err(rc);
     }
 
-    vboxsf_file_cookie* cookie = malloc(sizeof(vboxsf_file_cookie));
+    cookie = malloc(sizeof(vboxsf_file_cookie));
     if (!cookie)
     {
         dprintf("couldn't allocate file cookie\n");
@@ -761,13 +785,16 @@ status_t vboxsf_read(fs_volume* _volume, fs_vnode* _vnode, void* _cookie, off_t
     vboxsf_volume* volume = _volume->private_volume;
     vboxsf_vnode* vnode = _vnode->private_node;
     vboxsf_file_cookie* cookie = _cookie;
+    uint32_t l;
+    void* other_buffer;
+    int rc;
 
     if (*length > 0xFFFFFFFF)
         *length = 0xFFFFFFFF;
 
-    uint32_t l = *length;
-    void* other_buffer = malloc(l);  /* @todo map the user memory into kernel space here for efficiency */
-    int rc = vboxCallRead(&g_clientHandle, &volume->map, cookie->handle, pos, &l, other_buffer, false);
+    l = *length;
+    other_buffer = malloc(l);  /* @todo map the user memory into kernel space here for efficiency */
+    rc = vboxCallRead(&g_clientHandle, &volume->map, cookie->handle, pos, &l, other_buffer, false);
     memcpy(buffer, other_buffer, l);
     free(other_buffer);
 
@@ -782,14 +809,17 @@ status_t vboxsf_write(fs_volume* _volume, fs_vnode* _vnode, void* _cookie, off_t
     vboxsf_volume* volume = _volume->private_volume;
     vboxsf_vnode* vnode = _vnode->private_node;
     vboxsf_file_cookie* cookie = _cookie;
+    uint32_t l;
+    void* other_buffer;
+    int rc;
 
     if (*length > 0xFFFFFFFF)
         *length = 0xFFFFFFFF;
 
-    uint32_t l = *length;
-    void* other_buffer = malloc(l);  /* @todo map the user memory into kernel space here for efficiency */
+    l = *length;
+    other_buffer = malloc(l);  /* @todo map the user memory into kernel space here for efficiency */
     memcpy(other_buffer, buffer, l);
-    int rc = vboxCallWrite(&g_clientHandle, &volume->map, cookie->handle, pos, &l, other_buffer, false);
+    rc = vboxCallWrite(&g_clientHandle, &volume->map, cookie->handle, pos, &l, other_buffer, false);
     free(other_buffer);
 
     *length = l;
@@ -807,6 +837,8 @@ status_t vboxsf_write_stat(fs_volume *volume, fs_vnode *vnode, const struct stat
 status_t vboxsf_create_dir(fs_volume *_volume, fs_vnode *parent, const char *name, int perms)
 {
     vboxsf_volume* volume = _volume->private_volume;
+    PSHFLSTRING path;
+    int rc;
 
     SHFLCREATEPARMS params;
     params.Handle = 0;
@@ -814,8 +846,8 @@ status_t vboxsf_create_dir(fs_volume *_volume, fs_vnode *parent, const char *nam
     params.CreateFlags = SHFL_CF_DIRECTORY | SHFL_CF_ACT_CREATE_IF_NEW |
         SHFL_CF_ACT_FAIL_IF_EXISTS | SHFL_CF_ACCESS_READ;
 
-    PSHFLSTRING path = build_path(parent->private_node, name);
-    int rc = vboxCallCreate(&g_clientHandle, &volume->map, path, &params);
+    path = build_path(parent->private_node, name);
+    rc = vboxCallCreate(&g_clientHandle, &volume->map, path, &params);
     free(path);
     /** @todo r=ramshankar: we should perhaps also check rc here and change
      *        Handle initialization from 0 to SHFL_HANDLE_NIL. */
@@ -879,9 +911,10 @@ status_t vboxsf_create_symlink(fs_volume* _volume, fs_vnode* dir, const char* na
     PSHFLSTRING target = make_shflstring(path);
     PSHFLSTRING linkpath = build_path(dir->private_node, name);
     SHFLFSOBJINFO stuff;
+    int rc;
     RT_ZERO(stuff);
 
-    int rc = vboxCallSymlink(&g_clientHandle, &volume->map, linkpath, target, &stuff);
+    rc = vboxCallSymlink(&g_clientHandle, &volume->map, linkpath, target, &stuff);
 
     free(target);
     free(linkpath);
diff --git a/src/VBox/Additions/haiku/VBoxMouse/Makefile.kmk b/src/VBox/Additions/haiku/VBoxMouse/Makefile.kmk
index b206923..5abe0e8 100644
--- a/src/VBox/Additions/haiku/VBoxMouse/Makefile.kmk
+++ b/src/VBox/Additions/haiku/VBoxMouse/Makefile.kmk
@@ -52,7 +52,7 @@ include	$(KBUILD_PATH)/subheader.kmk
 # R1 will need gcc2-built input_server add-ons.
 
 PROGRAMS += VBoxMouse
-VBoxMouse_TEMPLATE = VBOXGUESTR3EXE
+VBoxMouse_TEMPLATE = NewVBoxGuestR3Exe
 VBoxMouse_DEFS     = VBOX_WITH_HGCM LOG_TO_BACKDOOR
 VBoxMouse_DEFS    += LOG_ENABLED
 VBoxMouse_INCS     = ../include
@@ -67,7 +67,7 @@ VBoxMouse_LIBS     = \
 	/system/servers/input_server
 
 PROGRAMS += VBoxMouseFilter
-VBoxMouseFilter_TEMPLATE = VBOXGUESTR3EXE
+VBoxMouseFilter_TEMPLATE = NewVBoxGuestR3Exe
 VBoxMouseFilter_DEFS     = VBOX_WITH_HGCM LOG_TO_BACKDOOR
 VBoxMouseFilter_DEFS    += LOG_ENABLED
 VBoxMouseFilter_INCS     = ../include
diff --git a/src/VBox/Additions/haiku/VBoxTray/Makefile.kmk b/src/VBox/Additions/haiku/VBoxTray/Makefile.kmk
index 1ef1842..7862bc7 100644
--- a/src/VBox/Additions/haiku/VBoxTray/Makefile.kmk
+++ b/src/VBox/Additions/haiku/VBoxTray/Makefile.kmk
@@ -51,7 +51,7 @@ include	$(KBUILD_PATH)/subheader.kmk
 # single bin will cause problems loading gcc4 binary from a gcc2-built Deskbar!
 
 PROGRAMS += VBoxTray
-VBoxTray_TEMPLATE = VBOXGUESTR3EXE
+VBoxTray_TEMPLATE = NewVBoxGuestR3Exe
 VBoxTray_DEFS     = VBOX_WITH_HGCM LOG_TO_BACKDOOR
 VBoxTray_DEFS    += LOG_ENABLED
 VBoxTray_INCS     = ../include
diff --git a/src/VBox/Additions/haiku/VBoxTray/VBoxGuestApplication.cpp b/src/VBox/Additions/haiku/VBoxTray/VBoxGuestApplication.cpp
index 53d16e3..a7e15b4 100644
--- a/src/VBox/Additions/haiku/VBoxTray/VBoxGuestApplication.cpp
+++ b/src/VBox/Additions/haiku/VBoxTray/VBoxGuestApplication.cpp
@@ -75,6 +75,7 @@ void VBoxGuestApplication::ReadyToRun()
     status_t err;
 
     err = VBoxGuestDeskbarView::AddToDeskbar();
+    printf("error 0x%08lx\n", err);
     LogFlow(("VBoxGuestDeskbarView::ReadyToRun: AddToDeskbar returned 0x%08lx\n", err));
     exit(0);
 }
diff --git a/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.cpp b/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.cpp
index 4f4ae9e..fdc9435 100644
--- a/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.cpp
+++ b/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.cpp
@@ -47,6 +47,7 @@
 *   Header Files                                                               *
 *******************************************************************************/
 #include <errno.h>
+#include <locale.h>
 #include <Alert.h>
 #include <Roster.h>
 #include <Debug.h>
@@ -83,7 +84,8 @@ our_image(image_info& image)
 VBoxGuestDeskbarView::VBoxGuestDeskbarView()
      : BView(BRect(0, 0, 15, 15), VIEWNAME, B_FOLLOW_NONE,
              B_WILL_DRAW | B_NAVIGABLE),
-       fIcon(NULL), fClipboardService(NULL), fDisplayService(NULL)
+       fIcon(NULL), fInitStatus(B_NO_INIT),
+       fClipboardService(NULL), fDisplayService(NULL)
 {
     _Init();
 }
@@ -91,7 +93,8 @@ VBoxGuestDeskbarView::VBoxGuestDeskbarView()
 
 VBoxGuestDeskbarView::VBoxGuestDeskbarView(BMessage *archive)
      : BView(archive),
-       fIcon(NULL)
+       fIcon(NULL), fInitStatus(B_NO_INIT),
+       fClipboardService(NULL), fDisplayService(NULL)
 {
     archive->PrintToStream();
     _Init(archive);
@@ -106,7 +109,13 @@ VBoxGuestDeskbarView::~VBoxGuestDeskbarView()
         fClipboardService->Disconnect();
         delete fClipboardService;
     }
-    VbglR3Term();
+    if (fDisplayService)
+    {
+        //fDisplayService->Disconnect();
+        delete fDisplayService;
+    }
+    if (fInitStatus == B_OK)
+        VbglR3Term();
 }
 
 
@@ -165,8 +174,10 @@ void VBoxGuestDeskbarView::AttachedToWindow()
 void VBoxGuestDeskbarView::DetachedFromWindow()
 {
     BMessage message(B_QUIT_REQUESTED);
-    fClipboardService->MessageReceived(&message);
-    fDisplayService->MessageReceived(&message);
+    if (fClipboardService)
+        fClipboardService->MessageReceived(&message);
+    if (fDisplayService)
+        fDisplayService->MessageReceived(&message);
 }
 
 
@@ -197,7 +208,7 @@ void VBoxGuestDeskbarView::MessageReceived(BMessage *message)
     if (message->what == B_QUIT_REQUESTED)
         RemoveFromDeskbar();
     else
-        BHandler::MessageReceived(message);
+        BView::MessageReceived(message);
 }
 
 
@@ -217,7 +228,9 @@ status_t VBoxGuestDeskbarView::AddToDeskbar(bool force)
         return err;
 
     BPath p(&info.ref);
-    return deskbar.AddItem(&info.ref);
+	printf("%s:%s\n", __FUNCTION__, p.Path());
+	int32 id;
+    return deskbar.AddItem(&info.ref, &id);
 }
 
 
@@ -260,14 +273,15 @@ status_t VBoxGuestDeskbarView::_Init(BMessage *archive)
         fIcon = BTranslationUtils::GetBitmap(&mem);
     }
 
-    int rc = RTR3InitDll(RTR3INIT_FLAGS_UNOBTRUSIVE);
+    int rc = RTR3InitDll(RTR3INIT_FLAGS_SUPLIB | RTR3INIT_FLAGS_UNOBTRUSIVE | RTR3INIT_FLAGS_UTF8_ARGV);
     if (RT_SUCCESS(rc))
     {
         rc = VbglR3Init();
         if (RT_SUCCESS(rc))
         {
             fClipboardService = new VBoxClipboardService();
-            fDisplayService = new VBoxDisplayService();
+            //fDisplayService = new VBoxDisplayService();
+            fInitStatus = B_OK;
         }
         else
             LogRel(("VBoxGuestDeskbarView::_init VbglR3Init failed. rc=%d\n", rc));
@@ -278,8 +292,10 @@ status_t VBoxGuestDeskbarView::_Init(BMessage *archive)
 }
 
 
+extern "C" {
 RTDECL(BView*) instantiate_deskbar_item()
 {
+	printf("%s()\n", __FUNCTION__);
     return new VBoxGuestDeskbarView();
 }
-
+} // C
diff --git a/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.h b/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.h
index 778c576..e70ac71 100644
--- a/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.h
+++ b/src/VBox/Additions/haiku/VBoxTray/VBoxGuestDeskbarView.h
@@ -88,6 +88,7 @@ class VBoxGuestDeskbarView : public BView
         status_t               _Init(BMessage *archive = NULL);
         BBitmap               *fIcon;
 
+        status_t               fInitStatus;
         VBoxClipboardService *fClipboardService;
         VBoxDisplayService *fDisplayService;
 };
diff --git a/src/VBox/Runtime/VBox/log-vbox.cpp b/src/VBox/Runtime/VBox/log-vbox.cpp
index 390a9a5..46eae72 100644
--- a/src/VBox/Runtime/VBox/log-vbox.cpp
+++ b/src/VBox/Runtime/VBox/log-vbox.cpp
@@ -424,7 +424,7 @@ RTDECL(PRTLOGGER) RTLogDefaultInit(void)
 
 # else  /* IN_GUEST */
     /* The user destination is backdoor logging. */
-    rc = RTLogCreate(&pLogger, 0, NULL, "VBOX_LOG", RT_ELEMENTS(g_apszGroups), &g_apszGroups[0], RTLOGDEST_USER, "VBox.log");
+    rc = RTLogCreate(&pLogger, 0, NULL, "VBOX_LOG", RT_ELEMENTS(g_apszGroups), &g_apszGroups[0], RTLOGDEST_USER, "VirtualBox.log");
 # endif /* IN_GUEST */
 
 #else /* IN_RING0 */
@@ -492,6 +492,11 @@ RTDECL(PRTLOGGER) RTLogDefaultInit(void)
         RTLogGroupSettings(pLogger, "all=~0 -default.l6.l5.l4.l3");
         RTLogFlags(pLogger, "enabled unbuffered tid");
         pLogger->fDestFlags |= RTLOGDEST_DEBUGGER | RTLOGDEST_STDOUT;
+# endif
+# if 1 /* vboxdrv logging - ATTENTION: this is what we're referring to guys! Change to '# if 1'. */
+        RTLogGroupSettings(pLogger, "+all");
+        RTLogFlags(pLogger, "enabled unbuffered tid");
+        pLogger->fDestFlags |= RTLOGDEST_DEBUGGER | RTLOGDEST_STDOUT;
 # endif
     }
 #endif /* IN_RING0 */
diff --git a/src/VBox/Runtime/r0drv/haiku/RTLogWriteDebugger-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/RTLogWriteDebugger-r0drv-haiku.c
index 7d67906..0d4528e 100644
--- a/src/VBox/Runtime/r0drv/haiku/RTLogWriteDebugger-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/RTLogWriteDebugger-r0drv-haiku.c
@@ -36,6 +36,7 @@
 RTDECL(void) RTLogWriteDebugger(const char *pch, size_t cb)
 {
     /** @todo implement this */
+    dprintf("%.*s", (int)cb, pch);
     /*kprintf("%.*s", (int)cb, pch);*/
     return;
 }
diff --git a/src/VBox/Runtime/r0drv/haiku/alloc-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/alloc-r0drv-haiku.c
index 58c7203..1397718 100644
--- a/src/VBox/Runtime/r0drv/haiku/alloc-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/alloc-r0drv-haiku.c
@@ -44,10 +44,12 @@
  */
 int rtR0MemAllocEx(size_t cb, uint32_t fFlags, PRTMEMHDR *ppHdr)
 {
+	PRTMEMHDR pHdr;
+
     if (RT_UNLIKELY(fFlags & RTMEMHDR_FLAG_ANY_CTX))
         return VERR_NOT_SUPPORTED;
 
-    PRTMEMHDR pHdr = (PRTMEMHDR)malloc(cb + sizeof(*pHdr));
+    pHdr = (PRTMEMHDR)malloc(cb + sizeof(*pHdr));
     if (RT_UNLIKELY(!pHdr))
     {
         LogRel(("rtR0MemAllocEx(%u, %#x) failed\n",(unsigned)cb + sizeof(*pHdr), fFlags));
@@ -75,6 +77,9 @@ void rtR0MemFree(PRTMEMHDR pHdr)
 
 RTR0DECL(void *) RTMemContAlloc(PRTCCPHYS pPhys, size_t cb) RT_NO_THROW
 {
+    void *pv;
+    area_id area;
+
     /*
      * Validate input.
      */
@@ -86,9 +91,8 @@ RTR0DECL(void *) RTMemContAlloc(PRTCCPHYS pPhys, size_t cb) RT_NO_THROW
      * Allocate the memory and ensure that the API is still providing
      * memory that's always below 4GB.
      */
-    cb = RT_ALIGN_Z(cb, PAGE_SIZE);
-    void *pv;
-    area_id area = create_area("VirtualBox Contig Alloc", &pv, B_ANY_KERNEL_ADDRESS, cb, B_32_BIT_CONTIGUOUS,
+    cb = RT_ALIGN_Z(cb, B_PAGE_SIZE);
+    area = create_area("VirtualBox Contig Alloc", &pv, B_ANY_KERNEL_ADDRESS, cb, B_32_BIT_CONTIGUOUS,
                                B_READ_AREA | B_WRITE_AREA);
     if (area >= 0)
     {
@@ -112,9 +116,10 @@ RTR0DECL(void) RTMemContFree(void *pv, size_t cb) RT_NO_THROW
     RT_ASSERT_PREEMPTIBLE();
     if (pv)
     {
+        area_id area;
         Assert(cb > 0);
 
-        area_id area = area_for(pv);
+        area = area_for(pv);
         if (area >= B_OK)
         delete_area(area);
         else
diff --git a/src/VBox/Runtime/r0drv/haiku/memobj-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/memobj-r0drv-haiku.c
index 8c27a26..a4a0742 100644
--- a/src/VBox/Runtime/r0drv/haiku/memobj-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/memobj-r0drv-haiku.c
@@ -153,13 +153,15 @@ int rtR0MemObjNativeFree(RTR0MEMOBJ pMem)
 static int rtR0MemObjNativeAllocArea(PPRTR0MEMOBJINTERNAL ppMem, size_t cb,
                                      bool fExecutable, RTR0MEMOBJTYPE type, RTHCPHYS PhysHighest, size_t uAlignment)
 {
-    NOREF(fExecutable);
-
     int rc;
     void *pvMap         = NULL;
     const char *pszName = NULL;
     uint32 addressSpec  = B_ANY_KERNEL_ADDRESS;
     uint32 fLock        = ~0U;
+    PRTR0MEMOBJHAIKU pMemHaiku;
+
+    NOREF(fExecutable);
+
     LogFlowFunc(("ppMem=%p cb=%u, fExecutable=%s, type=%08x, PhysHighest=%RX64 uAlignment=%u\n", ppMem,(unsigned)cb,
                  fExecutable ? "true" : "false", type, PhysHighest,(unsigned)uAlignment));
 
@@ -201,7 +203,6 @@ static int rtR0MemObjNativeAllocArea(PPRTR0MEMOBJINTERNAL ppMem, size_t cb,
     }
 
     /* Create the object. */
-    PRTR0MEMOBJHAIKU pMemHaiku;
     pMemHaiku = (PRTR0MEMOBJHAIKU)rtR0MemObjNew(sizeof(RTR0MEMOBJHAIKU), type, NULL, cb);
     if (RT_UNLIKELY(!pMemHaiku))
         return VERR_NO_MEMORY;
@@ -277,11 +278,13 @@ int rtR0MemObjNativeAllocPhysNC(PPRTR0MEMOBJINTERNAL ppMem, size_t cb, RTHCPHYS
 
 int rtR0MemObjNativeEnterPhys(PPRTR0MEMOBJINTERNAL ppMem, RTHCPHYS Phys, size_t cb, uint32_t uCachePolicy)
 {
+    PRTR0MEMOBJHAIKU pMemHaiku;
+
     AssertReturn(uCachePolicy == RTMEM_CACHE_POLICY_DONT_CARE, VERR_NOT_SUPPORTED);
     LogFlowFunc(("ppMem=%p Phys=%08x cb=%u uCachePolicy=%x\n", ppMem, Phys,(unsigned)cb, uCachePolicy));
 
     /* Create the object. */
-    PRTR0MEMOBJHAIKU pMemHaiku = (PRTR0MEMOBJHAIKU)rtR0MemObjNew(sizeof(*pMemHaiku), RTR0MEMOBJTYPE_PHYS, NULL, cb);
+    pMemHaiku = (PRTR0MEMOBJHAIKU)rtR0MemObjNew(sizeof(*pMemHaiku), RTR0MEMOBJTYPE_PHYS, NULL, cb);
     if (!pMemHaiku)
         return VERR_NO_MEMORY;
 
@@ -311,15 +314,16 @@ int rtR0MemObjNativeEnterPhys(PPRTR0MEMOBJINTERNAL ppMem, RTHCPHYS Phys, size_t
 static int rtR0MemObjNativeLockInMap(PPRTR0MEMOBJINTERNAL ppMem, void *pvStart, size_t cb, uint32_t fAccess,
                                      RTR0PROCESS R0Process, int fFlags)
 {
-    NOREF(fAccess);
     int rc;
     team_id TeamId = B_SYSTEM_TEAM;
+    PRTR0MEMOBJHAIKU pMemHaiku;
+    NOREF(fAccess);
 
     LogFlowFunc(("ppMem=%p pvStart=%p cb=%u fAccess=%x R0Process=%d fFlags=%x\n", ppMem, pvStart, cb, fAccess, R0Process,
                  fFlags));
 
     /* Create the object. */
-    PRTR0MEMOBJHAIKU pMemHaiku = (PRTR0MEMOBJHAIKU)rtR0MemObjNew(sizeof(*pMemHaiku), RTR0MEMOBJTYPE_LOCK, pvStart, cb);
+    pMemHaiku = (PRTR0MEMOBJHAIKU)rtR0MemObjNew(sizeof(*pMemHaiku), RTR0MEMOBJTYPE_LOCK, pvStart, cb);
     if (RT_UNLIKELY(!pMemHaiku))
         return VERR_NO_MEMORY;
 
@@ -605,10 +609,11 @@ RTHCPHYS rtR0MemObjNativeGetPagePhysAddr(PRTR0MEMOBJINTERNAL pMem, size_t iPage)
             team_id        TeamId = B_SYSTEM_TEAM;
             physical_entry aPhysMap[2];
             int32          cPhysMap = 2;    /** @todo r=ramshankar: why not use RT_ELEMENTS? */
+            void *pb;
 
             if (pMemHaiku->Core.u.Lock.R0Process != NIL_RTR0PROCESS)
                 TeamId = (team_id)pMemHaiku->Core.u.Lock.R0Process;
-            void *pb = pMemHaiku->Core.pv + (iPage << PAGE_SHIFT);
+            pb = pMemHaiku->Core.pv + (iPage << PAGE_SHIFT);
 
             rc = get_memory_map_etc(TeamId, pb, B_PAGE_SIZE, aPhysMap, &cPhysMap);
             if (rc < B_OK || cPhysMap < 1)
diff --git a/src/VBox/Runtime/r0drv/haiku/semevent-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/semevent-r0drv-haiku.c
index 9914262..667fe6e 100644
--- a/src/VBox/Runtime/r0drv/haiku/semevent-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/semevent-r0drv-haiku.c
@@ -66,12 +66,15 @@ RTDECL(int)  RTSemEventCreate(PRTSEMEVENT phEventSem)
 
 RTDECL(int)  RTSemEventCreateEx(PRTSEMEVENT phEventSem, uint32_t fFlags, RTLOCKVALCLASS hClass, const char *pszNameFmt, ...)
 {
+    PRTSEMEVENTINTERNAL pThis;
+
     AssertCompile(sizeof(RTSEMEVENTINTERNAL) > sizeof(void *));
     AssertReturn(!(fFlags & ~(RTSEMEVENT_FLAGS_NO_LOCK_VAL | RTSEMEVENT_FLAGS_BOOTSTRAP_HACK)), VERR_INVALID_PARAMETER);
     Assert(!(fFlags & RTSEMEVENT_FLAGS_BOOTSTRAP_HACK) || (fFlags & RTSEMEVENT_FLAGS_NO_LOCK_VAL));
+    dprintf("phEventSem: %p\n", phEventSem);
     AssertPtrReturn(phEventSem, VERR_INVALID_POINTER);
 
-    PRTSEMEVENTINTERNAL pThis = (PRTSEMEVENTINTERNAL)RTMemAllocZ(sizeof(*pThis));
+    pThis = (PRTSEMEVENTINTERNAL)RTMemAllocZ(sizeof(*pThis));
     if (!pThis)
         return VERR_NO_MEMORY;
 
diff --git a/src/VBox/Runtime/r0drv/haiku/semeventmulti-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/semeventmulti-r0drv-haiku.c
index 3179fc9..524e6d2 100644
--- a/src/VBox/Runtime/r0drv/haiku/semeventmulti-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/semeventmulti-r0drv-haiku.c
@@ -76,7 +76,7 @@ RTDECL(int)  RTSemEventMultiCreateEx(PRTSEMEVENTMULTI phEventMultiSem, uint32_t
     pThis->u32Magic  = RTSEMEVENTMULTI_MAGIC;
     pThis->cRefs     = 1;
     pThis->SemId     = create_sem(0, "IPRT Semaphore Event Multi");
-    if (pThis->SemId < B_OK)
+    if (pThis->SemId >= B_OK)
     {
         set_sem_owner(pThis->SemId, B_SYSTEM_TEAM);
         *phEventMultiSem = pThis;
diff --git a/src/VBox/Runtime/r0drv/haiku/semfastmutex-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/semfastmutex-r0drv-haiku.c
index c34189c..9c96529 100644
--- a/src/VBox/Runtime/r0drv/haiku/semfastmutex-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/semfastmutex-r0drv-haiku.c
@@ -57,10 +57,13 @@ typedef struct RTSEMFASTMUTEXINTERNAL
 
 RTDECL(int)  RTSemFastMutexCreate(PRTSEMFASTMUTEX phFastMtx)
 {
+    PRTSEMFASTMUTEXINTERNAL pThis;
+
     AssertCompile(sizeof(RTSEMFASTMUTEXINTERNAL) > sizeof(void *));
+    dprintf("phFastMtx: %p\n", phFastMtx);
     AssertPtrReturn(phFastMtx, VERR_INVALID_POINTER);
 
-    PRTSEMFASTMUTEXINTERNAL pThis = (PRTSEMFASTMUTEXINTERNAL)RTMemAllocZ(sizeof(*pThis));
+    pThis = (PRTSEMFASTMUTEXINTERNAL)RTMemAllocZ(sizeof(*pThis));
     if (RT_UNLIKELY(!pThis))
         return VERR_NO_MEMORY;
 
diff --git a/src/VBox/Runtime/r0drv/haiku/semmutex-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/semmutex-r0drv-haiku.c
index 4f4f68a..00b8d91 100644
--- a/src/VBox/Runtime/r0drv/haiku/semmutex-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/semmutex-r0drv-haiku.c
@@ -65,16 +65,19 @@ typedef struct RTSEMMUTEXINTERNAL
 
 RTDECL(int)  RTSemMutexCreate(PRTSEMMUTEX phMutexSem)
 {
+    PRTSEMMUTEXINTERNAL pThis;
+
     AssertCompile(sizeof(RTSEMMUTEXINTERNAL) > sizeof(void *));
+    dprintf("phMutexSem: %p\n", phMutexSem);
     AssertPtrReturn(phMutexSem, VERR_INVALID_POINTER);
 
-    PRTSEMMUTEXINTERNAL pThis = (PRTSEMMUTEXINTERNAL)RTMemAllocZ(sizeof(*pThis));
+    pThis = (PRTSEMMUTEXINTERNAL)RTMemAllocZ(sizeof(*pThis));
     if (RT_UNLIKELY(!pThis))
         return VERR_NO_MEMORY;
 
     pThis->u32Magic = RTSEMMUTEX_MAGIC;
     pThis->SemId = create_sem(0, "IPRT Mutex Semaphore");
-    if (pThis->SemId < B_OK)
+    if (pThis->SemId >= B_OK)
     {
         pThis->OwnerId = -1;
         pThis->cRecursion = 0;
@@ -215,7 +218,7 @@ RTDECL(int)  RTSemMutexRelease(RTSEMMUTEX hMutexSem)
     if (--pThis->cRecursion == 0)
     {
         pThis->OwnerId == -1;
-        release_sem(pThis->SemId);
+        release_sem_etc(pThis->SemId, 1, B_DO_NOT_RESCHEDULE);
     }
 
     return VINF_SUCCESS;
diff --git a/src/VBox/Runtime/r0drv/haiku/spinlock-r0drv-haiku.c b/src/VBox/Runtime/r0drv/haiku/spinlock-r0drv-haiku.c
index 6ffed17..e97a712 100644
--- a/src/VBox/Runtime/r0drv/haiku/spinlock-r0drv-haiku.c
+++ b/src/VBox/Runtime/r0drv/haiku/spinlock-r0drv-haiku.c
@@ -66,14 +66,15 @@ typedef struct RTSPINLOCKINTERNAL
 
 RTDECL(int)  RTSpinlockCreate(PRTSPINLOCK pSpinlock, uint32_t fFlags, const char *pszName)
 {
+    PRTSPINLOCKINTERNAL pSpinlockInt;
     RT_ASSERT_PREEMPTIBLE();
     NOREF(pszName);
 
     /*
      * Allocate.
      */
-    AssertCompile(sizeof(RTSPINLOCKINTERNAL) > sizeof(void *));
-    PRTSPINLOCKINTERNAL pSpinlockInt = (PRTSPINLOCKINTERNAL)RTMemAllocZ(sizeof(*pSpinlockInt));
+//    AssertCompile(sizeof(RTSPINLOCKINTERNAL) > sizeof(void *));
+    pSpinlockInt = (PRTSPINLOCKINTERNAL)RTMemAllocZ(sizeof(*pSpinlockInt));
     if (RT_UNLIKELY(!pSpinlockInt))
         return VERR_NO_MEMORY;
 
diff --git a/src/VBox/Runtime/r3/haiku/rtProcInitExePath-haiku.cpp b/src/VBox/Runtime/r3/haiku/rtProcInitExePath-haiku.cpp
index 7a41e9f..7dd0c0c 100644
--- a/src/VBox/Runtime/r3/haiku/rtProcInitExePath-haiku.cpp
+++ b/src/VBox/Runtime/r3/haiku/rtProcInitExePath-haiku.cpp
@@ -31,6 +31,7 @@
 #ifdef RT_OS_HAIKU
 # include <image.h>
 #endif
+#include <stdio.h>
 
 #include <iprt/string.h>
 #include <iprt/assert.h>
@@ -51,6 +52,7 @@ DECLHIDDEN(int) rtProcInitExePath(char *pszPath, size_t cchPath)
      */
     status = get_next_image_info(0, &Cookie, &ImageInfo);
     AssertReturn((status == B_OK), VERR_INTERNAL_ERROR);
+fprintf(stderr, "p='%s'\n", ImageInfo.name);
 
     int rc = rtPathFromNativeCopy(pszPath, MIN(cchPath, MAXPATHLEN), ImageInfo.name, NULL);
     AssertMsgRCReturn(rc, ("rc=%Rrc pszLink=\"%s\"\nhex: %.*Rhxs\n", rc, pszPath, MIN(cchPath, MAXPATHLEN), pszPath), rc);
diff --git a/src/VBox/Runtime/r3/posix/utf8-posix.cpp b/src/VBox/Runtime/r3/posix/utf8-posix.cpp
index cb723eb..c4c4d71 100644
--- a/src/VBox/Runtime/r3/posix/utf8-posix.cpp
+++ b/src/VBox/Runtime/r3/posix/utf8-posix.cpp
@@ -173,7 +173,7 @@ static int rtstrConvertCached(const void *pvInput, size_t cbInput, const char *p
         iconv_t hIconv = (iconv_t)*phIconv;
         if (hIconv == (iconv_t)-1)
         {
-#ifdef RT_OS_SOLARIS
+#if defined(RT_OS_HAIKU) || defined(RT_OS_SOLARIS)
             /* Solaris doesn't grok empty codeset strings, so help it find the current codeset. */
             if (!*pszInputCS)
                 pszInputCS = rtStrGetLocaleCodeset();
@@ -304,7 +304,7 @@ static int rtStrConvertUncached(const void *pvInput, size_t cbInput, const char
         /*
          * Create conversion object.
          */
-#ifdef RT_OS_SOLARIS
+#if defined(RT_OS_HAIKU) || defined(RT_OS_SOLARIS)
         /* Solaris doesn't grok empty codeset strings, so help it find the current codeset. */
         if (!*pszInputCS)
             pszInputCS = rtStrGetLocaleCodeset();
diff --git a/src/libs/kStuff/kStuff/include/k/kDefs.h b/src/libs/kStuff/kStuff/include/k/kDefs.h
index 0f2215f..064d62d 100644
--- a/src/libs/kStuff/kStuff/include/k/kDefs.h
+++ b/src/libs/kStuff/kStuff/include/k/kDefs.h
@@ -60,8 +60,10 @@
 #define K_OS_SOLARIS    9
 /** Windows. */
 #define K_OS_WINDOWS    10
+/** Haiku */
+#define K_OS_HAIKU      11
 /** The max K_OS_* value (exclusive). */
-#define K_OS_MAX        11
+#define K_OS_MAX        12
 /** @} */
 
 /** @def K_OS
@@ -82,6 +84,8 @@
 #  define K_OS      K_OS_DRAGONFLY
 # elif defined(__FreeBSD__) /*??*/
 #  define K_OS      K_OS_FREEBSD
+# elif defined(__HAIKU__)
+#  define K_OS      K_OS_HAIKU
 # elif defined(__gnu_linux__)
 #  define K_OS      K_OS_LINUX
 # elif defined(__NetBSD__) /*??*/
-- 
2.15.0

