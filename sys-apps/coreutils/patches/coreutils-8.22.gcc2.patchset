From ed40f7e0aa7652d5bf77c52047739a84b7acad8b Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Sun, 18 May 2014 21:41:14 +0000
Subject: gcc2 patch c89


diff --git a/lib/fts.c b/lib/fts.c
index 74968b3..6134365 100644
--- a/lib/fts.c
+++ b/lib/fts.c
@@ -1293,6 +1293,7 @@ fts_build (register FTS *sp, int type)
         int dir_fd;
         FTSENT *cur = sp->fts_cur;
         bool continue_readdir = !!cur->fts_dirp;
+		size_t max_entries;
 
         /* When cur->fts_dirp is non-NULL, that means we should
            continue calling readdir on that existing DIR* pointer
@@ -1354,7 +1355,7 @@ fts_build (register FTS *sp, int type)
            function.  But when no such function is specified, we can read
            entries in batches that are large enough to help us with inode-
            sorting, yet not so large that we risk exhausting memory.  */
-        size_t max_entries = (sp->fts_compar == NULL
+        max_entries = (sp->fts_compar == NULL
                               ? FTS_MAX_READDIR_ENTRIES : SIZE_MAX);
 
         /*
diff --git a/lib/randperm.c b/lib/randperm.c
index ffa8faa..31c8c06 100644
--- a/lib/randperm.c
+++ b/lib/randperm.c
@@ -114,8 +114,11 @@ sparse_new (size_t size_hint)
 static void
 sparse_swap (sparse_map *sv, size_t* v, size_t i, size_t j)
 {
-  struct sparse_ent_ *v1 = hash_delete (sv, &(struct sparse_ent_) {i,0});
-  struct sparse_ent_ *v2 = hash_delete (sv, &(struct sparse_ent_) {j,0});
+  struct sparse_ent_ ent1 = {i,0};
+  struct sparse_ent_ ent2 = {j,0};
+  size_t t;
+  struct sparse_ent_ *v1 = hash_delete (sv, &ent1);
+  struct sparse_ent_ *v2 = hash_delete (sv, &ent2);
 
   /* FIXME: reduce the frequency of these mallocs.  */
   if (!v1)
@@ -129,7 +132,7 @@ sparse_swap (sparse_map *sv, size_t* v, size_t i, size_t j)
       v2->index = v2->val = j;
     }
 
-  size_t t = v1->val;
+  t = v1->val;
   v1->val = v2->val;
   v2->val = t;
   if (!hash_insert (sv, v1))
diff --git a/lib/utimecmp.c b/lib/utimecmp.c
index dc622ad..895e500 100644
--- a/lib/utimecmp.c
+++ b/lib/utimecmp.c
@@ -131,14 +131,13 @@ utimecmp (char const *dst_name,
 
      time_t might be unsigned.  */
 
-  verify (TYPE_IS_INTEGER (time_t));
-  verify (TYPE_TWOS_COMPLEMENT (int));
-
   /* Destination and source time stamps.  */
   time_t dst_s = dst_stat->st_mtime;
   time_t src_s = src_stat->st_mtime;
   int dst_ns = get_stat_mtime_ns (dst_stat);
   int src_ns = get_stat_mtime_ns (src_stat);
+  verify (TYPE_IS_INTEGER (time_t));
+  verify (TYPE_TWOS_COMPLEMENT (int));
 
   if (options & UTIMECMP_TRUNCATE_SOURCE)
     {
diff --git a/lib/verify.h b/lib/verify.h
index bf40b02..4b34514 100644
--- a/lib/verify.h
+++ b/lib/verify.h
@@ -248,7 +248,8 @@ template <int w>
 /* Verify requirement R at compile-time, as a declaration without a
    trailing ';'.  */
 
-#define verify(R) _GL_VERIFY (R, "verify (" #R ")")
+//#define verify(R) _GL_VERIFY (R, "verify (" #R ")")
+#define verify(R)
 
 #ifndef __has_builtin
 # define __has_builtin(x) 0
diff --git a/src/chown-core.c b/src/chown-core.c
index a5a2b47..a8c4b07 100644
--- a/src/chown-core.c
+++ b/src/chown-core.c
@@ -219,6 +219,7 @@ restricted_chown (int cwd_fd, char const *file,
   struct stat st;
   int open_flags = O_NONBLOCK | O_NOCTTY;
   int fd;
+  int saved_errno;
 
   if (required_uid == (uid_t) -1 && required_gid == (gid_t) -1)
     return RC_do_ordinary_chown;
@@ -256,7 +257,7 @@ restricted_chown (int cwd_fd, char const *file,
         }
     }
 
-  int saved_errno = errno;
+  saved_errno = errno;
   close (fd);
   errno = saved_errno;
   return status;
diff --git a/src/chroot.c b/src/chroot.c
index 89fd392..ca4aeff 100644
--- a/src/chroot.c
+++ b/src/chroot.c
@@ -161,6 +161,7 @@ main (int argc, char **argv)
   int c;
   char const *userspec = NULL;
   char const *groups = NULL;
+  bool fail;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -221,7 +222,7 @@ main (int argc, char **argv)
       argv += optind + 1;
     }
 
-  bool fail = false;
+  fail = false;
 
   /* Attempt to set all three: supplementary groups, group ID, user ID.
      Diagnose any failures.  If any have failed, exit before execvp.  */
diff --git a/src/copy.c b/src/copy.c
index 0f044d0..d1cc7a0 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -293,13 +293,15 @@ extent_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
   /* Keep track of the output position.
      We may need this at the end, for a final ftruncate.  */
   off_t dest_pos = 0;
-
+  bool wrote_hole_at_eof = true;
+  
   extent_scan_init (src_fd, &scan);
 
   *require_normal_copy = false;
-  bool wrote_hole_at_eof = true;
   do
     {
+      unsigned int i;
+      bool empty_extent = false;
       bool ok = extent_scan_read (&scan);
       if (! ok)
         {
@@ -317,8 +319,6 @@ extent_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
           return false;
         }
 
-      unsigned int i;
-      bool empty_extent = false;
       for (i = 0; i < scan.ei_count || empty_extent; i++)
         {
           off_t ext_start;
@@ -589,6 +589,7 @@ copy_dir (char const *src_name_in, char const *dst_name_in, bool new_dst,
   char *namep;
   struct cp_options non_command_line_options = *x;
   bool ok = true;
+  bool new_first_dir_created = false;
 
   name_space = savedir (src_name_in);
   if (name_space == NULL)
@@ -604,7 +605,6 @@ copy_dir (char const *src_name_in, char const *dst_name_in, bool new_dst,
   if (x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)
     non_command_line_options.dereference = DEREF_NEVER;
 
-  bool new_first_dir_created = false;
   namep = name_space;
   while (*namep != '\0')
     {
@@ -991,7 +991,7 @@ copy_reg (char const *src_name, char const *dst_name,
   if (*new_dst)
     {
     open_with_O_CREAT:;
-
+{
       int open_flags = O_WRONLY | O_CREAT | O_BINARY;
       dest_desc = open (dst_name, open_flags | O_EXCL,
                         dst_mode & ~omitted_permissions);
@@ -1035,6 +1035,7 @@ copy_reg (char const *src_name, char const *dst_name,
           && *dst_name && dst_name[strlen (dst_name) - 1] == '/')
         dest_errno = ENOTDIR;
     }
+    }
   else
     {
       omitted_permissions = 0;
@@ -1097,12 +1098,14 @@ copy_reg (char const *src_name, char const *dst_name,
       size_t buf_alignment = lcm (getpagesize (), sizeof (word));
       size_t buf_alignment_slop = sizeof (word) + buf_alignment - 1;
       size_t buf_size = io_blksize (sb);
+      bool make_holes = false;
+      bool sparse_src = false;
+      off_t n_read;
+      bool wrote_hole_at_eof;
 
       fdadvise (source_desc, 0, 0, FADVISE_SEQUENTIAL);
 
       /* Deal with sparse files.  */
-      bool make_holes = false;
-      bool sparse_src = false;
 
       if (S_ISREG (sb.st_mode))
         {
@@ -1169,8 +1172,6 @@ copy_reg (char const *src_name, char const *dst_name,
             }
         }
 
-      off_t n_read;
-      bool wrote_hole_at_eof;
       if ( ! sparse_copy (source_desc, dest_desc, buf, buf_size,
                           make_holes, src_name, dst_name,
                           UINTMAX_MAX, &n_read,
@@ -1667,10 +1668,11 @@ create_hard_link (char const *src_name, char const *dst_name,
 {
   /* We want to guarantee that symlinks are not followed, unless requested.  */
   int flags = 0;
+  bool link_failed;
   if (dereference)
     flags = AT_SYMLINK_FOLLOW;
 
-  bool link_failed = (linkat (AT_FDCWD, src_name, AT_FDCWD, dst_name, flags)
+  link_failed = (linkat (AT_FDCWD, src_name, AT_FDCWD, dst_name, flags)
                       != 0);
 
   /* If the link failed because of an existing destination,
@@ -1746,6 +1748,7 @@ copy_internal (char const *src_name, char const *dst_name,
   bool copied_as_regular = false;
   bool dest_is_symlink = false;
   bool have_dst_lstat = false;
+  bool dereference;
 
   if (x->move_mode && rename_succeeded)
     *rename_succeeded = false;
@@ -1784,7 +1787,7 @@ copy_internal (char const *src_name, char const *dst_name,
       record_file (x->src_info, src_name, &src_sb);
     }
 
-  bool dereference = should_dereference (x, command_line_arg);
+  dereference = should_dereference (x, command_line_arg);
 
   if (!new_dst)
     {
@@ -2793,6 +2796,7 @@ copy (char const *src_name, char const *dst_name,
       bool nonexistent_dst, const struct cp_options *options,
       bool *copy_into_self, bool *rename_succeeded)
 {
+  bool first_dir_created_per_command_line_arg = false;
   assert (valid_options (options));
 
   /* Record the file names: they're used in case of error, when copying
@@ -2805,7 +2809,6 @@ copy (char const *src_name, char const *dst_name,
   top_level_src_name = src_name;
   top_level_dst_name = dst_name;
 
-  bool first_dir_created_per_command_line_arg = false;
   return copy_internal (src_name, dst_name, nonexistent_dst, 0, NULL,
                         options, true,
                         &first_dir_created_per_command_line_arg,
diff --git a/src/cp.c b/src/cp.c
index 9038d4e..f76a22b 100644
--- a/src/cp.c
+++ b/src/cp.c
@@ -823,6 +823,7 @@ cp_option_init (struct cp_options *x)
 static void
 decode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)
 {
+  char *arg_writable, *s;
   enum File_attribute
     {
       PRESERVE_MODE,
@@ -847,8 +848,8 @@ decode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)
     };
   ARGMATCH_VERIFY (preserve_args, preserve_vals);
 
-  char *arg_writable = xstrdup (arg);
-  char *s = arg_writable;
+  arg_writable = xstrdup (arg);
+  s = arg_writable;
   do
     {
       /* find next comma */
diff --git a/src/csplit.c b/src/csplit.c
index 5bfca09..581c790 100644
--- a/src/csplit.c
+++ b/src/csplit.c
@@ -1225,8 +1225,9 @@ static size_t
 get_format_flags (char const *format, int *flags_ptr)
 {
   int flags = 0;
+  size_t count;
 
-  for (size_t count = 0; ; count++)
+  for (count = 0; ; count++)
     {
       switch (format[count])
         {
@@ -1300,15 +1301,17 @@ static size_t
 max_out (char *format)
 {
   bool percent = false;
+  char *f;
+  int maxlen;
 
-  for (char *f = format; *f; f++)
+  for (f = format; *f; f++)
     if (*f == '%' && *++f != '%')
       {
+        int flags;
         if (percent)
           error (EXIT_FAILURE, 0,
                  _("too many %% conversion specifications in suffix"));
         percent = true;
-        int flags;
         f += get_format_flags (f, &flags);
         while (ISDIGIT (*f))
           f++;
@@ -1322,7 +1325,7 @@ max_out (char *format)
     error (EXIT_FAILURE, 0,
            _("missing %% conversion specification in suffix"));
 
-  int maxlen = snprintf (NULL, 0, format, UINT_MAX);
+  maxlen = snprintf (NULL, 0, format, UINT_MAX);
   if (! (0 <= maxlen && maxlen <= SIZE_MAX))
     xalloc_die ();
   return maxlen;
@@ -1333,6 +1336,8 @@ main (int argc, char **argv)
 {
   int optc;
   unsigned long int val;
+  size_t prefix_len;
+  size_t max_digit_string_len;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1402,8 +1407,8 @@ main (int argc, char **argv)
       usage (EXIT_FAILURE);
     }
 
-  size_t prefix_len = strlen (prefix);
-  size_t max_digit_string_len
+  prefix_len = strlen (prefix);
+  max_digit_string_len
     = (suffix
        ? max_out (suffix)
        : MAX (INT_STRLEN_BOUND (unsigned int), digits));
diff --git a/src/cut.c b/src/cut.c
index 19ef1d9..00d4b51 100644
--- a/src/cut.c
+++ b/src/cut.c
@@ -399,7 +399,8 @@ set_fields (const char *fieldstr)
   /* Merge range pairs (e.g. `2-5,3-4' becomes `2-5'). */
   for (i = 0; i < n_rp; ++i)
     {
-      for (size_t j = i + 1; j < n_rp; ++j)
+      size_t j;
+      for (j = i + 1; j < n_rp; ++j)
         {
           if (rp[j].lo <= rp[i].hi)
             {
@@ -534,6 +535,7 @@ cut_fields (FILE *stream)
 
   while (1)
     {
+      int prev_c;
       if (field_idx == 1 && buffer_first_field)
         {
           ssize_t len;
@@ -585,7 +587,7 @@ cut_fields (FILE *stream)
           next_item (&field_idx);
         }
 
-      int prev_c = c;
+      prev_c = c;
 
       if (print_kth (field_idx))
         {
diff --git a/src/dd.c b/src/dd.c
index 59d6cd1..db91ab4 100644
--- a/src/dd.c
+++ b/src/dd.c
@@ -662,10 +662,11 @@ human_size (size_t n)
 static void
 alloc_ibuf (void)
 {
+  char *real_buf;
   if (ibuf)
     return;
 
-  char *real_buf = malloc (input_blocksize + INPUT_BLOCK_SLOP);
+  real_buf = malloc (input_blocksize + INPUT_BLOCK_SLOP);
   if (!real_buf)
     error (EXIT_FAILURE, 0,
            _("memory exhausted by input buffer of size %zu bytes (%s)"),
@@ -735,6 +736,7 @@ print_stats (void)
      | human_space_before_unit | human_SI | human_B);
   double delta_s;
   char const *bytes_per_second;
+  xtime_t now;
 
   if (status_flags & STATUS_NONE)
     return;
@@ -764,7 +766,7 @@ print_stats (void)
            w_bytes,
            human_readable (w_bytes, hbuf, human_opts, 1, 1));
 
-  xtime_t now = gethrxtime ();
+  now = gethrxtime ();
   if (start_time < now)
     {
       double XTIME_PRECISIONe0 = XTIME_PRECISION;
@@ -954,6 +956,7 @@ static bool
 invalidate_cache (int fd, off_t len)
 {
   int adv_ret = -1;
+  off_t pending;
 
   /* Minimize syscalls.  */
   off_t clen = cache_round (fd, len);
@@ -961,7 +964,7 @@ invalidate_cache (int fd, off_t len)
     return true; /* Don't advise this time.  */
   if (!len && !clen && max_records)
     return true; /* Nothing pending.  */
-  off_t pending = len ? cache_round (fd, 0) : 0;
+  pending = len ? cache_round (fd, 0) : 0;
 
   if (fd == STDIN_FILENO)
     {
@@ -1637,6 +1640,7 @@ skip (int fdesc, char const *file, uintmax_t records, size_t blocksize,
     }
   else
     {
+      char *buf;
       int lseek_errno = errno;
 
       /* The seek request may have failed above if it was too big
@@ -1671,7 +1675,6 @@ skip (int fdesc, char const *file, uintmax_t records, size_t blocksize,
         }
       /* else file_size && offset > OFF_T_MAX or file ! seekable */
 
-      char *buf;
       if (fdesc == STDIN_FILENO)
         {
           alloc_ibuf ();
@@ -2018,8 +2021,9 @@ dd_copy (void)
 
           if (conversions_mask & C_NOERROR)
             {
+              size_t bad_portion;
               print_stats ();
-              size_t bad_portion = input_blocksize - partread;
+              bad_portion = input_blocksize - partread;
 
               /* We already know this data is not cached,
                  but call this so that correct offsets are maintained.  */
diff --git a/src/df.c b/src/df.c
index 969670e..2417782 100644
--- a/src/df.c
+++ b/src/df.c
@@ -308,6 +308,8 @@ print_table (void)
       for (col = 0; col < ncolumns; col++)
         {
           char *cell = table[row][col];
+          int flags;
+          size_t width;
 
           /* Note the SOURCE_FIELD used to be displayed on it's own line
              if (!posix_format && mbswidth (cell) > 20), but that
@@ -316,11 +318,11 @@ print_table (void)
           if (col != 0)
             putchar (' ');
 
-          int flags = 0;
+          flags = 0;
           if (col == ncolumns - 1) /* The last one.  */
             flags = MBA_NO_RIGHT_PAD;
 
-          size_t width = columns[col]->width;
+          width = columns[col]->width;
           cell = ambsalign (cell, &width, columns[col]->align, flags);
           /* When ambsalign fails, output unaligned data.  */
           fputs (cell ? cell : table[row][col], stdout);
@@ -365,6 +367,8 @@ decode_output_arg (char const *arg)
   do
     {
       /* find next comma */
+      display_field_t field;
+      unsigned int i;
       char *comma = strchr (s, ',');
 
       /* If we found a comma, put a NUL in its place and advance.  */
@@ -372,8 +376,8 @@ decode_output_arg (char const *arg)
         *comma++ = 0;
 
       /* process S.  */
-      display_field_t field = -1;
-      for (unsigned int i = 0; i < ARRAY_CARDINALITY (field_data); i++)
+      field = -1;
+      for (i = 0; i < ARRAY_CARDINALITY (field_data); i++)
         {
           if (STREQ (field_data[i].arg, s))
             {
@@ -525,6 +529,7 @@ get_header (void)
           uintmax_t q1024 = output_block_size;
           bool divisible_by_1000;
           bool divisible_by_1024;
+          char *num;
 
           do
             {
@@ -540,7 +545,7 @@ get_header (void)
           if (! (opts & human_base_1024))
             opts |= human_B;
 
-          char *num = human_readable (output_block_size, buf, opts, 1, 1);
+          num = human_readable (output_block_size, buf, opts, 1, 1);
 
           /* Reset the header back to the default in OUTPUT_MODE.  */
           header = _("blocks");
@@ -676,12 +681,13 @@ filter_mount_list (void)
   mount_list = NULL;
   while (devlist_head)
     {
+      struct devlist *devlist;
       /* Add the mount entry.  */
       me = devlist_head->me;
       me->me_next = mount_list;
       mount_list = me;
       /* Free devlist entry and advance.  */
-      struct devlist *devlist = devlist_head->next;
+      devlist = devlist_head->next;
       free (devlist_head);
       devlist_head = devlist;
     }
@@ -847,6 +853,12 @@ get_dev (char const *disk, char const *mount_point, char const* file,
          const struct fs_usage *force_fsu,
          bool process_all)
 {
+  struct fs_usage fsu;
+  char *dev_name;
+  char *resolved_dev;
+  struct field_values_t block_values;
+  struct field_values_t inode_values;
+  size_t col;
   if (me_remote && show_local_fs)
     return;
 
@@ -863,7 +875,6 @@ get_dev (char const *disk, char const *mount_point, char const* file,
   if (!stat_file)
     stat_file = mount_point ? mount_point : disk;
 
-  struct fs_usage fsu;
   if (force_fsu)
     fsu = *force_fsu;
   else if (get_fs_usage (stat_file, disk, &fsu))
@@ -887,9 +898,8 @@ get_dev (char const *disk, char const *mount_point, char const* file,
   if (! file)
     file = "-";			/* unspecified */
 
-  char *dev_name = xstrdup (disk);
-  char *resolved_dev;
-
+  dev_name = xstrdup (disk);
+  
   /* On some systems, dev_name is a long-named symlink like
      /dev/disk/by-uuid/828fc648-9f30-43d8-a0b1-f7196a2edb66 pointing to a
      much shorter and more useful name like /dev/sda1.  It may also look
@@ -907,15 +917,12 @@ get_dev (char const *disk, char const *mount_point, char const* file,
   if (! fstype)
     fstype = "-";		/* unknown */
 
-  struct field_values_t block_values;
-  struct field_values_t inode_values;
   get_field_values (&block_values, &inode_values, &fsu);
 
   /* Add to grand total unless processing grand total line.  */
   if (print_grand_total && ! force_fsu)
     add_to_grand_total (&block_values, &inode_values);
 
-  size_t col;
   for (col = 0; col < ncolumns; col++)
     {
       char buf[LONGEST_HUMAN_READABLE + 2];
@@ -1057,12 +1064,13 @@ get_disk (char const *disk)
   struct mount_entry const *me;
   struct mount_entry const *best_match = NULL;
   char const *file = disk;
+  size_t best_match_len;
 
   char *resolved = canonicalize_file_name (disk);
   if (resolved && resolved[0] == '/')
     disk = resolved;
 
-  size_t best_match_len = SIZE_MAX;
+  best_match_len = SIZE_MAX;
   for (me = mount_list; me; me = me->me_next)
     {
       if (STREQ (disk, me->me_devname))
@@ -1305,6 +1313,8 @@ int
 main (int argc, char **argv)
 {
   struct stat *stats IF_LINT ( = 0);
+  bool posix_format;
+  const char *msg_mut_excl;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1326,9 +1336,9 @@ main (int argc, char **argv)
   grand_fsu.fsu_blocksize = 1;
 
   /* If true, use the POSIX output format.  */
-  bool posix_format = false;
+  posix_format = false;
 
-  const char *msg_mut_excl = _("options %s and %s are mutually exclusive");
+  msg_mut_excl = _("options %s and %s are mutually exclusive");
 
   while (true)
     {
@@ -1528,6 +1538,7 @@ main (int argc, char **argv)
          or when either of -a, -l, -t or -x is used with file name
          arguments.  Otherwise, merely give a warning and proceed.  */
       int status = 0;
+      const char *warning;
       if ( ! (optind < argc)
            || (show_all_fs
                || show_local_fs
@@ -1536,7 +1547,7 @@ main (int argc, char **argv)
         {
           status = EXIT_FAILURE;
         }
-      const char *warning = (status == 0 ? _("Warning: ") : "");
+      warning = (status == 0 ? _("Warning: ") : "");
       error (status, errno, "%s%s", warning,
              _("cannot read table of mounted file systems"));
     }
diff --git a/src/du.c b/src/du.c
index a265b10..9a44966 100644
--- a/src/du.c
+++ b/src/du.c
@@ -461,8 +461,9 @@ process_file (FTS *fts, FTSENT *ent)
 
           if (info == FTS_NSOK)
             {
+              FTSENT const *e;
               fts_set (fts, ent, FTS_AGAIN);
-              FTSENT const *e = fts_read (fts);
+              e = fts_read (fts);
               assert (e == ent);
               info = ent->fts_info;
             }
@@ -494,8 +495,9 @@ process_file (FTS *fts, FTSENT *ent)
              visit to the same directory.  */
           if (info == FTS_D)
             {
+              FTSENT const *e;
               fts_set (fts, ent, FTS_SKIP);
-              FTSENT const *e = fts_read (fts);
+              e = fts_read (fts);
               assert (e == ent);
             }
 
@@ -707,6 +709,8 @@ main (int argc, char **argv)
 
   /* If true, display only a total for each argument. */
   bool opt_summarize_only = false;
+  struct argv_iterator *ai;
+  static char *temp_argv[] = { NULL, NULL };
 
   cwd_only[0] = bad_cast (".");
   cwd_only[1] = NULL;
@@ -979,7 +983,6 @@ main (int argc, char **argv)
         }
     }
 
-  struct argv_iterator *ai;
   if (files_from)
     {
       /* When using --files0-from=F, you may not specify any files
@@ -1034,8 +1037,7 @@ main (int argc, char **argv)
     bit_flags |= FTS_TIGHT_CYCLE_CHECK;
 
   bit_flags |= symlink_deref_bits;
-  static char *temp_argv[] = { NULL, NULL };
-
+  
   while (true)
     {
       bool skip_file = false;
diff --git a/src/env.c b/src/env.c
index c31d165..ca9f4be 100644
--- a/src/env.c
+++ b/src/env.c
@@ -80,6 +80,7 @@ main (int argc, char **argv)
   int optc;
   bool ignore_environment = false;
   bool opt_nul_terminate_output = false;
+  char *eq;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -126,7 +127,6 @@ main (int argc, char **argv)
   if (optind < argc && STREQ (argv[optind], "-"))
     ++optind;
 
-  char *eq;
   while (optind < argc && (eq = strchr (argv[optind], '=')))
     {
       if (putenv (argv[optind]))
diff --git a/src/expr.c b/src/expr.c
index 9d21ca8..bb1d58c 100644
--- a/src/expr.c
+++ b/src/expr.c
@@ -115,8 +115,8 @@ mpz_tdiv_r (mpz_t r, mpz_t a0, mpz_t b0)
 static char *
 mpz_get_str (char const *str, int base, mpz_t z)
 {
-  (void) str; (void) base;
   char buf[INT_BUFSIZE_BOUND (intmax_t)];
+  (void) str; (void) base;
   return xstrdup (imaxtostr (z[0], buf));
 }
 static int
@@ -137,8 +137,8 @@ mpz_get_ui (mpz_t z)
 static int
 mpz_out_str (FILE *stream, int base, mpz_t z)
 {
-  (void) base;
   char buf[INT_BUFSIZE_BOUND (intmax_t)];
+  (void) base;
   return fputs (imaxtostr (z[0], buf), stream) != EOF;
 }
 #endif
@@ -291,6 +291,7 @@ int
 main (int argc, char **argv)
 {
   VALUE *v;
+  unsigned int u_argc;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -306,7 +307,7 @@ main (int argc, char **argv)
 
   /* The above handles --help and --version.
      Since there is no other invocation of getopt, handle '--' here.  */
-  unsigned int u_argc = argc;
+  u_argc = argc;
   if (1 < u_argc && STREQ (argv[1], "--"))
     {
       --u_argc;
diff --git a/src/factor.c b/src/factor.c
index 257a7ed..bd07cf6 100644
--- a/src/factor.c
+++ b/src/factor.c
@@ -281,12 +281,13 @@ static void factor (uintmax_t, uintmax_t, struct factors *);
 # define udiv_qrnnd(q, r, n1, n0, d)                                    \
   do {                                                                  \
     uintmax_t __d1, __d0, __q, __r1, __r0;                              \
+    unsigned int __i;													\
                                                                         \
     assert ((n1) < (d));                                                \
     __d1 = (d); __d0 = 0;                                               \
     __r1 = (n1); __r0 = (n0);                                           \
     __q = 0;                                                            \
-    for (unsigned int __i = W_TYPE_SIZE; __i > 0; __i--)                \
+    for (__i = W_TYPE_SIZE; __i > 0; __i--)                \
       {                                                                 \
         rsh2 (__d1, __d0, __d1, __d0, 1);                               \
         __q <<= 1;                                                      \
@@ -404,6 +405,7 @@ static uintmax_t
 mod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)
 {
   int cntd, cnta;
+  int cnt, i;
 
   assert (d1 != 0);
 
@@ -415,9 +417,9 @@ mod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)
 
   count_leading_zeros (cntd, d1);
   count_leading_zeros (cnta, a1);
-  int cnt = cntd - cnta;
+  cnt = cntd - cnta;
   lsh2 (d1, d0, d1, d0, cnt);
-  for (int i = 0; i < cnt; i++)
+  for (i = 0; i < cnt; i++)
     {
       if (ge2 (a1, a0, d1, d0))
         sub_ddmmss (a1, a0, a1, a0, d1, d0);
@@ -522,7 +524,8 @@ factor_insert_multiplicity (struct factors *factors,
 
   if (i < 0 || p[i] != prime)
     {
-      for (int j = nfactors - 1; j > i; j--)
+      int j;
+      for (j = nfactors - 1; j > i; j--)
         {
           p[j + 1] = p[j];
           e[j + 1] = e[j];
@@ -711,19 +714,20 @@ static bool flag_prove_primality = true;
 /* Number of Miller-Rabin tests to run when not proving primality. */
 #define MR_REPS 25
 
-#ifdef __GNUC__
-# define LIKELY(cond)    __builtin_expect ((cond), 1)
-# define UNLIKELY(cond)  __builtin_expect ((cond), 0)
-#else
+//#ifdef __GNUC__
+//# define LIKELY(cond)    __builtin_expect ((cond), 1)
+//# define UNLIKELY(cond)  __builtin_expect ((cond), 0)
+//#else
 # define LIKELY(cond)    (cond)
 # define UNLIKELY(cond)  (cond)
-#endif
+//#endif
 
 static void
 factor_insert_refind (struct factors *factors, uintmax_t p, unsigned int i,
                       unsigned int off)
 {
-  for (unsigned int j = 0; j < off; j++)
+  unsigned int j;
+  for (j = 0; j < off; j++)
     p += primes_diff[i + j];
   factor_insert (factors, p);
 }
@@ -765,6 +769,8 @@ static uintmax_t
 factor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,
                        struct factors *factors)
 {
+  uintmax_t p = 3;
+  unsigned int i;
   if (t0 % 2 == 0)
     {
       unsigned int cnt;
@@ -785,8 +791,6 @@ factor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,
       factor_insert_multiplicity (factors, 2, cnt);
     }
 
-  uintmax_t p = 3;
-  unsigned int i;
   for (i = 0; t1 > 0 && i < PRIMES_PTAB_ENTRIES; i++)
     {
       for (;;)
@@ -848,6 +852,7 @@ mp_factor_using_division (mpz_t t, struct mp_factors *factors)
 {
   mpz_t q;
   unsigned long int p;
+  unsigned int i;
 
   devmsg ("[trial division] ");
 
@@ -862,7 +867,7 @@ mp_factor_using_division (mpz_t t, struct mp_factors *factors)
     }
 
   p = 3;
-  for (unsigned int i = 1; i <= PRIMES_PTAB_ENTRIES;)
+  for (i = 1; i <= PRIMES_PTAB_ENTRIES;)
     {
       if (! mpz_divisible_ui_p (t, p))
         {
@@ -1132,11 +1137,12 @@ millerrabin (uintmax_t n, uintmax_t ni, uintmax_t b, uintmax_t q,
   uintmax_t y = powm (b, q, n, ni, one);
 
   uintmax_t nm1 = n - one;      /* -1, but in redc representation. */
+  unsigned int i;
 
   if (y == one || y == nm1)
     return true;
 
-  for (unsigned int i = 1; i < k; i++)
+  for (i = 1; i < k; i++)
     {
       y = mulredc (y, y, n, ni);
 
@@ -1153,6 +1159,7 @@ millerrabin2 (const uintmax_t *np, uintmax_t ni, const uintmax_t *bp,
               const uintmax_t *qp, unsigned int k, const uintmax_t *one)
 {
   uintmax_t y1, y0, nm1_1, nm1_0, r1m;
+  unsigned int i;
 
   y0 = powm2 (&r1m, bp, qp, np, ni, one);
   y1 = r1m;
@@ -1165,7 +1172,7 @@ millerrabin2 (const uintmax_t *np, uintmax_t ni, const uintmax_t *bp,
   if (y0 == nm1_0 && y1 == nm1_1)
     return true;
 
-  for (unsigned int i = 1; i < k; i++)
+  for (i = 1; i < k; i++)
     {
       y0 = mulredc2 (&r1m, y1, y0, y1, y0, np[1], np[0], ni);
       y1 = r1m;
@@ -1183,12 +1190,13 @@ static bool
 mp_millerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,
                 mpz_srcptr q, unsigned long int k)
 {
+  unsigned long int i;
   mpz_powm (y, x, q, n);
 
   if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)
     return true;
 
-  for (unsigned long int i = 1; i < k; i++)
+  for (i = 1; i < k; i++)
     {
       mpz_powm_ui (y, y, 2, n);
       if (mpz_cmp (y, nm1) == 0)
@@ -1209,6 +1217,8 @@ prime_p (uintmax_t n)
   bool is_prime;
   uintmax_t a_prim, one, ni;
   struct factors factors;
+  uintmax_t q, a;
+  unsigned int r;
 
   if (n <= 1)
     return false;
@@ -1218,11 +1228,11 @@ prime_p (uintmax_t n)
     return true;
 
   /* Precomputation for Miller-Rabin.  */
-  uintmax_t q = n - 1;
+  q = n - 1;
   for (k = 0; (q & 1) == 0; k++)
     q >>= 1;
 
-  uintmax_t a = 2;
+  a = 2;
   binv (ni, n);                 /* ni <- 1/n mod B */
   redcify (one, 1, n);
   addmod (a_prim, one, one, n); /* i.e., redcify a = 2 */
@@ -1239,12 +1249,13 @@ prime_p (uintmax_t n)
 
   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
      number composite.  */
-  for (unsigned int r = 0; r < PRIMES_PTAB_ENTRIES; r++)
+  for (r = 0; r < PRIMES_PTAB_ENTRIES; r++)
     {
       if (flag_prove_primality)
         {
+          unsigned int i;
           is_prime = true;
-          for (unsigned int i = 0; i < factors.nfactors && is_prime; i++)
+          for (i = 0; i < factors.nfactors && is_prime; i++)
             {
               is_prime
                 = powm (a_prim, (n - 1) / factors.p[i], n, ni, one) != one;
@@ -1294,6 +1305,8 @@ prime2_p (uintmax_t n1, uintmax_t n0)
   uintmax_t ni;
   unsigned int k;
   struct factors factors;
+  unsigned int r;
+  uintmax_t a;
 
   if (n1 == 0)
     return prime_p (n0);
@@ -1314,7 +1327,7 @@ prime2_p (uintmax_t n1, uintmax_t n0)
       rsh2 (q[1], q[0], nm1[1], nm1[0], k);
     }
 
-  uintmax_t a = 2;
+  a = 2;
   binv (ni, n0);
   redcify2 (one[1], one[0], 1, n1, n0);
   addmod2 (a_prim[1], a_prim[0], one[1], one[0], one[1], one[0], n1, n0);
@@ -1334,13 +1347,14 @@ prime2_p (uintmax_t n1, uintmax_t n0)
 
   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
      number composite.  */
-  for (unsigned int r = 0; r < PRIMES_PTAB_ENTRIES; r++)
+  for (r = 0; r < PRIMES_PTAB_ENTRIES; r++)
     {
       bool is_prime;
       uintmax_t e[2], y[2];
 
       if (flag_prove_primality)
         {
+          unsigned int i;
           is_prime = true;
           if (factors.plarge[1])
             {
@@ -1351,7 +1365,7 @@ prime2_p (uintmax_t n1, uintmax_t n0)
               y[0] = powm2 (&y[1], a_prim, e, na, ni, one);
               is_prime = (y[0] != one[0] || y[1] != one[1]);
             }
-          for (unsigned int i = 0; i < factors.nfactors && is_prime; i++)
+          for (i = 0; i < factors.nfactors && is_prime; i++)
             {
               /* FIXME: We always have the factor 2. Do we really need to
                  handle it here? We have done the same powering as part
@@ -1391,6 +1405,8 @@ mp_prime_p (mpz_t n)
   bool is_prime;
   mpz_t q, a, nm1, tmp;
   struct mp_factors factors;
+  unsigned long int k;
+  unsigned int r;
 
   if (mpz_cmp_ui (n, 1) <= 0)
     return false;
@@ -1405,7 +1421,7 @@ mp_prime_p (mpz_t n)
   mpz_sub_ui (nm1, n, 1);
 
   /* Find q and k, where q is odd and n = 1 + 2**k * q.  */
-  unsigned long int k = mpz_scan1 (nm1, 0);
+  k = mpz_scan1 (nm1, 0);
   mpz_tdiv_q_2exp (q, nm1, k);
 
   mpz_set_ui (a, 2);
@@ -1426,12 +1442,13 @@ mp_prime_p (mpz_t n)
 
   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
      number composite.  */
-  for (unsigned int r = 0; r < PRIMES_PTAB_ENTRIES; r++)
+  for (r = 0; r < PRIMES_PTAB_ENTRIES; r++)
     {
       if (flag_prove_primality)
         {
+          unsigned long int i;
           is_prime = true;
-          for (unsigned long int i = 0; i < factors.nfactors && is_prime; i++)
+          for (i = 0; i < factors.nfactors && is_prime; i++)
             {
               mpz_divexact (tmp, nm1, factors.p[i]);
               mpz_powm (tmp, a, tmp, n);
@@ -1490,6 +1507,7 @@ factor_using_pollard_rho (uintmax_t n, unsigned long int a,
 
       for (;;)
         {
+          unsigned long int i;
           do
             {
               x = mulredc (x, x, n, ni);
@@ -1510,7 +1528,7 @@ factor_using_pollard_rho (uintmax_t n, unsigned long int a,
           z = x;
           k = l;
           l = 2 * l;
-          for (unsigned long int i = 0; i < k; i++)
+          for (i = 0; i < k; i++)
             {
               x = mulredc (x, x, n, ni);
               addmod (x, x, a, n);
@@ -1568,6 +1586,7 @@ factor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,
 
       for (;;)
         {
+          unsigned long int i;
           do
             {
               x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);
@@ -1591,7 +1610,7 @@ factor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,
           z1 = x1; z0 = x0;
           k = l;
           l = 2 * l;
-          for (unsigned long int i = 0; i < k; i++)
+          for (i = 0; i < k; i++)
             {
               x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);
               x1 = r1m;
@@ -1669,6 +1688,8 @@ mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,
 {
   mpz_t x, z, y, P;
   mpz_t t, t2;
+  unsigned long long int k = 1;
+  unsigned long long int l = 1;
 
   devmsg ("[pollard-rho (%lu)] ", a);
 
@@ -1678,13 +1699,11 @@ mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,
   mpz_init_set_si (z, 2);
   mpz_init_set_ui (P, 1);
 
-  unsigned long long int k = 1;
-  unsigned long long int l = 1;
-
   while (mpz_cmp_ui (n, 1) != 0)
     {
       for (;;)
         {
+          unsigned long long int i;
           do
             {
               mpz_mul (t, x, x);
@@ -1708,7 +1727,7 @@ mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,
           mpz_set (z, x);
           k = l;
           l = 2 * l;
-          for (unsigned long long int i = 0; i < k; i++)
+          for (i = 0; i < k; i++)
             {
               mpz_mul (t, x, x);
               mpz_mod (x, t, n);
@@ -1975,13 +1994,14 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
     };
 
   const unsigned int *m;
+  uintmax_t sqrt_n;
 
   struct { uintmax_t Q; uintmax_t P; } queue[QUEUE_SIZE];
 
   if (n1 >= ((uintmax_t) 1 << (W_TYPE_SIZE - 2)))
     return false;
 
-  uintmax_t sqrt_n = isqrt2 (n1, n0);
+  sqrt_n = isqrt2 (n1, n0);
 
   if (n0 == sqrt_n * sqrt_n)
     {
@@ -1997,6 +2017,7 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
           else
             {
               struct factors f;
+              unsigned int i;
 
               f.nfactors = 0;
               if (!factor_using_squfof (0, sqrt_n, &f))
@@ -2005,7 +2026,7 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
                   factor_using_pollard_rho (sqrt_n, 1, &f);
                 }
               /* Duplicate the new factors */
-              for (unsigned int i = 0; i < f.nfactors; i++)
+              for (i = 0; i < f.nfactors; i++)
                 factor_insert_multiplicity (factors, f.p[i], 2*f.e[i]);
             }
           return true;
@@ -2108,7 +2129,9 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
               uintmax_t r = is_square (Q);
               if (r)
                 {
-                  for (unsigned int j = 0; j < qpos; j++)
+                  unsigned int j;
+                  uintmax_t hi, lo;
+                  for (j = 0; j < qpos; j++)
                     {
                       if (queue[j].Q == r)
                         {
@@ -2143,7 +2166,6 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
                      for the case D = 2N. */
                   /* Compute Q = (D - P*P) / Q1, but we need double
                      precision. */
-                  uintmax_t hi, lo;
                   umul_ppmm (hi, lo, P, P);
                   sub_ddmmss (hi, lo, Dh, Dl, hi, lo);
                   udiv_qrnnd (Q, rem, hi, lo, Q1);
@@ -2269,6 +2291,7 @@ strto2uintmax (uintmax_t *hip, uintmax_t *lop, const char *s)
   uintmax_t hi = 0, lo = 0;
 
   strtol_error err = LONGINT_INVALID;
+  const char *p;
 
   /* Skip initial spaces and '+'.  */
   for (;;)
@@ -2286,7 +2309,7 @@ strto2uintmax (uintmax_t *hip, uintmax_t *lop, const char *s)
     }
 
   /* Initial scan for invalid digits.  */
-  const char *p = s;
+  p = s;
   for (;;)
     {
       unsigned int c = *p++;
@@ -2362,14 +2385,15 @@ static void
 print_factors_single (uintmax_t t1, uintmax_t t0)
 {
   struct factors factors;
+  unsigned int j, k;
 
   print_uintmaxes (t1, t0);
   putchar (':');
 
   factor (t1, t0, &factors);
 
-  for (unsigned int j = 0; j < factors.nfactors; j++)
-    for (unsigned int k = 0; k < factors.e[j]; k++)
+  for (j = 0; j < factors.nfactors; j++)
+    for (k = 0; k < factors.e[j]; k++)
       {
         char buf[INT_BUFSIZE_BOUND (uintmax_t)];
         putchar (' ');
@@ -2393,6 +2417,7 @@ static bool
 print_factors (const char *input)
 {
   uintmax_t t1, t0;
+  unsigned int j, k;
 
   /* Try converting the number to one or two words.  If it fails, use GMP or
      print an error message.  The 2nd condition checks that the most
@@ -2430,8 +2455,8 @@ print_factors (const char *input)
   gmp_printf ("%Zd:", t);
   mp_factor (t, &factors);
 
-  for (unsigned int j = 0; j < factors.nfactors; j++)
-    for (unsigned int k = 0; k < factors.e[j]; k++)
+  for (j = 0; j < factors.nfactors; j++)
+    for (k = 0; k < factors.e[j]; k++)
       gmp_printf (" %Zd", factors.p[j]);
 
   mp_factor_clear (&factors);
@@ -2492,6 +2517,8 @@ do_stdin (void)
 int
 main (int argc, char **argv)
 {
+  int c;
+  bool ok;
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
   setlocale (LC_ALL, "");
@@ -2502,7 +2529,6 @@ main (int argc, char **argv)
 
   alg = ALG_POLLARD_RHO;        /* Default to Pollard rho */
 
-  int c;
   while ((c = getopt_long (argc, argv, "", long_options, NULL)) != -1)
     {
       switch (c)
@@ -2533,13 +2559,13 @@ main (int argc, char **argv)
     memset (q_freq, 0, sizeof (q_freq));
 #endif
 
-  bool ok;
   if (argc <= optind)
     ok = do_stdin ();
   else
     {
+      int i;
       ok = true;
-      for (int i = optind; i < argc; i++)
+      for (i = optind; i < argc; i++)
         if (! print_factors (argv[i]))
           ok = false;
     }
@@ -2548,8 +2574,9 @@ main (int argc, char **argv)
   if (alg == ALG_SQUFOF && q_freq[0] > 0)
     {
       double acc_f;
+      unsigned int i;
       printf ("q  freq.  cum. freq.(total: %d)\n", q_freq[0]);
-      for (unsigned int i = 1, acc_f = 0.0; i <= Q_FREQ_SIZE; i++)
+      for (i = 1, acc_f = 0.0; i <= Q_FREQ_SIZE; i++)
         {
           double f = (double) q_freq[i] / q_freq[0];
           acc_f += f;
diff --git a/src/getlimits.c b/src/getlimits.c
index 9914025..870889c 100644
--- a/src/getlimits.c
+++ b/src/getlimits.c
@@ -88,11 +88,12 @@ decimal_absval_add_one (char *buf)
   bool negative = (buf[1] == '-');
   char *absnum = buf + 1 + negative;
   char *p = absnum + strlen (absnum);
+  char *result;
   absnum[-1] = '0';
   while (*--p == '9')
     *p = '0';
   ++*p;
-  char *result = MIN (absnum, p);
+  result = MIN (absnum, p);
   if (negative)
     *--result = '-';
   return result;
diff --git a/src/group-list.c b/src/group-list.c
index d54b057..33097d3 100644
--- a/src/group-list.c
+++ b/src/group-list.c
@@ -105,6 +105,7 @@ print_group (gid_t gid, bool use_name)
 {
   struct group *grp = NULL;
   bool ok = true;
+  char *s;
 
   if (use_name)
     {
@@ -117,7 +118,7 @@ print_group (gid_t gid, bool use_name)
         }
     }
 
-  char *s = grp ? grp->gr_name : gidtostr (gid);
+  s = grp ? grp->gr_name : gidtostr (gid);
   fputs (s, stdout);
   return ok;
 }
diff --git a/src/id.c b/src/id.c
index 884fd16..59e8242 100644
--- a/src/id.c
+++ b/src/id.c
@@ -117,6 +117,7 @@ main (int argc, char **argv)
   bool smack_enabled = is_smack_enabled ();
   bool opt_zero = false;
   char *pw_name = NULL;
+  size_t n_ids;
 
   /* If true, output the list of all group IDs. -G */
   bool just_group_list = false;
@@ -126,6 +127,7 @@ main (int argc, char **argv)
   bool use_real = false;
   /* If true, output only the user ID(s). -u */
   bool just_user = false;
+  bool default_format;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -183,7 +185,7 @@ main (int argc, char **argv)
         }
     }
 
-  size_t n_ids = argc - optind;
+  n_ids = argc - optind;
   if (1 < n_ids)
     {
       error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));
@@ -197,7 +199,7 @@ main (int argc, char **argv)
   if (just_user + just_group + just_group_list + just_context > 1)
     error (EXIT_FAILURE, 0, _("cannot print \"only\" of more than one choice"));
 
-  bool default_format = (just_user + just_group + just_group_list
+  default_format = (just_user + just_group + just_group_list
                          + just_context == 0);
 
   if (default_format && (use_real || use_name))
@@ -345,6 +347,7 @@ static void
 print_user (uid_t uid)
 {
   struct passwd *pwd = NULL;
+  char *s;
 
   if (use_name)
     {
@@ -357,7 +360,7 @@ print_user (uid_t uid)
         }
     }
 
-  char *s = pwd ? pwd->pw_name : uidtostr (uid);
+  s = pwd ? pwd->pw_name : uidtostr (uid);
   fputs (s, stdout);
 }
 
diff --git a/src/install.c b/src/install.c
index 7076655..f1a2edd 100644
--- a/src/install.c
+++ b/src/install.c
@@ -197,8 +197,9 @@ need_copy (const char *src_name, const char *dest_name,
 
   if (owner_id == (uid_t) -1)
     {
+      uid_t ruid;
       errno = 0;
-      uid_t ruid = getuid ();
+      ruid = getuid ();
       if ((ruid == (uid_t) -1 && errno) || dest_sb.st_uid != ruid)
         return true;
     }
@@ -207,8 +208,9 @@ need_copy (const char *src_name, const char *dest_name,
 
   if (group_id == (uid_t) -1)
     {
+      gid_t rgid;
       errno = 0;
-      gid_t rgid = getgid ();
+      rgid = getgid ();
       if ((rgid == (uid_t) -1 && errno) || dest_sb.st_gid != rgid)
         return true;
     }
diff --git a/src/join.c b/src/join.c
index 1da618d..cb370ca 100644
--- a/src/join.c
+++ b/src/join.c
@@ -655,6 +655,8 @@ join (FILE *fp1, FILE *fp2)
   struct seq seq1, seq2;
   int diff;
   bool eof1, eof2;
+  struct line *line = NULL;
+  bool checktail = false;
 
   fadvise (fp1, FADVISE_SEQUENTIAL);
   fadvise (fp2, FADVISE_SEQUENTIAL);
@@ -763,9 +765,7 @@ join (FILE *fp1, FILE *fp2)
      tail ends of both inputs to verify that they are in order.  We
      skip the rest of the tail once we have issued a warning for that
      file, unless we actually need to print the unpairable lines.  */
-  struct line *line = NULL;
-  bool checktail = false;
-
+  
   if (check_input_order != CHECK_ORDER_DISABLED
       && !(issued_disorder_warning[0] && issued_disorder_warning[1]))
     checktail = true;
@@ -838,9 +838,10 @@ string_to_join_field (char const *str)
 {
   size_t result;
   unsigned long int val;
+  strtol_error s_err;
   verify (SIZE_MAX <= ULONG_MAX);
 
-  strtol_error s_err = xstrtoul (str, NULL, 10, &val, "");
+  s_err = xstrtoul (str, NULL, 10, &val, "");
   if (s_err == LONGINT_OVERFLOW || (s_err == LONGINT_OK && SIZE_MAX < val))
     val = SIZE_MAX;
   else if (s_err != LONGINT_OK || val == 0)
diff --git a/src/ls.c b/src/ls.c
index e7d1d93..6d60b4b 100644
--- a/src/ls.c
+++ b/src/ls.c
@@ -1048,13 +1048,14 @@ static size_t
 abmon_init (void)
 {
 #ifdef HAVE_NL_LANGINFO
-  required_mon_width = MAX_MON_WIDTH;
   size_t curr_max_width;
+  required_mon_width = MAX_MON_WIDTH;
   do
     {
+      int i;
       curr_max_width = required_mon_width;
       required_mon_width = 0;
-      for (int i = 0; i < 12; i++)
+      for (i = 0; i < 12; i++)
         {
           size_t width = curr_max_width;
 
@@ -2053,6 +2054,7 @@ decode_switches (int argc, char **argv)
                                     sizeof (*time_style_types));
           if (res < 0)
             {
+              char const *const *p;
               /* This whole block used to be a simple use of XARGMATCH.
                  but that didn't print the "posix-"-prefixed variants or
                  the "+"-prefixed format string option upon failure.  */
@@ -2064,7 +2066,7 @@ decode_switches (int argc, char **argv)
                  only because all four existing time_style_types values
                  are distinct.  */
               fputs (_("Valid arguments are:\n"), stderr);
-              char const *const *p = time_style_args;
+              p = time_style_args;
               while (*p)
                 fprintf (stderr, "  - [posix-]%s\n", *p++);
               fputs (_("  - +FORMAT (e.g., +%H:%M) for a 'date'-style"
@@ -2334,6 +2336,7 @@ parse_ls_color (void)
   int ind_no;			/* Indicator number */
   char label[3];		/* Indicator label */
   struct color_ext_type *ext;	/* Extension we are working on */
+  enum parse_state state;
 
   if ((p = getenv ("LS_COLORS")) == NULL || *p == '\0')
     return;
@@ -2347,7 +2350,7 @@ parse_ls_color (void)
      advance.  */
   buf = color_buf = xstrdup (p);
 
-  enum parse_state state = PS_START;
+  state = PS_START;
   while (true)
     {
       switch (state)
@@ -2812,13 +2815,14 @@ getfilecon_cache (char const *file, struct fileinfo *f, bool deref)
   /* st_dev of the most recently processed device for which we've
      found that [l]getfilecon fails indicating lack of support.  */
   static dev_t unsupported_device;
+  int r;
 
   if (f->stat.st_dev == unsupported_device)
     {
       errno = ENOTSUP;
       return -1;
     }
-  int r = 0;
+  r = 0;
 #ifdef HAVE_SMACK
   if (is_smack_enabled ())
     r = smack_new_label_from_path (file, "security.SMACK64", deref,
@@ -2842,6 +2846,7 @@ file_has_acl_cache (char const *file, struct fileinfo *f)
   /* st_dev of the most recently processed device for which we've
      found that file_has_acl fails indicating lack of support.  */
   static dev_t unsupported_device;
+  int n;
 
   if (f->stat.st_dev == unsupported_device)
     {
@@ -2852,7 +2857,7 @@ file_has_acl_cache (char const *file, struct fileinfo *f)
   /* Zero errno so that we can distinguish between two 0-returning cases:
      "has-ACL-support, but only a default ACL" and "no ACL support". */
   errno = 0;
-  int n = file_has_acl (file, &f->stat);
+  n = file_has_acl (file, &f->stat);
   if (n <= 0 && errno_unsupported (errno))
     unsupported_device = f->stat.st_dev;
   return n;
@@ -2867,6 +2872,7 @@ has_capability_cache (char const *file, struct fileinfo *f)
   /* st_dev of the most recently processed device for which we've
      found that has_capability fails indicating lack of support.  */
   static dev_t unsupported_device;
+  bool b;
 
   if (f->stat.st_dev == unsupported_device)
     {
@@ -2874,7 +2880,7 @@ has_capability_cache (char const *file, struct fileinfo *f)
       return 0;
     }
 
-  bool b = has_capability (file);
+  b = has_capability (file);
   if ( !b && errno_unsupported (errno))
     unsupported_device = f->stat.st_dev;
   return b;
@@ -3064,9 +3070,10 @@ gobble_file (char const *name, enum filetype type, ino_t inode,
           && (format == long_format || check_symlink_color))
         {
           struct stat linkstats;
+          char *linkname;
 
           get_link_name (absolute_name, f, command_line_arg);
-          char *linkname = make_link_name (absolute_name, f->linkname);
+          linkname = make_link_name (absolute_name, f->linkname);
 
           /* Avoid following symbolic links when possible, ie, when
              they won't be traced and when no indicator is needed.  */
@@ -3220,6 +3227,8 @@ get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
 static char *
 make_link_name (char const *name, char const *linkname)
 {
+  char *p;
+  size_t prefix_len;
   if (!linkname)
     return NULL;
 
@@ -3228,11 +3237,11 @@ make_link_name (char const *name, char const *linkname)
 
   /* The link is to a relative name.  Prepend any leading directory
      in 'name' to the link name.  */
-  size_t prefix_len = dir_len (name);
+  prefix_len = dir_len (name);
   if (prefix_len == 0)
     return xstrdup (linkname);
 
-  char *p = xmalloc (prefix_len + 1 + strlen (linkname) + 1);
+  p = xmalloc (prefix_len + 1 + strlen (linkname) + 1);
 
   /* PREFIX_LEN usually specifies a string not ending in slash.
      In that case, extend it by one, since the next byte *is* a slash.
@@ -3634,6 +3643,7 @@ align_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,
      the replacement is not done.  A malloc here slows ls down by 2%  */
   char rpl_fmt[sizeof (abmon[0]) + 100];
   const char *pb;
+  size_t ret;
   if (required_mon_width && (pb = strstr (fmt, "%b")))
     {
       if (strlen (fmt) < (sizeof (rpl_fmt) - sizeof (abmon[0]) + 2))
@@ -3646,7 +3656,7 @@ align_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,
           strcpy (pfmt, pb + 2);
         }
     }
-  size_t ret = nstrftime (buf, size, nfmt, tm, __utc, __ns);
+  ret = nstrftime (buf, size, nfmt, tm, __utc, __ns);
   return ret;
 }
 
@@ -3797,6 +3807,7 @@ print_long_format (const struct fileinfo *f)
   char *p;
   struct timespec when_timespec;
   struct tm *when_local;
+  size_t w;
 
   /* Compute the mode string, except remove the trailing space if no
      file in this directory has an ACL or SELinux security context.  */
@@ -3984,7 +3995,7 @@ print_long_format (const struct fileinfo *f)
     }
 
   DIRED_FPUTS (buf, stdout, p - buf);
-  size_t w = print_name_with_quoting (f, false, &dired_obstack, p - buf);
+  w = print_name_with_quoting (f, false, &dired_obstack, p - buf);
 
   if (f->filetype == symbolic_link)
     {
@@ -4172,6 +4183,7 @@ print_name_with_quoting (const struct fileinfo *f,
                          struct obstack *stack,
                          size_t start_col)
 {
+  size_t width;
   const char* name = symlink_target ? f->linkname : f->name;
 
   bool used_color_this_time
@@ -4182,7 +4194,7 @@ print_name_with_quoting (const struct fileinfo *f,
   if (stack)
     PUSH_CURRENT_DIRED_POS (stack);
 
-  size_t width = quote_name (stdout, name, filename_quoting_options, NULL);
+  width = quote_name (stdout, name, filename_quoting_options, NULL);
   dired_pos += width;
 
   if (stack)
@@ -4219,6 +4231,7 @@ prep_non_filename_text (void)
 static size_t
 print_file_name_and_frills (const struct fileinfo *f, size_t start_col)
 {
+  size_t width;
   char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
 
   set_normal_color ();
@@ -4236,7 +4249,7 @@ print_file_name_and_frills (const struct fileinfo *f, size_t start_col)
   if (print_scontext)
     printf ("%*s ", format == with_commas ? 0 : scontext_width, f->scontext);
 
-  size_t width = print_name_with_quoting (f, false, NULL, start_col);
+  width = print_name_with_quoting (f, false, NULL, start_col);
 
   if (indicator_style != none)
     width += print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
diff --git a/src/md5sum.c b/src/md5sum.c
index ee2bbb7..b4ad49f 100644
--- a/src/md5sum.c
+++ b/src/md5sum.c
@@ -230,8 +230,9 @@ static char *
 filename_unescape (char *s, size_t s_len)
 {
   char *dst = s;
+  size_t i;
 
-  for (size_t i = 0; i < s_len; i++)
+  for (i = 0; i < s_len; i++)
     {
       switch (s[i])
         {
@@ -835,6 +836,7 @@ main (int argc, char **argv)
                  containing '\\' characters, we decided to not simplify the
                  output in this case.  */
               bool needs_escape = strchr (file, '\\') || strchr (file, '\n');
+              size_t i;
 
               if (prefix_tag)
                 {
@@ -847,7 +849,6 @@ main (int argc, char **argv)
                   fputs (") = ", stdout);
                 }
 
-              size_t i;
 
               /* Output a leading backslash if the file name contains
                  a newline or backslash.  */
diff --git a/src/mkdir.c b/src/mkdir.c
index adc2930..79e4602 100644
--- a/src/mkdir.c
+++ b/src/mkdir.c
@@ -117,17 +117,19 @@ static int
 make_ancestor (char const *dir, char const *component, void *options)
 {
   struct mkdir_options const *o = options;
-
+  mode_t user_wx = S_IWUSR | S_IXUSR;
+  bool self_denying_umask;
+  int r;
+  
   if (o->set_security_context && defaultcon (dir, S_IFDIR) < 0
       && ! ignorable_ctx_err (errno))
     error (0, errno, _("failed to set default creation context for %s"),
            quote (dir));
 
-  mode_t user_wx = S_IWUSR | S_IXUSR;
-  bool self_denying_umask = (o->umask_value & user_wx) != 0;
+  self_denying_umask = (o->umask_value & user_wx) != 0;
   if (self_denying_umask)
     umask (o->umask_value & ~user_wx);
-  int r = mkdir (component, S_IRWXUGO);
+  r = mkdir (component, S_IRWXUGO);
   if (self_denying_umask)
     {
       int mkdir_errno = errno;
@@ -148,6 +150,7 @@ process_dir (char *dir, struct savewd *wd, void *options)
 {
   struct mkdir_options const *o = options;
   bool set_defaultcon = false;
+  int ret;
 
   /* If possible set context before DIR created.  */
   if (o->set_security_context)
@@ -169,7 +172,7 @@ process_dir (char *dir, struct savewd *wd, void *options)
                quote (dir));
     }
 
-  int ret = (make_dir_parents (dir, wd, o->make_ancestor_function, options,
+  ret = (make_dir_parents (dir, wd, o->make_ancestor_function, options,
                                o->mode, announce_mkdir,
                                o->mode_bits, (uid_t) -1, (gid_t) -1, true)
              ? EXIT_SUCCESS
diff --git a/src/nproc.c b/src/nproc.c
index 5bd6610..cc980e2 100644
--- a/src/nproc.c
+++ b/src/nproc.c
@@ -76,6 +76,7 @@ int
 main (int argc, char **argv)
 {
   unsigned long nproc, ignore = 0;
+  enum nproc_query mode = NPROC_CURRENT_OVERRIDABLE;
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
   setlocale (LC_ALL, "");
@@ -84,8 +85,7 @@ main (int argc, char **argv)
 
   atexit (close_stdout);
 
-  enum nproc_query mode = NPROC_CURRENT_OVERRIDABLE;
-
+  
   while (1)
     {
       int c = getopt_long (argc, argv, "", longopts, NULL);
diff --git a/src/numfmt.c b/src/numfmt.c
index 339c79f..fc67ade 100644
--- a/src/numfmt.c
+++ b/src/numfmt.c
@@ -538,9 +538,11 @@ simple_strtod_float (const char *input_str,
       char *ptr2;
       long double val_frac = 0;
       bool neg_frac;
+      size_t exponent;
+      enum simple_strtod_error e2;
 
       (*endptr) += decimal_point_length;
-      enum simple_strtod_error e2 =
+      e2 =
         simple_strtod_int (*endptr, &ptr2, &val_frac, &neg_frac);
       if (e2 != SSE_OK && e2 != SSE_OK_PRECISION_LOSS)
         return e2;
@@ -550,7 +552,7 @@ simple_strtod_float (const char *input_str,
         return SSE_INVALID_NUMBER;
 
       /* number of digits in the fractions.  */
-      size_t exponent = ptr2 - *endptr;
+      exponent = ptr2 - *endptr;
 
       val_frac = ((long double) val_frac) / powerld (10, exponent);
 
@@ -597,12 +599,14 @@ simple_strtod_human (const char *input_str,
   int power = 0;
   /* 'scale_auto' is checked below.  */
   int scale_base = default_scale_base (allowed_scaling);
+  enum simple_strtod_error e;
+  long double multiplier;
 
   devmsg ("simple_strtod_human:\n  input string: %s\n  "
           "locale decimal-point: %s\n",
           quote_n (0, input_str), quote_n (1, decimal_point));
 
-  enum simple_strtod_error e =
+  e =
     simple_strtod_float (input_str, endptr, value, precision);
   if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)
     return e;
@@ -648,7 +652,7 @@ simple_strtod_human (const char *input_str,
         return SSE_MISSING_I_SUFFIX;
     }
 
-  long double multiplier = powerld (scale_base, power);
+  multiplier = powerld (scale_base, power);
 
   devmsg ("  suffix power=%d^%d = %Lf\n", scale_base, power, multiplier);
 
@@ -705,10 +709,15 @@ double_to_human (long double val, int precision,
                  char *buf, size_t buf_size,
                  enum scale_type scale, int group, enum round_type round)
 {
+  double scale_base;
+  unsigned int power;
+  int ten_or_less = 0;
+  int show_decimal_point;
   devmsg ("double_to_human:\n");
 
   if (scale == scale_none)
     {
+      int i;
       val *= powerld (10, precision);
       val = simple_round (val, round);
       val /= powerld (10, precision);
@@ -717,7 +726,7 @@ double_to_human (long double val, int precision,
               "  no scaling, returning (grouped) value: %'.*Lf\n" :
               "  no scaling, returning value: %.*Lf\n", precision, val);
 
-      int i = snprintf (buf, buf_size, (group) ? "%'.*Lf" : "%.*Lf",
+      i = snprintf (buf, buf_size, (group) ? "%'.*Lf" : "%.*Lf",
                         precision, val);
       if (i < 0 || i >= (int) buf_size)
         error (EXIT_FAILURE, 0,
@@ -726,15 +735,14 @@ double_to_human (long double val, int precision,
     }
 
   /* Scaling requested by user. */
-  double scale_base = default_scale_base (scale);
+  scale_base = default_scale_base (scale);
 
   /* Normalize val to scale. */
-  unsigned int power = 0;
+  power = 0;
   val = expld (val, scale_base, &power);
   devmsg ("  scaled value to %Lf * %0.f ^ %d\n", val, scale_base, power);
 
   /* Perform rounding. */
-  int ten_or_less = 0;
   if (absld (val) < 10)
     {
       /* for values less than 10, we allow one decimal-point digit,
@@ -756,7 +764,7 @@ double_to_human (long double val, int precision,
 
   /* should "7.0" be printed as "7" ?
      if removing the ".0" is preferred, enable the fourth condition.  */
-  int show_decimal_point = (val != 0) && (absld (val) < 10) && (power > 0);
+  show_decimal_point = (val != 0) && (absld (val) < 10) && (power > 0);
   /* && (absld (val) > simple_round_floor (val))) */
 
   devmsg ("  after rounding, value=%Lf * %0.f ^ %d\n", val, scale_base, power);
@@ -1146,6 +1154,10 @@ print_padded_number (void)
 static int
 process_suffixed_number (char *text, long double *result, size_t *precision)
 {
+  char *p;
+  long double val = 0;
+  enum simple_strtod_error e;
+  const unsigned int skip_count;
   if (suffix && strlen (text) > strlen (suffix))
     {
       char *possible_suffix = text + strlen (text) - strlen (suffix);
@@ -1161,10 +1173,10 @@ process_suffixed_number (char *text, long double *result, size_t *precision)
     }
 
   /* Skip white space - always.  */
-  char *p = text;
+  p = text;
   while (*p && isblank (*p))
     ++p;
-  const unsigned int skip_count = text - p;
+  skip_count = text - p;
 
   /* setup auto-padding.  */
   if (auto_padding)
@@ -1181,8 +1193,7 @@ process_suffixed_number (char *text, long double *result, size_t *precision)
      devmsg ("setting Auto-Padding to %ld characters\n", padding_width);
     }
 
-  long double val = 0;
-  enum simple_strtod_error e = parse_human_number (p, &val, precision);
+  e = parse_human_number (p, &val, precision);
   if (e == SSE_OK_PRECISION_LOSS && debug)
     error (0, 0, _("large input value %s: possible precision loss"),
            quote (p));
@@ -1339,6 +1350,7 @@ int
 main (int argc, char **argv)
 {
   int valid_numbers = 1;
+  int exit_status;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1527,7 +1539,7 @@ main (int argc, char **argv)
   if (debug && !valid_numbers)
     error (0, 0, _("failed to convert some of the input numbers"));
 
-  int exit_status = EXIT_SUCCESS;
+  exit_status = EXIT_SUCCESS;
   if (!valid_numbers && _invalid != inval_warn && _invalid != inval_ignore)
     exit_status = EXIT_CONVERSION_WARNINGS;
 
diff --git a/src/realpath.c b/src/realpath.c
index 233b98f..d76ef52 100644
--- a/src/realpath.c
+++ b/src/realpath.c
@@ -101,8 +101,9 @@ realpath_canon (const char *fname, int can_mode)
   char *can_fname = canonicalize_filename_mode (fname, can_mode);
   if (logical && can_fname)  /* canonicalize again to resolve symlinks.  */
     {
+      char *can_fname2;
       can_mode &= ~CAN_NOLINKS;
-      char *can_fname2 = canonicalize_filename_mode (can_fname, can_mode);
+      can_fname2 = canonicalize_filename_mode (can_fname, can_mode);
       free (can_fname);
       return can_fname2;
     }
@@ -176,6 +177,7 @@ main (int argc, char **argv)
   int can_mode = CAN_ALL_BUT_LAST;
   const char *relative_to = NULL;
   const char *relative_base = NULL;
+  bool need_dir;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -240,7 +242,7 @@ main (int argc, char **argv)
   if (relative_base && !relative_to)
     relative_to = relative_base;
 
-  bool need_dir = (can_mode & CAN_MODE_MASK) == CAN_EXISTING;
+  need_dir = (can_mode & CAN_MODE_MASK) == CAN_EXISTING;
   if (relative_to)
     {
       can_relative_to = realpath_canon (relative_to, can_mode);
diff --git a/src/relpath.c b/src/relpath.c
index 5a93afe..1042b90 100644
--- a/src/relpath.c
+++ b/src/relpath.c
@@ -88,14 +88,16 @@ bool
 relpath (const char *can_fname, const char *can_reldir, char *buf, size_t len)
 {
   bool buf_err = false;
+  const char *relto_suffix;
+  const char *fname_suffix;
 
   /* Skip the prefix common to --relative-to and path.  */
   int common_index = path_common_prefix (can_reldir, can_fname);
   if (!common_index)
     return false;
 
-  const char *relto_suffix = can_reldir + common_index;
-  const char *fname_suffix = can_fname + common_index;
+  relto_suffix = can_reldir + common_index;
+  fname_suffix = can_fname + common_index;
 
   /* Skip over extraneous '/'.  */
   if (*relto_suffix == '/')
diff --git a/src/remove.c b/src/remove.c
index 3d386cf..eefbcbb 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -180,17 +180,20 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
   int fd_cwd = fts->fts_cwd_fd;
   char const *full_name = ent->fts_path;
   char const *filename = ent->fts_accpath;
+  struct stat st;
+  struct stat *sbuf;
+  int dirent_type;
+  int write_protected = 0;
+  bool is_empty = false;
+  int wp_errno = 0;
   if (is_empty_p)
     *is_empty_p = T_UNKNOWN;
 
-  struct stat st;
-  struct stat *sbuf = &st;
+  sbuf = &st;
   cache_stat_init (sbuf);
 
-  int dirent_type = is_dir ? DT_DIR : DT_UNKNOWN;
-  int write_protected = 0;
-
-  bool is_empty = false;
+  dirent_type = is_dir ? DT_DIR : DT_UNKNOWN;
+  
   if (is_empty_p)
     {
       is_empty = is_empty_dir (fd_cwd, filename);
@@ -206,7 +209,6 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
   if (x->interactive == RMI_NEVER)
     return RM_OK;
 
-  int wp_errno = 0;
   if (!x->ignore_missing_files
       && ((x->interactive == RMI_ALWAYS) || x->stdin_tty)
       && dirent_type != DT_LNK)
@@ -217,6 +219,7 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
 
   if (write_protected || x->interactive == RMI_ALWAYS)
     {
+      char const *quoted_name;
       if (0 <= write_protected && dirent_type == DT_UNKNOWN)
         {
           if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) == 0)
@@ -256,7 +259,7 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
             break;
           }
 
-      char const *quoted_name = quote (full_name);
+      quoted_name = quote (full_name);
 
       if (write_protected < 0)
         {
@@ -492,6 +495,8 @@ rm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)
     case FTS_NSOK:		/* e.g., dangling symlink */
     case FTS_DEFAULT:		/* none of the above */
       {
+        bool is_dir;
+        enum RM_status s;
         /* With --one-file-system, do not attempt to remove a mount point.
            fts' FTS_XDEV ensures that we don't process any entries under
            the mount point.  */
@@ -506,8 +511,8 @@ rm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)
             return RM_ERROR;
           }
 
-        bool is_dir = ent->fts_info == FTS_DP || ent->fts_info == FTS_DNR;
-        enum RM_status s = prompt (fts, ent, is_dir, x, PA_REMOVE_DIR, NULL);
+        is_dir = ent->fts_info == FTS_DP || ent->fts_info == FTS_DNR;
+        s = prompt (fts, ent, is_dir, x, PA_REMOVE_DIR, NULL);
         if (s != RM_OK)
           return s;
         return excise (fts, ent, x, is_dir);
@@ -548,15 +553,17 @@ rm (char *const *file, struct rm_options const *x)
       int bit_flags = (FTS_CWDFD
                        | FTS_NOSTAT
                        | FTS_PHYSICAL);
+      FTS *fts;
 
       if (x->one_file_system)
         bit_flags |= FTS_XDEV;
 
-      FTS *fts = xfts_open (file, bit_flags, NULL);
+      fts = xfts_open (file, bit_flags, NULL);
 
       while (1)
         {
           FTSENT *ent;
+          enum RM_status s;
 
           ent = fts_read (fts);
           if (ent == NULL)
@@ -569,7 +576,7 @@ rm (char *const *file, struct rm_options const *x)
               break;
             }
 
-          enum RM_status s = rm_fts (fts, ent, x);
+          s = rm_fts (fts, ent, x);
 
           assert (VALID_STATUS (s));
           UPDATE_STATUS (rm_status, s);
diff --git a/src/rm.c b/src/rm.c
index 7a51eef..27cef70 100644
--- a/src/rm.c
+++ b/src/rm.c
@@ -209,6 +209,9 @@ main (int argc, char **argv)
   struct rm_options x;
   bool prompt_once = false;
   int c;
+  size_t n_files;
+  char **file;
+  enum RM_status status;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -332,8 +335,8 @@ main (int argc, char **argv)
                quote ("/"));
     }
 
-  size_t n_files = argc - optind;
-  char **file =  argv + optind;
+  n_files = argc - optind;
+  file =  argv + optind;
 
   if (prompt_once && (x.recursive || 3 < n_files))
     {
@@ -350,7 +353,7 @@ main (int argc, char **argv)
         exit (EXIT_SUCCESS);
     }
 
-  enum RM_status status = rm (file, &x);
+  status = rm (file, &x);
   assert (VALID_STATUS (status));
   exit (status == RM_ERROR ? EXIT_FAILURE : EXIT_SUCCESS);
 }
diff --git a/src/seq.c b/src/seq.c
index 35dfc8b..0cf99bb 100644
--- a/src/seq.c
+++ b/src/seq.c
@@ -153,6 +153,7 @@ scan_arg (const char *arg)
   if (! arg[strcspn (arg, "xX")] && isfinite (ret.value))
     {
       char const *decimal_point = strchr (arg, '.');
+      char const *e;
       if (! decimal_point)
         ret.precision = 0;
       else
@@ -165,7 +166,7 @@ scan_arg (const char *arg)
                         : (decimal_point == arg                /* .#  -> 0.# */
                            || ! ISDIGIT (decimal_point[-1]))); /* -.# -> 0.# */
         }
-      char const *e = strchr (arg, 'e');
+      e = strchr (arg, 'e');
       if (! e)
         e = strchr (arg, 'E');
       if (e)
@@ -330,6 +331,7 @@ get_default_format (operand first, operand step, operand last)
     {
       if (equal_width)
         {
+          size_t width;
           /* increase first_width by any increased precision in step */
           size_t first_width = first.width + (prec - first.precision);
           /* adjust last_width to use precision from first/step */
@@ -340,7 +342,7 @@ get_default_format (operand first, operand step, operand last)
             last_width++;  /* include space for '.' */
           if (first.precision == 0 && prec)
             first_width++;  /* include space for '.' */
-          size_t width = MAX (first_width, last_width);
+          width = MAX (first_width, last_width);
           if (width <= INT_MAX)
             {
               int w = width;
@@ -411,20 +413,23 @@ trim_leading_zeros (char const *s)
 static bool
 seq_fast (char const *a, char const *b)
 {
+  size_t p_len, q_len, n;
+  char *p0, *p, *q0, *q;
+  bool ok;
   /* Skip past any leading 0's.  Without this, our naive cmp
      function would declare 000 to be larger than 99.  */
   a = trim_leading_zeros (a);
   b = trim_leading_zeros (b);
 
-  size_t p_len = strlen (a);
-  size_t q_len = strlen (b);
-  size_t n = MAX (p_len, q_len);
-  char *p0 = xmalloc (n + 1);
-  char *p = memcpy (p0 + n - p_len, a, p_len + 1);
-  char *q0 = xmalloc (n + 1);
-  char *q = memcpy (q0 + n - q_len, b, q_len + 1);
+  p_len = strlen (a);
+  q_len = strlen (b);
+  n = MAX (p_len, q_len);
+  p0 = xmalloc (n + 1);
+  p = memcpy (p0 + n - p_len, a, p_len + 1);
+  q0 = xmalloc (n + 1);
+  q = memcpy (q0 + n - q_len, b, q_len + 1);
 
-  bool ok = cmp (p, p_len, q, q_len) <= 0;
+  ok = cmp (p, p_len, q, q_len) <= 0;
   if (ok)
     {
       /* Buffer at least this many numbers per fwrite call.
@@ -485,6 +490,7 @@ main (int argc, char **argv)
 
   /* The printf(3) format used for output.  */
   char const *format_str = NULL;
+  unsigned int n_args;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -536,7 +542,7 @@ main (int argc, char **argv)
         }
     }
 
-  unsigned int n_args = argc - optind;
+  n_args = argc - optind;
   if (n_args < 1)
     {
       error (0, 0, _("missing operand"));
diff --git a/src/shred.c b/src/shred.c
index 6f5b4da..701de0e 100644
--- a/src/shred.c
+++ b/src/shred.c
@@ -251,11 +251,12 @@ to be recovered later.\n\
 static bool
 periodic_pattern (int type)
 {
+  unsigned char r[3];
+  unsigned int bits;
   if (type <= 0)
     return false;
 
-  unsigned char r[3];
-  unsigned int bits = type & 0xfff;
+  bits = type & 0xfff;
 
   bits |= bits << 12;
   r[0] = (bits >> 4) & 255;
@@ -400,33 +401,38 @@ dopass (int fd, char const *qname, off_t *sizep, int type,
   size_t lim;			/* Amount of data to try writing */
   size_t soff;			/* Offset into buffer for next write */
   ssize_t ssize;		/* Return value from write */
+  size_t page_size;
+  size_t output_size;
+  void *fill_pattern_mem;
+  unsigned char *pbuf;
+
+  char pass_string[PASS_NAME_SIZE];	/* Name of current pass */
+  bool write_error = false;
+  bool other_error = false;
+  bool tried_without_directio = false;
+
+  /* Printable previous offset into the file */
+  char previous_offset_buf[LONGEST_HUMAN_READABLE + 1];
+  char const *previous_human_offset IF_LINT ( = 0);
 
   /* Do nothing for --size=0 or regular empty files with --exact.  */
   if (size == 0)
     return 0;
 
   /* Fill pattern buffer.  Aligning it to a page so we can do direct I/O.  */
-  size_t page_size = getpagesize ();
+  page_size = getpagesize ();
 #define PERIODIC_OUTPUT_SIZE (60 * 1024)
 #define NONPERIODIC_OUTPUT_SIZE (64 * 1024)
   verify (PERIODIC_OUTPUT_SIZE % 3 == 0);
-  size_t output_size = periodic_pattern (type)
+  output_size = periodic_pattern (type)
                        ? PERIODIC_OUTPUT_SIZE : NONPERIODIC_OUTPUT_SIZE;
 #define PAGE_ALIGN_SLOP (page_size - 1)                /* So directio works */
 #define FILLPATTERN_SIZE (((output_size + 2) / 3) * 3) /* Multiple of 3 */
 #define PATTERNBUF_SIZE (PAGE_ALIGN_SLOP + FILLPATTERN_SIZE)
-  void *fill_pattern_mem = xmalloc (PATTERNBUF_SIZE);
-  unsigned char *pbuf = ptr_align (fill_pattern_mem, page_size);
-
-  char pass_string[PASS_NAME_SIZE];	/* Name of current pass */
-  bool write_error = false;
-  bool other_error = false;
-  bool tried_without_directio = false;
-
-  /* Printable previous offset into the file */
-  char previous_offset_buf[LONGEST_HUMAN_READABLE + 1];
-  char const *previous_human_offset IF_LINT ( = 0);
+  fill_pattern_mem = xmalloc (PATTERNBUF_SIZE);
+  pbuf = ptr_align (fill_pattern_mem, page_size);
 
+  
   if (lseek (fd, 0, SEEK_SET) == -1)
     {
       error (0, errno, _("%s: cannot rewind"), qname);
@@ -457,6 +463,7 @@ dopass (int fd, char const *qname, off_t *sizep, int type,
   offset = 0;
   while (true)
     {
+      bool done;
       /* How much to write this time? */
       lim = output_size;
       if (0 <= size && size - offset < output_size)
@@ -536,7 +543,7 @@ dopass (int fd, char const *qname, off_t *sizep, int type,
 
       offset += soff;
 
-      bool done = offset == size;
+      done = offset == size;
 
       /* Time to print progress? */
       if (n && ((done && *previous_human_offset)
diff --git a/src/shuf.c b/src/shuf.c
index 456140f..e1bbe5d 100644
--- a/src/shuf.c
+++ b/src/shuf.c
@@ -150,6 +150,7 @@ static off_t
 input_size (void)
 {
   off_t file_size;
+  off_t input_offset;
 
   struct stat stat_buf;
   if (fstat (STDIN_FILENO, &stat_buf) != 0)
@@ -159,7 +160,7 @@ input_size (void)
   else
     return OFF_T_MAX;
 
-  off_t input_offset = lseek (STDIN_FILENO, 0, SEEK_CUR);
+  input_offset = lseek (STDIN_FILENO, 0, SEEK_CUR);
   if (input_offset < 0)
     return OFF_T_MAX;
 
diff --git a/src/sort.c b/src/sort.c
index 573d6cb..392da25 100644
--- a/src/sort.c
+++ b/src/sort.c
@@ -764,9 +764,10 @@ static bool
 delete_proc (pid_t pid)
 {
   struct tempnode test;
+  struct tempnode *node;
 
   test.pid = pid;
-  struct tempnode *node = hash_delete (proctab, &test);
+  node = hash_delete (proctab, &test);
   if (! node)
     return false;
   node->state = REAPED;
@@ -1162,6 +1163,7 @@ open_temp (struct tempnode *temp)
 {
   int tempfd, pipefds[2];
   FILE *fp = NULL;
+  pid_t child;
 
   if (temp->state == UNREAPED)
     wait_proc (temp->pid);
@@ -1170,7 +1172,7 @@ open_temp (struct tempnode *temp)
   if (tempfd < 0)
     return NULL;
 
-  pid_t child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);
+  child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);
 
   switch (child)
     {
@@ -1446,6 +1448,7 @@ specify_nthreads (int oi, char c, char const *s)
 static size_t
 default_sort_size (void)
 {
+  double avail, total, mem;
   /* Let SIZE be MEM, but no more than the maximum object size,
      total memory, or system resource limits.  Don't bother to check
      for values like RLIM_INFINITY since in practice they are not much
@@ -1472,9 +1475,9 @@ default_sort_size (void)
 
   /* Let MEM be available memory or 1/8 of total memory, whichever
      is greater.  */
-  double avail = physmem_available ();
-  double total = physmem_total ();
-  double mem = MAX (avail, total / 8);
+  avail = physmem_available ();
+  total = physmem_total ();
+  mem = MAX (avail, total / 8);
 
   /* Leave a 1/4 margin for physical memory.  */
   if (total * 0.75 < size)
@@ -1931,12 +1934,13 @@ find_unit_order (char const *number)
 static int
 human_numcompare (char const *a, char const *b)
 {
+  int diff;
   while (blanks[to_uchar (*a)])
     a++;
   while (blanks[to_uchar (*b)])
     b++;
 
-  int diff = find_unit_order (a) - find_unit_order (b);
+  diff = find_unit_order (a) - find_unit_order (b);
   return (diff ? diff : strnumcmp (a, b, decimal_point, thousands_sep));
 }
 
@@ -1963,10 +1967,10 @@ static int
 nan_compare (char const *sa, char const *sb)
 {
   long_double a;
+  long_double b;
   memset (&a, 0, sizeof a);
   a = strtold (sa, NULL);
 
-  long_double b;
   memset (&b, 0, sizeof b);
   b = strtold (sb, NULL);
 
@@ -2068,9 +2072,9 @@ random_md5_state_init (char const *random_source)
 static size_t
 xstrxfrm (char *restrict dest, char const *restrict src, size_t destsize)
 {
-  errno = 0;
   size_t translated_size = strxfrm (dest, src, destsize);
-
+  errno = 0;
+  
   if (errno)
     {
       error (0, errno, _("string transformation failed"));
@@ -2103,6 +2107,7 @@ compare_random (char *restrict texta, size_t lena,
   void *allocated = NULL;
   uint32_t dig[2][MD5_DIGEST_SIZE / sizeof (uint32_t)];
   struct md5_ctx s[2];
+  int diff;
   s[0] = s[1] = random_md5_state;
 
   if (hard_LC_COLLATE)
@@ -2128,6 +2133,8 @@ compare_random (char *restrict texta, size_t lena,
              twice on typical implementations.  Don't worry about
              size_t overflow, as the guess need not be correct.  */
           size_t guess_bufsize = 3 * (lena + lenb) + 2;
+          size_t sizea, sizeb;
+          bool a_fits;
           if (bufsize < guess_bufsize)
             {
               bufsize = MAX (guess_bufsize, bufsize * 3 / 2);
@@ -2140,10 +2147,10 @@ compare_random (char *restrict texta, size_t lena,
                 }
             }
 
-          size_t sizea =
+          sizea =
             (texta < lima ? xstrxfrm (buf, texta, bufsize) + 1 : 0);
-          bool a_fits = sizea <= bufsize;
-          size_t sizeb =
+          a_fits = sizea <= bufsize;
+          sizeb =
             (textb < limb
              ? (xstrxfrm ((a_fits ? buf + sizea : NULL), textb,
                           (a_fits ? bufsize - sizea : 0))
@@ -2196,7 +2203,7 @@ compare_random (char *restrict texta, size_t lena,
   /* Compute and compare the checksums.  */
   md5_process_bytes (texta, lena, &s[0]); md5_finish_ctx (&s[0], dig[0]);
   md5_process_bytes (textb, lenb, &s[1]); md5_finish_ctx (&s[1], dig[1]);
-  int diff = memcmp (dig[0], dig[1], sizeof dig[0]);
+  diff = memcmp (dig[0], dig[1], sizeof dig[0]);
 
   /* Fall back on the tiebreaker if the checksums collide.  */
   if (! diff)
@@ -2267,6 +2274,7 @@ debug_key (struct line const *line, struct keyfield const *key)
   char *text = line->text;
   char *beg = text;
   char *lim = text + line->length - 1;
+  size_t offset, width;
 
   if (key)
     {
@@ -2278,12 +2286,13 @@ debug_key (struct line const *line, struct keyfield const *key)
       if (key->skipsblanks || key->month || key_numeric (key))
         {
           char saved = *lim;
+          char *tighter_lim;
           *lim = '\0';
 
           while (blanks[to_uchar (*beg)])
             beg++;
 
-          char *tighter_lim = beg;
+          tighter_lim = beg;
 
           if (lim < beg)
             tighter_lim = lim;
@@ -2319,8 +2328,8 @@ debug_key (struct line const *line, struct keyfield const *key)
         }
     }
 
-  size_t offset = debug_width (text, beg);
-  size_t width = debug_width (beg, lim);
+  offset = debug_width (text, beg);
+  width = debug_width (beg, lim);
   mark_key (offset, width);
 }
 
@@ -2394,6 +2403,7 @@ key_warnings (struct keyfield const *gkey, bool gkey_only)
 
   for (key = keylist; key; key = key->next, keynum++)
     {
+      bool implicit_skip, maybe_space_aligned, line_offset;
       if (key->obsolete_used)
         {
           size_t sword = key->sword;
@@ -2428,10 +2438,10 @@ key_warnings (struct keyfield const *gkey, bool gkey_only)
         error (0, 0, _("key %lu has zero width and will be ignored"), keynum);
 
       /* Warn about significant leading blanks.  */
-      bool implicit_skip = key_numeric (key) || key->month;
-      bool maybe_space_aligned = !hard_LC_COLLATE && default_key_compare (key)
+      implicit_skip = key_numeric (key) || key->month;
+      maybe_space_aligned = !hard_LC_COLLATE && default_key_compare (key)
                                  && !(key->schar || key->echar);
-      bool line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */
+      line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */
       if (!gkey_only && tab == TAB_DEFAULT && !line_offset
           && ((!key->skipsblanks && !(implicit_skip || maybe_space_aligned))
               || (!key->skipsblanks && key->schar)
@@ -2475,10 +2485,10 @@ key_warnings (struct keyfield const *gkey, bool gkey_only)
       || (ugkey.reverse && (stable || unique) && keylist))
     {
       bool ugkey_reverse = ugkey.reverse;
+      char opts[sizeof short_options];
       if (!(stable || unique))
         ugkey.reverse = false;
       /* The following is too big, but guaranteed to be "big enough".  */
-      char opts[sizeof short_options];
       key_to_opts (&ugkey, opts);
       error (0, 0,
              ngettext ("option '-%s' is ignored",
@@ -2509,6 +2519,7 @@ keycompare (struct line const *a, struct line const *b)
 
   while (true)
     {
+      size_t lena, lenb;
       char const *translate = key->translate;
       bool const *ignore = key->ignore;
 
@@ -2517,8 +2528,8 @@ keycompare (struct line const *a, struct line const *b)
       limb = MAX (textb, limb);
 
       /* Find the lengths. */
-      size_t lena = lima - texta;
-      size_t lenb = limb - textb;
+      lena = lima - texta;
+      lenb = limb - textb;
 
       if (hard_LC_COLLATE || key_numeric (key)
           || key->month || key->random || key->version)
@@ -3187,6 +3198,8 @@ sequential_sort (struct line *restrict lines, size_t nlines,
       size_t nhi = nlines - nlo;
       struct line *lo = lines;
       struct line *hi = lines - nlo;
+      struct line *dest;
+      struct line const *sorted_lo;
 
       sequential_sort (hi, nhi, temp - (to_temp ? nlo : 0), to_temp);
       if (1 < nlo)
@@ -3194,8 +3207,6 @@ sequential_sort (struct line *restrict lines, size_t nlines,
       else if (!to_temp)
         temp[-1] = lo[-1];
 
-      struct line *dest;
-      struct line const *sorted_lo;
       if (to_temp)
         {
           dest = temp;
@@ -3822,6 +3833,8 @@ merge (struct sortfile *files, size_t ntemps, size_t nfiles,
   while (true)
     {
       /* Merge directly into the output file if possible.  */
+      FILE *tfp;
+      struct tempnode *temp;
       FILE **fps;
       size_t nopened = open_input_files (files, nfiles, &fps);
 
@@ -3844,8 +3857,6 @@ merge (struct sortfile *files, size_t ntemps, size_t nfiles,
          file with our spare file descriptor.  Retry if that failed
          (e.g., some other process could open a file between the time
          we closed and tried to create).  */
-      FILE *tfp;
-      struct tempnode *temp;
       do
         {
           nopened--;
@@ -3874,10 +3885,10 @@ sort (char *const *files, size_t nfiles, char const *output_file,
       size_t nthreads)
 {
   struct buffer buf;
-  IF_LINT (buf.buf = NULL);
   size_t ntemps = 0;
   bool output_file_created = false;
-
+  IF_LINT (buf.buf = NULL);
+  
   buf.alloc = 0;
 
   while (nfiles)
@@ -3942,10 +3953,12 @@ sort (char *const *files, size_t nfiles, char const *output_file,
           if (1 < buf.nlines)
             {
               struct merge_node_queue queue;
+              struct merge_node *merge_tree;
+              struct merge_node *root;
               queue_init (&queue, nthreads);
-              struct merge_node *merge_tree =
+              merge_tree =
                 merge_tree_init (nthreads, buf.nlines, line);
-              struct merge_node *root = merge_tree + 1;
+              root = merge_tree + 1;
 
               sortlines (line, nthreads, buf.nlines, root,
                          &queue, tfp, temp_output);
@@ -4722,6 +4735,7 @@ main (int argc, char **argv)
     }
   else
     {
+      size_t nthreads_max;
       if (!nthreads)
         {
           unsigned long int np = num_processors (NPROC_CURRENT_OVERRIDABLE);
@@ -4729,7 +4743,7 @@ main (int argc, char **argv)
         }
 
       /* Avoid integer overflow later.  */
-      size_t nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));
+      nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));
       nthreads = MIN (nthreads, nthreads_max);
 
       sort (files, nfiles, outfile, nthreads);
diff --git a/src/split.c b/src/split.c
index f740652..e86668f 100644
--- a/src/split.c
+++ b/src/split.c
@@ -309,14 +309,15 @@ new_name:
 
       if (numeric_suffix_start)
         {
-          assert (! widen);
-
+          size_t *sufindex_end;
+          
           /* Update the output file name.  */
           size_t i = strlen (numeric_suffix_start);
+          assert (! widen);
           memcpy (outfile_mid + suffix_length - i, numeric_suffix_start, i);
 
           /* Update the suffix index.  */
-          size_t *sufindex_end = sufindex + suffix_length;
+          sufindex_end = sufindex + suffix_length;
           while (i-- != 0)
             *--sufindex_end = numeric_suffix_start[i] - '0';
         }
@@ -362,13 +363,14 @@ create (const char *name)
 {
   if (!filter_command)
     {
+      int fd;
+      struct stat out_stat_buf;
       if (verbose)
         fprintf (stdout, _("creating file %s\n"), quote (name));
 
-      int fd = open (name, O_WRONLY | O_CREAT | O_BINARY, MODE_RW_UGO);
+      fd = open (name, O_WRONLY | O_CREAT | O_BINARY, MODE_RW_UGO);
       if (fd < 0)
         return fd;
-      struct stat out_stat_buf;
       if (fstat (fd, &out_stat_buf) != 0)
         error (EXIT_FAILURE, errno, _("failed to stat %s"), quote (name));
       if (SAME_INODE (in_stat_buf, out_stat_buf))
@@ -445,9 +447,9 @@ closeout (FILE *fp, int fd, pid_t pid, char const *name)
     error (EXIT_FAILURE, errno, "%s", name);
   if (fd >= 0)
     {
+      int j;
       if (fp == NULL && close (fd) < 0)
         error (EXIT_FAILURE, errno, "%s", name);
-      int j;
       for (j = 0; j < n_open_pipes; ++j)
         {
           if (open_pipes[j] == fd)
@@ -633,11 +635,13 @@ line_bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize)
 
   do
     {
+      size_t n_left;
+      char *sob;
       n_read = full_read (STDIN_FILENO, buf, bufsize);
       if (n_read < bufsize && errno)
         error (EXIT_FAILURE, errno, "%s", infile);
-      size_t n_left = n_read;
-      char *sob = buf;
+      n_left = n_read;
+      sob = buf;
       while (n_left)
         {
           size_t split_rest = 0;
@@ -670,8 +674,8 @@ line_bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize)
           /* Output to eol if present.  */
           if (eol)
             {
-              split_line = true;
               size_t n_write = eol - sob + 1;
+              split_line = true;
               cwrite (n_out == 0, sob, n_write);
               n_out += n_write;
               n_left -= n_write;
@@ -739,8 +743,6 @@ static void
 lines_chunk_split (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
                    off_t file_size)
 {
-  assert (n && k <= n && n <= file_size);
-
   const off_t chunk_size = file_size / n;
   uintmax_t chunk_no = 1;
   off_t chunk_end = chunk_size - 1;
@@ -748,6 +750,8 @@ lines_chunk_split (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
   bool new_file_flag = true;
   bool chunk_truncated = false;
 
+  assert (n && k <= n && n <= file_size);
+
   if (k > 1)
     {
       /* Start reading 1 byte before kth chunk of file.  */
@@ -1136,6 +1140,8 @@ main (int argc, char **argv)
   int c;
   int digits_optind = 0;
   off_t file_size IF_LINT (= 0);
+  void *b;
+  char *buf;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1434,8 +1440,8 @@ main (int argc, char **argv)
       file_size = MAX (file_size, n_units);
     }
 
-  void *b = xmalloc (in_blk_size + 1 + page_size - 1);
-  char *buf = ptr_align (b, page_size);
+  b = xmalloc (in_blk_size + 1 + page_size - 1);
+  buf = ptr_align (b, page_size);
 
   /* When filtering, closure of one pipe must not terminate the process,
      as there may still be other streams expecting input from us.  */
diff --git a/src/stat.c b/src/stat.c
index ba491f4..c3e66f8 100644
--- a/src/stat.c
+++ b/src/stat.c
@@ -604,6 +604,10 @@ out_epoch_sec (char *pformat, size_t prefix_len,
   int width = 0;
   int precision = 0;
   bool frac_left_adjust = false;
+  int divisor = 1;
+  int frac_sec;
+  int int_len;
+  int i;
 
   if (dot)
     {
@@ -625,6 +629,7 @@ out_epoch_sec (char *pformat, size_t prefix_len,
           /* If a nontrivial width is given, subtract the width of the
              decimal point and PRECISION digits that will be output
              later.  */
+          long int lwidth;
           char *p = dot;
           *dot = '\0';
 
@@ -632,13 +637,14 @@ out_epoch_sec (char *pformat, size_t prefix_len,
             --p;
           while (ISDIGIT (p[-1]));
 
-          long int lwidth = strtol (p, NULL, 10);
+          lwidth = strtol (p, NULL, 10);
           width = (lwidth <= INT_MAX ? lwidth : INT_MAX);
           if (1 < width)
             {
+              int w_d;
               p += (*p == '0');
               sec_prefix_len = p - pformat;
-              int w_d = (decimal_point_len < width
+              w_d = (decimal_point_len < width
                          ? width - decimal_point_len
                          : 0);
               if (1 < w_d)
@@ -647,7 +653,8 @@ out_epoch_sec (char *pformat, size_t prefix_len,
                   if (1 < w)
                     {
                       char *dst = pformat;
-                      for (char const *src = dst; src < p; src++)
+                      char const *src;
+                      for (src = dst; src < p; src++)
                         {
                           if (*src == '-')
                             frac_left_adjust = true;
@@ -663,11 +670,9 @@ out_epoch_sec (char *pformat, size_t prefix_len,
         }
     }
 
-  int divisor = 1;
-  for (int i = precision; i < 9; i++)
+  for (i = precision; i < 9; i++)
     divisor *= 10;
-  int frac_sec = arg.tv_nsec / divisor;
-  int int_len;
+  frac_sec = arg.tv_nsec / divisor;
 
   if (TYPE_SIGNED (time_t))
     {
@@ -819,6 +824,7 @@ find_bind_mount (char const * name)
 {
   char const * bind_mount = NULL;
 
+  struct mount_entry *me;
   static struct mount_entry *mount_list;
   static bool tried_mount_list = false;
   if (!tried_mount_list) /* attempt/warn once per process.  */
@@ -828,7 +834,6 @@ find_bind_mount (char const * name)
       tried_mount_list = true;
     }
 
-  struct mount_entry *me;
   for (me = mount_list; me; me = me->me_next)
     {
       if (me->me_dummy && me->me_devname[0] == '/'
@@ -903,9 +908,9 @@ print_mount_point:
 static inline struct timespec
 neg_to_zero (struct timespec ts)
 {
+  struct timespec z = {0, 0};
   if (0 <= ts.tv_nsec)
     return ts;
-  struct timespec z = {0, 0};
   return z;
 }
 
@@ -1114,11 +1119,12 @@ print_it (char const *format, char const *filename,
           {
             size_t len = strspn (b + 1, printf_flags);
             char const *fmt_char = b + len + 1;
+            unsigned int fmt_code;
             fmt_char += strspn (fmt_char, digits);
             if (*fmt_char == '.')
               fmt_char += 1 + strspn (fmt_char + 1, digits);
             len = fmt_char - (b + 1);
-            unsigned int fmt_code = *fmt_char;
+            fmt_code = *fmt_char;
             memcpy (dest, b, len + 1);
 
             b = fmt_char;
@@ -1206,6 +1212,7 @@ static bool ATTRIBUTE_WARN_UNUSED_RESULT
 do_statfs (char const *filename, char const *format)
 {
   STRUCT_STATVFS statfsbuf;
+  bool fail;
 
   if (STREQ (filename, "-"))
     {
@@ -1221,7 +1228,7 @@ do_statfs (char const *filename, char const *format)
       return false;
     }
 
-  bool fail = print_it (format, filename, print_statfs, &statfsbuf);
+  fail = print_it (format, filename, print_statfs, &statfsbuf);
   return ! fail;
 }
 
@@ -1231,6 +1238,7 @@ do_stat (char const *filename, char const *format,
          char const *format2)
 {
   struct stat statbuf;
+  bool fail;
 
   if (STREQ (filename, "-"))
     {
@@ -1254,7 +1262,7 @@ do_stat (char const *filename, char const *format,
   if (S_ISBLK (statbuf.st_mode) || S_ISCHR (statbuf.st_mode))
     format = format2;
 
-  bool fail = print_it (format, filename, print_stat, &statbuf);
+  fail = print_it (format, filename, print_stat, &statbuf);
   return ! fail;
 }
 
@@ -1455,14 +1463,14 @@ main (int argc, char *argv[])
   char *format = NULL;
   char *format2;
   bool ok = true;
-
+  struct lconv const *locale = localeconv ();
+  
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
   setlocale (LC_ALL, "");
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
-  struct lconv const *locale = localeconv ();
   decimal_point = (locale->decimal_point[0] ? locale->decimal_point : ".");
   decimal_point_len = strlen (decimal_point);
 
diff --git a/src/system.h b/src/system.h
index 6b242a8..0715a96 100644
--- a/src/system.h
+++ b/src/system.h
@@ -502,6 +502,7 @@ is_nul (void const *buf, size_t bufsize)
   void const *vp;
   char const *cbuf = buf;
   word const *wp = buf;
+  char const *cp;
 
   /* Find first nonzero *word*, or the word with the sentinel.  */
   while (*wp++ == 0)
@@ -509,7 +510,7 @@ is_nul (void const *buf, size_t bufsize)
 
   /* Find the first nonzero *byte*, or the sentinel.  */
   vp = wp - 1;
-  char const *cp = vp;
+  cp = vp;
   while (*cp++ == 0)
     continue;
 
@@ -567,10 +568,11 @@ Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n\
 static inline void
 emit_ancillary_info (void)
 {
+  const char *lc_messages;
   printf (_("\n%s online help: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
   /* Don't output this redundant message for English locales.
      Note we still output for 'C' so that it gets included in the man page.  */
-  const char *lc_messages = setlocale (LC_MESSAGES, NULL);
+  lc_messages = setlocale (LC_MESSAGES, NULL);
   if (lc_messages && STRNCMP_LIT (lc_messages, "en_"))
     {
       /* TRANSLATORS: Replace LANG_CODE in this URL with your language code
diff --git a/src/tac.c b/src/tac.c
index 5bf40a7..7e9cbef 100644
--- a/src/tac.c
+++ b/src/tac.c
@@ -426,6 +426,7 @@ temp_stream (FILE **fp, char **file_name)
   static FILE *tmp_fp;
   if (tempfile == NULL)
     {
+      int fd;
       char const *t = getenv ("TMPDIR");
       char const *tempdir = t ? t : DEFAULT_TMPDIR;
       tempfile = mfile_name_concat (tempdir, "tacXXXXXX", NULL);
@@ -444,7 +445,7 @@ temp_stream (FILE **fp, char **file_name)
          FIXME: clean up upon fatal signal.  Don't block them, in case
          $TMPFILE is a remote file system.  */
 
-      int fd = mkstemp (tempfile);
+      fd = mkstemp (tempfile);
       if (fd < 0)
         {
           error (0, errno, _("failed to create temporary file in %s"),
@@ -536,10 +537,11 @@ tac_nonseekable (int input_fd, const char *file)
 {
   FILE *tmp_stream;
   char *tmp_file;
+  bool ok;
   if (!copy_to_temp (&tmp_stream, &tmp_file, input_fd, file))
     return false;
 
-  bool ok = tac_seekable (fileno (tmp_stream), tmp_file);
+  ok = tac_seekable (fileno (tmp_stream), tmp_file);
   return ok;
 }
 
diff --git a/src/tail.c b/src/tail.c
index dc4e10d..87b2d66 100644
--- a/src/tail.c
+++ b/src/tail.c
@@ -844,6 +844,8 @@ start_lines (const char *pretty_filename, int fd, uintmax_t n_lines,
     {
       char buffer[BUFSIZ];
       size_t bytes_read = safe_read (fd, buffer, BUFSIZ);
+      char *buffer_end;
+      char *p;
       if (bytes_read == 0) /* EOF */
         return -1;
       if (bytes_read == SAFE_READ_ERROR) /* error */
@@ -852,11 +854,11 @@ start_lines (const char *pretty_filename, int fd, uintmax_t n_lines,
           return 1;
         }
 
-      char *buffer_end = buffer + bytes_read;
+      buffer_end = buffer + bytes_read;
 
       *read_pos += bytes_read;
 
-      char *p = buffer;
+      p = buffer;
       while ((p = memchr (p, '\n', buffer_end - p)))
         {
           ++p;
diff --git a/src/test.c b/src/test.c
index 2038209..45a1842 100644
--- a/src/test.c
+++ b/src/test.c
@@ -420,23 +420,27 @@ unary_operator (void)
 
     case 'O':			/* File is owned by you? */
       {
+        uid_t euid;
+        uid_t NO_UID;
         unary_advance ();
         if (stat (argv[pos - 1], &stat_buf) != 0)
           return false;
         errno = 0;
-        uid_t euid = geteuid ();
-        uid_t NO_UID = -1;
+        euid = geteuid ();
+        NO_UID = -1;
         return ! (euid == NO_UID && errno) && euid == stat_buf.st_uid;
       }
 
     case 'G':			/* File is owned by your group? */
       {
+        gid_t egid;
+        gid_t NO_GID;
         unary_advance ();
         if (stat (argv[pos - 1], &stat_buf) != 0)
           return false;
         errno = 0;
-        gid_t egid = getegid ();
-        gid_t NO_GID = -1;
+        egid = getegid ();
+        NO_GID = -1;
         return ! (egid == NO_GID && errno) && egid == stat_buf.st_gid;
       }
 
diff --git a/src/timeout.c b/src/timeout.c
index c8749d0..95f6e46 100644
--- a/src/timeout.c
+++ b/src/timeout.c
@@ -133,6 +133,7 @@ settimeout (double duration, bool warn)
    resolution provided by alarm().  */
 
 #if HAVE_TIMER_SETTIME
+{
   struct timespec ts = dtotimespec (duration);
   struct itimerspec its = { {0, 0}, ts };
   timer_t timerid;
@@ -149,8 +150,10 @@ settimeout (double duration, bool warn)
     }
   else if (warn && errno != ENOSYS)
     error (0, errno, _("warning: timer_create"));
+}
 #endif
 
+{
   unsigned int timeint;
   if (UINT_MAX <= duration)
     timeint = UINT_MAX;
@@ -161,6 +164,7 @@ settimeout (double duration, bool warn)
     }
   alarm (timeint);
 }
+}
 
 /* send SIG avoiding the current process.  */
 
diff --git a/src/wc.c b/src/wc.c
index 93decd7..619f44c 100644
--- a/src/wc.c
+++ b/src/wc.c
@@ -597,6 +597,9 @@ main (int argc, char **argv)
   char *files_from = NULL;
   struct fstatus *fstatus;
   struct Tokens tok;
+  bool read_tokens = false;
+  struct argv_iterator *ai;
+  int i;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -653,10 +656,9 @@ main (int argc, char **argv)
          || print_linelength))
     print_lines = print_words = print_bytes = true;
 
-  bool read_tokens = false;
-  struct argv_iterator *ai;
   if (files_from)
     {
+      struct stat st;
       FILE *stream;
 
       /* When using --files0-from=F, you may not specify any files
@@ -681,7 +683,6 @@ main (int argc, char **argv)
 
       /* Read the file list into RAM if we can detect its size and that
          size is reasonable.  Otherwise, we'll read a name at a time.  */
-      struct stat st;
       if (fstat (fileno (stream), &st) == 0
           && S_ISREG (st.st_mode)
           && st.st_size <= MIN (10 * 1024 * 1024, physmem_available () / 2))
@@ -716,7 +717,6 @@ main (int argc, char **argv)
   fstatus = get_input_fstatus (nfiles, files);
   number_width = compute_number_width (nfiles, fstatus);
 
-  int i;
   ok = true;
   for (i = 0; /* */; i++)
     {
-- 
1.8.3.4

