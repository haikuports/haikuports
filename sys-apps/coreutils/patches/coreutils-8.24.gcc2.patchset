From 40338befae6012dd77f69edcfc28dfee22408039 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Sat, 1 Aug 2015 20:52:28 +0000
Subject: [PATCH 1/2] gcc2 c89 patch

---
 lib/randperm.c   |   9 +++--
 lib/utimecmp.c   |   5 +--
 lib/verify.h     |   3 +-
 src/chown-core.c |   3 +-
 src/chroot.c     |  17 +++++---
 src/copy.c       |  50 ++++++++++++++----------
 src/cp.c         |   5 ++-
 src/csplit.c     |  17 +++++---
 src/cut.c        |   6 ++-
 src/dd.c         |  22 +++++++----
 src/df.c         |  45 +++++++++++++--------
 src/du.c         |  12 +++---
 src/env.c        |   5 ++-
 src/expr.c       |   7 ++--
 src/factor.c     | 117 ++++++++++++++++++++++++++++++++++---------------------
 src/getlimits.c  |   3 +-
 src/group-list.c |   3 +-
 src/head.c       |   9 +++--
 src/id.c         |  12 ++++--
 src/install.c    |   6 ++-
 src/join.c       |   9 +++--
 src/ls.c         |  43 +++++++++++++-------
 src/md5sum.c     |   5 ++-
 src/mkdir.c      |  13 ++++---
 src/nohup.c      |   8 ++--
 src/nproc.c      |   4 +-
 src/numfmt.c     |  47 ++++++++++++++--------
 src/od.c         |   2 +-
 src/realpath.c   |   6 ++-
 src/relpath.c    |   6 ++-
 src/remove.c     |  31 +++++++++------
 src/rm.c         |   9 +++--
 src/runcon.c     |   3 +-
 src/seq.c        |  29 ++++++++------
 src/shred.c      |  40 +++++++++++--------
 src/shuf.c       |   3 +-
 src/sort.c       |  73 ++++++++++++++++++++--------------
 src/split.c      |  43 ++++++++++++--------
 src/stat.c       |  38 +++++++++++-------
 src/stdbuf.c     |   3 +-
 src/sync.c       |   3 +-
 src/system.h     |   6 ++-
 src/tac.c        |   6 ++-
 src/tail.c       |   9 +++--
 src/test.c       |  12 ++++--
 src/timeout.c    |  10 ++++-
 src/wc.c         |  16 ++++----
 47 files changed, 515 insertions(+), 318 deletions(-)

diff --git a/lib/randperm.c b/lib/randperm.c
index 41ea4c1..4053e17 100644
--- a/lib/randperm.c
+++ b/lib/randperm.c
@@ -114,8 +114,11 @@ sparse_new (size_t size_hint)
 static void
 sparse_swap (sparse_map *sv, size_t* v, size_t i, size_t j)
 {
-  struct sparse_ent_ *v1 = hash_delete (sv, &(struct sparse_ent_) {i,0});
-  struct sparse_ent_ *v2 = hash_delete (sv, &(struct sparse_ent_) {j,0});
+  struct sparse_ent_ ent1 = {i,0};
+  struct sparse_ent_ ent2 = {j,0};
+  size_t t;
+  struct sparse_ent_ *v1 = hash_delete (sv, &ent1);
+  struct sparse_ent_ *v2 = hash_delete (sv, &ent2);
 
   /* FIXME: reduce the frequency of these mallocs.  */
   if (!v1)
@@ -129,7 +132,7 @@ sparse_swap (sparse_map *sv, size_t* v, size_t i, size_t j)
       v2->index = v2->val = j;
     }
 
-  size_t t = v1->val;
+  t = v1->val;
   v1->val = v2->val;
   v2->val = t;
   if (!hash_insert (sv, v1))
diff --git a/lib/utimecmp.c b/lib/utimecmp.c
index b91fe49..ad319dd 100644
--- a/lib/utimecmp.c
+++ b/lib/utimecmp.c
@@ -131,14 +131,13 @@ utimecmp (char const *dst_name,
 
      time_t might be unsigned.  */
 
-  verify (TYPE_IS_INTEGER (time_t));
-  verify (TYPE_TWOS_COMPLEMENT (int));
-
   /* Destination and source time stamps.  */
   time_t dst_s = dst_stat->st_mtime;
   time_t src_s = src_stat->st_mtime;
   int dst_ns = get_stat_mtime_ns (dst_stat);
   int src_ns = get_stat_mtime_ns (src_stat);
+  verify (TYPE_IS_INTEGER (time_t));
+  verify (TYPE_TWOS_COMPLEMENT (int));
 
   if (options & UTIMECMP_TRUNCATE_SOURCE)
     {
diff --git a/lib/verify.h b/lib/verify.h
index 60eba49..0812f3f 100644
--- a/lib/verify.h
+++ b/lib/verify.h
@@ -248,7 +248,8 @@ template <int w>
 /* Verify requirement R at compile-time, as a declaration without a
    trailing ';'.  */
 
-#define verify(R) _GL_VERIFY (R, "verify (" #R ")")
+//#define verify(R) _GL_VERIFY (R, "verify (" #R ")")
+#define verify(R)
 
 #ifndef __has_builtin
 # define __has_builtin(x) 0
diff --git a/src/chown-core.c b/src/chown-core.c
index e8a7d52..51acaca 100644
--- a/src/chown-core.c
+++ b/src/chown-core.c
@@ -219,6 +219,7 @@ restricted_chown (int cwd_fd, char const *file,
   struct stat st;
   int open_flags = O_NONBLOCK | O_NOCTTY;
   int fd;
+  int saved_errno;
 
   if (required_uid == (uid_t) -1 && required_gid == (gid_t) -1)
     return RC_do_ordinary_chown;
@@ -256,7 +257,7 @@ restricted_chown (int cwd_fd, char const *file,
         }
     }
 
-  int saved_errno = errno;
+  saved_errno = errno;
   close (fd);
   errno = saved_errno;
   return status;
diff --git a/src/chroot.c b/src/chroot.c
index 42b4501..cdb740e 100644
--- a/src/chroot.c
+++ b/src/chroot.c
@@ -228,7 +228,12 @@ main (int argc, char **argv)
   uid_t uid = -1;
   gid_t gid = -1;
   GETGROUPS_T *out_gids = NULL;
+  GETGROUPS_T *gids;
+  GETGROUPS_T *in_gids = NULL;
   size_t n_gids = 0;
+  char const *newroot;
+  bool is_oldroot;
+  int exit_status;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -245,11 +250,12 @@ main (int argc, char **argv)
         {
         case USERSPEC:
           {
+            size_t userlen;
             userspec = optarg;
             /* Treat 'user:' just like 'user'
                as we lookup the primary group by default
                (and support doing so for UIDs as well as names.  */
-            size_t userlen = strlen (userspec);
+            userlen = strlen (userspec);
             if (userlen && userspec[userlen - 1] == ':')
               userspec[userlen - 1] = '\0';
             break;
@@ -278,8 +284,8 @@ main (int argc, char **argv)
       usage (EXIT_CANCELED);
     }
 
-  char const *newroot = argv[optind];
-  bool is_oldroot = is_root (newroot);
+  newroot = argv[optind];
+  is_oldroot = is_root (newroot);
 
   if (! is_oldroot && skip_chdir)
     {
@@ -376,8 +382,7 @@ main (int argc, char **argv)
         }
     }
 
-  GETGROUPS_T *gids = out_gids;
-  GETGROUPS_T *in_gids = NULL;
+  gids = out_gids;
   if (groups && *groups)
     {
       if (parse_additional_groups (groups, &in_gids, &n_gids, !n_gids) != 0)
@@ -423,7 +428,7 @@ main (int argc, char **argv)
   /* Execute the given command.  */
   execvp (argv[0], argv);
 
-  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
+  exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
   error (0, errno, _("failed to run command %s"), quote (argv[0]));
   return exit_status;
 }
diff --git a/src/copy.c b/src/copy.c
index e8f74df..ba3c9f1 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -219,13 +219,15 @@ sparse_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
              uintmax_t max_n_read, off_t *total_n_read,
              bool *last_write_made_hole)
 {
-  *last_write_made_hole = false;
-  *total_n_read = 0;
   bool make_hole = false;
   off_t psize = 0;
-
+  *last_write_made_hole = false;
+  *total_n_read = 0;
+  
   while (max_n_read)
     {
+      size_t csize;
+      char *cbuf, *pbuf;
       ssize_t n_read = read (src_fd, buf, MIN (max_n_read, buf_size));
       if (n_read < 0)
         {
@@ -240,13 +242,14 @@ sparse_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
       *total_n_read += n_read;
 
       /* Loop over the input buffer in chunks of hole_size.  */
-      size_t csize = hole_size ? hole_size : buf_size;
-      char *cbuf = buf;
-      char *pbuf = buf;
+      csize = hole_size ? hole_size : buf_size;
+      cbuf = buf;
+      pbuf = buf;
 
       while (n_read)
         {
           bool prev_hole = make_hole;
+          bool transition, last_chunk;
           csize = MIN (csize, n_read);
 
           if (hole_size && csize)
@@ -262,8 +265,8 @@ sparse_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
               memcpy (cbuf + csize, &isnul_tmp, sizeof (word));
             }
 
-          bool transition = (make_hole != prev_hole) && psize;
-          bool last_chunk = (n_read == csize && ! make_hole) || ! csize;
+          transition = (make_hole != prev_hole) && psize;
+          last_chunk = (n_read == csize && ! make_hole) || ! csize;
 
           if (transition || last_chunk)
             {
@@ -402,13 +405,15 @@ extent_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
   /* Keep track of the output position.
      We may need this at the end, for a final ftruncate.  */
   off_t dest_pos = 0;
-
+  bool wrote_hole_at_eof = true;
+  
   extent_scan_init (src_fd, &scan);
 
   *require_normal_copy = false;
-  bool wrote_hole_at_eof = true;
   do
     {
+      unsigned int i;
+      bool empty_extent = false;
       bool ok = extent_scan_read (&scan);
       if (! ok)
         {
@@ -426,8 +431,6 @@ extent_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
           return false;
         }
 
-      unsigned int i;
-      bool empty_extent = false;
       for (i = 0; i < scan.ei_count || empty_extent; i++)
         {
           off_t ext_start;
@@ -790,6 +793,7 @@ copy_dir (char const *src_name_in, char const *dst_name_in, bool new_dst,
   char *namep;
   struct cp_options non_command_line_options = *x;
   bool ok = true;
+  bool new_first_dir_created = false;
 
   name_space = savedir (src_name_in, SAVEDIR_SORT_FASTREAD);
   if (name_space == NULL)
@@ -809,7 +813,6 @@ copy_dir (char const *src_name_in, char const *dst_name_in, bool new_dst,
   if (x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)
     non_command_line_options.dereference = DEREF_NEVER;
 
-  bool new_first_dir_created = false;
   namep = name_space;
   while (*namep != '\0')
     {
@@ -1196,7 +1199,7 @@ copy_reg (char const *src_name, char const *dst_name,
   if (*new_dst)
     {
     open_with_O_CREAT:;
-
+{
       int open_flags = O_WRONLY | O_CREAT | O_BINARY;
       dest_desc = open (dst_name, open_flags | O_EXCL,
                         dst_mode & ~omitted_permissions);
@@ -1240,6 +1243,7 @@ copy_reg (char const *src_name, char const *dst_name,
           && *dst_name && dst_name[strlen (dst_name) - 1] == '/')
         dest_errno = ENOTDIR;
     }
+    }
   else
     {
       omitted_permissions = 0;
@@ -1304,11 +1308,15 @@ copy_reg (char const *src_name, char const *dst_name,
       size_t buf_size = io_blksize (sb);
       size_t hole_size = ST_BLKSIZE (sb);
 
+      bool make_holes = false;
+      bool sparse_src;
+      off_t n_read;
+      bool wrote_hole_at_eof;
+
       fdadvise (source_desc, 0, 0, FADVISE_SEQUENTIAL);
 
       /* Deal with sparse files.  */
-      bool make_holes = false;
-      bool sparse_src = is_probably_sparse (&src_open_sb);
+      sparse_src = is_probably_sparse (&src_open_sb);
 
       if (S_ISREG (sb.st_mode))
         {
@@ -1374,8 +1382,6 @@ copy_reg (char const *src_name, char const *dst_name,
             }
         }
 
-      off_t n_read;
-      bool wrote_hole_at_eof;
       if (! sparse_copy (source_desc, dest_desc, buf, buf_size,
                          make_holes ? hole_size : 0,
                          x->sparse_mode == SPARSE_ALWAYS, src_name, dst_name,
@@ -1869,10 +1875,11 @@ create_hard_link (char const *src_name, char const *dst_name,
 {
   /* We want to guarantee that symlinks are not followed, unless requested.  */
   int flags = 0;
+  bool link_failed;
   if (dereference)
     flags = AT_SYMLINK_FOLLOW;
 
-  bool link_failed = (linkat (AT_FDCWD, src_name, AT_FDCWD, dst_name, flags)
+  link_failed = (linkat (AT_FDCWD, src_name, AT_FDCWD, dst_name, flags)
                       != 0);
 
   /* If the link failed because of an existing destination,
@@ -1947,6 +1954,7 @@ copy_internal (char const *src_name, char const *dst_name,
   bool copied_as_regular = false;
   bool dest_is_symlink = false;
   bool have_dst_lstat = false;
+  bool dereference;
 
   if (x->move_mode && rename_succeeded)
     *rename_succeeded = false;
@@ -1985,7 +1993,7 @@ copy_internal (char const *src_name, char const *dst_name,
       record_file (x->src_info, src_name, &src_sb);
     }
 
-  bool dereference = should_dereference (x, command_line_arg);
+  dereference = should_dereference (x, command_line_arg);
 
   if (!new_dst)
     {
@@ -3018,6 +3026,7 @@ copy (char const *src_name, char const *dst_name,
       bool nonexistent_dst, const struct cp_options *options,
       bool *copy_into_self, bool *rename_succeeded)
 {
+  bool first_dir_created_per_command_line_arg = false;
   assert (valid_options (options));
 
   /* Record the file names: they're used in case of error, when copying
@@ -3030,7 +3039,6 @@ copy (char const *src_name, char const *dst_name,
   top_level_src_name = src_name;
   top_level_dst_name = dst_name;
 
-  bool first_dir_created_per_command_line_arg = false;
   return copy_internal (src_name, dst_name, nonexistent_dst, NULL, NULL,
                         options, true,
                         &first_dir_created_per_command_line_arg,
diff --git a/src/cp.c b/src/cp.c
index a2a5e39..c98e895 100644
--- a/src/cp.c
+++ b/src/cp.c
@@ -829,6 +829,7 @@ cp_option_init (struct cp_options *x)
 static void
 decode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)
 {
+  char *arg_writable, *s;
   enum File_attribute
     {
       PRESERVE_MODE,
@@ -853,8 +854,8 @@ decode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)
     };
   ARGMATCH_VERIFY (preserve_args, preserve_vals);
 
-  char *arg_writable = xstrdup (arg);
-  char *s = arg_writable;
+  arg_writable = xstrdup (arg);
+  s = arg_writable;
   do
     {
       /* find next comma */
diff --git a/src/csplit.c b/src/csplit.c
index d966df5..2dcf820 100644
--- a/src/csplit.c
+++ b/src/csplit.c
@@ -1226,8 +1226,9 @@ static size_t
 get_format_flags (char const *format, int *flags_ptr)
 {
   int flags = 0;
+  size_t count;
 
-  for (size_t count = 0; ; count++)
+  for (count = 0; ; count++)
     {
       switch (format[count])
         {
@@ -1301,15 +1302,17 @@ static size_t
 max_out (char *format)
 {
   bool percent = false;
+  char *f;
+  int maxlen;
 
-  for (char *f = format; *f; f++)
+  for (f = format; *f; f++)
     if (*f == '%' && *++f != '%')
       {
+        int flags;
         if (percent)
           error (EXIT_FAILURE, 0,
                  _("too many %% conversion specifications in suffix"));
         percent = true;
-        int flags;
         f += get_format_flags (f, &flags);
         while (ISDIGIT (*f))
           f++;
@@ -1323,7 +1326,7 @@ max_out (char *format)
     error (EXIT_FAILURE, 0,
            _("missing %% conversion specification in suffix"));
 
-  int maxlen = snprintf (NULL, 0, format, UINT_MAX);
+  maxlen = snprintf (NULL, 0, format, UINT_MAX);
   if (! (0 <= maxlen && maxlen <= SIZE_MAX))
     xalloc_die ();
   return maxlen;
@@ -1333,6 +1336,8 @@ int
 main (int argc, char **argv)
 {
   int optc;
+  size_t prefix_len;
+  size_t max_digit_string_len;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1400,8 +1405,8 @@ main (int argc, char **argv)
       usage (EXIT_FAILURE);
     }
 
-  size_t prefix_len = strlen (prefix);
-  size_t max_digit_string_len
+  prefix_len = strlen (prefix);
+  max_digit_string_len
     = (suffix
        ? max_out (suffix)
        : MAX (INT_STRLEN_BOUND (unsigned int), digits));
diff --git a/src/cut.c b/src/cut.c
index 4f80ebd..ee801c9 100644
--- a/src/cut.c
+++ b/src/cut.c
@@ -398,7 +398,8 @@ set_fields (const char *fieldstr)
   /* Merge range pairs (e.g. `2-5,3-4' becomes `2-5'). */
   for (i = 0; i < n_rp; ++i)
     {
-      for (size_t j = i + 1; j < n_rp; ++j)
+      size_t j;
+      for (j = i + 1; j < n_rp; ++j)
         {
           if (rp[j].lo <= rp[i].hi)
             {
@@ -533,6 +534,7 @@ cut_fields (FILE *stream)
 
   while (1)
     {
+      int prev_c;
       if (field_idx == 1 && buffer_first_field)
         {
           ssize_t len;
@@ -594,7 +596,7 @@ cut_fields (FILE *stream)
           next_item (&field_idx);
         }
 
-      int prev_c = c;
+      prev_c = c;
 
       if (print_kth (field_idx))
         {
diff --git a/src/dd.c b/src/dd.c
index e647294..e4bdedc 100644
--- a/src/dd.c
+++ b/src/dd.c
@@ -532,13 +532,13 @@ maybe_close_stdout (void)
 static void _GL_ATTRIBUTE_FORMAT ((__printf__, 3, 4))
 nl_error (int status, int errnum, const char *fmt, ...)
 {
+  va_list ap;
   if (newline_pending)
     {
       fputc ('\n', stderr);
       newline_pending = false;
     }
 
-  va_list ap;
   va_start (ap, fmt);
   verror (status, errnum, fmt, ap);
   va_end (ap);
@@ -690,10 +690,11 @@ human_size (size_t n)
 static void
 alloc_ibuf (void)
 {
+  char *real_buf;
   if (ibuf)
     return;
 
-  char *real_buf = malloc (input_blocksize + INPUT_BLOCK_SLOP);
+  real_buf = malloc (input_blocksize + INPUT_BLOCK_SLOP);
   if (!real_buf)
     error (EXIT_FAILURE, 0,
            _("memory exhausted by input buffer of size %"PRIuMAX" bytes (%s)"),
@@ -763,6 +764,8 @@ print_xfer_stats (xtime_t progress_time) {
      | human_space_before_unit | human_SI | human_B);
   double delta_s;
   char const *bytes_per_second;
+  xtime_t now;
+  char const *time_fmt;
 
   if (progress_time)
     fputc ('\r', stderr);
@@ -777,7 +780,7 @@ print_xfer_stats (xtime_t progress_time) {
            w_bytes,
            human_readable (w_bytes, hbuf, human_opts, 1, 1));
 
-  xtime_t now = progress_time ? progress_time : gethrxtime ();
+  now = progress_time ? progress_time : gethrxtime ();
 
   if (start_time < now)
     {
@@ -804,7 +807,7 @@ print_xfer_stats (xtime_t progress_time) {
      but that was incorrect for languages like Polish.  To fix this
      bug we now use SI symbols even though they're a bit more
      confusing in English.  */
-  char const *time_fmt = _(", %g s, %s/s\n");
+  time_fmt = _(", %g s, %s/s\n");
   if (progress_time)
     time_fmt = _(", %.6f s, %s/s");  /* OK with '\r' as increasing width.  */
   fprintf (stderr, time_fmt, delta_s, bytes_per_second);
@@ -1008,6 +1011,7 @@ static bool
 invalidate_cache (int fd, off_t len)
 {
   int adv_ret = -1;
+  off_t pending;
 
   /* Minimize syscalls.  */
   off_t clen = cache_round (fd, len);
@@ -1015,7 +1019,7 @@ invalidate_cache (int fd, off_t len)
     return true; /* Don't advise this time.  */
   if (!len && !clen && max_records)
     return true; /* Nothing pending.  */
-  off_t pending = len ? cache_round (fd, 0) : 0;
+  pending = len ? cache_round (fd, 0) : 0;
 
   if (fd == STDIN_FILENO)
     {
@@ -1745,6 +1749,7 @@ skip (int fdesc, char const *file, uintmax_t records, size_t blocksize,
     }
   else
     {
+      char *buf;
       int lseek_errno = errno;
 
       /* The seek request may have failed above if it was too big
@@ -1779,7 +1784,6 @@ skip (int fdesc, char const *file, uintmax_t records, size_t blocksize,
         }
       /* else file_size && offset > OFF_T_MAX or file ! seekable */
 
-      char *buf;
       if (fdesc == STDIN_FILENO)
         {
           alloc_ibuf ();
@@ -2099,10 +2103,11 @@ dd_copy (void)
     {
       if (status_level == STATUS_PROGRESS)
         {
+          double XTIME_PRECISIONe0;
           xtime_t progress_time = gethrxtime ();
           uintmax_t delta_xtime = progress_time;
           delta_xtime -= previous_time;
-          double XTIME_PRECISIONe0 = XTIME_PRECISION;
+          XTIME_PRECISIONe0 = XTIME_PRECISION;
           if (delta_xtime / XTIME_PRECISIONe0 > 1)
             {
               print_xfer_stats (progress_time);
@@ -2139,8 +2144,9 @@ dd_copy (void)
 
           if (conversions_mask & C_NOERROR)
             {
+              size_t bad_portion;
               print_stats ();
-              size_t bad_portion = input_blocksize - partread;
+              bad_portion = input_blocksize - partread;
 
               /* We already know this data is not cached,
                  but call this so that correct offsets are maintained.  */
diff --git a/src/df.c b/src/df.c
index 2e541b9..b336e85 100644
--- a/src/df.c
+++ b/src/df.c
@@ -309,6 +309,8 @@ print_table (void)
       for (col = 0; col < ncolumns; col++)
         {
           char *cell = table[row][col];
+          int flags;
+          size_t width;
 
           /* Note the SOURCE_FIELD used to be displayed on it's own line
              if (!posix_format && mbswidth (cell) > 20), but that
@@ -317,11 +319,11 @@ print_table (void)
           if (col != 0)
             putchar (' ');
 
-          int flags = 0;
+          flags = 0;
           if (col == ncolumns - 1) /* The last one.  */
             flags = MBA_NO_RIGHT_PAD;
 
-          size_t width = columns[col]->width;
+          width = columns[col]->width;
           cell = ambsalign (cell, &width, columns[col]->align, flags);
           /* When ambsalign fails, output unaligned data.  */
           fputs (cell ? cell : table[row][col], stdout);
@@ -366,6 +368,8 @@ decode_output_arg (char const *arg)
   do
     {
       /* find next comma */
+      display_field_t field;
+      unsigned int i;
       char *comma = strchr (s, ',');
 
       /* If we found a comma, put a NUL in its place and advance.  */
@@ -373,8 +377,8 @@ decode_output_arg (char const *arg)
         *comma++ = 0;
 
       /* process S.  */
-      display_field_t field = INVALID_FIELD;
-      for (unsigned int i = 0; i < ARRAY_CARDINALITY (field_data); i++)
+      field = INVALID_FIELD;
+      for (i = 0; i < ARRAY_CARDINALITY (field_data); i++)
         {
           if (STREQ (field_data[i].arg, s))
             {
@@ -526,6 +530,7 @@ get_header (void)
           uintmax_t q1024 = output_block_size;
           bool divisible_by_1000;
           bool divisible_by_1024;
+          char *num;
 
           do
             {
@@ -541,7 +546,7 @@ get_header (void)
           if (! (opts & human_base_1024))
             opts |= human_B;
 
-          char *num = human_readable (output_block_size, buf, opts, 1, 1);
+          num = human_readable (output_block_size, buf, opts, 1, 1);
 
           /* Reset the header back to the default in OUTPUT_MODE.  */
           header = _("blocks");
@@ -701,12 +706,13 @@ filter_mount_list (bool devices_only)
     mount_list = NULL;
     while (device_list)
       {
+        struct devlist *devlist;
         /* Add the mount entry.  */
         me = device_list->me;
         me->me_next = mount_list;
         mount_list = me;
         /* Free devlist entry and advance.  */
-        struct devlist *devlist = device_list->next;
+        devlist = device_list->next;
         free (device_list);
         device_list = devlist;
       }
@@ -891,6 +897,12 @@ get_dev (char const *disk, char const *mount_point, char const* file,
          const struct fs_usage *force_fsu,
          bool process_all)
 {
+  struct fs_usage fsu;
+  char *dev_name;
+  char *resolved_dev;
+  struct field_values_t block_values;
+  struct field_values_t inode_values;
+  size_t col;
   if (me_remote && show_local_fs)
     return;
 
@@ -912,7 +924,6 @@ get_dev (char const *disk, char const *mount_point, char const* file,
   if (!stat_file)
     stat_file = mount_point ? mount_point : disk;
 
-  struct fs_usage fsu;
   if (force_fsu)
     fsu = *force_fsu;
   else if (get_fs_usage (stat_file, disk, &fsu))
@@ -972,9 +983,8 @@ get_dev (char const *disk, char const *mount_point, char const* file,
   if (! file)
     file = "-";			/* unspecified */
 
-  char *dev_name = xstrdup (disk);
-  char *resolved_dev;
-
+  dev_name = xstrdup (disk);
+  
   /* On some systems, dev_name is a long-named symlink like
      /dev/disk/by-uuid/828fc648-9f30-43d8-a0b1-f7196a2edb66 pointing to a
      much shorter and more useful name like /dev/sda1.  It may also look
@@ -992,15 +1002,12 @@ get_dev (char const *disk, char const *mount_point, char const* file,
   if (! fstype)
     fstype = "-";		/* unknown */
 
-  struct field_values_t block_values;
-  struct field_values_t inode_values;
   get_field_values (&block_values, &inode_values, &fsu);
 
   /* Add to grand total unless processing grand total line.  */
   if (print_grand_total && ! force_fsu)
     add_to_grand_total (&block_values, &inode_values);
 
-  size_t col;
   for (col = 0; col < ncolumns; col++)
     {
       char buf[LONGEST_HUMAN_READABLE + 2];
@@ -1172,12 +1179,13 @@ get_disk (char const *disk)
   bool best_match_accessible = false;
   bool eclipsed_device = false;
   char const *file = disk;
+  size_t best_match_len;
 
   char *resolved = canonicalize_file_name (disk);
   if (resolved && IS_ABSOLUTE_FILE_NAME (resolved))
     disk = resolved;
 
-  size_t best_match_len = SIZE_MAX;
+  best_match_len = SIZE_MAX;
   for (me = mount_list; me; me = me->me_next)
     {
       /* TODO: Should cache canon_dev in the mount_entry struct.  */
@@ -1460,6 +1468,8 @@ int
 main (int argc, char **argv)
 {
   struct stat *stats IF_LINT ( = 0);
+  bool posix_format;
+  const char *msg_mut_excl;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1481,9 +1491,9 @@ main (int argc, char **argv)
   grand_fsu.fsu_blocksize = 1;
 
   /* If true, use the POSIX output format.  */
-  bool posix_format = false;
+  posix_format = false;
 
-  const char *msg_mut_excl = _("options %s and %s are mutually exclusive");
+  msg_mut_excl = _("options %s and %s are mutually exclusive");
 
   while (true)
     {
@@ -1683,6 +1693,7 @@ main (int argc, char **argv)
          or when either of -a, -l, -t or -x is used with file name
          arguments.  Otherwise, merely give a warning and proceed.  */
       int status = 0;
+      const char *warning;
       if ( ! (optind < argc)
            || (show_all_fs
                || show_local_fs
@@ -1691,7 +1702,7 @@ main (int argc, char **argv)
         {
           status = EXIT_FAILURE;
         }
-      const char *warning = (status == 0 ? _("Warning: ") : "");
+      warning = (status == 0 ? _("Warning: ") : "");
       error (status, errno, "%s%s", warning,
              _("cannot read table of mounted file systems"));
     }
diff --git a/src/du.c b/src/du.c
index 86827f8..387b5c5 100644
--- a/src/du.c
+++ b/src/du.c
@@ -482,8 +482,9 @@ process_file (FTS *fts, FTSENT *ent)
 
           if (info == FTS_NSOK)
             {
+              FTSENT const *e;
               fts_set (fts, ent, FTS_AGAIN);
-              FTSENT const *e = fts_read (fts);
+              e = fts_read (fts);
               assert (e == ent);
               info = ent->fts_info;
             }
@@ -515,8 +516,9 @@ process_file (FTS *fts, FTSENT *ent)
              visit to the same directory.  */
           if (info == FTS_D)
             {
+              FTSENT const *e;
               fts_set (fts, ent, FTS_SKIP);
-              FTSENT const *e = fts_read (fts);
+              e = fts_read (fts);
               assert (e == ent);
             }
 
@@ -724,6 +726,8 @@ main (int argc, char **argv)
 
   /* If true, display only a total for each argument. */
   bool opt_summarize_only = false;
+  struct argv_iterator *ai;
+  static char *temp_argv[] = { NULL, NULL };
 
   cwd_only[0] = bad_cast (".");
   cwd_only[1] = NULL;
@@ -996,7 +1000,6 @@ main (int argc, char **argv)
         }
     }
 
-  struct argv_iterator *ai;
   if (files_from)
     {
       /* When using --files0-from=F, you may not specify any files
@@ -1051,8 +1054,7 @@ main (int argc, char **argv)
     bit_flags |= FTS_TIGHT_CYCLE_CHECK;
 
   bit_flags |= symlink_deref_bits;
-  static char *temp_argv[] = { NULL, NULL };
-
+  
   while (true)
     {
       bool skip_file = false;
diff --git a/src/env.c b/src/env.c
index 270d08e..5844002 100644
--- a/src/env.c
+++ b/src/env.c
@@ -80,6 +80,8 @@ main (int argc, char **argv)
   int optc;
   bool ignore_environment = false;
   bool opt_nul_terminate_output = false;
+  char *eq;
+  int exit_status;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -126,7 +128,6 @@ main (int argc, char **argv)
   if (optind < argc && STREQ (argv[optind], "-"))
     ++optind;
 
-  char *eq;
   while (optind < argc && (eq = strchr (argv[optind], '=')))
     {
       if (putenv (argv[optind]))
@@ -155,7 +156,7 @@ main (int argc, char **argv)
 
   execvp (argv[optind], &argv[optind]);
 
-  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
+  exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
   error (0, errno, "%s", argv[optind]);
   return exit_status;
 }
diff --git a/src/expr.c b/src/expr.c
index b368e23..e71dc1f 100644
--- a/src/expr.c
+++ b/src/expr.c
@@ -115,8 +115,8 @@ mpz_tdiv_r (mpz_t r, mpz_t a0, mpz_t b0)
 static char *
 mpz_get_str (char const *str, int base, mpz_t z)
 {
-  (void) str; (void) base;
   char buf[INT_BUFSIZE_BOUND (intmax_t)];
+  (void) str; (void) base;
   return xstrdup (imaxtostr (z[0], buf));
 }
 static int
@@ -137,8 +137,8 @@ mpz_get_ui (mpz_t z)
 static int
 mpz_out_str (FILE *stream, int base, mpz_t z)
 {
-  (void) base;
   char buf[INT_BUFSIZE_BOUND (intmax_t)];
+  (void) base;
   return fputs (imaxtostr (z[0], buf), stream) != EOF;
 }
 #endif
@@ -291,6 +291,7 @@ int
 main (int argc, char **argv)
 {
   VALUE *v;
+  unsigned int u_argc;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -306,7 +307,7 @@ main (int argc, char **argv)
 
   /* The above handles --help and --version.
      Since there is no other invocation of getopt, handle '--' here.  */
-  unsigned int u_argc = argc;
+  u_argc = argc;
   if (1 < u_argc && STREQ (argv[1], "--"))
     {
       --u_argc;
diff --git a/src/factor.c b/src/factor.c
index 1d7d7c8..22f2373 100644
--- a/src/factor.c
+++ b/src/factor.c
@@ -282,12 +282,13 @@ static void factor (uintmax_t, uintmax_t, struct factors *);
 # define udiv_qrnnd(q, r, n1, n0, d)                                    \
   do {                                                                  \
     uintmax_t __d1, __d0, __q, __r1, __r0;                              \
+    unsigned int __i;													\
                                                                         \
     assert ((n1) < (d));                                                \
     __d1 = (d); __d0 = 0;                                               \
     __r1 = (n1); __r0 = (n0);                                           \
     __q = 0;                                                            \
-    for (unsigned int __i = W_TYPE_SIZE; __i > 0; __i--)                \
+    for (__i = W_TYPE_SIZE; __i > 0; __i--)                \
       {                                                                 \
         rsh2 (__d1, __d0, __d1, __d0, 1);                               \
         __q <<= 1;                                                      \
@@ -405,6 +406,7 @@ static uintmax_t
 mod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)
 {
   int cntd, cnta;
+  int cnt, i;
 
   assert (d1 != 0);
 
@@ -416,9 +418,9 @@ mod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)
 
   count_leading_zeros (cntd, d1);
   count_leading_zeros (cnta, a1);
-  int cnt = cntd - cnta;
+  cnt = cntd - cnta;
   lsh2 (d1, d0, d1, d0, cnt);
-  for (int i = 0; i < cnt; i++)
+  for (i = 0; i < cnt; i++)
     {
       if (ge2 (a1, a0, d1, d0))
         sub_ddmmss (a1, a0, a1, a0, d1, d0);
@@ -523,7 +525,8 @@ factor_insert_multiplicity (struct factors *factors,
 
   if (i < 0 || p[i] != prime)
     {
-      for (int j = nfactors - 1; j > i; j--)
+      int j;
+      for (j = nfactors - 1; j > i; j--)
         {
           p[j + 1] = p[j];
           e[j + 1] = e[j];
@@ -696,19 +699,20 @@ static bool flag_prove_primality = true;
 /* Number of Miller-Rabin tests to run when not proving primality. */
 #define MR_REPS 25
 
-#ifdef __GNUC__
-# define LIKELY(cond)    __builtin_expect ((cond), 1)
-# define UNLIKELY(cond)  __builtin_expect ((cond), 0)
-#else
+//#ifdef __GNUC__
+//# define LIKELY(cond)    __builtin_expect ((cond), 1)
+//# define UNLIKELY(cond)  __builtin_expect ((cond), 0)
+//#else
 # define LIKELY(cond)    (cond)
 # define UNLIKELY(cond)  (cond)
-#endif
+//#endif
 
 static void
 factor_insert_refind (struct factors *factors, uintmax_t p, unsigned int i,
                       unsigned int off)
 {
-  for (unsigned int j = 0; j < off; j++)
+  unsigned int j;
+  for (j = 0; j < off; j++)
     p += primes_diff[i + j];
   factor_insert (factors, p);
 }
@@ -750,6 +754,8 @@ static uintmax_t
 factor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,
                        struct factors *factors)
 {
+  uintmax_t p = 3;
+  unsigned int i;
   if (t0 % 2 == 0)
     {
       unsigned int cnt;
@@ -770,8 +776,6 @@ factor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,
       factor_insert_multiplicity (factors, 2, cnt);
     }
 
-  uintmax_t p = 3;
-  unsigned int i;
   for (i = 0; t1 > 0 && i < PRIMES_PTAB_ENTRIES; i++)
     {
       for (;;)
@@ -833,6 +837,7 @@ mp_factor_using_division (mpz_t t, struct mp_factors *factors)
 {
   mpz_t q;
   unsigned long int p;
+  unsigned int i;
 
   devmsg ("[trial division] ");
 
@@ -847,7 +852,7 @@ mp_factor_using_division (mpz_t t, struct mp_factors *factors)
     }
 
   p = 3;
-  for (unsigned int i = 1; i <= PRIMES_PTAB_ENTRIES;)
+  for (i = 1; i <= PRIMES_PTAB_ENTRIES;)
     {
       if (! mpz_divisible_ui_p (t, p))
         {
@@ -1117,11 +1122,12 @@ millerrabin (uintmax_t n, uintmax_t ni, uintmax_t b, uintmax_t q,
   uintmax_t y = powm (b, q, n, ni, one);
 
   uintmax_t nm1 = n - one;      /* -1, but in redc representation. */
+  unsigned int i;
 
   if (y == one || y == nm1)
     return true;
 
-  for (unsigned int i = 1; i < k; i++)
+  for (i = 1; i < k; i++)
     {
       y = mulredc (y, y, n, ni);
 
@@ -1138,6 +1144,7 @@ millerrabin2 (const uintmax_t *np, uintmax_t ni, const uintmax_t *bp,
               const uintmax_t *qp, unsigned int k, const uintmax_t *one)
 {
   uintmax_t y1, y0, nm1_1, nm1_0, r1m;
+  unsigned int i;
 
   y0 = powm2 (&r1m, bp, qp, np, ni, one);
   y1 = r1m;
@@ -1150,7 +1157,7 @@ millerrabin2 (const uintmax_t *np, uintmax_t ni, const uintmax_t *bp,
   if (y0 == nm1_0 && y1 == nm1_1)
     return true;
 
-  for (unsigned int i = 1; i < k; i++)
+  for (i = 1; i < k; i++)
     {
       y0 = mulredc2 (&r1m, y1, y0, y1, y0, np[1], np[0], ni);
       y1 = r1m;
@@ -1168,12 +1175,13 @@ static bool
 mp_millerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,
                 mpz_srcptr q, unsigned long int k)
 {
+  unsigned long int i;
   mpz_powm (y, x, q, n);
 
   if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)
     return true;
 
-  for (unsigned long int i = 1; i < k; i++)
+  for (i = 1; i < k; i++)
     {
       mpz_powm_ui (y, y, 2, n);
       if (mpz_cmp (y, nm1) == 0)
@@ -1194,6 +1202,8 @@ prime_p (uintmax_t n)
   bool is_prime;
   uintmax_t a_prim, one, ni;
   struct factors factors;
+  uintmax_t q, a;
+  unsigned int r;
 
   if (n <= 1)
     return false;
@@ -1203,11 +1213,11 @@ prime_p (uintmax_t n)
     return true;
 
   /* Precomputation for Miller-Rabin.  */
-  uintmax_t q = n - 1;
+  q = n - 1;
   for (k = 0; (q & 1) == 0; k++)
     q >>= 1;
 
-  uintmax_t a = 2;
+  a = 2;
   binv (ni, n);                 /* ni <- 1/n mod B */
   redcify (one, 1, n);
   addmod (a_prim, one, one, n); /* i.e., redcify a = 2 */
@@ -1224,12 +1234,13 @@ prime_p (uintmax_t n)
 
   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
      number composite.  */
-  for (unsigned int r = 0; r < PRIMES_PTAB_ENTRIES; r++)
+  for (r = 0; r < PRIMES_PTAB_ENTRIES; r++)
     {
       if (flag_prove_primality)
         {
+          unsigned int i;
           is_prime = true;
-          for (unsigned int i = 0; i < factors.nfactors && is_prime; i++)
+          for (i = 0; i < factors.nfactors && is_prime; i++)
             {
               is_prime
                 = powm (a_prim, (n - 1) / factors.p[i], n, ni, one) != one;
@@ -1279,6 +1290,8 @@ prime2_p (uintmax_t n1, uintmax_t n0)
   uintmax_t ni;
   unsigned int k;
   struct factors factors;
+  unsigned int r;
+  uintmax_t a;
 
   if (n1 == 0)
     return prime_p (n0);
@@ -1299,7 +1312,7 @@ prime2_p (uintmax_t n1, uintmax_t n0)
       rsh2 (q[1], q[0], nm1[1], nm1[0], k);
     }
 
-  uintmax_t a = 2;
+  a = 2;
   binv (ni, n0);
   redcify2 (one[1], one[0], 1, n1, n0);
   addmod2 (a_prim[1], a_prim[0], one[1], one[0], one[1], one[0], n1, n0);
@@ -1319,13 +1332,14 @@ prime2_p (uintmax_t n1, uintmax_t n0)
 
   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
      number composite.  */
-  for (unsigned int r = 0; r < PRIMES_PTAB_ENTRIES; r++)
+  for (r = 0; r < PRIMES_PTAB_ENTRIES; r++)
     {
       bool is_prime;
       uintmax_t e[2], y[2];
 
       if (flag_prove_primality)
         {
+          unsigned int i;
           is_prime = true;
           if (factors.plarge[1])
             {
@@ -1336,7 +1350,7 @@ prime2_p (uintmax_t n1, uintmax_t n0)
               y[0] = powm2 (&y[1], a_prim, e, na, ni, one);
               is_prime = (y[0] != one[0] || y[1] != one[1]);
             }
-          for (unsigned int i = 0; i < factors.nfactors && is_prime; i++)
+          for (i = 0; i < factors.nfactors && is_prime; i++)
             {
               /* FIXME: We always have the factor 2. Do we really need to
                  handle it here? We have done the same powering as part
@@ -1376,6 +1390,8 @@ mp_prime_p (mpz_t n)
   bool is_prime;
   mpz_t q, a, nm1, tmp;
   struct mp_factors factors;
+  unsigned long int k;
+  unsigned int r;
 
   if (mpz_cmp_ui (n, 1) <= 0)
     return false;
@@ -1390,7 +1406,7 @@ mp_prime_p (mpz_t n)
   mpz_sub_ui (nm1, n, 1);
 
   /* Find q and k, where q is odd and n = 1 + 2**k * q.  */
-  unsigned long int k = mpz_scan1 (nm1, 0);
+  k = mpz_scan1 (nm1, 0);
   mpz_tdiv_q_2exp (q, nm1, k);
 
   mpz_set_ui (a, 2);
@@ -1411,12 +1427,13 @@ mp_prime_p (mpz_t n)
 
   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
      number composite.  */
-  for (unsigned int r = 0; r < PRIMES_PTAB_ENTRIES; r++)
+  for (r = 0; r < PRIMES_PTAB_ENTRIES; r++)
     {
       if (flag_prove_primality)
         {
+          unsigned long int i;
           is_prime = true;
-          for (unsigned long int i = 0; i < factors.nfactors && is_prime; i++)
+          for (i = 0; i < factors.nfactors && is_prime; i++)
             {
               mpz_divexact (tmp, nm1, factors.p[i]);
               mpz_powm (tmp, a, tmp, n);
@@ -1475,6 +1492,7 @@ factor_using_pollard_rho (uintmax_t n, unsigned long int a,
 
       for (;;)
         {
+          unsigned long int i;
           do
             {
               x = mulredc (x, x, n, ni);
@@ -1495,7 +1513,7 @@ factor_using_pollard_rho (uintmax_t n, unsigned long int a,
           z = x;
           k = l;
           l = 2 * l;
-          for (unsigned long int i = 0; i < k; i++)
+          for (i = 0; i < k; i++)
             {
               x = mulredc (x, x, n, ni);
               addmod (x, x, a, n);
@@ -1553,6 +1571,7 @@ factor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,
 
       for (;;)
         {
+          unsigned long int i;
           do
             {
               x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);
@@ -1576,7 +1595,7 @@ factor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,
           z1 = x1; z0 = x0;
           k = l;
           l = 2 * l;
-          for (unsigned long int i = 0; i < k; i++)
+          for (i = 0; i < k; i++)
             {
               x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);
               x1 = r1m;
@@ -1654,6 +1673,8 @@ mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,
 {
   mpz_t x, z, y, P;
   mpz_t t, t2;
+  unsigned long long int k = 1;
+  unsigned long long int l = 1;
 
   devmsg ("[pollard-rho (%lu)] ", a);
 
@@ -1663,13 +1684,11 @@ mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,
   mpz_init_set_si (z, 2);
   mpz_init_set_ui (P, 1);
 
-  unsigned long long int k = 1;
-  unsigned long long int l = 1;
-
   while (mpz_cmp_ui (n, 1) != 0)
     {
       for (;;)
         {
+          unsigned long long int i;
           do
             {
               mpz_mul (t, x, x);
@@ -1693,7 +1712,7 @@ mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,
           mpz_set (z, x);
           k = l;
           l = 2 * l;
-          for (unsigned long long int i = 0; i < k; i++)
+          for (i = 0; i < k; i++)
             {
               mpz_mul (t, x, x);
               mpz_mod (x, t, n);
@@ -1960,13 +1979,14 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
     };
 
   const unsigned int *m;
+  uintmax_t sqrt_n;
 
   struct { uintmax_t Q; uintmax_t P; } queue[QUEUE_SIZE];
 
   if (n1 >= ((uintmax_t) 1 << (W_TYPE_SIZE - 2)))
     return false;
 
-  uintmax_t sqrt_n = isqrt2 (n1, n0);
+  sqrt_n = isqrt2 (n1, n0);
 
   if (n0 == sqrt_n * sqrt_n)
     {
@@ -1982,6 +2002,7 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
           else
             {
               struct factors f;
+              unsigned int i;
 
               f.nfactors = 0;
               if (!factor_using_squfof (0, sqrt_n, &f))
@@ -1990,7 +2011,7 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
                   factor_using_pollard_rho (sqrt_n, 1, &f);
                 }
               /* Duplicate the new factors */
-              for (unsigned int i = 0; i < f.nfactors; i++)
+              for (i = 0; i < f.nfactors; i++)
                 factor_insert_multiplicity (factors, f.p[i], 2*f.e[i]);
             }
           return true;
@@ -2094,7 +2115,9 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
               uintmax_t r = is_square (Q);
               if (r)
                 {
-                  for (unsigned int j = 0; j < qpos; j++)
+                  unsigned int j;
+                  uintmax_t hi, lo;
+                  for (j = 0; j < qpos; j++)
                     {
                       if (queue[j].Q == r)
                         {
@@ -2129,7 +2152,6 @@ factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
                      for the case D = 2N. */
                   /* Compute Q = (D - P*P) / Q1, but we need double
                      precision. */
-                  uintmax_t hi, lo;
                   umul_ppmm (hi, lo, P, P);
                   sub_ddmmss (hi, lo, Dh, Dl, hi, lo);
                   udiv_qrnnd (Q, rem, hi, lo, Q1);
@@ -2255,6 +2277,7 @@ strto2uintmax (uintmax_t *hip, uintmax_t *lop, const char *s)
   uintmax_t hi = 0, lo = 0;
 
   strtol_error err = LONGINT_INVALID;
+  const char *p;
 
   /* Skip initial spaces and '+'.  */
   for (;;)
@@ -2272,7 +2295,7 @@ strto2uintmax (uintmax_t *hip, uintmax_t *lop, const char *s)
     }
 
   /* Initial scan for invalid digits.  */
-  const char *p = s;
+  p = s;
   for (;;)
     {
       unsigned int c = *p++;
@@ -2435,14 +2458,15 @@ static void
 print_factors_single (uintmax_t t1, uintmax_t t0)
 {
   struct factors factors;
+  unsigned int j, k;
 
   print_uintmaxes (t1, t0);
   lbuf_putc (':');
 
   factor (t1, t0, &factors);
 
-  for (unsigned int j = 0; j < factors.nfactors; j++)
-    for (unsigned int k = 0; k < factors.e[j]; k++)
+  for (j = 0; j < factors.nfactors; j++)
+    for (k = 0; k < factors.e[j]; k++)
       {
         lbuf_putc (' ');
         print_uintmaxes (0, factors.p[j]);
@@ -2466,6 +2490,7 @@ static bool
 print_factors (const char *input)
 {
   uintmax_t t1, t0;
+  unsigned int j, k;
 
   /* Try converting the number to one or two words.  If it fails, use GMP or
      print an error message.  The 2nd condition checks that the most
@@ -2503,8 +2528,8 @@ print_factors (const char *input)
   gmp_printf ("%Zd:", t);
   mp_factor (t, &factors);
 
-  for (unsigned int j = 0; j < factors.nfactors; j++)
-    for (unsigned int k = 0; k < factors.e[j]; k++)
+  for (j = 0; j < factors.nfactors; j++)
+    for (k = 0; k < factors.e[j]; k++)
       gmp_printf (" %Zd", factors.p[j]);
 
   mp_factor_clear (&factors);
@@ -2566,6 +2591,8 @@ do_stdin (void)
 int
 main (int argc, char **argv)
 {
+  int c;
+  bool ok;
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
   setlocale (LC_ALL, "");
@@ -2578,7 +2605,6 @@ main (int argc, char **argv)
 
   alg = ALG_POLLARD_RHO;        /* Default to Pollard rho */
 
-  int c;
   while ((c = getopt_long (argc, argv, "", long_options, NULL)) != -1)
     {
       switch (c)
@@ -2609,13 +2635,13 @@ main (int argc, char **argv)
     memset (q_freq, 0, sizeof (q_freq));
 #endif
 
-  bool ok;
   if (argc <= optind)
     ok = do_stdin ();
   else
     {
+      int i;
       ok = true;
-      for (int i = optind; i < argc; i++)
+      for (i = optind; i < argc; i++)
         if (! print_factors (argv[i]))
           ok = false;
     }
@@ -2624,8 +2650,9 @@ main (int argc, char **argv)
   if (alg == ALG_SQUFOF && q_freq[0] > 0)
     {
       double acc_f;
+      unsigned int i;
       printf ("q  freq.  cum. freq.(total: %d)\n", q_freq[0]);
-      for (unsigned int i = 1, acc_f = 0.0; i <= Q_FREQ_SIZE; i++)
+      for (i = 1, acc_f = 0.0; i <= Q_FREQ_SIZE; i++)
         {
           double f = (double) q_freq[i] / q_freq[0];
           acc_f += f;
diff --git a/src/getlimits.c b/src/getlimits.c
index d5af741..6c2b32e 100644
--- a/src/getlimits.c
+++ b/src/getlimits.c
@@ -88,11 +88,12 @@ decimal_absval_add_one (char *buf)
   bool negative = (buf[1] == '-');
   char *absnum = buf + 1 + negative;
   char *p = absnum + strlen (absnum);
+  char *result;
   absnum[-1] = '0';
   while (*--p == '9')
     *p = '0';
   ++*p;
-  char *result = MIN (absnum, p);
+  result = MIN (absnum, p);
   if (negative)
     *--result = '-';
   return result;
diff --git a/src/group-list.c b/src/group-list.c
index 5d7a8f2..c9182f4 100644
--- a/src/group-list.c
+++ b/src/group-list.c
@@ -105,6 +105,7 @@ print_group (gid_t gid, bool use_name)
 {
   struct group *grp = NULL;
   bool ok = true;
+  char *s;
 
   if (use_name)
     {
@@ -117,7 +118,7 @@ print_group (gid_t gid, bool use_name)
         }
     }
 
-  char *s = grp ? grp->gr_name : gidtostr (gid);
+  s = grp ? grp->gr_name : gidtostr (gid);
   fputs (s, stdout);
   return ok;
 }
diff --git a/src/head.c b/src/head.c
index 410cc4f..05c1b7c 100644
--- a/src/head.c
+++ b/src/head.c
@@ -462,6 +462,7 @@ elide_tail_bytes_file (const char *filename, int fd, uintmax_t n_elide,
     return elide_tail_bytes_pipe (filename, fd, n_elide, current_pos);
   else
     {
+      enum Copy_fd_status err;
       /* Be careful here.  The current position may actually be
          beyond the end of the file.  */
       off_t diff = size - current_pos;
@@ -470,7 +471,7 @@ elide_tail_bytes_file (const char *filename, int fd, uintmax_t n_elide,
       if (bytes_remaining <= n_elide)
         return true;
 
-      enum Copy_fd_status err = copy_fd (fd, bytes_remaining - n_elide);
+      err = copy_fd (fd, bytes_remaining - n_elide);
       if (err == COPY_FD_OK)
         return true;
 
@@ -640,6 +641,9 @@ elide_tail_lines_seekable (const char *pretty_filename, int fd,
                            uintmax_t n_lines,
                            off_t start_pos, off_t size)
 {
+  /* n_lines == 0 case needs special treatment. */
+  const bool all_lines = !n_lines;
+
   char buffer[BUFSIZ];
   size_t bytes_read;
   off_t pos = size;
@@ -661,9 +665,6 @@ elide_tail_lines_seekable (const char *pretty_filename, int fd,
       return false;
     }
 
-  /* n_lines == 0 case needs special treatment. */
-  const bool all_lines = !n_lines;
-
   /* Count the incomplete line on files that don't end with a newline.  */
   if (n_lines && bytes_read && buffer[bytes_read - 1] != '\n')
     --n_lines;
diff --git a/src/id.c b/src/id.c
index 26f8e2d..b861b63 100644
--- a/src/id.c
+++ b/src/id.c
@@ -117,6 +117,7 @@ main (int argc, char **argv)
   bool smack_enabled = is_smack_enabled ();
   bool opt_zero = false;
   char *pw_name = NULL;
+  size_t n_ids;
 
   /* If true, output the list of all group IDs. -G */
   bool just_group_list = false;
@@ -126,6 +127,7 @@ main (int argc, char **argv)
   bool use_real = false;
   /* If true, output only the user ID(s). -u */
   bool just_user = false;
+  bool default_format;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -183,7 +185,7 @@ main (int argc, char **argv)
         }
     }
 
-  size_t n_ids = argc - optind;
+  n_ids = argc - optind;
   if (1 < n_ids)
     {
       error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));
@@ -197,7 +199,7 @@ main (int argc, char **argv)
   if (just_user + just_group + just_group_list + just_context > 1)
     error (EXIT_FAILURE, 0, _("cannot print \"only\" of more than one choice"));
 
-  bool default_format = (just_user + just_group + just_group_list
+  default_format = (just_user + just_group + just_group_list
                          + just_context == 0);
 
   if (default_format && (use_real || use_name))
@@ -345,6 +347,7 @@ static void
 print_user (uid_t uid)
 {
   struct passwd *pwd = NULL;
+  char *s;
 
   if (use_name)
     {
@@ -357,7 +360,7 @@ print_user (uid_t uid)
         }
     }
 
-  char *s = pwd ? pwd->pw_name : uidtostr (uid);
+  s = pwd ? pwd->pw_name : uidtostr (uid);
   fputs (s, stdout);
 }
 
@@ -396,6 +399,7 @@ print_full_info (const char *username)
     }
 
   {
+    int n_groups;
     gid_t *groups;
     int i;
 
@@ -405,7 +409,7 @@ print_full_info (const char *username)
     else
       primary_group = egid;
 
-    int n_groups = xgetgroups (username, primary_group, &groups);
+    n_groups = xgetgroups (username, primary_group, &groups);
     if (n_groups < 0)
       {
         if (username)
diff --git a/src/install.c b/src/install.c
index bfde21d..6ddbf17 100644
--- a/src/install.c
+++ b/src/install.c
@@ -197,8 +197,9 @@ need_copy (const char *src_name, const char *dest_name,
 
   if (owner_id == (uid_t) -1)
     {
+      uid_t ruid;
       errno = 0;
-      uid_t ruid = getuid ();
+      ruid = getuid ();
       if ((ruid == (uid_t) -1 && errno) || dest_sb.st_uid != ruid)
         return true;
     }
@@ -207,8 +208,9 @@ need_copy (const char *src_name, const char *dest_name,
 
   if (group_id == (uid_t) -1)
     {
+      gid_t rgid;
       errno = 0;
-      gid_t rgid = getgid ();
+      rgid = getgid ();
       if ((rgid == (uid_t) -1 && errno) || dest_sb.st_gid != rgid)
         return true;
     }
diff --git a/src/join.c b/src/join.c
index 52e4b18..9717a34 100644
--- a/src/join.c
+++ b/src/join.c
@@ -661,6 +661,8 @@ join (FILE *fp1, FILE *fp2)
   struct seq seq1, seq2;
   int diff;
   bool eof1, eof2;
+  struct line *line = NULL;
+  bool checktail = false;
 
   fadvise (fp1, FADVISE_SEQUENTIAL);
   fadvise (fp2, FADVISE_SEQUENTIAL);
@@ -769,9 +771,7 @@ join (FILE *fp1, FILE *fp2)
      tail ends of both inputs to verify that they are in order.  We
      skip the rest of the tail once we have issued a warning for that
      file, unless we actually need to print the unpairable lines.  */
-  struct line *line = NULL;
-  bool checktail = false;
-
+  
   if (check_input_order != CHECK_ORDER_DISABLED
       && !(issued_disorder_warning[0] && issued_disorder_warning[1]))
     checktail = true;
@@ -844,9 +844,10 @@ string_to_join_field (char const *str)
 {
   size_t result;
   unsigned long int val;
+  strtol_error s_err;
   verify (SIZE_MAX <= ULONG_MAX);
 
-  strtol_error s_err = xstrtoul (str, NULL, 10, &val, "");
+  s_err = xstrtoul (str, NULL, 10, &val, "");
   if (s_err == LONGINT_OVERFLOW || (s_err == LONGINT_OK && SIZE_MAX < val))
     val = SIZE_MAX;
   else if (s_err != LONGINT_OK || val == 0)
diff --git a/src/ls.c b/src/ls.c
index 19e1fae..c7b8be8 100644
--- a/src/ls.c
+++ b/src/ls.c
@@ -1057,13 +1057,14 @@ static size_t
 abmon_init (void)
 {
 #ifdef HAVE_NL_LANGINFO
-  required_mon_width = MAX_MON_WIDTH;
   size_t curr_max_width;
+  required_mon_width = MAX_MON_WIDTH;
   do
     {
+      int i;
       curr_max_width = required_mon_width;
       required_mon_width = 0;
-      for (int i = 0; i < 12; i++)
+      for (i = 0; i < 12; i++)
         {
           size_t width = curr_max_width;
 
@@ -2039,6 +2040,7 @@ decode_switches (int argc, char **argv)
                                     sizeof (*time_style_types));
           if (res < 0)
             {
+              char const *const *p;
               /* This whole block used to be a simple use of XARGMATCH.
                  but that didn't print the "posix-"-prefixed variants or
                  the "+"-prefixed format string option upon failure.  */
@@ -2050,7 +2052,7 @@ decode_switches (int argc, char **argv)
                  only because all four existing time_style_types values
                  are distinct.  */
               fputs (_("Valid arguments are:\n"), stderr);
-              char const *const *p = time_style_args;
+              p = time_style_args;
               while (*p)
                 fprintf (stderr, "  - [posix-]%s\n", *p++);
               fputs (_("  - +FORMAT (e.g., +%H:%M) for a 'date'-style"
@@ -2321,10 +2323,10 @@ static bool
 known_term_type (void)
 {
   char const *term = getenv ("TERM");
+  char const *line = G_line;
   if (! term || ! *term)
     return false;
 
-  char const *line = G_line;
   while (line - G_line < sizeof (G_line))
     {
       if (STRNCMP_LIT (line, "TERM ") == 0)
@@ -2346,6 +2348,7 @@ parse_ls_color (void)
   int ind_no;			/* Indicator number */
   char label[3];		/* Indicator label */
   struct color_ext_type *ext;	/* Extension we are working on */
+  enum parse_state state;
 
   if ((p = getenv ("LS_COLORS")) == NULL || *p == '\0')
     {
@@ -2368,7 +2371,7 @@ parse_ls_color (void)
      advance.  */
   buf = color_buf = xstrdup (p);
 
-  enum parse_state state = PS_START;
+  state = PS_START;
   while (true)
     {
       switch (state)
@@ -2849,13 +2852,14 @@ getfilecon_cache (char const *file, struct fileinfo *f, bool deref)
   /* st_dev of the most recently processed device for which we've
      found that [l]getfilecon fails indicating lack of support.  */
   static dev_t unsupported_device;
+  int r;
 
   if (f->stat.st_dev == unsupported_device)
     {
       errno = ENOTSUP;
       return -1;
     }
-  int r = 0;
+  r = 0;
 #ifdef HAVE_SMACK
   if (is_smack_enabled ())
     r = smack_new_label_from_path (file, "security.SMACK64", deref,
@@ -2879,6 +2883,7 @@ file_has_acl_cache (char const *file, struct fileinfo *f)
   /* st_dev of the most recently processed device for which we've
      found that file_has_acl fails indicating lack of support.  */
   static dev_t unsupported_device;
+  int n;
 
   if (f->stat.st_dev == unsupported_device)
     {
@@ -2889,7 +2894,7 @@ file_has_acl_cache (char const *file, struct fileinfo *f)
   /* Zero errno so that we can distinguish between two 0-returning cases:
      "has-ACL-support, but only a default ACL" and "no ACL support". */
   errno = 0;
-  int n = file_has_acl (file, &f->stat);
+  n = file_has_acl (file, &f->stat);
   if (n <= 0 && errno_unsupported (errno))
     unsupported_device = f->stat.st_dev;
   return n;
@@ -2904,6 +2909,7 @@ has_capability_cache (char const *file, struct fileinfo *f)
   /* st_dev of the most recently processed device for which we've
      found that has_capability fails indicating lack of support.  */
   static dev_t unsupported_device;
+  bool b;
 
   if (f->stat.st_dev == unsupported_device)
     {
@@ -2911,7 +2917,7 @@ has_capability_cache (char const *file, struct fileinfo *f)
       return 0;
     }
 
-  bool b = has_capability (file);
+  b = has_capability (file);
   if ( !b && errno_unsupported (errno))
     unsupported_device = f->stat.st_dev;
   return b;
@@ -3100,9 +3106,10 @@ gobble_file (char const *name, enum filetype type, ino_t inode,
           && (format == long_format || check_symlink_color))
         {
           struct stat linkstats;
+          char *linkname;
 
           get_link_name (absolute_name, f, command_line_arg);
-          char *linkname = make_link_name (absolute_name, f->linkname);
+          linkname = make_link_name (absolute_name, f->linkname);
 
           /* Avoid following symbolic links when possible, ie, when
              they won't be traced and when no indicator is needed.  */
@@ -3256,6 +3263,8 @@ get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
 static char *
 make_link_name (char const *name, char const *linkname)
 {
+  char *p;
+  size_t prefix_len;
   if (!linkname)
     return NULL;
 
@@ -3264,11 +3273,11 @@ make_link_name (char const *name, char const *linkname)
 
   /* The link is to a relative name.  Prepend any leading directory
      in 'name' to the link name.  */
-  size_t prefix_len = dir_len (name);
+  prefix_len = dir_len (name);
   if (prefix_len == 0)
     return xstrdup (linkname);
 
-  char *p = xmalloc (prefix_len + 1 + strlen (linkname) + 1);
+  p = xmalloc (prefix_len + 1 + strlen (linkname) + 1);
 
   /* PREFIX_LEN usually specifies a string not ending in slash.
      In that case, extend it by one, since the next byte *is* a slash.
@@ -3670,6 +3679,7 @@ align_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,
      the replacement is not done.  A malloc here slows ls down by 2%  */
   char rpl_fmt[sizeof (abmon[0]) + 100];
   const char *pb;
+  size_t ret;
   if (required_mon_width && (pb = strstr (fmt, "%b"))
       && 0 <= tm->tm_mon && tm->tm_mon <= 11)
     {
@@ -3683,7 +3693,7 @@ align_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,
           strcpy (pfmt, pb + 2);
         }
     }
-  size_t ret = nstrftime (buf, size, nfmt, tm, __utc, __ns);
+  ret = nstrftime (buf, size, nfmt, tm, __utc, __ns);
   return ret;
 }
 
@@ -3834,6 +3844,7 @@ print_long_format (const struct fileinfo *f)
   char *p;
   struct timespec when_timespec;
   struct tm *when_local;
+  size_t w;
 
   /* Compute the mode string, except remove the trailing space if no
      file in this directory has an ACL or security context.  */
@@ -4023,7 +4034,7 @@ print_long_format (const struct fileinfo *f)
     }
 
   DIRED_FPUTS (buf, stdout, p - buf);
-  size_t w = print_name_with_quoting (f, false, &dired_obstack, p - buf);
+  w = print_name_with_quoting (f, false, &dired_obstack, p - buf);
 
   if (f->filetype == symbolic_link)
     {
@@ -4211,6 +4222,7 @@ print_name_with_quoting (const struct fileinfo *f,
                          struct obstack *stack,
                          size_t start_col)
 {
+  size_t width;
   const char* name = symlink_target ? f->linkname : f->name;
 
   bool used_color_this_time
@@ -4221,7 +4233,7 @@ print_name_with_quoting (const struct fileinfo *f,
   if (stack)
     PUSH_CURRENT_DIRED_POS (stack);
 
-  size_t width = quote_name (stdout, name, filename_quoting_options, NULL);
+  width = quote_name (stdout, name, filename_quoting_options, NULL);
   dired_pos += width;
 
   if (stack)
@@ -4258,6 +4270,7 @@ prep_non_filename_text (void)
 static size_t
 print_file_name_and_frills (const struct fileinfo *f, size_t start_col)
 {
+  size_t width;
   char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
 
   set_normal_color ();
@@ -4275,7 +4288,7 @@ print_file_name_and_frills (const struct fileinfo *f, size_t start_col)
   if (print_scontext)
     printf ("%*s ", format == with_commas ? 0 : scontext_width, f->scontext);
 
-  size_t width = print_name_with_quoting (f, false, NULL, start_col);
+  width = print_name_with_quoting (f, false, NULL, start_col);
 
   if (indicator_style != none)
     width += print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
diff --git a/src/md5sum.c b/src/md5sum.c
index bc2b709..3febad5 100644
--- a/src/md5sum.c
+++ b/src/md5sum.c
@@ -233,8 +233,9 @@ static char *
 filename_unescape (char *s, size_t s_len)
 {
   char *dst = s;
+  size_t i;
 
-  for (size_t i = 0; i < s_len; i++)
+  for (i = 0; i < s_len; i++)
     {
       switch (s[i])
         {
@@ -838,6 +839,7 @@ main (int argc, char **argv)
                  containing '\\' characters, we decided to not simplify the
                  output in this case.  */
               bool needs_escape = strchr (file, '\\') || strchr (file, '\n');
+              size_t i;
 
               if (prefix_tag)
                 {
@@ -850,7 +852,6 @@ main (int argc, char **argv)
                   fputs (") = ", stdout);
                 }
 
-              size_t i;
 
               /* Output a leading backslash if the file name contains
                  a newline or backslash.  */
diff --git a/src/mkdir.c b/src/mkdir.c
index ff51ae1..edb756b 100644
--- a/src/mkdir.c
+++ b/src/mkdir.c
@@ -121,17 +121,19 @@ static int
 make_ancestor (char const *dir, char const *component, void *options)
 {
   struct mkdir_options const *o = options;
-
+  mode_t user_wx = S_IWUSR | S_IXUSR;
+  bool self_denying_umask;
+  int r;
+  
   if (o->set_security_context && defaultcon (dir, S_IFDIR) < 0
       && ! ignorable_ctx_err (errno))
     error (0, errno, _("failed to set default creation context for %s"),
            quote (dir));
 
-  mode_t user_wx = S_IWUSR | S_IXUSR;
-  bool self_denying_umask = (o->umask_value & user_wx) != 0;
+  self_denying_umask = (o->umask_value & user_wx) != 0;
   if (self_denying_umask)
     umask (o->umask_value & ~user_wx);
-  int r = mkdir (component, S_IRWXUGO);
+  r = mkdir (component, S_IRWXUGO);
   if (self_denying_umask)
     {
       int mkdir_errno = errno;
@@ -151,6 +153,7 @@ static int
 process_dir (char *dir, struct savewd *wd, void *options)
 {
   struct mkdir_options const *o = options;
+  int ret;
 
   /* If possible set context before DIR created.  */
   if (o->set_security_context)
@@ -161,7 +164,7 @@ process_dir (char *dir, struct savewd *wd, void *options)
                quote (dir));
     }
 
-  int ret = (make_dir_parents (dir, wd, o->make_ancestor_function, options,
+  ret = (make_dir_parents (dir, wd, o->make_ancestor_function, options,
                                o->mode, announce_mkdir,
                                o->mode_bits, (uid_t) -1, (gid_t) -1, true)
              ? EXIT_SUCCESS
diff --git a/src/nohup.c b/src/nohup.c
index 8cdaced..7928c03 100644
--- a/src/nohup.c
+++ b/src/nohup.c
@@ -85,6 +85,8 @@ main (int argc, char **argv)
   bool stdout_is_closed;
   bool redirecting_stderr;
   int exit_internal_failure;
+  char **cmd;
+  int exit_status, saved_errno;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -215,10 +217,10 @@ main (int argc, char **argv)
 
   signal (SIGHUP, SIG_IGN);
 
-  char **cmd = argv + optind;
+  cmd = argv + optind;
   execvp (*cmd, cmd);
-  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
-  int saved_errno = errno;
+  exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
+  saved_errno = errno;
 
   /* The execve failed.  Output a diagnostic to stderr only if:
      - stderr was initially redirected to a non-tty, or
diff --git a/src/nproc.c b/src/nproc.c
index 63c78cd..3571c6c 100644
--- a/src/nproc.c
+++ b/src/nproc.c
@@ -76,6 +76,7 @@ int
 main (int argc, char **argv)
 {
   unsigned long nproc, ignore = 0;
+  enum nproc_query mode = NPROC_CURRENT_OVERRIDABLE;
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
   setlocale (LC_ALL, "");
@@ -84,8 +85,7 @@ main (int argc, char **argv)
 
   atexit (close_stdout);
 
-  enum nproc_query mode = NPROC_CURRENT_OVERRIDABLE;
-
+  
   while (1)
     {
       int c = getopt_long (argc, argv, "", longopts, NULL);
diff --git a/src/numfmt.c b/src/numfmt.c
index 35c5c5b..a754700 100644
--- a/src/numfmt.c
+++ b/src/numfmt.c
@@ -546,9 +546,11 @@ simple_strtod_float (const char *input_str,
       char *ptr2;
       long double val_frac = 0;
       bool neg_frac;
+      size_t exponent;
+      enum simple_strtod_error e2;
 
       (*endptr) += decimal_point_length;
-      enum simple_strtod_error e2 =
+      e2 =
         simple_strtod_int (*endptr, &ptr2, &val_frac, &neg_frac);
       if (e2 != SSE_OK && e2 != SSE_OK_PRECISION_LOSS)
         return e2;
@@ -558,7 +560,7 @@ simple_strtod_float (const char *input_str,
         return SSE_INVALID_NUMBER;
 
       /* number of digits in the fractions.  */
-      size_t exponent = ptr2 - *endptr;
+      exponent = ptr2 - *endptr;
 
       val_frac = ((long double) val_frac) / powerld (10, exponent);
 
@@ -607,6 +609,8 @@ simple_strtod_human (const char *input_str,
   int power = 0;
   /* 'scale_auto' is checked below.  */
   int scale_base = default_scale_base (allowed_scaling);
+  enum simple_strtod_error e;
+  long double multiplier;
 
   devmsg ("simple_strtod_human:\n  input string: %s\n"
           "  locale decimal-point: %s\n"
@@ -615,7 +619,7 @@ simple_strtod_human (const char *input_str,
           quote_n (1, decimal_point),
           MAX_UNSCALED_DIGITS);
 
-  enum simple_strtod_error e =
+  e =
     simple_strtod_float (input_str, endptr, value, precision);
   if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)
     return e;
@@ -661,7 +665,7 @@ simple_strtod_human (const char *input_str,
         return SSE_MISSING_I_SUFFIX;
     }
 
-  long double multiplier = powerld (scale_base, power);
+  multiplier = powerld (scale_base, power);
 
   devmsg ("  suffix power=%d^%d = %Lf\n", scale_base, power, multiplier);
 
@@ -718,13 +722,20 @@ double_to_human (long double val, int precision,
                  char *buf, size_t buf_size,
                  enum scale_type scale, int group, enum round_type round)
 {
+  double scale_base;
+  int ten_or_less = 0;
+  int show_decimal_point;
+  unsigned int power = 0;
+  unsigned int power_adjust;
+  int prec;
+  char *pfmt;
   int num_size;
   char fmt[64];
   verify (sizeof (fmt) > (INT_BUFSIZE_BOUND (zero_padding_width)
                           + INT_BUFSIZE_BOUND (precision)
                           + 10 /* for %.Lf  etc.  */));
 
-  char *pfmt = fmt;
+  pfmt = fmt;
   *pfmt++ = '%';
 
   if (group)
@@ -755,15 +766,15 @@ double_to_human (long double val, int precision,
     }
 
   /* Scaling requested by user. */
-  double scale_base = default_scale_base (scale);
+  scale_base = default_scale_base (scale);
 
   /* Normalize val to scale. */
-  unsigned int power = 0;
+  power = 0;
   val = expld (val, scale_base, &power);
   devmsg ("  scaled value to %Lf * %0.f ^ %u\n", val, scale_base, power);
 
   /* Perform rounding. */
-  unsigned int power_adjust = 0;
+  power_adjust = 0;
   if (user_precision != -1)
     power_adjust = MIN (power * 3, user_precision);
   else if (absld (val) < 10)
@@ -788,14 +799,14 @@ double_to_human (long double val, int precision,
 
   /* should "7.0" be printed as "7" ?
      if removing the ".0" is preferred, enable the fourth condition.  */
-  int show_decimal_point = (val != 0) && (absld (val) < 10) && (power > 0);
+  show_decimal_point = (val != 0) && (absld (val) < 10) && (power > 0);
   /* && (absld (val) > simple_round_floor (val))) */
 
   devmsg ("  after rounding, value=%Lf * %0.f ^ %u\n", val, scale_base, power);
 
   stpcpy (pfmt, ".*Lf%s");
 
-  int prec = user_precision == -1 ? show_decimal_point : user_precision;
+  prec = user_precision == -1 ? show_decimal_point : user_precision;
 
   /* buf_size - 1 used here to ensure place for possible scale_IEC_I suffix.  */
   num_size = snprintf (buf, buf_size - 1, fmt, prec, val,
@@ -1264,6 +1275,10 @@ static int
 process_suffixed_number (char *text, long double *result,
                          size_t *precision, long int field)
 {
+  char *p;
+  long double val = 0;
+  enum simple_strtod_error e;
+  unsigned int skip_count;
   if (suffix && strlen (text) > strlen (suffix))
     {
       char *possible_suffix = text + strlen (text) - strlen (suffix);
@@ -1279,10 +1294,10 @@ process_suffixed_number (char *text, long double *result,
     }
 
   /* Skip white space - always.  */
-  char *p = text;
+  p = text;
   while (*p && isblank (to_uchar (*p)))
     ++p;
-  const unsigned int skip_count = text - p;
+  skip_count = text - p;
 
   /* setup auto-padding.  */
   if (auto_padding)
@@ -1299,8 +1314,7 @@ process_suffixed_number (char *text, long double *result,
      devmsg ("setting Auto-Padding to %ld characters\n", padding_width);
     }
 
-  long double val = 0;
-  enum simple_strtod_error e = parse_human_number (p, &val, precision);
+  e = parse_human_number (p, &val, precision);
   if (e == SSE_OK_PRECISION_LOSS && debug)
     error (0, 0, _("large input value %s: possible precision loss"),
            quote (p));
@@ -1495,7 +1509,7 @@ include_field (size_t field)
   if (! field_list)
     return field == 1;
 
-  return gl_sortedlist_search (field_list, match_field, &field);
+  return gl_sortedlist_search (field_list, match_field, &field) != NULL;
 }
 
 /* Convert and output the given field. If it is not included in the set
@@ -1571,6 +1585,7 @@ int
 main (int argc, char **argv)
 {
   int valid_numbers = 1;
+  int exit_status;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1769,7 +1784,7 @@ main (int argc, char **argv)
   if (debug && !valid_numbers)
     error (0, 0, _("failed to convert some of the input numbers"));
 
-  int exit_status = EXIT_SUCCESS;
+  exit_status = EXIT_SUCCESS;
   if (!valid_numbers
       && inval_style != inval_warn && inval_style != inval_ignore)
     exit_status = EXIT_CONVERSION_WARNINGS;
diff --git a/src/od.c b/src/od.c
index 0ca3ca7..0583075 100644
--- a/src/od.c
+++ b/src/od.c
@@ -451,7 +451,7 @@ N (size_t fields, size_t blank, void const *block,                      \
       else                                                              \
         x = *p;                                                         \
       p++;                                                              \
-      ACTION;                                                           \
+      { ACTION; }                                                       \
       pad_remaining = next_pad;                                         \
     }                                                                   \
 }
diff --git a/src/realpath.c b/src/realpath.c
index d1fca7b..ca24f0c 100644
--- a/src/realpath.c
+++ b/src/realpath.c
@@ -101,8 +101,9 @@ realpath_canon (const char *fname, int can_mode)
   char *can_fname = canonicalize_filename_mode (fname, can_mode);
   if (logical && can_fname)  /* canonicalize again to resolve symlinks.  */
     {
+      char *can_fname2;
       can_mode &= ~CAN_NOLINKS;
-      char *can_fname2 = canonicalize_filename_mode (can_fname, can_mode);
+      can_fname2 = canonicalize_filename_mode (can_fname, can_mode);
       free (can_fname);
       return can_fname2;
     }
@@ -176,6 +177,7 @@ main (int argc, char **argv)
   int can_mode = CAN_ALL_BUT_LAST;
   const char *relative_to = NULL;
   const char *relative_base = NULL;
+  bool need_dir;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -240,7 +242,7 @@ main (int argc, char **argv)
   if (relative_base && !relative_to)
     relative_to = relative_base;
 
-  bool need_dir = (can_mode & CAN_MODE_MASK) == CAN_EXISTING;
+  need_dir = (can_mode & CAN_MODE_MASK) == CAN_EXISTING;
   if (relative_to)
     {
       can_relative_to = realpath_canon (relative_to, can_mode);
diff --git a/src/relpath.c b/src/relpath.c
index 5ba4b9c..ad47643 100644
--- a/src/relpath.c
+++ b/src/relpath.c
@@ -88,14 +88,16 @@ bool
 relpath (const char *can_fname, const char *can_reldir, char *buf, size_t len)
 {
   bool buf_err = false;
+  const char *relto_suffix;
+  const char *fname_suffix;
 
   /* Skip the prefix common to --relative-to and path.  */
   int common_index = path_common_prefix (can_reldir, can_fname);
   if (!common_index)
     return false;
 
-  const char *relto_suffix = can_reldir + common_index;
-  const char *fname_suffix = can_fname + common_index;
+  relto_suffix = can_reldir + common_index;
+  fname_suffix = can_fname + common_index;
 
   /* Skip over extraneous '/'.  */
   if (*relto_suffix == '/')
diff --git a/src/remove.c b/src/remove.c
index e913ce3..818e8e0 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -180,17 +180,20 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
   int fd_cwd = fts->fts_cwd_fd;
   char const *full_name = ent->fts_path;
   char const *filename = ent->fts_accpath;
+  struct stat st;
+  struct stat *sbuf;
+  int dirent_type;
+  int write_protected = 0;
+  bool is_empty = false;
+  int wp_errno = 0;
   if (is_empty_p)
     *is_empty_p = T_UNKNOWN;
 
-  struct stat st;
-  struct stat *sbuf = &st;
+  sbuf = &st;
   cache_stat_init (sbuf);
 
-  int dirent_type = is_dir ? DT_DIR : DT_UNKNOWN;
-  int write_protected = 0;
-
-  bool is_empty = false;
+  dirent_type = is_dir ? DT_DIR : DT_UNKNOWN;
+  
   if (is_empty_p)
     {
       is_empty = is_empty_dir (fd_cwd, filename);
@@ -206,7 +209,6 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
   if (x->interactive == RMI_NEVER)
     return RM_OK;
 
-  int wp_errno = 0;
   if (!x->ignore_missing_files
       && ((x->interactive == RMI_ALWAYS) || x->stdin_tty)
       && dirent_type != DT_LNK)
@@ -217,6 +219,7 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
 
   if (write_protected || errno || x->interactive == RMI_ALWAYS)
     {
+      char const *quoted_name;
       if (0 <= write_protected && dirent_type == DT_UNKNOWN)
         {
           if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) == 0)
@@ -256,7 +259,7 @@ prompt (FTS const *fts, FTSENT const *ent, bool is_dir,
             break;
           }
 
-      char const *quoted_name = quote (full_name);
+      quoted_name = quote (full_name);
 
       if (write_protected < 0)
         {
@@ -493,6 +496,8 @@ rm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)
     case FTS_NSOK:		/* e.g., dangling symlink */
     case FTS_DEFAULT:		/* none of the above */
       {
+        bool is_dir;
+        enum RM_status s;
         /* With --one-file-system, do not attempt to remove a mount point.
            fts' FTS_XDEV ensures that we don't process any entries under
            the mount point.  */
@@ -507,8 +512,8 @@ rm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)
             return RM_ERROR;
           }
 
-        bool is_dir = ent->fts_info == FTS_DP || ent->fts_info == FTS_DNR;
-        enum RM_status s = prompt (fts, ent, is_dir, x, PA_REMOVE_DIR, NULL);
+        is_dir = ent->fts_info == FTS_DP || ent->fts_info == FTS_DNR;
+        s = prompt (fts, ent, is_dir, x, PA_REMOVE_DIR, NULL);
         if (s != RM_OK)
           return s;
         return excise (fts, ent, x, is_dir);
@@ -549,15 +554,17 @@ rm (char *const *file, struct rm_options const *x)
       int bit_flags = (FTS_CWDFD
                        | FTS_NOSTAT
                        | FTS_PHYSICAL);
+      FTS *fts;
 
       if (x->one_file_system)
         bit_flags |= FTS_XDEV;
 
-      FTS *fts = xfts_open (file, bit_flags, NULL);
+      fts = xfts_open (file, bit_flags, NULL);
 
       while (1)
         {
           FTSENT *ent;
+          enum RM_status s;
 
           ent = fts_read (fts);
           if (ent == NULL)
@@ -570,7 +577,7 @@ rm (char *const *file, struct rm_options const *x)
               break;
             }
 
-          enum RM_status s = rm_fts (fts, ent, x);
+          s = rm_fts (fts, ent, x);
 
           assert (VALID_STATUS (s));
           UPDATE_STATUS (rm_status, s);
diff --git a/src/rm.c b/src/rm.c
index c1a23d5..53c7a78 100644
--- a/src/rm.c
+++ b/src/rm.c
@@ -209,6 +209,9 @@ main (int argc, char **argv)
   struct rm_options x;
   bool prompt_once = false;
   int c;
+  uintmax_t n_files;
+  char **file;
+  enum RM_status status;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -332,8 +335,8 @@ main (int argc, char **argv)
                quote ("/"));
     }
 
-  uintmax_t n_files = argc - optind;
-  char **file =  argv + optind;
+  n_files = argc - optind;
+  file =  argv + optind;
 
   if (prompt_once && (x.recursive || 3 < n_files))
     {
@@ -350,7 +353,7 @@ main (int argc, char **argv)
         return EXIT_SUCCESS;
     }
 
-  enum RM_status status = rm (file, &x);
+  status = rm (file, &x);
   assert (VALID_STATUS (status));
   return status == RM_ERROR ? EXIT_FAILURE : EXIT_SUCCESS;
 }
diff --git a/src/runcon.c b/src/runcon.c
index 5b9cb33..9cfa331 100644
--- a/src/runcon.c
+++ b/src/runcon.c
@@ -119,6 +119,7 @@ main (int argc, char **argv)
   char *file_context = NULL;
   char *new_context = NULL;
   bool compute_trans = false;
+  int exit_status;
 
   context_t con;
 
@@ -258,7 +259,7 @@ main (int argc, char **argv)
 
   execvp (argv[optind], argv + optind);
 
-  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
+  exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
   error (0, errno, "%s", argv[optind]);
   return exit_status;
 }
diff --git a/src/seq.c b/src/seq.c
index 2426c4d..8952488 100644
--- a/src/seq.c
+++ b/src/seq.c
@@ -136,6 +136,7 @@ static operand
 scan_arg (const char *arg)
 {
   operand ret;
+  char const *decimal_point;
 
   if (! xstrtold (arg, NULL, &ret.value, c_strtold))
     {
@@ -152,7 +153,7 @@ scan_arg (const char *arg)
   ret.precision = INT_MAX;
 
   /* Use no precision (and possibly fast generation) for integers.  */
-  char const *decimal_point = strchr (arg, '.');
+  decimal_point = strchr (arg, '.');
   if (! decimal_point && ! strchr (arg, 'p') /* not a hex float */)
     ret.precision = 0;
 
@@ -160,6 +161,7 @@ scan_arg (const char *arg)
   if (! arg[strcspn (arg, "xX")] && isfinite (ret.value))
     {
       size_t fraction_len = 0;
+      char const *e;
       ret.width = strlen (arg);
 
       if (decimal_point)
@@ -172,7 +174,7 @@ scan_arg (const char *arg)
                         : (decimal_point == arg                /* .#  -> 0.# */
                            || ! ISDIGIT (decimal_point[-1]))); /* -.# -> 0.# */
         }
-      char const *e = strchr (arg, 'e');
+      e = strchr (arg, 'e');
       if (! e)
         e = strchr (arg, 'E');
       if (e)
@@ -344,6 +346,7 @@ get_default_format (operand first, operand step, operand last)
     {
       if (equal_width)
         {
+          size_t width;
           /* increase first_width by any increased precision in step */
           size_t first_width = first.width + (prec - first.precision);
           /* adjust last_width to use precision from first/step */
@@ -354,7 +357,7 @@ get_default_format (operand first, operand step, operand last)
             last_width++;  /* include space for '.' */
           if (first.precision == 0 && prec)
             first_width++;  /* include space for '.' */
-          size_t width = MAX (first_width, last_width);
+          width = MAX (first_width, last_width);
           if (width <= INT_MAX)
             {
               int w = width;
@@ -426,24 +429,25 @@ static bool
 seq_fast (char const *a, char const *b)
 {
   bool inf = STREQ (b, "inf");
+  size_t p_len, q_len, inc_size;
+  char *p0, *p, *q, *q0;
+  bool ok;
 
   /* Skip past any leading 0's.  Without this, our naive cmp
      function would declare 000 to be larger than 99.  */
   a = trim_leading_zeros (a);
   b = trim_leading_zeros (b);
 
-  size_t p_len = strlen (a);
-  size_t q_len = inf ? 0 : strlen (b);
+  p_len = strlen (a);
+  q_len = inf ? 0 : strlen (b);
 
   /* Allow for at least 31 digits without realloc.
      1 more than p_len is needed for the inf case.  */
-  size_t inc_size = MAX (MAX (p_len + 1, q_len), 31);
+  inc_size = MAX (MAX (p_len + 1, q_len), 31);
 
   /* Copy input strings (incl NUL) to end of new buffers.  */
-  char *p0 = xmalloc (inc_size + 1);
-  char *p = memcpy (p0 + inc_size - p_len, a, p_len + 1);
-  char *q;
-  char *q0;
+  p0 = xmalloc (inc_size + 1);
+  p = memcpy (p0 + inc_size - p_len, a, p_len + 1);
   if (! inf)
     {
       q0 = xmalloc (inc_size + 1);
@@ -452,7 +456,7 @@ seq_fast (char const *a, char const *b)
   else
     q = q0 = NULL;
 
-  bool ok = inf || cmp (p, p_len, q, q_len) <= 0;
+  ok = inf || cmp (p, p_len, q, q_len) <= 0;
   if (ok)
     {
       /* Reduce number of fwrite calls which is seen to
@@ -531,6 +535,7 @@ main (int argc, char **argv)
 
   /* The printf(3) format used for output.  */
   char const *format_str = NULL;
+  unsigned int n_args;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -582,7 +587,7 @@ main (int argc, char **argv)
         }
     }
 
-  unsigned int n_args = argc - optind;
+  n_args = argc - optind;
   if (n_args < 1)
     {
       error (0, 0, _("missing operand"));
diff --git a/src/shred.c b/src/shred.c
index 63bcd6f..49a1a3e 100644
--- a/src/shred.c
+++ b/src/shred.c
@@ -256,11 +256,12 @@ to be recovered later.\n\
 static bool
 periodic_pattern (int type)
 {
+  unsigned char r[3];
+  unsigned int bits;
   if (type <= 0)
     return false;
 
-  unsigned char r[3];
-  unsigned int bits = type & 0xfff;
+  bits = type & 0xfff;
 
   bits |= bits << 12;
   r[0] = (bits >> 4) & 255;
@@ -388,6 +389,7 @@ direct_mode (int fd, bool enable)
 static bool
 dorewind (int fd, struct stat const *st)
 {
+  off_t offset;
   if (S_ISCHR (st->st_mode))
     {
 #ifdef __linux__
@@ -401,7 +403,7 @@ dorewind (int fd, struct stat const *st)
         return true;
 #endif
     }
-  off_t offset = lseek (fd, 0, SEEK_SET);
+  offset = lseek (fd, 0, SEEK_SET);
   if (0 < offset)
     errno = EINVAL;
   return offset == 0;
@@ -429,32 +431,37 @@ dopass (int fd, struct stat const *st, char const *qname, off_t *sizep,
   size_t lim;			/* Amount of data to try writing */
   size_t soff;			/* Offset into buffer for next write */
   ssize_t ssize;		/* Return value from write */
+  size_t output_size;
+  void *fill_pattern_mem;
+  unsigned char *pbuf;
+
+  char pass_string[PASS_NAME_SIZE];	/* Name of current pass */
+  bool write_error = false;
+  bool other_error = false;
+
+  /* Printable previous offset into the file */
+  char previous_offset_buf[LONGEST_HUMAN_READABLE + 1];
+  char const *previous_human_offset IF_LINT ( = 0);
+  
+  bool try_without_directio;
 
   /* Fill pattern buffer.  Aligning it to a page so we can do direct I/O.  */
   size_t page_size = getpagesize ();
 #define PERIODIC_OUTPUT_SIZE (60 * 1024)
 #define NONPERIODIC_OUTPUT_SIZE (64 * 1024)
   verify (PERIODIC_OUTPUT_SIZE % 3 == 0);
-  size_t output_size = periodic_pattern (type)
+  output_size = periodic_pattern (type)
                        ? PERIODIC_OUTPUT_SIZE : NONPERIODIC_OUTPUT_SIZE;
 #define PAGE_ALIGN_SLOP (page_size - 1)                /* So directio works */
 #define FILLPATTERN_SIZE (((output_size + 2) / 3) * 3) /* Multiple of 3 */
 #define PATTERNBUF_SIZE (PAGE_ALIGN_SLOP + FILLPATTERN_SIZE)
-  void *fill_pattern_mem = xmalloc (PATTERNBUF_SIZE);
-  unsigned char *pbuf = ptr_align (fill_pattern_mem, page_size);
-
-  char pass_string[PASS_NAME_SIZE];	/* Name of current pass */
-  bool write_error = false;
-  bool other_error = false;
-
-  /* Printable previous offset into the file */
-  char previous_offset_buf[LONGEST_HUMAN_READABLE + 1];
-  char const *previous_human_offset IF_LINT ( = 0);
+  fill_pattern_mem = xmalloc (PATTERNBUF_SIZE);
+  pbuf = ptr_align (fill_pattern_mem, page_size);
 
   /* As a performance tweak, avoid direct I/O for small sizes,
      as it's just a performance rather then security consideration,
      and direct I/O can often be unsupported for small non aligned sizes.  */
-  bool try_without_directio = 0 < size && size < output_size;
+  try_without_directio = 0 < size && size < output_size;
   if (! try_without_directio)
     direct_mode (fd, true);
 
@@ -488,6 +495,7 @@ dopass (int fd, struct stat const *st, char const *qname, off_t *sizep,
   offset = 0;
   while (true)
     {
+      bool done;
       /* How much to write this time? */
       lim = output_size;
       if (0 <= size && size - offset < output_size)
@@ -567,7 +575,7 @@ dopass (int fd, struct stat const *st, char const *qname, off_t *sizep,
 
       offset += soff;
 
-      bool done = offset == size;
+      done = offset == size;
 
       /* Time to print progress? */
       if (n && ((done && *previous_human_offset)
diff --git a/src/shuf.c b/src/shuf.c
index ff2337d..c86457d 100644
--- a/src/shuf.c
+++ b/src/shuf.c
@@ -150,6 +150,7 @@ static off_t
 input_size (void)
 {
   off_t file_size;
+  off_t input_offset;
 
   struct stat stat_buf;
   if (fstat (STDIN_FILENO, &stat_buf) != 0)
@@ -159,7 +160,7 @@ input_size (void)
   else
     return OFF_T_MAX;
 
-  off_t input_offset = lseek (STDIN_FILENO, 0, SEEK_CUR);
+  input_offset = lseek (STDIN_FILENO, 0, SEEK_CUR);
   if (input_offset < 0)
     return OFF_T_MAX;
 
diff --git a/src/sort.c b/src/sort.c
index 85fc38f..8417681 100644
--- a/src/sort.c
+++ b/src/sort.c
@@ -763,9 +763,10 @@ static bool
 delete_proc (pid_t pid)
 {
   struct tempnode test;
+  struct tempnode *node;
 
   test.pid = pid;
-  struct tempnode *node = hash_delete (proctab, &test);
+  node = hash_delete (proctab, &test);
   if (! node)
     return false;
   node->state = REAPED;
@@ -1161,6 +1162,7 @@ open_temp (struct tempnode *temp)
 {
   int tempfd, pipefds[2];
   FILE *fp = NULL;
+  pid_t child;
 
   if (temp->state == UNREAPED)
     wait_proc (temp->pid);
@@ -1169,7 +1171,7 @@ open_temp (struct tempnode *temp)
   if (tempfd < 0)
     return NULL;
 
-  pid_t child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);
+  child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);
 
   switch (child)
     {
@@ -1445,6 +1447,7 @@ specify_nthreads (int oi, char c, char const *s)
 static size_t
 default_sort_size (void)
 {
+  double avail, total, mem;
   /* Let SIZE be MEM, but no more than the maximum object size,
      total memory, or system resource limits.  Don't bother to check
      for values like RLIM_INFINITY since in practice they are not much
@@ -1471,9 +1474,9 @@ default_sort_size (void)
 
   /* Let MEM be available memory or 1/8 of total memory, whichever
      is greater.  */
-  double avail = physmem_available ();
-  double total = physmem_total ();
-  double mem = MAX (avail, total / 8);
+  avail = physmem_available ();
+  total = physmem_total ();
+  mem = MAX (avail, total / 8);
 
   /* Leave a 1/4 margin for physical memory.  */
   if (total * 0.75 < size)
@@ -1930,12 +1933,13 @@ find_unit_order (char const *number)
 static int
 human_numcompare (char const *a, char const *b)
 {
+  int diff;
   while (blanks[to_uchar (*a)])
     a++;
   while (blanks[to_uchar (*b)])
     b++;
 
-  int diff = find_unit_order (a) - find_unit_order (b);
+  diff = find_unit_order (a) - find_unit_order (b);
   return (diff ? diff : strnumcmp (a, b, decimal_point, thousands_sep));
 }
 
@@ -1962,10 +1966,10 @@ static int
 nan_compare (char const *sa, char const *sb)
 {
   long_double a;
+  long_double b;
   memset (&a, 0, sizeof a);
   a = strtold (sa, NULL);
 
-  long_double b;
   memset (&b, 0, sizeof b);
   b = strtold (sb, NULL);
 
@@ -2067,9 +2071,9 @@ random_md5_state_init (char const *random_source)
 static size_t
 xstrxfrm (char *restrict dest, char const *restrict src, size_t destsize)
 {
-  errno = 0;
   size_t translated_size = strxfrm (dest, src, destsize);
-
+  errno = 0;
+  
   if (errno)
     {
       error (0, errno, _("string transformation failed"));
@@ -2102,6 +2106,7 @@ compare_random (char *restrict texta, size_t lena,
   void *allocated = NULL;
   uint32_t dig[2][MD5_DIGEST_SIZE / sizeof (uint32_t)];
   struct md5_ctx s[2];
+  int diff;
   s[0] = s[1] = random_md5_state;
 
   if (hard_LC_COLLATE)
@@ -2127,6 +2132,8 @@ compare_random (char *restrict texta, size_t lena,
              twice on typical implementations.  Don't worry about
              size_t overflow, as the guess need not be correct.  */
           size_t guess_bufsize = 3 * (lena + lenb) + 2;
+          size_t sizea, sizeb;
+          bool a_fits;
           if (bufsize < guess_bufsize)
             {
               bufsize = MAX (guess_bufsize, bufsize * 3 / 2);
@@ -2139,10 +2146,10 @@ compare_random (char *restrict texta, size_t lena,
                 }
             }
 
-          size_t sizea =
+          sizea =
             (texta < lima ? xstrxfrm (buf, texta, bufsize) + 1 : 0);
-          bool a_fits = sizea <= bufsize;
-          size_t sizeb =
+          a_fits = sizea <= bufsize;
+          sizeb =
             (textb < limb
              ? (xstrxfrm ((a_fits ? buf + sizea : NULL), textb,
                           (a_fits ? bufsize - sizea : 0))
@@ -2195,7 +2202,7 @@ compare_random (char *restrict texta, size_t lena,
   /* Compute and compare the checksums.  */
   md5_process_bytes (texta, lena, &s[0]); md5_finish_ctx (&s[0], dig[0]);
   md5_process_bytes (textb, lenb, &s[1]); md5_finish_ctx (&s[1], dig[1]);
-  int diff = memcmp (dig[0], dig[1], sizeof dig[0]);
+  diff = memcmp (dig[0], dig[1], sizeof dig[0]);
 
   /* Fall back on the tiebreaker if the checksums collide.  */
   if (! diff)
@@ -2266,6 +2273,7 @@ debug_key (struct line const *line, struct keyfield const *key)
   char *text = line->text;
   char *beg = text;
   char *lim = text + line->length - 1;
+  size_t offset, width;
 
   if (key)
     {
@@ -2277,12 +2285,13 @@ debug_key (struct line const *line, struct keyfield const *key)
       if (key->skipsblanks || key->month || key_numeric (key))
         {
           char saved = *lim;
+          char *tighter_lim;
           *lim = '\0';
 
           while (blanks[to_uchar (*beg)])
             beg++;
 
-          char *tighter_lim = beg;
+          tighter_lim = beg;
 
           if (lim < beg)
             tighter_lim = lim;
@@ -2318,8 +2327,8 @@ debug_key (struct line const *line, struct keyfield const *key)
         }
     }
 
-  size_t offset = debug_width (text, beg);
-  size_t width = debug_width (beg, lim);
+  offset = debug_width (text, beg);
+  width = debug_width (beg, lim);
   mark_key (offset, width);
 }
 
@@ -2393,6 +2402,7 @@ key_warnings (struct keyfield const *gkey, bool gkey_only)
 
   for (key = keylist; key; key = key->next, keynum++)
     {
+      bool implicit_skip, maybe_space_aligned, line_offset;
       if (key->obsolete_used)
         {
           size_t sword = key->sword;
@@ -2427,10 +2437,10 @@ key_warnings (struct keyfield const *gkey, bool gkey_only)
         error (0, 0, _("key %lu has zero width and will be ignored"), keynum);
 
       /* Warn about significant leading blanks.  */
-      bool implicit_skip = key_numeric (key) || key->month;
-      bool maybe_space_aligned = !hard_LC_COLLATE && default_key_compare (key)
+      implicit_skip = key_numeric (key) || key->month;
+      maybe_space_aligned = !hard_LC_COLLATE && default_key_compare (key)
                                  && !(key->schar || key->echar);
-      bool line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */
+      line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */
       if (!gkey_only && tab == TAB_DEFAULT && !line_offset
           && ((!key->skipsblanks && !(implicit_skip || maybe_space_aligned))
               || (!key->skipsblanks && key->schar)
@@ -2474,10 +2484,10 @@ key_warnings (struct keyfield const *gkey, bool gkey_only)
       || (ugkey.reverse && (stable || unique) && keylist))
     {
       bool ugkey_reverse = ugkey.reverse;
+      char opts[sizeof short_options];
       if (!(stable || unique))
         ugkey.reverse = false;
       /* The following is too big, but guaranteed to be "big enough".  */
-      char opts[sizeof short_options];
       key_to_opts (&ugkey, opts);
       error (0, 0,
              ngettext ("option '-%s' is ignored",
@@ -2508,6 +2518,7 @@ keycompare (struct line const *a, struct line const *b)
 
   while (true)
     {
+      size_t lena, lenb;
       char const *translate = key->translate;
       bool const *ignore = key->ignore;
 
@@ -2516,8 +2527,8 @@ keycompare (struct line const *a, struct line const *b)
       limb = MAX (textb, limb);
 
       /* Find the lengths. */
-      size_t lena = lima - texta;
-      size_t lenb = limb - textb;
+      lena = lima - texta;
+      lenb = limb - textb;
 
       if (hard_LC_COLLATE || key_numeric (key)
           || key->month || key->random || key->version)
@@ -3186,6 +3197,8 @@ sequential_sort (struct line *restrict lines, size_t nlines,
       size_t nhi = nlines - nlo;
       struct line *lo = lines;
       struct line *hi = lines - nlo;
+      struct line *dest;
+      struct line const *sorted_lo;
 
       sequential_sort (hi, nhi, temp - (to_temp ? nlo : 0), to_temp);
       if (1 < nlo)
@@ -3193,8 +3206,6 @@ sequential_sort (struct line *restrict lines, size_t nlines,
       else if (!to_temp)
         temp[-1] = lo[-1];
 
-      struct line *dest;
-      struct line const *sorted_lo;
       if (to_temp)
         {
           dest = temp;
@@ -3828,6 +3839,8 @@ merge (struct sortfile *files, size_t ntemps, size_t nfiles,
   while (true)
     {
       /* Merge directly into the output file if possible.  */
+      FILE *tfp;
+      struct tempnode *temp;
       FILE **fps;
       size_t nopened = open_input_files (files, nfiles, &fps);
 
@@ -3850,8 +3863,6 @@ merge (struct sortfile *files, size_t ntemps, size_t nfiles,
          file with our spare file descriptor.  Retry if that failed
          (e.g., some other process could open a file between the time
          we closed and tried to create).  */
-      FILE *tfp;
-      struct tempnode *temp;
       do
         {
           nopened--;
@@ -3880,10 +3891,10 @@ sort (char *const *files, size_t nfiles, char const *output_file,
       size_t nthreads)
 {
   struct buffer buf;
-  IF_LINT (buf.buf = NULL);
   size_t ntemps = 0;
   bool output_file_created = false;
-
+  IF_LINT (buf.buf = NULL);
+  
   buf.alloc = 0;
 
   while (nfiles)
@@ -3948,8 +3959,9 @@ sort (char *const *files, size_t nfiles, char const *output_file,
           if (1 < buf.nlines)
             {
               struct merge_node_queue queue;
+              struct merge_node *merge_tree;
               queue_init (&queue, nthreads);
-              struct merge_node *merge_tree =
+              merge_tree =
                 merge_tree_init (nthreads, buf.nlines, line);
 
               sortlines (line, nthreads, buf.nlines, merge_tree + 1,
@@ -4729,6 +4741,7 @@ main (int argc, char **argv)
     }
   else
     {
+      size_t nthreads_max;
       if (!nthreads)
         {
           unsigned long int np = num_processors (NPROC_CURRENT_OVERRIDABLE);
@@ -4736,7 +4749,7 @@ main (int argc, char **argv)
         }
 
       /* Avoid integer overflow later.  */
-      size_t nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));
+      nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));
       nthreads = MIN (nthreads, nthreads_max);
 
       sort (files, nfiles, outfile, nthreads);
diff --git a/src/split.c b/src/split.c
index 35f2629..083cdd7 100644
--- a/src/split.c
+++ b/src/split.c
@@ -174,6 +174,8 @@ set_suffix_length (uintmax_t n_units, enum Split_type split_type)
   if (split_type == type_chunk_bytes || split_type == type_chunk_lines
       || split_type == type_rr)
     {
+      size_t alphabet_len;
+      bool alphabet_slop;
       uintmax_t n_units_end = n_units;
       if (numeric_suffix_start)
         {
@@ -191,8 +193,8 @@ set_suffix_length (uintmax_t n_units, enum Split_type split_type)
             }
 
         }
-      size_t alphabet_len = strlen (suffix_alphabet);
-      bool alphabet_slop = (n_units_end % alphabet_len) != 0;
+      alphabet_len = strlen (suffix_alphabet);
+      alphabet_slop = (n_units_end % alphabet_len) != 0;
       while (n_units_end /= alphabet_len)
         suffix_needed++;
       suffix_needed += alphabet_slop;
@@ -362,14 +364,15 @@ new_name:
 
       if (numeric_suffix_start)
         {
-          assert (! widen);
-
+          size_t *sufindex_end;
+          
           /* Update the output file name.  */
           size_t i = strlen (numeric_suffix_start);
+          assert (! widen);
           memcpy (outfile_mid + suffix_length - i, numeric_suffix_start, i);
 
           /* Update the suffix index.  */
-          size_t *sufindex_end = sufindex + suffix_length;
+          sufindex_end = sufindex + suffix_length;
           while (i-- != 0)
             *--sufindex_end = numeric_suffix_start[i] - '0';
         }
@@ -415,13 +418,14 @@ create (const char *name)
 {
   if (!filter_command)
     {
+      int fd;
+      struct stat out_stat_buf;
       if (verbose)
         fprintf (stdout, _("creating file %s\n"), quote (name));
 
-      int fd = open (name, O_WRONLY | O_CREAT | O_BINARY, MODE_RW_UGO);
+      fd = open (name, O_WRONLY | O_CREAT | O_BINARY, MODE_RW_UGO);
       if (fd < 0)
         return fd;
-      struct stat out_stat_buf;
       if (fstat (fd, &out_stat_buf) != 0)
         error (EXIT_FAILURE, errno, _("failed to stat %s"), quote (name));
       if (SAME_INODE (in_stat_buf, out_stat_buf))
@@ -498,9 +502,9 @@ closeout (FILE *fp, int fd, pid_t pid, char const *name)
     error (EXIT_FAILURE, errno, "%s", name);
   if (fd >= 0)
     {
+      int j;
       if (fp == NULL && close (fd) < 0)
         error (EXIT_FAILURE, errno, "%s", name);
-      int j;
       for (j = 0; j < n_open_pipes; ++j)
         {
           if (open_pipes[j] == fd)
@@ -697,11 +701,13 @@ line_bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize)
 
   do
     {
+      size_t n_left;
+      char *sob;
       n_read = safe_read (STDIN_FILENO, buf, bufsize);
       if (n_read == SAFE_READ_ERROR)
         error (EXIT_FAILURE, errno, "%s", infile);
-      size_t n_left = n_read;
-      char *sob = buf;
+      n_left = n_read;
+      sob = buf;
       while (n_left)
         {
           size_t split_rest = 0;
@@ -734,8 +740,8 @@ line_bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize)
           /* Output to eol if present.  */
           if (eol)
             {
-              split_line = true;
               size_t n_write = eol - sob + 1;
+              split_line = true;
               cwrite (n_out == 0, sob, n_write);
               n_out += n_write;
               n_left -= n_write;
@@ -803,8 +809,6 @@ static void
 lines_chunk_split (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
                    size_t initial_read, off_t file_size)
 {
-  assert (n && k <= n && n <= file_size);
-
   const off_t chunk_size = file_size / n;
   uintmax_t chunk_no = 1;
   off_t chunk_end = chunk_size - 1;
@@ -812,6 +816,8 @@ lines_chunk_split (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
   bool new_file_flag = true;
   bool chunk_truncated = false;
 
+  assert (n && k <= n && n <= file_size);
+
   if (k > 1)
     {
       /* Start reading 1 byte before kth chunk of file.  */
@@ -1227,6 +1233,10 @@ main (int argc, char **argv)
   int c;
   int digits_optind = 0;
   off_t file_size IF_LINT (= 0);
+  void *b;
+  char *buf;
+  bool specified_buf_size;
+  size_t initial_read = SIZE_MAX;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -1494,13 +1504,12 @@ main (int argc, char **argv)
   if (fstat (STDIN_FILENO, &in_stat_buf) != 0)
     error (EXIT_FAILURE, errno, "%s", infile);
 
-  bool specified_buf_size = !! in_blk_size;
+  specified_buf_size = !! in_blk_size;
   if (! specified_buf_size)
     in_blk_size = io_blksize (in_stat_buf);
 
-  void *b = xmalloc (in_blk_size + 1 + page_size - 1);
-  char *buf = ptr_align (b, page_size);
-  size_t initial_read = SIZE_MAX;
+  b = xmalloc (in_blk_size + 1 + page_size - 1);
+  buf = ptr_align (b, page_size);
 
   if (split_type == type_chunk_bytes || split_type == type_chunk_lines)
     {
diff --git a/src/stat.c b/src/stat.c
index 6d23665..ede55a4 100644
--- a/src/stat.c
+++ b/src/stat.c
@@ -622,6 +622,10 @@ out_epoch_sec (char *pformat, size_t prefix_len,
   int width = 0;
   int precision = 0;
   bool frac_left_adjust = false;
+  int divisor = 1;
+  int frac_sec;
+  int int_len;
+  int i;
 
   if (dot)
     {
@@ -643,6 +647,7 @@ out_epoch_sec (char *pformat, size_t prefix_len,
           /* If a nontrivial width is given, subtract the width of the
              decimal point and PRECISION digits that will be output
              later.  */
+          long int lwidth;
           char *p = dot;
           *dot = '\0';
 
@@ -650,13 +655,14 @@ out_epoch_sec (char *pformat, size_t prefix_len,
             --p;
           while (ISDIGIT (p[-1]));
 
-          long int lwidth = strtol (p, NULL, 10);
+          lwidth = strtol (p, NULL, 10);
           width = (lwidth <= INT_MAX ? lwidth : INT_MAX);
           if (1 < width)
             {
+              int w_d;
               p += (*p == '0');
               sec_prefix_len = p - pformat;
-              int w_d = (decimal_point_len < width
+              w_d = (decimal_point_len < width
                          ? width - decimal_point_len
                          : 0);
               if (1 < w_d)
@@ -665,7 +671,8 @@ out_epoch_sec (char *pformat, size_t prefix_len,
                   if (1 < w)
                     {
                       char *dst = pformat;
-                      for (char const *src = dst; src < p; src++)
+                      char const *src;
+                      for (src = dst; src < p; src++)
                         {
                           if (*src == '-')
                             frac_left_adjust = true;
@@ -681,11 +688,9 @@ out_epoch_sec (char *pformat, size_t prefix_len,
         }
     }
 
-  int divisor = 1;
-  for (int i = precision; i < 9; i++)
+  for (i = precision; i < 9; i++)
     divisor *= 10;
-  int frac_sec = arg.tv_nsec / divisor;
-  int int_len;
+  frac_sec = arg.tv_nsec / divisor;
 
   if (TYPE_SIGNED (time_t))
     {
@@ -836,7 +841,9 @@ static char const * ATTRIBUTE_WARN_UNUSED_RESULT
 find_bind_mount (char const * name)
 {
   char const * bind_mount = NULL;
+  struct stat name_stats;
 
+  struct mount_entry *me;
   static struct mount_entry *mount_list;
   static bool tried_mount_list = false;
   if (!tried_mount_list) /* attempt/warn once per process.  */
@@ -846,11 +853,9 @@ find_bind_mount (char const * name)
       tried_mount_list = true;
     }
 
-  struct stat name_stats;
   if (stat (name, &name_stats) != 0)
     return NULL;
 
-  struct mount_entry *me;
   for (me = mount_list; me; me = me->me_next)
     {
       if (me->me_dummy && me->me_devname[0] == '/'
@@ -955,9 +960,9 @@ get_birthtime (int fd, char const *filename, struct stat const *st)
 static inline struct timespec
 neg_to_zero (struct timespec ts)
 {
+  struct timespec z = {0, 0};
   if (0 <= ts.tv_nsec)
     return ts;
-  struct timespec z = {0, 0};
   return z;
 }
 
@@ -1166,11 +1171,12 @@ print_it (char const *format, int fd, char const *filename,
           {
             size_t len = strspn (b + 1, printf_flags);
             char const *fmt_char = b + len + 1;
+            unsigned int fmt_code;
             fmt_char += strspn (fmt_char, digits);
             if (*fmt_char == '.')
               fmt_char += 1 + strspn (fmt_char + 1, digits);
             len = fmt_char - (b + 1);
-            unsigned int fmt_code = *fmt_char;
+            fmt_code = *fmt_char;
             memcpy (dest, b, len + 1);
 
             b = fmt_char;
@@ -1259,6 +1265,7 @@ static bool ATTRIBUTE_WARN_UNUSED_RESULT
 do_statfs (char const *filename, char const *format)
 {
   STRUCT_STATVFS statfsbuf;
+  bool fail;
 
   if (STREQ (filename, "-"))
     {
@@ -1274,7 +1281,7 @@ do_statfs (char const *filename, char const *format)
       return false;
     }
 
-  bool fail = print_it (format, -1, filename, print_statfs, &statfsbuf);
+  fail = print_it (format, -1, filename, print_statfs, &statfsbuf);
   return ! fail;
 }
 
@@ -1285,6 +1292,7 @@ do_stat (char const *filename, char const *format,
 {
   int fd = STREQ (filename, "-") ? 0 : -1;
   struct stat statbuf;
+  bool fail;
 
   if (0 <= fd)
     {
@@ -1308,7 +1316,7 @@ do_stat (char const *filename, char const *format,
   if (S_ISBLK (statbuf.st_mode) || S_ISCHR (statbuf.st_mode))
     format = format2;
 
-  bool fail = print_it (format, fd, filename, print_stat, &statbuf);
+  fail = print_it (format, fd, filename, print_stat, &statbuf);
   return ! fail;
 }
 
@@ -1509,14 +1517,14 @@ main (int argc, char *argv[])
   char *format = NULL;
   char *format2;
   bool ok = true;
-
+  struct lconv const *locale = localeconv ();
+  
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
   setlocale (LC_ALL, "");
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
-  struct lconv const *locale = localeconv ();
   decimal_point = (locale->decimal_point[0] ? locale->decimal_point : ".");
   decimal_point_len = strlen (decimal_point);
 
diff --git a/src/stdbuf.c b/src/stdbuf.c
index 116619d..d65b718 100644
--- a/src/stdbuf.c
+++ b/src/stdbuf.c
@@ -311,6 +311,7 @@ int
 main (int argc, char **argv)
 {
   int c;
+  int exit_status;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -387,7 +388,7 @@ main (int argc, char **argv)
 
   execvp (*argv, argv);
 
-  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
+  exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
   error (0, errno, _("failed to run command %s"), quote (argv[0]));
   return exit_status;
 }
diff --git a/src/sync.c b/src/sync.c
index 5e1dbb8..d7f152b 100644
--- a/src/sync.c
+++ b/src/sync.c
@@ -93,6 +93,7 @@ sync_arg (enum sync_mode mode, char const *file)
   bool ret = true;
   int open_flags = O_RDONLY | O_NONBLOCK;
   int fd;
+  int fdflags;
 
 #ifdef _AIX
   /* AIX 7.1 fsync requires write access to file.  */
@@ -117,7 +118,7 @@ sync_arg (enum sync_mode mode, char const *file)
 
   /* We used O_NONBLOCK above to not hang with fifos,
      so reset that here.  */
-  int fdflags = fcntl (fd, F_GETFL);
+  fdflags = fcntl (fd, F_GETFL);
   if (fdflags == -1
       || fcntl (fd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)
     {
diff --git a/src/system.h b/src/system.h
index 8f6a2ea..9ae73e8 100644
--- a/src/system.h
+++ b/src/system.h
@@ -496,6 +496,7 @@ is_nul (void const *buf, size_t bufsize)
   void const *vp;
   char const *cbuf = buf;
   word const *wp = buf;
+  char const *cp;
 
   /* Find first nonzero *word*, or the word with the sentinel.  */
   while (*wp++ == 0)
@@ -503,7 +504,7 @@ is_nul (void const *buf, size_t bufsize)
 
   /* Find the first nonzero *byte*, or the sentinel.  */
   vp = wp - 1;
-  char const *cp = vp;
+  cp = vp;
   while (*cp++ == 0)
     continue;
 
@@ -568,6 +569,7 @@ Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n\
 static inline void
 emit_ancillary_info (char const *program)
 {
+  const char *lc_messages;
   struct infomap { char const *program; char const *node; } const infomap[] = {
     { "[", "test invocation" },
     { "coreutils", "Multi-call invocation" },
@@ -591,7 +593,7 @@ emit_ancillary_info (char const *program)
 
   /* Don't output this redundant message for English locales.
      Note we still output for 'C' so that it gets included in the man page.  */
-  const char *lc_messages = setlocale (LC_MESSAGES, NULL);
+  lc_messages = setlocale (LC_MESSAGES, NULL);
   if (lc_messages && STRNCMP_LIT (lc_messages, "en_"))
     {
       /* TRANSLATORS: Replace LANG_CODE in this URL with your language code
diff --git a/src/tac.c b/src/tac.c
index 57e7e76..5619afb 100644
--- a/src/tac.c
+++ b/src/tac.c
@@ -435,6 +435,7 @@ temp_stream (FILE **fp, char **file_name)
   static FILE *tmp_fp;
   if (tempfile == NULL)
     {
+      int fd;
       char const *t = getenv ("TMPDIR");
       char const *tempdir = t ? t : DEFAULT_TMPDIR;
       tempfile = mfile_name_concat (tempdir, "tacXXXXXX", NULL);
@@ -453,7 +454,7 @@ temp_stream (FILE **fp, char **file_name)
          FIXME: clean up upon fatal signal.  Don't block them, in case
          $TMPFILE is a remote file system.  */
 
-      int fd = mkstemp (tempfile);
+      fd = mkstemp (tempfile);
       if (fd < 0)
         {
           error (0, errno, _("failed to create temporary file in %s"),
@@ -551,11 +552,12 @@ tac_nonseekable (int input_fd, const char *file)
 {
   FILE *tmp_stream;
   char *tmp_file;
+  bool ok;
   off_t bytes_copied = copy_to_temp (&tmp_stream, &tmp_file, input_fd, file);
   if (bytes_copied < 0)
     return false;
 
-  bool ok = tac_seekable (fileno (tmp_stream), tmp_file, bytes_copied);
+  ok = tac_seekable (fileno (tmp_stream), tmp_file, bytes_copied);
   return ok;
 }
 
diff --git a/src/tail.c b/src/tail.c
index c062d40..699e157 100644
--- a/src/tail.c
+++ b/src/tail.c
@@ -846,6 +846,8 @@ start_lines (const char *pretty_filename, int fd, uintmax_t n_lines,
     {
       char buffer[BUFSIZ];
       size_t bytes_read = safe_read (fd, buffer, BUFSIZ);
+      char *buffer_end;
+      char *p;
       if (bytes_read == 0) /* EOF */
         return -1;
       if (bytes_read == SAFE_READ_ERROR) /* error */
@@ -854,11 +856,11 @@ start_lines (const char *pretty_filename, int fd, uintmax_t n_lines,
           return 1;
         }
 
-      char *buffer_end = buffer + bytes_read;
+      buffer_end = buffer + bytes_read;
 
       *read_pos += bytes_read;
 
-      char *p = buffer;
+      p = buffer;
       while ((p = memchr (p, '\n', buffer_end - p)))
         {
           ++p;
@@ -1737,12 +1739,13 @@ tail_bytes (const char *pretty_filename, int fd, uintmax_t n_bytes,
     }
   else
     {
+      off_t current_pos;
       off_t end_pos = ((! presume_input_pipe && usable_st_size (&stats)
                         && n_bytes <= OFF_T_MAX)
                        ? stats.st_size : -1);
       if (end_pos <= ST_BLKSIZE (stats))
         return pipe_bytes (pretty_filename, fd, n_bytes, read_pos);
-      off_t current_pos = xlseek (fd, 0, SEEK_CUR, pretty_filename);
+      current_pos = xlseek (fd, 0, SEEK_CUR, pretty_filename);
       if (current_pos < end_pos)
         {
           off_t bytes_remaining = end_pos - current_pos;
diff --git a/src/test.c b/src/test.c
index 80cc679..6d2a4db 100644
--- a/src/test.c
+++ b/src/test.c
@@ -422,23 +422,27 @@ unary_operator (void)
 
     case 'O':			/* File is owned by you? */
       {
+        uid_t euid;
+        uid_t NO_UID;
         unary_advance ();
         if (stat (argv[pos - 1], &stat_buf) != 0)
           return false;
         errno = 0;
-        uid_t euid = geteuid ();
-        uid_t NO_UID = -1;
+        euid = geteuid ();
+        NO_UID = -1;
         return ! (euid == NO_UID && errno) && euid == stat_buf.st_uid;
       }
 
     case 'G':			/* File is owned by your group? */
       {
+        gid_t egid;
+        gid_t NO_GID;
         unary_advance ();
         if (stat (argv[pos - 1], &stat_buf) != 0)
           return false;
         errno = 0;
-        gid_t egid = getegid ();
-        gid_t NO_GID = -1;
+        egid = getegid ();
+        NO_GID = -1;
         return ! (egid == NO_GID && errno) && egid == stat_buf.st_gid;
       }
 
diff --git a/src/timeout.c b/src/timeout.c
index 98378f6..650fa6d 100644
--- a/src/timeout.c
+++ b/src/timeout.c
@@ -133,6 +133,7 @@ settimeout (double duration, bool warn)
    resolution provided by alarm().  */
 
 #if HAVE_TIMER_SETTIME
+{
   struct timespec ts = dtotimespec (duration);
   struct itimerspec its = { {0, 0}, ts };
   timer_t timerid;
@@ -149,8 +150,10 @@ settimeout (double duration, bool warn)
     }
   else if (warn && errno != ENOSYS)
     error (0, errno, _("warning: timer_create"));
+}
 #endif
 
+{
   unsigned int timeint;
   if (UINT_MAX <= duration)
     timeint = UINT_MAX;
@@ -161,6 +164,7 @@ settimeout (double duration, bool warn)
     }
   alarm (timeint);
 }
+}
 
 /* send SIG avoiding the current process.  */
 
@@ -445,7 +449,9 @@ main (int argc, char **argv)
       return EXIT_CANCELED;
     }
   else if (monitored_pid == 0)
-    {                           /* child */
+    { 
+      int exit_status;
+                                /* child */
       /* exec doesn't reset SIG_IGN -> SIG_DFL.  */
       signal (SIGTTIN, SIG_DFL);
       signal (SIGTTOU, SIG_DFL);
@@ -453,7 +459,7 @@ main (int argc, char **argv)
       execvp (argv[0], argv);   /* FIXME: should we use "sh -c" ... here?  */
 
       /* exit like sh, env, nohup, ...  */
-      int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
+      exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;
       error (0, errno, _("failed to run command %s"), quote (argv[0]));
       return exit_status;
     }
diff --git a/src/wc.c b/src/wc.c
index 9fbaee7..36f9c32 100644
--- a/src/wc.c
+++ b/src/wc.c
@@ -273,6 +273,8 @@ wc (int fd, char const *file_x, struct fstatus *fstatus, off_t current_pos)
       bool long_lines = false;
       while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)
         {
+          char *p, *end;
+          uintmax_t plines;
           if (bytes_read == SAFE_READ_ERROR)
             {
               error (0, errno, "%s", file);
@@ -282,9 +284,9 @@ wc (int fd, char const *file_x, struct fstatus *fstatus, off_t current_pos)
 
           bytes += bytes_read;
 
-          char *p = buf;
-          char *end = p + bytes_read;
-          uintmax_t plines = lines;
+          p = buf;
+          end = p + bytes_read;
+          plines = lines;
 
           if (! long_lines)
             {
@@ -631,6 +633,9 @@ main (int argc, char **argv)
   char *files_from = NULL;
   struct fstatus *fstatus;
   struct Tokens tok;
+  bool read_tokens = false;
+  struct argv_iterator *ai;
+  int i;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -687,10 +692,9 @@ main (int argc, char **argv)
          || print_linelength))
     print_lines = print_words = print_bytes = true;
 
-  bool read_tokens = false;
-  struct argv_iterator *ai;
   if (files_from)
     {
+      struct stat st;
       FILE *stream;
 
       /* When using --files0-from=F, you may not specify any files
@@ -715,7 +719,6 @@ main (int argc, char **argv)
 
       /* Read the file list into RAM if we can detect its size and that
          size is reasonable.  Otherwise, we'll read a name at a time.  */
-      struct stat st;
       if (fstat (fileno (stream), &st) == 0
           && S_ISREG (st.st_mode)
           && st.st_size <= MIN (10 * 1024 * 1024, physmem_available () / 2))
@@ -750,7 +753,6 @@ main (int argc, char **argv)
   fstatus = get_input_fstatus (nfiles, files);
   number_width = compute_number_width (nfiles, fstatus);
 
-  int i;
   ok = true;
   for (i = 0; /* */; i++)
     {
-- 
2.2.2

