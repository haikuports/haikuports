From 13d06c680fe3d3f6340b9c17aa9f2b04c04ffba3 Mon Sep 17 00:00:00 2001
From: David Karoly <david.karoly@outlook.com>
Date: Mon, 22 Nov 2021 16:35:32 +0000
Subject: fix build


diff --git a/Makefile.in b/Makefile.in
index 4f14819..6dfdb75 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -8,7 +8,7 @@ SCRIPTS=bon_csv2txt
 prefix=@prefix@
 eprefix=@exec_prefix@
 #MORE_WARNINGS=-Weffc++
-WFLAGS=-Wall -W -Wshadow -Wpointer-arith -Wwrite-strings -pedantic -ffor-scope -Wcast-align -Wsign-compare -Wpointer-arith -Wwrite-strings -Wformat-security -Wswitch-enum -Winit-self $(MORE_WARNINGS)
+WFLAGS=-Wall -W -Wshadow -Wpointer-arith -Wwrite-strings -pedantic -Wcast-align -Wsign-compare -Wpointer-arith -Wwrite-strings -Wformat-security -Wswitch-enum -Winit-self $(MORE_WARNINGS)
 CFLAGS=-O2 @debug@ -DNDEBUG $(WFLAGS) $(MORECFLAGS)
 CXX=@CXX@ $(CFLAGS)
 LINK=@CXX@
diff --git a/bon_csv2html.cpp b/bon_csv2html.cpp
index e9d9c50..652e330 100644
--- a/bon_csv2html.cpp
+++ b/bon_csv2html.cpp
@@ -87,8 +87,8 @@ int main(int argc, char **argv)
     read_in(buf);
   }
 
-  props = new PPCCHAR[data.size()];
-  for(i = 0; i < data.size(); i++)
+  props = new PPCCHAR[::data.size()];
+  for(i = 0; i < ::data.size(); i++)
   {
     props[i] = new PCCHAR[MAX_ITEMS];
     props[i][0] = NULL;
@@ -109,7 +109,7 @@ int main(int argc, char **argv)
   }
   calc_vals();
   int mid_width = header();
-  for(i = 0; i < data.size(); i++)
+  for(i = 0; i < ::data.size(); i++)
   {
 // First print the average speed line
     printf("<tr>");
@@ -171,23 +171,23 @@ int compar(const void *a, const void *b)
 
 void calc_vals()
 {
-  ITEM *arr = new ITEM[data.size()];
+  ITEM *arr = new ITEM[::data.size()];
   for(unsigned int column_ind = 0; column_ind < MAX_ITEMS; column_ind++)
   {
     switch(vals[column_ind])
     {
     case eNoCols:
     {
-      for(unsigned int row_ind = 0; row_ind < data.size(); row_ind++)
+      for(unsigned int row_ind = 0; row_ind < ::data.size(); row_ind++)
       {
         if(column_ind == COL_CONCURRENCY)
         {
-          if(data[row_ind][column_ind] && strcmp("1", data[row_ind][column_ind]))
+          if(::data[row_ind][column_ind] && strcmp("1", ::data[row_ind][column_ind]))
             col_used[column_ind] = true;
         }
         else
         {
-          if(data[row_ind][column_ind] && strlen(data[row_ind][column_ind]))
+          if(::data[row_ind][column_ind] && strlen(::data[row_ind][column_ind]))
             col_used[column_ind] = true;
         }
       }
@@ -195,22 +195,22 @@ void calc_vals()
     break;
     case eCPU:
     {
-      for(unsigned int row_ind = 0; row_ind < data.size(); row_ind++)
+      for(unsigned int row_ind = 0; row_ind < ::data.size(); row_ind++)
       {
         double work, cpu;
         arr[row_ind].val = 0.0;
-        if(data[row_ind].size() > column_ind
-         && sscanf(data[row_ind][column_ind - 1], "%lf", &work) == 1
-         && sscanf(data[row_ind][column_ind], "%lf", &cpu) == 1)
+        if(::data[row_ind].size() > column_ind
+         && sscanf(::data[row_ind][column_ind - 1], "%lf", &work) == 1
+         && sscanf(::data[row_ind][column_ind], "%lf", &cpu) == 1)
         {
           arr[row_ind].val = cpu / work;
         }
         arr[row_ind].pos = row_ind;
       }
-      qsort(arr, data.size(), sizeof(ITEM), compar);
+      qsort(arr, ::data.size(), sizeof(ITEM), compar);
       int col_count = -1;
       double min_col = -1.0, max_col = -1.0;
-      for(unsigned int sort_ind = 0; sort_ind < data.size(); sort_ind++)
+      for(unsigned int sort_ind = 0; sort_ind < ::data.size(); sort_ind++)
       {
         // if item is different from previous or if the first row
         // (sort_ind == 0) then increment col count
@@ -239,7 +239,7 @@ void calc_vals()
           min_col /= mult;
         }
         double range_col = max_col - min_col;
-        for(unsigned int sort_ind = 0; sort_ind < data.size(); sort_ind++)
+        for(unsigned int sort_ind = 0; sort_ind < ::data.size(); sort_ind++)
         {
           if(arr[sort_ind].col_ind > -1)
           {
@@ -250,7 +250,7 @@ void calc_vals()
       }
       else
       {
-        for(unsigned int sort_ind = 0; sort_ind < data.size(); sort_ind++)
+        for(unsigned int sort_ind = 0; sort_ind < ::data.size(); sort_ind++)
         {
           if(vals[column_ind] == eLatency)
           {
@@ -263,25 +263,25 @@ void calc_vals()
     case eSpeed:
     case eLatency:
     {
-      for(unsigned int row_ind = 0; row_ind < data.size(); row_ind++)
+      for(unsigned int row_ind = 0; row_ind < ::data.size(); row_ind++)
       {
         arr[row_ind].val = 0.0;
-        if(data[row_ind].size() <= column_ind
-         || sscanf(data[row_ind][column_ind], "%lf", &arr[row_ind].val) == 0)
+        if(::data[row_ind].size() <= column_ind
+         || sscanf(::data[row_ind][column_ind], "%lf", &arr[row_ind].val) == 0)
           arr[row_ind].val = 0.0;
         if(vals[column_ind] == eLatency && arr[row_ind].val != 0.0)
         {
-          if(strstr(data[row_ind][column_ind], "ms"))
+          if(strstr(::data[row_ind][column_ind], "ms"))
             arr[row_ind].val *= 1000.0;
-          else if(!strstr(data[row_ind][column_ind], "us"))
+          else if(!strstr(::data[row_ind][column_ind], "us"))
             arr[row_ind].val *= 1000000.0; // is !us && !ms then secs!
         }
         arr[row_ind].pos = row_ind;
       }
-      qsort(arr, data.size(), sizeof(ITEM), compar);
+      qsort(arr, ::data.size(), sizeof(ITEM), compar);
       int col_count = -1;
       double min_col = -1.0, max_col = -1.0;
-      for(unsigned int sort_ind = 0; sort_ind < data.size(); sort_ind++)
+      for(unsigned int sort_ind = 0; sort_ind < ::data.size(); sort_ind++)
       {
         // if item is different from previous or if the first row
         // (sort_ind == 0) then increment col count
@@ -310,7 +310,7 @@ void calc_vals()
           min_col /= mult;
         }
         double range_col = max_col - min_col;
-        for(unsigned int sort_ind = 0; sort_ind < data.size(); sort_ind++)
+        for(unsigned int sort_ind = 0; sort_ind < ::data.size(); sort_ind++)
         {
           if(arr[sort_ind].col_ind > -1)
           {
@@ -332,7 +332,7 @@ void calc_vals()
       }
       else
       {
-        for(unsigned int sort_ind = 0; sort_ind < data.size(); sort_ind++)
+        for(unsigned int sort_ind = 0; sort_ind < ::data.size(); sort_ind++)
         {
           if(vals[column_ind] == eLatency)
           {
@@ -481,16 +481,16 @@ void read_in(CPCCHAR buf)
     free((void *)arr[0]);
     return;
   }
-  data.push_back(arr);
+  ::data.push_back(arr);
 }
 
 void print_item(int num, int item, CPCCHAR extra)
 {
   PCCHAR line_data;
   char buf[1024];
-  if(int(data[num].size()) > item)
+  if(int(::data[num].size()) > item)
   {
-    line_data = data[num][item];
+    line_data = ::data[num][item];
     switch(item)
     {
     case COL_PUT_BLOCK:
-- 
2.30.2


From e06c3b9c088e6916800e52830447e6387e15e807 Mon Sep 17 00:00:00 2001
From: Kyle Ambroff-Kao <kyle@ambroffkao.com>
Date: Sun, 15 Sep 2019 14:45:20 -0700
Subject: Fix support for large files on Haiku


diff --git a/bon_io.cpp b/bon_io.cpp
index bb482f0..4a1c3a6 100644
--- a/bon_io.cpp
+++ b/bon_io.cpp
@@ -292,7 +292,7 @@ int CFileOp::m_open(CPCCHAR base_name, bool create)
   else
   {
     flags = O_RDWR;
-#ifdef _LARGEFILE64_SOURCE
+#if defined(_LARGEFILE64_SOURCE) && !defined(__HAIKU__)
     flags |= O_LARGEFILE;
 #endif
   }
diff --git a/configure.in b/configure.in
index 080e40c..9173dfb 100644
--- a/configure.in
+++ b/configure.in
@@ -94,6 +94,7 @@ AC_TRY_RUN([#ifndef _LARGEFILE64_SOURCE
 #include <stdlib.h>
 
 int main () {
+#ifndef __HAIKU__
   int fd;
   off64_t i = off64_t(1) << 32 + 1;
   const char * const name = "test.2g";
@@ -117,6 +118,7 @@ int main () {
     exit(1);
   }
   close(fd);
+#endif
   return 0;
 }], large_file="yes")
 if [[ -n "$large_file" ]]; then
diff --git a/port.h.in b/port.h.in
index 70d748e..5cacfbc 100644
--- a/port.h.in
+++ b/port.h.in
@@ -23,7 +23,7 @@
 // UNIX here
 typedef struct timeval TIMEVAL_TYPE;
 
-#ifdef _LARGEFILE64_SOURCE
+#if defined(_LARGEFILE64_SOURCE) && !defined(__HAIKU__)
 #define OFF_TYPE off64_t
 #define file_lseek lseek64
 #define file_creat creat64
-- 
2.30.2

