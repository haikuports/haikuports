From 4dfe242a81816e159e68aeb662d22c4ccda0844b Mon Sep 17 00:00:00 2001
From: Alexander von Gluck IV <kallisti5@unixzen.com>
Date: Fri, 17 Nov 2023 14:39:01 -0600
Subject: Haiku: Introduce basic platform support

* Missing gateway detection in route.c
* Missing ipv6 routing calls

diff --git a/configure.ac b/configure.ac
index df16c43..4962179 100644
--- a/configure.ac
+++ b/configure.ac
@@ -374,6 +374,10 @@ case "$host" in
 		have_tap_header="yes"
 		ac_cv_header_net_if_h="no"	# exists, but breaks things
 		;;
+	*-*-haiku*)
+		AC_DEFINE([TARGET_HAIKU], [1], [Are we running Haiku?])
+		AC_DEFINE_UNQUOTED([TARGET_PREFIX], ["H"], [Target prefix])
+		;;
 	*)
 		AC_DEFINE_UNQUOTED([TARGET_PREFIX], ["X"], [Target prefix])
 		have_tap_header="yes"
diff --git a/src/openvpn/route.c b/src/openvpn/route.c
index 66540db..02ad925 100644
--- a/src/openvpn/route.c
+++ b/src/openvpn/route.c
@@ -1845,6 +1845,22 @@ add_route(struct route_ipv4 *r,
         status = ret ? RTA_SUCCESS : RTA_ERROR;
     }
 
+#elif defined(TARGET_HAIKU)
+
+    {
+    /* ex: route add /dev/net/ipro1000/0 0.0.0.0 gw 192.168.1.1 netmask 128.0.0.0 */
+    argv_printf(&argv, "%s add %s inet %s gw %s netmask %s",
+                ROUTE_PATH,
+                rgi->iface,
+                network,
+                gateway,
+                netmask);
+    argv_msg(D_ROUTE, &argv);
+    bool ret = openvpn_execve_check(&argv, es, 0,
+                                    "ERROR: Haiku inet route add command failed");
+    status = ret ? RTA_SUCCESS : RTA_ERROR;
+    }
+
 #else  /* if defined(TARGET_LINUX) */
     msg(M_FATAL, "Sorry, but I don't know how to do 'route' commands on this operating system.  Try putting your routes in a --route-up script");
 #endif /* if defined(TARGET_LINUX) */
@@ -2118,6 +2134,19 @@ add_route_ipv6(struct route_ipv6 *r6, const struct tuntap *tt,
                                     "ERROR: AIX route add command failed");
     status = ret ? RTA_SUCCESS : RTA_ERROR;
 
+#elif defined(TARGET_HAIKU)
+    /* ex: route add /dev/net/ipro1000/0 inet6 :: gw beef::cafe prefixlen 64 */
+    argv_printf(&argv, "%s add %s inet6 %s gw %s prefixlen %d",
+                ROUTE_PATH,
+                r6->iface,
+                network,
+                gateway,
+                r6->netbits);
+    argv_msg(D_ROUTE, &argv);
+    bool ret = openvpn_execve_check(&argv, es, 0,
+                                    "ERROR: Haiku inet6 route add command failed");
+    status = ret ? RTA_SUCCESS : RTA_ERROR;
+    
 #else  /* if defined(TARGET_LINUX) */
     msg(M_FATAL, "Sorry, but I don't know how to do 'route ipv6' commands on this operating system.  Try putting your routes in a --route-up script");
 #endif /* if defined(TARGET_LINUX) */
@@ -2321,6 +2350,17 @@ delete_route(struct route_ipv4 *r,
         openvpn_execve_check(&argv, es, 0, "ERROR: AIX route delete command failed");
     }
 
+#elif defined(TARGET_HAIKU)
+    /* ex: route del /dev/net/ipro1000/0 inet 192.168.0.0 gw 192.168.1.1 netmask 255.255.0.0 */
+    argv_printf(&argv, "%s del %s inet %s gw %s netmask %s",
+                ROUTE_PATH,
+                rgi->iface,
+                network,
+                gateway,
+                netmask);
+    argv_msg(D_ROUTE, &argv);
+    openvpn_execve_check(&argv, es, 0, "ERROR: Haiku inet route delete command failed");
+
 #else  /* if defined(TARGET_LINUX) */
     msg(M_FATAL, "Sorry, but I don't know how to do 'route' commands on this operating system.  Try putting your routes in a --route-up script");
 #endif /* if defined(TARGET_LINUX) */
@@ -2500,6 +2540,17 @@ delete_route_ipv6(const struct route_ipv6 *r6, const struct tuntap *tt,
     msg(D_ROUTE_DEBUG, "Deleting routes on Android is not possible/not "
         "needed. The VpnService API allows routes to be set "
         "on connect only and will clean up automatically.");
+#elif defined(TARGET_HAIKU)
+    /* ex: route del /dev/net/ipro1000/0 inet6 :: gw beef::cafe prefixlen 64 */
+    argv_printf(&argv, "%s del %s inet6 %s gw %s prefixlen %d",
+                ROUTE_PATH,
+                r6->iface,
+                network,
+                gateway,
+                r6->netbits);
+    argv_msg(D_ROUTE, &argv);
+    openvpn_execve_check(&argv, es, 0, "ERROR: Haiku inet6 route delete command failed");
+    
 #else  /* if defined(TARGET_LINUX) */
     msg(M_FATAL, "Sorry, but I don't know how to do 'route ipv6' commands on this operating system.  Try putting your routes in a --route-down script");
 #endif /* if defined(TARGET_LINUX) */
@@ -3878,6 +3929,76 @@ done:
 
 #undef max
 
+#elif defined(TARGET_HAIKU)
+void
+get_default_gateway(struct route_gateway_info *rgi, openvpn_net_ctx_t *ctx)
+{
+    CLEAR(*rgi);
+    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+    if (sockfd < 0)
+    {
+        msg(M_ERRNO, "%s: Error opening socket for AF_INET", __func__);
+        return;
+    }
+    struct ifconf config;
+    config.ifc_len = sizeof(config.ifc_value);
+    if (ioctl(sockfd, SIOCGRTSIZE, &config, sizeof(struct ifconf)) < 0)
+    {
+        msg(M_ERRNO, "%s: Error getting routing table size", __func__);
+        return;
+    }
+    uint32 size = (uint32)config.ifc_value;
+    if (size == 0)
+    {
+        return;
+    }
+    void *buffer = malloc(size);
+    check_malloc_return(buffer);
+    config.ifc_len = size;
+    config.ifc_buf = buffer;
+    if (ioctl(sockfd, SIOCGRTTABLE, &config, sizeof(struct ifconf)) < 0)
+    {
+        free(buffer);
+        return;
+    }
+
+    struct ifreq *interface = (struct ifreq *)buffer;
+    struct ifreq *end = (struct ifreq *)((uint8 *)buffer + size);
+    while (interface < end)
+    {
+        struct route_entry route = interface->ifr_route;
+        if ((route.flags & RTF_GATEWAY) != 0 && (route.flags & RTF_DEFAULT) != 0)
+        {
+            rgi->gateway.addr = ntohl(((struct sockaddr_in *)route.gateway)->sin_addr.s_addr);
+            rgi->flags = RGI_ADDR_DEFINED | RGI_IFACE_DEFINED;
+            strncpy(rgi->iface, interface->ifr_name, sizeof(rgi->iface));
+        }
+        int32 address_size = 0;
+        if (route.destination != NULL)
+        {
+            address_size += route.destination->sa_len;
+        }
+        if (route.mask != NULL)
+        {
+            address_size += route.mask->sa_len;
+        }
+        if (route.gateway != NULL)
+        {
+            address_size += route.gateway->sa_len;
+        }
+        interface = (struct ifreq *)((addr_t)interface + IF_NAMESIZE
+                                     + sizeof(struct route_entry) + address_size);
+    }
+    free(buffer);
+}
+void
+get_default_gateway_ipv6(struct route_ipv6_gateway_info *rgi6,
+                         const struct in6_addr *dest, openvpn_net_ctx_t *ctx)
+{
+    /* TODO: Same for ipv6 with AF_INET6 */
+    CLEAR(*rgi6);
+}
+
 #else  /* if defined(_WIN32) */
 
 /*
diff --git a/src/openvpn/syshead.h b/src/openvpn/syshead.h
index 3e0f31a..b0e19ff 100644
--- a/src/openvpn/syshead.h
+++ b/src/openvpn/syshead.h
@@ -166,6 +166,12 @@
 #include <string.h>
 #endif
 
+#if defined(TARGET_HAIKU)
+#include <SupportDefs.h>   /* uint32, etc */
+#include <net/if.h>        /* ifconf etc */
+#include <sys/sockio.h>    /* SIOCGRTTABLE, etc */
+#endif /* TARGET_HAIKU */
+
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
diff --git a/src/openvpn/tun.c b/src/openvpn/tun.c
index 92e71a3..1c0c02a 100644
--- a/src/openvpn/tun.c
+++ b/src/openvpn/tun.c
@@ -1637,6 +1637,16 @@ do_ifconfig_ipv4(struct tuntap *tt, const char *ifname, int tun_mtu,
     {
         windows_set_mtu(tt->adapter_index, AF_INET, tun_mtu);
     }
+#elif defined(TARGET_HAIKU)
+    {
+        /* example: ifconfig tun/0 inet 1.1.1.1 255.255.255.0 mtu 1450 up */
+        // Need to add ifconfig_remote_netmask since right now it is just NULL
+        argv_printf(&argv, "%s %s inet %s %s mtu %d up", IFCONFIG_PATH,
+            ifname, ifconfig_local, ifconfig_remote_netmask, tun_mtu);
+
+        argv_msg(M_INFO, &argv);
+        openvpn_execve_check(&argv, es, S_FATAL, "Haiku ifconfig failed");
+    }
 #else  /* if defined(TARGET_LINUX) */
     msg(M_FATAL, "Sorry, but I don't know how to do 'ifconfig' commands on this operating system.  You should ifconfig your TUN/TAP device manually or use an --up script.");
 #endif /* if defined(TARGET_LINUX) */
@@ -1893,7 +1903,6 @@ tun_dco_enabled(struct tuntap *tt)
 }
 #endif
 
-
 #if !(defined(_WIN32) || defined(TARGET_LINUX))
 static void
 open_tun_generic(const char *dev, const char *dev_type, const char *dev_node,
@@ -1928,10 +1937,17 @@ open_tun_generic(const char *dev, const char *dev_type, const char *dev_node,
             {
                 for (int i = 0; i < 256; ++i)
                 {
+#if defined(TARGET_HAIKU)
+                    openvpn_snprintf(tunname, sizeof(tunname),
+                                     "/dev/%s/%d", dev, i);
+                    openvpn_snprintf(dynamic_name, sizeof(dynamic_name),
+                                     "%s/%d", dev, i);
+#else
                     openvpn_snprintf(tunname, sizeof(tunname),
                                      "/dev/%s%d", dev, i);
                     openvpn_snprintf(dynamic_name, sizeof(dynamic_name),
                                      "%s%d", dev, i);
+#endif
                     if ((tt->fd = open(tunname, O_RDWR)) > 0)
                     {
                         dynamic_opened = true;
-- 
2.45.2

