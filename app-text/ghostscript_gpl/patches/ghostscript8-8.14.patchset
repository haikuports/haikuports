From bc1e9c965e8a7b657665e6218bab47b5fde4190c Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Fri, 15 Mar 2019 08:17:45 +0100
Subject: Fix build on Haiku using Unix makefiles.


diff --git a/src/unix-aux.mak b/src/unix-aux.mak
index 6bbf607..76ab802 100644
--- a/src/unix-aux.mak
+++ b/src/unix-aux.mak
@@ -79,7 +79,7 @@ $(GENINIT_XE): $(GLSRC)geninit.c $(AK) $(GENINIT_DEPS)
 # The "else true;" is required because Ultrix's implementation of sh -e
 # terminates execution of a command if any error occurs, even if the command
 # traps the error with ||.
-INCLUDE=/usr/include
+INCLUDE=/system/develop/headers/posix
 $(gconfig__h): $(UNIX_AUX_MAK) $(ECHOGS_XE)
 	$(ECHOGS_XE) -w $(gconfig__h) -x 2f2a -s This file was generated automatically by unix-aux.mak. -s -x 2a2f
 	if ( test -f $(INCLUDE)/dirent.h ); then $(ECHOGS_XE) -a $(gconfig__h) -x 23 define HAVE_DIRENT_H; else true; fi
diff --git a/src/unix-dll.mak b/src/unix-dll.mak
index 2570d69..8626ba4 100644
--- a/src/unix-dll.mak
+++ b/src/unix-dll.mak
@@ -87,13 +87,13 @@ SODEFS=LDFLAGS='$(LDFLAGS) $(CFLAGS_SO) -shared -Wl,-soname=$(GS_SONAME_MAJOR)'\
 
 # Normal shared object
 so: SODIRS
-	$(MAKE) $(SODEFS) CFLAGS='$(CFLAGS_STANDARD) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' prefix=$(prefix) $(GSSOC) $(GSSOX)
+	$(MAKE) $(SODEFS) CFLAGS='$(CFLAGS_STANDARD) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' prefix=$(prefix) $(GSSOC)
 
 # Debug shared object
 # Note that this is in the same directory as the normal shared
 # object, so you will need to use 'make soclean', 'make sodebug'
 sodebug: SODIRS
-	$(MAKE) $(SODEFS) GENOPT='-DDEBUG' CFLAGS='$(CFLAGS_DEBUG) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' $(GSSOC) $(GSSOX)
+	$(MAKE) $(SODEFS) GENOPT='-DDEBUG' CFLAGS='$(CFLAGS_DEBUG) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' $(GSSOC)
 
 install-so: so
 	-mkdir -p $(prefix)
@@ -103,7 +103,6 @@ install-so: so
 	-mkdir -p $(bindir)
 	-mkdir -p $(libdir)
 	$(INSTALL_PROGRAM) $(GSSOC) $(bindir)/$(GSSOC_XENAME)
-	$(INSTALL_PROGRAM) $(GSSOX) $(bindir)/$(GSSOX_XENAME)
 	$(INSTALL_PROGRAM) $(BINDIR)/$(SOBINRELDIR)/$(GS_SONAME_MAJOR_MINOR) $(libdir)/$(GS_SONAME_MAJOR_MINOR)
 	$(RM_) $(libdir)/$(GS_SONAME)
 	ln -s $(GS_SONAME_MAJOR_MINOR) $(libdir)/$(GS_SONAME)
-- 
2.37.3


From 177b69ebc7763053e535a47980903312b7b16afd Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Fri, 15 Mar 2019 10:16:42 +0100
Subject: Import the BeOS patches.


diff --git a/src/contrib.mak b/src/contrib.mak
index 2e868e3..bc889fb 100644
--- a/src/contrib.mak
+++ b/src/contrib.mak
@@ -122,6 +122,12 @@ CONTRIB_MAK=$(GLSRC)contrib.mak
 #	mgr8	8-bit color MGR devices
 #	sgirgb	SGI RGB pixmap format
 #	sunhmono  Harlequin variant of 1-bit Sun raster file
+# BeOS:
+#	beos			BeOS standard non-anti-aliasing
+#	bealpha2		BeOS anti-aliasing device (2 bits for alpha channel)
+#	bealpha4		BeOS anti-aliasing device (4 bits for alpha channel)
+#	bealpht2		BeOS text only anti-aliasing device (2 bits for alpha channel)
+#	bealpht4		BeOS text only anti-aliasing device (4 bits for alpha channel)
 
 # If you add drivers, it would be nice if you kept each list
 # in alphabetical order.
@@ -850,3 +856,27 @@ $(DD)sunhmono.dev : $(sunr_) $(DD)page.dev
 $(GLOBJ)gdevsunr.$(OBJ) : $(GLSRC)gdevsunr.c $(PDEVH)
 	$(GLCC) $(GLO_)gdevsunr.$(OBJ) $(C_) $(GLSRC)gdevsunr.c
 
+### ------------------------ The BeOS devices ------------------------- ###
+### Note: these drivers are maintained by users:                        ###
+###       Original BeOS device by Jake Hamby, ported to GS 6.01         ###
+###       by Sander Stoks <sanders@sumware.demon.nl>, ported to GS 8.14 ### 
+###       by Michael Pfeiffer <michael.pfeiffer@utanet.at>;             ###
+###       anti-aliasing drivers by Michael Pfeiffer.                    ###
+
+$(DD)beos.dev: $(GLOBJ)gdevbe.$(OBJ)
+	$(SETDEV) $(DD)beos $(GLOBJ)gdevbe.$(OBJ)
+
+$(DD)bealpha2.dev: $(GLOBJ)gdevbe.$(OBJ)
+	$(SETDEV) $(DD)bealpha2 $(GLOBJ)gdevbe.$(OBJ)
+
+$(DD)bealpha4.dev: $(GLOBJ)gdevbe.$(OBJ)
+	$(SETDEV) $(DD)bealpha4 $(GLOBJ)gdevbe.$(OBJ)
+ 
+$(DD)bealpht2.dev: $(GLOBJ)gdevbe.$(OBJ)
+	$(SETDEV) $(DD)bealpht2 $(GLOBJ)gdevbe.$(OBJ)
+
+$(DD)bealpht4.dev: $(GLOBJ)gdevbe.$(OBJ)
+	$(SETDEV) $(DD)bealpht4 $(GLOBJ)gdevbe.$(OBJ)
+
+ $(GLOBJ)gdevbe.$(OBJ): $(GLSRC)gdevbe.cpp $(GLSRC)gdevbe.h $(GDEV)
+	$(GLCC) $(GLO_)gdevbe.$(OBJ) $(C_) $(GLSRC)gdevbe.cpp
diff --git a/src/gdevbe.cpp b/src/gdevbe.cpp
new file mode 100644
index 0000000..3aff1ff
--- /dev/null
+++ b/src/gdevbe.cpp
@@ -0,0 +1,1435 @@
+/* BeOS driver for Ghostscript using a BBitmap for buffering.
+ * This driver has been heavily rewritten from the previous version.
+ *
+ * Copyright 1998, Jake Hamby
+ * Send all comments, bug fixes, etc. to:  jehamby@lightside.com
+ *
+ * Anti-Aliasing drivers: bealpha2, bealpht2, bealpha4 and bealpht4 
+ * Copyright 2000, Michael Pfeiffer
+ * Email: laplace@users.sourceforge.net
+ *
+ * Description: bealpha2 and bealpha4 anti-alias text and graphic. 
+ * bealpht2 and bealpht4 anti-alias text only.
+ * 
+ * History
+ * 1998 initial port by Jake Hamby
+ * 2000 ported version 7 by Sander Stoks 
+ *      anti-aliasing driver by Michael Pfeiffer
+ * 2004 ported version 8, by Michael Pfeiffer
+ *		documented, refactored and improved AA device
+ *      (about 50% faster for certain kind of PS files e.g. tiger.eps) 
+ *      
+ *
+ * To do (eventually): 
+ * -  Creating and deleting BBitmap object is an inefficient operation!
+ *    If BE_ALPHA_BITMAP_CACHE then
+ *    - check if temporary list is faster on SMP then _cached_bitmap
+ *    - on cache overflow try to reuse a large enough bitmap instead
+ *      of deleting bitmaps from cache and creating a new one
+ *    - on cache overflow delete large bitmaps first
+ * -  Find optimal values for (see gdevbe.h):
+ *    - BE_ALPHA_HASHTABLE_SIZE
+ *    - BE_ALPHA_MAX_BITMAPS
+ *    - BE_ALPHA_REMOVE_BITMAPS
+ *    - BE_ALPHA_MAX_SIZE
+ *    and an optimal hash function HASH_FUNC in this file.
+ * -  Set the bits per pixel for the internal bitmap with a 
+ *    parameter (e.g. gs -dBitsPerPixel={8,16,32}).
+ * -  Limit the number of bitmaps in the mono bitmap cache.
+ * -  Let the GS interpreter be interruptible (return a negative number
+ *    in the device-callback functions).
+ */
+
+// set PROFILE to 1 to enable profiling
+#define PROFILE 0
+// set TRACE_COPY_CALLS to 1 to enable tracing of copy mono and alpha function calls
+#define TRACE_COPY_CALLS 0
+
+// define macro if certain functions should be inlined
+//#define INLINE inline
+// define macro if inlining should be disabled
+#define INLINE 
+
+#include <View.h>
+#include <Window.h>
+#include <Bitmap.h>
+
+typedef void* HWND;       // For old DLL interface
+
+extern "C" {
+	void gsdll_draw(unsigned char *device, BView *view, BRect dest, BRect src);
+
+	#define __PROTOTYPES__    // C++ needs prototypes, of course
+	#include "gx.h"			  // for gx_bitmap; includes std.h 
+	#include "math_.h"
+	#include "memory_.h"
+	#include "gserrors.h"
+	#include "gsparam.h"
+	#include "gsstruct.h"
+	#include "gxdevice.h"
+	#include "gsdevice.h"
+	#include "gdevbe.h"
+	#include "gsdll.h"
+
+	// Intel does name mangling on variables, so define these here.
+	extern gx_device_be gs_bealpha2_device;	
+	extern gx_device_be gs_bealpha4_device;	
+	extern gx_device_be gs_bealpht2_device;	
+	extern gx_device_be gs_bealpht4_device;	
+	extern gx_device_be gs_beos_device;	
+	extern HWND hwndtext;		        
+} // extern "C"
+
+// Macros
+#if 0
+#pragma mark *********** Macros ***************
+#endif
+// The hash function
+#define BE_ALPHA_HASH(key) ((key) % BE_ALPHA_HASHTABLE_SIZE)
+// Color compare function
+#define SAME_COLOR(c1, c2) (*((uint32*)&(c1)) == *((uint32*)&(c2)))
+
+
+// Types
+#if 0
+#pragma mark *********** Types ***************
+#endif
+// type to convert values between rgb_color and gx_color_index
+typedef union {
+	rgb_color rgb;
+	gx_color_index index;
+} colorcast_t;
+
+// The BBitmap cache entry
+// The bitmaps are stored in a linked list
+typedef struct bmapcache_s {
+	gx_bitmap_id id;          // the id of the bitmap
+	struct bmapcache_s *next; // the next entry in the linked list
+	BBitmap bitmap;           // the BBitmap
+	
+	// constructor
+	bmapcache_s(
+		gx_bitmap_id id, 
+		BRect bounds, 
+		color_space mode) 
+	: 
+		id(id), 
+		next(NULL), 
+		bitmap(bounds, mode) // construct the BBitmap
+	{ 
+		// nothing to do
+	}
+} bmapcache;
+
+
+// The BBitmap alpha cache struct 
+typedef struct bmap_alpha_cache_s {
+	gx_bitmap_id id; // the id of the bitmap stored in this entry
+	rgb_color color; // the color of this bitmap
+	long size;       // the size of this bitmap in 4 bytes
+	struct bmap_alpha_cache_s *of_next;   // the next entry in the overflow list
+	struct bmap_alpha_cache_s *of_prev;   // the previous entry in the overflow list
+	struct bmap_alpha_cache_s *mru_next;  // the next entry in the MRU list (most recently used)
+	struct bmap_alpha_cache_s *mru_prev;  // the previous entry in the MRU list
+	struct bmap_alpha_cache_s **ht_entry; // the hashtable entry with this bitmap 	
+	BBitmap bitmap;
+
+	// constructor	
+	bmap_alpha_cache_s(
+		struct bmap_alpha_cache_s **ht_entry, 
+		gx_bitmap_id id, 
+		rgb_color color, 
+		int w, int h, 
+		color_space mode) 
+	:
+		id(id), 
+		color(color), 
+		size(w*h), 
+		of_next(NULL), 
+		of_prev(NULL), 
+		mru_next(NULL), 
+		mru_prev(NULL), 
+		ht_entry(ht_entry),
+		bitmap(BRect(0, 0, w-1, h-1), mode) // construct BBitmap
+	{ 
+		// nothing to do
+	}
+} bmap_alpha_cache;
+
+// Global variables
+HWND hwndtext;               /* currently unused */
+
+// alpha conversion table
+// 2 bit alpha -> 8 bit alpha (= 255/((1 << 2) - 1) * alpha)
+static unsigned char g_alpha2[4] = {0, 85, 170, 255};
+// 4 bit alpha -> 8 bit alpha (= 255/((1 << 4) - 1) * alpha)
+static unsigned char g_alpha4[16] = {0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};
+
+
+
+// Procedures for non anti-aliased device (named beos)
+#if 0
+#pragma mark *********** GS Procedures ***************
+#endif
+
+private dev_proc_open_device(be_open);
+private dev_proc_sync_output(be_sync);
+private dev_proc_output_page(be_output_page);
+private dev_proc_close_device(be_close);
+private dev_proc_map_rgb_color(be_map_rgb_color);
+private dev_proc_map_color_rgb(be_map_color_rgb);
+private dev_proc_fill_rectangle(be_fill_rectangle);
+private dev_proc_copy_mono(be_copy_mono);
+#if 0
+private dev_proc_copy_color(be_copy_color);
+#endif
+private dev_proc_draw_line(be_draw_line);
+
+#if 0
+// Not Implemented
+private dev_proc_strip_tile_rectangle(be_strip_tile_rectangle);
+
+private dev_proc_get_params(be_get_params);
+private dev_proc_put_params(be_put_params);
+#endif
+
+// Procedures for anti-aliased devices (bealpha2, bealpha4, bealpht2, bealpht4)
+private dev_proc_map_color_rgb(be_alpha_map_color_rgb);
+private dev_proc_map_rgb_alpha_color(be_alpha_map_rgb_alpha_color);
+private dev_proc_copy_alpha(be_alpha_copy_alpha);
+
+
+#if 0
+#pragma mark *********** Device Descriptors & Devices ***************
+#endif
+#if 0
+#pragma mark ** beos **
+#endif
+// The device descriptor used by gs_beos_device
+private gx_device_procs be_procs = {
+	be_open,
+	gx_default_get_initial_matrix,
+	be_sync,
+	be_output_page,
+	be_close,
+	be_map_rgb_color,
+	be_map_color_rgb,
+	be_fill_rectangle,
+	NULL,			/* tile_rectangle */
+	be_copy_mono,
+	NULL,			/* copy_color */
+	be_draw_line,
+	NULL,			/* get_bits */
+	NULL, // be_get_params,			/* get_params */
+	NULL, // be_put_params,			/* put_params */
+	NULL,			/* map_cmyk_color */
+	NULL,			/* get_xfont_procs */
+	NULL,			/* get_xfont_device */
+	NULL,			/* map_rgb_alpha_color */
+	gx_page_device_get_page_device,
+	NULL,			/* get_alpha_bits */
+	NULL,			/* copy_alpha */
+	NULL,			/* get_band */
+	NULL,			/* copy_rop */
+	NULL,			/* fill_path */
+	NULL,			/* stroke_path */
+	NULL,			/* fill_mask */
+	NULL,			/* fill_trapezoid */
+	NULL,			/* fill_parallelogram */
+	NULL,			/* fill_triangle */
+	NULL,			/* draw_thin_line */
+	NULL,			/* begin_image */
+	NULL,			/* image_data */
+	NULL,			/* end_image */
+	NULL			/* be_strip_tile_rectangle */
+};
+
+/* The instance is public. */
+gx_device_be gs_beos_device = {
+	std_device_color_body(gx_device_be, &be_procs, "beos",
+	  INITIAL_WIDTH, INITIAL_HEIGHT,
+	  INITIAL_RESOLUTION, INITIAL_RESOLUTION,
+	  24, 255, 256),
+	{ 0 },			/* std_procs */
+	-1,				/* mutex */
+	NULL,			/* main bitmap */
+	NULL,			/* offscreen view */
+	NULL,			/* bmapcache ptr */
+	0,				/* next bitmap to use */
+};
+
+/* ---------------------------------- */
+/* ------------ bealpha2 ------------ */
+/* ---------------------------------- */
+#if 0
+#pragma mark ** bealpha2 **
+#endif
+
+/* The device descriptor */
+private gx_device_procs be_alpha2_procs = {
+	be_open,
+	gx_default_get_initial_matrix,
+	be_sync,
+	be_output_page,
+	be_close,
+	be_map_rgb_color,
+	be_alpha_map_color_rgb, // be_map_color_rgb,
+	be_fill_rectangle,
+	NULL,			/* tile_rectangle */
+	be_copy_mono,
+	NULL,			/* copy_color */
+	be_draw_line,
+	NULL,			/* get_bits */
+	NULL,			/* get_params */
+	NULL,			/* put_params */
+	NULL,			/* map_cmyk_color */
+	NULL,			/* get_xfont_procs */
+	NULL,			/* get_xfont_device */
+	be_alpha_map_rgb_alpha_color,			/* map_rgb_alpha_color */
+	gx_page_device_get_page_device,
+	NULL,           /* get_alpha_bits */
+	be_alpha_copy_alpha,			/* copy_alpha */
+	NULL,			/* get_band */
+	NULL,			/* copy_rop */
+	NULL,			/* fill_path */
+	NULL,			/* stroke_path */
+	NULL,			/* fill_mask */
+	NULL,			/* fill_trapezoid */
+	NULL,			/* fill_parallelogram */
+	NULL,			/* fill_triangle */
+	NULL,			/* draw_thin_line */
+	NULL,			/* begin_image */
+	NULL,			/* image_data */
+	NULL,			/* end_image */
+	NULL			/* be_strip_tile_rectangle */
+};
+
+/* The instance is public. */
+gx_device_be gs_bealpha2_device = {
+    std_device_dci_alpha_type_body(gx_device_be, &be_alpha2_procs,
+	"bealpha2", NULL,
+	  INITIAL_WIDTH, INITIAL_HEIGHT,
+	  INITIAL_RESOLUTION, INITIAL_RESOLUTION,
+	3, 32, 255, 255, 256, 256, 2, 2),
+	{ 0 },			/* std_procs */
+	-1,				/* mutex */
+	NULL,			/* main bitmap */
+	NULL,			/* offscreen view */
+	NULL,			/* bmapcache ptr */
+	0,				/* next bitmap to use */
+};
+
+
+/* ---------------------------------- */
+/* ------------ bealpha4 ------------ */
+/* ---------------------------------- */
+#if 0
+#pragma mark ** bealpha4 **
+#endif
+
+/* The device descriptor */
+private gx_device_procs be_alpha4_procs = {
+	be_open,
+	gx_default_get_initial_matrix,
+	be_sync,
+	be_output_page,
+	be_close,
+	be_map_rgb_color,
+	be_alpha_map_color_rgb, // be_map_color_rgb,
+	be_fill_rectangle,
+	NULL,			/* tile_rectangle */
+	be_copy_mono,
+	NULL,			/* copy_color */
+	be_draw_line,
+	NULL,			/* get_bits */
+	NULL,			/* get_params */
+	NULL,			/* put_params */
+	NULL,			/* map_cmyk_color */
+	NULL,			/* get_xfont_procs */
+	NULL,			/* get_xfont_device */
+	be_alpha_map_rgb_alpha_color,			/* map_rgb_alpha_color */
+	gx_page_device_get_page_device,
+	NULL, // be_alpha4_get_alpha_bits,			/* get_alpha_bits */
+	be_alpha_copy_alpha,			/* copy_alpha */
+	NULL,			/* get_band */
+	NULL,			/* copy_rop */
+	NULL,			/* fill_path */
+	NULL,			/* stroke_path */
+	NULL,			/* fill_mask */
+	NULL,			/* fill_trapezoid */
+	NULL,			/* fill_parallelogram */
+	NULL,			/* fill_triangle */
+	NULL,			/* draw_thin_line */
+	NULL,			/* begin_image */
+	NULL,			/* image_data */
+	NULL,			/* end_image */
+	NULL			/* be_strip_tile_rectangle */
+};
+
+/* The instance is public. */
+gx_device_be gs_bealpha4_device = {
+    std_device_dci_alpha_type_body(gx_device_be, &be_alpha4_procs,
+	"bealpha4", NULL,
+	  INITIAL_WIDTH, INITIAL_HEIGHT,
+	  INITIAL_RESOLUTION, INITIAL_RESOLUTION,
+	3, 32, 255, 255, 256, 256, 4, 4),
+	{ 0 },			/* std_procs */
+	-1,				/* mutex */
+	NULL,			/* main bitmap */
+	NULL,			/* offscreen view */
+	NULL,			/* bmapcache ptr */
+	0,				/* next bitmap to use */
+};
+
+/* ---------------------------------- */
+/* ------------ bealpht2 ------------ */
+/* ---------------------------------- */
+#if 0
+#pragma mark ** bealpht2 **
+#endif
+
+/* The device descriptor */
+private gx_device_procs be_alpht2_procs = {
+	be_open,
+	gx_default_get_initial_matrix,
+	be_sync,
+	be_output_page,
+	be_close,
+	be_map_rgb_color,
+	be_alpha_map_color_rgb, // be_map_color_rgb,
+	be_fill_rectangle,
+	NULL,			/* tile_rectangle */
+	be_copy_mono,
+	NULL,			/* copy_color */
+	be_draw_line,
+	NULL,			/* get_bits */
+	NULL,			/* get_params */
+	NULL,			/* put_params */
+	NULL,			/* map_cmyk_color */
+	NULL,			/* get_xfont_procs */
+	NULL,			/* get_xfont_device */
+	be_alpha_map_rgb_alpha_color,			/* map_rgb_alpha_color */
+	gx_page_device_get_page_device,
+	NULL,			/* get_alpha_bits */
+	be_alpha_copy_alpha,			/* copy_alpha */
+	NULL,			/* get_band */
+	NULL,			/* copy_rop */
+	NULL,			/* fill_path */
+	NULL,			/* stroke_path */
+	NULL,			/* fill_mask */
+	NULL,			/* fill_trapezoid */
+	NULL,			/* fill_parallelogram */
+	NULL,			/* fill_triangle */
+	NULL,			/* draw_thin_line */
+	NULL,			/* begin_image */
+	NULL,			/* image_data */
+	NULL,			/* end_image */
+	NULL			/* be_strip_tile_rectangle */
+};
+
+/* The instance is public. */
+gx_device_be gs_bealpht2_device = {
+    std_device_dci_alpha_type_body(gx_device_be, &be_alpht2_procs,
+	"bealpht2", NULL,
+	  INITIAL_WIDTH, INITIAL_HEIGHT,
+	  INITIAL_RESOLUTION, INITIAL_RESOLUTION,
+	3, 32, 255, 255, 256, 256, 2, 1),
+	{ 0 },			/* std_procs */
+	-1,				/* mutex */
+	NULL,			/* main bitmap */
+	NULL,			/* offscreen view */
+	NULL,			/* bmapcache ptr */
+	0,				/* next bitmap to use */
+};
+
+/* ---------------------------------- */
+/* ------------ bealpht4 ------------ */
+/* ---------------------------------- */
+#if 0
+#pragma mark ** bealphat4 **
+#endif
+
+/* The device descriptor */
+private gx_device_procs be_alpht4_procs = {
+	be_open,
+	gx_default_get_initial_matrix,
+	be_sync,
+	be_output_page,
+	be_close,
+	be_map_rgb_color,
+	be_alpha_map_color_rgb, // be_map_color_rgb,
+	be_fill_rectangle,
+	NULL,			/* tile_rectangle */
+	be_copy_mono,
+	NULL,			/* copy_color */
+	be_draw_line,
+	NULL,			/* get_bits */
+	NULL,			/* get_params */
+	NULL,			/* put_params */
+	NULL,			/* map_cmyk_color */
+	NULL,			/* get_xfont_procs */
+	NULL,			/* get_xfont_device */
+	be_alpha_map_rgb_alpha_color,			/* map_rgb_alpha_color */
+	gx_page_device_get_page_device,
+	NULL, 			/* get_alpha_bits */
+	be_alpha_copy_alpha,			/* copy_alpha */
+	NULL,			/* get_band */
+	NULL,			/* copy_rop */
+	NULL,			/* fill_path */
+	NULL,			/* stroke_path */
+	NULL,			/* fill_mask */
+	NULL,			/* fill_trapezoid */
+	NULL,			/* fill_parallelogram */
+	NULL,			/* fill_triangle */
+	NULL,			/* draw_thin_line */
+	NULL,			/* begin_image */
+	NULL,			/* image_data */
+	NULL,			/* end_image */
+	NULL			/* be_strip_tile_rectangle */
+};
+
+/* The instance is public. */
+gx_device_be gs_bealpht4_device = {
+    std_device_dci_alpha_type_body(gx_device_be, &be_alpht4_procs,
+	"bealpht4", NULL,
+	  INITIAL_WIDTH, INITIAL_HEIGHT,
+	  INITIAL_RESOLUTION, INITIAL_RESOLUTION,
+	3, 32, 255, 255, 256, 256, 4, 1),
+	{ 0 },			/* std_procs */
+	-1,				/* mutex */
+	NULL,			/* main bitmap */
+	NULL,			/* offscreen view */
+	NULL,			/* bmapcache ptr */
+	0,				/* next bitmap to use */
+};
+
+
+// -----------------------------------------------------------------------------
+// Bitmap Cache Functions
+// -----------------------------------------------------------------------------
+
+// Initialize the bitmap cache
+private void
+initialize_bitmap_cache(gx_device_be* bdev)
+{
+	bdev->_bmapcache_current = &(bdev->_bmapcache);
+}
+
+// flush
+private void
+flush_bitmap_cache(gx_device_be* bdev) 
+{
+	bmapcache_s *cur = bdev->_bmapcache;
+	while(cur) {
+		bmapcache_s *next = cur->next;
+		delete cur;
+		cur = next;
+	}
+	bdev->_bmapcache = NULL;
+	bdev->_bmapcache_current = &(bdev->_bmapcache);
+}
+
+// store bitmap in bitmap cache
+private void
+add_to_bitmap_cache(gx_device_be* bdev, bmapcache_s* bmapc)
+{
+	*(bdev->_bmapcache_current) = bmapc;
+	bdev->_bmapcache_current = &(bmapc->next);
+}
+
+// find bitmap in bitmap cache
+private BBitmap*
+find_bitmap(gx_device_be* bdev, gx_bitmap_id id)
+{
+	if(id != gx_no_bitmap_id) {
+		bmapcache_s *current = bdev->_bmapcache;
+		while(current) {
+		    if(current->id == id) {
+		    	return &(current->bitmap);
+		    }
+			current = current->next;
+		}
+	}
+	return NULL;
+}
+
+
+// -----------------------------------------------------------------------------
+// Alpha Bitmap Cache Functions
+// -----------------------------------------------------------------------------
+
+// Initialize cache
+private void
+be_alpha_initialize(gx_device_be* bdev)
+{
+	// initialize hash table
+	for (int i = 0; i < BE_ALPHA_HASHTABLE_SIZE; i++) {
+		bdev->_alpha_hashtable[i] = NULL;
+	}
+	// initialize MRU list
+	bdev->_alpha_mru_first = NULL;
+	bdev->_alpha_mru_last = NULL;
+	// initialize run time statistics
+	bdev->_alpha_num_bmaps = 0;
+	bdev->_alpha_size = 0;
+}
+
+// Uninitialize cache
+private void
+be_alpha_uninitialize(gx_device_be* bdev)
+{
+	// remove bitmaps from hash table
+	bmap_alpha_cache *current, *old;
+	for (int i = 0; i < BE_ALPHA_HASHTABLE_SIZE; i++) {
+		current = bdev->_alpha_hashtable[i];
+		while (current) {
+			old = current;
+			current = current->of_next;
+			delete old;
+		}
+		bdev->_alpha_hashtable[i] = NULL;
+	}
+		
+	bdev->_alpha_mru_first = NULL;
+	bdev->_alpha_mru_last  = NULL;
+	bdev->_alpha_num_bmaps = 0;
+	bdev->_alpha_size      = 0;
+}
+
+// Find bmapc in hash table
+// Returns entry in hash table and bmapc if it is in overflow list
+private INLINE bmap_alpha_cache **
+be_alpha_find_bmap(
+	gx_device_be *bdev, 
+	gx_bitmap_id id, 
+	rgb_color color, 
+	bmap_alpha_cache **bmapc) 
+{
+	bmap_alpha_cache **ht_entry = &bdev->_alpha_hashtable[BE_ALPHA_HASH(id)];
+	bmap_alpha_cache *current = *ht_entry;
+	// find bitmap in overflow list
+	while (current) {
+	 	if ((current->id == id) && SAME_COLOR(current->color, color)) {
+	 		break; // found
+	 	}
+		current = current->of_next;
+	}
+	*bmapc = current;
+	return ht_entry;
+}
+
+// Insert bmapc at top of overflow list of hashtable entry ht_entry
+private INLINE void 
+be_alpha_ht_insert(
+	gx_device_be *bdev, 
+	bmap_alpha_cache **ht_entry, 
+	bmap_alpha_cache *bmapc) 
+{
+	bmapc->of_next = *ht_entry;
+	bmapc->of_prev = NULL;
+	if (*ht_entry) {
+		(*ht_entry)->of_prev = bmapc;
+	}
+	*ht_entry = bmapc;
+}
+
+// Remove bmapc from overflow list of hasttable entry ht_entry
+private INLINE void 
+be_alpha_ht_remove(
+	gx_device_be *bdev, 
+	bmap_alpha_cache **ht_entry, 
+	bmap_alpha_cache *bmapc) 
+{
+	// is bmapc on top of overflow list?
+	if (*ht_entry == bmapc) {
+		*ht_entry = bmapc->of_next;
+	}
+	// update doubly linked overflow list
+	if (bmapc->of_next) {
+		bmapc->of_next->of_prev = bmapc->of_prev;
+	}
+	if (bmapc->of_prev) {
+		bmapc->of_prev->of_next = bmapc->of_next;
+	}
+}
+
+// Insert bmapc at top of MRU list. bmpac must not be in list already!
+private INLINE void 
+be_alpha_mru_insert(
+	gx_device_be *bdev, 
+	bmap_alpha_cache *bmapc) 
+{
+	// update doubly linked list
+	bmapc->mru_next = bdev->_alpha_mru_first;
+	bmapc->mru_prev = NULL;
+	if (bdev->_alpha_mru_first) {
+		// MRU list was not empty
+		bdev->_alpha_mru_first->mru_prev = bmapc;
+	} else { 
+		// bmapc is first element in MRU list
+		bdev->_alpha_mru_last = bmapc; 
+	}
+	// bmapc becomes top of MRU list	
+	bdev->_alpha_mru_first = bmapc;
+}
+
+// Remove bmapc from MRU list
+private INLINE void 
+be_alpha_mru_remove(
+	gx_device_be *bdev, 
+	bmap_alpha_cache *bmapc) 
+{
+	if (bdev->_alpha_mru_first == bmapc) { 
+		bdev->_alpha_mru_first = bmapc->mru_next;
+	}
+	if (bdev->_alpha_mru_last == bmapc) {
+		bdev->_alpha_mru_last = bmapc->mru_prev;
+	}
+	if (bmapc->mru_next) {
+		bmapc->mru_next->mru_prev = bmapc->mru_prev;
+	}
+	if (bmapc->mru_prev) {
+		bmapc->mru_prev->mru_next = bmapc->mru_next;
+	}
+}
+
+// Move bmapc on top of overflow list of hashtable entry ht_entry
+private INLINE void 
+be_alpha_update_of_list(
+	gx_device_be *bdev, 
+	bmap_alpha_cache **ht_entry, 
+	bmap_alpha_cache *bmapc) 
+{
+	if (*ht_entry != bmapc) {
+		be_alpha_ht_remove(bdev, ht_entry, bmapc);
+		be_alpha_ht_insert(bdev, ht_entry, bmapc);
+	}
+}
+
+// Move bmapc in front of mru list
+private INLINE void 
+be_alpha_update_mru_list(
+	gx_device_be *bdev, 
+	bmap_alpha_cache *bmapc) 
+{
+	if (bdev->_alpha_mru_first != bmapc) {
+		be_alpha_mru_remove(bdev, bmapc);
+		be_alpha_mru_insert(bdev, bmapc);
+	}
+}
+
+// Move bmapc on top of overflow list and MRU list
+private INLINE void 
+be_alpha_move_to_top(
+	gx_device_be *bdev, 
+	bmap_alpha_cache **ht_entry, 
+	bmap_alpha_cache *bmapc) 
+{
+	be_alpha_update_of_list(bdev, ht_entry, bmapc);
+	be_alpha_update_mru_list(bdev, bmapc);
+}
+
+// Add bmapc to overflow list and MRU list
+private INLINE void 
+be_alpha_insert_bmap(
+	gx_device_be *bdev, 
+	bmap_alpha_cache **ht_entry, 
+	bmap_alpha_cache *bmapc) 
+{
+	be_alpha_ht_insert(bdev, ht_entry, bmapc);
+	be_alpha_mru_insert(bdev, bmapc);
+	bdev->_alpha_num_bmaps ++;
+	bdev->_alpha_size += bmapc->size;
+}
+
+// Remove bmapc from overflow list and MRU list
+private INLINE void 
+be_alpha_remove_bmap(
+	gx_device_be *bdev, 
+	bmap_alpha_cache **ht_entry, 
+	bmap_alpha_cache *bmapc) 
+{
+	be_alpha_ht_remove(bdev, ht_entry, bmapc);
+	be_alpha_mru_remove(bdev, bmapc);
+	bdev->_alpha_num_bmaps --;
+	bdev->_alpha_size -= bmapc->size;
+}
+
+
+// -----------------------------------------------------------------------------
+// Device functions
+// -----------------------------------------------------------------------------
+
+/* Open the device. */
+private int
+be_open(gx_device *dev)
+{
+	// gx_device_be has been created for us
+    gx_device_be *bdev = (gx_device_be *)dev;
+    initialize_bitmap_cache(bdev);
+	// create semaphore for locking
+	bdev->_mutex = create_sem(1, "gsdll sem");
+	
+	if (dev->width == INITIAL_WIDTH)
+		dev->width = (int)(8.5 * dev->x_pixels_per_inch);
+	if (dev->height == INITIAL_HEIGHT)
+		dev->height = (int)(11.0 * dev->y_pixels_per_inch);
+
+	// initialize cached bitmap
+	bdev->_cached_bitmap = NULL;
+	bdev->_cached_width  = 0;
+	bdev->_cached_height = 0;
+
+	// setup BBitmap and BView
+	BRect frame(0.0, 0.0, dev->width-1, dev->height-1);
+	bdev->_bitmap = new BBitmap(frame, B_RGB_32_BIT, true);
+	bdev->_view = new BView(frame, "bitmap view", B_FOLLOW_NONE, B_WILL_DRAW);
+	bdev->_bitmap->AddChild(bdev->_view);
+	bdev->_view->Window()->Lock();
+	bdev->_view->SetBlendingMode(B_PIXEL_ALPHA, B_ALPHA_OVERLAY);
+
+	be_alpha_initialize(bdev);
+
+#if PROFILE
+	// initialize profiler statistics
+	bdev->_fillrect  = 0;
+	bdev->_copymono  = 0;
+	bdev->_drawline  = 0;
+	bdev->_copyalpha = 0;
+	bdev->_size      = 0; 
+	bdev->_bitmaps   = 0;
+#endif
+
+	// Notify caller about new device
+	(*pgsdll_callback)(GSDLL_DEVICE, (char *)dev, 1);
+	// Notify caller about the page size
+	(*pgsdll_callback)(GSDLL_SIZE, (char *)dev,
+			(dev->width & 0xffff) +
+			((ulong)(dev->height & 0xffff) << 16));
+    return 0;
+}
+
+#if PROFILE
+private void
+print_profile_statistics(gx_device_be* bdev)
+{
+    fprintf(stderr, "fillrect=%d copymono=%d drawline=%d copyalpha=%d "
+    	"bitmaps=%ld size=%ld\n",
+    	bdev->_fillrect, 
+    	bdev->_copymono, 
+    	bdev->_drawline, 
+    	bdev->_copyalpha,
+   		bdev->_bitmaps, 
+   		bdev->_size);
+
+    fprintf(stderr, "alpha_num_bmaps=%d alpha_size=%ld\n",
+   		bdev->_alpha_num_bmaps, 
+   		bdev->_alpha_size);
+
+}
+#endif
+
+/* Close the device. */
+private int
+be_close(gx_device *dev)
+{
+    gx_device_be *bdev = (gx_device_be *)dev;
+
+    // wait until bitmap is not being used by caller
+    gsdll_lock_device((unsigned char*)dev, 1);
+
+    // notify caller that device has been closed
+	(*pgsdll_callback)(GSDLL_DEVICE, (char *)dev, 0);
+	gsdll_lock_device((unsigned char*)dev, 0);
+
+
+	// complete all drawing operations
+	bdev->_view->Sync();
+	
+	// delete bitmap; deletes view too
+	delete bdev->_bitmap;
+	
+	// delete cached bitmap
+	delete bdev->_cached_bitmap;
+	
+	// delete monochrome bitmap cache
+	flush_bitmap_cache(bdev);
+
+	be_alpha_uninitialize(bdev);
+
+	delete_sem(bdev->_mutex);
+
+#if PROFILE
+	print_profile_statistics(bdev);
+#endif
+
+    return 0;
+}
+
+/* Map a color to index.  */
+private gx_color_index
+be_map_rgb_color(
+	register gx_device *dev,
+	const gx_color_value rgb[])
+{
+    colorcast_t colorcast;
+	colorcast.rgb.red   = rgb[0] >> 8;
+	colorcast.rgb.green = rgb[1] >> 8;
+	colorcast.rgb.blue  = rgb[2] >> 8;
+	colorcast.rgb.alpha = 0;
+	return colorcast.index;
+}
+
+
+/* Map a "device color" back to r-g-b. */
+private int
+be_map_color_rgb(
+	register gx_device *dev, 
+	gx_color_index color,
+	gx_color_value prgb[3])
+{
+	colorcast_t colorcast;
+	
+	colorcast.index = color;
+	prgb[0] = colorcast.rgb.red << 8;
+	prgb[1] = colorcast.rgb.green << 8;
+	prgb[2] = colorcast.rgb.blue << 8;
+	return 0;
+}
+
+// Synchronize the display with the commands already given 
+private int
+be_sync(register gx_device *dev)
+{
+    gx_device_be *bdev = (gx_device_be *)dev;
+    
+    bdev->_view->Sync();
+    
+    return (*pgsdll_callback)(GSDLL_SYNC, (char *)dev, 0);
+}
+
+// Display the output.
+int
+be_output_page(gx_device *dev, int copies, int flush)
+{
+    gx_device_be *bdev = (gx_device_be *)dev;
+    
+    bdev->_view->Sync();
+    
+	int ret = (*pgsdll_callback)(GSDLL_PAGE, (char *)dev, 0);
+
+#if PROFILE
+	print_profile_statistics(bdev);
+#endif
+
+    return ret;
+}
+
+// Fill a rectangle with a color.
+private int
+be_fill_rectangle(register gx_device *dev,
+		 int x, int y, int w, int h, gx_color_index color)
+{
+#if PROFILE
+    bigtime_t start = system_time();
+#endif
+
+    gx_device_be *bdev = (gx_device_be *)dev;
+    
+	colorcast_t colorcast;
+	colorcast.index = color;
+	bdev->_view->SetDrawingMode(B_OP_COPY);
+	bdev->_view->SetHighColor(colorcast.rgb);
+	bdev->_view->FillRect(BRect(x, y, w+x-1, y+h-1));
+
+	if(x <= 0 && y <= 0 && w >= bdev->width && h >= bdev->height) {
+		bdev->_view->Sync();
+		// Just cleared the screen so clear the bitmap cache 
+		flush_bitmap_cache(bdev);
+	}
+
+#if PROFILE
+	bdev->_fillrect += (int)(system_time() - start);
+#endif
+
+	return 0;
+}
+
+/* Copy a monochrome bitmap. */
+private int
+be_copy_mono(register gx_device *dev,
+	    const byte *base, int sourcex, int raster, gx_bitmap_id id,
+	    int x, int y, int w, int h,
+	    gx_color_index zero, gx_color_index one)
+{
+#if TRACE_COPY_CALLS
+	fprintf(stderr, "*+-m\t%d\t%d\t%d\t%ld\t%ld\n",
+		(int)id,
+		w, h,
+		(unsigned long)zero,
+		(unsigned long)one);
+#endif
+
+#if PROFILE
+    bigtime_t start = system_time();
+#endif
+
+    gx_device_be *bdev = (gx_device_be *)dev;
+
+    if(raster > 0) {
+		colorcast_t colorcast;
+		
+		// set high color
+		colorcast.index = one;
+		bdev->_view->SetHighColor(colorcast.rgb);
+		
+		// set low color
+		if(zero == gx_no_color_index) {
+			// transparent pixels
+			bdev->_view->SetDrawingMode(B_OP_OVER);
+		} else {
+			colorcast.index = zero;
+			bdev->_view->SetLowColor(colorcast.rgb);
+			bdev->_view->SetDrawingMode(B_OP_COPY);
+		}
+	
+		BBitmap *bitmap = NULL;
+		bitmap = find_bitmap(bdev, id);
+		bool bitmapInCache = bitmap != NULL;
+		
+		BRect from(sourcex, 0, sourcex + w - 1, h - 1);
+		BRect to(x, y, x + w - 1, y + h - 1);
+		
+		bmapcache_s *bmapc = NULL;
+		if(!bitmapInCache) {
+			// create new bitmap
+			bmapc = new bmapcache_s(id, BRect(0.0, 0.0, (raster << 3) - 1, h - 1), B_MONOCHROME_1_BIT);
+		    bmapc->bitmap.SetBits(base, raster * h, 0, B_MONOCHROME_1_BIT);
+			bitmap = &(bmapc->bitmap);
+			
+		    if (id != gx_no_bitmap_id) {
+		    	// store bitmap in cache
+		    	add_to_bitmap_cache(bdev, bmapc);
+				bdev->_view->DrawBitmapAsync(bitmap, from, to);
+				bitmapInCache = true;
+			}
+		}
+		
+		if (bitmapInCache) {
+			bdev->_view->DrawBitmapAsync(bitmap, from, to);
+		} else {
+			bdev->_view->DrawBitmap(bitmap, from, to);
+			delete bmapc;
+		}
+    }
+    
+#if PROFILE
+	bdev->_copymono += (int)(system_time() - start);
+#endif
+
+    return 0;
+}
+
+/* Copy a color bitmap. */
+/* Note:  I couldn't find any PS file which uses this function, so I left
+ * it unimplemented for now.  -jeh
+ */
+#if 0
+private int
+be_copy_color(register gx_device *dev,
+	     const byte *base, int sourcex, int raster, gx_bitmap_id id,
+	     int x, int y, int w, int h)
+{
+    fprintf(stderr, "copy color!\n");
+    return 0;
+}
+#endif
+
+/* Draw a line */
+private int
+be_draw_line(register gx_device *dev,
+  	     int x0, int y0, int x1, int y1, 
+  	     gx_color_index color)
+{
+#if PROFILE
+    bigtime_t start = system_time();
+#endif
+
+    gx_device_be *bdev = (gx_device_be *)dev;
+	colorcast_t colorcast;
+	colorcast.index = color;
+	bdev->_view->SetDrawingMode(B_OP_COPY);
+	bdev->_view->SetHighColor(colorcast.rgb);
+	bdev->_view->StrokeLine(BPoint(x0, y0), BPoint(x1, y1));
+
+#if PROFILE
+	bdev->_drawline += (int)(system_time() - start);
+#endif
+
+    return 0;
+}
+
+/* Tile a rectangle. */
+/* Note:  Because the Be GUI always has at least 256 colors, and because
+ *   this function is only used for halftoning, I left it unimplemented for
+ *   now.  -jeh
+ */
+#if 0
+private int
+be_strip_tile_rectangle(register gx_device *dev, const gx_strip_bitmap *tiles,
+		       int x, int y, int w, int h,
+		       gx_color_index zero, gx_color_index one,
+		       int px, int py)
+{
+    fprintf(stderr, "Striptile rectangle\n");
+    return 0;
+}
+#endif
+
+// Lock to make DLL threadsafe
+#if defined(__POWERPC__)
+__declspec(export)
+#endif
+int gsdll_lock_device(unsigned char *dev, int flag) {
+	gx_device_be *bdev = (gx_device_be *)dev;
+	
+    if (flag) {
+    	acquire_sem(bdev->_mutex);
+    	return 1;
+    }
+    
+    release_sem(bdev->_mutex);
+    return 0;
+}
+
+// Draw to on-screen BView 
+#if defined(__POWERPC__)
+__declspec(export)
+#endif
+void gsdll_draw(unsigned char *dev, BView *view, BRect dest, BRect src) {
+	gx_device_be *bdev = (gx_device_be *)dev;
+	view->SetDrawingMode(B_OP_COPY);
+	view->DrawBitmapAsync(bdev->_bitmap, src, dest);
+}
+
+#if 0
+// TODO Use an argument to specify whether to use anti-aliasing or not
+// and the the bit depth of the alpha channel.
+int be_get_params(gx_device *dev, gs_param_list *plist) {
+	if (plist) {
+		gs_param_enumerator_t iterator;
+		gs_param_key_t key;
+		param_init_enumerator(&iterator);
+		while (0 == param_get_next_key(plist, &iterator, &key)) {
+			if (key.data) {
+				fprintf(stderr, "%*.*s %d\n", (int)key.size, (int)key.size, key.data);
+			}
+		}
+	}
+	return 0;
+}
+
+int be_put_params(gx_device *dev, gs_param_list *plist) {	
+	if (plist) {
+		gs_param_enumerator_t iterator;
+		gs_param_key_t key;
+		param_init_enumerator(&iterator);
+		while (0 == param_get_next_key(plist, &iterator, &key)) {
+			if (key.data) {
+				fprintf(stderr, "%*.*s %d\n", (int)key.size, (int)key.size, key.data);
+			}
+		}
+	
+		int bpp;
+		param_read_int(plist, "BitsPerPixel", &bpp);
+		long l;
+		param_read_long(plist, "BitsPerPixel", &l);
+	}
+	return 0;
+}
+#endif
+
+
+/* Anti-aliasing Devices: bealpha2, bealpha4, bealpht2, bealpht4 */
+
+// Color conversion from gx_color_index to gx_color_value
+private int
+be_alpha_map_color_rgb(
+	gx_device * dev, 
+	gx_color_index color,
+	gx_color_value prgb[3])
+{
+    colorcast_t colorcast;
+	colorcast.index = color;
+	prgb[0] = colorcast.rgb.red   << 8;
+	prgb[1] = colorcast.rgb.green << 8;
+	prgb[2] = colorcast.rgb.blue  << 8;
+	return 0;	
+}
+
+// Color conversion from gx_color_values to index
+private gx_color_index
+be_alpha_map_rgb_alpha_color(
+	gx_device * dev,
+	gx_color_value r, 
+	gx_color_value g, 
+	gx_color_value b, 
+	gx_color_value alpha)
+{
+    colorcast_t colorcast;
+	colorcast.rgb.red   = r >> 8;
+	colorcast.rgb.green = g >> 8;
+	colorcast.rgb.blue  = b >> 8;
+	colorcast.rgb.alpha = alpha >> 8;
+	return colorcast.index;
+}
+
+
+private void
+make_room_in_alpha_cache(gx_device_be* bdev)
+{
+	bmap_alpha_cache *bmapc;
+	// Remove bitmaps from cache if required
+	if ((bdev->_alpha_num_bmaps >= BE_ALPHA_MAX_BITMAPS) || (bdev->_alpha_size >= BE_ALPHA_MAX_SIZE)) {
+		bdev->_view->Sync();
+		// Do we need to remove more bitmaps?
+		bmapc = bdev->_alpha_mru_last;
+		if (bmapc && 
+			((bdev->_alpha_num_bmaps >= BE_ALPHA_MAX_BITMAPS) || (bdev->_alpha_size >= BE_ALPHA_MAX_SIZE))) {
+			// Remove the least recently used bitmaps
+			do {
+				be_alpha_remove_bmap(bdev, bmapc->ht_entry, bmapc);
+				delete bmapc;
+				bmapc = bdev->_alpha_mru_last;
+			} while (bmapc && 
+				((bdev->_alpha_num_bmaps >= (BE_ALPHA_MAX_BITMAPS - BE_ALPHA_REMOVE_BITMAPS)) || 
+				(bdev->_alpha_size >= BE_ALPHA_MAX_SIZE)));
+		}
+	}
+} 
+
+// 2 alpha bits per pixel  (4 alpha values per byte in base)
+private void
+alpha2_to_bitmap(const unsigned char *base, int raster, int w, int h, BBitmap* bitmap, colorcast_t colorcast)
+{
+	unsigned char *bmp = (unsigned char*)bitmap->Bits();
+	int32 bpr = bitmap->BytesPerRow();
+	const unsigned char *data = base;
+	int32 w4 = w/4;
+	int32 rest = w & 3;
+	
+	for (int32 line = h; line; line --) {
+		// start of line
+		const unsigned char *src = data; 
+		rgb_color *dst = (rgb_color*)bmp; 
+		
+		// next line
+		data += raster;
+		bmp += bpr;
+		
+		// fill bitmap
+		for (int32 column = w4; column; column --) {
+			colorcast.rgb.alpha = g_alpha2[(*src) >> 6];
+			*dst = colorcast.rgb;
+			dst++;
+			
+			colorcast.rgb.alpha = g_alpha2[((*src) >> 4) & 0x03];
+			*dst = colorcast.rgb;
+			dst++;
+			
+			colorcast.rgb.alpha = g_alpha2[((*src) >> 2) & 0x03];
+			*dst = colorcast.rgb;
+			dst++;
+			
+			colorcast.rgb.alpha = g_alpha2[(*src) & 0x03];
+			*dst = colorcast.rgb;
+			dst++; src++;
+		}
+		
+		switch (rest) {
+			case 1:
+				colorcast.rgb.alpha = g_alpha2[(*src) >> 6];
+				*dst = colorcast.rgb;
+				break;
+
+			case 2:
+				colorcast.rgb.alpha = g_alpha2[(*src) >> 6];
+				*dst = colorcast.rgb;
+				dst++;
+				
+				colorcast.rgb.alpha = g_alpha2[((*src) >> 4) & 0x03];
+				*dst = colorcast.rgb;
+				break;
+				
+			case 3:
+				colorcast.rgb.alpha = g_alpha2[(*src) >> 6];
+				*dst = colorcast.rgb;
+				dst++;
+				
+				colorcast.rgb.alpha = g_alpha2[((*src) >> 4) & 0x03];
+				*dst = colorcast.rgb;
+				dst++;
+				
+				colorcast.rgb.alpha = g_alpha2[((*src) >> 2) & 0x03];
+				*dst = colorcast.rgb;
+				break;
+		}
+	}
+}
+
+
+// 4 alpha bits per pixel (2 alpha values per byte in base)
+private void
+alpha4_to_bitmap(const unsigned char *base, int raster, int w, int h, BBitmap* bitmap, colorcast_t colorcast)
+{
+	unsigned char *bmp = (unsigned char*)bitmap->Bits();
+	int32 bpr = bitmap->BytesPerRow();
+	const unsigned char *data = base;
+	int32 w2 = w/2;
+	bool rest = (w & 1) > 0;
+	
+	for (int32 line = h; line; line --) {
+		// start of line
+		const unsigned char *src = data; 
+		rgb_color *dst = (rgb_color*)bmp;
+		
+		// next line
+		data += raster;
+		bmp += bpr;
+		
+		// fill bitmap
+		for (int32 column = w2; column; column --) {
+			colorcast.rgb.alpha = g_alpha4[(*src) >> 4];
+			*dst = colorcast.rgb;
+			dst++;
+			
+			colorcast.rgb.alpha = g_alpha4[(*src) & 0x0F];
+			*dst = colorcast.rgb;
+			src++; dst++;
+		}
+	
+		if (rest) {
+			colorcast.rgb.alpha = g_alpha4[(*src) >> 4];
+			*dst = colorcast.rgb;
+		}
+	}
+}
+
+// return a bitmap that is large enough (if necessary delete the cached bitmap
+// and create a new one)
+private BBitmap*
+get_cached_bitmap(gx_device_be* bdev, int w, int h)
+{
+	BBitmap* bitmap = bdev->_cached_bitmap;
+	if (bitmap == NULL || (bdev->_cached_width < w) || (bdev->_cached_height < h)) {
+		delete bitmap;
+		bitmap = new BBitmap(BRect(0.0, 0.0, w-1, h-1), B_RGBA32);
+		bdev->_cached_bitmap = bitmap;
+		bdev->_cached_width = w;
+		bdev->_cached_height = h;
+	}
+	return bitmap;
+}
+
+// Copy alpha mask
+private int
+be_alpha_copy_alpha(
+	gx_device * dev, 
+	const unsigned char *base, 
+	int sourcex,
+	int raster, 
+	gx_bitmap_id id, 
+	int x, int y, int w, int h,
+	gx_color_index color, 
+	int depth)
+{
+#if TRACE_COPY_CALLS
+	fprintf(stderr, "*+-a\t%d\t%d\t%d\t%ld\t%d\n",
+		(int)id,
+		w, h,
+		(unsigned long)color,
+		depth);
+#endif
+
+#if PROFILE
+    bigtime_t start = system_time();
+#endif
+
+    gx_device_be *bdev = (gx_device_be *)dev;
+
+    if(raster > 0) {
+		colorcast_t colorcast;
+		colorcast.index = color;
+	
+		// We have to swap red and blue values, so we can use colorcast.rgb to write directly to memory
+		unsigned char swap = colorcast.rgb.red; 
+		colorcast.rgb.red = colorcast.rgb.blue; 
+		colorcast.rgb.blue = swap;
+	
+		BBitmap *bitmap = NULL;
+	
+		bmap_alpha_cache **ht_entry = NULL;
+		bmap_alpha_cache *bmapc;
+		
+		
+		// look in alpha cache
+		if (id != gx_no_bitmap_id) {
+			ht_entry = be_alpha_find_bmap(bdev, id, colorcast.rgb, &bmapc);
+			if (bmapc != NULL) { 
+				// cache hit 
+				bitmap = &(bmapc->bitmap);
+				be_alpha_move_to_top(bdev, ht_entry, bmapc);
+			}
+		}
+	
+		if(bitmap == NULL) {
+			// Create a bitmap in the color 'color'; take alpha channel from 'base'
+			if (ht_entry) {
+			#if 0
+				// if cache is full
+				//   if cache has reuseable bitmap
+				//      take bitmap, move to top, sync
+				//   else
+				//      delete some bitmaps from cache
+				// else
+				//   create a new bitmap
+			#else
+				make_room_in_alpha_cache(bdev);
+				bmapc = new bmap_alpha_cache_s(ht_entry, id, colorcast.rgb, w, h, B_RGBA32);
+				bitmap = &(bmapc->bitmap); 
+				be_alpha_insert_bmap(bdev, ht_entry, bmapc);
+			#endif
+			} else {
+				// Because bitmaps are drawn asynchronously wait for completion
+				// otherwise we could delete or overwrite a currently being drawn bitmap!
+				bdev->_view->Sync();
+				bitmap = get_cached_bitmap(bdev, w, h);
+			}
+
+			// convert the alpha mask to BBitmap
+			if (depth == 2) { 
+				alpha2_to_bitmap(base, raster, w, h, bitmap, colorcast);
+			} else if (depth == 4) { 
+				alpha4_to_bitmap(base, raster, w, h, bitmap, colorcast);
+			} else { 
+				// should not reach here!
+			}
+		} // bitmap == NULL
+
+		bdev->_view->SetDrawingMode(B_OP_ALPHA);
+
+		if (bitmap != NULL) {		
+			BRect from(sourcex, 0, sourcex + w - 1, h - 1);
+			BRect to(x, y, x + w - 1, y + h - 1);
+			bdev->_view->DrawBitmapAsync(bitmap, from, to);
+		} // bitmap != NULL
+    } // raster > 0
+    
+#if PROFILE
+	bdev->_copyalpha += (int)(system_time() - start);
+	bdev->_bitmaps++; bdev->_size += w * h;
+#endif
+    
+    return 0;
+}
+
diff --git a/src/gdevbe.h b/src/gdevbe.h
new file mode 100644
index 0000000..fd3d61d
--- /dev/null
+++ b/src/gdevbe.h
@@ -0,0 +1,65 @@
+/* BeOS driver for Ghostscript using a BBitmap for buffering.
+ * This driver has been heavily rewritten from the previous version.
+ *
+ * Copyright 1998, Jake Hamby
+ * Send all comments, bug fixes, etc. to:  jehamby@lightside.com
+ * 
+ * Anti-Aliasing drivers: bealpha2, bealpht2, bealpha4 and bealpht4 
+ * Copyright 2000-2004, Michael Pfeiffer
+ */
+
+/* Size of the hashtable */
+#define BE_ALPHA_HASHTABLE_SIZE 255
+/* Max number of bitmaps in cache */
+#define BE_ALPHA_MAX_BITMAPS 500
+/* On overflow remove this number of bitmaps */
+#define BE_ALPHA_REMOVE_BITMAPS 100 
+/* Max size */
+/* 4 MBytes (divide by 4, because bitmaps have 4 bytes per pixel) */
+#define BE_ALPHA_MAX_SIZE 4*1024*1024/4 
+
+/* Contains a BBitmap, so can't define from C */
+struct bmapcache_s;         /* the cache entry for a monochrome bitmap */
+struct bmap_alpha_cache_s;  /* the cache entry for a color bitmap with an alpha channel */
+
+/* Define the BeOS device */
+typedef struct gx_device_be_s {
+	gx_device_common;
+	sem_id _mutex;      /* for gsdll_lock_device */
+	BBitmap *_bitmap; /* the bitmap for buffering */
+	BView *_view;     /* offscreen view for drawing into the bitmap */
+	struct bmapcache_s *_bmapcache;          /* the monochrome bitmap cache */
+	struct bmapcache_s **_bmapcache_current; /* the most recently used bitmap in monochrome bitmap cache */
+
+	/* The hash table of the color bitmap cache */
+	struct bmap_alpha_cache_s *_alpha_hashtable[BE_ALPHA_HASHTABLE_SIZE];
+	/* The MRU list */ 
+	/* used to delete the least recently used bitmaps */	
+	struct bmap_alpha_cache_s *_alpha_mru_first;
+	struct bmap_alpha_cache_s *_alpha_mru_last;
+	/* Number of bitmaps in cache */
+	int _alpha_num_bmaps;
+	/* The size of all bitmaps in hashtable list in units of 4 bytes */
+	long _alpha_size; 
+
+	/* Single bitmap used to convert from alpha mask to BBitmap */
+	BBitmap* _cached_bitmap;
+	int      _cached_width;
+	int      _cached_height;
+
+#if PROFILE
+	/* Statistics */
+	int  _fillrect;
+	int  _copymono;
+	int  _drawline;
+	int  _copyalpha;
+	long _size;
+	long _bitmaps;
+#endif
+} gx_device_be;
+
+/* Default dots-per-inch (be sure to choose an even number!) */
+/* Macros are duplicated in gsfront.cpp; synchronize them if necessary! */
+#define INITIAL_RESOLUTION ((int)96.0)
+#define INITIAL_WIDTH ((int)(INITIAL_RESOLUTION * 85 / 10 + 1))
+#define INITIAL_HEIGHT ((int)(INITIAL_RESOLUTION * 11 + 1))
diff --git a/src/gsdll.c b/src/gsdll.c
index ea9b0ce..3ceb6cb 100644
--- a/src/gsdll.c
+++ b/src/gsdll.c
@@ -52,6 +52,10 @@
 extern HWND hwndtext;
 #endif
 
+#ifdef __BEOS__
+#define HWND void *
+#endif
+
 /****** SINGLE-INSTANCE HACK ******/
 /* GLOBAL WARNING */
 GSDLL_CALLBACK pgsdll_callback = NULL;	/* callback for messages and stdio to caller */
diff --git a/src/gsdll.h b/src/gsdll.h
index 4316937..98b8dec 100644
--- a/src/gsdll.h
+++ b/src/gsdll.h
@@ -44,6 +44,10 @@
 #define GSDLLCALLLINK
 #endif
 
+#ifdef __BEOS__
+#define HWND void *
+#endif
+
 /* global pointer to callback */
 typedef int (* GSDLLCALLLINK GSDLL_CALLBACK) (int, char *, unsigned long);
 extern GSDLL_CALLBACK pgsdll_callback;
diff --git a/src/gsfcmap.c b/src/gsfcmap.c
index 4436a6c..e82ab0c 100644
--- a/src/gsfcmap.c
+++ b/src/gsfcmap.c
@@ -219,7 +219,7 @@ gs_cmap_create_char_identity(gs_cmap_t **ppcmap, int num_bytes, int wmode,
 /*
  * Check for identity CMap. Uses a fast check for special cases.
  */
-int
+bool
 gs_cmap_is_identity(const gs_cmap_t *pcmap, int font_index_only)
 {
     return pcmap->procs->is_identity(pcmap, font_index_only);
diff --git a/src/gsfront.cpp b/src/gsfront.cpp
new file mode 100644
index 0000000..db03cd6
--- /dev/null
+++ b/src/gsfront.cpp
@@ -0,0 +1,775 @@
+/* Copyright (C) 1998, Jake Hamby.  All rights reserved.
+
+  This file is part of Aladdin Ghostscript.
+
+  Aladdin Ghostscript is distributed with NO WARRANTY OF ANY KIND.  No author
+  or distributor accepts any responsibility for the consequences of using it,
+  or for whether it serves any particular purpose or works at all, unless he
+  or she says so in writing.  Refer to the Aladdin Ghostscript Free Public
+  License (the "License") for full details.
+
+  Every copy of Aladdin Ghostscript must include a copy of the License,
+  normally in a plain ASCII text file named PUBLIC.  The License grants you
+  the right to copy, modify and redistribute Aladdin Ghostscript, but only
+  under certain conditions described in the License.  Among other things, the
+  License requires that the copyright notice and this notice be preserved on
+  all copies.
+  
+
+  gsfront.cpp
+
+  Shared library front-end to Ghostscript.  Simulates traditional "gs"
+  executable, but opens a window for the native BeOS GUI driver
+
+  History
+  1998 Initial port by Jake Hamby
+  2000 Ported version 7 by Sander Stoks (see comment below)
+  2004 Ported version 8 by Michael Pfeiffer (laplace@users.sourceforge.net)
+
+  Note by Sander Stoks:
+  This is mostly Jake Hamby's work.  All I did was modify it to use
+  ArgvReceived() and RefsReceived() properly, so you can set this front-end
+  to be the preferred app for application/postscript files and have it
+  launch with the file opened when you double-click a PS file. 
+  This is only of limited use since I left the "next page" stuff
+  unimplemented.  A "proper" front end would open a small window with
+  backward/forward buttons.  Maybe I'll write one on a rainy Sunday afternoon
+  (and although I have plenty of those here in London, don't hold your breath :-) 
+*/
+
+// set VERBOSE to 1 to print debugging output
+#define VERBOSE 0
+
+#include <stdio.h>
+#include <string.h>
+
+#include <Alert.h>
+#include <Application.h>
+#include <Autolock.h>
+#include <Beep.h>
+#include <Entry.h>
+#include <File.h>
+#include <FindDirectory.h>
+#include <MenuItem.h>
+#include <Path.h>
+#include <PopUpMenu.h>
+#include <Screen.h>
+#include <ScrollView.h>
+
+typedef void *HWND;
+
+extern "C" {
+#include "gsdll.h"
+void gsdll_draw(unsigned char *device, BView *view, BRect dest, BRect src);
+}
+
+#if VERBOSE
+	#define OUT(args) fprintf args
+#else
+	#define OUT(args)
+#endif
+
+// Constants
+
+// Default dots-per-inch (be sure to choose an even number!)
+// Copied from gdevbe.h
+#define INITIAL_RESOLUTION ((int)96.0)
+#define INITIAL_WIDTH ((int)(INITIAL_RESOLUTION * 85 / 10 + 1))
+#define INITIAL_HEIGHT ((int)(INITIAL_RESOLUTION * 11 + 1))
+
+// Preferences
+static const char* kPreferencesFile = "ghostscript_settings";
+static const char* kWindowLeft = "window_left";
+static const char* kWindowTop  = "window_top";
+
+// TODO query these from the system:
+static const int kWindowTabHeight = 24;
+static const int kWindowBorderSize = 4;
+
+// Prototypes
+long gsloop(void *foo);
+
+// Local class declarations
+
+
+class Preferences {
+public:
+	Preferences();
+	virtual ~Preferences();
+	bool GetPath(BPath* path);
+
+	BPoint GetWindowPosition()              { return fWindowPosition; }
+	void SetWindowPosition(BPoint position) { fWindowPosition = position; }
+	
+private:
+	BPoint fWindowPosition;
+};
+
+
+class PSView : public BView {
+public:
+	PSView(BRect area);
+	void Draw(BRect area);
+	void Pulse();
+	void UpdateScrollbar(orientation direction, float viewSize, float pageSize);
+	void UpdateScrollbars();
+	void SetPageSize(int width, int height);
+	
+	void ScrollTo(BPoint point);
+
+	BPoint GetMouseScreenPosition();
+
+	void ShowPopUpMenu(BPoint point);
+	void MouseDown(BPoint point);
+	void MouseMoved(BPoint point, uint32 transit, const BMessage *msg);
+	void MouseUp(BPoint point);
+	
+	void MouseWheelChanged(BMessage* msg);
+
+	void MessageReceived(BMessage* msg);
+	
+	
+private:
+	int         fPageWidth;
+	int         fPageHeight;
+	// fields used for dragging support
+	bool        fDragView;
+	BPoint      fLastMousePosition;
+};
+
+class PSWindow : public BWindow {
+public:
+	PSWindow(BRect frame, const char *title, window_type type, ulong flags, Preferences* prefs);
+	bool QuitRequested();
+	void MessageReceived(BMessage* msg);
+	
+	void GsDllSync();
+	void GsDllPage();
+	void GsDllSetPageSize(int width, int height);
+	void GsStopUpdate();
+	
+	void FrameMoved(BPoint position);
+	void FrameResized(float width, float height);	
+
+	PSView* GetView() { return fPSView; }
+	
+	
+private:
+	PSView      *fPSView;
+	BScrollView *fScrollView;
+	Preferences* fPreferences;
+};
+
+class PSApplication : public BApplication {
+public:
+    PSApplication(const char *sig);
+	virtual ~PSApplication();
+	
+    void AboutRequested();
+    void MessageReceived(BMessage *message);
+    bool QuitRequested();
+    void RefsReceived(BMessage *message);
+    void ReadyToRun();
+
+
+	PSWindow* GetWindow() { return fWindow; }
+	Preferences* GetPreferences() { return fPreferences; }
+
+private:
+	Preferences *fPreferences;
+    PSWindow    *fWindow;
+	thread_id   fGhostscriptThread;
+};
+
+// Private message types
+#define SHOW_FILE_PANEL	'SPNL'
+#define NEXT_PAGE		'NXPG'
+
+// The BeOS device to draw
+unsigned char *gBeDevice = NULL;
+
+// more global variables
+PSApplication *gApplication;
+int           gArgc;
+char          **gArgv;
+bool          gRunInTerminal;
+
+
+// Implementation of Preferences
+Preferences::Preferences()
+	: fWindowPosition(15, kWindowTabHeight)
+{
+	BPath path;
+	if (GetPath(&path)) {
+		BFile file(path.Path(), B_READ_ONLY);
+		BMessage data;
+		if (file.InitCheck() == B_OK &&
+			data.Unflatten(&file) == B_OK) {
+			
+			// read preferences
+			data.FindFloat(kWindowLeft, &fWindowPosition.x);
+			data.FindFloat(kWindowTop, &fWindowPosition.y);
+		}
+	}
+}
+
+Preferences::~Preferences()
+{
+	BPath path;
+	if (GetPath(&path)) {
+		// write preferences
+		BMessage data;
+		data.AddFloat(kWindowLeft, fWindowPosition.x);
+		data.AddFloat(kWindowTop, fWindowPosition.y);
+		
+		BFile file(path.Path(), B_WRITE_ONLY | B_CREATE_FILE | B_ERASE_FILE);
+		if (file.InitCheck() == B_OK) {
+			data.Flatten(&file);
+		}
+	}
+}
+
+bool Preferences::GetPath(BPath* path)
+{
+	return find_directory(B_COMMON_SETTINGS_DIRECTORY, path) == B_OK &&
+		path->Append(kPreferencesFile) == B_OK;
+}
+
+
+// Implementation of PSWindow
+
+PSWindow::PSWindow(BRect frame, const char *title, window_type type, ulong flags, Preferences* prefs) 
+	: BWindow(frame, title, type, flags)
+	, fPreferences(prefs)
+{
+	AddShortcut('a', B_COMMAND_KEY, new BMessage(B_ABOUT_REQUESTED));
+	
+	frame.OffsetTo(B_ORIGIN);
+	frame.right -= B_V_SCROLL_BAR_WIDTH;
+	frame.bottom -= B_H_SCROLL_BAR_HEIGHT;
+	fPSView = new PSView(frame);
+	
+	fScrollView = new BScrollView("Scroll View", fPSView, B_FOLLOW_ALL,
+			0, true, true, B_FANCY_BORDER);
+	fScrollView->ScrollBar(B_HORIZONTAL)->SetRange(0, 611);
+	fScrollView->ScrollBar(B_VERTICAL)->SetRange(0, 791);
+
+	AddChild(fScrollView);
+	fPSView->UpdateScrollbars();
+	fPSView->MakeFocus();
+}
+
+bool PSWindow::QuitRequested() 
+{
+	be_app_messenger.SendMessage(B_QUIT_REQUESTED);
+	return true;
+}
+
+void PSWindow::MessageReceived(BMessage* msg)
+{
+	if (msg->what == B_ABOUT_REQUESTED) {
+		be_app_messenger.SendMessage(B_ABOUT_REQUESTED);
+	}
+}
+
+void PSWindow::GsDllSync()
+{
+	BAutolock autoLock(this);
+	if (!autoLock.IsLocked()) return;
+	// Use pulse to update the view while the page is being rendered
+	fPSView->Invalidate();
+	SetPulseRate(1000000/10);
+}
+
+void PSWindow::GsDllPage()
+{
+	BAutolock autoLock(this);
+	if (!autoLock.IsLocked()) return;
+	// Stop pulse
+	SetPulseRate(0);
+	fPSView->Invalidate();
+}
+
+void PSWindow::GsStopUpdate()
+{
+	BAutolock autoLock(this);
+	if (autoLock.IsLocked()) {
+		SetPulseRate(0);
+	}
+}
+
+// Resize window but stay inside screen bounds
+void PSWindow::GsDllSetPageSize(int width, int height)
+{
+	BAutolock autoLock(this);
+	
+	fPSView->SetPageSize(width, height);
+	
+	BRect screensize;
+	BScreen screen;
+	if (screen.IsValid()) {
+		screensize = screen.Frame();
+	} else {
+		screensize = BRect(0, 0, 640, 480);
+	}
+	
+	// scroll bars should not overlap page
+	width += (int)B_V_SCROLL_BAR_WIDTH;
+	height += (int)B_H_SCROLL_BAR_HEIGHT;
+	
+	BRect frame(Frame());
+	// stay inside screen
+	if (frame.left + width - kWindowBorderSize > screensize.right) {
+		width = (int)(screensize.right - frame.left - kWindowBorderSize);
+	}
+	if (frame.top + height - kWindowBorderSize > screensize.bottom) {
+		height = (int)(screensize.bottom - frame.top - kWindowBorderSize);
+	}
+	ResizeTo(width, height);
+}
+
+void PSWindow::FrameMoved(BPoint position)
+{
+	if (fPreferences != NULL) {
+		fPreferences->SetWindowPosition(position);
+	}
+}
+
+void PSWindow::FrameResized(float width, float height)
+{
+	fPSView->UpdateScrollbars();
+}
+
+// Implementation of PSView
+
+PSView::PSView(BRect frame) 
+	: BView(frame, "PSView", B_FOLLOW_ALL_SIDES, B_WILL_DRAW | B_PULSE_NEEDED) 
+	, fPageWidth(INITIAL_WIDTH)
+	, fPageHeight(INITIAL_HEIGHT)
+{
+	SetViewColor(B_TRANSPARENT_COLOR);
+}
+
+void PSView::Draw(BRect area) 
+{
+	const rgb_color kWhite = {255, 255, 255, 0};
+	SetDrawingMode(B_OP_COPY);
+	SetHighColor(kWhite);
+
+	if(gBeDevice) {
+		// fill space around page with white color
+		if (area.left < 0) {
+			FillRect(BRect(area.left, area.top, -1, area.bottom));
+		}
+		if (fPageWidth <= area.right) {
+			FillRect(BRect(fPageWidth, area.top, area.right, area.bottom));
+		}
+		if (area.top < 0) {
+			FillRect(BRect(area.left, area.top, area.right, -1));
+		}
+		if (fPageHeight <= area.bottom) {
+			FillRect(BRect(area.left, fPageHeight, area.right, area.bottom));			
+		}
+		// paint page
+		gsdll_lock_device(gBeDevice, 1);
+		gsdll_draw(gBeDevice, this, area, area);
+		gsdll_lock_device(gBeDevice, 0);
+	} else {
+		FillRect(area);
+	}
+}
+
+void PSView::Pulse()
+{
+	Invalidate();
+}
+
+void PSView::SetPageSize(int width, int height)
+{
+	fPageWidth = width;
+	fPageHeight = height;
+}
+
+void PSView::UpdateScrollbar(orientation direction, float viewSize, float pageSize) 
+{
+	BScrollBar* scrollBar = ScrollBar(direction);
+	if (scrollBar != NULL) {
+		float outsideSize = pageSize - viewSize;
+		if (outsideSize < 0.0) {
+			outsideSize = 0.0;
+		}
+		
+		scrollBar->SetRange(0, outsideSize);
+		scrollBar->SetProportion(viewSize / pageSize);
+		scrollBar->SetSteps(viewSize / 10.0, viewSize);
+	}
+}
+
+void PSView::UpdateScrollbars() 
+{
+	BRect bounds(Bounds());
+	UpdateScrollbar(B_HORIZONTAL, bounds.Width(), fPageWidth);
+	UpdateScrollbar(B_VERTICAL, bounds.Height(), fPageHeight);
+}
+
+// scroll restricted within page size
+void PSView::ScrollTo(BPoint point) 
+{
+	BRect bounds(Bounds());
+	float xMax = fPageWidth - bounds.Width();
+	float yMax = fPageHeight - bounds.Height();
+	
+	if (xMax < 0) xMax = 0;	
+	if (yMax < 0) yMax = 0;
+	
+	if (point.x < 0) {
+		point.x = 0;
+	} else if (point.x > xMax) {
+		point.x = xMax;
+	}
+	
+	if (point.y < 0) {
+		point.y = 0;
+	} else if (point.y > yMax)  {
+		point.y = yMax;
+	}
+		
+	BView::ScrollTo(point); 
+}
+
+BPoint PSView::GetMouseScreenPosition()
+{
+	uint32 buttons;
+	BPoint position;
+	GetMouse(&position, &buttons, false);
+	ConvertToScreen(&position);
+	return position;
+}
+
+void PSView::ShowPopUpMenu(BPoint point)
+{
+	BPopUpMenu* menu = new BPopUpMenu("PopUpMenu");
+	menu->SetAsyncAutoDestruct(true);
+
+	BMessage* msg;
+	BMenuItem* i;
+
+	// About menu item
+	msg = new BMessage(B_ABOUT_REQUESTED);
+	i = new BMenuItem("About", msg);
+	i->SetTarget(this);
+	menu->AddItem(i);
+
+	point -= BPoint(10, 10);
+	menu->Go(point, true, false, false);	
+}
+
+void PSView::MouseDown(BPoint point)
+{
+	// 
+	if (modifiers() != 0) return;
+	
+	uint32 buttons;
+	GetMouse(&point, &buttons);
+	if (buttons & B_PRIMARY_MOUSE_BUTTON) {
+		MakeFocus();
+		SetMouseEventMask(B_POINTER_EVENTS);
+		fLastMousePosition = GetMouseScreenPosition();
+		fDragView = true;	
+	} else if (buttons & B_SECONDARY_MOUSE_BUTTON) {
+		ShowPopUpMenu(GetMouseScreenPosition());
+	}
+}
+
+void PSView::MouseMoved(BPoint point, uint32 transit, const BMessage *msg)
+{
+	if (fDragView) {
+		BPoint position(GetMouseScreenPosition());
+		BPoint delta(fLastMousePosition - position);
+		ScrollBy(delta.x, delta.y);
+		fLastMousePosition = position;
+	}
+}
+
+void PSView::MouseUp(BPoint point)
+{
+	if (fDragView) {
+		MouseMoved(point, 0, NULL);
+		fDragView = false;
+	}
+}
+
+void PSView::MouseWheelChanged(BMessage* msg)
+{
+	float scrollDistance = 25;
+	
+	// set scroll distance to 20% of the minimum of screen width and height
+	BScreen screen;
+	if (screen.IsValid()) {
+		BRect frame(screen.Frame());
+		if (frame.right < frame.bottom) {
+			scrollDistance = frame.right;
+		} else {
+			scrollDistance = frame.bottom;
+		}
+		scrollDistance *= 0.20;
+	}
+	
+	float dy, dx;
+	if (msg->FindFloat("be:wheel_delta_y", &dy) == B_OK && dy != 0.0) {
+		bool down = dy > 0;
+		// intelliMouse driver uses command key to simulate wheel_detla_x!
+		if ((modifiers() & (B_COMMAND_KEY | B_OPTION_KEY))) {
+			// Zoom(!down); // zoom in / out	
+		} else if ((modifiers() & (B_SHIFT_KEY | B_CONTROL_KEY))) {
+			// next/previous page
+			// MoveToPage(mCurrentPage + (down ? 1 : -1));
+		} else {
+			ScrollBy(0, scrollDistance * (down ? 1 : -1));
+		}
+	}
+	if (msg->FindFloat("be:wheel_delta_x", &dx) == B_OK && dx != 0.0) {
+		bool right = dx > 0;
+		ScrollBy(scrollDistance * (right ? 1 : -1), 0);
+	}
+}
+
+void PSView::MessageReceived(BMessage* msg)
+{
+//	if (msg->what == B_MOUSE_WHEEL_CHANGED) {
+		// MouseWheelChanged(msg);
+//	} else {
+		BView::MessageReceived(msg);
+//	}
+}
+
+// Implementation of PSApplication
+
+PSApplication::PSApplication(const char *sig) : BApplication(sig) 
+{
+	fPreferences = new Preferences();
+	
+	BScreen myscreen;
+	BRect screensize;
+	if (myscreen.IsValid()) {
+		screensize = myscreen.Frame();
+	} else {
+		screensize = BRect(0,0,640,480);
+	}
+	
+	BPoint position(15, kWindowTabHeight);
+	if (fPreferences != NULL) {
+		position = fPreferences->GetWindowPosition();
+	}
+	BRect frame(position.x, position.y, 
+		screensize.right - kWindowBorderSize, screensize.bottom - kWindowBorderSize);
+		
+    fWindow = new PSWindow(frame, "Ghostscript", B_DOCUMENT_WINDOW, 0, fPreferences);
+        		
+	fWindow->Run();
+}
+
+PSApplication::~PSApplication() {
+	delete fPreferences;
+	fPreferences = NULL;
+}
+
+void PSApplication::ReadyToRun ()
+{
+	fGhostscriptThread = spawn_thread(gsloop, "GS Loop", B_NORMAL_PRIORITY, (void *)GetWindow()->GetView());
+	resume_thread(fGhostscriptThread);
+}
+
+void PSApplication::AboutRequested() {
+   BAlert *alert;
+
+   alert = new BAlert("", "AFPL Ghostscript 8.14 (2004-02-20)\n\n"
+	"Copyright (C) 2004 artofcode LLC, Benicia, CA.  All rights reserved.\n"
+	"This software comes with NO WARRANTY: see the file PUBLIC for details.\n\n"
+	"BeOS port by Jake Hamby, Sander Stoks and Michael Pfeiffer.\n\n"
+	"Please send all comments to:\n"
+	"    laplace@users.sourceforge.net",
+   	"OK", NULL, NULL, B_WIDTH_AS_USUAL, B_INFO_ALERT);
+   alert->Go();
+}
+
+void PSApplication::MessageReceived(BMessage *message)
+{
+	switch (message->what) {
+		case SHOW_FILE_PANEL:
+//			RunFilePanel();         // Use default values
+			OUT((stderr, "Open file...\n"));
+			break;
+        case NEXT_PAGE:
+			OUT((stderr, "Next page...\n"));
+			break;
+		default:
+			BApplication::MessageReceived(message);
+            break;
+	}
+}
+
+bool PSApplication::QuitRequested() {
+	kill_thread(fGhostscriptThread);  // Kill Ghostscript thread if still running
+	return true;                      // and exit app
+}
+
+void PSApplication::RefsReceived(BMessage *message)
+{
+	gRunInTerminal = false;
+	BPath path;
+	entry_ref ref;
+	if (message->FindRef ("refs", &ref) == B_OK) {
+		gArgc = 2;
+		gArgv[0] = new char[16];
+		strcpy (gArgv[0], "gs");
+		path.SetTo (&ref);
+		gArgv[1] = new char[strlen(path.Path()) + 1];
+		strcpy (gArgv[1], path.Path());
+	}
+}
+
+// Only used to open and close BWindow
+int
+gsdll_callback(int message, char *str, unsigned long data)
+{
+	static bool child_added = 0;
+    char *p;
+    switch (message) {
+	    case GSDLL_STDIN:
+	    	OUT((stderr, "GSDLL_STDIN called\n"));
+	        p = fgets(str, data, stdin);
+	        if (p)
+	           return strlen(str);
+	        else
+	           return 0; 
+	    case GSDLL_STDOUT:
+	    	OUT((stderr, "GSDLL_STDOUT called\n"));
+	        if (str != (char *)NULL)
+				fwrite(str, 1, data, stderr);
+	        return data;
+	    case GSDLL_DEVICE:
+			OUT((stderr, "GSDLL_DEVICE called\n"));
+			gBeDevice = (unsigned char *)str;
+			if (data && !child_added) {	// open window
+				child_added = 1;
+				gApplication->GetWindow()->Lock();
+				gApplication->GetWindow()->Show();
+				gApplication->GetWindow()->Unlock();
+			} else {	// close window
+				// do nothing right now
+			}
+			break;
+	    case GSDLL_SYNC:
+	        OUT((stderr,"Callback: SYNC %p %ld\n", str, data));
+	        gApplication->GetWindow()->GsDllSync();
+	        break;
+	    case GSDLL_PAGE:
+	        OUT((stderr,"Callback: PAGE %p %ld\n", str, data));
+	        gApplication->GetWindow()->GsDllPage();
+	        break;
+	    case GSDLL_SIZE:
+	        OUT((stderr,"Callback: SIZE %p width=%d height=%d\n", str,
+	            (int)(data & 0xffff), (int)((data>>16) & 0xffff) ));
+			{
+				int width = (int)(data & 0xffff);
+				int height = (int)((data>>16) & 0xffff);
+				gApplication->GetWindow()->GsDllSetPageSize(width, height);
+			}
+	        break;
+	    case GSDLL_POLL:
+	        OUT((stderr,"Callback: POLL %p\n", str));
+	        return 0; /* no error */
+	    default:
+	        OUT((stderr,"Callback: Unknown message=%d\n",message));
+	        break;
+    }
+    return 0;
+}
+
+void stop_automatic_invalidation()
+{
+	if (gBeDevice != NULL) {
+		gApplication->GetWindow()->GsStopUpdate();
+	}
+}
+
+void prompt()
+{
+	fprintf(stdout, "GS> ");
+	fflush(stdout);
+}
+
+bool isBatchProcessing() {
+	for (int i = 1; i < gArgc; i ++) {
+		if (strcmp(gArgv[i], "-dBATCH") == 0) {
+			return true;
+		}
+	}
+	return false;
+}
+
+long gsloop(void *psview)
+{    
+    int code;
+    code = gsdll_init(gsdll_callback, NULL, gArgc, gArgv);
+	OUT((stderr, "gsdll_init returns %d\n", code));
+
+	if (code == GSDLL_INIT_QUIT) {
+		goto done;
+	}
+
+	if (code == 0) {
+    	code = gsdll_execute_begin();
+    }
+
+	OUT((stderr, "gsdll_execute_begin returns %d\n", code));
+    if (code == 0) {
+    	if (!isBatchProcessing()) { 
+			stop_automatic_invalidation();
+			prompt();
+			while(1)
+			{
+				char input[256];
+
+			    if(!fgets(input, sizeof(input)-1, stdin))
+					break;
+	
+				code = gsdll_execute_cont(input, strlen(input));
+				OUT((stderr, "gsdll_execute returns %d\n", code));
+	
+				if (code < 0)
+			    	break;
+				
+				stop_automatic_invalidation();
+				prompt();
+			}
+		}
+		
+		if (code < 0) {
+			code = gsdll_execute_end();
+			OUT((stderr, "gsdll_execute_end returns %d\n", code));
+		}
+		
+		code = gsdll_exit();
+		OUT((stderr, "gsdll_exit returns %d\n", code));
+	}
+
+done:
+	be_app_messenger.SendMessage(B_QUIT_REQUESTED);
+    return 0;
+}
+
+int main (int32 argc, char *argv[])
+{
+	gArgc = argc;
+	gArgv = argv;
+    PSApplication app("application/x-vnd.jehamby.gs");
+    gApplication = &app; // so global functions can find the app
+    
+    gRunInTerminal = true;
+    
+    app.Run();
+    return 0;
+}
+
diff --git a/src/gsovrc.c b/src/gsovrc.c
index 3eeaff9..24a8c47 100644
--- a/src/gsovrc.c
+++ b/src/gsovrc.c
@@ -263,7 +263,7 @@ gs_create_overprint(
  * This is used by the gs_pdf1.4_device (and eventually the PDFWrite
  * device), which implements overprint and overprint mode directly.
  */
-int
+bool
 gs_is_overprint_compositor(const gs_composite_t * pct)
 {
     return pct->type == &gs_composite_overprint_type;
diff --git a/src/gximag3x.c b/src/gximag3x.c
index b09b9cd..2fb6b79 100644
--- a/src/gximag3x.c
+++ b/src/gximag3x.c
@@ -374,7 +374,7 @@ check_image3x_extent(floatp mask_coeff, floatp data_coeff)
  * pmcs->{InterleaveType,width,height,full_height,depth,data,y,skip}.
  * If the mask is omitted, sets pmcs->depth = 0 and returns normally.
  */
-private bool
+private int
 check_image3x_mask(const gs_image3x_t *pim, const gs_image3x_mask_t *pimm,
 		   const image3x_channel_values_t *ppcv,
 		   image3x_channel_values_t *pmcv,
diff --git a/src/gxwts.c b/src/gxwts.c
index f1effcf..71d4b4a 100644
--- a/src/gxwts.c
+++ b/src/gxwts.c
@@ -493,7 +493,7 @@ gx_dc_wts_fill_rectangle(const gx_device_color *pdevc,
 }
 
 /* Compare two wts colors for equality. */
-private int
+private bool
 gx_dc_wts_equal(const gx_device_color *pdevc1,
 		const gx_device_color *pdevc2)
 {
diff --git a/src/unix-aux.mak b/src/unix-aux.mak
index 76ab802..6aded32 100644
--- a/src/unix-aux.mak
+++ b/src/unix-aux.mak
@@ -30,10 +30,32 @@ UNIX_AUX_MAK=$(GLSRC)unix-aux.mak
 
 # Unix platforms other than System V, and also System V Release 4
 # (SVR4) platforms.
-unix__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ)
+unix__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ) $(GLOBJ)gsdll.$(OBJ)
 $(GLGEN)unix_.dev: $(unix__) $(GLD)nosync.dev
 	$(SETMOD) $(GLGEN)unix_ $(unix__) -include $(GLD)nosync
 
+bealpha2__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ) $(GLOBJ)gsdll.$(OBJ)
+$(GLGEN)bealpha2_.dev: $(bealpha2__) $(GLD)nosync.dev
+	$(SETMOD) $(GLGEN)bealpha2_ $(bealpha2__) -include $(GLD)nosync
+#	$(ADDMOD) $(GLGEN)bealpha2_ -iodev wstdio
+
+bealpha4__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ) $(GLOBJ)gsdll.$(OBJ)
+$(GLGEN)bealpha4_.dev: $(bealpha4__) $(GLD)nosync.dev
+	$(SETMOD) $(GLGEN)bealpha4_ $(bealpha4__) -include $(GLD)nosync
+#	$(ADDMOD) $(GLGEN)bealpha4_ -iodev wstdio
+
+bealpht2__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ) $(GLOBJ)gsdll.$(OBJ)
+$(GLGEN)bealpht2_.dev: $(bealpht2__) $(GLD)nosync.dev
+	$(SETMOD) $(GLGEN)bealpht2_ $(bealpht2__) -include $(GLD)nosync
+#	$(ADDMOD) $(GLGEN)bealpht2_ -iodev wstdio
+
+bealpht4__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ) $(GLOBJ)gsdll.$(OBJ)
+$(GLGEN)bealpht4_.dev: $(bealpht4__) $(GLD)nosync.dev
+	$(SETMOD) $(GLGEN)bealpht4_ $(bealpht4__) -include $(GLD)nosync
+#	$(ADDMOD) $(GLGEN)bealpht4_ -iodev wstdio
+
+
+
 $(GLOBJ)gp_unix.$(OBJ): $(GLSRC)gp_unix.c $(AK)\
  $(pipe__h) $(string__h) $(time__h)\
  $(gx_h) $(gsexit_h) $(gp_h)
diff --git a/src/unix-dll.mak b/src/unix-dll.mak
index 8626ba4..ab84c1b 100644
--- a/src/unix-dll.mak
+++ b/src/unix-dll.mak
@@ -44,6 +44,11 @@ GSSOX_XENAME=$(GS)x$(XE)
 GSSOX_XE=$(BINDIR)/$(GSSOX_XENAME)
 GSSOX=$(BINDIR)/$(SOBINRELDIR)/$(GSSOX_XENAME)
 
+# loader suporting display device using BeOS
+GSSOBE_XENAME=$(GS)be$(XE)
+GSSOBE_XE=$(BINDIR)/$(GSSOBE_XENAME)
+GSSOBE=$(BINDIR)/$(SOBINRELDIR)/$(GSSOBE_XENAME)
+
 # shared library
 GS_SONAME=lib$(GS).so
 GS_SONAME_MAJOR=$(GS_SONAME).$(GS_VERSION_MAJOR)
@@ -72,6 +77,9 @@ $(GSSOX_XE): $(GS_SO) $(GLSRC)dxmain.c
 $(GSSOC_XE): $(GS_SO) $(GLSRC)dxmainc.c
 	$(GLCC) -g -o $(GSSOC_XE) $(GLSRC)dxmainc.c -L$(BINDIR) -l$(GS)
 
+$(GSSOBE_XE): $(GS_SO) $(GLSRC)gsfront.cpp
+	$(GLCC) -g -o $(GSSOBE_XE) $(GLSRC)gsfront.cpp -L$(BINDIR) -l$(GS) -lbe
+
 # ------------------------- Recursive make targets ------------------------- #
 
 SODEFS=LDFLAGS='$(LDFLAGS) $(CFLAGS_SO) -shared -Wl,-soname=$(GS_SONAME_MAJOR)'\
@@ -87,13 +95,13 @@ SODEFS=LDFLAGS='$(LDFLAGS) $(CFLAGS_SO) -shared -Wl,-soname=$(GS_SONAME_MAJOR)'\
 
 # Normal shared object
 so: SODIRS
-	$(MAKE) $(SODEFS) CFLAGS='$(CFLAGS_STANDARD) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' prefix=$(prefix) $(GSSOC)
+	$(MAKE) $(SODEFS) CFLAGS='$(CFLAGS_STANDARD) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' prefix=$(prefix) $(GSSOC) $(GSSOBE)
 
 # Debug shared object
 # Note that this is in the same directory as the normal shared
 # object, so you will need to use 'make soclean', 'make sodebug'
 sodebug: SODIRS
-	$(MAKE) $(SODEFS) GENOPT='-DDEBUG' CFLAGS='$(CFLAGS_DEBUG) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' $(GSSOC)
+	$(MAKE) $(SODEFS) GENOPT='-DDEBUG' CFLAGS='$(CFLAGS_DEBUG) $(CFLAGS_SO) $(GCFLAGS) $(XCFLAGS)' $(GSSOC) $(GSSOBE)
 
 install-so: so
 	-mkdir -p $(prefix)
@@ -103,6 +111,7 @@ install-so: so
 	-mkdir -p $(bindir)
 	-mkdir -p $(libdir)
 	$(INSTALL_PROGRAM) $(GSSOC) $(bindir)/$(GSSOC_XENAME)
+	$(INSTALL_PROGRAM) $(GSSOBE) $(bindir)/$(GSSOBE_XENAME)
 	$(INSTALL_PROGRAM) $(BINDIR)/$(SOBINRELDIR)/$(GS_SONAME_MAJOR_MINOR) $(libdir)/$(GS_SONAME_MAJOR_MINOR)
 	$(RM_) $(libdir)/$(GS_SONAME)
 	ln -s $(GS_SONAME_MAJOR_MINOR) $(libdir)/$(GS_SONAME)
@@ -126,5 +135,6 @@ soclean: SODIRS
 	$(RM_) $(BINDIR)/$(SOBINRELDIR)/$(GS_SONAME_MAJOR)
 	$(RM_) $(GSSOC)
 	$(RM_) $(GSSOX)
+	$(RM_) $(GSSOBE)
 
 # End of unix-dll.mak
diff --git a/src/unix-gcc.mak b/src/unix-gcc.mak
index f0d4944..e4e3113 100644
--- a/src/unix-gcc.mak
+++ b/src/unix-gcc.mak
@@ -256,7 +256,7 @@ LDFLAGS=$(XLDFLAGS)
 # Solaris may need -lnsl -lsocket -lposix4.
 # (Libraries required by individual drivers are handled automatically.)
 
-EXTRALIBS=
+EXTRALIBS=-lbe
 
 # Define the standard libraries to search at the end of linking.
 # Most platforms require -lpthread for the POSIX threads library;
@@ -367,7 +367,8 @@ EXTEND_NAMES=0
 # Choose the device(s) to include.  See devs.mak for details,
 # devs.mak and contrib.mak for the list of available devices.
 
-DEVICE_DEVS=$(DISPLAY_DEV) $(DD)x11.dev $(DD)x11alpha.dev $(DD)x11cmyk.dev $(DD)x11gray2.dev $(DD)x11gray4.dev $(DD)x11mono.dev
+DEVICE_DEVS=$(DISPLAY_DEV) $(DD)beos.dev $(DD)bealpha2.dev $(DD)bealpha4.dev $(DD)bealpht2.dev $(DD)bealpht4.dev
+#DEVICE_DEVS=$(DISPLAY_DEV) $(DD)x11.dev $(DD)x11alpha.dev $(DD)x11cmyk.dev $(DD)x11gray2.dev $(DD)x11gray4.dev $(DD)x11mono.dev
 
 #DEVICE_DEVS1=
 #DEVICE_DEVS2=
-- 
2.37.3


From 7cd527226710f3e3491ff6aaf602c2390d137c6e Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Fri, 15 Mar 2019 19:30:01 +0100
Subject: Fix the build.

Move some of the BeOS changes into configure.ac/Makefile.in

diff --git a/src/Makefile.in b/src/Makefile.in
index 22c7773..5151451 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -282,6 +282,8 @@ XLIBDIR=
 #XLIBS=Xt Xext X11
 XLIBS=@XLIBS@
 
+BELIBS=@BELIBS@
+
 # Define whether this platform has floating point hardware:
 #	FPU_TYPE=2 means floating point is faster than fixed point.
 # (This is the case on some RISCs with multiple instruction dispatch.)
@@ -353,7 +355,7 @@ EXTEND_NAMES=0
 # devs.mak and contrib.mak for the list of available devices.
 
 #DEVICE_DEVS=$(DISPLAY_DEV) $(DD)x11.dev $(DD)x11alpha.dev $(DD)x11cmyk.dev $(DD)x11gray2.dev $(DD)x11gray4.dev $(DD)x11mono.dev
-DEVICE_DEVS=$(DISPLAY_DEV) @X11DEVS@
+DEVICE_DEVS=$(DISPLAY_DEV) @X11DEVS@ @BEDEVS@
 
 DEVICE_DEVS1=$(DD)bmpmono.dev $(DD)bmpgray.dev $(DD)bmpsep1.dev $(DD)bmpsep8.dev $(DD)bmp16.dev $(DD)bmp256.dev $(DD)bmp16m.dev $(DD)bmp32b.dev
 DEVICE_DEVS2=
diff --git a/src/configure.ac b/src/configure.ac
index a18f4d0..e145051 100644
--- a/src/configure.ac
+++ b/src/configure.ac
@@ -308,6 +308,12 @@ fi
 AC_SUBST(X11DEVS)
 AC_SUBST(XLIBS)
 
+BELIBS='-lbe'
+AC_SUBST(BELIBS)
+
+BEDEVS='$(DD)beos.dev $(DD)bealpha2.dev $(DD)bealpha4.dev $(DD)bealpht2.dev $(DD)bealpht4.dev'
+AC_SUBST(BEDEVS)
+
 dnl executible name
 AC_ARG_WITH(gs, AC_HELP_STRING([--with-gs=NAME],
 	[name of the ghostscript executible [[gs]]]),
diff --git a/src/contrib.mak b/src/contrib.mak
index bc889fb..a9eba37 100644
--- a/src/contrib.mak
+++ b/src/contrib.mak
@@ -865,18 +865,23 @@ $(GLOBJ)gdevsunr.$(OBJ) : $(GLSRC)gdevsunr.c $(PDEVH)
 
 $(DD)beos.dev: $(GLOBJ)gdevbe.$(OBJ)
 	$(SETDEV) $(DD)beos $(GLOBJ)gdevbe.$(OBJ)
+	$(ADDMOD) $(DD)beos -lib $(BELIBS)
 
 $(DD)bealpha2.dev: $(GLOBJ)gdevbe.$(OBJ)
 	$(SETDEV) $(DD)bealpha2 $(GLOBJ)gdevbe.$(OBJ)
+	$(ADDMOD) $(DD)bealpha2 -lib $(BELIBS)
 
 $(DD)bealpha4.dev: $(GLOBJ)gdevbe.$(OBJ)
 	$(SETDEV) $(DD)bealpha4 $(GLOBJ)gdevbe.$(OBJ)
- 
+	$(ADDMOD) $(DD)bealpha4 -lib $(BELIBS)
+
 $(DD)bealpht2.dev: $(GLOBJ)gdevbe.$(OBJ)
 	$(SETDEV) $(DD)bealpht2 $(GLOBJ)gdevbe.$(OBJ)
+	$(ADDMOD) $(DD)bealpht2 -lib $(BELIBS)
 
 $(DD)bealpht4.dev: $(GLOBJ)gdevbe.$(OBJ)
 	$(SETDEV) $(DD)bealpht4 $(GLOBJ)gdevbe.$(OBJ)
+	$(ADDMOD) $(DD)bealpht4 -lib $(BELIBS)
 
- $(GLOBJ)gdevbe.$(OBJ): $(GLSRC)gdevbe.cpp $(GLSRC)gdevbe.h $(GDEV)
+$(GLOBJ)gdevbe.$(OBJ): $(GLSRC)gdevbe.cpp $(GLSRC)gdevbe.h $(GDEV)
 	$(GLCC) $(GLO_)gdevbe.$(OBJ) $(C_) $(GLSRC)gdevbe.cpp
diff --git a/src/gsdll.h b/src/gsdll.h
index 98b8dec..5bc09e4 100644
--- a/src/gsdll.h
+++ b/src/gsdll.h
@@ -44,7 +44,7 @@
 #define GSDLLCALLLINK
 #endif
 
-#ifdef __BEOS__
+#if defined(__BEOS__) || defined(__HAIKU__)
 #define HWND void *
 #endif
 
diff --git a/src/gsfront.cpp b/src/gsfront.cpp
index db03cd6..ee3848a 100644
--- a/src/gsfront.cpp
+++ b/src/gsfront.cpp
@@ -231,7 +231,7 @@ Preferences::~Preferences()
 
 bool Preferences::GetPath(BPath* path)
 {
-	return find_directory(B_COMMON_SETTINGS_DIRECTORY, path) == B_OK &&
+	return find_directory(B_USER_SETTINGS_DIRECTORY, path) == B_OK &&
 		path->Append(kPreferencesFile) == B_OK;
 }
 
diff --git a/src/stdpre.h b/src/stdpre.h
index 101d4b9..932b678 100644
--- a/src/stdpre.h
+++ b/src/stdpre.h
@@ -281,13 +281,7 @@ typedef unsigned long ulong;
  * and the MetroWerks C++ compiler insists that bool be equivalent to
  * unsigned char.
  */
-#ifndef __cplusplus
-#ifdef __BEOS__
-typedef unsigned char bool;
-#else
-typedef int bool;
-#endif
-#endif
+#include <stdbool.h>
 /*
  * Older versions of MetroWerks CodeWarrior defined true and false, but they're now
  * an enum in the (MacOS) Universal Interfaces. The only way around this is to escape
diff --git a/src/unix-aux.mak b/src/unix-aux.mak
index 6aded32..29c585d 100644
--- a/src/unix-aux.mak
+++ b/src/unix-aux.mak
@@ -30,7 +30,7 @@ UNIX_AUX_MAK=$(GLSRC)unix-aux.mak
 
 # Unix platforms other than System V, and also System V Release 4
 # (SVR4) platforms.
-unix__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ) $(GLOBJ)gsdll.$(OBJ)
+unix__=$(GLOBJ)gp_getnv.$(OBJ) $(GLOBJ)gp_unix.$(OBJ) $(GLOBJ)gp_unifs.$(OBJ) $(GLOBJ)gp_unifn.$(OBJ) $(GLOBJ)gp_stdia.$(OBJ) $(GLOBJ)gsdll.$(OBJ) $(GLOBJ)gdevbe.$(OBJ)
 $(GLGEN)unix_.dev: $(unix__) $(GLD)nosync.dev
 	$(SETMOD) $(GLGEN)unix_ $(unix__) -include $(GLD)nosync
 
@@ -61,6 +61,11 @@ $(GLOBJ)gp_unix.$(OBJ): $(GLSRC)gp_unix.c $(AK)\
  $(gx_h) $(gsexit_h) $(gp_h)
 	$(GLCC) $(GLO_)gp_unix.$(OBJ) $(C_) $(GLSRC)gp_unix.c
 
+$(GLOBJ)gsdll.$(OBJ): $(GLSRC)gsdll.c $(gconfigv_h) $(AK)\
+ $(stdio__h) $(time__h) $(unistd__h) $(gx_h) $(gp_h)
+	$(GLCC) $(GLO_)gsdll.$(OBJ) $(C_) $(GLSRC)gsdll.c
+
+
 # assume all Unix platforms support unbuffered read
 $(GLOBJ)gp_stdia.$(OBJ): $(GLSRC)gp_stdia.c $(AK)\
   $(stdio__h) $(time__h) $(unistd__h) $(gx_h) $(gp_h)
diff --git a/src/unix-dll.mak b/src/unix-dll.mak
index ab84c1b..0c9c04a 100644
--- a/src/unix-dll.mak
+++ b/src/unix-dll.mak
@@ -78,7 +78,7 @@ $(GSSOC_XE): $(GS_SO) $(GLSRC)dxmainc.c
 	$(GLCC) -g -o $(GSSOC_XE) $(GLSRC)dxmainc.c -L$(BINDIR) -l$(GS)
 
 $(GSSOBE_XE): $(GS_SO) $(GLSRC)gsfront.cpp
-	$(GLCC) -g -o $(GSSOBE_XE) $(GLSRC)gsfront.cpp -L$(BINDIR) -l$(GS) -lbe
+	$(GLCC) -g -o $(GSSOBE_XE) $(GLSRC)gsfront.cpp -L$(BINDIR) -l$(GS) -lbe -lstdc++
 
 # ------------------------- Recursive make targets ------------------------- #
 
diff --git a/src/unix-gcc.mak b/src/unix-gcc.mak
index e4e3113..1d14d0a 100644
--- a/src/unix-gcc.mak
+++ b/src/unix-gcc.mak
@@ -256,7 +256,7 @@ LDFLAGS=$(XLDFLAGS)
 # Solaris may need -lnsl -lsocket -lposix4.
 # (Libraries required by individual drivers are handled automatically.)
 
-EXTRALIBS=-lbe
+EXTRALIBS=
 
 # Define the standard libraries to search at the end of linking.
 # Most platforms require -lpthread for the POSIX threads library;
@@ -367,7 +367,6 @@ EXTEND_NAMES=0
 # Choose the device(s) to include.  See devs.mak for details,
 # devs.mak and contrib.mak for the list of available devices.
 
-DEVICE_DEVS=$(DISPLAY_DEV) $(DD)beos.dev $(DD)bealpha2.dev $(DD)bealpha4.dev $(DD)bealpht2.dev $(DD)bealpht4.dev
 #DEVICE_DEVS=$(DISPLAY_DEV) $(DD)x11.dev $(DD)x11alpha.dev $(DD)x11cmyk.dev $(DD)x11gray2.dev $(DD)x11gray4.dev $(DD)x11mono.dev
 
 #DEVICE_DEVS1=
diff --git a/src/unixlink.mak b/src/unixlink.mak
index e8b122e..bcaf1a8 100644
--- a/src/unixlink.mak
+++ b/src/unixlink.mak
@@ -56,7 +56,7 @@ $(GS_XE): $(ld_tr) $(ECHOGS_XE) $(XE_ALL)
 	$(ECHOGS_XE) -w $(ldt_tr) -n - $(CCLD) $(LDFLAGS) -o $(GS_XE)
 	$(ECHOGS_XE) -a $(ldt_tr) -n -s $(PSOBJ)gs.$(OBJ) -s
 	cat $(ld_tr) >>$(ldt_tr)
-	$(ECHOGS_XE) -a $(ldt_tr) -s - $(EXTRALIBS) $(STDLIBS)
+	$(ECHOGS_XE) -a $(ldt_tr) -s - $(EXTRALIBS) -lbe -lstdc++ $(STDLIBS)
 	if [ x$(XLIBDIR) != x ]; then LD_RUN_PATH=$(XLIBDIR); export LD_RUN_PATH; fi; \
 	XCFLAGS= XINCLUDE= XLDFLAGS= XLIBDIRS= XLIBS= \
 	FEATURE_DEVS= DEVICE_DEVS= DEVICE_DEVS1= DEVICE_DEVS2= DEVICE_DEVS3= \
-- 
2.37.3


From 1e138d52a9f435600238d432e7d684e7e19c5e8a Mon Sep 17 00:00:00 2001
From: Ken Sharp <ken.sharp@artifex.com>
Date: Fri, 24 Mar 2023 13:19:57 +0000
Subject: Graphics library - prevent buffer overrun in (T)BCP encoding

Bug #706494 "Buffer Overflow in s_xBCPE_process"

As described in detail in the bug report, if the write buffer is filled
to one byte less than full, and we then try to write an escaped
character, we overrun the buffer because we don't check before
writing two bytes to it.

This just checks if we have two bytes before starting to write an
escaped character and exits if we don't (replacing the consumed byte
of the input).

Up for further discussion; why do we even permit a BCP encoding filter
anyway ? I think we should remove this, at least when SAFER is true.

diff --git a/src/sbcp.c b/src/sbcp.c
index 3641954..676109b 100644
--- a/src/sbcp.c
+++ b/src/sbcp.c
@@ -51,6 +51,14 @@ s_xBCPE_process(stream_state * st, stream_cursor_read * pr,
 	byte ch = *++p;
 
 	if (ch <= 31 && escaped[ch]) {
+            /* Make sure we have space to store two characters in the write buffer,
+             * if we don't then exit without consuming the input character, we'll process
+             * that on the next time round.
+             */
+            if (pw->limit - q < 2) {
+                p--;
+                break;
+            }
 	    if (p == rlimit) {
 		p--;
 		break;
-- 
2.37.3


From af355854d55bc5fe96db46ef566030bd0c658d5b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joachim=20Mairb=C3=B6ck?= <j.mairboeck@gmail.com>
Date: Sun, 9 Apr 2023 20:54:53 +0200
Subject: add config.guess and config.sub scripts (needed for modern autoconf)


diff --git a/config.guess b/config.guess
new file mode 100644
index 0000000..69188da
--- /dev/null
+++ b/config.guess
@@ -0,0 +1,1774 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright 1992-2023 Free Software Foundation, Inc.
+
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2023-01-01'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+#
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
+#
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
+
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Options:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright 1992-2023 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+# Just in case it came from the environment.
+GUESS=
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+tmp=
+# shellcheck disable=SC2172
+trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
+
+set_cc_for_build() {
+    # prevent multiple calls if $tmp is already set
+    test "$tmp" && return 0
+    : "${TMPDIR=/tmp}"
+    # shellcheck disable=SC2039,SC3028
+    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
+    dummy=$tmp/dummy
+    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
+	,,)    echo "int x;" > "$dummy.c"
+	       for driver in cc gcc c89 c99 ; do
+		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+		       CC_FOR_BUILD=$driver
+		       break
+		   fi
+	       done
+	       if test x"$CC_FOR_BUILD" = x ; then
+		   CC_FOR_BUILD=no_compiler_found
+	       fi
+	       ;;
+	,,*)   CC_FOR_BUILD=$CC ;;
+	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+    esac
+}
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if test -f /.attbin/uname ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+case $UNAME_SYSTEM in
+Linux|GNU|GNU/*)
+	LIBC=unknown
+
+	set_cc_for_build
+	cat <<-EOF > "$dummy.c"
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#elif defined(__GLIBC__)
+	LIBC=gnu
+	#else
+	#include <stdarg.h>
+	/* First heuristic to detect musl libc.  */
+	#ifdef __DEFINED_va_list
+	LIBC=musl
+	#endif
+	#endif
+	EOF
+	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	eval "$cc_set_libc"
+
+	# Second heuristic to detect musl libc.
+	if [ "$LIBC" = unknown ] &&
+	   command -v ldd >/dev/null &&
+	   ldd --version 2>&1 | grep -q ^musl; then
+		LIBC=musl
+	fi
+
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	if [ "$LIBC" = unknown ]; then
+		LIBC=gnu
+	fi
+	;;
+esac
+
+# Note: order is significant - the case branches are not exclusive.
+
+case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    echo unknown)`
+	case $UNAME_MACHINE_ARCH in
+	    aarch64eb) machine=aarch64_be-unknown ;;
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
+	    *) machine=$UNAME_MACHINE_ARCH-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently (or will in the future) and ABI.
+	case $UNAME_MACHINE_ARCH in
+	    earm*)
+		os=netbsdelf
+		;;
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep -q __ELF__
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+		os=netbsd
+		;;
+	esac
+	# Determine ABI tags.
+	case $UNAME_MACHINE_ARCH in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case $UNAME_VERSION in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	GUESS=$machine-${os}${release}${abi-}
+	;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE
+	;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE
+	;;
+    *:SecBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE
+	;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE
+	;;
+    *:MidnightBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE
+	;;
+    *:ekkoBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE
+	;;
+    *:SolidBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE
+	;;
+    *:OS108:*:*)
+	GUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE
+	;;
+    macppc:MirBSD:*:*)
+	GUESS=powerpc-unknown-mirbsd$UNAME_RELEASE
+	;;
+    *:MirBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE
+	;;
+    *:Sortix:*:*)
+	GUESS=$UNAME_MACHINE-unknown-sortix
+	;;
+    *:Twizzler:*:*)
+	GUESS=$UNAME_MACHINE-unknown-twizzler
+	;;
+    *:Redox:*:*)
+	GUESS=$UNAME_MACHINE-unknown-redox
+	;;
+    mips:OSF1:*.*)
+	GUESS=mips-dec-osf1
+	;;
+    alpha:OSF1:*:*)
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	trap '' 0
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case $ALPHA_CPU_TYPE in
+	    "EV4 (21064)")
+		UNAME_MACHINE=alpha ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE=alpha ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE=alpha ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE=alphaev5 ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE=alphaev56 ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE=alphapca56 ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE=alphapca57 ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE=alphaev6 ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE=alphaev67 ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE=alphaev69 ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE=alphaev7 ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE=alphaev79 ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	OSF_REL=`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	GUESS=$UNAME_MACHINE-dec-osf$OSF_REL
+	;;
+    Amiga*:UNIX_System_V:4.0:*)
+	GUESS=m68k-unknown-sysv4
+	;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	GUESS=$UNAME_MACHINE-unknown-amigaos
+	;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	GUESS=$UNAME_MACHINE-unknown-morphos
+	;;
+    *:OS/390:*:*)
+	GUESS=i370-ibm-openedition
+	;;
+    *:z/VM:*:*)
+	GUESS=s390-ibm-zvmoe
+	;;
+    *:OS400:*:*)
+	GUESS=powerpc-ibm-os400
+	;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	GUESS=arm-acorn-riscix$UNAME_RELEASE
+	;;
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
+	GUESS=arm-unknown-riscos
+	;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	GUESS=hppa1.1-hitachi-hiuxmpp
+	;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	case `(/bin/universe) 2>/dev/null` in
+	    att) GUESS=pyramid-pyramid-sysv3 ;;
+	    *)   GUESS=pyramid-pyramid-bsd   ;;
+	esac
+	;;
+    NILE*:*:*:dcosx)
+	GUESS=pyramid-pyramid-svr4
+	;;
+    DRS?6000:unix:4.0:6*)
+	GUESS=sparc-icl-nx6
+	;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) GUESS=sparc-icl-nx7 ;;
+	esac
+	;;
+    s390x:SunOS:*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL
+	;;
+    sun4H:SunOS:5.*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-hal-solaris2$SUN_REL
+	;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris2$SUN_REL
+	;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	GUESS=i386-pc-auroraux$UNAME_RELEASE
+	;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	set_cc_for_build
+	SUN_ARCH=i386
+	# If there is a compiler, see if it is configured for 64-bit objects.
+	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+	# This test works for both compilers.
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS="" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		SUN_ARCH=x86_64
+	    fi
+	fi
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$SUN_ARCH-pc-solaris2$SUN_REL
+	;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris3$SUN_REL
+	;;
+    sun4*:SunOS:*:*)
+	case `/usr/bin/arch -k` in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/'`
+	GUESS=sparc-sun-sunos$SUN_REL
+	;;
+    sun3*:SunOS:*:*)
+	GUESS=m68k-sun-sunos$UNAME_RELEASE
+	;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
+	case `/bin/arch` in
+	    sun3)
+		GUESS=m68k-sun-sunos$UNAME_RELEASE
+		;;
+	    sun4)
+		GUESS=sparc-sun-sunos$UNAME_RELEASE
+		;;
+	esac
+	;;
+    aushp:SunOS:*:*)
+	GUESS=sparc-auspex-sunos$UNAME_RELEASE
+	;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+	GUESS=m68k-milan-mint$UNAME_RELEASE
+	;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+	GUESS=m68k-hades-mint$UNAME_RELEASE
+	;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+	GUESS=m68k-unknown-mint$UNAME_RELEASE
+	;;
+    m68k:machten:*:*)
+	GUESS=m68k-apple-machten$UNAME_RELEASE
+	;;
+    powerpc:machten:*:*)
+	GUESS=powerpc-apple-machten$UNAME_RELEASE
+	;;
+    RISC*:Mach:*:*)
+	GUESS=mips-dec-mach_bsd4.3
+	;;
+    RISC*:ULTRIX:*:*)
+	GUESS=mips-dec-ultrix$UNAME_RELEASE
+	;;
+    VAX*:ULTRIX*:*:*)
+	GUESS=vax-dec-ultrix$UNAME_RELEASE
+	;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	GUESS=clipper-intergraph-clix$UNAME_RELEASE
+	;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
+	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	GUESS=mips-mips-riscos$UNAME_RELEASE
+	;;
+    Motorola:PowerMAX_OS:*:*)
+	GUESS=powerpc-motorola-powermax
+	;;
+    Motorola:*:4.3:PL8-*)
+	GUESS=powerpc-harris-powermax
+	;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	GUESS=powerpc-harris-powermax
+	;;
+    Night_Hawk:Power_UNIX:*:*)
+	GUESS=powerpc-harris-powerunix
+	;;
+    m88k:CX/UX:7*:*)
+	GUESS=m88k-harris-cxux7
+	;;
+    m88k:*:4*:R4*)
+	GUESS=m88k-motorola-sysv4
+	;;
+    m88k:*:3*:R3*)
+	GUESS=m88k-motorola-sysv3
+	;;
+    AViiON:dgux:*:*)
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
+	then
+	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
+	       test "$TARGET_BINARY_INTERFACE"x = x
+	    then
+		GUESS=m88k-dg-dgux$UNAME_RELEASE
+	    else
+		GUESS=m88k-dg-dguxbcs$UNAME_RELEASE
+	    fi
+	else
+	    GUESS=i586-dg-dgux$UNAME_RELEASE
+	fi
+	;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	GUESS=m88k-dolphin-sysv3
+	;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	GUESS=m88k-motorola-sysv3
+	;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	GUESS=m88k-tektronix-sysv3
+	;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	GUESS=m68k-tektronix-bsd
+	;;
+    *:IRIX*:*:*)
+	IRIX_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/g'`
+	GUESS=mips-sgi-irix$IRIX_REL
+	;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	GUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id
+	;;                    # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	GUESS=i386-ibm-aix
+	;;
+    ia64:AIX:*:*)
+	if test -x /usr/bin/oslevel ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
+	fi
+	GUESS=$UNAME_MACHINE-ibm-aix$IBM_REV
+	;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		set_cc_for_build
+		sed 's/^		//' << EOF > "$dummy.c"
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
+		then
+			GUESS=$SYSTEM_NAME
+		else
+			GUESS=rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		GUESS=rs6000-ibm-aix3.2.4
+	else
+		GUESS=rs6000-ibm-aix3.2
+	fi
+	;;
+    *:AIX:*:[4567])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if test -x /usr/bin/lslpp ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
+	else
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
+	fi
+	GUESS=$IBM_ARCH-ibm-aix$IBM_REV
+	;;
+    *:AIX:*:*)
+	GUESS=rs6000-ibm-aix
+	;;
+    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
+	GUESS=romp-ibm-bsd4.4
+	;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	GUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to
+	;;                                  # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	GUESS=rs6000-bull-bosx
+	;;
+    DPX/2?00:B.O.S.:*:*)
+	GUESS=m68k-bull-sysv3
+	;;
+    9000/[34]??:4.3bsd:1.*:*)
+	GUESS=m68k-hp-bsd
+	;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	GUESS=m68k-hp-bsd4.4
+	;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	case $UNAME_MACHINE in
+	    9000/31?)            HP_ARCH=m68000 ;;
+	    9000/[34]??)         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if test -x /usr/bin/getconf; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case $sc_cpu_version in
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case $sc_kernel_bits in
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
+			esac ;;
+		    esac
+		fi
+		if test "$HP_ARCH" = ""; then
+		    set_cc_for_build
+		    sed 's/^		//' << EOF > "$dummy.c"
+
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
+
+		int main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
+EOF
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if test "$HP_ARCH" = hppa2.0w
+	then
+	    set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep -q __LP64__
+	    then
+		HP_ARCH=hppa2.0w
+	    else
+		HP_ARCH=hppa64
+	    fi
+	fi
+	GUESS=$HP_ARCH-hp-hpux$HPUX_REV
+	;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	GUESS=ia64-hp-hpux$HPUX_REV
+	;;
+    3050*:HI-UX:*:*)
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	GUESS=unknown-hitachi-hiuxwe2
+	;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
+	GUESS=hppa1.1-hp-bsd
+	;;
+    9000/8??:4.3bsd:*:*)
+	GUESS=hppa1.0-hp-bsd
+	;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	GUESS=hppa1.0-hp-mpeix
+	;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
+	GUESS=hppa1.1-hp-osf
+	;;
+    hp8??:OSF1:*:*)
+	GUESS=hppa1.0-hp-osf
+	;;
+    i*86:OSF1:*:*)
+	if test -x /usr/sbin/sysversion ; then
+	    GUESS=$UNAME_MACHINE-unknown-osf1mk
+	else
+	    GUESS=$UNAME_MACHINE-unknown-osf1
+	fi
+	;;
+    parisc*:Lites*:*:*)
+	GUESS=hppa1.1-hp-lites
+	;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	GUESS=c1-convex-bsd
+	;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	GUESS=c34-convex-bsd
+	;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	GUESS=c38-convex-bsd
+	;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	GUESS=c4-convex-bsd
+	;;
+    CRAY*Y-MP:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=ymp-cray-unicos$CRAY_REL
+	;;
+    CRAY*[A-Z]90:*:*:*)
+	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=t90-cray-unicos$CRAY_REL
+	;;
+    CRAY*T3E:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=alphaev5-cray-unicosmk$CRAY_REL
+	;;
+    CRAY*SV1:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=sv1-cray-unicos$CRAY_REL
+	;;
+    *:UNICOS/mp:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=craynv-cray-unicosmp$CRAY_REL
+	;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	GUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
+    5000:UNIX_System_V:4.*:*)
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	GUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	GUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE
+	;;
+    sparc*:BSD/OS:*:*)
+	GUESS=sparc-unknown-bsdi$UNAME_RELEASE
+	;;
+    *:BSD/OS:*:*)
+	GUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE
+	;;
+    arm:FreeBSD:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	set_cc_for_build
+	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_PCS_VFP
+	then
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi
+	else
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf
+	fi
+	;;
+    *:FreeBSD:*:*)
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case $UNAME_PROCESSOR in
+	    amd64)
+		UNAME_PROCESSOR=x86_64 ;;
+	    i386)
+		UNAME_PROCESSOR=i586 ;;
+	esac
+	FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL
+	;;
+    i*:CYGWIN*:*)
+	GUESS=$UNAME_MACHINE-pc-cygwin
+	;;
+    *:MINGW64*:*)
+	GUESS=$UNAME_MACHINE-pc-mingw64
+	;;
+    *:MINGW*:*)
+	GUESS=$UNAME_MACHINE-pc-mingw32
+	;;
+    *:MSYS*:*)
+	GUESS=$UNAME_MACHINE-pc-msys
+	;;
+    i*:PW*:*)
+	GUESS=$UNAME_MACHINE-pc-pw32
+	;;
+    *:SerenityOS:*:*)
+        GUESS=$UNAME_MACHINE-pc-serenity
+        ;;
+    *:Interix*:*)
+	case $UNAME_MACHINE in
+	    x86)
+		GUESS=i586-pc-interix$UNAME_RELEASE
+		;;
+	    authenticamd | genuineintel | EM64T)
+		GUESS=x86_64-unknown-interix$UNAME_RELEASE
+		;;
+	    IA64)
+		GUESS=ia64-unknown-interix$UNAME_RELEASE
+		;;
+	esac ;;
+    i*:UWIN*:*)
+	GUESS=$UNAME_MACHINE-pc-uwin
+	;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	GUESS=x86_64-pc-cygwin
+	;;
+    prep*:SunOS:5.*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=powerpcle-unknown-solaris2$SUN_REL
+	;;
+    *:GNU:*:*)
+	# the GNU system
+	GNU_ARCH=`echo "$UNAME_MACHINE" | sed -e 's,[-/].*$,,'`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's,/.*$,,'`
+	GUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL
+	;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	GNU_SYS=`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC
+	;;
+    x86_64:[Mm]anagarm:*:*|i?86:[Mm]anagarm:*:*)
+	GUESS="$UNAME_MACHINE-pc-managarm-mlibc"
+	;;
+    *:[Mm]anagarm:*:*)
+	GUESS="$UNAME_MACHINE-unknown-managarm-mlibc"
+	;;
+    *:Minix:*:*)
+	GUESS=$UNAME_MACHINE-unknown-minix
+	;;
+    aarch64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+	esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    arm*:Linux:*:*)
+	set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	else
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi
+	    else
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf
+	    fi
+	fi
+	;;
+    avr32*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    cris:Linux:*:*)
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
+    crisv32:Linux:*:*)
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
+    e2k:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    frv:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    hexagon:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    i*86:Linux:*:*)
+	GUESS=$UNAME_MACHINE-pc-linux-$LIBC
+	;;
+    ia64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    k1om:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    loongarch32:Linux:*:* | loongarch64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    m32r*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    m68*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    mips:Linux:*:* | mips64:Linux:*:*)
+	set_cc_for_build
+	IS_GLIBC=0
+	test x"${LIBC}" = xgnu && IS_GLIBC=1
+	sed 's/^	//' << EOF > "$dummy.c"
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#undef mips64
+	#undef mips64el
+	#if ${IS_GLIBC} && defined(_ABI64)
+	LIBCABI=gnuabi64
+	#else
+	#if ${IS_GLIBC} && defined(_ABIN32)
+	LIBCABI=gnuabin32
+	#else
+	LIBCABI=${LIBC}
+	#endif
+	#endif
+
+	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa64r6
+	#else
+	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa32r6
+	#else
+	#if defined(__mips64)
+	CPU=mips64
+	#else
+	CPU=mips
+	#endif
+	#endif
+	#endif
+
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	MIPS_ENDIAN=el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	MIPS_ENDIAN=
+	#else
+	MIPS_ENDIAN=
+	#endif
+	#endif
+EOF
+	cc_set_vars=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`
+	eval "$cc_set_vars"
+	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
+	;;
+    mips64el:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    openrisc*:Linux:*:*)
+	GUESS=or1k-unknown-linux-$LIBC
+	;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    padre:Linux:*:*)
+	GUESS=sparc-unknown-linux-$LIBC
+	;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	GUESS=hppa64-unknown-linux-$LIBC
+	;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;
+	  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;
+	  *)    GUESS=hppa-unknown-linux-$LIBC ;;
+	esac
+	;;
+    ppc64:Linux:*:*)
+	GUESS=powerpc64-unknown-linux-$LIBC
+	;;
+    ppc:Linux:*:*)
+	GUESS=powerpc-unknown-linux-$LIBC
+	;;
+    ppc64le:Linux:*:*)
+	GUESS=powerpc64le-unknown-linux-$LIBC
+	;;
+    ppcle:Linux:*:*)
+	GUESS=powerpcle-unknown-linux-$LIBC
+	;;
+    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	GUESS=$UNAME_MACHINE-ibm-linux-$LIBC
+	;;
+    sh64*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    sh*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    tile*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    vax:Linux:*:*)
+	GUESS=$UNAME_MACHINE-dec-linux-$LIBC
+	;;
+    x86_64:Linux:*:*)
+	set_cc_for_build
+	CPU=$UNAME_MACHINE
+	LIBCABI=$LIBC
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    ABI=64
+	    sed 's/^	    //' << EOF > "$dummy.c"
+	    #ifdef __i386__
+	    ABI=x86
+	    #else
+	    #ifdef __ILP32__
+	    ABI=x32
+	    #endif
+	    #endif
+EOF
+	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
+	    eval "$cc_set_abi"
+	    case $ABI in
+		x86) CPU=i686 ;;
+		x32) LIBCABI=${LIBC}x32 ;;
+	    esac
+	fi
+	GUESS=$CPU-pc-linux-$LIBCABI
+	;;
+    xtensa*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	GUESS=i386-sequent-sysv4
+	;;
+    i*86:UNIX_SV:4.2MP:2.*)
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+	# Use sysv4.2uw... so that sysv4* matches it.
+	GUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION
+	;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	GUESS=$UNAME_MACHINE-pc-os2-emx
+	;;
+    i*86:XTS-300:*:STOP)
+	GUESS=$UNAME_MACHINE-unknown-stop
+	;;
+    i*86:atheos:*:*)
+	GUESS=$UNAME_MACHINE-unknown-atheos
+	;;
+    i*86:syllable:*:*)
+	GUESS=$UNAME_MACHINE-pc-syllable
+	;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
+	GUESS=i386-unknown-lynxos$UNAME_RELEASE
+	;;
+    i*86:*DOS:*:*)
+	GUESS=$UNAME_MACHINE-pc-msdosdjgpp
+	;;
+    i*86:*:4.*:*)
+	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		GUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL
+	else
+		GUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL
+	fi
+	;;
+    i*86:*:5:[678]*)
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	GUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		GUESS=$UNAME_MACHINE-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		GUESS=$UNAME_MACHINE-pc-sco$UNAME_REL
+	else
+		GUESS=$UNAME_MACHINE-pc-sysv32
+	fi
+	;;
+    pc:*:*:*)
+	# Left here for compatibility:
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configure will decide that
+	# this is a cross-build.
+	GUESS=i586-pc-msdosdjgpp
+	;;
+    Intel:Mach:3*:*)
+	GUESS=i386-pc-mach3
+	;;
+    paragon:*:*:*)
+	GUESS=i860-intel-osf1
+	;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4
+	fi
+	;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	GUESS=m68010-convergent-sysv
+	;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	GUESS=m68k-convergent-sysv
+	;;
+    M680?0:D-NIX:5.3:*)
+	GUESS=m68k-diab-dnix
+	;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	GUESS=m68k-unknown-lynxos$UNAME_RELEASE
+	;;
+    mc68030:UNIX_System_V:4.*:*)
+	GUESS=m68k-atari-sysv4
+	;;
+    TSUNAMI:LynxOS:2.*:*)
+	GUESS=sparc-unknown-lynxos$UNAME_RELEASE
+	;;
+    rs6000:LynxOS:2.*:*)
+	GUESS=rs6000-unknown-lynxos$UNAME_RELEASE
+	;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
+	GUESS=powerpc-unknown-lynxos$UNAME_RELEASE
+	;;
+    SM[BE]S:UNIX_SV:*:*)
+	GUESS=mips-dde-sysv$UNAME_RELEASE
+	;;
+    RM*:ReliantUNIX-*:*:*)
+	GUESS=mips-sni-sysv4
+	;;
+    RM*:SINIX-*:*:*)
+	GUESS=mips-sni-sysv4
+	;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		GUESS=$UNAME_MACHINE-sni-sysv4
+	else
+		GUESS=ns32k-sni-sysv
+	fi
+	;;
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	GUESS=i586-unisys-sysv4
+	;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	GUESS=hppa1.1-stratus-sysv4
+	;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	GUESS=i860-stratus-sysv4
+	;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	GUESS=$UNAME_MACHINE-stratus-vos
+	;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	GUESS=hppa1.1-stratus-vos
+	;;
+    mc68*:A/UX:*:*)
+	GUESS=m68k-apple-aux$UNAME_RELEASE
+	;;
+    news*:NEWS-OS:6*:*)
+	GUESS=mips-sony-newsos6
+	;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if test -d /usr/nec; then
+		GUESS=mips-nec-sysv$UNAME_RELEASE
+	else
+		GUESS=mips-unknown-sysv$UNAME_RELEASE
+	fi
+	;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	GUESS=powerpc-be-beos
+	;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	GUESS=powerpc-apple-beos
+	;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	GUESS=i586-pc-beos
+	;;
+    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+	GUESS=i586-pc-haiku
+	;;
+    ppc:Haiku:*:*)	# Haiku running on Apple PowerPC
+	GUESS=powerpc-apple-haiku
+	;;
+    *:Haiku:*:*)	# Haiku modern gcc (not bound by BeOS compat)
+	GUESS=$UNAME_MACHINE-unknown-haiku
+	;;
+    SX-4:SUPER-UX:*:*)
+	GUESS=sx4-nec-superux$UNAME_RELEASE
+	;;
+    SX-5:SUPER-UX:*:*)
+	GUESS=sx5-nec-superux$UNAME_RELEASE
+	;;
+    SX-6:SUPER-UX:*:*)
+	GUESS=sx6-nec-superux$UNAME_RELEASE
+	;;
+    SX-7:SUPER-UX:*:*)
+	GUESS=sx7-nec-superux$UNAME_RELEASE
+	;;
+    SX-8:SUPER-UX:*:*)
+	GUESS=sx8-nec-superux$UNAME_RELEASE
+	;;
+    SX-8R:SUPER-UX:*:*)
+	GUESS=sx8r-nec-superux$UNAME_RELEASE
+	;;
+    SX-ACE:SUPER-UX:*:*)
+	GUESS=sxace-nec-superux$UNAME_RELEASE
+	;;
+    Power*:Rhapsody:*:*)
+	GUESS=powerpc-apple-rhapsody$UNAME_RELEASE
+	;;
+    *:Rhapsody:*:*)
+	GUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE
+	;;
+    arm64:Darwin:*:*)
+	GUESS=aarch64-apple-darwin$UNAME_RELEASE
+	;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	if command -v xcode-select > /dev/null 2> /dev/null && \
+		! xcode-select --print-path > /dev/null 2> /dev/null ; then
+	    # Avoid executing cc if there is no toolchain installed as
+	    # cc will be a stub that puts up a graphical alert
+	    # prompting the user to install developer tools.
+	    CC_FOR_BUILD=no_compiler_found
+	else
+	    set_cc_for_build
+	fi
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+	    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_PPC >/dev/null
+	    then
+		UNAME_PROCESSOR=powerpc
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # uname -m returns i386 or x86_64
+	    UNAME_PROCESSOR=$UNAME_MACHINE
+	fi
+	GUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE
+	;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = x86; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	GUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE
+	;;
+    *:QNX:*:4*)
+	GUESS=i386-pc-qnx
+	;;
+    NEO-*:NONSTOP_KERNEL:*:*)
+	GUESS=neo-tandem-nsk$UNAME_RELEASE
+	;;
+    NSE-*:NONSTOP_KERNEL:*:*)
+	GUESS=nse-tandem-nsk$UNAME_RELEASE
+	;;
+    NSR-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsr-tandem-nsk$UNAME_RELEASE
+	;;
+    NSV-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsv-tandem-nsk$UNAME_RELEASE
+	;;
+    NSX-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsx-tandem-nsk$UNAME_RELEASE
+	;;
+    *:NonStop-UX:*:*)
+	GUESS=mips-compaq-nonstopux
+	;;
+    BS2000:POSIX*:*:*)
+	GUESS=bs2000-siemens-sysv
+	;;
+    DS/*:UNIX_System_V:*:*)
+	GUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE
+	;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "${cputype-}" = 386; then
+	    UNAME_MACHINE=i386
+	elif test "x${cputype-}" != x; then
+	    UNAME_MACHINE=$cputype
+	fi
+	GUESS=$UNAME_MACHINE-unknown-plan9
+	;;
+    *:TOPS-10:*:*)
+	GUESS=pdp10-unknown-tops10
+	;;
+    *:TENEX:*:*)
+	GUESS=pdp10-unknown-tenex
+	;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	GUESS=pdp10-dec-tops20
+	;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	GUESS=pdp10-xkl-tops20
+	;;
+    *:TOPS-20:*:*)
+	GUESS=pdp10-unknown-tops20
+	;;
+    *:ITS:*:*)
+	GUESS=pdp10-unknown-its
+	;;
+    SEI:*:*:SEIUX)
+	GUESS=mips-sei-seiux$UNAME_RELEASE
+	;;
+    *:DragonFly:*:*)
+	DRAGONFLY_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL
+	;;
+    *:*VMS:*:*)
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case $UNAME_MACHINE in
+	    A*) GUESS=alpha-dec-vms ;;
+	    I*) GUESS=ia64-dec-vms ;;
+	    V*) GUESS=vax-dec-vms ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	GUESS=i386-pc-xenix
+	;;
+    i*86:skyos:*:*)
+	SKYOS_REL=`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`
+	GUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL
+	;;
+    i*86:rdos:*:*)
+	GUESS=$UNAME_MACHINE-pc-rdos
+	;;
+    i*86:Fiwix:*:*)
+	GUESS=$UNAME_MACHINE-pc-fiwix
+	;;
+    *:AROS:*:*)
+	GUESS=$UNAME_MACHINE-unknown-aros
+	;;
+    x86_64:VMkernel:*:*)
+	GUESS=$UNAME_MACHINE-unknown-esx
+	;;
+    amd64:Isilon\ OneFS:*:*)
+	GUESS=x86_64-unknown-onefs
+	;;
+    *:Unleashed:*:*)
+	GUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE
+	;;
+esac
+
+# Do we have a guess based on uname results?
+if test "x$GUESS" != x; then
+    echo "$GUESS"
+    exit
+fi
+
+# No uname command or uname output not recognized.
+set_cc_for_build
+cat > "$dummy.c" <<EOF
+#ifdef _SEQUENT_
+#include <sys/types.h>
+#include <sys/utsname.h>
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+  "4"
+#else
+  ""
+#endif
+  ); exit (0);
+#endif
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+  struct utsname un;
+
+  uname(&un);
+  if (strncmp(un.version, "V2", 2) == 0) {
+    printf ("i386-sequent-ptx2\n"); exit (0);
+  }
+  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+    printf ("i386-sequent-ptx1\n"); exit (0);
+  }
+  printf ("i386-sequent-ptx\n"); exit (0);
+#endif
+
+#if defined (vax)
+#if !defined (ultrix)
+#include <sys/param.h>
+#if defined (BSD)
+#if BSD == 43
+  printf ("vax-dec-bsd4.3\n"); exit (0);
+#else
+#if BSD == 199006
+  printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#endif
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("mips-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`"$dummy"` &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
+
+echo "$0: unable to guess system type" >&2
+
+case $UNAME_MACHINE:$UNAME_SYSTEM in
+    mips:Linux | mips64:Linux)
+	# If we got here on MIPS GNU/Linux, output extra information.
+	cat >&2 <<EOF
+
+NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize
+the system type. Please install a C compiler and try again.
+EOF
+	;;
+esac
+
+cat >&2 <<EOF
+
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite *all*
+copies of config.guess and config.sub with the latest versions from:
+
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
+and
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+EOF
+
+our_year=`echo $timestamp | sed 's,-.*,,'`
+thisyear=`date +%Y`
+# shellcheck disable=SC2003
+script_age=`expr "$thisyear" - "$our_year"`
+if test "$script_age" -lt 3 ; then
+   cat >&2 <<EOF
+
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = "$UNAME_MACHINE"
+UNAME_RELEASE = "$UNAME_RELEASE"
+UNAME_SYSTEM  = "$UNAME_SYSTEM"
+UNAME_VERSION = "$UNAME_VERSION"
+EOF
+fi
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff --git a/config.sub b/config.sub
new file mode 100644
index 0000000..de4259e
--- /dev/null
+++ b/config.sub
@@ -0,0 +1,1907 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright 1992-2023 Free Software Foundation, Inc.
+
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2023-01-21'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+
+
+# Please send patches to <config-patches@gnu.org>.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
+
+Canonicalize a configuration name.
+
+Options:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright 1992-2023 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo "$1"
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Split fields of configuration type
+# shellcheck disable=SC2162
+saved_IFS=$IFS
+IFS="-" read field1 field2 field3 field4 <<EOF
+$1
+EOF
+IFS=$saved_IFS
+
+# Separate into logical components for further validation
+case $1 in
+	*-*-*-*-*)
+		echo Invalid configuration \`"$1"\': more than four components >&2
+		exit 1
+		;;
+	*-*-*-*)
+		basic_machine=$field1-$field2
+		basic_os=$field3-$field4
+		;;
+	*-*-*)
+		# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two
+		# parts
+		maybe_os=$field2-$field3
+		case $maybe_os in
+			nto-qnx* | linux-* | uclinux-uclibc* \
+			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
+			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
+			| storm-chaos* | os2-emx* | rtmk-nova* | managarm-*)
+				basic_machine=$field1
+				basic_os=$maybe_os
+				;;
+			android-linux)
+				basic_machine=$field1-unknown
+				basic_os=linux-android
+				;;
+			*)
+				basic_machine=$field1-$field2
+				basic_os=$field3
+				;;
+		esac
+		;;
+	*-*)
+		# A lone config we happen to match not fitting any pattern
+		case $field1-$field2 in
+			decstation-3100)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			*-*)
+				# Second component is usually, but not always the OS
+				case $field2 in
+					# Prevent following clause from handling this valid os
+					sun*os*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+					zephyr*)
+						basic_machine=$field1-unknown
+						basic_os=$field2
+						;;
+					# Manufacturers
+					dec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \
+					| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \
+					| unicom* | ibm* | next | hp | isi* | apollo | altos* \
+					| convergent* | ncr* | news | 32* | 3600* | 3100* \
+					| hitachi* | c[123]* | convex* | sun | crds | omron* | dg \
+					| ultra | tti* | harris | dolphin | highlevel | gould \
+					| cbm | ns | masscomp | apple | axis | knuth | cray \
+					| microblaze* | sim | cisco \
+					| oki | wec | wrs | winbond)
+						basic_machine=$field1-$field2
+						basic_os=
+						;;
+					*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+				esac
+			;;
+		esac
+		;;
+	*)
+		# Convert single-component short-hands not valid as part of
+		# multi-component configurations.
+		case $field1 in
+			386bsd)
+				basic_machine=i386-pc
+				basic_os=bsd
+				;;
+			a29khif)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			adobe68k)
+				basic_machine=m68010-adobe
+				basic_os=scout
+				;;
+			alliant)
+				basic_machine=fx80-alliant
+				basic_os=
+				;;
+			altos | altos3068)
+				basic_machine=m68k-altos
+				basic_os=
+				;;
+			am29k)
+				basic_machine=a29k-none
+				basic_os=bsd
+				;;
+			amdahl)
+				basic_machine=580-amdahl
+				basic_os=sysv
+				;;
+			amiga)
+				basic_machine=m68k-unknown
+				basic_os=
+				;;
+			amigaos | amigados)
+				basic_machine=m68k-unknown
+				basic_os=amigaos
+				;;
+			amigaunix | amix)
+				basic_machine=m68k-unknown
+				basic_os=sysv4
+				;;
+			apollo68)
+				basic_machine=m68k-apollo
+				basic_os=sysv
+				;;
+			apollo68bsd)
+				basic_machine=m68k-apollo
+				basic_os=bsd
+				;;
+			aros)
+				basic_machine=i386-pc
+				basic_os=aros
+				;;
+			aux)
+				basic_machine=m68k-apple
+				basic_os=aux
+				;;
+			balance)
+				basic_machine=ns32k-sequent
+				basic_os=dynix
+				;;
+			blackfin)
+				basic_machine=bfin-unknown
+				basic_os=linux
+				;;
+			cegcc)
+				basic_machine=arm-unknown
+				basic_os=cegcc
+				;;
+			convex-c1)
+				basic_machine=c1-convex
+				basic_os=bsd
+				;;
+			convex-c2)
+				basic_machine=c2-convex
+				basic_os=bsd
+				;;
+			convex-c32)
+				basic_machine=c32-convex
+				basic_os=bsd
+				;;
+			convex-c34)
+				basic_machine=c34-convex
+				basic_os=bsd
+				;;
+			convex-c38)
+				basic_machine=c38-convex
+				basic_os=bsd
+				;;
+			cray)
+				basic_machine=j90-cray
+				basic_os=unicos
+				;;
+			crds | unos)
+				basic_machine=m68k-crds
+				basic_os=
+				;;
+			da30)
+				basic_machine=m68k-da30
+				basic_os=
+				;;
+			decstation | pmax | pmin | dec3100 | decstatn)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			delta88)
+				basic_machine=m88k-motorola
+				basic_os=sysv3
+				;;
+			dicos)
+				basic_machine=i686-pc
+				basic_os=dicos
+				;;
+			djgpp)
+				basic_machine=i586-pc
+				basic_os=msdosdjgpp
+				;;
+			ebmon29k)
+				basic_machine=a29k-amd
+				basic_os=ebmon
+				;;
+			es1800 | OSE68k | ose68k | ose | OSE)
+				basic_machine=m68k-ericsson
+				basic_os=ose
+				;;
+			gmicro)
+				basic_machine=tron-gmicro
+				basic_os=sysv
+				;;
+			go32)
+				basic_machine=i386-pc
+				basic_os=go32
+				;;
+			h8300hms)
+				basic_machine=h8300-hitachi
+				basic_os=hms
+				;;
+			h8300xray)
+				basic_machine=h8300-hitachi
+				basic_os=xray
+				;;
+			h8500hms)
+				basic_machine=h8500-hitachi
+				basic_os=hms
+				;;
+			harris)
+				basic_machine=m88k-harris
+				basic_os=sysv3
+				;;
+			hp300 | hp300hpux)
+				basic_machine=m68k-hp
+				basic_os=hpux
+				;;
+			hp300bsd)
+				basic_machine=m68k-hp
+				basic_os=bsd
+				;;
+			hppaosf)
+				basic_machine=hppa1.1-hp
+				basic_os=osf
+				;;
+			hppro)
+				basic_machine=hppa1.1-hp
+				basic_os=proelf
+				;;
+			i386mach)
+				basic_machine=i386-mach
+				basic_os=mach
+				;;
+			isi68 | isi)
+				basic_machine=m68k-isi
+				basic_os=sysv
+				;;
+			m68knommu)
+				basic_machine=m68k-unknown
+				basic_os=linux
+				;;
+			magnum | m3230)
+				basic_machine=mips-mips
+				basic_os=sysv
+				;;
+			merlin)
+				basic_machine=ns32k-utek
+				basic_os=sysv
+				;;
+			mingw64)
+				basic_machine=x86_64-pc
+				basic_os=mingw64
+				;;
+			mingw32)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			mingw32ce)
+				basic_machine=arm-unknown
+				basic_os=mingw32ce
+				;;
+			monitor)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			morphos)
+				basic_machine=powerpc-unknown
+				basic_os=morphos
+				;;
+			moxiebox)
+				basic_machine=moxie-unknown
+				basic_os=moxiebox
+				;;
+			msdos)
+				basic_machine=i386-pc
+				basic_os=msdos
+				;;
+			msys)
+				basic_machine=i686-pc
+				basic_os=msys
+				;;
+			mvs)
+				basic_machine=i370-ibm
+				basic_os=mvs
+				;;
+			nacl)
+				basic_machine=le32-unknown
+				basic_os=nacl
+				;;
+			ncr3000)
+				basic_machine=i486-ncr
+				basic_os=sysv4
+				;;
+			netbsd386)
+				basic_machine=i386-pc
+				basic_os=netbsd
+				;;
+			netwinder)
+				basic_machine=armv4l-rebel
+				basic_os=linux
+				;;
+			news | news700 | news800 | news900)
+				basic_machine=m68k-sony
+				basic_os=newsos
+				;;
+			news1000)
+				basic_machine=m68030-sony
+				basic_os=newsos
+				;;
+			necv70)
+				basic_machine=v70-nec
+				basic_os=sysv
+				;;
+			nh3000)
+				basic_machine=m68k-harris
+				basic_os=cxux
+				;;
+			nh[45]000)
+				basic_machine=m88k-harris
+				basic_os=cxux
+				;;
+			nindy960)
+				basic_machine=i960-intel
+				basic_os=nindy
+				;;
+			mon960)
+				basic_machine=i960-intel
+				basic_os=mon960
+				;;
+			nonstopux)
+				basic_machine=mips-compaq
+				basic_os=nonstopux
+				;;
+			os400)
+				basic_machine=powerpc-ibm
+				basic_os=os400
+				;;
+			OSE68000 | ose68000)
+				basic_machine=m68000-ericsson
+				basic_os=ose
+				;;
+			os68k)
+				basic_machine=m68k-none
+				basic_os=os68k
+				;;
+			paragon)
+				basic_machine=i860-intel
+				basic_os=osf
+				;;
+			parisc)
+				basic_machine=hppa-unknown
+				basic_os=linux
+				;;
+			psp)
+				basic_machine=mipsallegrexel-sony
+				basic_os=psp
+				;;
+			pw32)
+				basic_machine=i586-unknown
+				basic_os=pw32
+				;;
+			rdos | rdos64)
+				basic_machine=x86_64-pc
+				basic_os=rdos
+				;;
+			rdos32)
+				basic_machine=i386-pc
+				basic_os=rdos
+				;;
+			rom68k)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			sa29200)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			sei)
+				basic_machine=mips-sei
+				basic_os=seiux
+				;;
+			sequent)
+				basic_machine=i386-sequent
+				basic_os=
+				;;
+			sps7)
+				basic_machine=m68k-bull
+				basic_os=sysv2
+				;;
+			st2000)
+				basic_machine=m68k-tandem
+				basic_os=
+				;;
+			stratus)
+				basic_machine=i860-stratus
+				basic_os=sysv4
+				;;
+			sun2)
+				basic_machine=m68000-sun
+				basic_os=
+				;;
+			sun2os3)
+				basic_machine=m68000-sun
+				basic_os=sunos3
+				;;
+			sun2os4)
+				basic_machine=m68000-sun
+				basic_os=sunos4
+				;;
+			sun3)
+				basic_machine=m68k-sun
+				basic_os=
+				;;
+			sun3os3)
+				basic_machine=m68k-sun
+				basic_os=sunos3
+				;;
+			sun3os4)
+				basic_machine=m68k-sun
+				basic_os=sunos4
+				;;
+			sun4)
+				basic_machine=sparc-sun
+				basic_os=
+				;;
+			sun4os3)
+				basic_machine=sparc-sun
+				basic_os=sunos3
+				;;
+			sun4os4)
+				basic_machine=sparc-sun
+				basic_os=sunos4
+				;;
+			sun4sol2)
+				basic_machine=sparc-sun
+				basic_os=solaris2
+				;;
+			sun386 | sun386i | roadrunner)
+				basic_machine=i386-sun
+				basic_os=
+				;;
+			sv1)
+				basic_machine=sv1-cray
+				basic_os=unicos
+				;;
+			symmetry)
+				basic_machine=i386-sequent
+				basic_os=dynix
+				;;
+			t3e)
+				basic_machine=alphaev5-cray
+				basic_os=unicos
+				;;
+			t90)
+				basic_machine=t90-cray
+				basic_os=unicos
+				;;
+			toad1)
+				basic_machine=pdp10-xkl
+				basic_os=tops20
+				;;
+			tpf)
+				basic_machine=s390x-ibm
+				basic_os=tpf
+				;;
+			udi29k)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			ultra3)
+				basic_machine=a29k-nyu
+				basic_os=sym1
+				;;
+			v810 | necv810)
+				basic_machine=v810-nec
+				basic_os=none
+				;;
+			vaxv)
+				basic_machine=vax-dec
+				basic_os=sysv
+				;;
+			vms)
+				basic_machine=vax-dec
+				basic_os=vms
+				;;
+			vsta)
+				basic_machine=i386-pc
+				basic_os=vsta
+				;;
+			vxworks960)
+				basic_machine=i960-wrs
+				basic_os=vxworks
+				;;
+			vxworks68)
+				basic_machine=m68k-wrs
+				basic_os=vxworks
+				;;
+			vxworks29k)
+				basic_machine=a29k-wrs
+				basic_os=vxworks
+				;;
+			xbox)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			ymp)
+				basic_machine=ymp-cray
+				basic_os=unicos
+				;;
+			*)
+				basic_machine=$1
+				basic_os=
+				;;
+		esac
+		;;
+esac
+
+# Decode 1-component or ad-hoc basic machines
+case $basic_machine in
+	# Here we handle the default manufacturer of certain CPU types.  It is in
+	# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		cpu=hppa1.1
+		vendor=winbond
+		;;
+	op50n)
+		cpu=hppa1.1
+		vendor=oki
+		;;
+	op60c)
+		cpu=hppa1.1
+		vendor=oki
+		;;
+	ibm*)
+		cpu=i370
+		vendor=ibm
+		;;
+	orion105)
+		cpu=clipper
+		vendor=highlevel
+		;;
+	mac | mpw | mac-mpw)
+		cpu=m68k
+		vendor=apple
+		;;
+	pmac | pmac-mpw)
+		cpu=powerpc
+		vendor=apple
+		;;
+
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		cpu=m68000
+		vendor=att
+		;;
+	3b*)
+		cpu=we32k
+		vendor=att
+		;;
+	bluegene*)
+		cpu=powerpc
+		vendor=ibm
+		basic_os=cnk
+		;;
+	decsystem10* | dec10*)
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops10
+		;;
+	decsystem20* | dec20*)
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		cpu=m68k
+		vendor=motorola
+		;;
+	dpx2*)
+		cpu=m68k
+		vendor=bull
+		basic_os=sysv3
+		;;
+	encore | umax | mmax)
+		cpu=ns32k
+		vendor=encore
+		;;
+	elxsi)
+		cpu=elxsi
+		vendor=elxsi
+		basic_os=${basic_os:-bsd}
+		;;
+	fx2800)
+		cpu=i860
+		vendor=alliant
+		;;
+	genix)
+		cpu=ns32k
+		vendor=ns
+		;;
+	h3050r* | hiux*)
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		cpu=m68000
+		vendor=hp
+		;;
+	hp9k3[2-9][0-9])
+		cpu=m68k
+		vendor=hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	i*86v32)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv32
+		;;
+	i*86v4*)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv4
+		;;
+	i*86v)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv
+		;;
+	i*86sol2)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=solaris2
+		;;
+	j90 | j90-cray)
+		cpu=j90
+		vendor=cray
+		basic_os=${basic_os:-unicos}
+		;;
+	iris | iris4d)
+		cpu=mips
+		vendor=sgi
+		case $basic_os in
+		    irix*)
+			;;
+		    *)
+			basic_os=irix4
+			;;
+		esac
+		;;
+	miniframe)
+		cpu=m68000
+		vendor=convergent
+		;;
+	*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		cpu=m68k
+		vendor=atari
+		basic_os=mint
+		;;
+	news-3600 | risc-news)
+		cpu=mips
+		vendor=sony
+		basic_os=newsos
+		;;
+	next | m*-next)
+		cpu=m68k
+		vendor=next
+		case $basic_os in
+		    openstep*)
+		        ;;
+		    nextstep*)
+			;;
+		    ns2*)
+		      basic_os=nextstep2
+			;;
+		    *)
+		      basic_os=nextstep3
+			;;
+		esac
+		;;
+	np1)
+		cpu=np1
+		vendor=gould
+		;;
+	op50n-* | op60c-*)
+		cpu=hppa1.1
+		vendor=oki
+		basic_os=proelf
+		;;
+	pa-hitachi)
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
+		;;
+	pbd)
+		cpu=sparc
+		vendor=tti
+		;;
+	pbb)
+		cpu=m68k
+		vendor=tti
+		;;
+	pc532)
+		cpu=ns32k
+		vendor=pc532
+		;;
+	pn)
+		cpu=pn
+		vendor=gould
+		;;
+	power)
+		cpu=power
+		vendor=ibm
+		;;
+	ps2)
+		cpu=i386
+		vendor=ibm
+		;;
+	rm[46]00)
+		cpu=mips
+		vendor=siemens
+		;;
+	rtpc | rtpc-*)
+		cpu=romp
+		vendor=ibm
+		;;
+	sde)
+		cpu=mipsisa32
+		vendor=sde
+		basic_os=${basic_os:-elf}
+		;;
+	simso-wrs)
+		cpu=sparclite
+		vendor=wrs
+		basic_os=vxworks
+		;;
+	tower | tower-32)
+		cpu=m68k
+		vendor=ncr
+		;;
+	vpp*|vx|vx-*)
+		cpu=f301
+		vendor=fujitsu
+		;;
+	w65)
+		cpu=w65
+		vendor=wdc
+		;;
+	w89k-*)
+		cpu=hppa1.1
+		vendor=winbond
+		basic_os=proelf
+		;;
+	none)
+		cpu=none
+		vendor=none
+		;;
+	leon|leon[3-9])
+		cpu=sparc
+		vendor=$basic_machine
+		;;
+	leon-*|leon[3-9]-*)
+		cpu=sparc
+		vendor=`echo "$basic_machine" | sed 's/-.*//'`
+		;;
+
+	*-*)
+		# shellcheck disable=SC2162
+		saved_IFS=$IFS
+		IFS="-" read cpu vendor <<EOF
+$basic_machine
+EOF
+		IFS=$saved_IFS
+		;;
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+		cpu=$basic_machine
+		vendor=pc
+		;;
+	# These rules are duplicated from below for sake of the special case above;
+	# i.e. things that normalized to x86 arches should also default to "pc"
+	pc98)
+		cpu=i386
+		vendor=pc
+		;;
+	x64 | amd64)
+		cpu=x86_64
+		vendor=pc
+		;;
+	# Recognize the basic CPU types without company name.
+	*)
+		cpu=$basic_machine
+		vendor=unknown
+		;;
+esac
+
+unset -v basic_machine
+
+# Decode basic machines in the full and proper CPU-Company form.
+case $cpu-$vendor in
+	# Here we handle the default manufacturer of certain CPU types in canonical form. It is in
+	# some cases the only manufacturer, in others, it is the most popular.
+	craynv-unknown)
+		vendor=cray
+		basic_os=${basic_os:-unicosmp}
+		;;
+	c90-unknown | c90-cray)
+		vendor=cray
+		basic_os=${Basic_os:-unicos}
+		;;
+	fx80-unknown)
+		vendor=alliant
+		;;
+	romp-unknown)
+		vendor=ibm
+		;;
+	mmix-unknown)
+		vendor=knuth
+		;;
+	microblaze-unknown | microblazeel-unknown)
+		vendor=xilinx
+		;;
+	rs6000-unknown)
+		vendor=ibm
+		;;
+	vax-unknown)
+		vendor=dec
+		;;
+	pdp11-unknown)
+		vendor=dec
+		;;
+	we32k-unknown)
+		vendor=att
+		;;
+	cydra-unknown)
+		vendor=cydrome
+		;;
+	i370-ibm*)
+		vendor=ibm
+		;;
+	orion-unknown)
+		vendor=highlevel
+		;;
+	xps-unknown | xps100-unknown)
+		cpu=xps100
+		vendor=honeywell
+		;;
+
+	# Here we normalize CPU types with a missing or matching vendor
+	armh-unknown | armh-alt)
+		cpu=armv7l
+		vendor=alt
+		basic_os=${basic_os:-linux-gnueabihf}
+		;;
+	dpx20-unknown | dpx20-bull)
+		cpu=rs6000
+		vendor=bull
+		basic_os=${basic_os:-bosx}
+		;;
+
+	# Here we normalize CPU types irrespective of the vendor
+	amd64-*)
+		cpu=x86_64
+		;;
+	blackfin-*)
+		cpu=bfin
+		basic_os=linux
+		;;
+	c54x-*)
+		cpu=tic54x
+		;;
+	c55x-*)
+		cpu=tic55x
+		;;
+	c6x-*)
+		cpu=tic6x
+		;;
+	e500v[12]-*)
+		cpu=powerpc
+		basic_os=${basic_os}"spe"
+		;;
+	mips3*-*)
+		cpu=mips64
+		;;
+	ms1-*)
+		cpu=mt
+		;;
+	m68knommu-*)
+		cpu=m68k
+		basic_os=linux
+		;;
+	m9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)
+		cpu=s12z
+		;;
+	openrisc-*)
+		cpu=or32
+		;;
+	parisc-*)
+		cpu=hppa
+		basic_os=linux
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		cpu=i586
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)
+		cpu=i686
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		cpu=i686
+		;;
+	pentium4-*)
+		cpu=i786
+		;;
+	pc98-*)
+		cpu=i386
+		;;
+	ppc-* | ppcbe-*)
+		cpu=powerpc
+		;;
+	ppcle-* | powerpclittle-*)
+		cpu=powerpcle
+		;;
+	ppc64-*)
+		cpu=powerpc64
+		;;
+	ppc64le-* | powerpc64little-*)
+		cpu=powerpc64le
+		;;
+	sb1-*)
+		cpu=mipsisa64sb1
+		;;
+	sb1el-*)
+		cpu=mipsisa64sb1el
+		;;
+	sh5e[lb]-*)
+		cpu=`echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/'`
+		;;
+	spur-*)
+		cpu=spur
+		;;
+	strongarm-* | thumb-*)
+		cpu=arm
+		;;
+	tx39-*)
+		cpu=mipstx39
+		;;
+	tx39el-*)
+		cpu=mipstx39el
+		;;
+	x64-*)
+		cpu=x86_64
+		;;
+	xscale-* | xscalee[bl]-*)
+		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
+		;;
+	arm64-* | aarch64le-*)
+		cpu=aarch64
+		;;
+
+	# Recognize the canonical CPU Types that limit and/or modify the
+	# company names they are paired with.
+	cr16-*)
+		basic_os=${basic_os:-elf}
+		;;
+	crisv32-* | etraxfs*-*)
+		cpu=crisv32
+		vendor=axis
+		;;
+	cris-* | etrax*-*)
+		cpu=cris
+		vendor=axis
+		;;
+	crx-*)
+		basic_os=${basic_os:-elf}
+		;;
+	neo-tandem)
+		cpu=neo
+		vendor=tandem
+		;;
+	nse-tandem)
+		cpu=nse
+		vendor=tandem
+		;;
+	nsr-tandem)
+		cpu=nsr
+		vendor=tandem
+		;;
+	nsv-tandem)
+		cpu=nsv
+		vendor=tandem
+		;;
+	nsx-tandem)
+		cpu=nsx
+		vendor=tandem
+		;;
+	mipsallegrexel-sony)
+		cpu=mipsallegrexel
+		vendor=sony
+		;;
+	tile*-*)
+		basic_os=${basic_os:-linux-gnu}
+		;;
+
+	*)
+		# Recognize the canonical CPU types that are allowed with any
+		# company name.
+		case $cpu in
+			1750a | 580 \
+			| a29k \
+			| aarch64 | aarch64_be \
+			| abacus \
+			| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] \
+			| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] \
+			| alphapca5[67] | alpha64pca5[67] \
+			| am33_2.0 \
+			| amdgcn \
+			| arc | arceb | arc32 | arc64 \
+			| arm | arm[lb]e | arme[lb] | armv* \
+			| avr | avr32 \
+			| asmjs \
+			| ba \
+			| be32 | be64 \
+			| bfin | bpf | bs2000 \
+			| c[123]* | c30 | [cjt]90 | c4x \
+			| c8051 | clipper | craynv | csky | cydra \
+			| d10v | d30v | dlx | dsp16xx \
+			| e2k | elxsi | epiphany \
+			| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \
+			| h8300 | h8500 \
+			| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+			| hexagon \
+			| i370 | i*86 | i860 | i960 | ia16 | ia64 \
+			| ip2k | iq2000 \
+			| k1om \
+			| le32 | le64 \
+			| lm32 \
+			| loongarch32 | loongarch64 \
+			| m32c | m32r | m32rle \
+			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
+			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
+			| m88110 | m88k | maxq | mb | mcore | mep | metag \
+			| microblaze | microblazeel \
+			| mips | mipsbe | mipseb | mipsel | mipsle \
+			| mips16 \
+			| mips64 | mips64eb | mips64el \
+			| mips64octeon | mips64octeonel \
+			| mips64orion | mips64orionel \
+			| mips64r5900 | mips64r5900el \
+			| mips64vr | mips64vrel \
+			| mips64vr4100 | mips64vr4100el \
+			| mips64vr4300 | mips64vr4300el \
+			| mips64vr5000 | mips64vr5000el \
+			| mips64vr5900 | mips64vr5900el \
+			| mipsisa32 | mipsisa32el \
+			| mipsisa32r2 | mipsisa32r2el \
+			| mipsisa32r3 | mipsisa32r3el \
+			| mipsisa32r5 | mipsisa32r5el \
+			| mipsisa32r6 | mipsisa32r6el \
+			| mipsisa64 | mipsisa64el \
+			| mipsisa64r2 | mipsisa64r2el \
+			| mipsisa64r3 | mipsisa64r3el \
+			| mipsisa64r5 | mipsisa64r5el \
+			| mipsisa64r6 | mipsisa64r6el \
+			| mipsisa64sb1 | mipsisa64sb1el \
+			| mipsisa64sr71k | mipsisa64sr71kel \
+			| mipsr5900 | mipsr5900el \
+			| mipstx39 | mipstx39el \
+			| mmix \
+			| mn10200 | mn10300 \
+			| moxie \
+			| mt \
+			| msp430 \
+			| nds32 | nds32le | nds32be \
+			| nfp \
+			| nios | nios2 | nios2eb | nios2el \
+			| none | np1 | ns16k | ns32k | nvptx \
+			| open8 \
+			| or1k* \
+			| or32 \
+			| orion \
+			| picochip \
+			| pdp10 | pdp11 | pj | pjl | pn | power \
+			| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \
+			| pru \
+			| pyramid \
+			| riscv | riscv32 | riscv32be | riscv64 | riscv64be \
+			| rl78 | romp | rs6000 | rx \
+			| s390 | s390x \
+			| score \
+			| sh | shl \
+			| sh[1234] | sh[24]a | sh[24]ae[lb] | sh[23]e | she[lb] | sh[lb]e \
+			| sh[1234]e[lb] |  sh[12345][lb]e | sh[23]ele | sh64 | sh64le \
+			| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet \
+			| sparclite \
+			| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \
+			| spu \
+			| tahoe \
+			| thumbv7* \
+			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
+			| tron \
+			| ubicom32 \
+			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
+			| vax \
+			| visium \
+			| w65 \
+			| wasm32 | wasm64 \
+			| we32k \
+			| x86 | x86_64 | xc16x | xgate | xps100 \
+			| xstormy16 | xtensa* \
+			| ymp \
+			| z8k | z80)
+				;;
+
+			*)
+				echo Invalid configuration \`"$1"\': machine \`"$cpu-$vendor"\' not recognized 1>&2
+				exit 1
+				;;
+		esac
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $vendor in
+	digital*)
+		vendor=dec
+		;;
+	commodore*)
+		vendor=cbm
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if test x$basic_os != x
+then
+
+# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just
+# set os.
+case $basic_os in
+	gnu/linux*)
+		kernel=linux
+		os=`echo "$basic_os" | sed -e 's|gnu/linux|gnu|'`
+		;;
+	os2-emx)
+		kernel=os2
+		os=`echo "$basic_os" | sed -e 's|os2-emx|emx|'`
+		;;
+	nto-qnx*)
+		kernel=nto
+		os=`echo "$basic_os" | sed -e 's|nto-qnx|qnx|'`
+		;;
+	*-*)
+		# shellcheck disable=SC2162
+		saved_IFS=$IFS
+		IFS="-" read kernel os <<EOF
+$basic_os
+EOF
+		IFS=$saved_IFS
+		;;
+	# Default OS when just kernel was specified
+	nto*)
+		kernel=nto
+		os=`echo "$basic_os" | sed -e 's|nto|qnx|'`
+		;;
+	linux*)
+		kernel=linux
+		os=`echo "$basic_os" | sed -e 's|linux|gnu|'`
+		;;
+	managarm*)
+		kernel=managarm
+		os=`echo "$basic_os" | sed -e 's|managarm|mlibc|'`
+		;;
+	*)
+		kernel=
+		os=$basic_os
+		;;
+esac
+
+# Now, normalize the OS (knowing we just have one component, it's not a kernel,
+# etc.)
+case $os in
+	# First match some system type aliases that might get confused
+	# with valid system types.
+	# solaris* is a basic system type, with this one exception.
+	auroraux)
+		os=auroraux
+		;;
+	bluegene*)
+		os=cnk
+		;;
+	solaris1 | solaris1.*)
+		os=`echo "$os" | sed -e 's|solaris1|sunos4|'`
+		;;
+	solaris)
+		os=solaris2
+		;;
+	unixware*)
+		os=sysv4.2uw
+		;;
+	# es1800 is here to avoid being matched by es* (a different OS)
+	es1800*)
+		os=ose
+		;;
+	# Some version numbers need modification
+	chorusos*)
+		os=chorusos
+		;;
+	isc)
+		os=isc2.2
+		;;
+	sco6)
+		os=sco5v6
+		;;
+	sco5)
+		os=sco3.2v5
+		;;
+	sco4)
+		os=sco3.2v4
+		;;
+	sco3.2.[4-9]*)
+		os=`echo "$os" | sed -e 's/sco3.2./sco3.2v/'`
+		;;
+	sco*v* | scout)
+		# Don't match below
+		;;
+	sco*)
+		os=sco3.2v2
+		;;
+	psos*)
+		os=psos
+		;;
+	qnx*)
+		os=qnx
+		;;
+	hiux*)
+		os=hiuxwe2
+		;;
+	lynx*178)
+		os=lynxos178
+		;;
+	lynx*5)
+		os=lynxos5
+		;;
+	lynxos*)
+		# don't get caught up in next wildcard
+		;;
+	lynx*)
+		os=lynxos
+		;;
+	mac[0-9]*)
+		os=`echo "$os" | sed -e 's|mac|macos|'`
+		;;
+	opened*)
+		os=openedition
+		;;
+	os400*)
+		os=os400
+		;;
+	sunos5*)
+		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
+		;;
+	sunos6*)
+		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
+		;;
+	wince*)
+		os=wince
+		;;
+	utek*)
+		os=bsd
+		;;
+	dynix*)
+		os=bsd
+		;;
+	acis*)
+		os=aos
+		;;
+	atheos*)
+		os=atheos
+		;;
+	syllable*)
+		os=syllable
+		;;
+	386bsd)
+		os=bsd
+		;;
+	ctix* | uts*)
+		os=sysv
+		;;
+	nova*)
+		os=rtmk-nova
+		;;
+	ns2)
+		os=nextstep2
+		;;
+	# Preserve the version number of sinix5.
+	sinix5.*)
+		os=`echo "$os" | sed -e 's|sinix|sysv|'`
+		;;
+	sinix*)
+		os=sysv4
+		;;
+	tpf*)
+		os=tpf
+		;;
+	triton*)
+		os=sysv3
+		;;
+	oss*)
+		os=sysv3
+		;;
+	svr4*)
+		os=sysv4
+		;;
+	svr3)
+		os=sysv3
+		;;
+	sysvr4)
+		os=sysv4
+		;;
+	ose*)
+		os=ose
+		;;
+	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
+		os=mint
+		;;
+	dicos*)
+		os=dicos
+		;;
+	pikeos*)
+		# Until real need of OS specific support for
+		# particular features comes up, bare metal
+		# configurations are quite functional.
+		case $cpu in
+		    arm*)
+			os=eabi
+			;;
+		    *)
+			os=elf
+			;;
+		esac
+		;;
+	*)
+		# No normalization, but not necessarily accepted, that comes below.
+		;;
+esac
+
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+kernel=
+case $cpu-$vendor in
+	score-*)
+		os=elf
+		;;
+	spu-*)
+		os=elf
+		;;
+	*-acorn)
+		os=riscix1.2
+		;;
+	arm*-rebel)
+		kernel=linux
+		os=gnu
+		;;
+	arm*-semi)
+		os=aout
+		;;
+	c4x-* | tic4x-*)
+		os=coff
+		;;
+	c8051-*)
+		os=elf
+		;;
+	clipper-intergraph)
+		os=clix
+		;;
+	hexagon-*)
+		os=elf
+		;;
+	tic54x-*)
+		os=coff
+		;;
+	tic55x-*)
+		os=coff
+		;;
+	tic6x-*)
+		os=coff
+		;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=tops20
+		;;
+	pdp11-*)
+		os=none
+		;;
+	*-dec | vax-*)
+		os=ultrix4.2
+		;;
+	m68*-apollo)
+		os=domain
+		;;
+	i386-sun)
+		os=sunos4.0.2
+		;;
+	m68000-sun)
+		os=sunos3
+		;;
+	m68*-cisco)
+		os=aout
+		;;
+	mep-*)
+		os=elf
+		;;
+	mips*-cisco)
+		os=elf
+		;;
+	mips*-*)
+		os=elf
+		;;
+	or32-*)
+		os=coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=sysv3
+		;;
+	sparc-* | *-sun)
+		os=sunos4.1.1
+		;;
+	pru-*)
+		os=elf
+		;;
+	*-be)
+		os=beos
+		;;
+	*-ibm)
+		os=aix
+		;;
+	*-knuth)
+		os=mmixware
+		;;
+	*-wec)
+		os=proelf
+		;;
+	*-winbond)
+		os=proelf
+		;;
+	*-oki)
+		os=proelf
+		;;
+	*-hp)
+		os=hpux
+		;;
+	*-hitachi)
+		os=hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=sysv
+		;;
+	*-cbm)
+		os=amigaos
+		;;
+	*-dg)
+		os=dgux
+		;;
+	*-dolphin)
+		os=sysv3
+		;;
+	m68k-ccur)
+		os=rtu
+		;;
+	m88k-omron*)
+		os=luna
+		;;
+	*-next)
+		os=nextstep
+		;;
+	*-sequent)
+		os=ptx
+		;;
+	*-crds)
+		os=unos
+		;;
+	*-ns)
+		os=genix
+		;;
+	i370-*)
+		os=mvs
+		;;
+	*-gould)
+		os=sysv
+		;;
+	*-highlevel)
+		os=bsd
+		;;
+	*-encore)
+		os=bsd
+		;;
+	*-sgi)
+		os=irix
+		;;
+	*-siemens)
+		os=sysv4
+		;;
+	*-masscomp)
+		os=rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=uxpv
+		;;
+	*-rom68k)
+		os=coff
+		;;
+	*-*bug)
+		os=coff
+		;;
+	*-apple)
+		os=macos
+		;;
+	*-atari*)
+		os=mint
+		;;
+	*-wrs)
+		os=vxworks
+		;;
+	*)
+		os=none
+		;;
+esac
+
+fi
+
+# Now, validate our (potentially fixed-up) OS.
+case $os in
+	# Sometimes we do "kernel-libc", so those need to count as OSes.
+	musl* | newlib* | relibc* | uclibc*)
+		;;
+	# Likewise for "kernel-abi"
+	eabi* | gnueabi*)
+		;;
+	# VxWorks passes extra cpu info in the 4th filed.
+	simlinux | simwindows | spe)
+		;;
+	# Now accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST end in a * to match a version number.
+	gnu* | android* | bsd* | mach* | minix* | genix* | ultrix* | irix* \
+	     | *vms* | esix* | aix* | cnk* | sunos | sunos[34]* \
+	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
+	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
+	     | hiux* | abug | nacl* | netware* | windows* \
+	     | os9* | macos* | osx* | ios* \
+	     | mpw* | magic* | mmixware* | mon960* | lnews* \
+	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
+	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
+	     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \
+	     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \
+	     | mirbsd* | netbsd* | dicos* | openedition* | ose* \
+	     | bitrig* | openbsd* | secbsd* | solidbsd* | libertybsd* | os108* \
+	     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \
+	     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \
+	     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \
+	     | udi* | lites* | ieee* | go32* | aux* | hcos* \
+	     | chorusrdb* | cegcc* | glidix* | serenity* \
+	     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \
+	     | midipix* | mingw32* | mingw64* | mint* \
+	     | uxpv* | beos* | mpeix* | udk* | moxiebox* \
+	     | interix* | uwin* | mks* | rhapsody* | darwin* \
+	     | openstep* | oskit* | conix* | pw32* | nonstopux* \
+	     | storm-chaos* | tops10* | tenex* | tops20* | its* \
+	     | os2* | vos* | palmos* | uclinux* | nucleus* | morphos* \
+	     | scout* | superux* | sysv* | rtmk* | tpf* | windiss* \
+	     | powermax* | dnix* | nx6 | nx7 | sei* | dragonfly* \
+	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
+	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
+	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
+	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \
+	     | fiwix* | mlibc* )
+		;;
+	# This one is extra strict with allowed versions
+	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		;;
+	none)
+		;;
+	kernel* )
+		# Restricted further below
+		;;
+	*)
+		echo Invalid configuration \`"$1"\': OS \`"$os"\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# As a final step for OS-related things, validate the OS-kernel combination
+# (given a valid OS), if there is a kernel.
+case $kernel-$os in
+	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \
+		   | linux-musl* | linux-relibc* | linux-uclibc* | linux-mlibc* )
+		;;
+	uclinux-uclibc* )
+		;;
+	managarm-mlibc* | managarm-kernel* )
+		;;
+	-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* | -mlibc* )
+		# These are just libc implementations, not actual OSes, and thus
+		# require a kernel.
+		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	-kernel* )
+		echo "Invalid configuration \`$1': \`$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	*-kernel* )
+		echo "Invalid configuration \`$1': \`$kernel' does not support \`$os'." 1>&2
+		exit 1
+		;;
+	kfreebsd*-gnu* | kopensolaris*-gnu*)
+		;;
+	vxworks-simlinux | vxworks-simwindows | vxworks-spe)
+		;;
+	nto-qnx*)
+		;;
+	os2-emx)
+		;;
+	*-eabi* | *-gnueabi*)
+		;;
+	-*)
+		# Blank kernel with real OS is always fine.
+		;;
+	*-*)
+		echo "Invalid configuration \`$1': Kernel \`$kernel' not known to work with OS \`$os'." 1>&2
+		exit 1
+		;;
+esac
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+case $vendor in
+	unknown)
+		case $cpu-$os in
+			*-riscix*)
+				vendor=acorn
+				;;
+			*-sunos*)
+				vendor=sun
+				;;
+			*-cnk* | *-aix*)
+				vendor=ibm
+				;;
+			*-beos*)
+				vendor=be
+				;;
+			*-hpux*)
+				vendor=hp
+				;;
+			*-mpeix*)
+				vendor=hp
+				;;
+			*-hiux*)
+				vendor=hitachi
+				;;
+			*-unos*)
+				vendor=crds
+				;;
+			*-dgux*)
+				vendor=dg
+				;;
+			*-luna*)
+				vendor=omron
+				;;
+			*-genix*)
+				vendor=ns
+				;;
+			*-clix*)
+				vendor=intergraph
+				;;
+			*-mvs* | *-opened*)
+				vendor=ibm
+				;;
+			*-os400*)
+				vendor=ibm
+				;;
+			s390-* | s390x-*)
+				vendor=ibm
+				;;
+			*-ptx*)
+				vendor=sequent
+				;;
+			*-tpf*)
+				vendor=ibm
+				;;
+			*-vxsim* | *-vxworks* | *-windiss*)
+				vendor=wrs
+				;;
+			*-aux*)
+				vendor=apple
+				;;
+			*-hms*)
+				vendor=hitachi
+				;;
+			*-mpw* | *-macos*)
+				vendor=apple
+				;;
+			*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)
+				vendor=atari
+				;;
+			*-vos*)
+				vendor=stratus
+				;;
+		esac
+		;;
+esac
+
+echo "$cpu-$vendor-${kernel:+$kernel-}$os"
+exit
+
+# Local variables:
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
-- 
2.37.3

