From 3864b4785cbf7cafecfdb7dc82b854ca14a7735a Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Fri, 19 Jun 2020 21:33:30 +1000
Subject: Add Haiku support


diff --git a/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp b/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp
index 8e93a7e..0d4c02d 100644
--- a/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp
+++ b/Source/JavaScriptCore/dfg/DFGByteCodeParser.cpp
@@ -4397,7 +4397,7 @@ bool ByteCodeParser::parseBlock(unsigned limit)
                     nodeType = GetGlobalVar;
                 else
                     nodeType = GetGlobalLexicalVariable;
-                Node* value = addToGraph(nodeType, OpInfo(operand), OpInfo(prediction));
+                Node* value = addToGraph(nodeType, OpInfo((void*)operand), OpInfo(prediction));
                 if (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks)
                     addToGraph(CheckNotEmpty, value);
                 set(VirtualRegister(dst), value);
@@ -4427,7 +4427,7 @@ bool ByteCodeParser::parseBlock(unsigned limit)
                 }
                 SpeculatedType prediction = getPrediction();
                 set(VirtualRegister(dst),
-                    addToGraph(GetClosureVar, OpInfo(operand), OpInfo(prediction), scopeNode));
+                    addToGraph(GetClosureVar, OpInfo((void*)operand), OpInfo(prediction), scopeNode));
                 break;
             }
             case UnresolvedProperty:
@@ -4500,7 +4500,7 @@ bool ByteCodeParser::parseBlock(unsigned limit)
             case GlobalVarWithVarInjectionChecks: {
                 if (getPutInfo.initializationMode() != Initialization && (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks)) {
                     SpeculatedType prediction = SpecEmpty;
-                    Node* value = addToGraph(GetGlobalLexicalVariable, OpInfo(operand), OpInfo(prediction));
+                    Node* value = addToGraph(GetGlobalLexicalVariable, OpInfo((void*)operand), OpInfo(prediction));
                     addToGraph(CheckNotEmpty, value);
                 }
 
@@ -4510,7 +4510,7 @@ bool ByteCodeParser::parseBlock(unsigned limit)
                     ASSERT_UNUSED(entry, watchpoints == entry.watchpointSet());
                 }
                 Node* valueNode = get(VirtualRegister(value));
-                addToGraph(PutGlobalVariable, OpInfo(operand), weakJSConstant(scopeObject), valueNode);
+                addToGraph(PutGlobalVariable, OpInfo((void*)operand), weakJSConstant(scopeObject), valueNode);
                 if (watchpoints && watchpoints->state() != IsInvalidated) {
                     // Must happen after the store. See comment for GetGlobalVar.
                     addToGraph(NotifyWrite, OpInfo(watchpoints));
@@ -4525,7 +4525,7 @@ bool ByteCodeParser::parseBlock(unsigned limit)
                 Node* scopeNode = get(VirtualRegister(scope));
                 Node* valueNode = get(VirtualRegister(value));
 
-                addToGraph(PutClosureVar, OpInfo(operand), scopeNode, valueNode);
+                addToGraph(PutClosureVar, OpInfo((void*)operand), scopeNode, valueNode);
 
                 if (watchpoints && watchpoints->state() != IsInvalidated) {
                     // Must happen after the store. See comment for GetGlobalVar.
diff --git a/Source/JavaScriptCore/heap/HeapStatistics.cpp b/Source/JavaScriptCore/heap/HeapStatistics.cpp
index 12d12ce..15ed177 100644
--- a/Source/JavaScriptCore/heap/HeapStatistics.cpp
+++ b/Source/JavaScriptCore/heap/HeapStatistics.cpp
@@ -47,7 +47,7 @@ double HeapStatistics::s_endTime = 0.0;
 Vector<double>* HeapStatistics::s_pauseTimeStarts = 0;
 Vector<double>* HeapStatistics::s_pauseTimeEnds = 0;
 
-#if OS(UNIX) 
+#if OS(UNIX) && !OS(HAIKU)
 
 void HeapStatistics::initialize()
 {
diff --git a/Source/JavaScriptCore/heap/MachineStackMarker.cpp b/Source/JavaScriptCore/heap/MachineStackMarker.cpp
index 883914f..63fdb56 100644
--- a/Source/JavaScriptCore/heap/MachineStackMarker.cpp
+++ b/Source/JavaScriptCore/heap/MachineStackMarker.cpp
@@ -62,6 +62,12 @@
 #include <pthread_np.h>
 #endif
 
+#if OS(HAIKU)
+extern "C" {
+	int pthread_attr_get_np(pthread_t thread, pthread_attr_t *_attr);
+}
+#endif
+
 #if USE(PTHREADS) && !OS(WINDOWS) && !OS(DARWIN)
 #include <signal.h>
 
@@ -483,7 +489,7 @@ size_t MachineThreads::Thread::getRegisters(Thread::Registers& registers)
     return sizeof(CONTEXT);
 #elif USE(PTHREADS)
     pthread_attr_init(&regs.attribute);
-#if HAVE(PTHREAD_NP_H) || OS(NETBSD)
+#if HAVE(PTHREAD_NP_H) || OS(NETBSD) || OS(HAIKU)
 #if !OS(OPENBSD)
     // e.g. on FreeBSD 5.4, neundorf@kde.org
     pthread_attr_get_np(platformThread, &regs.attribute);
diff --git a/Source/JavaScriptCore/heap/MachineStackMarker.h b/Source/JavaScriptCore/heap/MachineStackMarker.h
index a16f0da..1591989 100644
--- a/Source/JavaScriptCore/heap/MachineStackMarker.h
+++ b/Source/JavaScriptCore/heap/MachineStackMarker.h
@@ -31,6 +31,7 @@
 #include <mach/thread_act.h>
 #endif
 
+
 #if USE(PTHREADS) && !OS(WINDOWS) && !OS(DARWIN)
 #include <semaphore.h>
 #include <signal.h>
diff --git a/Source/ThirdParty/ANGLE/src/common/platform.h b/Source/ThirdParty/ANGLE/src/common/platform.h
index 56db297..c98bfdd 100644
--- a/Source/ThirdParty/ANGLE/src/common/platform.h
+++ b/Source/ThirdParty/ANGLE/src/common/platform.h
@@ -26,6 +26,7 @@
       defined(__DragonFly__) || \
       defined(__sun) || \
       defined(__GLIBC__) || \
+      defined(__HAIKU__) || \
       defined(__GNU__) || \
       defined(__QNX__)
 #   define ANGLE_PLATFORM_POSIX 1
diff --git a/Source/ThirdParty/gtest/include/gtest/internal/gtest-port.h b/Source/ThirdParty/gtest/include/gtest/internal/gtest-port.h
index e8c6ae0..d72dee9 100644
--- a/Source/ThirdParty/gtest/include/gtest/internal/gtest-port.h
+++ b/Source/ThirdParty/gtest/include/gtest/internal/gtest-port.h
@@ -223,7 +223,7 @@
 #define GTEST_OS_LINUX 1
 #elif defined __GNU__
 #define GTEST_OS_HURD 1
-#elif defined(__FreeBSD__) || defined(__DragonFly__) || defined(__FreeBSD_kernel__)
+#elif defined(__FreeBSD__) || defined(__DragonFly__) || defined(__FreeBSD_kernel__) || defined(__HAIKU__)
 #define GTEST_OS_FREEBSD 1
 #elif defined __MVS__
 #define GTEST_OS_ZOS 1
diff --git a/Source/WTF/wtf/DateMath.cpp b/Source/WTF/wtf/DateMath.cpp
index 80086b3..836da0f 100644
--- a/Source/WTF/wtf/DateMath.cpp
+++ b/Source/WTF/wtf/DateMath.cpp
@@ -432,7 +432,7 @@ static int32_t calculateUTCOffset()
     localt.tm_zone = 0;
 #endif
 
-#if HAVE(TIMEGM)
+#if HAVE(TIMEGM) && !OS(HAIKU)
     time_t utcOffset = timegm(&localt) - mktime(&localt);
 #else
     // Using a canned date of 01/01/2009 on platforms with weaker date-handling foo.
diff --git a/Source/WTF/wtf/InlineASM.h b/Source/WTF/wtf/InlineASM.h
index 965e281..b2129b1 100644
--- a/Source/WTF/wtf/InlineASM.h
+++ b/Source/WTF/wtf/InlineASM.h
@@ -40,7 +40,7 @@
 #define THUMB_FUNC_PARAM(name)
 #endif
 
-#if (OS(LINUX) || OS(FREEBSD)) && CPU(X86_64)
+#if (OS(LINUX) || OS(FREEBSD) || OS(HAIKU)) && CPU(X86_64)
 #define GLOBAL_REFERENCE(name) #name "@plt"
 #elif CPU(X86) && COMPILER(MINGW)
 #define GLOBAL_REFERENCE(name) "@" #name "@4"
@@ -82,6 +82,7 @@
 #elif   OS(LINUX)               \
     || OS(FREEBSD)             \
     || OS(OPENBSD)             \
+    || OS(HAIKU)               \
     || OS(HURD)                \
     || OS(NETBSD)              \
     || COMPILER(MINGW)
diff --git a/Source/WTF/wtf/Platform.h b/Source/WTF/wtf/Platform.h
index 7aefa1b..7f97654 100644
--- a/Source/WTF/wtf/Platform.h
+++ b/Source/WTF/wtf/Platform.h
@@ -405,6 +405,11 @@
 #define WTF_OS_NETBSD 1
 #endif
 
+/* OS(HAIKU) - Haiku  */
+#if defined(__HAIKU__)
+#define WTF_OS_HAIKU 1
+#endif
+
 /* OS(OPENBSD) - OpenBSD */
 #ifdef __OpenBSD__
 #define WTF_OS_OPENBSD 1
@@ -430,6 +435,7 @@
     || OS(HURD)             \
     || OS(LINUX)            \
     || OS(NETBSD)           \
+    || OS(HAIKU)           \
     || OS(OPENBSD)          \
     || OS(SOLARIS)          \
     || defined(unix)        \
diff --git a/Source/WTF/wtf/ProcessID.h b/Source/WTF/wtf/ProcessID.h
index f84716e..ca7c266 100644
--- a/Source/WTF/wtf/ProcessID.h
+++ b/Source/WTF/wtf/ProcessID.h
@@ -41,7 +41,7 @@ inline int getCurrentProcessID()
 #if OS(WINDOWS)
     return GetCurrentProcessId();
 #else
-    return getpid();
+    return ::getpid();
 #endif
 }
 
diff --git a/Source/WTF/wtf/StackBounds.cpp b/Source/WTF/wtf/StackBounds.cpp
index f308ac1..2cde905 100644
--- a/Source/WTF/wtf/StackBounds.cpp
+++ b/Source/WTF/wtf/StackBounds.cpp
@@ -42,6 +42,12 @@
 #include <pthread_np.h>
 #endif
 
+#if OS(HAIKU)
+extern "C" {
+	int pthread_attr_get_np(pthread_t thread, pthread_attr_t *_attr);
+}
+#endif
+
 #endif
 
 namespace WTF {
@@ -100,7 +106,7 @@ void StackBounds::initialize()
     pthread_t thread = pthread_self();
     pthread_attr_t sattr;
     pthread_attr_init(&sattr);
-#if HAVE(PTHREAD_NP_H) || OS(NETBSD)
+#if HAVE(PTHREAD_NP_H) || OS(NETBSD) || OS(HAIKU)
     // e.g. on FreeBSD 5.4, neundorf@kde.org
     pthread_attr_get_np(thread, &sattr);
 #else
diff --git a/Source/WebCore/PlatformQt.cmake b/Source/WebCore/PlatformQt.cmake
index 99c625d..2e235f4 100644
--- a/Source/WebCore/PlatformQt.cmake
+++ b/Source/WebCore/PlatformQt.cmake
@@ -79,7 +79,8 @@ list(APPEND WebCore_SOURCES
 
     platform/audio/qt/AudioBusQt.cpp
 
-    platform/crypto/qt/CryptoDigestQt.cpp
+#    platform/crypto/qt/CryptoDigestQt.cpp
+    platform/crypto/gnutls/CryptoDigestGnuTLS.cpp
 
     platform/graphics/ImageSource.cpp
     platform/graphics/PlatformDisplay.cpp
@@ -260,6 +261,52 @@ if (ENABLE_SMOOTH_SCROLLING)
     )
 endif ()
 
+if (ENABLE_SUBTLE_CRYPTO)
+    list(APPEND WebCore_SOURCES
+        crypto/CryptoAlgorithm.cpp
+        crypto/CryptoAlgorithmDescriptionBuilder.cpp
+        crypto/CryptoAlgorithmRegistry.cpp
+        crypto/CryptoKey.cpp
+        crypto/CryptoKeyPair.cpp
+        crypto/SubtleCrypto.cpp
+
+        crypto/algorithms/CryptoAlgorithmAES_CBC.cpp
+        crypto/algorithms/CryptoAlgorithmAES_KW.cpp
+        crypto/algorithms/CryptoAlgorithmHMAC.cpp
+        crypto/algorithms/CryptoAlgorithmRSAES_PKCS1_v1_5.cpp
+        crypto/algorithms/CryptoAlgorithmRSASSA_PKCS1_v1_5.cpp
+        crypto/algorithms/CryptoAlgorithmRSA_OAEP.cpp
+        crypto/algorithms/CryptoAlgorithmSHA1.cpp
+        crypto/algorithms/CryptoAlgorithmSHA224.cpp
+        crypto/algorithms/CryptoAlgorithmSHA256.cpp
+        crypto/algorithms/CryptoAlgorithmSHA384.cpp
+        crypto/algorithms/CryptoAlgorithmSHA512.cpp
+
+        crypto/gnutls/CryptoAlgorithmAES_CBCGnuTLS.cpp
+        crypto/gnutls/CryptoAlgorithmAES_KWGnuTLS.cpp
+        crypto/gnutls/CryptoAlgorithmHMACGnuTLS.cpp
+        crypto/gnutls/CryptoAlgorithmRSAES_PKCS1_v1_5GnuTLS.cpp
+        crypto/gnutls/CryptoAlgorithmRSASSA_PKCS1_v1_5GnuTLS.cpp
+        crypto/gnutls/CryptoAlgorithmRSA_OAEPGnuTLS.cpp
+        crypto/gnutls/CryptoAlgorithmRegistryGnuTLS.cpp
+        crypto/gnutls/CryptoKeyRSAGnuTLS.cpp
+        crypto/gnutls/SerializedCryptoKeyWrapGnuTLS.cpp
+
+        crypto/keys/CryptoKeyAES.cpp
+        crypto/keys/CryptoKeyDataOctetSequence.cpp
+        crypto/keys/CryptoKeyDataRSAComponents.cpp
+        crypto/keys/CryptoKeyHMAC.cpp
+        crypto/keys/CryptoKeySerializationRaw.cpp
+    )
+
+    list(APPEND WebCore_SYSTEM_INCLUDE_DIRECTORIES
+        ${GNUTLS_INCLUDE_DIRS}
+    )
+    list(APPEND WebCore_LIBRARIES
+        ${GNUTLS_LIBRARIES}
+    )
+endif ()
+
 # Do it in the WebCore to support SHARED_CORE since WebKitWidgets won't load WebKit in that case.
 # This should match the opposite statement in WebKit/PlatformQt.cmake
 if (SHARED_CORE)
diff --git a/Source/WebCore/bindings/js/JSMediaStreamTrackCustom.cpp b/Source/WebCore/bindings/js/JSMediaStreamTrackCustom.cpp
index 55154b8..24481e6 100644
--- a/Source/WebCore/bindings/js/JSMediaStreamTrackCustom.cpp
+++ b/Source/WebCore/bindings/js/JSMediaStreamTrackCustom.cpp
@@ -127,7 +127,7 @@ JSC::JSValue JSMediaStreamTrack::getCapabilities(ExecState& state)
             facingModes.reserveCapacity(modes.size());
 
             for (auto& mode : modes)
-                facingModes.append(RealtimeMediaSourceSettings::facingMode(mode));
+                facingModes.append(QString(RealtimeMediaSourceSettings::facingMode(mode)));
         }
 
         object->putDirect(state.vm(), Identifier::fromString(&state, "facingMode"), jsArray(&state, castedThis->globalObject(), facingModes), DontDelete | ReadOnly);
diff --git a/Source/WebCore/crypto/CryptoKey.cpp b/Source/WebCore/crypto/CryptoKey.cpp
index 53d1c1e..99a90e2 100644
--- a/Source/WebCore/crypto/CryptoKey.cpp
+++ b/Source/WebCore/crypto/CryptoKey.cpp
@@ -91,7 +91,7 @@ Vector<String> CryptoKey::usages() const
     return result;
 }
 
-#if !OS(DARWIN) || PLATFORM(EFL) || PLATFORM(GTK)
+#if !OS(DARWIN) || PLATFORM(EFL) || PLATFORM(GTK) || OS(HAIKU)
 Vector<uint8_t> CryptoKey::randomData(size_t size)
 {
     Vector<uint8_t> result(size);
diff --git a/Source/WebCore/crypto/gnutls/CryptoAlgorithmAES_CBCGnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoAlgorithmAES_CBCGnuTLS.cpp
new file mode 100644
index 0000000..c287650
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoAlgorithmAES_CBCGnuTLS.cpp
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoAlgorithmAES_CBC.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoAlgorithmAesCbcParams.h"
+#include "CryptoKeyAES.h"
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
+
+namespace WebCore {
+	
+enum {
+    CryptoNoErr = 0,
+    CryptoDataErr,
+    CryptoNotSupportedErr,
+    CryptoInvalidAccessErr,
+    CryptoTypeMismatchErr,
+    CryptoExceededQuotaErr,
+    CryptoSyntaxErr,
+    CryptoOperationErr
+};
+
+static gnutls_cipher_hd_t createCipher(const CryptoAlgorithmAesCbcParams& parameters, const CryptoKeyAES& key, gnutls_cipher_algorithm_t algorithm)
+{
+    ASSERT(sizeof(parameters.iv) == gnutls_cipher_get_iv_size(algorithm));
+
+    size_t keyLengthInBytes = key.key().size();
+    if (keyLengthInBytes != 16 && keyLengthInBytes != 24 && keyLengthInBytes != 32)
+        return 0;
+
+    gnutls_datum_t gnutlsKey;
+    gnutlsKey.data = const_cast<unsigned char*>(key.key().data());
+    gnutlsKey.size = keyLengthInBytes;
+
+    gnutls_datum_t gnutlsIv;
+    gnutlsIv.data = const_cast<unsigned char *>(reinterpret_cast<const unsigned char*>(parameters.iv.data()));
+    gnutlsIv.size = sizeof(parameters.iv);
+
+    gnutls_cipher_hd_t cipher;
+    int ret = gnutls_cipher_init(&cipher, algorithm, &gnutlsKey, &gnutlsIv);
+    if (ret != GNUTLS_E_SUCCESS)
+        return 0;
+
+    return cipher;
+}
+
+void CryptoAlgorithmAES_CBC::platformEncrypt(const CryptoAlgorithmAesCbcParams& parameters, const CryptoKeyAES& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    // in this context, AES_256_CBC is a valid algorithm also for 128 and 192
+    gnutls_cipher_algorithm_t algorithm = GNUTLS_CIPHER_AES_128_CBC;
+
+    gnutls_cipher_hd_t cipher = createCipher(parameters, key, algorithm);
+    if (!cipher) {
+        ec = CryptoDataErr;
+        failureCallback();
+        return;
+    }
+
+    uint8_t blockSize = gnutls_cipher_get_block_size(algorithm);
+    size_t dataSize = data.second;
+
+    uint8_t paddingSize = blockSize - (dataSize % blockSize);
+    size_t paddedSize = (dataSize / blockSize) * blockSize;
+    size_t cipherTextSize = paddedSize + blockSize;
+
+    Vector<uint8_t> result(cipherTextSize);
+
+    // Encrypt all data except last unpadded octets
+    int ret;
+    if (paddedSize > 0) {
+        ret = gnutls_cipher_encrypt2(cipher, (void *) data.first, paddedSize, (void *) result.data(), paddedSize);
+        if (ret != GNUTLS_E_SUCCESS) {
+            gnutls_cipher_deinit(cipher);
+            ec = CryptoOperationErr;
+            failureCallback();
+            return;
+        }
+    }
+
+    // Add PKCS7 padding <http://tools.ietf.org/html/rfc5652#section-6.3>
+    // and encrypt last block
+    memcpy(result.data() + paddedSize, data.first + paddedSize, blockSize - paddingSize);
+    memset(result.data() + cipherTextSize - paddingSize, paddingSize, paddingSize);
+
+    // Encrypt last block with padding
+    ret = gnutls_cipher_encrypt2(cipher, result.data() + paddedSize, blockSize, (void *) (result.data() + paddedSize), blockSize);
+    if (ret != GNUTLS_E_SUCCESS) {
+        gnutls_cipher_deinit(cipher);
+            ec = CryptoOperationErr;
+        failureCallback();
+        return;
+    }
+
+    gnutls_cipher_deinit(cipher);
+    callback(result);
+}
+
+void CryptoAlgorithmAES_CBC::platformDecrypt(const CryptoAlgorithmAesCbcParams& parameters, const CryptoKeyAES& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    // in this context, AES_256_CBC is a valid algorithm also for 128 and 192
+    gnutls_cipher_algorithm_t algorithm = GNUTLS_CIPHER_AES_128_CBC;
+
+    gnutls_cipher_hd_t cipher = createCipher(parameters, key, algorithm);
+    if (!cipher) {
+        ec = CryptoDataErr;
+        failureCallback();
+        return;
+    }
+
+    Vector<uint8_t> result(data.second);
+    int ret = gnutls_cipher_decrypt2(cipher, data.first, data.second, (void *) result.data(), result.size());
+    if (ret != GNUTLS_E_SUCCESS) {
+        gnutls_cipher_deinit(cipher);
+        ec = CryptoOperationErr;
+        failureCallback();
+        return;
+    }
+
+    // Remove PKCS7 padding <http://tools.ietf.org/html/rfc5652#section-6.3>
+    size_t dataSize = result.size();
+    uint8_t blockSize = gnutls_cipher_get_block_size(algorithm);
+    uint8_t paddingSize = result.data() [dataSize - 1];
+    if (!paddingSize || paddingSize > blockSize) {
+        gnutls_cipher_deinit(cipher);
+        ec = CryptoDataErr;
+        failureCallback();
+        return;
+    }
+    // Check sanity of the whole padding
+    for (int i = 1; i < paddingSize; i++) {
+        if (result.data() [dataSize - i] != paddingSize) {
+            gnutls_cipher_deinit(cipher);
+            ec = CryptoDataErr;
+            failureCallback();
+            return;
+        }
+    }
+
+    result.shrink(dataSize - paddingSize);
+
+    gnutls_cipher_deinit(cipher);
+    callback(result);
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/CryptoAlgorithmAES_KWGnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoAlgorithmAES_KWGnuTLS.cpp
new file mode 100644
index 0000000..cf7bf95
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoAlgorithmAES_KWGnuTLS.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoAlgorithmAES_KW.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoKeyAES.h"
+#include "ExceptionCode.h"
+#include "NotImplemented.h"
+
+namespace WebCore {
+
+void CryptoAlgorithmAES_KW::platformEncrypt(const CryptoKeyAES& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+}
+
+void CryptoAlgorithmAES_KW::platformDecrypt(const CryptoKeyAES& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/CryptoAlgorithmHMACGnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoAlgorithmHMACGnuTLS.cpp
new file mode 100644
index 0000000..cc98561
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoAlgorithmHMACGnuTLS.cpp
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoAlgorithmHMAC.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoAlgorithmHmacParams.h"
+#include "CryptoKeyHMAC.h"
+#include "ExceptionCode.h"
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
+#include <wtf/CryptographicUtilities.h>
+
+namespace WebCore {
+
+static gnutls_mac_algorithm_t getGnutlsDigestAlgorithm(CryptoAlgorithmIdentifier hashFunction)
+{
+    switch (hashFunction) {
+    case CryptoAlgorithmIdentifier::SHA_1:
+        return GNUTLS_MAC_SHA1;
+    case CryptoAlgorithmIdentifier::SHA_224:
+        return GNUTLS_MAC_SHA224;
+    case CryptoAlgorithmIdentifier::SHA_256:
+        return GNUTLS_MAC_SHA256;
+    case CryptoAlgorithmIdentifier::SHA_384:
+        return GNUTLS_MAC_SHA384;
+    case CryptoAlgorithmIdentifier::SHA_512:
+        return GNUTLS_MAC_SHA512;
+    default:
+        return GNUTLS_MAC_UNKNOWN;
+    }
+}
+
+static Vector<uint8_t> calculateSignature(gnutls_mac_algorithm_t algorithm, const Vector<uint8_t>& key, const CryptoOperationData& data)
+{
+    size_t digestLength = gnutls_hmac_get_len(algorithm);
+
+    Vector<uint8_t> result(digestLength);
+    const void* keyData = key.data() ? key.data() : reinterpret_cast<const uint8_t*>("");
+    int ret = gnutls_hmac_fast(algorithm, keyData, key.size(), data.first, data.second, result.data());
+    ASSERT(ret == GNUTLS_E_SUCCESS);
+    UNUSED_PARAM(ret);
+
+    return result;
+}
+
+void CryptoAlgorithmHMAC::platformSign(const CryptoAlgorithmHmacParams& parameters, const CryptoKeyHMAC& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    gnutls_mac_algorithm_t algorithm = getGnutlsDigestAlgorithm(parameters.hash);
+    if (algorithm == GNUTLS_MAC_UNKNOWN) {
+        ec = NOT_SUPPORTED_ERR;
+        failureCallback();
+        return;
+    }
+
+    Vector<uint8_t> signature = calculateSignature(algorithm, key.key(), data);
+
+    callback(signature);
+}
+
+void CryptoAlgorithmHMAC::platformVerify(const CryptoAlgorithmHmacParams& parameters, const CryptoKeyHMAC& key, const CryptoOperationData& expectedSignature, const CryptoOperationData& data, BoolCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    gnutls_mac_algorithm_t algorithm = getGnutlsDigestAlgorithm(parameters.hash);
+    if (algorithm == GNUTLS_MAC_UNKNOWN) {
+        ec = NOT_SUPPORTED_ERR;
+        failureCallback();
+        return;
+    }
+
+    Vector<uint8_t> signature = calculateSignature(algorithm, key.key(), data);
+
+    // Using a constant time comparison to prevent timing attacks.
+    bool result = signature.size() == expectedSignature.second && !constantTimeMemcmp(signature.data(), expectedSignature.first, signature.size());
+
+    callback(result);
+}
+
+}
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSAES_PKCS1_v1_5GnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSAES_PKCS1_v1_5GnuTLS.cpp
new file mode 100644
index 0000000..fbfe1c4
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSAES_PKCS1_v1_5GnuTLS.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoAlgorithmRSAES_PKCS1_v1_5.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoKeyRSA.h"
+#include "ExceptionCode.h"
+#include "NotImplemented.h"
+
+namespace WebCore {
+
+void CryptoAlgorithmRSAES_PKCS1_v1_5::platformEncrypt(const CryptoKeyRSA& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+}
+
+void CryptoAlgorithmRSAES_PKCS1_v1_5::platformDecrypt(const CryptoKeyRSA& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSASSA_PKCS1_v1_5GnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSASSA_PKCS1_v1_5GnuTLS.cpp
new file mode 100644
index 0000000..3e606bc
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSASSA_PKCS1_v1_5GnuTLS.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoAlgorithmRSASSA_PKCS1_v1_5.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoAlgorithmRsaSsaParams.h"
+#include "CryptoKeyRSA.h"
+#include "ExceptionCode.h"
+#include "NotImplemented.h"
+
+namespace WebCore {
+
+void CryptoAlgorithmRSASSA_PKCS1_v1_5::platformSign(const CryptoAlgorithmRsaSsaParams& parameters, const CryptoKeyRSA& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(parameters);
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+    UNUSED_PARAM(ec);
+}
+
+void CryptoAlgorithmRSASSA_PKCS1_v1_5::platformVerify(const CryptoAlgorithmRsaSsaParams& parameters, const CryptoKeyRSA& key, const CryptoOperationData& signature, const CryptoOperationData& data, BoolCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(parameters);
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(signature);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+    UNUSED_PARAM(ec);
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSA_OAEPGnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSA_OAEPGnuTLS.cpp
new file mode 100644
index 0000000..5e5b436
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRSA_OAEPGnuTLS.cpp
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoAlgorithmRSA_OAEP.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoAlgorithmRsaOaepParams.h"
+#include "CryptoKeyRSA.h"
+#include "ExceptionCode.h"
+#include "NotImplemented.h"
+
+namespace WebCore {
+
+void CryptoAlgorithmRSA_OAEP::platformEncrypt(const CryptoAlgorithmRsaOaepParams& parameters, const CryptoKeyRSA& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(parameters);
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+}
+
+void CryptoAlgorithmRSA_OAEP::platformDecrypt(const CryptoAlgorithmRsaOaepParams& parameters, const CryptoKeyRSA& key, const CryptoOperationData& data, VectorCallback&& callback, VoidCallback&& failureCallback, ExceptionCode& ec)
+{
+    notImplemented();
+    ec = NOT_SUPPORTED_ERR;
+    failureCallback();
+
+    UNUSED_PARAM(parameters);
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(callback);
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/CryptoAlgorithmRegistryGnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRegistryGnuTLS.cpp
new file mode 100644
index 0000000..34cbf9d
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoAlgorithmRegistryGnuTLS.cpp
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoAlgorithmRegistry.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoAlgorithmAES_CBC.h"
+#include "CryptoAlgorithmAES_KW.h"
+#include "CryptoAlgorithmHMAC.h"
+#include "CryptoAlgorithmRSAES_PKCS1_v1_5.h"
+#include "CryptoAlgorithmRSASSA_PKCS1_v1_5.h"
+#include "CryptoAlgorithmRSA_OAEP.h"
+#include "CryptoAlgorithmSHA1.h"
+#include "CryptoAlgorithmSHA224.h"
+#include "CryptoAlgorithmSHA256.h"
+#include "CryptoAlgorithmSHA384.h"
+#include "CryptoAlgorithmSHA512.h"
+
+namespace WebCore {
+
+void CryptoAlgorithmRegistry::platformRegisterAlgorithms()
+{
+    registerAlgorithm<CryptoAlgorithmAES_CBC>();
+    registerAlgorithm<CryptoAlgorithmAES_KW>();
+    registerAlgorithm<CryptoAlgorithmHMAC>();
+    registerAlgorithm<CryptoAlgorithmRSAES_PKCS1_v1_5>();
+    registerAlgorithm<CryptoAlgorithmRSASSA_PKCS1_v1_5>();
+    registerAlgorithm<CryptoAlgorithmRSA_OAEP>();
+    registerAlgorithm<CryptoAlgorithmSHA1>();
+    registerAlgorithm<CryptoAlgorithmSHA224>();
+    registerAlgorithm<CryptoAlgorithmSHA256>();
+    registerAlgorithm<CryptoAlgorithmSHA384>();
+    registerAlgorithm<CryptoAlgorithmSHA512>();
+}
+
+}
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/CryptoKeyRSAGnuTLS.cpp b/Source/WebCore/crypto/gnutls/CryptoKeyRSAGnuTLS.cpp
new file mode 100644
index 0000000..d7045a5
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/CryptoKeyRSAGnuTLS.cpp
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoKeyRSA.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "CryptoAlgorithmDescriptionBuilder.h"
+#include "CryptoAlgorithmRegistry.h"
+#include "CryptoKeyDataRSAComponents.h"
+#include "CryptoKeyPair.h"
+#include "NotImplemented.h"
+
+namespace WebCore {
+
+struct _PlatformRSAKeyGnuTLS {
+};
+
+CryptoKeyRSA::CryptoKeyRSA(CryptoAlgorithmIdentifier identifier, CryptoAlgorithmIdentifier hash, bool hasHash, CryptoKeyType type, PlatformRSAKey platformKey, bool extractable, CryptoKeyUsage usage)
+    : CryptoKey(identifier, type, extractable, usage)
+    , m_platformKey(platformKey)
+    , m_restrictedToSpecificHash(hasHash)
+    , m_hash(hash)
+{
+    notImplemented();
+}
+
+RefPtr<CryptoKeyRSA> CryptoKeyRSA::create(CryptoAlgorithmIdentifier identifier, CryptoAlgorithmIdentifier hash, bool hasHash, const CryptoKeyDataRSAComponents& keyData, bool extractable, CryptoKeyUsage usage)
+{
+    notImplemented();
+    UNUSED_PARAM(identifier);
+    UNUSED_PARAM(hash);
+    UNUSED_PARAM(hasHash);
+    UNUSED_PARAM(keyData);
+    UNUSED_PARAM(extractable);
+    UNUSED_PARAM(usage);
+
+    return nullptr;
+}
+
+CryptoKeyRSA::~CryptoKeyRSA()
+{
+    notImplemented();
+}
+
+bool CryptoKeyRSA::isRestrictedToHash(CryptoAlgorithmIdentifier& identifier) const
+{
+    if (!m_restrictedToSpecificHash)
+        return false;
+
+    identifier = m_hash;
+    return true;
+}
+
+size_t CryptoKeyRSA::keySizeInBits() const
+{
+    notImplemented();
+    return 0;
+}
+
+void CryptoKeyRSA::buildAlgorithmDescription(CryptoAlgorithmDescriptionBuilder& builder) const
+{
+    notImplemented();
+    UNUSED_PARAM(builder);
+}
+
+std::unique_ptr<CryptoKeyData> CryptoKeyRSA::exportData() const
+{
+    ASSERT(extractable());
+
+    notImplemented();
+    return nullptr;
+}
+
+void CryptoKeyRSA::generatePair(CryptoAlgorithmIdentifier algorithm, CryptoAlgorithmIdentifier hash, bool hasHash, unsigned modulusLength, const Vector<uint8_t>& publicExponent, bool extractable, CryptoKeyUsage usage, KeyPairCallback callback, VoidCallback failureCallback)
+{
+    notImplemented();
+    failureCallback();
+
+    UNUSED_PARAM(algorithm);
+    UNUSED_PARAM(hash);
+    UNUSED_PARAM(hasHash);
+    UNUSED_PARAM(modulusLength);
+    UNUSED_PARAM(publicExponent);
+    UNUSED_PARAM(extractable);
+    UNUSED_PARAM(usage);
+    UNUSED_PARAM(callback);
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/gnutls/SerializedCryptoKeyWrapGnuTLS.cpp b/Source/WebCore/crypto/gnutls/SerializedCryptoKeyWrapGnuTLS.cpp
new file mode 100644
index 0000000..949989f
--- /dev/null
+++ b/Source/WebCore/crypto/gnutls/SerializedCryptoKeyWrapGnuTLS.cpp
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "SerializedCryptoKeyWrap.h"
+
+#if ENABLE(SUBTLE_CRYPTO)
+
+#include "NotImplemented.h"
+
+namespace WebCore {
+
+bool getDefaultWebCryptoMasterKey(Vector<uint8_t>& masterKey)
+{
+    notImplemented();
+    UNUSED_PARAM(masterKey);
+
+    return false;
+}
+
+bool wrapSerializedCryptoKey(const Vector<uint8_t>& masterKey, const Vector<uint8_t>& key, Vector<uint8_t>& result)
+{
+    notImplemented();
+    UNUSED_PARAM(masterKey);
+    UNUSED_PARAM(key);
+    UNUSED_PARAM(result);
+
+    return false;
+}
+
+bool unwrapSerializedCryptoKey(const Vector<uint8_t>& masterKey, const Vector<uint8_t>& wrappedKey, Vector<uint8_t>& key)
+{
+    notImplemented();
+    UNUSED_PARAM(masterKey);
+    UNUSED_PARAM(wrappedKey);
+    UNUSED_PARAM(key);
+
+    return false;
+}
+
+}
+
+#endif // ENABLE(SUBTLE_CRYPTO)
diff --git a/Source/WebCore/crypto/keys/CryptoKeyRSA.h b/Source/WebCore/crypto/keys/CryptoKeyRSA.h
index 17d24a9..dcd2c9e 100644
--- a/Source/WebCore/crypto/keys/CryptoKeyRSA.h
+++ b/Source/WebCore/crypto/keys/CryptoKeyRSA.h
@@ -36,7 +36,7 @@ typedef struct _CCRSACryptor *CCRSACryptorRef;
 typedef CCRSACryptorRef PlatformRSAKey;
 #endif
 
-#if PLATFORM(GTK) || PLATFORM(EFL)
+#if PLATFORM(GTK) || PLATFORM(EFL) || OS(HAIKU)
 typedef struct _PlatformRSAKeyGnuTLS PlatformRSAKeyGnuTLS;
 typedef PlatformRSAKeyGnuTLS *PlatformRSAKey;
 #endif
diff --git a/Source/WebCore/platform/FileSystem.cpp b/Source/WebCore/platform/FileSystem.cpp
index 1db7e03..4d2b532 100644
--- a/Source/WebCore/platform/FileSystem.cpp
+++ b/Source/WebCore/platform/FileSystem.cpp
@@ -149,7 +149,7 @@ bool excludeFromBackup(const String&)
 
 MappedFileData::~MappedFileData()
 {
-#if !OS(WINDOWS)
+#if !OS(WINDOWS) || OS(HAIKU)
     if (!m_fileData)
         return;
     munmap(m_fileData, m_fileSize);
@@ -158,7 +158,7 @@ MappedFileData::~MappedFileData()
 
 MappedFileData::MappedFileData(const String& filePath, bool& success)
 {
-#if OS(WINDOWS)
+#if OS(WINDOWS) || OS(HAIKU)
     // FIXME: Implement mapping
     success = false;
 #else
diff --git a/Source/WebCore/platform/crypto/gnutls/CryptoDigestGnuTLS.cpp b/Source/WebCore/platform/crypto/gnutls/CryptoDigestGnuTLS.cpp
new file mode 100644
index 0000000..89a5d81
--- /dev/null
+++ b/Source/WebCore/platform/crypto/gnutls/CryptoDigestGnuTLS.cpp
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CryptoDigest.h"
+
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
+
+namespace WebCore {
+
+struct CryptoDigestContext {
+    gnutls_digest_algorithm_t algorithm;
+    gnutls_hash_hd_t hash;
+};
+
+CryptoDigest::CryptoDigest()
+    : m_context(new CryptoDigestContext)
+{
+}
+
+CryptoDigest::~CryptoDigest()
+{
+    gnutls_hash_deinit(m_context->hash, 0);
+}
+
+std::unique_ptr<CryptoDigest> CryptoDigest::create(CryptoDigest::Algorithm algorithm)
+{
+    gnutls_digest_algorithm_t gnutlsAlgorithm;
+
+    switch (algorithm) {
+    case CryptoDigest::Algorithm::SHA_1: {
+        gnutlsAlgorithm = GNUTLS_DIG_SHA1;
+        break;
+    }
+    case CryptoDigest::Algorithm::SHA_224: {
+        gnutlsAlgorithm = GNUTLS_DIG_SHA224;
+        break;
+    }
+    case CryptoDigest::Algorithm::SHA_256: {
+        gnutlsAlgorithm = GNUTLS_DIG_SHA256;
+        break;
+    }
+    case CryptoDigest::Algorithm::SHA_384: {
+        gnutlsAlgorithm = GNUTLS_DIG_SHA384;
+        break;
+    }
+    case CryptoDigest::Algorithm::SHA_512: {
+        gnutlsAlgorithm = GNUTLS_DIG_SHA512;
+        break;
+    }
+    }
+
+    std::unique_ptr<CryptoDigest> digest(new CryptoDigest);
+    digest->m_context->algorithm = gnutlsAlgorithm;
+
+    int ret = gnutls_hash_init(&digest->m_context->hash, gnutlsAlgorithm);
+    if (ret != GNUTLS_E_SUCCESS)
+        return nullptr;
+
+    return digest;
+}
+
+void CryptoDigest::addBytes(const void* input, size_t length)
+{
+    gnutls_hash(m_context->hash, input, length);
+}
+
+Vector<uint8_t> CryptoDigest::computeHash()
+{
+    Vector<uint8_t> result;
+    int digestLen = gnutls_hash_get_len(m_context->algorithm);
+    result.resize(digestLen);
+
+    gnutls_hash_output(m_context->hash, result.data());
+
+    return result;
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/platform/qt/UserAgentQt.cpp b/Source/WebCore/platform/qt/UserAgentQt.cpp
index fc5eab7..207f57f 100644
--- a/Source/WebCore/platform/qt/UserAgentQt.cpp
+++ b/Source/WebCore/platform/qt/UserAgentQt.cpp
@@ -62,7 +62,7 @@ String UserAgentQt::standardUserAgent(const String &applicationNameForUserAgent,
 
         // Platform.
         ua = ua.arg(
-#if OS(MAC_OS_X)
+#if OS(MAC_OS_X) || OS(HAIKU)
             QStringLiteral("Macintosh; ")
 #elif OS(WINDOWS)
             QStringLiteral("")
@@ -94,6 +94,12 @@ String UserAgentQt::standardUserAgent(const String &applicationNameForUserAgent,
 
 #elif OS(FREEBSD)
             "FreeBSD"
+#elif OS(HAIKU)
+#if CPU(X86) || CPU(X86_64)
+            "Intel Haiku R1 x86"
+#else
+            "Haiku R1"
+#endif
 #elif OS(HURD)
             "GNU Hurd"
 #elif OS(LINUX)
diff --git a/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp b/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp
index ccd1afb..c096f14 100644
--- a/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp
+++ b/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.cpp
@@ -51,6 +51,82 @@ namespace WebCore {
 
 #if ENABLE(NOTIFICATIONS)
 
+#if defined(Q_OS_HAIKU)
+
+static void appendBlobResolved(QByteArray& data, const QUrl& url, QString* contentType = 0)
+{
+    RefPtr<BlobData> blobData = static_cast<BlobRegistryImpl&>(blobRegistry()).getBlobDataFromURL(url);
+    if (!blobData)
+        return;
+
+    if (contentType)
+        *contentType = blobData->contentType();
+
+    BlobDataItemList::const_iterator it = blobData->items().begin();
+    const BlobDataItemList::const_iterator itend = blobData->items().end();
+    for (; it != itend; ++it) {
+        const BlobDataItem& blobItem = *it;
+        if (blobItem.type() == BlobDataItem::Type::Data)
+            data.append(reinterpret_cast<const char*>(blobItem.data().data()->data()) + static_cast<int>(blobItem.offset()), static_cast<int>(blobItem.length()));
+        else if (blobItem.type() == BlobDataItem::Type::File) {
+            // File types are not allowed here, so just ignore it.
+            RELEASE_ASSERT_WITH_MESSAGE(false, "File types are not allowed here");
+        } else
+            ASSERT_NOT_REACHED();
+    }
+}
+
+static void resolveBlobUrl(const QUrl& url, QUrl& resolvedUrl)
+{
+    RefPtr<BlobData> blobData = static_cast<BlobRegistryImpl&>(blobRegistry()).getBlobDataFromURL(url);
+    if (!blobData)
+        return;
+
+    QByteArray data;
+    QString contentType;
+    appendBlobResolved(data, url, &contentType);
+
+    QString dataUri(QStringLiteral("data:"));
+    dataUri.append(contentType);
+    dataUri.append(QStringLiteral(";base64,"));
+    dataUri.append(QString::fromLatin1(data.toBase64()));
+    resolvedUrl = QUrl(dataUri);
+}
+
+static QImage httpGetImage(QNetworkAccessManager *netMgr, const QUrl& src)
+{
+	QNetworkRequest request;
+	QUrl url = src;
+    if (url.scheme() == QLatin1String("blob"))
+        resolveBlobUrl(src, url);
+	request.setUrl(url);
+	QNetworkReply* reply = netMgr->get(request);
+
+	QEventLoop eventloop;
+    QObject::connect(reply, SIGNAL(finished()), &eventloop, SLOT(quit()));
+    QTimer::singleShot(3000, &eventloop, SLOT(quit()));
+    eventloop.exec();
+
+	QVariant redirectedUrl = reply->attribute(QNetworkRequest::RedirectionTargetAttribute);
+	QUrl redirectedTo = redirectedUrl.toUrl();
+	if (redirectedTo.isValid()) {
+		if (redirectedTo != reply->request().url())
+			return httpGetImage(netMgr, redirectedTo);
+		else
+			return QImage();
+	} else {
+	    if (reply->error() == QNetworkReply::NoError) {
+			QByteArray data = reply->readAll();
+			QImage image = QImage::fromData(data);
+			reply->deleteLater();
+			return image;
+	    }
+	}
+
+    return QImage();
+}
+#endif
+
 const double notificationTimeout = 10.0;
 
 bool NotificationPresenterClientQt::dumpNotification = false;
@@ -218,8 +294,19 @@ void NotificationPresenterClientQt::displayNotification(Notification* notificati
 #ifndef QT_NO_SYSTEMTRAYICON
     wrapper->connect(m_systemTrayIcon.data(), SIGNAL(messageClicked()), wrapper, SLOT(notificationClicked()));
     QMetaObject::invokeMethod(m_systemTrayIcon.data(), "show");
+#if defined(Q_OS_HAIKU)
+	m_netMgr = new QNetworkAccessManager();
+	QImage image = httpGetImage(m_netMgr, notification->iconURL());
+	QIcon icon(QPixmap::fromImage(image).scaled(32, 32));
+	QMetaObject::invokeMethod(m_systemTrayIcon.data(), "showMessage",
+		Q_ARG(QString, notification->title()),
+		Q_ARG(QString, notification->body()),
+		Q_ARG(QIcon, icon));
+    delete m_netMgr;
+#else
     QMetaObject::invokeMethod(m_systemTrayIcon.data(), "showMessage", Q_ARG(QString, notification->title()), Q_ARG(QString, notification->body()));
 #endif
+#endif
 }
 
 void NotificationPresenterClientQt::cancel(Notification* notification)
diff --git a/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.h b/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.h
index f53fe51..9f69a31 100644
--- a/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.h
+++ b/Source/WebKit/qt/WebCoreSupport/NotificationPresenterClientQt.h
@@ -40,6 +40,18 @@
 #include <QMultiHash>
 #include <QScopedPointer>
 
+#if defined(Q_OS_HAIKU)
+#include <QUrl>
+#include <QNetworkAccessManager>
+#include <QNetworkReply>
+#include <QNetworkRequest>
+#include <QEventLoop>
+#include <QTimer>
+
+#include "BlobData.h"
+#include "BlobRegistryImpl.h"
+#endif
+
 class QWebFrameAdapter;
 class QWebPageAdapter;
 
@@ -136,6 +148,9 @@ private:
     QtPlatformPlugin m_platformPlugin;
 #ifndef QT_NO_SYSTEMTRAYICON
     QScopedPointer<QObject> m_systemTrayIcon;
+#if defined(Q_OS_HAIKU)
+	QNetworkAccessManager *m_netMgr;
+#endif
 #endif
 };
 
diff --git a/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp b/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp
index 841d054..1fef346 100644
--- a/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp
+++ b/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp
@@ -965,6 +965,9 @@ void QWebFrameAdapter::setViewportSize(const QSize& size)
     if (view->needsLayout())
         view->layout();
     view->adjustViewSize();
+
+    if (view->needsLayout())
+        view->layout();
 }
 
 
diff --git a/Source/WebKit2/CMakeLists.txt b/Source/WebKit2/CMakeLists.txt
index aa7863c..2907f6f 100644
--- a/Source/WebKit2/CMakeLists.txt
+++ b/Source/WebKit2/CMakeLists.txt
@@ -743,6 +743,12 @@ set(PluginProcess_LIBRARIES
     WebKit2
 )
 
+if (HAIKU)
+	list(APPEND WebKit2_LIBRARIES network)
+	list(APPEND WebProcess_LIBRARIES network)
+	list(APPEND NetworkProcess_LIBRARIES network)
+endif ()
+
 if (COMPILER_IS_GCC_OR_CLANG)
     set(ATOMIC_TEST_SOURCE
     "
diff --git a/Source/WebKit2/UIProcess/Launcher/qt/ProcessLauncherQt.cpp b/Source/WebKit2/UIProcess/Launcher/qt/ProcessLauncherQt.cpp
index 694a759..aa701e8 100644
--- a/Source/WebKit2/UIProcess/Launcher/qt/ProcessLauncherQt.cpp
+++ b/Source/WebKit2/UIProcess/Launcher/qt/ProcessLauncherQt.cpp
@@ -223,7 +223,7 @@ void ProcessLauncher::launchProcess()
         delete webProcessOrSUIDHelper;
         return;
     }
-#if OS(UNIX)
+#if OS(UNIX) && !OS(HAIKU)
     setpriority(PRIO_PROCESS, webProcessOrSUIDHelper->pid(), 10);
 #endif
     RefPtr<ProcessLauncher> protector(this);
diff --git a/Source/cmake/OptionsQt.cmake b/Source/cmake/OptionsQt.cmake
index bce9ea2..bea3766 100644
--- a/Source/cmake/OptionsQt.cmake
+++ b/Source/cmake/OptionsQt.cmake
@@ -766,6 +766,13 @@ if (ENABLE_X11_TARGET)
     endif ()
 endif ()
 
+if (ENABLE_SUBTLE_CRYPTO)
+    find_package(GnuTLS 3.0.0)
+    if (NOT GNUTLS_FOUND)
+        message(FATAL_ERROR "GnuTLS is needed for ENABLE_SUBTLE_CRYPTO")
+    endif ()
+endif ()
+
 if (NOT ENABLE_VIDEO)
     set(USE_MEDIA_FOUNDATION OFF)
     set(USE_QT_MULTIMEDIA OFF)
-- 
2.43.2


From 9ded1463fe9e11d23d27e7af6d50cc0151df8853 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Fri, 25 Feb 2022 15:48:30 +0100
Subject: Patch for newer libs


diff --git a/Source/WebCore/platform/text/LocaleICU.cpp b/Source/WebCore/platform/text/LocaleICU.cpp
index 6fbe495..9ae0058 100644
--- a/Source/WebCore/platform/text/LocaleICU.cpp
+++ b/Source/WebCore/platform/text/LocaleICU.cpp
@@ -153,12 +153,12 @@ static String getDateFormatPattern(const UDateFormat* dateFormat)
         return emptyString();
 
     UErrorCode status = U_ZERO_ERROR;
-    int32_t length = udat_toPattern(dateFormat, TRUE, 0, 0, &status);
+    int32_t length = udat_toPattern(dateFormat, true, 0, 0, &status);
     if (status != U_BUFFER_OVERFLOW_ERROR || !length)
         return emptyString();
     Vector<UChar> buffer(length);
     status = U_ZERO_ERROR;
-    udat_toPattern(dateFormat, TRUE, buffer.data(), length, &status);
+    udat_toPattern(dateFormat, true, buffer.data(), length, &status);
     if (U_FAILURE(status))
         return emptyString();
     return String::adopt(buffer);
diff --git a/Source/WebCore/platform/text/TextCodecICU.cpp b/Source/WebCore/platform/text/TextCodecICU.cpp
index dd6ff06..e0f4bd7 100644
--- a/Source/WebCore/platform/text/TextCodecICU.cpp
+++ b/Source/WebCore/platform/text/TextCodecICU.cpp
@@ -308,7 +308,7 @@ void TextCodecICU::createICUConverter() const
     m_converterICU = ucnv_open(m_canonicalConverterName, &err);
     ASSERT(U_SUCCESS(err));
     if (m_converterICU)
-        ucnv_setFallback(m_converterICU, TRUE);
+        ucnv_setFallback(m_converterICU, true);
 }
 
 int TextCodecICU::decodeToBuffer(UChar* target, UChar* targetLimit, const char*& source, const char* sourceLimit, int32_t* offsets, bool flush, UErrorCode& err)
diff --git a/Source/WebCore/platform/text/icu/UTextProvider.h b/Source/WebCore/platform/text/icu/UTextProvider.h
index c254fc4..6d1e1cb 100644
--- a/Source/WebCore/platform/text/icu/UTextProvider.h
+++ b/Source/WebCore/platform/text/icu/UTextProvider.h
@@ -80,12 +80,12 @@ inline bool uTextAccessInChunkOrOutOfRange(UText* text, int64_t nativeIndex, int
             // Ensure chunk offset is well formed if computed offset exceeds int32_t range.
             ASSERT(offset < std::numeric_limits<int32_t>::max());
             text->chunkOffset = offset < std::numeric_limits<int32_t>::max() ? static_cast<int32_t>(offset) : 0;
-            isAccessible = TRUE;
+            isAccessible = true;
             return true;
         }
         if (nativeIndex >= nativeLength && text->chunkNativeLimit == nativeLength) {
             text->chunkOffset = text->chunkLength;
-            isAccessible = FALSE;
+            isAccessible = false;
             return true;
         }
     } else {
@@ -94,12 +94,12 @@ inline bool uTextAccessInChunkOrOutOfRange(UText* text, int64_t nativeIndex, int
             // Ensure chunk offset is well formed if computed offset exceeds int32_t range.
             ASSERT(offset < std::numeric_limits<int32_t>::max());
             text->chunkOffset = offset < std::numeric_limits<int32_t>::max() ? static_cast<int32_t>(offset) : 0;
-            isAccessible = TRUE;
+            isAccessible = true;
             return true;
         }
         if (nativeIndex <= 0 && !text->chunkNativeStart) {
             text->chunkOffset = 0;
-            isAccessible = FALSE;
+            isAccessible = false;
             return true;
         }
     }
diff --git a/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp b/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp
index cd6852c..6a864b1 100644
--- a/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp
+++ b/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp
@@ -100,23 +100,23 @@ static UBool uTextLatin1Access(UText* uText, int64_t index, UBool forward)
         if (index < uText->chunkNativeLimit && index >= uText->chunkNativeStart) {
             // Already inside the buffer. Set the new offset.
             uText->chunkOffset = static_cast<int32_t>(index - uText->chunkNativeStart);
-            return TRUE;
+            return true;
         }
         if (index >= length && uText->chunkNativeLimit == length) {
             // Off the end of the buffer, but we can't get it.
             uText->chunkOffset = static_cast<int32_t>(index - uText->chunkNativeStart);
-            return FALSE;
+            return false;
         }
     } else {
         if (index <= uText->chunkNativeLimit && index > uText->chunkNativeStart) {
             // Already inside the buffer. Set the new offset.
             uText->chunkOffset = static_cast<int32_t>(index - uText->chunkNativeStart);
-            return TRUE;
+            return true;
         }
         if (!index && !uText->chunkNativeStart) {
             // Already at the beginning; can't go any farther.
             uText->chunkOffset = 0;
-            return FALSE;
+            return false;
         }
     }
     
@@ -144,7 +144,7 @@ static UBool uTextLatin1Access(UText* uText, int64_t index, UBool forward)
 
     uText->nativeIndexingLimit = uText->chunkLength;
 
-    return TRUE;
+    return true;
 }
 
 static int32_t uTextLatin1Extract(UText* uText, int64_t start, int64_t limit, UChar* dest, int32_t destCapacity, UErrorCode* status)
@@ -336,7 +336,7 @@ static int64_t uTextLatin1ContextAwareNativeLength(UText* text)
 static UBool uTextLatin1ContextAwareAccess(UText* text, int64_t nativeIndex, UBool forward)
 {
     if (!text->context)
-        return FALSE;
+        return false;
     int64_t nativeLength = uTextLatin1ContextAwareNativeLength(text);
     UBool isAccessible;
     if (uTextAccessInChunkOrOutOfRange(text, nativeIndex, nativeLength, forward, isAccessible))
@@ -356,7 +356,7 @@ static UBool uTextLatin1ContextAwareAccess(UText* text, int64_t nativeIndex, UBo
         ASSERT(newContext == UTextProviderContext::PriorContext);
         textLatin1ContextAwareSwitchToPriorContext(text, nativeIndex, nativeLength, forward);
     }
-    return TRUE;
+    return true;
 }
 
 static int32_t uTextLatin1ContextAwareExtract(UText*, int64_t, int64_t, UChar*, int32_t, UErrorCode* errorCode)
diff --git a/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp b/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp
index 7aaac48..9ae0d36 100644
--- a/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp
+++ b/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp
@@ -125,7 +125,7 @@ static inline int64_t uTextUTF16ContextAwareNativeLength(UText* text)
 static UBool uTextUTF16ContextAwareAccess(UText* text, int64_t nativeIndex, UBool forward)
 {
     if (!text->context)
-        return FALSE;
+        return false;
     int64_t nativeLength = uTextUTF16ContextAwareNativeLength(text);
     UBool isAccessible;
     if (uTextAccessInChunkOrOutOfRange(text, nativeIndex, nativeLength, forward, isAccessible))
@@ -145,7 +145,7 @@ static UBool uTextUTF16ContextAwareAccess(UText* text, int64_t nativeIndex, UBoo
         ASSERT(newContext == UTextProviderContext::PriorContext);
         textUTF16ContextAwareSwitchToPriorContext(text, nativeIndex, nativeLength, forward);
     }
-    return TRUE;
+    return true;
 }
 
 static int32_t uTextUTF16ContextAwareExtract(UText*, int64_t, int64_t, UChar*, int32_t, UErrorCode* errorCode)
-- 
2.43.2


From 9e12a7e45df4c4d82429f7ec41f4925e4288510b Mon Sep 17 00:00:00 2001
From: Schrijvers Luc <begasus@gmail.com>
Date: Sat, 25 May 2024 12:12:58 +0200
Subject: Offlineasm warnings with newer Ruby versions

https://github.com/WebKit/WebKit/commit/c7d19a492d97f9282a546831beb918e03315f6ef

diff --git a/Source/JavaScriptCore/offlineasm/parser.rb b/Source/JavaScriptCore/offlineasm/parser.rb
index b445112..cd1cffa 100644
--- a/Source/JavaScriptCore/offlineasm/parser.rb
+++ b/Source/JavaScriptCore/offlineasm/parser.rb
@@ -584,9 +584,7 @@ class Parser
         firstCodeOrigin = @tokens[@idx].codeOrigin
         list = []
         loop {
-            if (@idx == @tokens.length and not final) or (final and @tokens[@idx] =~ final)
-                break
-            elsif @tokens[@idx].is_a? Annotation
+            if @tokens[@idx].is_a? Annotation
                 # This is the only place where we can encounter a global
                 # annotation, and hence need to be able to distinguish between
                 # them.
@@ -600,6 +598,8 @@ class Parser
                 list << Instruction.new(codeOrigin, annotationOpcode, [], @tokens[@idx].string)
                 @annotation = nil
                 @idx += 2 # Consume the newline as well.
+            elsif (@idx == @tokens.length and not final) or (final and @tokens[@idx] =~ final)
+                break
             elsif @tokens[@idx] == "\n"
                 # ignore
                 @idx += 1
-- 
2.43.2


From 272f4a46335fbdf5e80f1c6d467a6c684e21c148 Mon Sep 17 00:00:00 2001
From: Schrijvers Luc <begasus@gmail.com>
Date: Sat, 25 May 2024 17:48:07 +0200
Subject: Build fails with libxml2 version 2.12.0 due to API change

https://github.com/WebKit/WebKit/commit/1bad176b2496579d760852c80cff3ad9fb7c3a4b

diff --git a/Source/WebCore/xml/XSLTProcessor.h b/Source/WebCore/xml/XSLTProcessor.h
index cffd1c4..88094c0 100644
--- a/Source/WebCore/xml/XSLTProcessor.h
+++ b/Source/WebCore/xml/XSLTProcessor.h
@@ -64,7 +64,11 @@ public:
 
     void reset();
 
+#if LIBXML_VERSION >= 21200
+    static void parseErrorFunc(void* userData, const xmlError*);
+#else
     static void parseErrorFunc(void* userData, xmlError*);
+#endif
     static void genericErrorFunc(void* userData, const char* msg, ...);
     
     // Only for libXSLT callbacks
diff --git a/Source/WebCore/xml/XSLTProcessorLibxslt.cpp b/Source/WebCore/xml/XSLTProcessorLibxslt.cpp
index 8587b00..e553255 100644
--- a/Source/WebCore/xml/XSLTProcessorLibxslt.cpp
+++ b/Source/WebCore/xml/XSLTProcessorLibxslt.cpp
@@ -78,7 +78,11 @@ void XSLTProcessor::genericErrorFunc(void*, const char*, ...)
     // It would be nice to do something with this error message.
 }
 
-void XSLTProcessor::parseErrorFunc(void* userData, xmlError* error)
+#if LIBXML_VERSION >= 21200
+    void XSLTProcessor::parseErrorFunc(void* userData, const xmlError* error)
+#else
+    void XSLTProcessor::parseErrorFunc(void* userData, xmlError* error)
+#endif
 {
     PageConsoleClient* console = static_cast<PageConsoleClient*>(userData);
     if (!console)
-- 
2.43.2


From 6d5f214da258da7f228161100edf4acb632857a8 Mon Sep 17 00:00:00 2001
From: Schrijvers Luc <begasus@gmail.com>
Date: Sat, 25 May 2024 19:43:10 +0200
Subject: Silense some warning


diff --git a/CMakeLists.txt b/CMakeLists.txt
index eaf3a35..9f0672f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -104,6 +104,10 @@ else ()
     message(FATAL_ERROR "Unknown OS '${CMAKE_SYSTEM_NAME}'")
 endif ()
 
+if(HAIKU)
+    add_definitions(-Wno-deprecated-copy -Wno-redundant-move -Wno-class-memaccess)
+endif()
+
 # -----------------------------------------------------------------------------
 # Default library types
 # -----------------------------------------------------------------------------
-- 
2.43.2

