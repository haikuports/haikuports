From cf41b77fc16a8555f64b6481fda7bc02135a997f Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Fri, 16 Oct 2015 23:07:40 +1000
Subject: Fix Haiku build


diff --git a/qtbase/src/corelib/io/qstandardpaths_haiku.cpp b/qtbase/src/corelib/io/qstandardpaths_haiku.cpp
index 044d69f..89653c1 100644
--- a/qtbase/src/corelib/io/qstandardpaths_haiku.cpp
+++ b/qtbase/src/corelib/io/qstandardpaths_haiku.cpp
@@ -145,15 +145,15 @@ QString QStandardPaths::writableLocation(StandardLocation type)
         return haikuStandardPath(B_USER_NONPACKAGED_BIN_DIRECTORY);
     case TempLocation:
         return haikuStandardPath(B_SYSTEM_TEMP_DIRECTORY);
-    case AppDataLocation: // fall through
-    case AppLocalDataLocation:
-        return haikuAppStandardPath(B_USER_NONPACKAGED_DATA_DIRECTORY);
-    case GenericDataLocation:
-        return haikuStandardPath(B_USER_NONPACKAGED_DATA_DIRECTORY);
+//    case AppDataLocation: // fall through
+//    case AppLocalDataLocation:
+//        return haikuAppStandardPath(B_USER_NONPACKAGED_DATA_DIRECTORY);
+//    case GenericDataLocation:
+//        return haikuStandardPath(B_USER_NONPACKAGED_DATA_DIRECTORY);
     case CacheLocation:
         return haikuAppStandardPath(B_USER_CACHE_DIRECTORY);
     case GenericCacheLocation:
-        return haikuStandardPath(B_USER_CACHE_DIRECTORY);
+        return haikuStandardPath(B_SYSTEM_CACHE_DIRECTORY);
     case ConfigLocation: // fall through
     case AppConfigLocation:
         return haikuAppStandardPath(B_USER_SETTINGS_DIRECTORY);
@@ -179,7 +179,7 @@ QStringList QStandardPaths::standardLocations(StandardLocation type)
     case MoviesLocation:
     case DownloadLocation:
     case HomeLocation:
-        paths += haikuStandardPath(B_USER_NONPACKAGED_DIRECTORY);
+        paths += haikuStandardPath(B_USER_DIRECTORY);
         break;
     case FontsLocation:
         paths += haikuStandardPaths(B_FIND_PATH_FONTS_DIRECTORY);
@@ -203,7 +203,7 @@ QStringList QStandardPaths::standardLocations(StandardLocation type)
         break;
     case ConfigLocation: // fall through
     case AppConfigLocation:
-        paths += haikuAppStandardPath(B_SYSTEM_SETTINGS_DIRECTORY);
+        paths += haikuAppStandardPath(B_USER_SETTINGS_DIRECTORY);
         break;
     case GenericConfigLocation:
         paths += haikuStandardPath(B_SYSTEM_SETTINGS_DIRECTORY);
diff --git a/qtbase/tests/auto/corelib/io/qfileselector/qfileselector.qrc b/qtbase/tests/auto/corelib/io/qfileselector/qfileselector.qrc
index ea9b827..928e949 100644
--- a/qtbase/tests/auto/corelib/io/qfileselector/qfileselector.qrc
+++ b/qtbase/tests/auto/corelib/io/qfileselector/qfileselector.qrc
@@ -21,6 +21,7 @@
    <file>platforms/+unix/+darwin/test</file>
    <file>platforms/+unix/+haiku/test</file>
    <file>platforms/+unix/+linux/test</file>
+   <file>platforms/+unix/+haiku/test</file>
    <file>platforms/+unix/test</file>
    <file>platforms/+windows/+wince/test</file>
    <file>platforms/+windows/+winnt/test</file>
diff --git a/qtdeclarative/src/3rdparty/masm/wtf/PageBlock.cpp b/qtdeclarative/src/3rdparty/masm/wtf/PageBlock.cpp
index e715ed2..b05e71e 100644
--- a/qtdeclarative/src/3rdparty/masm/wtf/PageBlock.cpp
+++ b/qtdeclarative/src/3rdparty/masm/wtf/PageBlock.cpp
@@ -47,6 +47,13 @@ inline size_t systemPageSize()
     return ::sysconf(_SC_PAGESIZE);
 }
 
+#elif OS(HAIKU)
+
+inline size_t systemPageSize()
+{
+    return 4096;
+}
+
 #elif OS(WINDOWS)
 
 inline size_t systemPageSize()
diff --git a/qtdeclarative/src/3rdparty/masm/wtf/Platform.h b/qtdeclarative/src/3rdparty/masm/wtf/Platform.h
index 7f2023a..4b3d202 100644
--- a/qtdeclarative/src/3rdparty/masm/wtf/Platform.h
+++ b/qtdeclarative/src/3rdparty/masm/wtf/Platform.h
@@ -412,6 +412,11 @@
 #define WTF_OS_QNX 1
 #endif
 
+/* OS(HAIKU) - Haiku */
+#if defined(__HAIKU__)
+#define WTF_OS_HAIKU 1
+#endif
+
 /* OS(SOLARIS) - Solaris */
 #if defined(sun) || defined(__sun)
 #define WTF_OS_SOLARIS 1
@@ -442,6 +447,7 @@
     || OS(HURD)             \
     || OS(INTEGRITY)        \
     || OS(LINUX)            \
+    || OS(HAIKU)            \
     || OS(NETBSD)           \
     || OS(OPENBSD)          \
     || OS(QNX)              \
-- 
2.12.2


From e74d980c19079acb76026d50007fedc30678ad3d Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Fri, 16 Oct 2015 23:07:40 +1000
Subject: Set Experimental Haiku QPA plugin

Updated for 5.7 and 5.8 by Jerome Duval.

diff --git a/qtbase/src/plugins/platforms/haiku/haiku.pro b/qtbase/src/plugins/platforms/haiku/haiku.pro
index fd1f47b..381d842 100644
--- a/qtbase/src/plugins/platforms/haiku/haiku.pro
+++ b/qtbase/src/plugins/platforms/haiku/haiku.pro
@@ -1,41 +1,42 @@
 TARGET = qhaiku
 
-QT += core-private gui-private eventdistpatcher_support-private
+QT += core-private gui-private eventdispatcher_support-private
+LIBS += -lbe -lroot -ltracker
+# -lfreetype
+INCLUDEPATH += $$QT_SOURCE_TREE/src/3rdparty/freetype/include
+INCLUDEPATH += $$QT_SOURCE_TREE/src/3rdparty/freetype/include/config
 
-SOURCES = \
-    main.cpp \
-    qhaikuapplication.cpp \
-    qhaikubuffer.cpp \
-    qhaikuclipboard.cpp \
-    qhaikucursor.cpp \
-    qhaikuintegration.cpp \
-    qhaikukeymapper.cpp \
-    qhaikurasterbackingstore.cpp \
-    qhaikurasterwindow.cpp \
-    qhaikuscreen.cpp \
-    qhaikuservices.cpp \
-    qhaikuutils.cpp \
-    qhaikuwindow.cpp
+SOURCES =   main.cpp \
+            qhaikuintegration.cpp \
+            qhaikuintegration_haiku.cpp \
+            qhaikuwindow.cpp \
+            qhaikucommon.cpp \
+            qhaikutheme.cpp \
+            qhaikusystemsettings.cpp \
+            qhaikuclipboard.cpp \
+            qhaikuplatformfontdatabase.cpp \
+            qhaikuplatformdialoghelpers.cpp \
+            qhaikuview.cpp \
+            qhaikuservices.cpp \
+            qhaikucursor.cpp
 
-HEADERS = \
-    main.h \
-    qhaikuapplication.h \
-    qhaikubuffer.h \
-    qhaikuclipboard.h \
-    qhaikucursor.h \
-    qhaikuintegration.h \
-    qhaikukeymapper.h \
-    qhaikurasterbackingstore.h \
-    qhaikurasterwindow.h \
-    qhaikuscreen.h \
-    qhaikuservices.h \
-    qhaikuutils.h \
-    qhaikuwindow.h
+HEADERS =   qhaikuintegration.h \
+            qhaikuwindow.h \
+            qhaikucommon.h \
+            qhaikutheme.h \
+            qhaikusystemsettings.h \
+            qhaikuclipboard.h \
+            qhaikuplatformfontdatabase.h \
+            qhaikuplatformdialoghelpers.h \
+            qhaikuview.h \
+            qhaikuservices.h \
+            qhaikucursor.h
 
-LIBS += -lbe
+include($$QT_SOURCE_TREE/src/platformsupport/fontdatabases/basic/basic.pri)
 
 OTHER_FILES += haiku.json
 
 PLUGIN_TYPE = platforms
-PLUGIN_CLASS_NAME = QHaikuIntegrationPlugin
+PLUGIN_CLASS_NAME = QHaikuExpIntegrationPlugin
+!equals(TARGET, $$QT_DEFAULT_QPA_PLUGIN): PLUGIN_EXTENDS = -
 load(qt_plugin)
diff --git a/qtbase/src/plugins/platforms/haiku/main.cpp b/qtbase/src/plugins/platforms/haiku/main.cpp
index 02168d0..f8de98a 100644
--- a/qtbase/src/plugins/platforms/haiku/main.cpp
+++ b/qtbase/src/plugins/platforms/haiku/main.cpp
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -37,17 +37,28 @@
 **
 ****************************************************************************/
 
-#include "main.h"
+#include <qpa/qplatformintegrationplugin.h>
+
 #include "qhaikuintegration.h"
 
 QT_BEGIN_NAMESPACE
 
-QPlatformIntegration *QHaikuIntegrationPlugin::create(const QString& system, const QStringList& paramList)
+class QHaikuExpIntegrationPlugin : public QPlatformIntegrationPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "haiku.json")
+public:
+    QPlatformIntegration *create(const QString&, const QStringList&, int &, char **);
+};
+
+QPlatformIntegration *QHaikuExpIntegrationPlugin::create(const QString& system, const QStringList& parameters, int &argc, char **argv)
 {
     if (!system.compare(QLatin1String("haiku"), Qt::CaseInsensitive))
-        return new QHaikuIntegration(paramList);
+        return QHaikuIntegration::createHaikuIntegration(parameters, argc, argv);
 
-    return Q_NULLPTR;
+    return 0;
 }
 
 QT_END_NAMESPACE
+
+#include "main.moc"
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuapplication.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuapplication.cpp
deleted file mode 100644
index b75810c..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikuapplication.cpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qhaikuapplication.h"
-
-#include <QCoreApplication>
-#include <QFileOpenEvent>
-
-#include <Entry.h>
-#include <Path.h>
-
-QHaikuApplication::QHaikuApplication(const char *signature)
-    : BApplication(signature)
-{
-}
-
-bool QHaikuApplication::QuitRequested()
-{
-    QEvent quitEvent(QEvent::Quit);
-    QCoreApplication::sendEvent(QCoreApplication::instance(), &quitEvent);
-    return true;
-}
-
-void QHaikuApplication::RefsReceived(BMessage* message)
-{
-    uint32 type;
-    int32 count;
-
-    const status_t status = message->GetInfo("refs", &type, &count);
-    if (status == B_OK && type == B_REF_TYPE) {
-        entry_ref ref;
-        for (int32 i = 0; i < count; ++i) {
-            if (message->FindRef("refs", i, &ref) == B_OK) {
-                const BPath path(&ref);
-                QCoreApplication::postEvent(QCoreApplication::instance(), new QFileOpenEvent(QFile::decodeName(path.Path())));
-            }
-        }
-    }
-
-    BApplication::RefsReceived(message);
-}
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuapplication.h b/qtbase/src/plugins/platforms/haiku/qhaikuapplication.h
deleted file mode 100644
index 0696df8..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikuapplication.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QHAIKUAPPLICATION_H
-#define QHAIKUAPPLICATION_H
-
-#include <qglobal.h>
-
-#include <Application.h>
-
-class QHaikuApplication : public BApplication
-{
-public:
-    explicit QHaikuApplication(const char *signature);
-
-    bool QuitRequested() Q_DECL_OVERRIDE;
-    void RefsReceived(BMessage* message) Q_DECL_OVERRIDE;
-};
-
-#endif
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikubuffer.cpp b/qtbase/src/plugins/platforms/haiku/qhaikubuffer.cpp
deleted file mode 100644
index c6f6ffe..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikubuffer.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qhaikubuffer.h"
-
-#include <Bitmap.h>
-#include <Rect.h>
-
-QT_BEGIN_NAMESPACE
-
-QHaikuBuffer::QHaikuBuffer()
-    : m_buffer(Q_NULLPTR)
-{
-}
-
-QHaikuBuffer::QHaikuBuffer(BBitmap *buffer)
-    : m_buffer(buffer)
-{
-    // wrap buffer in an image
-    m_image = QImage(static_cast<uchar*>(m_buffer->Bits()), m_buffer->Bounds().right, m_buffer->Bounds().bottom, m_buffer->BytesPerRow(), QImage::Format_RGB32);
-}
-
-BBitmap* QHaikuBuffer::nativeBuffer() const
-{
-    return m_buffer;
-}
-
-const QImage *QHaikuBuffer::image() const
-{
-    return (m_buffer != Q_NULLPTR) ? &m_image : Q_NULLPTR;
-}
-
-QImage *QHaikuBuffer::image()
-{
-    return (m_buffer != Q_NULLPTR) ? &m_image : Q_NULLPTR;
-}
-
-QRect QHaikuBuffer::rect() const
-{
-    return m_image.rect();
-}
-
-QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.cpp
index 774da44..9043270 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.cpp
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2011 - 2012 Research In Motion
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -41,133 +41,88 @@
 
 #include "qhaikuclipboard.h"
 
-#include <QMimeData>
-#include <QThread>
+#include <QtGui/QColor>
 
+#include <QtCore/QDebug>
+#include <QtCore/QMimeData>
+#include <QtCore/QStringList>
+#include <QtCore/QUrl>
+
+#include <String.h>
 #include <Clipboard.h>
 
+QT_BEGIN_NAMESPACE
+
 QHaikuClipboard::QHaikuClipboard()
-    : m_systemMimeData(Q_NULLPTR)
-    , m_userMimeData(Q_NULLPTR)
 {
-    if (be_clipboard)
-        be_clipboard->StartWatching(BMessenger(this));
 }
 
 QHaikuClipboard::~QHaikuClipboard()
-{
-    if (be_clipboard)
-        be_clipboard->StopWatching(BMessenger(this));
-
-    delete m_userMimeData;
-    delete m_systemMimeData;
-}
-
-QMimeData *QHaikuClipboard::mimeData(QClipboard::Mode mode)
-{
-    if (mode != QClipboard::Clipboard)
-        return 0;
-
-    if (m_userMimeData)
-        return m_userMimeData;
-
-    if (!be_clipboard->Lock())
-        return 0;
-
-    if (!m_systemMimeData)
-        m_systemMimeData = new QMimeData();
-    else
-        m_systemMimeData->clear();
-
-    const BMessage *clipboard = be_clipboard->Data();
-    if (clipboard) {
-        char *name = Q_NULLPTR;
-        uint32 type = 0;
-        int32 count = 0;
-
-        for (int i = 0; clipboard->GetInfo(B_MIME_TYPE, i, &name, &type, &count) == B_OK; i++) {
-            const void *data = Q_NULLPTR;
-            int32 dataLen = 0;
-
-            const status_t status = clipboard->FindData(name, B_MIME_TYPE, &data, &dataLen);
-            if (dataLen && (status == B_OK)) {
-                const QLatin1String format(name);
-                if (format == QLatin1String("text/plain")) {
-                    m_systemMimeData->setText(QString::fromLocal8Bit(reinterpret_cast<const char*>(data), dataLen));
-                } else if (format == QLatin1String("text/html")) {
-                    m_systemMimeData->setHtml(QString::fromLocal8Bit(reinterpret_cast<const char*>(data), dataLen));
-                } else {
-                    m_systemMimeData->setData(format, QByteArray(reinterpret_cast<const char*>(data), dataLen));
-                }
-            }
-        }
-    }
-
-    be_clipboard->Unlock();
-
-    return m_systemMimeData;
+{   
 }
 
-void QHaikuClipboard::setMimeData(QMimeData *mimeData, QClipboard::Mode mode)
+void QHaikuClipboard::setMimeData(QMimeData *data, QClipboard::Mode mode)
 {
     if (mode != QClipboard::Clipboard)
         return;
 
-    if (mimeData) {
-        if (m_systemMimeData == mimeData)
-            return;
-
-        if (m_userMimeData == mimeData)
-            return;
-    }
-
-    if (!be_clipboard->Lock())
-        return;
-
-    be_clipboard->Clear();
-    if (mimeData) {
-        BMessage *clipboard = be_clipboard->Data();
-        if (clipboard) {
-            const QStringList formats = mimeData->formats();
-            Q_FOREACH (const QString &format, formats) {
-                const QByteArray data = mimeData->data(format).data();
-                clipboard->AddData(format.toUtf8(), B_MIME_TYPE, data, data.count());
-            }
-        }
-    }
-
-    if (be_clipboard->Commit() != B_OK)
-        qWarning("Unable to store mime data on clipboard");
-
-    be_clipboard->Unlock();
-
-    m_userMimeData = mimeData;
-
-    emitChanged(QClipboard::Clipboard);
-}
-
-bool QHaikuClipboard::supportsMode(QClipboard::Mode mode) const
-{
-    return (mode == QClipboard::Clipboard);
+	if (be_clipboard->Lock()) {
+		be_clipboard->Clear();
+		if (data){
+			BMessage* clip = (BMessage *)NULL;
+	    	if( (clip = be_clipboard->Data()) != NULL) {
+	    		QStringList formats = data->formats();
+				for(int f = 0; f < formats.size(); ++f) {
+            		QString mimeType = formats.at(f);	    			
+					clip->AddData(mimeType.toUtf8(), B_MIME_TYPE, data->data(mimeType).data(), data->data(mimeType).count());
+	    		}
+	    	}
+		}
+		be_clipboard->Commit();
+	   	be_clipboard->Unlock();
+	}
 }
 
-bool QHaikuClipboard::ownsMode(QClipboard::Mode mode) const
+QMimeData *QHaikuClipboard::mimeData(QClipboard::Mode mode)
 {
-    Q_UNUSED(mode);
+    if (mode != QClipboard::Clipboard)
+        return 0;
 
-    return false;
+	QMimeData *md = new QMimeData();
+
+	BMessage* clip = (BMessage *)NULL;
+  	if (be_clipboard->Lock()) {
+    	if( (clip = be_clipboard->Data()) != NULL) {
+    		BMessage *msg = (BMessage*)(be_clipboard->Data());
+    		
+			char *name;
+			uint32 type;
+			int32 count;
+
+			for ( int i = 0; msg->GetInfo(B_MIME_TYPE, i, &name, &type, &count) == B_OK; i++ ) {
+				const void *data;
+				ssize_t dataLen = 0;
+				status_t stat = msg->FindData(name,B_MIME_TYPE,&data,&dataLen);
+				if(dataLen && stat==B_OK)	{
+					QString mime(name);
+					if(mime=="text/plain") {
+						QString text = QString::fromUtf8((const char*)data, dataLen);
+						md->setText(text);
+					} else if(mime=="text/html") {
+						QString html = QString::fromUtf8((const char*)data, dataLen);
+						md->setHtml(html);
+					} else {
+						QByteArray clip_data((const char*)data, dataLen);
+						md->setData(mime,clip_data);
+					}
+				}
+			}		
+			be_clipboard->Unlock();
+    	}
+	}
+	return md;
 }
 
-void QHaikuClipboard::MessageReceived(BMessage* message)
-{
-    if (message->what == B_CLIPBOARD_CHANGED) {
-        delete m_userMimeData;
-        m_userMimeData = Q_NULLPTR;
-
-        emitChanged(QClipboard::Clipboard);
-    }
-
-    BHandler::MessageReceived(message);
-}
+QT_END_NAMESPACE
 
-#endif
+#endif //QT_NO_CLIPBOARD
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.h b/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.h
index 3dd4496..12c01d5 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuclipboard.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2011 - 2012 Research In Motion
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -40,35 +40,27 @@
 #ifndef QHAIKUCLIPBOARD_H
 #define QHAIKUCLIPBOARD_H
 
-#if !defined(QT_NO_CLIPBOARD)
+#include <QtCore/qglobal.h>
 
+#if !defined(QT_NO_CLIPBOARD)
 #include <qpa/qplatformclipboard.h>
 
-#include <Handler.h>
-
 QT_BEGIN_NAMESPACE
 
-class QHaikuClipboard : public QPlatformClipboard, public BHandler
+class QHaikuClipboard : public QPlatformClipboard
 {
 public:
     QHaikuClipboard();
     ~QHaikuClipboard();
-
-    QMimeData *mimeData(QClipboard::Mode mode = QClipboard::Clipboard) Q_DECL_OVERRIDE;
-    void setMimeData(QMimeData *data, QClipboard::Mode mode = QClipboard::Clipboard) Q_DECL_OVERRIDE;
-    bool supportsMode(QClipboard::Mode mode) const Q_DECL_OVERRIDE;
-    bool ownsMode(QClipboard::Mode mode) const Q_DECL_OVERRIDE;
-
-    // override from BHandler to catch change notifications from Haiku clipboard
-    void MessageReceived(BMessage* message) Q_DECL_OVERRIDE;
+    QMimeData *mimeData(QClipboard::Mode mode = QClipboard::Clipboard);
+    void setMimeData(QMimeData *data, QClipboard::Mode mode = QClipboard::Clipboard);
 
 private:
-    QMimeData *m_systemMimeData;
-    QMimeData *m_userMimeData;
+    class MimeData;
+    MimeData *m_mimeData;
 };
 
 QT_END_NAMESPACE
 
-#endif
-
-#endif
+#endif //QT_NO_CLIPBOARD
+#endif //QHAIKUCLIPBOARD_H
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikucommon.cpp b/qtbase/src/plugins/platforms/haiku/qhaikucommon.cpp
new file mode 100644
index 0000000..3601226
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikucommon.cpp
@@ -0,0 +1,234 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qhaikucommon.h"
+#include "qhaikuwindow.h"
+#include "qhaikucursor.h"
+
+#include <QtGui/private/qpixmap_raster_p.h>
+#include <QtGui/private/qguiapplication_p.h>
+
+#include <qpa/qplatformcursor.h>
+#include <qpa/qplatformwindow.h>
+
+#include <qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+QHaikuScreen::QHaikuScreen()
+    : BScreen(B_MAIN_SCREEN_ID)
+    , m_geometry(0, 0, 800, 600)
+    , m_cursor(new QHaikuCursor)
+{
+	BRect frame = BScreen::Frame();
+	m_geometry.setCoords(0, 0, frame.Width(), frame.Height());
+}
+
+QPlatformCursor *QHaikuScreen::cursor() const
+{
+    return m_cursor;
+}
+
+QHaikuScreen::~QHaikuScreen()
+{
+    delete m_cursor;
+}
+
+
+QPixmap QHaikuScreen::grabWindow(WId id, int x, int y, int width, int height) const
+{
+    QRect rect(x, y, width, height);
+
+    QHaikuWindow *window = QHaikuWindow::windowForWinId(id);
+    if (!window || window->window()->type() == Qt::Desktop) {
+        QWindowList wl = QGuiApplication::topLevelWindows();
+        QWindow *containing = 0;
+        foreach (QWindow *w, wl) {
+            if (w->type() != Qt::Desktop && w->isExposed() && w->geometry().contains(rect)) {
+                containing = w;
+                break;
+            }
+        }
+
+        if (!containing)
+            return QPixmap();
+
+        id = containing->winId();
+        rect = rect.translated(-containing->geometry().topLeft());
+    }
+
+    QHaikuBackingStore *store = QHaikuBackingStore::backingStoreForWinId(id);
+    if (store)
+        return store->grabWindow(id, rect);
+    return QPixmap();
+}
+
+QHaikuBackingStore::QHaikuBackingStore(QWindow *window)
+    : QPlatformBackingStore(window)
+{
+	BRect rect(0, 0, window->width() - 1, window->height() - 1);
+	m_bitmap = new BBitmap(rect, B_RGB32);	
+	m_image = QImage((uchar*)m_bitmap->Bits(), window->width(), window->height(), m_bitmap->BytesPerRow(), QImage::Format_RGB32);
+}
+
+QHaikuBackingStore::~QHaikuBackingStore()
+{
+	m_image = QImage();
+	delete m_bitmap;
+	
+    clearHash();
+}
+
+QPaintDevice *QHaikuBackingStore::paintDevice()
+{
+    return &m_image;
+}
+
+#define Q2BRect(r) BRect(r.left(), r.top(), r.right(), r.bottom())
+
+void QHaikuBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
+{
+    Q_UNUSED(region);
+
+    if (m_image.size().isEmpty())
+        return;
+
+    QSize imageSize = m_image.size();
+
+    QRegion clipped = QRect(0, 0, window->width(), window->height());
+    clipped &= QRect(0, 0, imageSize.width(), imageSize.height()).translated(-offset);
+
+    QRect bounds = clipped.boundingRect().translated(offset);
+
+    if (bounds.isNull())
+        return;
+
+    WId id = window->winId();
+    
+    QHaikuWindow *wnd = (QHaikuWindow*)(id);
+    FBView *view = wnd->m_window->View();        
+
+    QRect outline = region.boundingRect();
+    
+    if(view->LockLooper()) {
+    	view->SetViewBitmap(m_bitmap);
+    	BRect rect(outline.left(), outline.top(), outline.right(), outline.bottom());
+    	view->DrawBitmap(m_bitmap, rect, rect);
+    	view->UnlockLooper();
+    }
+        
+    m_windowAreaHash[id] = bounds;
+    m_backingStoreForWinIdHash[id] = this;
+}
+
+void QHaikuBackingStore::resize(const QSize &size, const QRegion &)
+{
+    WId id = window()->winId();
+
+    QImage::Format format = QGuiApplication::primaryScreen()->handle()->format();
+    if (m_image.size() != size) {
+		QHaikuWindow *wnd = (QHaikuWindow*)(id);
+    	FBView *view = wnd->m_window->View();
+    	if(view->LockLooper()) {
+    		m_image = QImage();
+	        delete m_bitmap;
+
+			BRect rect(0, 0, size.width() - 1, size.height() - 1);
+			m_bitmap = new BBitmap(rect, B_RGB32, true);
+	    	view->SetViewBitmap(m_bitmap);
+			m_image = QImage((uchar*)m_bitmap->Bits(), size.width(), size.height(), m_bitmap->BytesPerRow(), QImage::Format_RGB32);			
+			view->UnlockLooper();
+    	}
+    }
+    clearHash();        
+}
+
+extern void qt_scrollRectInImage(QImage &img, const QRect &rect, const QPoint &offset);
+
+bool QHaikuBackingStore::scroll(const QRegion &area, int dx, int dy)
+{
+    if (m_image.isNull())
+        return false;
+
+    const QVector<QRect> rects = area.rects();
+    for (int i = 0; i < rects.size(); ++i)
+        qt_scrollRectInImage(m_image, rects.at(i), QPoint(dx, dy));
+
+    return true;
+}
+
+QPixmap QHaikuBackingStore::grabWindow(WId window, const QRect &rect) const
+{
+    QRect area = m_windowAreaHash.value(window, QRect());
+    if (area.isNull())
+        return QPixmap();
+
+    QRect adjusted = rect;
+    if (adjusted.width() <= 0)
+        adjusted.setWidth(area.width());
+    if (adjusted.height() <= 0)
+        adjusted.setHeight(area.height());
+
+    adjusted = adjusted.translated(area.topLeft()) & area;
+
+    if (adjusted.isEmpty())
+        return QPixmap();
+
+    return QPixmap::fromImage(m_image.copy(adjusted));
+}
+
+QHaikuBackingStore *QHaikuBackingStore::backingStoreForWinId(WId id)
+{
+    return m_backingStoreForWinIdHash.value(id, 0);
+}
+
+void QHaikuBackingStore::clearHash()
+{
+    QList<WId> ids = m_windowAreaHash.keys();
+    foreach (WId id, ids) {
+        QHash<WId, QHaikuBackingStore *>::iterator it = m_backingStoreForWinIdHash.find(id);
+        if (it.value() == this)
+            m_backingStoreForWinIdHash.remove(id);
+    }
+    m_windowAreaHash.clear();
+}
+
+QHash<WId, QHaikuBackingStore *> QHaikuBackingStore::m_backingStoreForWinIdHash;
+
+QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikurasterbackingstore.h b/qtbase/src/plugins/platforms/haiku/qhaikucommon.h
similarity index 57%
rename from qtbase/src/plugins/platforms/haiku/qhaikurasterbackingstore.h
rename to qtbase/src/plugins/platforms/haiku/qhaikucommon.h
index 06a46e7..66c0014 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikurasterbackingstore.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikucommon.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -37,32 +37,80 @@
 **
 ****************************************************************************/
 
-#ifndef QHAIKURASTERWINDOWSURFACE_H
-#define QHAIKURASTERWINDOWSURFACE_H
+#ifndef QHAIKUCOMMON_H
+#define QHAIKUCOMMON_H
+
+#include "qhaikucursor.h"
 
 #include <qpa/qplatformbackingstore.h>
+#include <qpa/qplatformdrag.h>
+#include <qpa/qplatformintegration.h>
+#include <qpa/qplatformscreen.h>
+#include <qpa/qplatformwindow.h>
+
+#include <qscopedpointer.h>
+#include <qimage.h>
+#include <qhash.h>
 
-#include "qhaikubuffer.h"
+#include <Screen.h>
+#include <View.h>
+#include <Bitmap.h>
 
 QT_BEGIN_NAMESPACE
 
-class BBitmap;
-class QHaikuRasterWindow;
+class QHaikuScreen : public QPlatformScreen, public BScreen
+{
+public:
+    QHaikuScreen();
+    ~QHaikuScreen();
+
+    QRect geometry() const { return m_geometry; }
+    int depth() const { return 32; }
+    QImage::Format format() const { return QImage::Format_RGB32; }
+	QPlatformCursor *cursor() const;
+	
+    QPixmap grabWindow(WId window, int x, int y, int width, int height) const;
+
+//    static QPlatformWindow *windowContainingCursor;
+
+public:
+    QRect m_geometry;
+    QHaikuCursor *m_cursor;
+};
 
-class QHaikuRasterBackingStore : public QPlatformBackingStore
+//#ifndef QT_NO_DRAGANDDROP
+class QHaikuDrag : public QPlatformDrag
 {
 public:
-    explicit QHaikuRasterBackingStore(QWindow *window);
-    ~QHaikuRasterBackingStore();
+    QMimeData *platformDropData() { return 0; }
+    Qt::DropAction drag(QDrag *) { return Qt::IgnoreAction; }
+};
+//#endif
+
+class QHaikuBackingStore : public QPlatformBackingStore
+{
+public:
+    QHaikuBackingStore(QWindow *window);
+    ~QHaikuBackingStore();
 
-    QPaintDevice *paintDevice() Q_DECL_OVERRIDE;
-    void flush(QWindow *window, const QRegion &region, const QPoint &offset) Q_DECL_OVERRIDE;
-    void resize(const QSize &size, const QRegion &staticContents) Q_DECL_OVERRIDE;
+    QPaintDevice *paintDevice();
+    void flush(QWindow *window, const QRegion &region, const QPoint &offset);
+    void resize(const QSize &size, const QRegion &staticContents);
+    bool scroll(const QRegion &area, int dx, int dy);
+
+    QPixmap grabWindow(WId window, const QRect &rect) const;
+
+    static QHaikuBackingStore *backingStoreForWinId(WId id);
 
 private:
+    void clearHash();
+
+    QImage m_image;
     BBitmap *m_bitmap;
-    QHaikuBuffer m_buffer;
-    QSize m_bufferSize;
+    
+    QHash<WId, QRect> m_windowAreaHash;
+
+    static QHash<WId, QHaikuBackingStore *> m_backingStoreForWinIdHash;
 };
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikucursor.cpp b/qtbase/src/plugins/platforms/haiku/qhaikucursor.cpp
index d8e79f1..f8840d3 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikucursor.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikucursor.cpp
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -37,62 +37,68 @@
 **
 ****************************************************************************/
 
-#include "qhaikucursor.h"
+#include <QtGui/private/qpixmap_raster_p.h>
+#include <QtGui/private/qguiapplication_p.h>
+
+#include <qpa/qplatformcursor.h>
+#include <qpa/qplatformwindow.h>
+#include <qdebug.h>
+
+#include <Application.h>
 
-#include "qhaikurasterwindow.h"
+#include "qhaikucursor.h"
 
-#include <Cursor.h>
+QT_BEGIN_NAMESPACE
 
 QHaikuCursor::QHaikuCursor()
 {
-    m_cursorIds.insert(Qt::ArrowCursor, B_CURSOR_ID_SYSTEM_DEFAULT);
-    m_cursorIds.insert(Qt::UpArrowCursor, B_CURSOR_ID_RESIZE_NORTH);
-    m_cursorIds.insert(Qt::CrossCursor, B_CURSOR_ID_CROSS_HAIR);
-    m_cursorIds.insert(Qt::WaitCursor, B_CURSOR_ID_PROGRESS);
-    m_cursorIds.insert(Qt::IBeamCursor, B_CURSOR_ID_I_BEAM);
-    m_cursorIds.insert(Qt::SizeVerCursor, B_CURSOR_ID_RESIZE_NORTH_SOUTH);
-    m_cursorIds.insert(Qt::SizeHorCursor, B_CURSOR_ID_RESIZE_EAST_WEST);
-    m_cursorIds.insert(Qt::SizeBDiagCursor, B_CURSOR_ID_RESIZE_NORTH_EAST_SOUTH_WEST);
-    m_cursorIds.insert(Qt::SizeFDiagCursor, B_CURSOR_ID_RESIZE_NORTH_WEST_SOUTH_EAST);
-    m_cursorIds.insert(Qt::SizeAllCursor, B_CURSOR_ID_MOVE);
-    m_cursorIds.insert(Qt::BlankCursor, B_CURSOR_ID_NO_CURSOR);
-    m_cursorIds.insert(Qt::SplitVCursor, B_CURSOR_ID_RESIZE_NORTH_SOUTH);
-    m_cursorIds.insert(Qt::SplitHCursor, B_CURSOR_ID_RESIZE_EAST_WEST);
-    m_cursorIds.insert(Qt::PointingHandCursor, B_CURSOR_ID_FOLLOW_LINK);
-    m_cursorIds.insert(Qt::ForbiddenCursor, B_CURSOR_ID_NOT_ALLOWED);
-    m_cursorIds.insert(Qt::OpenHandCursor, B_CURSOR_ID_GRAB);
-    m_cursorIds.insert(Qt::ClosedHandCursor, B_CURSOR_ID_GRABBING);
-    m_cursorIds.insert(Qt::WhatsThisCursor, B_CURSOR_ID_HELP);
-    m_cursorIds.insert(Qt::BusyCursor, B_CURSOR_ID_PROGRESS);
+	m_cursorHash.insert(Qt::ArrowCursor, new BCursor(B_CURSOR_ID_SYSTEM_DEFAULT));
+	m_cursorHash.insert(Qt::UpArrowCursor, new BCursor(B_CURSOR_ID_RESIZE_NORTH));
+	m_cursorHash.insert(Qt::CrossCursor, new BCursor(B_CURSOR_ID_CROSS_HAIR));
+	m_cursorHash.insert(Qt::WaitCursor, new BCursor(B_CURSOR_ID_PROGRESS));
+	m_cursorHash.insert(Qt::IBeamCursor, new BCursor(B_CURSOR_ID_I_BEAM));
+	m_cursorHash.insert(Qt::SizeVerCursor, new BCursor(B_CURSOR_ID_RESIZE_NORTH_SOUTH));
+	m_cursorHash.insert(Qt::SizeHorCursor, new BCursor(B_CURSOR_ID_RESIZE_EAST_WEST));
+	m_cursorHash.insert(Qt::SizeBDiagCursor, new BCursor(B_CURSOR_ID_RESIZE_NORTH_EAST_SOUTH_WEST));
+	m_cursorHash.insert(Qt::SizeFDiagCursor, new BCursor(B_CURSOR_ID_RESIZE_NORTH_WEST_SOUTH_EAST));
+	m_cursorHash.insert(Qt::SizeAllCursor, new BCursor(B_CURSOR_ID_MOVE));
+	m_cursorHash.insert(Qt::BlankCursor, new BCursor(B_CURSOR_ID_NO_CURSOR));
+	m_cursorHash.insert(Qt::SplitVCursor, new BCursor(B_CURSOR_ID_RESIZE_NORTH_SOUTH));
+	m_cursorHash.insert(Qt::SplitHCursor, new BCursor(B_CURSOR_ID_RESIZE_EAST_WEST));
+	m_cursorHash.insert(Qt::PointingHandCursor, new BCursor(B_CURSOR_ID_FOLLOW_LINK));
+	m_cursorHash.insert(Qt::ForbiddenCursor, new BCursor(B_CURSOR_ID_NOT_ALLOWED));
+	m_cursorHash.insert(Qt::OpenHandCursor, new BCursor(B_CURSOR_ID_GRAB));
+	m_cursorHash.insert(Qt::ClosedHandCursor, new BCursor(B_CURSOR_ID_GRABBING));
+	m_cursorHash.insert(Qt::WhatsThisCursor, new BCursor(B_CURSOR_ID_HELP));
+	m_cursorHash.insert(Qt::BusyCursor, new BCursor(B_CURSOR_ID_PROGRESS));
 }
 
-#ifndef QT_NO_CURSOR
-void QHaikuCursor::changeCursor(QCursor *windowCursor, QWindow *window)
+QHaikuCursor::~QHaikuCursor()
 {
-    if (!window)
-        return;
+	foreach (BCursor *cursor, m_cursorHash)
+		delete cursor;
+}
 
-    BWindow *haikuWindow = reinterpret_cast<BWindow*>(window->winId());
+void QHaikuCursor::changeCursor(QCursor *windowCursor, QWindow *window)
+{	
+	if (windowCursor != NULL) {
+		BCursor *cursor = m_cursorHash.value(windowCursor->shape(), NULL);
+		if (cursor != NULL) {
+			be_app->SetCursor(cursor);
+			return;
+		}
+	}
+	be_app->SetCursor((BCursor*)B_CURSOR_SYSTEM_DEFAULT);
+}
+/*
+void QHaikuCursor::setPos(const QPoint &pos)
+{
+    m_pos = pos;
+}
 
-    // We expect that every BWindow has exactly one BView as child,
-    // so we can use CurrentFocus to retrieve it and call SetViewCursor
-    // to change the cursor for the whole window.
-    if (!windowCursor) {
-        BView *view = haikuWindow->CurrentFocus();
-        if (view) {
-            view->SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);
-        }
-    } else {
-        const Qt::CursorShape shape = windowCursor->shape();
-        if (!m_cursors.contains(shape))
-            m_cursors.insert(shape, new BCursor(m_cursorIds.value(shape)));
+QPoint QHaikuCursor::pos() const
+{
+    return m_pos;
+}*/
 
-        BView *view = haikuWindow->CurrentFocus();
-        if (view) {
-            view->LockLooper();
-            view->SetViewCursor(m_cursors.value(shape));
-            view->UnlockLooper();
-        }
-    }
-}
-#endif
+QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikucursor.h b/qtbase/src/plugins/platforms/haiku/qhaikucursor.h
index 5d70c97..e9c8156 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikucursor.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikucursor.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -41,7 +41,6 @@
 #define QHAIKUCURSOR_H
 
 #include <qpa/qplatformcursor.h>
-
 #include <Cursor.h>
 
 QT_BEGIN_NAMESPACE
@@ -49,17 +48,17 @@ QT_BEGIN_NAMESPACE
 class QHaikuCursor : public QPlatformCursor
 {
 public:
-    QHaikuCursor();
-
-#ifndef QT_NO_CURSOR
-    void changeCursor(QCursor *windowCursor, QWindow *window) Q_DECL_OVERRIDE;
-#endif
-
+    explicit QHaikuCursor();
+    ~QHaikuCursor();
+    void changeCursor(QCursor * windowCursor, QWindow *);
+//    void setPos(const QPoint &pos);
+//    QPoint pos() const;
 private:
-    QHash<Qt::CursorShape, BCursorID> m_cursorIds;
-    QHash<Qt::CursorShape, BCursor*> m_cursors;
+	typedef QHash<int, BCursor*> CursorHash;
+	CursorHash m_cursorHash;
+    QPoint m_pos;
 };
 
 QT_END_NAMESPACE
 
-#endif
+#endif // QHAIKUCURSOR_H
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
index d46d77f..5a55498 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -38,102 +38,225 @@
 ****************************************************************************/
 
 #include "qhaikuintegration.h"
+#include "qhaikuwindow.h"
+#include "qhaikucommon.h"
+#include "qhaikutheme.h"
+
+#include <QtPlatformSupport/private/qgenericunixeventdispatcher_p.h>
+#include <qpa/qplatformfontdatabase.h>
+#include <QtPlatformSupport/private/qgenericunixfontdatabase_p.h>
+#include <QtPlatformSupport/private/qbasicfontdatabase_p.h>
+#include <QtGui/private/qpixmap_raster_p.h>
+#include <QtGui/private/qguiapplication_p.h>
+
+#include <private/qsimpledrag_p.h>
+
+#include <qpa/qplatformservices.h>
+#include <qpa/qplatformopenglcontext.h>
 
-#include "qhaikuapplication.h"
 #include "qhaikuclipboard.h"
-#include "qhaikurasterbackingstore.h"
-#include "qhaikurasterwindow.h"
-#include "qhaikuscreen.h"
 #include "qhaikuservices.h"
+#include "qhaikuplatformfontdatabase.h"
 
-#include <QCoreApplication>
-#include <QFileInfo>
-#include <qpa/qplatformwindow.h>
-#include <QtEventDispatcherSupport/private/qgenericunixeventdispatcher_p.h>
-
-#include <Application.h>
+#if !defined(QT_NO_OPENGL)
+#include <GLView.h>
+#endif
 
 QT_BEGIN_NAMESPACE
 
-static long int startApplicationThread(void *data)
+template <typename BaseEventDispatcher>
+class QHaikuEventDispatcher : public BaseEventDispatcher
 {
-    QHaikuApplication *app = static_cast<QHaikuApplication*>(data);
-    app->LockLooper();
-    return app->Run();
-}
+public:
+    explicit QHaikuEventDispatcher(QObject *parent = 0)
+        : BaseEventDispatcher(parent)
+    {
+    }
 
-QHaikuIntegration::QHaikuIntegration(const QStringList &parameters)
-    : m_clipboard(new QHaikuClipboard)
-{
-    Q_UNUSED(parameters);
+    bool processEvents(QEventLoop::ProcessEventsFlags flags)
+    {
+        bool didSendEvents = BaseEventDispatcher::processEvents(flags);
 
-    const QString signature = QStringLiteral("application/x-vnd.Qt.%1").arg(QFileInfo(QCoreApplication::applicationFilePath()).fileName());
+        return QWindowSystemInterface::sendWindowSystemEvents(flags) || didSendEvents;
+    }
 
-    QHaikuApplication *app = new QHaikuApplication(signature.toLocal8Bit());
-    be_app = app;
+    bool hasPendingEvents()
+    {
+        return BaseEventDispatcher::hasPendingEvents()
+            || QWindowSystemInterface::windowSystemEventsQueued();
+    }
 
-    const thread_id applicationThreadId = spawn_thread(startApplicationThread, "app_thread", 1, static_cast<void*>(app));
-    resume_thread(applicationThreadId);
-    app->UnlockLooper();
+    void flush()
+    {
+        if (qApp)
+            qApp->sendPostedEvents();
+        BaseEventDispatcher::flush();
+    }
+};
 
-    m_screen = new QHaikuScreen;
+QHaikuIntegration::QHaikuIntegration(const QStringList &parameters, int &argc, char **argv)
+	: QPlatformIntegration()
+	, m_clipboard(0)
+    , m_drag(new QSimpleDrag())
+    , m_services(new QHaikuServices)
+{
+    m_fontDatabase.reset(new QHaikuPlatformFontDatabase());
+    screenAdded(new QHaikuScreen);
+}
 
-    m_services = new QHaikuServices;
+QHaikuIntegration::~QHaikuIntegration()
+{
+    delete m_drag;
+	delete m_clipboard;
+}
 
-    // notify system about available screen
-    screenAdded(m_screen);
+bool QHaikuIntegration::hasCapability(QPlatformIntegration::Capability cap) const
+{
+    switch (cap) {
+    case ThreadedPixmaps: return true;
+ //   case OpenGL: return true;
+//    case ThreadedOpenGL: return true;
+    case MultipleWindows: return true;
+//    case WindowMasks: return true;
+ //   case ForeignWindows: return true;
+
+    default: return QPlatformIntegration::hasCapability(cap);
+    }
 }
 
-QHaikuIntegration::~QHaikuIntegration()
+QPlatformWindow *QHaikuIntegration::createPlatformWindow(QWindow *window) const
 {
-    destroyScreen(m_screen);
-    m_screen = Q_NULLPTR;
+    Q_UNUSED(window);
+    QPlatformWindow *w = new QHaikuWindow(window);
+    w->requestActivateWindow();
+    return w;
+}
 
-    delete m_services;
-    m_services = Q_NULLPTR;
+QStringList QHaikuIntegration::themeNames() const
+{
+    return QStringList(QHaikuTheme::name());
+}
 
-    delete m_clipboard;
-    m_clipboard = Q_NULLPTR;
+QPlatformTheme *QHaikuIntegration::createPlatformTheme(const QString &name) const
+{
+    if (name == QHaikuTheme::name())
+        return new QHaikuTheme(this);
+    return 0;
+}
+
+QPlatformBackingStore *QHaikuIntegration::createPlatformBackingStore(QWindow *window) const
+{
+    return new QHaikuBackingStore(window);
+}
 
-    be_app->LockLooper();
-    be_app->Quit();
+#if !defined(QT_NO_OPENGL)
+QPlatformOpenGLContext *QHaikuIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
+{
+    qDebug() << "Create GL context";
+    return new QHaikuGLContext(context);
 }
+#endif
 
-bool QHaikuIntegration::hasCapability(QPlatformIntegration::Capability capability) const
+QAbstractEventDispatcher *QHaikuIntegration::createEventDispatcher() const
 {
-    return QPlatformIntegration::hasCapability(capability);
+    return createUnixEventDispatcher();
 }
 
 QPlatformFontDatabase *QHaikuIntegration::fontDatabase() const
 {
-    return QPlatformIntegration::fontDatabase();
+    return m_fontDatabase.data();
 }
 
-QPlatformServices *QHaikuIntegration::services() const
+QPlatformDrag *QHaikuIntegration::drag() const
 {
-    return m_services;
+    return m_drag;
 }
 
 QPlatformClipboard *QHaikuIntegration::clipboard() const
 {
+    if (!m_clipboard)
+        m_clipboard = new QHaikuClipboard;
+        
     return m_clipboard;
 }
 
-QPlatformWindow *QHaikuIntegration::createPlatformWindow(QWindow *window) const
+QPlatformServices *QHaikuIntegration::services() const
 {
-    QPlatformWindow *platformWindow = new QHaikuRasterWindow(window);
-    platformWindow->requestActivateWindow();
-    return platformWindow;
+    return m_services;
 }
 
-QPlatformBackingStore *QHaikuIntegration::createPlatformBackingStore(QWindow *window) const
+#if !defined(QT_NO_OPENGL)
+QHaikuGLContext::QHaikuGLContext(QOpenGLContext *context)
+	: QPlatformOpenGLContext()  
 {
-    return new QHaikuRasterBackingStore(window);
+	d_format = context->format();
+//	BWindow *win = new BWindow(BRect(100,100,100+640,100+480), "GL",B_TITLED_WINDOW,0);	
+	glview = new BGLView(BRect(0,0,640,480), "bglview", B_FOLLOW_ALL_SIDES, 0, BGL_RGB | BGL_DOUBLE);
+//	win->AddChild(glview);
+//	win->Show();
+	qDebug() << "QHaikuGLContext";
 }
 
-QAbstractEventDispatcher *QHaikuIntegration::createEventDispatcher() const
+QHaikuGLContext::~QHaikuGLContext()
 {
-    return createUnixEventDispatcher();
+	qDebug() << "~QHaikuGLContext";
+//	delete glview;
+}
+
+void (*QHaikuGLContext::getProcAddress(const QByteArray &procName)) ()
+{
+	qDebug() << procName.constData();
+	return (void (*)())glview->GetGLProcAddress(procName.constData());
+}
+
+
+bool QHaikuGLContext::makeCurrent(QPlatformSurface *surface)
+{
+	QSize size = surface->surface()->size();
+	QHaikuWindow *window = static_cast<QHaikuWindow *>(surface);
+	if (window->m_window->fGLView == NULL) {
+		window->m_window->fGLView = glview;
+		window->m_window->Lock();
+		window->m_window->AddChild(glview);
+		glview->ResizeTo(size.width(), size.height());
+		glViewport(0, 0, size.width(), size.height());
+		window->m_window->Unlock();
+	}
+	return true;
+}
+
+void QHaikuGLContext::doneCurrent()
+{
+	//qDebug() << "doneCurrent";
+}
+
+void QHaikuGLContext::swapBuffers(QPlatformSurface *surface)
+{
+	QHaikuWindow *window = static_cast<QHaikuWindow *>(surface);
+
+//	glview->LockGL();
+	window->m_window->fGLView->SwapBuffers();
+//	glview->UnlockGL();
+}
+
+QSurfaceFormat QHaikuGLContext::format() const
+{
+	return QSurfaceFormat();
+    //return d_format;
+}
+/*
+bool QHaikuGLContext::isSharing() const
+{
+//	qDebug() << "isSharing";
+    return false;
 }
 
+bool QHaikuGLContext::isValid() const
+{
+//	qDebug() << "isValid";
+    return true;
+}*/
+
+#endif
+
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.h b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.h
index 1b938ac..8985542 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -41,36 +41,77 @@
 #define QHAIKUINTEGRATION_H
 
 #include <qpa/qplatformintegration.h>
+#include <qpa/qplatformopenglcontext.h>
+#include <qscopedpointer.h>
+
+//OpenGL support disabled for now
+#define QT_NO_OPENGL
+
+#include "qhaikuclipboard.h"
+
+#if !defined(QT_NO_OPENGL)
+#include <GLView.h>
+#endif
 
 QT_BEGIN_NAMESPACE
 
-class QHaikuClipboard;
-class QHaikuScreen;
-class QHaikuServices;
+class QSimpleDrag;
+class QHaikuBackendData;
+
+#if !defined(QT_NO_OPENGL)
+class QHaikuGLContext : public QPlatformOpenGLContext
+{
+public:
+    QHaikuGLContext(QOpenGLContext *context);
+    ~QHaikuGLContext();
+
+    bool makeCurrent(QPlatformSurface *surface);
+    void doneCurrent();
+    void swapBuffers(QPlatformSurface *surface);
+    void (*getProcAddress(const QByteArray &procName)) ();
+
+    QSurfaceFormat format() const;
+  //  bool isSharing() const;
+//    bool isValid() const;
+private:
+	QSurfaceFormat d_format;
+	BGLView *glview;
+};
+#endif
 
 class QHaikuIntegration : public QPlatformIntegration
 {
 public:
-    explicit QHaikuIntegration(const QStringList &paramList);
+    QHaikuIntegration(const QStringList &parameters, int &argc, char **argv);
     ~QHaikuIntegration();
 
-    bool hasCapability(QPlatformIntegration::Capability cap) const Q_DECL_OVERRIDE;
+    bool hasCapability(QPlatformIntegration::Capability cap) const;
 
-    QPlatformWindow *createPlatformWindow(QWindow *window) const Q_DECL_OVERRIDE;
-    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const Q_DECL_OVERRIDE;
-    QAbstractEventDispatcher *createEventDispatcher() const Q_DECL_OVERRIDE;
+    QPlatformWindow *createPlatformWindow(QWindow *window) const;
+    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const;
+#if !defined(QT_NO_OPENGL)    
+    QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const;
+#endif    
+    
+    QPlatformClipboard *clipboard() const;
 
-    QPlatformFontDatabase *fontDatabase() const Q_DECL_OVERRIDE;
-    QPlatformServices *services() const Q_DECL_OVERRIDE;
+    QPlatformDrag *drag() const;
+    QPlatformServices *services() const;
 
-#ifndef QT_NO_CLIPBOARD
-    QPlatformClipboard *clipboard() const Q_DECL_OVERRIDE;
-#endif
+    QPlatformFontDatabase *fontDatabase() const;
+    QAbstractEventDispatcher *createEventDispatcher() const;
+
+    static QHaikuIntegration *createHaikuIntegration(const QStringList& parameters, int &argc, char **argv);
+
+    QStringList themeNames() const;
+    QPlatformTheme *createPlatformTheme(const QString &name) const; 
 
 private:
-    QHaikuClipboard *m_clipboard;
-    QHaikuScreen *m_screen;
-    QHaikuServices *m_services;
+    QScopedPointer<QPlatformFontDatabase> m_fontDatabase;
+    
+    mutable QHaikuClipboard* m_clipboard;
+    QSimpleDrag *m_drag;
+    QPlatformServices *m_services;
 };
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuintegration_haiku.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuintegration_haiku.cpp
new file mode 100644
index 0000000..7eb4ad7
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuintegration_haiku.cpp
@@ -0,0 +1,162 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qhaikuintegration.h"
+
+#include <QtWidgets/qapplication.h>
+#include <qevent.h>
+#include <qdebug.h>
+
+#include <Application.h>
+#include <kernel/OS.h>
+#include <Application.h>
+#include <Path.h>
+#include <Entry.h>
+#include <String.h>
+
+#include <stdio.h>
+
+class HQApplication : public BApplication
+{
+public:
+	HQApplication(const char*);
+	~HQApplication();
+
+	virtual void MessageReceived(BMessage *message);
+	void	ArgvReceived(int32 argc, char **argv);
+	void	RefsReceived(BMessage *pmsg);
+	virtual	bool QuitRequested();
+	bool	RefHandled;
+	entry_ref Ref;
+private:
+	BPath 	refReceived;
+	BMessenger  fTrackerMessenger;
+};
+
+namespace {
+static HQApplication* haikuApplication = NULL;
+}
+
+HQApplication::HQApplication(const char* signature)
+		: BApplication(signature)
+{
+	RefHandled = false;	
+}
+
+HQApplication::~HQApplication()
+{
+}
+
+void HQApplication::MessageReceived(BMessage* msg)
+{
+	BApplication::MessageReceived(msg);
+}
+
+void 
+HQApplication::RefsReceived(BMessage *pmsg)
+{
+	if (pmsg->HasMessenger("TrackerViewToken")) {
+		pmsg->FindMessenger("TrackerViewToken", &fTrackerMessenger);
+	}
+
+	uint32 type;
+	int32 count;
+	status_t ret = pmsg->GetInfo("refs", &type, &count);
+	if (ret != B_OK || type != B_REF_TYPE)
+		return;
+
+	entry_ref ref;
+	for (int32 i = 0; i < count; i++) {
+   		if (pmsg->FindRef("refs", i, &ref) == B_OK) {   			
+   			refReceived.SetTo(&ref);
+   			Ref = ref;
+   			if (RefHandled) {
+   				QCoreApplication::postEvent(qApp, new QFileOpenEvent(refReceived.Path()));
+   			}
+   			RefHandled = true;
+   		}
+   	}
+}
+
+void
+HQApplication::ArgvReceived(int32 argc, char **argv)
+{
+}
+
+bool 
+HQApplication::QuitRequested() {
+    QCoreApplication::postEvent(qApp, new QEvent(QEvent::Quit));
+	return false;
+}
+
+int32 AppThread(void *data)
+{
+	HQApplication *app = (HQApplication*)data;
+	app->LockLooper();
+	app->Run();	
+}
+
+
+QHaikuIntegration *QHaikuIntegration::createHaikuIntegration(const QStringList& parameters, int &argc, char **argv)
+{
+	thread_id my_thread;
+	QString appSignature = QLatin1String("application/x-vnd.qt5-") + QCoreApplication::applicationName();
+	haikuApplication = new HQApplication(appSignature.toUtf8());
+	be_app = haikuApplication;
+
+	my_thread = spawn_thread(AppThread, "BApplication_thread", B_NORMAL_PRIORITY, (void*)haikuApplication);
+	resume_thread(my_thread);
+		
+	haikuApplication->UnlockLooper();
+	
+	if(argc==1) {
+		for(int i=0;i<100;i++) {
+			if(haikuApplication->RefHandled) {
+				BPath p(&haikuApplication->Ref);
+				argc = 2;
+				argv[1]=strdup(p.Path());
+				argv[2]=0;
+				break;
+			}
+			snooze(1000);
+		}
+	}
+	
+    return new QHaikuIntegration(parameters, argc, argv);
+}
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikukeymapper.cpp b/qtbase/src/plugins/platforms/haiku/qhaikukeymapper.cpp
deleted file mode 100644
index 3862fac..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikukeymapper.cpp
+++ /dev/null
@@ -1,186 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qhaikukeymapper.h"
-
-QT_BEGIN_NAMESPACE
-
-uint32 Haiku_ScanCodes[] = {
-    Qt::Key_Escape,       0x01,
-    Qt::Key_F1,           0x02,
-    Qt::Key_F2,           0x03,
-    Qt::Key_F3,           0x04,
-    Qt::Key_F4,           0x05,
-    Qt::Key_F5,           0x06,
-    Qt::Key_F6,           0x07,
-    Qt::Key_F7,           0x08,
-    Qt::Key_F8,           0x09,
-    Qt::Key_F9,           0x0A,
-    Qt::Key_F10,          0x0B,
-    Qt::Key_F11,          0x0C,
-    Qt::Key_F12,          0x0D,
-    Qt::Key_Print,        0x0E,
-    Qt::Key_Pause,        0x22,
-    Qt::Key_AsciiTilde,   0x11,
-    Qt::Key_1,            0x12,
-    Qt::Key_2,            0x13,
-    Qt::Key_3,            0x14,
-    Qt::Key_4,            0x15,
-    Qt::Key_5,            0x16,
-    Qt::Key_6,            0x17,
-    Qt::Key_7,            0x18,
-    Qt::Key_8,            0x19,
-    Qt::Key_9,            0x1A,
-    Qt::Key_0,            0x1B,
-    Qt::Key_Minus,        0x1C,
-    Qt::Key_Plus,         0x1D,
-    Qt::Key_Backspace,    0x1E,
-    Qt::Key_Insert,       0x1F,
-    Qt::Key_Home,         0x20,
-    Qt::Key_PageUp,       0x21,
-    Qt::Key_Slash,        0x23,
-    Qt::Key_Asterisk,     0x24,
-    Qt::Key_Minus,        0x25,
-    Qt::Key_Tab,          0x26,
-    Qt::Key_Q,            0x27,
-    Qt::Key_W,            0x28,
-    Qt::Key_E,            0x29,
-    Qt::Key_R,            0x2A,
-    Qt::Key_T,            0x2B,
-    Qt::Key_Y,            0x2C,
-    Qt::Key_U,            0x2D,
-    Qt::Key_I,            0x2E,
-    Qt::Key_O,            0x2F,
-    Qt::Key_P,            0x30,
-    Qt::Key_BracketLeft,  0x31,
-    Qt::Key_BracketRight, 0x32,
-    Qt::Key_Backslash,    0x33,
-    Qt::Key_Delete,       0x34,
-    Qt::Key_End,          0x35,
-    Qt::Key_PageDown,     0x36,
-    Qt::Key_Home,         0x37, // numpad
-    Qt::Key_Up,           0x38, // numpad
-    Qt::Key_PageUp,       0x39, // numpad
-    Qt::Key_Plus,         0x3A, // numpad
-    Qt::Key_A,            0x3C,
-    Qt::Key_S,            0x3D,
-    Qt::Key_D,            0x3E,
-    Qt::Key_F,            0x3F,
-    Qt::Key_G,            0x40,
-    Qt::Key_H,            0x41,
-    Qt::Key_J,            0x42,
-    Qt::Key_K,            0x43,
-    Qt::Key_L,            0x44,
-    Qt::Key_Colon,        0x45,
-    Qt::Key_QuoteDbl,     0x46,
-    Qt::Key_Return,       0x47,
-    Qt::Key_Left,         0x48, // numpad
-    Qt::Key_5,            0x49, // numpad ???
-    Qt::Key_Right,        0x4A, // numpad
-    Qt::Key_Z,            0x4C,
-    Qt::Key_X,            0x4D,
-    Qt::Key_C,            0x4E,
-    Qt::Key_V,            0x4F,
-    Qt::Key_B,            0x50,
-    Qt::Key_N,            0x51,
-    Qt::Key_M,            0x51,
-    Qt::Key_Less,         0x52,
-    Qt::Key_Greater,      0x54,
-    Qt::Key_Question,     0x55,
-    Qt::Key_Up,           0x57, // cursor
-    Qt::Key_End,          0x58, // numpad
-    Qt::Key_Down,         0x59, // numpad
-    Qt::Key_PageDown,     0x5A, // numpad
-    Qt::Key_Enter,        0x5B, // numpad
-    Qt::Key_Space,        0x5E,
-    Qt::Key_Left,         0x61, // cursor
-    Qt::Key_Down,         0x62, // cursor
-    Qt::Key_Right,        0x63, // cursor
-    Qt::Key_Insert,       0x64, // cursor
-    Qt::Key_Delete,       0x65, // numpad
-    0,                    0x00
-};
-
-uint32 Haiku_ScanCodes_Numlock[] = {
-    Qt::Key_7,     0x37,
-    Qt::Key_8,     0x38,
-    Qt::Key_9,     0x39,
-    Qt::Key_Plus,  0x3A,
-    Qt::Key_4,     0x48,
-    Qt::Key_5,     0x49,
-    Qt::Key_6,     0x4A,
-    Qt::Key_1,     0x58,
-    Qt::Key_2,     0x59,
-    Qt::Key_3,     0x5A,
-    Qt::Key_Enter, 0x5B,
-    Qt::Key_Comma, 0x65,
-    0,             0x00
-};
-
-uint32 QHaikuKeyMapper::translateKeyCode(uint32 key, bool numlockActive)
-{
-    uint32 code = 0;
-    int i = 0;
-
-    if (numlockActive) {
-        while (Haiku_ScanCodes_Numlock[i]) {
-            if (key == Haiku_ScanCodes_Numlock[i + 1]) {
-                code = Haiku_ScanCodes_Numlock[i];
-                break;
-            }
-            i += 2;
-        }
-
-        if (code > 0)
-            return code;
-    }
-
-    i = 0;
-    while (Haiku_ScanCodes[i]) {
-        if (key == Haiku_ScanCodes[i + 1]) {
-            code = Haiku_ScanCodes[i];
-            break;
-        }
-        i += 2;
-    }
-
-    return code;
-}
-
-QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuplatformdialoghelpers.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuplatformdialoghelpers.cpp
new file mode 100644
index 0000000..09a458f
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformdialoghelpers.cpp
@@ -0,0 +1,149 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qhaikuplatformdialoghelpers.h"
+
+#include <QTextDocument>
+
+#include <private/qguiapplication_p.h>
+#include <qpa/qplatformtheme.h>
+#include <QtWidgets/qmessagebox.h>
+#include <qdebug.h>
+
+#include <Alert.h>
+#include <TextView.h>
+
+namespace QtHaikuDialogHelpers {
+
+QHaikuPlatformMessageDialogHelper::QHaikuPlatformMessageDialogHelper()
+    :m_buttonId(-1)
+    ,m_shown(false)
+{
+}
+
+void QHaikuPlatformMessageDialogHelper::exec()
+{
+    if (!m_shown)
+        show(Qt::Dialog, Qt::ApplicationModal, 0);
+}
+
+static QString htmlText(QString text)
+{
+    if (Qt::mightBeRichText(text))
+        return text;
+    text.remove(QLatin1Char('\r'));
+    return text.toHtmlEscaped().replace(QLatin1Char('\n'), QLatin1String("<br />"));
+}
+
+bool QHaikuPlatformMessageDialogHelper::show(Qt::WindowFlags windowFlags
+                                         , Qt::WindowModality windowModality
+                                         , QWindow *parent)
+{
+    QSharedPointer<QMessageDialogOptions> options = this->options();
+    if (!options.data())
+        return false;
+
+    const QString informativeText = options->informativeText();
+    const QString title = options->windowTitle();
+    const QString text = informativeText.isEmpty() ? options->text() : (options->text() + QLatin1Char('\n') + informativeText);
+    
+    alert_type type = B_INFO_ALERT;
+    switch (options->icon()) {
+    	case QMessageBox::NoIcon:
+    		type = B_EMPTY_ALERT;
+    		break;
+    	case QMessageBox::Information:
+    		type = B_INFO_ALERT;
+    		break;
+		case QMessageBox::Warning:
+			type = B_WARNING_ALERT;
+			break;
+		case QMessageBox::Critical:
+			type = B_STOP_ALERT;
+			break;			
+		case QMessageBox::Question:
+			type = B_INFO_ALERT; //?
+			break;
+		default:
+			type = B_INFO_ALERT;
+			break;			
+    }    
+	
+	QTextDocument doc;
+	doc.setHtml(text);
+
+	int buttons = options->standardButtons();
+    if (buttons == 0)
+        buttons = QPlatformDialogHelper::Ok;
+
+	const char *nativeButtonText[3] = {NULL, NULL, NULL};
+	int	buttonsIds[3] = {0, 0, 0};
+	int32 buttonsCount = 0;
+	
+    for (int i = QPlatformDialogHelper::FirstButton; i < QPlatformDialogHelper::LastButton; i<<=1) {
+        if (buttons & i) {
+			if (buttonsCount > 2)
+				return false;
+            QString label = QGuiApplicationPrivate::platformTheme()->standardButtonText(i);
+            label.remove(QChar('&'));
+            nativeButtonText[buttonsCount] = strdup(label.toUtf8());
+            buttonsIds[buttonsCount] = i;
+            buttonsCount++;
+        }
+    }
+	
+	BAlert* alert = new BAlert(title.toUtf8(), doc.toPlainText().toUtf8(),
+		nativeButtonText[0], nativeButtonText[1], nativeButtonText[2], B_WIDTH_AS_USUAL, type);
+	
+	int buttonId = buttonsIds[alert->Go()];
+
+    QPlatformDialogHelper::StandardButton standardButton = static_cast<QPlatformDialogHelper::StandardButton>(buttonId);
+    QPlatformDialogHelper::ButtonRole role = QPlatformDialogHelper::buttonRole(standardButton);
+    emit clicked(standardButton, role);
+
+	m_shown = true;
+    return true;
+}
+
+void QHaikuPlatformMessageDialogHelper::hide()
+{
+    m_shown = false;
+}
+
+}
diff --git a/qtbase/src/plugins/platforms/haiku/main.h b/qtbase/src/plugins/platforms/haiku/qhaikuplatformdialoghelpers.h
similarity index 75%
rename from qtbase/src/plugins/platforms/haiku/main.h
rename to qtbase/src/plugins/platforms/haiku/qhaikuplatformdialoghelpers.h
index 82f3313..e6a87bb 100644
--- a/qtbase/src/plugins/platforms/haiku/main.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformdialoghelpers.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2013 BogDan Vatra <bogdan@kde.org>
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -37,17 +37,31 @@
 **
 ****************************************************************************/
 
-#include <qpa/qplatformintegrationplugin.h>
+#ifndef QHAIKUPLATFORMDIALOGHELPERS_H
+#define QHAIKUPLATFORMDIALOGHELPERS_H
 
-QT_BEGIN_NAMESPACE
+#include <qpa/qplatformdialoghelper.h>
+#include <QEventLoop>
 
-class QHaikuIntegrationPlugin : public QPlatformIntegrationPlugin
+namespace QtHaikuDialogHelpers {
+
+class QHaikuPlatformMessageDialogHelper: public QPlatformMessageDialogHelper
 {
     Q_OBJECT
-    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "haiku.json")
-
 public:
-    QPlatformIntegration *create(const QString&, const QStringList&) Q_DECL_OVERRIDE;
+    QHaikuPlatformMessageDialogHelper();
+    void exec();
+    bool show(Qt::WindowFlags windowFlags,
+                          Qt::WindowModality windowModality,
+                          QWindow *parent);
+    void hide();
+    
+private:
+    int m_buttonId;
+    bool m_shown;
 };
 
-QT_END_NAMESPACE
+
+}
+
+#endif // QHAIKUPLATFORMDIALOGHELPERS_H
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
new file mode 100644
index 0000000..0b5d24c
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
@@ -0,0 +1,149 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QDir>
+#include <QDirIterator>
+#include <QtGui/private/qfontengine_ft_p.h>
+
+#include "qhaikuplatformfontdatabase.h"
+
+#include <Path.h>
+#include <PathFinder.h>
+#include <String.h>
+#include <StringList.h>
+
+QString QHaikuPlatformFontDatabase::fontDir() const
+{
+    return QLatin1String("/boot/system/data/fonts/ttfonts");
+}
+
+void QHaikuPlatformFontDatabase::populateFontDatabase()
+{
+    QString fontpath = fontDir();
+
+    if (!QFile::exists(fontpath)) {
+        qFatal("QFontDatabase: Cannot find font directory %s - is Qt installed correctly?",
+               qPrintable(fontpath));
+    }
+
+	BStringList fontPaths;
+	BPathFinder::FindPaths(NULL, B_FIND_PATH_FONTS_DIRECTORY,
+		NULL, B_FIND_PATH_EXISTING_ONLY, fontPaths);
+	
+	for (int32 i = 0; i < fontPaths.CountStrings(); i++) {
+	    QDir dir(QLatin1String(fontPaths.StringAt(i).String()));
+		QDirIterator qdi(dir.absolutePath(),
+            QStringList() << "*.ttf",
+            QDir::Files, QDirIterator::Subdirectories);
+    	while (qdi.hasNext()) {
+			const QByteArray file = QFile::encodeName(qdi.next());
+        	QStringList families = addTTFile(QByteArray(), file);
+    	}
+    }
+}
+
+QStringList QHaikuPlatformFontDatabase::fallbacksForFamily(const QString &family,
+                                                             QFont::Style style,
+                                                             QFont::StyleHint styleHint,
+                                                             QChar::Script script) const
+{
+	QStringList result = QPlatformFontDatabase::fallbacksForFamily(family, style, styleHint, script);
+    
+    if (!result.isEmpty())
+        return result;
+
+    switch (styleHint) {
+        case QFont::Times:
+            result << QString::fromLatin1("DejaVu Serif");
+            break;
+        case QFont::Courier:
+            result << QString::fromLatin1("DejaVu Sans Mono");
+            break;
+        case QFont::Monospace:
+            result << QString::fromLatin1("DejaVu Sans Mono");
+            break;
+        case QFont::Cursive:
+        case QFont::Fantasy:
+        case QFont::Decorative:
+        case QFont::Helvetica:
+        case QFont::System:
+        default:
+            result << QString::fromLatin1("DejaVu Sans");
+    }
+
+    return result;
+}
+
+QFont QHaikuPlatformFontDatabase::defaultFont() const
+{
+	QFont font(QStringLiteral("DejaVu Sans"));
+	font.setStretch(QFont::SemiExpanded);
+    return font;
+}
+
+QFontEngine *QHaikuPlatformFontDatabase::fontEngine(const QFontDef &fontDef, void *handle)
+{
+    if (!handle) // Happens if a font family population failed
+        return 0;
+
+    QFontEngine::FaceId faceId;
+	FontFile *fontfile = static_cast<FontFile *>(handle);
+	faceId.filename = fontfile->fileName.toLocal8Bit();
+	faceId.index = fontfile->indexValue;	
+
+    const bool antialias = !(fontDef.styleStrategy & QFont::NoAntialias);
+    
+    QFontEngineFT::GlyphFormat format = antialias ? QFontEngineFT::Format_A8 : QFontEngineFT::Format_Mono;
+    QFontEngineFT *engine = new QFontEngineFT(fontDef);
+    if (!engine->init(faceId, antialias, format) || engine->invalid()) {
+        delete engine;
+        return 0;
+    }
+    
+    engine->setDefaultHintStyle(QFontEngine::HintFull);
+
+    return engine;
+}
+
+void QHaikuPlatformFontDatabase::releaseHandle(void *handle)
+{
+    if (!handle)
+        return;
+    QBasicFontDatabase::releaseHandle(handle);
+}
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikubuffer.h b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
similarity index 68%
rename from qtbase/src/plugins/platforms/haiku/qhaikubuffer.h
rename to qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
index bc88e6a..d3a9cbe 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikubuffer.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
@@ -1,6 +1,6 @@
-/***************************************************************************
+/****************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -37,32 +37,25 @@
 **
 ****************************************************************************/
 
-#ifndef QHAIKUBUFFER_H
-#define QHAIKUBUFFER_H
+#ifndef QANDROIDPLATFORMFONTDATABASE_H
+#define QANDROIDPLATFORMFONTDATABASE_H
 
-#include <QtGui/QImage>
+#include <QtPlatformSupport/private/qbasicfontdatabase_p.h>
 
-class BBitmap;
-
-QT_BEGIN_NAMESPACE
-
-class QHaikuBuffer
+class QHaikuPlatformFontDatabase: public QBasicFontDatabase
 {
 public:
-    QHaikuBuffer();
-    QHaikuBuffer(BBitmap *buffer);
-
-    BBitmap* nativeBuffer() const;
-    const QImage *image() const;
-    QImage *image();
-
-    QRect rect() const;
-
+    QString fontDir() const;
+    void populateFontDatabase();
+    QFont defaultFont() const Q_DECL_OVERRIDE;
+    QStringList fallbacksForFamily(const QString &family,
+                                           QFont::Style style,
+                                           QFont::StyleHint styleHint,
+                                           QChar::Script script) const;
+    QFontEngine *fontEngine(const QFontDef &fontDef, void *handle) Q_DECL_OVERRIDE;
+    void releaseHandle(void *handle) Q_DECL_OVERRIDE;
 private:
-    BBitmap *m_buffer;
-    QImage m_image;
+    QHash<QChar::Script, QStringList> m_fallbacks;
 };
 
-QT_END_NAMESPACE
-
-#endif
+#endif // QANDROIDPLATFORMFONTDATABASE_H
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikurasterbackingstore.cpp b/qtbase/src/plugins/platforms/haiku/qhaikurasterbackingstore.cpp
deleted file mode 100644
index ee53f69..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikurasterbackingstore.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qhaikurasterbackingstore.h"
-#include "qhaikurasterwindow.h"
-
-#include <Bitmap.h>
-#include <View.h>
-
-QT_BEGIN_NAMESPACE
-
-QHaikuRasterBackingStore::QHaikuRasterBackingStore(QWindow *window)
-    : QPlatformBackingStore(window)
-    , m_bitmap(Q_NULLPTR)
-{
-}
-
-QHaikuRasterBackingStore::~QHaikuRasterBackingStore()
-{
-    delete m_bitmap;
-    m_bitmap = Q_NULLPTR;
-}
-
-QPaintDevice *QHaikuRasterBackingStore::paintDevice()
-{
-    if (!m_bufferSize.isEmpty() && m_bitmap)
-        return m_buffer.image();
-
-    return Q_NULLPTR;
-}
-
-void QHaikuRasterBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
-{
-    Q_UNUSED(region);
-    Q_UNUSED(offset);
-
-    if (!window)
-        return;
-
-    QHaikuRasterWindow *targetWindow = static_cast<QHaikuRasterWindow*>(window->handle());
-
-    BView *view = targetWindow->nativeViewHandle();
-
-    view->LockLooper();
-    view->DrawBitmap(m_bitmap);
-    view->UnlockLooper();
-}
-
-void QHaikuRasterBackingStore::resize(const QSize &size, const QRegion &staticContents)
-{
-    Q_UNUSED(staticContents);
-
-    if (m_bufferSize == size)
-        return;
-
-    delete m_bitmap;
-    m_bitmap = new BBitmap(BRect(0, 0, size.width(), size.height()), B_RGB32, false, true);
-    m_buffer = QHaikuBuffer(m_bitmap);
-    m_bufferSize = size;
-}
-
-QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikurasterwindow.cpp b/qtbase/src/plugins/platforms/haiku/qhaikurasterwindow.cpp
deleted file mode 100644
index 9834b7c..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikurasterwindow.cpp
+++ /dev/null
@@ -1,276 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qhaikurasterwindow.h"
-
-#include "qhaikukeymapper.h"
-
-#include <View.h>
-#include <Window.h>
-
-#include <qpa/qwindowsysteminterface.h>
-
-QT_BEGIN_NAMESPACE
-
-Q_DECLARE_METATYPE(QEvent::Type)
-Q_DECLARE_METATYPE(Qt::MouseButtons)
-Q_DECLARE_METATYPE(Qt::MouseEventSource)
-Q_DECLARE_METATYPE(Qt::KeyboardModifiers)
-Q_DECLARE_METATYPE(Qt::Orientation)
-
-HaikuViewProxy::HaikuViewProxy(BWindow *window, QObject *parent)
-    : QObject(parent)
-    , BView(BRect(0, 0, window->Bounds().right, window->Bounds().bottom), 0, B_FOLLOW_ALL_SIDES, B_WILL_DRAW | B_FRAME_EVENTS)
-{
-}
-
-void HaikuViewProxy::MessageReceived(BMessage *message)
-{
-    switch (message->what) {
-    case B_MOUSE_WHEEL_CHANGED:
-        {
-             float deltaX = 0;
-             if (message->FindFloat("be:wheel_delta_x", &deltaX) != B_OK)
-                 deltaX = 0;
-
-             float deltaY = 0;
-             if (message->FindFloat("be:wheel_delta_y", &deltaY) != B_OK)
-                 deltaY = 0;
-
-             if (deltaX != 0 || deltaY != 0) {
-                BPoint localPos;
-                uint32 keyState = 0;
-                GetMouse(&localPos, &keyState);
-                const Qt::KeyboardModifiers keyboardModifiers = keyStateToModifiers(modifiers());
-
-                const BPoint globalPos = ConvertToScreen(localPos);
-                const QPoint globalPosition = QPoint(globalPos.x, globalPos.y);
-                const QPoint localPosition = QPoint(localPos.x, localPos.y);
-
-                if (deltaX != 0)
-                    Q_EMIT wheelEvent(localPosition, globalPosition, (deltaX * -120), Qt::Horizontal, keyboardModifiers);
-
-                if (deltaY != 0)
-                    Q_EMIT wheelEvent(localPosition, globalPosition, (deltaY * -120), Qt::Vertical, keyboardModifiers);
-             }
-             break;
-        }
-    default:
-        BView::MessageReceived(message);
-        break;
-    }
-
-}
-
-void HaikuViewProxy::Draw(BRect updateRect)
-{
-    BView::Draw(updateRect);
-
-    Q_EMIT drawRequest(QRect(updateRect.left, updateRect.top, updateRect.Width(), updateRect.Height()));
-}
-
-void HaikuViewProxy::MouseDown(BPoint localPos)
-{
-    BPoint dummyPos;
-    uint32 keyState = 0;
-    GetMouse(&dummyPos, &keyState);
-
-    const Qt::MouseButtons mouseButtons = keyStateToMouseButtons(keyState);
-    const Qt::KeyboardModifiers keyboardModifiers = keyStateToModifiers(modifiers());
-    const Qt::MouseEventSource source = Qt::MouseEventNotSynthesized;
-
-    const BPoint globalPos = ConvertToScreen(localPos);
-    const QPoint globalPosition = QPoint(globalPos.x, globalPos.y);
-    const QPoint localPosition = QPoint(localPos.x, localPos.y);
-
-    Q_EMIT mouseEvent(localPosition, globalPosition, mouseButtons, keyboardModifiers, source);
-}
-
-void HaikuViewProxy::MouseUp(BPoint localPos)
-{
-    BPoint dummyPos;
-    uint32 keyState = 0;
-    GetMouse(&dummyPos, &keyState);
-
-    const Qt::MouseButtons mouseButtons = keyStateToMouseButtons(keyState);
-    const Qt::KeyboardModifiers keyboardModifiers = keyStateToModifiers(modifiers());
-    const Qt::MouseEventSource source = Qt::MouseEventNotSynthesized;
-
-    const BPoint globalPos = ConvertToScreen(localPos);
-    const QPoint globalPosition = QPoint(globalPos.x, globalPos.y);
-    const QPoint localPosition = QPoint(localPos.x, localPos.y);
-
-    Q_EMIT mouseEvent(localPosition, globalPosition, mouseButtons, keyboardModifiers, source);
-}
-
-void HaikuViewProxy::MouseMoved(BPoint pos, uint32 code, const BMessage *dragMessage)
-{
-    switch (code) {
-    case B_INSIDE_VIEW:
-        {
-            BPoint dummyPos;
-            uint32 keyState = 0;
-            GetMouse(&dummyPos, &keyState);
-
-            const Qt::MouseButtons mouseButtons = keyStateToMouseButtons(keyState);
-            const Qt::KeyboardModifiers keyboardModifiers = keyStateToModifiers(modifiers());
-            const Qt::MouseEventSource source = Qt::MouseEventNotSynthesized;
-
-            const BPoint globalPos = ConvertToScreen(pos);
-            const QPoint globalPosition = QPoint(globalPos.x, globalPos.y);
-            const QPoint localPosition = QPoint(pos.x, pos.y);
-
-            Q_EMIT mouseEvent(localPosition, globalPosition, mouseButtons, keyboardModifiers, source);
-        }
-        break;
-    case B_ENTERED_VIEW:
-        Q_EMIT enteredView();
-        break;
-    case B_EXITED_VIEW:
-        Q_EMIT exitedView();
-        break;
-    }
-
-    BView::MouseMoved(pos, code, dragMessage);
-}
-
-void HaikuViewProxy::KeyDown(const char*, int32)
-{
-    handleKeyEvent(QEvent::KeyPress, Window()->CurrentMessage());
-}
-
-void HaikuViewProxy::KeyUp(const char*, int32)
-{
-    handleKeyEvent(QEvent::KeyRelease, Window()->CurrentMessage());
-}
-
-Qt::MouseButtons HaikuViewProxy::keyStateToMouseButtons(uint32 keyState) const
-{
-    Qt::MouseButtons mouseButtons(Qt::NoButton);
-    if (keyState & B_PRIMARY_MOUSE_BUTTON)
-        mouseButtons |= Qt::LeftButton;
-    if (keyState & B_SECONDARY_MOUSE_BUTTON)
-        mouseButtons |= Qt::RightButton;
-    if (keyState & B_TERTIARY_MOUSE_BUTTON)
-        mouseButtons |= Qt::MiddleButton;
-
-    return mouseButtons;
-}
-
-Qt::KeyboardModifiers HaikuViewProxy::keyStateToModifiers(uint32 keyState) const
-{
-    Qt::KeyboardModifiers modifiers(Qt::NoModifier);
-
-    if (keyState & B_SHIFT_KEY)
-        modifiers |= Qt::ShiftModifier;
-    if (keyState & B_CONTROL_KEY)
-        modifiers |= Qt::AltModifier;
-    if (keyState & B_COMMAND_KEY)
-        modifiers |= Qt::ControlModifier;
-
-    return modifiers;
-}
-
-void HaikuViewProxy::handleKeyEvent(QEvent::Type type, BMessage *message)
-{
-    int32 key = 0;
-    uint32 code = 0;
-    const char *bytes = Q_NULLPTR;
-    QString text;
-
-    if (message) {
-        if (message->FindString("bytes", &bytes) == B_OK) {
-            text = QString::fromLocal8Bit(bytes, strlen(bytes));
-        }
-
-        if (message->FindInt32("key", &key) == B_OK) {
-            code = QHaikuKeyMapper::translateKeyCode(key, (modifiers() & B_NUM_LOCK));
-        }
-    }
-
-    const Qt::KeyboardModifiers keyboardModifiers = keyStateToModifiers(modifiers());
-
-    Q_EMIT keyEvent(type, code, keyboardModifiers, text);
-}
-
-
-QHaikuRasterWindow::QHaikuRasterWindow(QWindow *window)
-    : QHaikuWindow(window)
-{
-    qRegisterMetaType<QEvent::Type>();
-    qRegisterMetaType<Qt::MouseButtons>();
-    qRegisterMetaType<Qt::MouseEventSource>();
-    qRegisterMetaType<Qt::KeyboardModifiers>();
-    qRegisterMetaType<Qt::Orientation>();
-
-    HaikuViewProxy *haikuView = new HaikuViewProxy(m_window);
-    connect(haikuView, SIGNAL(mouseEvent(QPoint,QPoint,Qt::MouseButtons,Qt::KeyboardModifiers,Qt::MouseEventSource)),
-            this, SLOT(haikuMouseEvent(QPoint,QPoint,Qt::MouseButtons,Qt::KeyboardModifiers,Qt::MouseEventSource)));
-    connect(haikuView, SIGNAL(wheelEvent(QPoint,QPoint,int,Qt::Orientation,Qt::KeyboardModifiers)),
-            this, SLOT(haikuWheelEvent(QPoint,QPoint,int,Qt::Orientation,Qt::KeyboardModifiers)));
-    connect(haikuView, SIGNAL(keyEvent(QEvent::Type,int,Qt::KeyboardModifiers,QString)),
-            this, SLOT(haikuKeyEvent(QEvent::Type,int,Qt::KeyboardModifiers,QString)));
-    connect(haikuView, SIGNAL(enteredView()), this, SLOT(haikuEnteredView()));
-    connect(haikuView, SIGNAL(exitedView()), this, SLOT(haikuExitedView()));
-    connect(haikuView, SIGNAL(drawRequest(QRect)), this, SLOT(haikuDrawRequest(QRect)));
-
-    m_view = haikuView;
-
-    m_window->LockLooper();
-    m_window->AddChild(m_view);
-    m_view->MakeFocus();
-    m_window->UnlockLooper();
-}
-
-QHaikuRasterWindow::~QHaikuRasterWindow()
-{
-    m_window->LockLooper();
-    m_view->RemoveSelf();
-    m_window->UnlockLooper();
-
-    delete m_view;
-    m_view = Q_NULLPTR;
-}
-
-BView* QHaikuRasterWindow::nativeViewHandle() const
-{
-    return m_view;
-}
-
-QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikurasterwindow.h b/qtbase/src/plugins/platforms/haiku/qhaikurasterwindow.h
deleted file mode 100644
index ae57e0f..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikurasterwindow.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QHAIKURASTERWINDOW_H
-#define QHAIKURASTERWINDOW_H
-
-#include "qhaikuwindow.h"
-
-#include <View.h>
-
-QT_BEGIN_NAMESPACE
-
-class HaikuViewProxy : public QObject, public BView
-{
-    Q_OBJECT
-
-public:
-    explicit HaikuViewProxy(BWindow *window, QObject *parent = Q_NULLPTR);
-
-    void MessageReceived(BMessage *message) Q_DECL_OVERRIDE;
-    void Draw(BRect updateRect) Q_DECL_OVERRIDE;
-    void MouseDown(BPoint pos) Q_DECL_OVERRIDE;
-    void MouseUp(BPoint pos) Q_DECL_OVERRIDE;
-    void MouseMoved(BPoint pos, uint32 code, const BMessage *dragMessage) Q_DECL_OVERRIDE;
-    void KeyDown(const char *bytes, int32 numBytes) Q_DECL_OVERRIDE;
-    void KeyUp(const char *bytes, int32 numBytes) Q_DECL_OVERRIDE;
-
-Q_SIGNALS:
-    void mouseEvent(const QPoint &localPosition, const QPoint &globalPosition, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::MouseEventSource source);
-    void wheelEvent(const QPoint &localPosition, const QPoint &globalPosition, int delta, Qt::Orientation orientation, Qt::KeyboardModifiers modifiers);
-    void keyEvent(QEvent::Type type, int key, Qt::KeyboardModifiers modifiers, const QString &text);
-    void enteredView();
-    void exitedView();
-    void drawRequest(const QRect &rect);
-
-private:
-    Qt::MouseButtons keyStateToMouseButtons(uint32 keyState) const;
-    Qt::KeyboardModifiers keyStateToModifiers(uint32 keyState) const;
-    void handleKeyEvent(QEvent::Type type, BMessage *message);
-};
-
-class QHaikuRasterWindow : public QHaikuWindow
-{
-    Q_OBJECT
-
-public:
-    explicit QHaikuRasterWindow(QWindow *window);
-    ~QHaikuRasterWindow();
-
-    BView* nativeViewHandle() const;
-
-private:
-    HaikuViewProxy *m_view;
-};
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuscreen.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuscreen.cpp
deleted file mode 100644
index 54951a0..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikuscreen.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qhaikuscreen.h"
-
-#include "qhaikucursor.h"
-#include "qhaikuutils.h"
-
-#include <qpa/qwindowsysteminterface.h>
-
-#include <Bitmap.h>
-#include <Screen.h>
-#include <Window.h>
-
-QHaikuScreen::QHaikuScreen()
-    : m_screen(new BScreen(B_MAIN_SCREEN_ID))
-    , m_cursor(new QHaikuCursor)
-{
-    Q_ASSERT(m_screen->IsValid());
-}
-
-QHaikuScreen::~QHaikuScreen()
-{
-    delete m_cursor;
-    m_cursor = Q_NULLPTR;
-
-    delete m_screen;
-    m_screen = Q_NULLPTR;
-}
-
-QPixmap QHaikuScreen::grabWindow(WId winId, int x, int y, int width, int height) const
-{
-    if (width == 0 || height == 0)
-        return QPixmap();
-
-    BScreen screen(Q_NULLPTR);
-    BBitmap *bitmap = Q_NULLPTR;
-    screen.GetBitmap(&bitmap);
-
-    const BRect frame = (winId ? ((BWindow*)winId)->Frame() : screen.Frame());
-
-    const int absoluteX = frame.left + x;
-    const int absoluteY = frame.top + y;
-
-    if (width < 0)
-        width = frame.Width() - x;
-    if (height < 0)
-        height = frame.Height() - y;
-
-    const QImage::Format format = QHaikuUtils::colorSpaceToImageFormat(bitmap->ColorSpace());
-
-    // get image of complete screen
-    QImage image((uchar*)bitmap->Bits(), screen.Frame().Width() + 1, screen.Frame().Height() + 1, bitmap->BytesPerRow(), format);
-
-    // extract the area of the requested window
-    QRect grabRect(absoluteX, absoluteY, width, height);
-    image = image.copy(grabRect);
-
-    delete bitmap;
-
-    return QPixmap::fromImage(image);
-}
-
-QRect QHaikuScreen::geometry() const
-{
-    const BRect frame = m_screen->Frame();
-    return QRect(frame.left, frame.top, frame.right - frame.left, frame.bottom - frame.top);
-}
-
-int QHaikuScreen::depth() const
-{
-    switch (format()) {
-    case QImage::Format_Invalid:
-        return 0;
-        break;
-    case QImage::Format_MonoLSB:
-        return 1;
-        break;
-    case QImage::Format_Indexed8:
-        return 8;
-        break;
-    case QImage::Format_RGB16:
-    case QImage::Format_RGB555:
-        return 16;
-        break;
-    case QImage::Format_RGB888:
-        return 24;
-        break;
-    case QImage::Format_RGB32:
-    case QImage::Format_ARGB32:
-    default:
-        return 32;
-        break;
-    }
-}
-
-QImage::Format QHaikuScreen::format() const
-{
-    return QHaikuUtils::colorSpaceToImageFormat(m_screen->ColorSpace());
-}
-
-QPlatformCursor *QHaikuScreen::cursor() const
-{
-    return m_cursor;
-}
-
-QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuservices.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuservices.cpp
index cc7e588..c6ecc51 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuservices.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuservices.cpp
@@ -1,6 +1,6 @@
-/***************************************************************************
+/****************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -39,50 +39,40 @@
 
 #include "qhaikuservices.h"
 
-#include <QFile>
-#include <QMimeDatabase>
-#include <QString>
-#include <QUrl>
+#include <qdebug.h>
 
-#include <Roster.h>
+#include <QtCore/QUrl>
+#include <QtCore/QDir>
+#include <QtCore/QCoreApplication>
+
+#include <stdlib.h>
 
 QT_BEGIN_NAMESPACE
 
-bool QHaikuServices::openUrl(const QUrl &url)
+QHaikuServices::QHaikuServices()
 {
-    const QMimeDatabase mimeDatabase;
-
-    const QMimeType mimeType = mimeDatabase.mimeTypeForUrl(url);
-    if (!mimeType.isValid())
-        return false;
-
-    const QByteArray mimeTypeName = mimeType.name().toLatin1();
-    QByteArray urlData = url.toString().toLocal8Bit();
-    char *rawUrlData = urlData.data();
-
-    if (be_roster->Launch(mimeTypeName.constData(), 1, &rawUrlData) != B_OK)
-        return false;
-
-    return true;
 }
 
-bool QHaikuServices::openDocument(const QUrl &url)
+QHaikuServices::~QHaikuServices()
 {
-    const QByteArray localPath = QFile::encodeName(url.toLocalFile());
-
-    entry_ref ref;
-    if (get_ref_for_path(localPath.constData(), &ref) != B_OK)
-        return false;
-
-    if (be_roster->Launch(&ref) != B_OK)
-        return false;
+}
 
+bool QHaikuServices::openUrl(const QUrl &url)
+{
+    QString urlString;
+    urlString.append("open ");
+    urlString.append(url.toString());
+    system(urlString.toUtf8());
     return true;
 }
 
-QByteArray QHaikuServices::desktopEnvironment() const
+bool QHaikuServices::openDocument(const QUrl &url)
 {
-    return QByteArray("Haiku");
+    QString urlString;
+    urlString.append("open ");
+    urlString.append(url.toString());
+    system(urlString.toUtf8());
+    return true;
 }
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuservices.h b/qtbase/src/plugins/platforms/haiku/qhaikuservices.h
index a210eb8..08a7178 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuservices.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuservices.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -47,12 +47,13 @@ QT_BEGIN_NAMESPACE
 class QHaikuServices : public QPlatformServices
 {
 public:
-    bool openUrl(const QUrl &url) Q_DECL_OVERRIDE;
-    bool openDocument(const QUrl &url) Q_DECL_OVERRIDE;
+    explicit QHaikuServices();
+    ~QHaikuServices();
 
-    QByteArray desktopEnvironment() const Q_DECL_OVERRIDE;
+    bool openUrl(const QUrl &url);
+    bool openDocument(const QUrl &url);
 };
 
 QT_END_NAMESPACE
 
-#endif
+#endif // QHAIKUSERVICES_H
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikusystemsettings.cpp b/qtbase/src/plugins/platforms/haiku/qhaikusystemsettings.cpp
new file mode 100644
index 0000000..0843ab5
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikusystemsettings.cpp
@@ -0,0 +1,112 @@
+/***************************************************************************
+**
+** Copyright (C) 2012 Research In Motion
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qhaikusystemsettings.h"
+
+#include <QFont>
+#include <qpa/qplatformfontdatabase.h>
+#include <qdebug.h>
+
+#include <View.h>
+#include <Font.h>
+#include <Menu.h>
+
+QT_BEGIN_NAMESPACE
+
+extern status_t _get_system_font_(const char *which, font_family family, font_style style, float *size);
+
+
+QHash<QPlatformTheme::Font, QFont *> qt_haiku_createRoleFonts(QPlatformFontDatabase *fontDatabase)
+{
+	QFontDatabase db;
+
+    font_family plainFontFamily;
+    font_style plainFontStyle;        
+	BFont plainFont = *be_plain_font;
+	plainFont.GetFamilyAndStyle(&plainFontFamily, &plainFontStyle);
+
+    font_family fixedFontFamily;
+    font_style fixedFontStyle;        
+	BFont fixedFont = *be_fixed_font;
+	fixedFont.GetFamilyAndStyle(&fixedFontFamily, &fixedFontStyle);
+
+	menu_info menuFontInfo;
+	get_menu_info(&menuFontInfo);
+	
+	qDebug() << "plainFont:" << (char*)plainFontStyle << (char*)plainFontStyle << plainFont.Size();
+    QFont baseFont = db.font(plainFontFamily, plainFontStyle, plainFont.Size() * 72.0 / 96.0);
+    baseFont.setStretch(QFont::Unstretched);
+    //baseFont.setStyle(QFont::StyleNormal);
+   
+	qDebug() << "monoFont:" << (char*)fixedFontFamily << (char*)fixedFontStyle << fixedFont.Size();
+    QFont monoFont = db.font(fixedFontFamily, fixedFontStyle, fixedFont.Size() * 72.0 / 96.0);
+    monoFont.setStretch(QFont::Unstretched);
+    //monoFont.setStyle(QFont::StyleNormal);
+
+    qDebug() << "menuFont:" << (char*)menuFontInfo.f_family << (char*)menuFontInfo.f_style << menuFontInfo.font_size;
+    QFont menuFont = db.font(menuFontInfo.f_family, menuFontInfo.f_style, menuFontInfo.font_size * 72.0 / 96.0);    
+    menuFont.setStretch(QFont::Unstretched);
+   // menuFont.setStyle(QFont::StyleNormal);
+
+    QHash<QPlatformTheme::Font, QFont *> fonts;
+    fonts.insert(QPlatformTheme::SystemFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::PushButtonFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::ListViewFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::ListBoxFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::TitleBarFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::MenuFont, new QFont(menuFont));
+    fonts.insert(QPlatformTheme::MenuBarFont, new QFont(menuFont));
+    fonts.insert(QPlatformTheme::ComboMenuItemFont, new QFont(menuFont));
+    fonts.insert(QPlatformTheme::HeaderViewFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::TipLabelFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::LabelFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::ToolButtonFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::MenuItemFont, new QFont(menuFont));
+    fonts.insert(QPlatformTheme::ComboLineEditFont, new QFont(baseFont));
+    fonts.insert(QPlatformTheme::FixedFont, new QFont(monoFont));
+
+    QFont smallFont(baseFont);
+    smallFont.setPixelSize(plainFont.Size() * 0.75);
+    fonts.insert(QPlatformTheme::SmallFont, new QFont(smallFont));
+    fonts.insert(QPlatformTheme::MiniFont, new QFont(smallFont));
+
+    return fonts;
+}
+
+QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikukeymapper.h b/qtbase/src/plugins/platforms/haiku/qhaikusystemsettings.h
similarity index 83%
rename from qtbase/src/plugins/platforms/haiku/qhaikukeymapper.h
rename to qtbase/src/plugins/platforms/haiku/qhaikusystemsettings.h
index 73d1794..2091689 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikukeymapper.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikusystemsettings.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 Research In Motion
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -37,23 +37,18 @@
 **
 ****************************************************************************/
 
-#ifndef QHAIKUKEYMAPPER_H
-#define QHAIKUKEYMAPPER_H
+#ifndef QHAIKUSYSTEMSETTINGS_H
+#define QHAIKUSYSTEMSETTINGS_H
 
-#include <qnamespace.h>
+#include <QtCore/qhash.h>
+#include <qpa/qplatformtheme.h>
 
-#include <InterfaceDefs.h>
+class QPlatformFontDatabase;
 
 QT_BEGIN_NAMESPACE
 
-class QHaikuKeyMapper
-{
-public:
-    QHaikuKeyMapper();
-
-    static uint32 translateKeyCode(uint32 key, bool numlockActive);
-};
+QHash<QPlatformTheme::Font, QFont *> qt_haiku_createRoleFonts(QPlatformFontDatabase *fontDatabase);
 
 QT_END_NAMESPACE
 
-#endif
+#endif // QHAIKUSYSTEMSETTINGS_H
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikutheme.cpp b/qtbase/src/plugins/platforms/haiku/qhaikutheme.cpp
new file mode 100644
index 0000000..086b5c1
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikutheme.cpp
@@ -0,0 +1,173 @@
+/***************************************************************************
+**
+** Copyright (C) 2012 Research In Motion
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qhaikutheme.h"
+
+#include "qhaikuplatformdialoghelpers.h"
+#include "qhaikusystemsettings.h"
+#include "qhaikuintegration.h"
+
+#include <qdebug.h>
+
+#include <Rect.h>
+#include <File.h>
+#include <Node.h>
+#include <NodeInfo.h>
+#include <Bitmap.h>
+
+QT_BEGIN_NAMESPACE
+
+QHaikuTheme::QHaikuTheme(const QHaikuIntegration *integration) : m_integration(integration)
+{	
+    // Set the dark theme as default palette
+ /*   QColor color = QColor(211, 211, 211);
+    m_defaultPalette.setBrush(QPalette::ButtonText, color);
+    m_defaultPalette.setBrush(QPalette::WindowText, color);
+    m_defaultPalette.setBrush(QPalette::Text, color);
+
+    color.setAlpha(179);
+    m_defaultPalette.setBrush(QPalette::Disabled, QPalette::ButtonText, color);
+    m_defaultPalette.setBrush(QPalette::Disabled, QPalette::WindowText, color);
+    m_defaultPalette.setBrush(QPalette::Disabled, QPalette::Text, color);
+
+    color.setRgb(18, 18, 18);
+    m_defaultPalette.setColor(QPalette::Window, color);
+    m_defaultPalette.setColor(QPalette::Base, color);
+    m_defaultPalette.setColor(QPalette::AlternateBase, QColor(50, 50, 50));
+    m_defaultPalette.setColor(QPalette::Button, color);
+
+    m_defaultPalette.setBrush(QPalette::Highlight, QColor(0, 168, 223));
+    m_defaultPalette.setBrush(QPalette::HighlightedText, QColor(250, 250,250));*/
+}
+
+QHaikuTheme::~QHaikuTheme()
+{
+    qDeleteAll(m_fonts);
+}
+
+bool QHaikuTheme::usePlatformNativeDialog(DialogType type) const
+{
+	if (type == QPlatformTheme::MessageDialog)
+		return false;
+    if (type == QPlatformTheme::FileDialog)
+        return false;
+#if !defined(QT_NO_COLORDIALOG)
+    if (type == QPlatformTheme::ColorDialog)
+        return false;
+#endif
+#if !defined(QT_NO_FONTDIALOG)
+    if (type == QPlatformTheme::FontDialog)
+        return false;
+#endif
+    return false;
+}
+
+QPlatformDialogHelper *QHaikuTheme::createPlatformDialogHelper(DialogType type) const
+{
+    switch (type) {
+	case QPlatformTheme::MessageDialog:
+    //    return new QtHaikuDialogHelpers::QHaikuPlatformMessageDialogHelper;
+    case QPlatformTheme::FileDialog:
+    case QPlatformTheme::ColorDialog:
+    case QPlatformTheme::FontDialog:
+    default:
+        return 0;
+    }
+}
+
+QVariant QHaikuTheme::themeHint(ThemeHint hint) const
+{
+	switch (hint) {
+    case QPlatformTheme::StyleNames:
+        return QStringList("fusion");
+    case QPlatformTheme::IconPixmapSizes:
+    	{
+        	QList<int> sizes;
+        	sizes << 16 << 32;
+        	return QVariant::fromValue(sizes);
+    	}
+    case QPlatformTheme::ContextMenuOnMouseRelease:
+        return QVariant(true);
+    default:
+        return QPlatformTheme::themeHint(hint);
+    }	
+}
+
+
+const QFont *QHaikuTheme::font(Font type) const
+{
+    QPlatformFontDatabase *fontDatabase = m_integration->fontDatabase();
+
+    if (fontDatabase && m_fonts.isEmpty())
+        m_fonts = qt_haiku_createRoleFonts(fontDatabase);
+    return m_fonts.value(type, 0);
+}
+
+const QPalette *QHaikuTheme::palette(Palette type) const
+{
+    // Return the default palette
+    if (type == SystemPalette)
+        return &m_defaultPalette;
+
+    return QPlatformTheme::palette(type);
+}
+
+QPixmap QHaikuTheme::standardPixmap(StandardPixmap sp, const QSizeF &size) const
+{
+	return QPlatformTheme::standardPixmap(sp, size);
+}
+
+QPixmap QHaikuTheme::fileIconPixmap(const QFileInfo &fileInfo, const QSizeF &size,
+                                      QPlatformTheme::IconOptions iconOptions) const
+{
+	BFile file(fileInfo.filePath().toUtf8(), O_RDONLY);
+	BNodeInfo nodeInfo(&file);
+	icon_size iconSize = size.width() > 16 ? B_LARGE_ICON : B_MINI_ICON;
+	BRect rect(0, 0, iconSize - 1, iconSize -1);
+	BBitmap bitmap(rect, B_RGBA32);
+	if (nodeInfo.GetTrackerIcon(&bitmap, iconSize) == B_NO_ERROR) {
+		QImage image(iconSize, iconSize, QImage::Format_ARGB32);
+		memcpy((uchar*)image.bits(), (uchar*)bitmap.Bits(), iconSize * iconSize * 4);
+		QPixmap pixmap = QPixmap::fromImage(image);
+		return pixmap;
+	}
+	return QPlatformTheme::fileIconPixmap(fileInfo, size);
+}
+
+QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuscreen.h b/qtbase/src/plugins/platforms/haiku/qhaikutheme.h
similarity index 62%
rename from qtbase/src/plugins/platforms/haiku/qhaikuscreen.h
rename to qtbase/src/plugins/platforms/haiku/qhaikutheme.h
index 49fa3f0..dba27ee 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuscreen.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikutheme.h
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 Research In Motion
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -37,36 +37,48 @@
 **
 ****************************************************************************/
 
-#ifndef QHAIKUSCREEN_H
-#define QHAIKUSCREEN_H
+#ifndef QHAIKUTHEME_H
+#define QHAIKUTHEME_H
 
-#include <qpa/qplatformscreen.h>
+#include <qpa/qplatformtheme.h>
 
-class BScreen;
-class QHaikuCursor;
+#include <QtGui/qfont.h>
+#include <QtCore/qhash.h>
+#include <QtCore/qstring.h>
+#include <QtGui/QColor>
+#include <QtGui/QPalette>
 
 QT_BEGIN_NAMESPACE
 
-class QHaikuScreen : public QPlatformScreen
+class QHaikuIntegration;
+
+class QHaikuTheme : public QPlatformTheme
 {
 public:
-    QHaikuScreen();
-    ~QHaikuScreen();
+    explicit QHaikuTheme(const QHaikuIntegration *);
+    ~QHaikuTheme();
 
-    QPixmap grabWindow(WId window, int x, int y, int width, int height) const Q_DECL_OVERRIDE;
+    static QString name() { return QStringLiteral("haiku"); }
 
-    QRect geometry() const Q_DECL_OVERRIDE;
-    int depth() const Q_DECL_OVERRIDE;
-    QImage::Format format() const Q_DECL_OVERRIDE;
+    bool usePlatformNativeDialog(DialogType type) const;
+    QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const;
+    
+    virtual QVariant themeHint(ThemeHint hint) const;
 
-    QPlatformCursor *cursor() const Q_DECL_OVERRIDE;
+    const QFont *font(Font type = SystemFont) const;
 
-private:
-    BScreen *m_screen;
+    const QPalette *palette(Palette type = SystemPalette) const;
 
-    QHaikuCursor *m_cursor;
+    virtual QPixmap standardPixmap(StandardPixmap sp, const QSizeF &size) const;
+    virtual QPixmap fileIconPixmap(const QFileInfo &fileInfo, const QSizeF &size,
+                                   QPlatformTheme::IconOptions iconOptions = 0) const;
+
+private:
+    mutable QHash<QPlatformTheme::Font, QFont*> m_fonts;
+    const QHaikuIntegration *m_integration;
+    QPalette m_defaultPalette;
 };
 
 QT_END_NAMESPACE
 
-#endif
+#endif // QHAIKUTHEME_H
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuutils.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuutils.cpp
deleted file mode 100644
index 1173de8..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikuutils.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qhaikuutils.h"
-
-color_space QHaikuUtils::imageFormatToColorSpace(QImage::Format format)
-{
-    color_space colorSpace = B_NO_COLOR_SPACE;
-    switch (format) {
-    case QImage::Format_Invalid:
-        colorSpace = B_NO_COLOR_SPACE;
-        break;
-    case QImage::Format_MonoLSB:
-        colorSpace = B_GRAY1;
-        break;
-    case QImage::Format_Indexed8:
-        colorSpace = B_CMAP8;
-        break;
-    case QImage::Format_RGB32:
-        colorSpace = B_RGB32;
-        break;
-    case QImage::Format_ARGB32:
-        colorSpace = B_RGBA32;
-        break;
-    case QImage::Format_RGB16:
-        colorSpace = B_RGB16;
-        break;
-    case QImage::Format_RGB555:
-        colorSpace = B_RGB15;
-        break;
-    case QImage::Format_RGB888:
-        colorSpace = B_RGB24;
-        break;
-    default:
-        qWarning("Cannot convert image format %d to color space", format);
-        Q_ASSERT(false);
-        break;
-    }
-
-    return colorSpace;
-}
-
-QImage::Format QHaikuUtils::colorSpaceToImageFormat(color_space colorSpace)
-{
-    QImage::Format format = QImage::Format_Invalid;
-    switch (colorSpace) {
-    case B_NO_COLOR_SPACE:
-        format = QImage::Format_Invalid;
-        break;
-    case B_GRAY1:
-        format = QImage::Format_MonoLSB;
-        break;
-    case B_CMAP8:
-        format = QImage::Format_Indexed8;
-        break;
-    case B_RGB32:
-        format = QImage::Format_RGB32;
-        break;
-    case B_RGBA32:
-        format = QImage::Format_ARGB32;
-        break;
-    case B_RGB16:
-        format = QImage::Format_RGB16;
-        break;
-    case B_RGB15:
-        format = QImage::Format_RGB555;
-        break;
-    case B_RGB24:
-        format = QImage::Format_RGB888;
-        break;
-    default:
-        qWarning("Cannot convert color space %d to image format", colorSpace);
-        Q_ASSERT(false);
-        break;
-    }
-
-    return format;
-}
-
-QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuutils.h b/qtbase/src/plugins/platforms/haiku/qhaikuutils.h
deleted file mode 100644
index d726426..0000000
--- a/qtbase/src/plugins/platforms/haiku/qhaikuutils.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QHAIKUUTILS_H
-#define QHAIKUUTILS_H
-
-#include <QImage>
-
-#include <GraphicsDefs.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace QHaikuUtils
-{
-    color_space imageFormatToColorSpace(QImage::Format format);
-    QImage::Format colorSpaceToImageFormat(color_space colorSpace);
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuview.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuview.cpp
new file mode 100644
index 0000000..d5a07b1
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuview.cpp
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2010 Your Name <your@email.address>
+ * All rights reserved. Distributed under the terms of the MIT license.
+ */
+#include <stdio.h>
+
+#include <qpa/qwindowsysteminterface.h>
+#include <qpa/qplatformwindow.h>
+#include <qdebug.h>
+
+#include "qhaikuwindow.h"
+#include "qhaikuview.h"
+
+
+FBView::FBView(BRect rect) : 
+	BView(rect, "FBView", B_FOLLOW_ALL, B_WILL_DRAW),
+	viewBitmap(0)
+{
+	SetDrawingMode(B_OP_COPY);
+	lastMouseMoveTime = system_time();
+	//SetViewColor(B_TRANSPARENT_32_BIT);
+}
+
+FBView::~FBView()
+{	
+}
+
+void
+FBView::Draw(BRect rect)
+{
+	if(viewBitmap != NULL) {
+		SetDrawingMode(B_OP_COPY);
+		DrawBitmap(viewBitmap, rect, rect);
+	}
+}
+
+Qt::MouseButtons 
+FBView::hostToQtButtons(uint32 buttons)
+{
+	Qt::MouseButtons qtButtons = Qt::NoButton;
+    
+    if (buttons & B_PRIMARY_MOUSE_BUTTON)
+        qtButtons |= Qt::LeftButton;
+    if (buttons & B_TERTIARY_MOUSE_BUTTON)
+        qtButtons |= Qt::MidButton;
+    if (buttons & B_SECONDARY_MOUSE_BUTTON)
+        qtButtons |= Qt::RightButton;
+        
+    return qtButtons;
+}
+
+
+void 
+FBView::MouseDown(BPoint point)
+{
+	BPoint s_point = ConvertToScreen(point);	
+	QPoint lp(point.x, point.y);
+	QPoint gp(s_point.x, s_point.y);
+	
+	uint32 buttons = Window()->CurrentMessage()->FindInt32("buttons");
+	
+	lastButtons = hostToQtButtons(buttons);
+	
+	QHaikuWindow *wnd = ((QtHaikuWindow*)Window())->fQWindow;
+	
+	SetMouseEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);
+	
+//	QWindowSystemInterface::handleWindowActivated(wnd->window());
+	
+	QWindowSystemInterface::handleMouseEvent( wnd->window(), lp, gp, lastButtons);
+}
+
+void 
+FBView::MouseUp(BPoint point)
+{
+	BPoint s_point = ConvertToScreen(point);
+	QPoint lp(point.x, point.y);
+	QPoint gp(s_point.x, s_point.y);
+	
+	QHaikuWindow *wnd = ((QtHaikuWindow*)Window())->fQWindow;
+
+	BPoint p;
+	uint32 buttons;
+	GetMouse(&p, &buttons);
+
+	QWindowSystemInterface::handleMouseEvent( wnd->window(), lp, gp, hostToQtButtons(buttons));
+}
+
+void 
+FBView::MouseMoved(BPoint point, uint32 transit, const BMessage *msg)
+{
+	BPoint s_point = ConvertToScreen(point);
+	QPoint lp(point.x, point.y);
+	QPoint gp(s_point.x, s_point.y);
+	
+	bigtime_t t = system_time();
+	
+	if(t - lastMouseMoveTime > 10000) {
+		BPoint p;
+		uint32 buttons;
+		GetMouse(&p, &buttons);
+
+		lastLocalMousePoint = lp;
+		lastGlobalMousePoint = gp;
+	
+		QHaikuWindow *wnd = ((QtHaikuWindow*)Window())->fQWindow;
+
+		QWindowSystemInterface::handleMouseEvent( wnd->window(), lp, gp, hostToQtButtons(buttons));
+		lastMouseMoveTime = t;
+	}
+}
+
+void
+FBView::SetViewBitmap(BBitmap *bmp)
+{
+	viewBitmap = bmp;
+}
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuview.h b/qtbase/src/plugins/platforms/haiku/qhaikuview.h
new file mode 100644
index 0000000..fb666f9
--- /dev/null
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuview.h
@@ -0,0 +1,34 @@
+#ifndef _H_FBVIEW_
+#define _H_FBVIEW_
+
+#include <SupportDefs.h>
+#include <Bitmap.h>
+#include <View.h>
+#include <Point.h>
+#include <Rect.h>
+
+class FBView : public BView 
+{
+ public:
+		FBView(BRect rect);
+		~FBView();
+		
+		virtual void Draw(BRect rect);
+		virtual void MouseDown(BPoint p);
+		virtual void MouseUp(BPoint p);
+		virtual void MouseMoved(BPoint point, uint32 transit, const BMessage *msg);
+		
+		void SetViewBitmap(BBitmap *bmp);
+		
+		QPoint	lastLocalMousePoint;
+		QPoint 	lastGlobalMousePoint;
+		
+ private:
+ 		Qt::MouseButtons hostToQtButtons(uint32 buttons);
+ 		
+ 		bigtime_t lastMouseMoveTime;
+		BBitmap *viewBitmap;
+		Qt::MouseButtons lastButtons;
+};
+
+#endif
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuwindow.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuwindow.cpp
index 4634012..9b51a6d 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuwindow.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuwindow.cpp
@@ -1,6 +1,6 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
@@ -38,354 +38,677 @@
 ****************************************************************************/
 
 #include "qhaikuwindow.h"
+#include "qhaikucommon.h"
 
-#include "private/qguiapplication_p.h"
-
-#include <QCoreApplication>
-#include <QThread>
-#include <QWindow>
+#include <qpa/qplatformscreen.h>
 #include <qpa/qwindowsysteminterface.h>
 
-#include <Rect.h>
-#include <Window.h>
+#include <qguiapplication.h>
 
-QT_BEGIN_NAMESPACE
+#include <private/qwindow_p.h>
 
-enum {
-    DefaultWindowWidth = 160,
-    DefaultWindowHeight = 160
-};
-
-HaikuWindowProxy::HaikuWindowProxy(QWindow *window, const QRect &rect, QObject *parent)
-    : QObject(parent)
-    , BWindow(BRect(rect.x(), rect.y(), rect.right() - 1, rect.bottom() - 1),
-              window->title().toUtf8(), B_NO_BORDER_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL, 0)
-    , m_qtCalledZoom(false)
-    , m_zoomInProgress(false)
-{
-}
+#include <qdebug.h>
 
-void HaikuWindowProxy::FrameMoved(BPoint pos)
-{
-    Q_EMIT moved(QPoint(pos.x, pos.y));
-}
+QT_BEGIN_NAMESPACE
+
+ static uint32 ScanCodes[] = {
+        Qt::Key_Escape,		0x01,
+        Qt::Key_F1,			0x02,
+        Qt::Key_F2,			0x03,
+        Qt::Key_F3,			0x04,
+        Qt::Key_F4,			0x05,
+        Qt::Key_F5,			0x06,
+        Qt::Key_F6,			0x07,
+        Qt::Key_F7,			0x08,
+        Qt::Key_F8,			0x09,
+        Qt::Key_F9,			0x0A,
+        Qt::Key_F10,		0x0B,
+        Qt::Key_F11,		0x0C,
+        Qt::Key_F12,		0x0D,
+        Qt::Key_Print,		0x0E,
+//      Qt::Key_ScrollLock = 0x0F,  //modificator
+        Qt::Key_Pause,		0x22,
+
+		Qt::Key_AsciiTilde, 0x11,
+        Qt::Key_1,			0x12,
+        Qt::Key_2,			0x13,
+        Qt::Key_3,			0x14,
+        Qt::Key_4,			0x15,
+        Qt::Key_5,			0x16,
+        Qt::Key_6,			0x17,
+        Qt::Key_7,			0x18,
+        Qt::Key_8,			0x19,
+        Qt::Key_9,			0x1A,
+        Qt::Key_0,			0x1B,
+        Qt::Key_Minus,		0x1C,
+        Qt::Key_Plus,		0x1D,
+        Qt::Key_Backspace,	0x1E,
+        Qt::Key_Insert,		0x1F,
+        Qt::Key_Home,		0x20,
+        Qt::Key_PageUp,		0x21,
+//		Qt::Key_NumLock,	0x22,   //modificator    
+		Qt::Key_Slash,		0x23,
+		Qt::Key_Asterisk,	0x24,
+		Qt::Key_Minus,		0x25,		
+		                
+        Qt::Key_Tab,		0x26,        
+        Qt::Key_Q,			0x27,
+        Qt::Key_W,			0x28,
+        Qt::Key_E,			0x29,
+        Qt::Key_R,			0x2A,
+        Qt::Key_T,			0x2B,
+        Qt::Key_Y,			0x2C,
+        Qt::Key_U,			0x2D,
+        Qt::Key_I,			0x2E,
+        Qt::Key_O,			0x2F,
+        Qt::Key_P,			0x30,      
+        Qt::Key_BracketLeft,0x31,
+        Qt::Key_BracketRight,0x32,
+		Qt::Key_Backslash,	0x33,
+        Qt::Key_Delete,		0x34,
+        Qt::Key_End,		0x35,
+        Qt::Key_PageDown,	0x36, 
+		Qt::Key_Home,		0x37, //numpad		      
+        Qt::Key_Up,			0x38, //numpad
+        Qt::Key_PageUp,		0x39, //numpad
+        Qt::Key_Plus,		0x3A, //numpad
+
+//		Qt::Key_CapsLock,	0x3B, //modificator
+        Qt::Key_A,			0x3C,
+        Qt::Key_S,			0x3D,
+        Qt::Key_D,			0x3E,
+        Qt::Key_F,			0x3F,
+        Qt::Key_G,			0x40,
+        Qt::Key_H,			0x41,
+        Qt::Key_J,			0x42,
+        Qt::Key_K,			0x43,
+        Qt::Key_L,			0x44,
+        Qt::Key_Colon,		0x45,
+        Qt::Key_QuoteDbl,	0x46,
+        Qt::Key_Return,		0x47,              
+        Qt::Key_Left,		0x48, //numpad
+		Qt::Key_5,			0x49, //numpad ???
+        Qt::Key_Right,		0x4A, //numpad
+
+        Qt::Key_Z,			0x4C,
+        Qt::Key_X,			0x4D,
+        Qt::Key_C,			0x4E,
+        Qt::Key_V,			0x4F,
+        Qt::Key_B,			0x50,
+        Qt::Key_N,			0x51,
+        Qt::Key_M,			0x51,
+        Qt::Key_Less,		0x52,
+        Qt::Key_Greater,	0x54,
+        Qt::Key_Question,	0x55,
+        Qt::Key_Up,			0x57,	//cursor
+        Qt::Key_End,		0x58,	//numpad
+        Qt::Key_Down,		0x59,   //numpad
+        Qt::Key_PageDown,	0x5A,   //numpad
+		Qt::Key_Enter,		0x5B,   //numpad
+
+		Qt::Key_Space,		0x5E,
+		Qt::Key_Left,		0x61,   //cursor
+		Qt::Key_Down,		0x62,   //cursor
+		Qt::Key_Right,		0x63,   //cursor
+		Qt::Key_Insert,		0x64,   //cursor
+		Qt::Key_Delete,		0x65,   //numpad
+		0,					0x00
+	};
+
+static uint32 ScanCodes_Numlock[] = {
+		Qt::Key_7,			0x37,
+        Qt::Key_8,			0x38,
+        Qt::Key_9,			0x39,
+        Qt::Key_Plus,		0x3A,
+        Qt::Key_4,			0x48,
+		Qt::Key_5,			0x49,
+        Qt::Key_6,			0x4A,
+        Qt::Key_1,			0x58,
+        Qt::Key_2,			0x59,
+        Qt::Key_3,			0x5A,
+		Qt::Key_Enter,		0x5B,
+		Qt::Key_Comma,		0x65,
+		0,					0x00
+	};
+
+static uint32 translateKeyCode(uint32 key)
+{
+	uint32 code = 0;
+	uint32 i = 0;
+	if(modifiers()&&B_NUM_LOCK) {
+	    while (ScanCodes_Numlock[i]) {
+	      		if ( key == ScanCodes_Numlock[i + 1]) {
+	            code = ScanCodes_Numlock[i];
+	      		    break;
+	        	}
+	       	i += 2;
+	  	}	
+		if(code>0)
+			return code;   
+	}
+	
+	i = 0;
+    while (ScanCodes[i]) {
+      		if ( key == ScanCodes[i + 1]) {
+            code = ScanCodes[i];
+      		    break;
+        	}
+       	i += 2;
+  	}	
+	return code;   
+}
+
+
+QtHaikuWindow::QtHaikuWindow(QHaikuWindow *qwindow,
+		BRect frame,
+		const char *title,
+		window_look look,
+		window_feel feel,
+		uint32 flags)
+		:BWindow(frame, title, look, feel, flags)
+{
+	fQWindow = qwindow;
+	fView = new FBView(Bounds());
+#if !defined(QT_NO_OPENGL)
+	fGLView = NULL;
+#endif	
+ 	AddChild(fView);
+}
+
+QtHaikuWindow::~QtHaikuWindow()
+{
+}
+
+
+FBView *
+QtHaikuWindow::View(void)
+{
+	return fView;
+}
+
+
+void
+QtHaikuWindow::DispatchMessage(BMessage *msg, BHandler *handler)
+{
+	switch(msg->what) {
+		case B_UNMAPPED_KEY_DOWN:
+		case B_KEY_DOWN:
+			{
+				uint32 modifier = msg->FindInt32("modifiers");
+				uint32 key = msg->FindInt32("key");
+				
+				QString text;
+				
+				const char* bytes;;
+				if(msg->FindString("bytes", &bytes) == B_OK)
+					text = QString::fromUtf8(bytes);
+				
+				Qt::KeyboardModifiers modifiers;
+		        if (modifier & B_SHIFT_KEY)
+		            modifiers |= Qt::ShiftModifier;
+		
+		        if (modifier & B_CONTROL_KEY)
+		            modifiers |= Qt::AltModifier;
+		
+		        if (modifier & B_COMMAND_KEY)
+		            modifiers |= Qt::ControlModifier;
+		
+				QWindowSystemInterface::handleWindowActivated(fQWindow->window());
+		
+		        QWindowSystemInterface::handleKeyEvent(0,
+                                        QEvent::KeyPress,
+                                        translateKeyCode(key),
+                                        modifiers,
+                                        text,
+                                        false);
+
+				break;	
+			}
+		case B_UNMAPPED_KEY_UP:
+		case B_KEY_UP:
+			{
+				uint32 modifier = msg->FindInt32("modifiers");
+				uint32 key = msg->FindInt32("key");
+				
+				QString text;
+				
+				const char* bytes;;
+				if(msg->FindString("bytes", &bytes) == B_OK)
+					text = QString::fromUtf8(bytes);
+				
+				Qt::KeyboardModifiers modifiers;
+		        if (modifier & B_SHIFT_KEY)
+		            modifiers |= Qt::ShiftModifier;
+		
+		        if (modifier & B_CONTROL_KEY)
+		            modifiers |= Qt::AltModifier;
+		
+		        if (modifier & B_COMMAND_KEY)
+		            modifiers |= Qt::ControlModifier;
+		
+		        QWindowSystemInterface::handleKeyEvent(0,
+                                        QEvent::KeyRelease,
+                                        translateKeyCode(key),
+                                        modifiers,
+                                        text,
+                                        false);
+				
+				break;
+			}	
+	default:
+		break;
+	}			
+	BWindow::DispatchMessage(msg, handler);
+}
+
+
+void QtHaikuWindow::MessageReceived(BMessage* msg)
+{
+	switch(msg->what) {
+	case B_MOUSE_WHEEL_CHANGED:
+		{
+			 float shift_x=0;
+			 float shift_y=0;
+			 if(msg->FindFloat("be:wheel_delta_x",&shift_x)!=B_OK)
+			 	shift_x = 0;
+			 if(msg->FindFloat("be:wheel_delta_y",&shift_y)!=B_OK)			 	
+			 	shift_y = 0;
+			 
+			 if(shift_y !=0) {
+			 	QWindowSystemInterface::handleWheelEvent(fQWindow->window(), fView->lastLocalMousePoint, fView->lastGlobalMousePoint, -shift_y * 96, Qt::Vertical);
+			 }
+			 if(shift_x !=0) {
+			 	QWindowSystemInterface::handleWheelEvent(fQWindow->window(), fView->lastLocalMousePoint, fView->lastGlobalMousePoint, shift_x * 96, Qt::Horizontal);
+			 }
+
+			 break;
+		}		
+	default:
+		BWindow::MessageReceived(msg);
+		break;
+	}
+}
+
+
+void
+QtHaikuWindow::Zoom(BPoint origin, float w, float h)
+{	
+	if (fQWindow->window()->windowState() & Qt::WindowMaximized) {
+		fQWindow->setWindowState(Qt::WindowNoState);
+	} else {
+		fQWindow->setWindowState(Qt::WindowMaximized);
+	}
+}
+
+
+void
+QtHaikuWindow::FrameResized(float width, float height)
+{
+	if (fQWindow->window()->windowState() & Qt::WindowMaximized) {
+		QWindowSystemInterface::handleWindowStateChanged(fQWindow->window(), Qt::WindowNoState);
+	}
+	fQWindow->FrameResized(width, height);
+}
+
+
+void
+QtHaikuWindow::FrameMoved(BPoint point)
+{
+	fQWindow->FrameMoved(point);
+}
+
+
+void
+QtHaikuWindow::WindowActivated(bool active)
+{
+	if (active) {
+		fQWindow->requestActivateWindow();
+		QWindowSystemInterface::handleWindowActivated(fQWindow->window());
+	}
+}
+
+
+bool QtHaikuWindow::QuitRequested()
+{
+	QWindowSystemInterface::handleCloseEvent(fQWindow->window());
+	return false;
+}
 
-void HaikuWindowProxy::FrameResized(float width, float height)
-{
-    Q_EMIT resized(QSize(static_cast<int>(width), static_cast<int>(height)), m_zoomInProgress);
 
-    m_zoomInProgress = false;
-}
+QHaikuWindow::QHaikuWindow(QWindow *wnd)
+    : QPlatformWindow(wnd)
+    , m_positionIncludesFrame(false)
+    , m_visible(false)
+    , m_pendingGeometryChangeOnShow(true)
+{	
+	qDebug() << "window()->surfaceType() " << window()->surfaceType() << window()->type();
+	
+	m_window = new QtHaikuWindow(this, BRect(wnd->geometry().left(),
+    				wnd->geometry().top(),
+    				wnd->geometry().right(),
+    				wnd->geometry().bottom()),
+    				wnd->title().toUtf8(),
+    				B_NO_BORDER_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL, 0);
+    
+    setWindowFlags(wnd->flags());
+    setWindowState(wnd->windowState());
+    handleContentOrientationChange(wnd->contentOrientation());	 	
+    setGeometry(wnd->geometry());
 
-void HaikuWindowProxy::WindowActivated(bool activated)
-{
-    Q_EMIT windowActivated(activated);
+    QWindowSystemInterface::flushWindowSystemEvents();
+    
+    m_winId = (WId)this;
 }
 
-void HaikuWindowProxy::Minimize(bool minimize)
-{
-    BWindow::Minimize(minimize);
 
-    Q_EMIT minimized(minimize);
-}
-
-void HaikuWindowProxy::Zoom(BPoint pos, float width, float height)
+QHaikuWindow::~QHaikuWindow()
 {
-    m_zoomInProgress = true;
-    BWindow::Zoom(pos, width, height);
+	m_window->Lock();
+	m_window->Quit();
+}
+
+
+void
+QHaikuWindow::setWindowFlags(Qt::WindowFlags flags)
+{
+   Qt::WindowType type =  static_cast<Qt::WindowType>(int(flags & Qt::WindowType_Mask)) ;
+
+    
+	bool popup = (type == Qt::Popup);
+	bool splash = (type == Qt::SplashScreen);
+	bool dialog = (type == Qt::Dialog
+                   || type == Qt::Sheet
+                   || (flags & Qt::MSWindowsFixedSizeDialogHint));
+	bool tool = (type == Qt::Tool || type == Qt::Drawer);
+	bool tooltip = (type == Qt::ToolTip);
+
+	window_look wlook = B_TITLED_WINDOW_LOOK;
+	window_feel wfeel = B_NORMAL_WINDOW_FEEL;
+	uint32 wflag = B_NO_WORKSPACE_ACTIVATION | B_NOT_ANCHORED_ON_ACTIVATE ;
+
+	if (tool) {
+		wlook = B_FLOATING_WINDOW_LOOK;	
+		wflag |= B_WILL_ACCEPT_FIRST_CLICK;			
+	}
+	
+	if (splash) {
+		wlook = B_NO_BORDER_WINDOW_LOOK;			
+	}
+	
+	if (popup) {
+		wlook = B_NO_BORDER_WINDOW_LOOK;			
+		wflag |= B_WILL_ACCEPT_FIRST_CLICK | B_AVOID_FRONT | B_AVOID_FOCUS;
+		wfeel = window_feel(1025);
+	}
+
+	if (tooltip) {
+		wlook = B_NO_BORDER_WINDOW_LOOK;
+		wflag |= B_WILL_ACCEPT_FIRST_CLICK | B_AVOID_FRONT | B_AVOID_FOCUS;
+		wfeel = window_feel(1025);
+		//flags |= Qt::WindowStaysOnTopHint;
+	}
 
-    // Only notify about Zoom invocations from the Haiku windowing system
-    if (!m_qtCalledZoom)
-        Q_EMIT zoomed();
-}
+    if (flags & Qt::FramelessWindowHint)
+    	wlook = B_NO_BORDER_WINDOW_LOOK;
+	if (flags & Qt::MSWindowsFixedSizeDialogHint)// (dialog)
+    	wflag |= B_NOT_RESIZABLE | B_NOT_ZOOMABLE;               
 
-bool HaikuWindowProxy::QuitRequested()
-{
-    Q_EMIT quitRequested();
+	if (flags & Qt::CustomizeWindowHint){
+		if (!(flags & Qt::WindowMinimizeButtonHint))
+    		wflag |= B_NOT_MINIMIZABLE;
+		if (!(flags & Qt::WindowMaximizeButtonHint))
+			wflag |= B_NOT_ZOOMABLE;					
+		if (!(flags & Qt::WindowCloseButtonHint))
+			wflag |= B_NOT_CLOSABLE;
+	}
 
-    // Return false to prevent Haiku windowing system to clean up
-    // the BWindow and BView instances. We will do that ourself when
-    // Qt invokes the dtor of QHaikuWindow
-    return false;
-}
+	if (flags & Qt::WindowStaysOnTopHint)
+		wfeel = B_FLOATING_ALL_WINDOW_FEEL;	
 
-void HaikuWindowProxy::zoomByQt()
-{
-    m_qtCalledZoom = true;
-    BWindow::Zoom();
-    m_qtCalledZoom = false;
+	m_window->SetLook(wlook);
+	m_window->SetFeel(wfeel);
+	m_window->SetFlags(wflag);
 }
 
-QHaikuWindow::QHaikuWindow(QWindow *window)
-    : QPlatformWindow(window)
-    , m_window(Q_NULLPTR)
-    , m_windowState(Qt::WindowNoState)
-{
-    const QRect rect = initialGeometry(window, window->geometry(), DefaultWindowWidth, DefaultWindowHeight);
-
-    HaikuWindowProxy *haikuWindow = new HaikuWindowProxy(window, rect, Q_NULLPTR);
-    connect(haikuWindow, SIGNAL(moved(QPoint)), SLOT(haikuWindowMoved(QPoint)));
-    connect(haikuWindow, SIGNAL(resized(QSize,bool)), SLOT(haikuWindowResized(QSize,bool)));
-    connect(haikuWindow, SIGNAL(windowActivated(bool)), SLOT(haikuWindowActivated(bool)));
-    connect(haikuWindow, SIGNAL(minimized(bool)), SLOT(haikuWindowMinimized(bool)));
-    connect(haikuWindow, SIGNAL(zoomed()), SLOT(haikuWindowZoomed()));
-    connect(haikuWindow, SIGNAL(quitRequested()), SLOT(haikuWindowQuitRequested()), Qt::BlockingQueuedConnection);
 
-    m_window = haikuWindow;
-
-    if (Q_UNLIKELY(!m_window))
-        qFatal("QHaikuWindow: failed to create window");
-
-    setGeometry(rect);
-    setWindowFlags(window->flags());
-}
-
-QHaikuWindow::~QHaikuWindow()
+void
+QHaikuWindow::setWindowTitle(const QString &title)
 {
-    m_window->LockLooper();
-    m_window->Quit();
-
-    m_window = Q_NULLPTR;
+	m_window->SetTitle(title.toUtf8());
 }
 
+
 void QHaikuWindow::setGeometry(const QRect &rect)
 {
-    QPlatformWindow::setGeometry(rect);
+    if (window()->windowState() != Qt::WindowNoState)
+        return;
 
-    m_window->MoveTo(rect.x(), rect.y());
-    m_window->ResizeTo(rect.width(), rect.height());
-}
+    m_positionIncludesFrame = qt_window_private(window())->positionPolicy == QWindowPrivate::WindowFrameInclusive;
 
-QMargins QHaikuWindow::frameMargins() const
-{
-    const BRect decoratorFrame = m_window->DecoratorFrame();
-    const BRect frame = m_window->Frame();
+    setFrameMarginsEnabled(true);
+    setGeometryImpl(rect);
 
-    return QMargins(frame.left - decoratorFrame.left,
-                    frame.top - decoratorFrame.top,
-                    decoratorFrame.right - frame.right,
-                    decoratorFrame.bottom - frame.bottom);
+    m_normalGeometry = geometry();    
 }
 
-void QHaikuWindow::setVisible(bool visible)
+void QHaikuWindow::propagateSizeHints()
 {
-    if (visible) {
-        m_window->Show();
-
-        window()->requestActivate();
-
-        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(0, 0), window()->geometry().size()));
+	QWindow *win = window();
+	
+    QSize minimumSize = win->minimumSize();
+    QSize maximumSize = win->maximumSize();
+//    QSize baseSize = win->baseSize();
+//    QSize sizeIncrement = win->sizeIncrement();
+    
+    float minW, maxW, minH, maxH;
+    m_window->GetSizeLimits(&minW, &maxW, &minH, &maxH);
+    
+//    qDebug() << "G: " << minW << maxW << minH << maxH;
+    
+    if (minimumSize.width() > 0)
+    	minW = minimumSize.width();
+    if (minimumSize.height() > 0)
+    	minH = minimumSize.height();    	
+    if (maximumSize.width() < QWINDOWSIZE_MAX)
+    	maxW = maximumSize.width();
+    if (maximumSize.height() < QWINDOWSIZE_MAX)
+    	maxH = maximumSize.height();
+    	
+//    qDebug() << "S: " << minW << maxW << minH << maxH;
+   
+	m_window->SetSizeLimits(minW, maxW, minH, maxH);
+}
+
+
+void QHaikuWindow::setGeometryImpl(const QRect &rect)
+{
+    QRect adjusted = rect;
+    if (adjusted.width() <= 0)
+        adjusted.setWidth(1);
+    if (adjusted.height() <= 0)
+        adjusted.setHeight(1);
+
+    if (m_positionIncludesFrame) {
+        adjusted.translate(m_margins.left(), m_margins.top());
     } else {
-        m_window->Hide();
+        // make sure we're not placed off-screen
+        if (adjusted.left() < m_margins.left())
+            adjusted.translate(m_margins.left(), 0);
+        if (adjusted.top() < m_margins.top())
+            adjusted.translate(0, m_margins.top());
     }
-}
-
-bool QHaikuWindow::isExposed() const
-{
-    return !m_window->IsHidden();
-}
-
-bool QHaikuWindow::isActive() const
-{
-    return m_window->IsActive();
-}
 
-WId QHaikuWindow::winId() const
-{
-    return (WId)static_cast<BWindow*>(m_window);
-}
+    QPlatformWindow::setGeometry(adjusted);
+    m_window->MoveTo(adjusted.left(), adjusted.top());
+    m_window->ResizeTo(adjusted.width() - 1, adjusted.height() - 1);
 
-BWindow* QHaikuWindow::nativeHandle() const
-{
-    return m_window;
+    if (m_visible) {
+        QWindowSystemInterface::handleGeometryChange(window(), adjusted);
+        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(), adjusted.size()));
+    } else {
+        m_pendingGeometryChangeOnShow = true;
+    }
 }
 
-void QHaikuWindow::requestActivateWindow()
-{
-    m_window->Activate(true);
-}
 
-void QHaikuWindow::setWindowState(Qt::WindowState state)
+void QHaikuWindow::setVisible(bool visible)
 {
-    if (m_windowState == state)
+    if (visible == m_visible)
         return;
 
-    const Qt::WindowState oldState = m_windowState;
-
-    m_windowState = state;
-
-    if (m_windowState == Qt::WindowMaximized) {
-        m_window->zoomByQt();
-    } else if (m_windowState == Qt::WindowMinimized) {
-        m_window->Minimize(true);
-    } else if (m_windowState == Qt::WindowNoState) {
-        if (oldState == Qt::WindowMaximized)
-            m_window->zoomByQt(); // undo zoom
-
-        if (oldState == Qt::WindowMinimized)
-            m_window->Minimize(false); // undo minimize
-    }
-}
-
-void QHaikuWindow::setWindowFlags(Qt::WindowFlags flags)
-{
-    const Qt::WindowType type = static_cast<Qt::WindowType>(static_cast<int>(flags & Qt::WindowType_Mask));
-
-    const bool isPopup = (type == Qt::Popup);
-    const bool isSplashScreen = (type == Qt::SplashScreen);
-    const bool isDialog = ((type == Qt::Dialog) || (type == Qt::Sheet) || (type == Qt::MSWindowsFixedSizeDialogHint));
-    const bool isTool = ((type == Qt::Tool) || (type == Qt::Drawer));
-    const bool isToolTip = (type == Qt::ToolTip);
-
-    window_look wlook = B_TITLED_WINDOW_LOOK;
-    window_feel wfeel = B_NORMAL_WINDOW_FEEL;
-    uint32 wflag = (B_NO_WORKSPACE_ACTIVATION | B_NOT_ANCHORED_ON_ACTIVATE);
+    if (visible) {
+        if (window()->type() != Qt::ToolTip)
+            QWindowSystemInterface::handleWindowActivated(window());
 
-    if (isTool) {
-        wlook = B_FLOATING_WINDOW_LOOK;
-        wflag |= B_WILL_ACCEPT_FIRST_CLICK;
+        if (m_pendingGeometryChangeOnShow) {
+            m_pendingGeometryChangeOnShow = false;
+            QWindowSystemInterface::handleGeometryChange(window(), geometry());
+        }
     }
 
-    if (isSplashScreen) {
-        wlook = B_NO_BORDER_WINDOW_LOOK;
+    if (visible) {
+        QRect rect(QPoint(), geometry().size());
+        QWindowSystemInterface::handleExposeEvent(window(), rect);
+    } else {
+        QWindowSystemInterface::handleExposeEvent(window(), QRegion());
     }
-
-    if (isPopup) {
-        wlook = B_NO_BORDER_WINDOW_LOOK;
-        wflag |= (B_WILL_ACCEPT_FIRST_CLICK | B_AVOID_FRONT | B_AVOID_FOCUS);
-        flags |= Qt::WindowStaysOnTopHint;
+    
+    if (visible) {
+    	m_window->Show();
+    } else {
+    	m_window->Hide();
     }
 
-    if (isDialog) {
-        if (window()->modality() == Qt::WindowModal)
-            wfeel = B_MODAL_SUBSET_WINDOW_FEEL;
-        else if (window()->modality() == Qt::ApplicationModal)
-            wfeel = B_MODAL_APP_WINDOW_FEEL;
-    }
+    m_visible = visible;
+}
 
-    if (isToolTip) {
-        wlook = B_NO_BORDER_WINDOW_LOOK;
-        wflag |= (B_WILL_ACCEPT_FIRST_CLICK | B_AVOID_FOCUS);
-        flags |= Qt::WindowStaysOnTopHint;
-    }
 
-    if (flags & Qt::FramelessWindowHint)
-        wlook = B_NO_BORDER_WINDOW_LOOK;
-
-    if (flags & Qt::MSWindowsFixedSizeDialogHint)
-        wflag |= (B_NOT_RESIZABLE | B_NOT_ZOOMABLE);
-
-    if (flags & Qt::CustomizeWindowHint) {
-        if (!(flags & Qt::WindowMinimizeButtonHint))
-            wflag |= B_NOT_MINIMIZABLE;
-        if (!(flags & Qt::WindowMaximizeButtonHint))
-            wflag |= B_NOT_ZOOMABLE;
-        if (!(flags & Qt::WindowCloseButtonHint))
-            wflag |= B_NOT_CLOSABLE;
-    }
+void QHaikuWindow::requestActivateWindow()
+{
+//    QHaikuWindow *focusWindow = 0;
+//    if (QGuiApplication::focusWindow())
+//        focusWindow = static_cast<QHaikuWindow*>(QGuiApplication::focusWindow()->handle());
 
-    if (flags & Qt::WindowStaysOnTopHint)
-        wfeel = B_FLOATING_ALL_WINDOW_FEEL;
+//    if (focusWindow == this)
+//        return;
 
-    m_window->SetLook(wlook);
-    m_window->SetFeel(wfeel);
-    m_window->SetFlags(wflag);
+//    if (window()->type() != Qt::Desktop)
+ //   m_window->Activate(true);
+    QWindowSystemInterface::handleWindowActivated(window());
+    QWindowSystemInterface::handleExposeEvent(window(), window()->geometry());
 }
 
-void QHaikuWindow::setWindowTitle(const QString &title)
-{
-    m_window->SetTitle(title.toLocal8Bit().constData());
-}
 
-void QHaikuWindow::propagateSizeHints()
+WId QHaikuWindow::winId() const
 {
-    m_window->SetSizeLimits(window()->minimumSize().width(),
-                            window()->maximumSize().width(),
-                            window()->minimumSize().height(),
-                            window()->maximumSize().height());
-
-    m_window->SetZoomLimits(window()->maximumSize().width(),
-                            window()->maximumSize().height());
+    return m_winId;
 }
 
-void QHaikuWindow::haikuWindowMoved(const QPoint &pos)
-{
-    const QRect newGeometry(pos, geometry().size());
 
-    QPlatformWindow::setGeometry(newGeometry);
-    QWindowSystemInterface::handleGeometryChange(window(), newGeometry);
-    QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(0, 0), newGeometry.size()));
-}
-
-void QHaikuWindow::haikuWindowResized(const QSize &size, bool zoomInProgress)
+QMargins QHaikuWindow::frameMargins() const
 {
-    const QRect newGeometry(geometry().topLeft(), size);
-
-    QPlatformWindow::setGeometry(newGeometry);
-    QWindowSystemInterface::handleGeometryChange(window(), newGeometry);
-    QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(0, 0), newGeometry.size()));
-
-    if ((m_windowState == Qt::WindowMaximized) && !zoomInProgress) {
-        // the user has resized the window while maximized -> reset maximized flag
-        m_windowState = Qt::WindowNoState;
-
-        QWindowSystemInterface::handleWindowStateChanged(window(), m_windowState);
-    }
+    return m_margins;
 }
 
-void QHaikuWindow::haikuWindowActivated(bool activated)
+
+void QHaikuWindow::raise()
 {
-    QWindowSystemInterface::handleWindowActivated(activated ? window() : Q_NULLPTR);
+    if (window()->type() != Qt::Desktop) {
+        m_window->Activate(true);
+    //    QWindowSystemInterface::handleExposeEvent(window(), window()->geometry());
+    }	
 }
 
-void QHaikuWindow::haikuWindowMinimized(bool minimize)
+void QHaikuWindow::lower()
 {
-    m_windowState = (minimize ? Qt::WindowMinimized : Qt::WindowNoState);
-
-    QWindowSystemInterface::handleWindowStateChanged(window(), m_windowState);
+    if (window()->type() != Qt::Desktop) {
+        m_window->Activate(false);
+      //  QWindowSystemInterface::handleExposeEvent(window(), window()->geometry());
+    }	
 }
 
-void QHaikuWindow::haikuWindowZoomed()
+
+void QHaikuWindow::setFrameMarginsEnabled(bool enabled)
 {
-    m_windowState = (m_windowState == Qt::WindowMaximized ? Qt::WindowNoState : Qt::WindowMaximized);
+    if (enabled && !(window()->flags() & Qt::FramelessWindowHint)) {
+    	BRect frame = m_window->Frame();
+    	BRect decoratorFrame = m_window->DecoratorFrame();
+    	    	    	
+		int left = frame.left - decoratorFrame.left;
+		int top = frame.top - decoratorFrame.top;
+		int right = decoratorFrame.right - frame.right;
+		int bottom = decoratorFrame.bottom - frame.bottom;
 
-    QWindowSystemInterface::handleWindowStateChanged(window(), m_windowState);
+		m_margins = QMargins(left, top, right, bottom);
+    } else
+        m_margins = QMargins(0, 0, 0, 0);
 }
 
-void QHaikuWindow::haikuWindowQuitRequested()
+void QHaikuWindow::setWindowState(Qt::WindowState state)
 {
-    QWindowSystemInterface::handleCloseEvent(window());
-}
+    setFrameMarginsEnabled(state != Qt::WindowFullScreen);
+    m_positionIncludesFrame = false;
+
+    switch (state) {
+    case Qt::WindowFullScreen:
+        setGeometryImpl(screen()->geometry());
+        break;
+    case Qt::WindowMaximized:
+    	m_normalGeometry = geometry();
+		setGeometryImpl(screen()->availableGeometry().adjusted(m_margins.left(),
+			m_margins.top(), -m_margins.right(), -m_margins.bottom()));
+		break;
+    case Qt::WindowMinimized:
+        break;
+    case Qt::WindowNoState:
+        setGeometryImpl(m_normalGeometry);
+        break;
+    default:
+        break;
+    }
 
-void QHaikuWindow::haikuMouseEvent(const QPoint &localPosition, const QPoint &globalPosition, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::MouseEventSource source)
-{
-    QWindowSystemInterface::handleMouseEvent(window(), localPosition, globalPosition,
-                                             buttons, modifiers, source);
+    QWindowSystemInterface::handleWindowStateChanged(window(), state);
 }
 
-void QHaikuWindow::haikuWheelEvent(const QPoint &localPosition, const QPoint &globalPosition, int delta, Qt::Orientation orientation, Qt::KeyboardModifiers modifiers)
-{
-    QWindowSystemInterface::handleWheelEvent(window(), localPosition, globalPosition, delta, orientation, modifiers);
-}
 
-void QHaikuWindow::haikuKeyEvent(QEvent::Type type, int key, Qt::KeyboardModifiers modifiers, const QString &text)
+QHaikuWindow *QHaikuWindow::windowForWinId(WId id)
 {
-    QWindowSystemInterface::handleKeyEvent(window(), type, key, modifiers, text);
+    return (QHaikuWindow*)id;
 }
 
-void QHaikuWindow::haikuEnteredView()
-{
-    QWindowSystemInterface::handleEnterEvent(window());
-}
 
-void QHaikuWindow::haikuExitedView()
+void 
+QHaikuWindow::FrameResized(float w, float h)
 {
-    QWindowSystemInterface::handleLeaveEvent(window());
+	QRect adjusted = geometry();
+	adjusted.setWidth(w + 1);
+	adjusted.setHeight(h + 1);
+	
+    QPlatformWindow::setGeometry(adjusted);
+    
+    if (m_visible) {
+        QWindowSystemInterface::handleGeometryChange(window(), adjusted);
+        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(), adjusted.size()));
+    } else {
+        m_pendingGeometryChangeOnShow = true;
+    }
 }
 
-void QHaikuWindow::haikuDrawRequest(const QRect &rect)
+
+void 
+QHaikuWindow::FrameMoved(BPoint point)
 {
-    QWindowSystemInterface::handleExposeEvent(window(), QRegion(rect));
+	QRect adjusted = geometry();
+	adjusted.moveTopLeft(QPoint(point.x, point.y));
+	
+    QPlatformWindow::setGeometry(adjusted);
+        
+    if (m_visible) {
+        QWindowSystemInterface::handleGeometryChange(window(), adjusted);
+        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(), adjusted.size()));
+    } else {
+        m_pendingGeometryChangeOnShow = true;
+    }
 }
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuwindow.h b/qtbase/src/plugins/platforms/haiku/qhaikuwindow.h
index 75403fb..d540219 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuwindow.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuwindow.h
@@ -1,7 +1,7 @@
 /***************************************************************************
 **
-** Copyright (C) 2015 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Tobias Koenig <tobias.koenig@kdab.com>
-** Contact: https://www.qt.io/licensing/
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+*** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the plugins of the Qt Toolkit.
 **
@@ -40,87 +40,94 @@
 #ifndef QHAIKUWINDOW_H
 #define QHAIKUWINDOW_H
 
+#include <qpa/qplatformbackingstore.h>
 #include <qpa/qplatformwindow.h>
 
 #include <Window.h>
+#include <Rect.h>
+#include <View.h>
 
-QT_BEGIN_NAMESPACE
+#if !defined(QT_NO_OPENGL)
+#include <GLView.h>
+#endif
 
-class HaikuWindowProxy : public QObject, public BWindow
-{
-    Q_OBJECT
+#include <qhash.h>
 
-public:
-    explicit HaikuWindowProxy(QWindow *window, const QRect &rect, QObject *parent = Q_NULLPTR);
+#include "qhaikuview.h"
 
-    void FrameMoved(BPoint pos) Q_DECL_OVERRIDE;
-    void FrameResized(float width, float height) Q_DECL_OVERRIDE;
-    void WindowActivated(bool activated) Q_DECL_OVERRIDE;
-    void Minimize(bool minimize) Q_DECL_OVERRIDE;
-    void Zoom(BPoint pos, float width, float height) Q_DECL_OVERRIDE;
-    bool QuitRequested() Q_DECL_OVERRIDE;
+QT_BEGIN_NAMESPACE
 
-    void zoomByQt();
+class QHaikuWindow;
 
-Q_SIGNALS:
-    void moved(const QPoint &pos);
-    void resized(const QSize &size, bool zoomInProgress);
-    void windowActivated(bool activated);
-    void minimized(bool minimize);
-    void zoomed();
-    void quitRequested();
 
-private:
-    bool m_qtCalledZoom;
-    bool m_zoomInProgress;
+class QtHaikuWindow : public BWindow
+{
+public:
+	QtHaikuWindow(QHaikuWindow *qwindow, BRect frame, const char *title, window_look look, window_feel feel, uint32 flags);
+	~QtHaikuWindow();
+
+	void FrameResized(float width, float height);
+	void FrameMoved(BPoint point);
+	void MessageReceived(BMessage* msg);
+	virtual void DispatchMessage(BMessage *, BHandler *);	
+	virtual void WindowActivated(bool active);
+	virtual bool QuitRequested();
+	
+	virtual void Zoom(BPoint origin, float w, float h);
+	
+	FBView *View(void);
+
+	FBView *fView;
+#if !defined(QT_NO_OPENGL)
+	BGLView *fGLView;
+#endif
+	QHaikuWindow *fQWindow;
 };
 
-class QHaikuWindow : public QObject, public QPlatformWindow
+class QHaikuWindow : public QPlatformWindow
 {
-    Q_OBJECT
-
 public:
-    explicit QHaikuWindow(QWindow *window);
-    virtual ~QHaikuWindow();
+    QHaikuWindow(QWindow *window);
+    ~QHaikuWindow();
 
-    void setGeometry(const QRect &rect) Q_DECL_OVERRIDE;
-    QMargins frameMargins() const Q_DECL_OVERRIDE;
-    void setVisible(bool visible) Q_DECL_OVERRIDE;
+    void setGeometry(const QRect &rect);
+    void setWindowTitle(const QString &title);
+    void setWindowState(Qt::WindowState state);
+    void setWindowFlags(Qt::WindowFlags flags);
 
-    bool isExposed() const Q_DECL_OVERRIDE;
-    bool isActive() const Q_DECL_OVERRIDE;
+    QMargins frameMargins() const;
 
-    WId winId() const Q_DECL_OVERRIDE;
-    BWindow* nativeHandle() const;
+    void setVisible(bool visible);
+    void requestActivateWindow();
+    
+    bool setKeyboardGrabEnabled(bool) Q_DECL_OVERRIDE { return false; }
+    bool setMouseGrabEnabled(bool) Q_DECL_OVERRIDE { return false; }
+    void propagateSizeHints();
+    
+    void FrameResized(float w, float h);
+    void FrameMoved(BPoint point);
 
-    void requestActivateWindow() Q_DECL_OVERRIDE;
-    void setWindowState(Qt::WindowState state) Q_DECL_OVERRIDE;
-    void setWindowFlags(Qt::WindowFlags flags) Q_DECL_OVERRIDE;
+    WId winId() const;
+    
+    void raise();
+    void lower();
 
-    void setWindowTitle(const QString &title) Q_DECL_OVERRIDE;
+    static QHaikuWindow *windowForWinId(WId id);
 
-    void propagateSizeHints() Q_DECL_OVERRIDE;
+    QtHaikuWindow *m_window;
 
-protected:
-    HaikuWindowProxy *m_window;
-
-private Q_SLOTS:
-    void haikuWindowMoved(const QPoint &pos);
-    void haikuWindowResized(const QSize &size, bool zoomInProgress);
-    void haikuWindowActivated(bool activated);
-    void haikuWindowMinimized(bool minimize);
-    void haikuWindowZoomed();
-    void haikuWindowQuitRequested();
+private:
+    void setFrameMarginsEnabled(bool enabled);
+    void setGeometryImpl(const QRect &rect);
 
-    void haikuMouseEvent(const QPoint &localPosition, const QPoint &globalPosition, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::MouseEventSource source);
-    void haikuWheelEvent(const QPoint &localPosition, const QPoint &globalPosition, int delta, Qt::Orientation orientation, Qt::KeyboardModifiers modifiers);
-    void haikuKeyEvent(QEvent::Type type, int key, Qt::KeyboardModifiers modifiers, const QString &text);
-    void haikuEnteredView();
-    void haikuExitedView();
-    void haikuDrawRequest(const QRect &rect);
+    QRect m_normalGeometry;
+    QMargins m_margins;
+    bool m_positionIncludesFrame;
+    bool m_visible;
+    bool m_pendingGeometryChangeOnShow;
+    WId m_winId;
 
-private:
-    Qt::WindowState m_windowState;
+    static QHash<WId, QHaikuWindow *> m_windowForWinIdHash;
 };
 
 QT_END_NAMESPACE
-- 
2.12.2


From b4b66070154f6127dcd10f32c926dda4be6b6709 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Revol?= <revol@free.fr>
Date: Mon, 11 Apr 2016 01:04:24 +0200
Subject: Add filteredDeviceFilePaths for Haiku's /dev/ports/*


diff --git a/qtserialport/src/serialport/qserialportinfo_unix.cpp b/qtserialport/src/serialport/qserialportinfo_unix.cpp
index 0f62a9d..afd5c0b 100644
--- a/qtserialport/src/serialport/qserialportinfo_unix.cpp
+++ b/qtserialport/src/serialport/qserialportinfo_unix.cpp
@@ -79,13 +79,20 @@ static QStringList filteredDeviceFilePaths()
     << QStringLiteral("cu*");
 #elif defined(Q_OS_QNX)
     << QStringLiteral("ser*");
+#elif defined(Q_OS_HAIKU)
+    << QStringLiteral("*serial*")
+    << QStringLiteral("usb*");
 #else
     ;
 #endif
 
     QStringList result;
 
+#if defined(Q_OS_HAIKU)
+    QDir deviceDir(QStringLiteral("/dev/ports"));
+#else
     QDir deviceDir(QStringLiteral("/dev"));
+#endif
     if (deviceDir.exists()) {
         deviceDir.setNameFilters(deviceFileNameFilterList);
         deviceDir.setFilter(QDir::Files | QDir::System | QDir::NoSymLinks);
-- 
2.12.2


From 8fb85ed2f4ca47caac9a181e7594c85cc960d545 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Revol?= <revol@free.fr>
Date: Sat, 12 Nov 2016 03:19:40 +0100
Subject: Make sure libs are searched in the develop/ dir by CMake

Static libs at least are not in the lib[/x86] dirs...

diff --git a/qtbase/mkspecs/features/create_cmake.prf b/qtbase/mkspecs/features/create_cmake.prf
index bb5083c..b286bed 100644
--- a/qtbase/mkspecs/features/create_cmake.prf
+++ b/qtbase/mkspecs/features/create_cmake.prf
@@ -84,6 +84,9 @@ win32:!static:!staticlib {
         CMAKE_DLL_DIR = $$[QT_INSTALL_BINS]/
         CMAKE_DLL_DIR_IS_ABSOLUTE = True
     }
+} else:haiku {
+    CMAKE_DLL_DIR = develop/$$CMAKE_LIB_DIR
+    CMAKE_DLL_DIR_IS_ABSOLUTE = $$CMAKE_LIB_DIR_IS_ABSOLUTE
 } else {
     CMAKE_DLL_DIR = $$CMAKE_LIB_DIR
     CMAKE_DLL_DIR_IS_ABSOLUTE = $$CMAKE_LIB_DIR_IS_ABSOLUTE
-- 
2.12.2


From b4febbf706ec7c41d90a7075861a98b549129671 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Sat, 4 Mar 2017 10:39:18 +0100
Subject: Haiku PlatformSupport changes.


diff --git a/qtbase/src/plugins/platforms/haiku/haiku.pro b/qtbase/src/plugins/platforms/haiku/haiku.pro
index 381d842..4eacb7d 100644
--- a/qtbase/src/plugins/platforms/haiku/haiku.pro
+++ b/qtbase/src/plugins/platforms/haiku/haiku.pro
@@ -1,6 +1,10 @@
 TARGET = qhaiku
 
-QT += core-private gui-private eventdispatcher_support-private
+QT += \
+	core-private gui-private \
+	eventdispatcher_support-private fontdatabase_support-private \
+	theme_support-private
+
 LIBS += -lbe -lroot -ltracker
 # -lfreetype
 INCLUDEPATH += $$QT_SOURCE_TREE/src/3rdparty/freetype/include
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
index 5a55498..abe5c88 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
@@ -42,10 +42,10 @@
 #include "qhaikucommon.h"
 #include "qhaikutheme.h"
 
-#include <QtPlatformSupport/private/qgenericunixeventdispatcher_p.h>
+#include <QtEventDispatcherSupport/private/qgenericunixeventdispatcher_p.h>
 #include <qpa/qplatformfontdatabase.h>
-#include <QtPlatformSupport/private/qgenericunixfontdatabase_p.h>
-#include <QtPlatformSupport/private/qbasicfontdatabase_p.h>
+#include <QtFontDatabaseSupport/private/qgenericunixfontdatabase_p.h>
+#include <QtFontDatabaseSupport/private/qbasicfontdatabase_p.h>
 #include <QtGui/private/qpixmap_raster_p.h>
 #include <QtGui/private/qguiapplication_p.h>
 
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
index d3a9cbe..2d27d06 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
@@ -40,7 +40,7 @@
 #ifndef QANDROIDPLATFORMFONTDATABASE_H
 #define QANDROIDPLATFORMFONTDATABASE_H
 
-#include <QtPlatformSupport/private/qbasicfontdatabase_p.h>
+#include <QtFontDatabaseSupport/private/qbasicfontdatabase_p.h>
 
 class QHaikuPlatformFontDatabase: public QBasicFontDatabase
 {
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikutheme.cpp b/qtbase/src/plugins/platforms/haiku/qhaikutheme.cpp
index 086b5c1..cd61ebd 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikutheme.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikutheme.cpp
@@ -43,6 +43,7 @@
 #include "qhaikusystemsettings.h"
 #include "qhaikuintegration.h"
 
+#include <QtThemeSupport/private/qabstractfileiconengine_p.h>
 #include <qdebug.h>
 
 #include <Rect.h>
@@ -153,10 +154,23 @@ QPixmap QHaikuTheme::standardPixmap(StandardPixmap sp, const QSizeF &size) const
 	return QPlatformTheme::standardPixmap(sp, size);
 }
 
-QPixmap QHaikuTheme::fileIconPixmap(const QFileInfo &fileInfo, const QSizeF &size,
-                                      QPlatformTheme::IconOptions iconOptions) const
+class QHaikuFileIconEngine : public QAbstractFileIconEngine
 {
-	BFile file(fileInfo.filePath().toUtf8(), O_RDONLY);
+public:
+    explicit QHaikuFileIconEngine(const QFileInfo &info,
+                                    QPlatformTheme::IconOptions opts) :
+        QAbstractFileIconEngine(info, opts) {}
+
+    //QList<QSize> availableSizes(QIcon::Mode = QIcon::Normal, QIcon::State = QIcon::Off) const override
+    //{ return QHaikuTheme::instance()->availableFileIconSizes(); }
+
+protected:
+    QPixmap filePixmap(const QSize &size, QIcon::Mode mode, QIcon::State) override;
+};
+
+QPixmap QHaikuFileIconEngine::filePixmap(const QSize &size, QIcon::Mode, QIcon::State)
+{
+	BFile file(fileInfo().filePath().toUtf8(), O_RDONLY);
 	BNodeInfo nodeInfo(&file);
 	icon_size iconSize = size.width() > 16 ? B_LARGE_ICON : B_MINI_ICON;
 	BRect rect(0, 0, iconSize - 1, iconSize -1);
@@ -167,7 +181,13 @@ QPixmap QHaikuTheme::fileIconPixmap(const QFileInfo &fileInfo, const QSizeF &siz
 		QPixmap pixmap = QPixmap::fromImage(image);
 		return pixmap;
 	}
-	return QPlatformTheme::fileIconPixmap(fileInfo, size);
+	 QPixmap pixmap;
+	return pixmap;
 }
 
+QIcon QHaikuTheme::fileIcon(const QFileInfo &fileInfo, QPlatformTheme::IconOptions iconOptions) const
+{
+    return QIcon(new QHaikuFileIconEngine(fileInfo, iconOptions));
+ }
+
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikutheme.h b/qtbase/src/plugins/platforms/haiku/qhaikutheme.h
index dba27ee..0af18a6 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikutheme.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikutheme.h
@@ -70,7 +70,7 @@ public:
     const QPalette *palette(Palette type = SystemPalette) const;
 
     virtual QPixmap standardPixmap(StandardPixmap sp, const QSizeF &size) const;
-    virtual QPixmap fileIconPixmap(const QFileInfo &fileInfo, const QSizeF &size,
+    virtual QIcon fileIcon(const QFileInfo &fileInfo,
                                    QPlatformTheme::IconOptions iconOptions = 0) const;
 
 private:
-- 
2.12.2


From 438e24aff5fc731cbd32c77bb97e3c9859d0b69e Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Sat, 4 Mar 2017 10:41:09 +0100
Subject: Haiku also provides bluetooth/bluetooth.h, so check for Bluez a bit
 more.


diff --git a/qtconnectivity/config.tests/bluez/main.cpp b/qtconnectivity/config.tests/bluez/main.cpp
index 0b9235a..bfc2a0c 100644
--- a/qtconnectivity/config.tests/bluez/main.cpp
+++ b/qtconnectivity/config.tests/bluez/main.cpp
@@ -30,5 +30,6 @@
 
 int main()
 {
+    bacmp(BDADDR_ANY, BDADDR_NONE);
     return 0;
 }
-- 
2.12.2


From 735cd07ecf93602e1c838d071c9d39f1b2ee6295 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Thu, 9 Mar 2017 23:57:24 +0100
Subject: update to QtFontDatabaseSupport.


diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
index 0b5d24c..6c29d98 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
@@ -39,7 +39,7 @@
 
 #include <QDir>
 #include <QDirIterator>
-#include <QtGui/private/qfontengine_ft_p.h>
+#include <QtFontDatabaseSupport/private/qfontengine_ft_p.h>
 
 #include "qhaikuplatformfontdatabase.h"
 
-- 
2.12.2


From 5b684f2f86e2d30f0d3907d616778ee1a02508e7 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Thu, 23 Mar 2017 21:08:37 +0100
Subject: enable QV4 JIT.


diff --git a/qtdeclarative/src/qml/jit/qv4targetplatform_p.h b/qtdeclarative/src/qml/jit/qv4targetplatform_p.h
index 6d788f4..c4c47ea 100644
--- a/qtdeclarative/src/qml/jit/qv4targetplatform_p.h
+++ b/qtdeclarative/src/qml/jit/qv4targetplatform_p.h
@@ -90,7 +90,7 @@ class TargetPlatform
 {
 };
 
-#if CPU(X86) && (OS(LINUX) || OS(WINDOWS) || OS(QNX) || OS(FREEBSD) || defined(Q_OS_IOS))
+#if CPU(X86) && (OS(LINUX) || OS(WINDOWS) || OS(QNX) || OS(FREEBSD) || defined(Q_OS_IOS) || OS(HAIKU) )
 template <>
 class TargetPlatform<JSC::MacroAssemblerX86, NoOperatingSystemSpecialization>
 {
@@ -150,7 +150,7 @@ public:
     }
 
 #if OS(WINDOWS) || OS(QNX) || \
-    ((OS(LINUX) || OS(FREEBSD)) && (defined(__PIC__) || defined(__PIE__)))
+    ((OS(LINUX) || OS(FREEBSD) || OS(HAIKU)) && (defined(__PIC__) || defined(__PIE__)))
 
     static const int gotRegister = JSC::X86Registers::ebx;
     static int savedGOTRegisterSlotOnStack() {
@@ -178,7 +178,7 @@ public:
 };
 #endif // x86
 
-#if CPU(X86_64) && (OS(LINUX) || OS(MAC_OS_X) || OS(FREEBSD) || OS(QNX) || defined(Q_OS_IOS))
+#if CPU(X86_64) && (OS(LINUX) || OS(MAC_OS_X) || OS(FREEBSD) || OS(HAIKU) ||OS(QNX) || defined(Q_OS_IOS))
 template <>
 class TargetPlatform<JSC::MacroAssemblerX86_64, NoOperatingSystemSpecialization>
 {
diff --git a/qtdeclarative/src/qml/jsruntime/qv4global_p.h b/qtdeclarative/src/qml/jsruntime/qv4global_p.h
index 3abda68..0eef251 100644
--- a/qtdeclarative/src/qml/jsruntime/qv4global_p.h
+++ b/qtdeclarative/src/qml/jsruntime/qv4global_p.h
@@ -92,10 +92,10 @@ inline double trunc(double d) { return d > 0 ? floor(d) : ceil(d); }
 // NOTE: This should match the logic in qv4targetplatform_p.h!
 
 #if defined(Q_PROCESSOR_X86) && (QT_POINTER_SIZE == 4) \
-    && (defined(Q_OS_WIN) || defined(Q_OS_LINUX) || defined(Q_OS_QNX) || defined(Q_OS_FREEBSD))
+    && (defined(Q_OS_WIN) || defined(Q_OS_LINUX) || defined(Q_OS_QNX) || defined(Q_OS_FREEBSD) || defined(Q_OS_HAIKU))
 #  define V4_ENABLE_JIT
 #elif defined(Q_PROCESSOR_X86_64) && (QT_POINTER_SIZE == 8) \
-    && (defined(Q_OS_WIN) || defined(Q_OS_LINUX) || defined(Q_OS_MAC) || defined(Q_OS_FREEBSD))
+    && (defined(Q_OS_WIN) || defined(Q_OS_LINUX) || defined(Q_OS_MAC) || defined(Q_OS_FREEBSD) || defined(Q_OS_HAIKU))
 #  define V4_ENABLE_JIT
 #elif defined(Q_PROCESSOR_ARM_32) && (QT_POINTER_SIZE == 4)
 #  if defined(thumb2) || defined(__thumb2__) || ((defined(__thumb) || defined(__thumb__)) && __TARGET_ARCH_THUMB-0 == 4)
-- 
2.12.2


From 8db45a7485c59ba8b68dda5ffb507f4c0530f8e9 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Mon, 10 Apr 2017 19:52:46 +0200
Subject: disable mapbox-gl-native on Haiku.


diff --git a/qtlocation/src/plugins/geoservices/geoservices.pro b/qtlocation/src/plugins/geoservices/geoservices.pro
index 459897a..6d19b96 100644
--- a/qtlocation/src/plugins/geoservices/geoservices.pro
+++ b/qtlocation/src/plugins/geoservices/geoservices.pro
@@ -6,7 +6,7 @@ qtConfig(concurrent) {
     SUBDIRS += osm
 }
 
-qtConfig(opengl):qtConfig(c++14):!win32|mingw:!qnx {
+qtConfig(opengl):qtConfig(c++14):!win32|mingw:!qnx:!haiku {
     !exists(../../3rdparty/mapbox-gl-native/CMakeLists.txt) {
         warning("Submodule mapbox-gl-native does not exist. Run 'git submodule update --init' on qtlocation.")
     } else {
-- 
2.12.2


From 59a4c7bbf122c4a30e2b516b0be00e3a58b5a301 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Sat, 22 Apr 2017 13:10:20 +0200
Subject: Rename QBasicFontDatabase to QFreeTypeFontDatabase.


diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
index abe5c88..96c90ae 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuintegration.cpp
@@ -45,7 +45,7 @@
 #include <QtEventDispatcherSupport/private/qgenericunixeventdispatcher_p.h>
 #include <qpa/qplatformfontdatabase.h>
 #include <QtFontDatabaseSupport/private/qgenericunixfontdatabase_p.h>
-#include <QtFontDatabaseSupport/private/qbasicfontdatabase_p.h>
+#include <QtFontDatabaseSupport/private/qfreetypefontdatabase_p.h>
 #include <QtGui/private/qpixmap_raster_p.h>
 #include <QtGui/private/qguiapplication_p.h>
 
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
index 6c29d98..a3858ba 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.cpp
@@ -145,5 +145,5 @@ void QHaikuPlatformFontDatabase::releaseHandle(void *handle)
 {
     if (!handle)
         return;
-    QBasicFontDatabase::releaseHandle(handle);
+    QFreeTypeFontDatabase::releaseHandle(handle);
 }
diff --git a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
index 2d27d06..f79f087 100644
--- a/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
+++ b/qtbase/src/plugins/platforms/haiku/qhaikuplatformfontdatabase.h
@@ -40,9 +40,9 @@
 #ifndef QANDROIDPLATFORMFONTDATABASE_H
 #define QANDROIDPLATFORMFONTDATABASE_H
 
-#include <QtFontDatabaseSupport/private/qbasicfontdatabase_p.h>
+#include <QtFontDatabaseSupport/private/qfreetypefontdatabase_p.h>
 
-class QHaikuPlatformFontDatabase: public QBasicFontDatabase
+class QHaikuPlatformFontDatabase: public QFreeTypeFontDatabase
 {
 public:
     QString fontDir() const;
-- 
2.12.2


From 3db19f454e555219276af053d8527d6163bda91a Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Wed, 31 May 2017 20:58:35 +0200
Subject: fix build in tiff imageformats plugin.

tip from 3deyes!

diff --git a/qtimageformats/src/plugins/imageformats/tiff/qtiffhandler.cpp b/qtimageformats/src/plugins/imageformats/tiff/qtiffhandler.cpp
index 81ad7e9..8f3d3e4 100644
--- a/qtimageformats/src/plugins/imageformats/tiff/qtiffhandler.cpp
+++ b/qtimageformats/src/plugins/imageformats/tiff/qtiffhandler.cpp
@@ -335,8 +335,8 @@ bool QTiffHandler::read(QImage *image)
     }
 
     TIFF *const tiff = d->tiff;
-    const uint32 width = d->size.width();
-    const uint32 height = d->size.height();
+    const quint32 width = d->size.width();
+    const quint32 height = d->size.height();
 
     if (format == QImage::Format_Mono || format == QImage::Format_Indexed8 || format == QImage::Format_Grayscale8) {
         if (format == QImage::Format_Mono) {
-- 
2.12.2


From cf819b41ff25452a8048ae1deefa30ccb580cc5a Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Wed, 31 May 2017 21:59:22 +0200
Subject: fix qt3d build on x86.


diff --git a/qt3d/src/3rdparty/assimp/contrib/rapidjson/include/rapidjson/document.h b/qt3d/src/3rdparty/assimp/contrib/rapidjson/include/rapidjson/document.h
index 98053cb..57ca638 100644
--- a/qt3d/src/3rdparty/assimp/contrib/rapidjson/include/rapidjson/document.h
+++ b/qt3d/src/3rdparty/assimp/contrib/rapidjson/include/rapidjson/document.h
@@ -545,7 +545,8 @@ public:
             flags_ |= kIntFlag;
     }
 
-#if defined(__APPLE__)
+#if defined(__APPLE__) || defined(__HAIKU__)
+#if !defined(__HAIKU__)
     //! Constructor for unsigned long value.
     explicit GenericValue(unsigned long u64) RAPIDJSON_NOEXCEPT : data_(), flags_(kNumberUint64Flag) {
         data_.n.u64 = u64;
@@ -556,6 +557,7 @@ public:
         if (!(u64 & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
             flags_ |= kIntFlag;
     }
+#endif
 
 #if !defined(__x86_64__) && !defined(__arm64__)
     //! Constructor for size_t value.
-- 
2.12.2


From 69106579e7943e0e7075c69dd1c2ab9d38d94e7c Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Fri, 9 Jun 2017 19:47:02 +0200
Subject: QSslSocketPrivate::unixRootCertDirectories(): add ssl path for Haiku.


diff --git a/qtbase/src/network/ssl/qsslsocket.cpp b/qtbase/src/network/ssl/qsslsocket.cpp
index 84b8f3a..62b63ab 100644
--- a/qtbase/src/network/ssl/qsslsocket.cpp
+++ b/qtbase/src/network/ssl/qsslsocket.cpp
@@ -2658,6 +2658,7 @@ QList<QByteArray> QSslSocketPrivate::unixRootCertDirectories()
                                << "/usr/local/ssl/certs/" // Solaris
                                << "/etc/openssl/certs/" // BlackBerry
                                << "/opt/openssl/certs/" // HP-UX
+                               << "/system/data/ssl/" // Haiku
                                << "/etc/ssl/"; // OpenBSD
 }
 
-- 
2.12.2

