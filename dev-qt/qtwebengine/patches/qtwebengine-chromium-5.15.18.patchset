From 57aa28e5f662a5cc5267c93234907ab856cc1f8f Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Thu, 7 Dec 2023 18:33:47 +1000
Subject: =?UTF-8?q?Patchset=20based=20on=20qtwebengine=20patches=20for=20F?=
 =?UTF-8?q?reeBSD,=20as=20well=20as=20patches=20by=20Kacper=20Kasper=20(Ka?=
 =?UTF-8?q?pix),=20J=C3=A9r=C3=B4me=20Duval=20(korli)=20and=20Gerasim=20Tr?=
 =?UTF-8?q?oeglazov=20(3dEyes).?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit


diff --git a/chromium/BUILD.gn b/chromium/BUILD.gn
index 8d9657d..5f6954b 100644
--- a/chromium/BUILD.gn
+++ b/chromium/BUILD.gn
@@ -423,7 +423,7 @@ group("gn_all") {
     ]
   }
 
-  if (is_linux || is_chromeos || is_android) {
+  if ((is_linux && !is_haiku) || is_chromeos || is_android) {
     deps += [
       "//third_party/breakpad:breakpad_unittests",
       "//third_party/breakpad:core-2-minidump",
@@ -464,8 +464,6 @@ group("gn_all") {
       "//net:disk_cache_memory_test",
       "//net:quic_client",
       "//net:quic_server",
-      "//sandbox/linux:chrome_sandbox",
-      "//sandbox/linux:sandbox_linux_unittests",
       "//testing:empty_main",
     ]
 
@@ -520,10 +518,6 @@ group("gn_all") {
         "//chrome/test:load_library_perf_tests",
         "//chrome/test:sync_performance_tests",
         "//chrome/test/chromedriver:chromedriver",
-        "//courgette:courgette",
-        "//courgette:courgette_fuzz",
-        "//courgette:courgette_minimal_tool",
-        "//courgette:courgette_unittests",
         "//media/cast:generate_barcode_video",
         "//media/cast:generate_timecode_audio",
         "//net:crash_cache",
@@ -595,13 +589,9 @@ group("gn_all") {
       "//mojo:mojo_perftests",
       "//services/service_manager/public/cpp",
       "//testing/gmock:gmock_main",
-      "//third_party/breakpad:dump_syms($host_toolchain)",
-      "//third_party/breakpad:microdump_stackwalk($host_toolchain)",
-      "//third_party/breakpad:minidump_dump($host_toolchain)",
-      "//third_party/breakpad:minidump_stackwalk($host_toolchain)",
     ]
 
-    if (!is_android) {
+    if (!is_android && !is_haiku) {
       deps += [
         "//chrome/test:chrome_app_unittests",
         "//gpu/khronos_glcts_support:khronos_glcts_test",
@@ -676,7 +666,7 @@ group("gn_all") {
         host_os == "win" && !use_qt) {
       deps += [ "//chrome/test/mini_installer:mini_installer_tests" ]
     }
-  } else if (!is_android && !is_ios && !is_fuchsia && !is_win) {
+  } else if (!is_android && !is_ios && !is_fuchsia && !is_win && !is_haiku) {
     deps += [ "//third_party/breakpad:symupload($host_toolchain)" ]
   }
 
@@ -810,7 +800,6 @@ group("gn_all") {
       "//chrome/browser/vr:vr_common_perftests",
       "//chrome/browser/vr:vr_common_unittests",
       "//chrome/browser/vr:vr_pixeltests",
-      "//tools/perf/contrib/vr_benchmarks:vr_perf_tests",
     ]
     if (is_android) {
       deps += [ "//chrome/browser/android/vr:vr_android_unittests" ]
@@ -1103,7 +1092,7 @@ if (!is_ios && !use_qt) {
       data_deps += [ "//content/web_test:web_test_common_mojom_js_data_deps" ]
     }
 
-    if (!is_win && !is_android) {
+    if (!is_win && !is_android && !is_haiku) {
       data_deps +=
           [ "//third_party/breakpad:minidump_stackwalk($host_toolchain)" ]
     }
@@ -1112,7 +1101,7 @@ if (!is_ios && !use_qt) {
       data_deps += [ "//third_party/breakpad:dump_syms($host_toolchain)" ]
     }
 
-    if (is_linux || is_chromeos) {
+    if ((is_linux && !is_haiku) || is_chromeos) {
       data_deps += [ "//third_party/breakpad:dump_syms($host_toolchain)" ]
     }
 
@@ -1308,9 +1297,6 @@ group("chromium_builder_perf") {
 
     if (is_win) {
       data_deps += [ "//chrome/installer/mini_installer:mini_installer" ]
-    } else {
-      data_deps +=
-          [ "//third_party/breakpad:minidump_stackwalk($host_toolchain)" ]
     }
     if (is_win || is_android) {
       data_deps += [
@@ -1420,6 +1406,7 @@ assert(
                      "*\bmac/*",
                      "*\bposix/*",
                      "*\bwin/*",
+                     "*\bhaiku/*",
                    ]) != [],
     "Do not use a platform name in your output directory (found \"$root_build_dir\"). http://crbug.com/548283")
 
diff --git a/chromium/base/BUILD.gn b/chromium/base/BUILD.gn
index c15b2b2..03bde29 100644
--- a/chromium/base/BUILD.gn
+++ b/chromium/base/BUILD.gn
@@ -54,7 +54,7 @@ declare_args() {
   # replacement base::Location::Current(). On by default in non-official builds
   # for testing purposes.
   # TODO(https://crbug.com/974061): remove this eventually.
-  from_here_uses_location_builtins = !is_official_build
+  from_here_uses_location_builtins = !is_official_build && !is_haiku
 
   # Unsafe developer build. Has developer-friendly features that may weaken or
   # disable security measures like sandboxing or ASLR.
@@ -886,7 +886,7 @@ jumbo_component("base") {
       "timer/hi_res_timer_manager_posix.cc",
     ]
 
-    if (!is_nacl && !is_apple) {
+    if (!is_nacl && !is_apple && !is_haiku) {
       sources += [
         "cpu_affinity_posix.cc",
         "cpu_affinity_posix.h",
@@ -897,6 +897,12 @@ jumbo_component("base") {
         "profiler/thread_delegate_posix.h",
       ]
     }
+
+    if (is_haiku) {
+      sources += [
+        "profiler/stack_sampler_posix.cc",
+      ]
+    }
   }
 
   jumbo_excluded_sources = [
@@ -1213,7 +1219,9 @@ jumbo_component("base") {
       "process/process_metrics_linux.cc",
       "threading/platform_thread_linux.cc",
     ]
-    jumbo_excluded_sources += [ "process/memory_linux.cc" ]
+    #jumbo_excluded_sources += [ "process/memory_linux.cc" ]
+    jumbo_excluded_sources += [ "metrics/histogram.cc" ]
+    jumbo_excluded_sources += [ "metrics/sparse_histogram.cc" ]
   }
 
   if (!is_nacl) {
@@ -1355,7 +1363,7 @@ jumbo_component("base") {
           "allocator/allocator_shim_default_dispatch_to_mac_zoned_malloc.cc",
         ]
       }
-      if (is_chromeos || is_linux) {
+      if (is_chromeos || (is_linux && !is_haiku)) {
         sources += [ "allocator/allocator_shim_default_dispatch_to_glibc.cc" ]
       }
       if (is_win) {
@@ -1826,7 +1834,7 @@ jumbo_component("base") {
         ]
       }
 
-      if (is_linux || is_chromeos || is_android) {
+      if ((is_linux && !is_haiku) || is_chromeos || is_android) {
         sources += [
           "allocator/partition_allocator/spinning_futex_linux.cc",
           "allocator/partition_allocator/spinning_futex_linux.h",
@@ -1982,6 +1990,36 @@ jumbo_component("base") {
     }
   }
 
+  if (is_haiku) {
+    sources -= [ 
+      "process/memory_linux.cc",
+      "process/process_handle_linux.cc",
+      "process/process_iterator_linux.cc",
+      "process/process_metrics_linux.cc",
+      "files/file_path_watcher_linux.cc",
+      "files/file_util_linux.cc",
+      "system/sys_info_linux.cc",
+      "threading/platform_thread_linux.cc",
+      "debug/proc_maps_linux.cc",
+      "debug/proc_maps_linux.h",
+    ]
+#      "memory/madv_free_discardable_memory_posix.cc",
+#     "memory/madv_free_discardable_memory_posix.h",
+    sources += [
+      "base_paths_haiku.cc",
+      "base_paths_haiku.h",
+      "files/file_path_watcher_stub.cc",
+      "process/memory_stubs.cc",
+      "process/process_handle_haiku.cc",
+      "process/process_iterator_haiku.cc",
+      "process/process_metrics_haiku.cc",
+      "threading/platform_thread_haiku.cc",
+      "system/sys_info_haiku.cc"
+    ]
+
+    defines += [ "_BSD_SOURCE", "__USE_XOPEN2K8" ]
+  }
+
   # iOS
   if (is_ios) {
     sources -= [
diff --git a/chromium/base/base_paths_haiku.cc b/chromium/base/base_paths_haiku.cc
new file mode 100644
index 0000000..ca8aa43
--- /dev/null
+++ b/chromium/base/base_paths_haiku.cc
@@ -0,0 +1,21 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/base_paths.h"
+
+#include <stdlib.h>
+
+#include "base/base_paths_haiku.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+#include "base/process/process.h"
+
+namespace base {
+
+bool PathProviderHaiku(int key, FilePath* result) {
+  return false;
+}
+
+}  // namespace base
diff --git a/chromium/base/base_paths_haiku.h b/chromium/base/base_paths_haiku.h
new file mode 100644
index 0000000..d30b52a
--- /dev/null
+++ b/chromium/base/base_paths_haiku.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_BASE_PATHS_HAIKU_H_
+#define BASE_BASE_PATHS_HAIKU_H_
+
+#include "base/base_export.h"
+#include "base/files/file_path.h"
+
+namespace base {
+
+// These can be used with the PathService to access various special
+// directories and files.
+enum {
+  PATH_HAIKU_START = 1200,
+
+  // Path to the directory which contains application user data.
+  DIR_APP_DATA,
+
+  PATH_HAIKU_END,
+};
+
+}  // namespace base
+
+#endif  // BASE_BASE_PATHS_HAIKU_H_
diff --git a/chromium/base/base_switches.cc b/chromium/base/base_switches.cc
index 8c8563e..4b73087 100644
--- a/chromium/base/base_switches.cc
+++ b/chromium/base/base_switches.cc
@@ -117,7 +117,7 @@ const char kDisableHighResTimer[] = "disable-highres-timer";
 const char kDisableUsbKeyboardDetect[]      = "disable-usb-keyboard-detect";
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
+#if (defined(OS_LINUX) || defined(OS_HAIKU)) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
 // The /dev/shm partition is too small in certain VM environments, causing
 // Chrome to fail or crash (see http://crbug.com/715363). Use this flag to
 // work-around this issue (a temporary directory will always be used to create
diff --git a/chromium/base/base_switches.h b/chromium/base/base_switches.h
index ce6d2db..b885653 100644
--- a/chromium/base/base_switches.h
+++ b/chromium/base/base_switches.h
@@ -39,7 +39,7 @@ extern const char kDisableHighResTimer[];
 extern const char kDisableUsbKeyboardDetect[];
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
+#if (defined(OS_LINUX) || defined(OS_HAIKU)) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
 extern const char kDisableDevShmUsage[];
 #endif
 
diff --git a/chromium/base/cpu.cc b/chromium/base/cpu.cc
index 2a5b803..9312918 100644
--- a/chromium/base/cpu.cc
+++ b/chromium/base/cpu.cc
@@ -17,7 +17,7 @@
 #include "base/stl_util.h"
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
 #include "base/containers/flat_set.h"
 #include "base/files/file_util.h"
 #include "base/no_destructor.h"
diff --git a/chromium/base/cpu.h b/chromium/base/cpu.h
index 2e2d29a..0f3b681 100644
--- a/chromium/base/cpu.h
+++ b/chromium/base/cpu.h
@@ -74,7 +74,7 @@ class BASE_EXPORT CPU final {
   const std::string& cpu_brand() const { return cpu_brand_; }
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
   enum class CoreType {
     kUnknown = 0,
     kOther,
@@ -125,7 +125,7 @@ class BASE_EXPORT CPU final {
   using CoreIdleTimes = std::vector<TimeDelta>;
   static bool GetCumulativeCoreIdleTimes(CoreIdleTimes&);
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) ||
-        // defined(OS_AIX)
+        // defined(OS_AIX) || defined(OS_HAIKU)
 
  private:
   // Query the processor for CPUID information.
diff --git a/chromium/base/debug/elf_reader.cc b/chromium/base/debug/elf_reader.cc
index 0389c44..8bc5fb2 100644
--- a/chromium/base/debug/elf_reader.cc
+++ b/chromium/base/debug/elf_reader.cc
@@ -8,6 +8,12 @@
 #include <elf.h>
 #include <string.h>
 
+#if defined(OS_HAIKU)
+/* Build ID bits as generated by ld --build-id.
+   The descriptor consists of any nonzero number of bytes.  */
+#define NT_GNU_BUILD_ID	3
+#endif
+
 #include "base/bits.h"
 #include "base/containers/span.h"
 #include "base/hash/sha1.h"
diff --git a/chromium/base/debug/stack_trace.cc b/chromium/base/debug/stack_trace.cc
index f5e2dbb..f01db79 100644
--- a/chromium/base/debug/stack_trace.cc
+++ b/chromium/base/debug/stack_trace.cc
@@ -225,7 +225,7 @@ std::string StackTrace::ToString() const {
 }
 std::string StackTrace::ToStringWithPrefix(const char* prefix_string) const {
   std::stringstream stream;
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_HAIKU)
   OutputToStreamWithPrefix(&stream, prefix_string);
 #endif
   return stream.str();
diff --git a/chromium/base/debug/stack_trace_posix.cc b/chromium/base/debug/stack_trace_posix.cc
index 6a1531e..61f1fcf 100644
--- a/chromium/base/debug/stack_trace_posix.cc
+++ b/chromium/base/debug/stack_trace_posix.cc
@@ -27,7 +27,7 @@
 #if !defined(USE_SYMBOLIZE)
 #include <cxxabi.h>
 #endif
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_HAIKU)
 #include <execinfo.h>
 #endif
 
@@ -35,7 +35,7 @@
 #include <AvailabilityMacros.h>
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "base/debug/proc_maps_linux.h"
 #endif
 
@@ -88,7 +88,7 @@ void DemangleSymbols(std::string* text) {
   // Note: code in this function is NOT async-signal safe (std::string uses
   // malloc internally).
 
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_HAIKU)
   std::string::size_type search_from = 0;
   while (search_from < text->size()) {
     // Look for the start of a mangled symbol, from search_from.
@@ -135,7 +135,7 @@ class BacktraceOutputHandler {
   virtual ~BacktraceOutputHandler() = default;
 };
 
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_HAIKU)
 void OutputPointer(void* pointer, BacktraceOutputHandler* handler) {
   // This should be more than enough to store a 64-bit number in hex:
   // 16 hex digits + 1 for null-terminator.
@@ -834,7 +834,7 @@ size_t CollectStackTrace(void** trace, size_t count) {
   // NOTE: This code MUST be async-signal safe (it's used by in-process
   // stack dumping signal handler). NO malloc or stdio is allowed here.
 
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_HAIKU)
   // Though the backtrace API man page does not list any possible negative
   // return values, we take no chance.
   return base::saturated_cast<size_t>(backtrace(trace, count));
@@ -847,13 +847,13 @@ void StackTrace::PrintWithPrefix(const char* prefix_string) const {
 // NOTE: This code MUST be async-signal safe (it's used by in-process
 // stack dumping signal handler). NO malloc or stdio is allowed here.
 
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_HAIKU)
   PrintBacktraceOutputHandler handler;
   ProcessBacktrace(trace_, count_, prefix_string, &handler);
 #endif
 }
 
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_HAIKU)
 void StackTrace::OutputToStreamWithPrefix(std::ostream* os,
                                           const char* prefix_string) const {
   StreamBacktraceOutputHandler handler(os);
diff --git a/chromium/base/files/file.h b/chromium/base/files/file.h
index 2743d1f..871ef43 100644
--- a/chromium/base/files/file.h
+++ b/chromium/base/files/file.h
@@ -25,7 +25,8 @@
 namespace base {
 
 #if defined(OS_BSD) || defined(OS_APPLE) || defined(OS_NACL) || \
-    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21)
+    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21) || \
+    defined(OS_HAIKU)
 typedef struct stat stat_wrapper_t;
 #elif defined(OS_POSIX)
 typedef struct stat64 stat_wrapper_t;
diff --git a/chromium/base/files/file_posix.cc b/chromium/base/files/file_posix.cc
index b69d2e6..a521ef0 100644
--- a/chromium/base/files/file_posix.cc
+++ b/chromium/base/files/file_posix.cc
@@ -584,7 +584,8 @@ File::Error File::GetLastFileError() {
 }
 
 #if defined(OS_BSD) || defined(OS_APPLE) || defined(OS_NACL) || \
-    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21)
+    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21) || \
+    defined(OS_HAIKU)
 int File::Stat(const char* path, stat_wrapper_t* sb) {
   ScopedBlockingCall scoped_blocking_call(FROM_HERE, BlockingType::MAY_BLOCK);
   return stat(path, sb);
diff --git a/chromium/base/files/file_util.h b/chromium/base/files/file_util.h
index df0f0bd..618b712 100644
--- a/chromium/base/files/file_util.h
+++ b/chromium/base/files/file_util.h
@@ -278,14 +278,14 @@ BASE_EXPORT bool SetPosixFilePermissions(const FilePath& path, int mode);
 BASE_EXPORT bool ExecutableExistsInPath(Environment* env,
                                         const FilePath::StringType& executable);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_HAIKU)
 // Determine if files under a given |path| can be mapped and then mprotect'd
 // PROT_EXEC. This depends on the mount options used for |path|, which vary
 // among different Linux distributions and possibly local configuration. It also
 // depends on details of kernel--ChromeOS uses the noexec option for /dev/shm
 // but its kernel allows mprotect with PROT_EXEC anyway.
 BASE_EXPORT bool IsPathExecutable(const FilePath& path);
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_HAIKU)
 
 #endif  // OS_POSIX
 
@@ -592,7 +592,7 @@ BASE_EXPORT bool VerifyPathControlledByAdmin(const base::FilePath& path);
 // the directory |path|, in the number of FilePath::CharType, or -1 on failure.
 BASE_EXPORT int GetMaximumPathComponentLength(const base::FilePath& path);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_HAIKU)
 // Broad categories of file systems as returned by statfs() on Linux.
 enum FileSystemType {
   FILE_SYSTEM_UNKNOWN,  // statfs failed.
diff --git a/chromium/base/files/file_util_posix.cc b/chromium/base/files/file_util_posix.cc
index d74cf2b..1eb07ae 100644
--- a/chromium/base/files/file_util_posix.cc
+++ b/chromium/base/files/file_util_posix.cc
@@ -951,6 +951,10 @@ bool AllocateFileRegion(File* file, int64_t offset, size_t size) {
   if (HANDLE_EINTR(fallocate(file->GetPlatformFile(), 0, offset, size)) != -1)
     return true;
   DPLOG(ERROR) << "fallocate";
+#elif defined(OS_HAIKU)
+  if (HANDLE_EINTR(posix_fallocate(file->GetPlatformFile(), offset, size)) != -1)
+    return true;
+  DPLOG(ERROR) << "posix_fallocate"; 
 #elif defined(OS_APPLE)
   // MacOS doesn't support fallocate even though their new APFS filesystem
   // does support sparse files. It does, however, have the functionality
@@ -1118,7 +1122,7 @@ int GetMaximumPathComponentLength(const FilePath& path) {
 #if !defined(OS_ANDROID)
 // This is implemented in file_util_android.cc for that platform.
 bool GetShmemTempDir(bool executable, FilePath* path) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_HAIKU)
   bool disable_dev_shm = false;
 #if !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
   disable_dev_shm = CommandLine::ForCurrentProcess()->HasSwitch(
@@ -1127,14 +1131,22 @@ bool GetShmemTempDir(bool executable, FilePath* path) {
   bool use_dev_shm = true;
   if (executable) {
     static const bool s_dev_shm_executable =
+#if defined(OS_HAIKU)
+        IsPathExecutable(FilePath("/var/shared_memory"));
+#else
         IsPathExecutable(FilePath("/dev/shm"));
+#endif
     use_dev_shm = s_dev_shm_executable;
   }
   if (use_dev_shm && !disable_dev_shm) {
+#if defined(OS_HAIKU)
+    *path = FilePath("/var/shared_memory");
+#else
     *path = FilePath("/dev/shm");
+#endif
     return true;
   }
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_HAIKU)
   return GetTempDir(path);
 }
 #endif  // !defined(OS_ANDROID)
@@ -1172,7 +1184,7 @@ PrefetchResult PreReadFile(const FilePath& file_path,
   // posix_fadvise() is only available in the Android NDK in API 21+. Older
   // versions may have the required kernel support, but don't have enough usage
   // to justify backporting.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || \
+#if defined(OS_LINUX) || defined(OS_HAIKU) || defined(OS_CHROMEOS) || \
     (defined(OS_ANDROID) && __ANDROID_API__ >= 21)
   File file(file_path, File::FLAG_OPEN | File::FLAG_READ);
   if (!file.IsValid())
@@ -1208,7 +1220,7 @@ PrefetchResult PreReadFile(const FilePath& file_path,
   return internal::PreReadFileSlow(file_path, max_bytes)
              ? PrefetchResult{PrefetchResultCode::kSlowSuccess}
              : PrefetchResult{PrefetchResultCode::kSlowFailed};
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || (defined(OS_ANDROID) &&
+#endif  // defined(OS_LINUX)  || defined(OS_HAIKU) || defined(OS_CHROMEOS) || (defined(OS_ANDROID) &&
         // __ANDROID_API__ >= 21)
 }
 
@@ -1243,7 +1255,7 @@ bool MoveUnsafe(const FilePath& from_path, const FilePath& to_path) {
 
 #endif  // !defined(OS_NACL_NONSFI)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_HAIKU)
 BASE_EXPORT bool IsPathExecutable(const FilePath& path) {
   bool result = false;
   FilePath tmp_file_path;
@@ -1264,6 +1276,6 @@ BASE_EXPORT bool IsPathExecutable(const FilePath& path) {
   }
   return result;
 }
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_HAIKU)
 
 }  // namespace base
diff --git a/chromium/base/files/scoped_file.cc b/chromium/base/files/scoped_file.cc
index a2e1e6b..50226cf 100644
--- a/chromium/base/files/scoped_file.cc
+++ b/chromium/base/files/scoped_file.cc
@@ -29,7 +29,7 @@ void ScopedFDCloseTraits::Free(int fd) {
   // It's especially problematic on Linux with the setuid sandbox, where
   // a single open directory would bypass the entire security model.
   int ret = IGNORE_EINTR(close(fd));
-
+#if !defined(OS_HAIKU)
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_APPLE) || \
     defined(OS_FUCHSIA) || defined(OS_ANDROID)
   // NB: Some file descriptors can return errors from close() e.g. network
@@ -41,6 +41,7 @@ void ScopedFDCloseTraits::Free(int fd) {
 #endif
 
   PCHECK(0 == ret);
+#endif
 }
 
 #endif  // OS_POSIX || OS_FUCHSIA
diff --git a/chromium/base/linux_util.cc b/chromium/base/linux_util.cc
index 8dac7c7..3b429fe 100644
--- a/chromium/base/linux_util.cc
+++ b/chromium/base/linux_util.cc
@@ -25,6 +25,7 @@
 #include "base/strings/string_split.h"
 #include "base/strings/string_tokenizer.h"
 #include "base/strings/string_util.h"
+#include "base/logging.h"
 #include "build/build_config.h"
 
 namespace base {
diff --git a/chromium/base/logging.cc b/chromium/base/logging.cc
index b5cf2c4..4efc27d 100644
--- a/chromium/base/logging.cc
+++ b/chromium/base/logging.cc
@@ -549,7 +549,7 @@ LogMessage::LogMessage(const char* file, int line, const char* condition)
 LogMessage::~LogMessage() {
   size_t stack_start = stream_.tellp();
 #if !defined(OFFICIAL_BUILD) && !defined(OS_NACL) && !defined(__UCLIBC__) && \
-    !defined(OS_AIX)
+    !defined(OS_AIX) && !defined(OS_HAIKU)
   if (severity_ == LOG_FATAL && !base::debug::BeingDebugged()) {
     // Include a stack trace on a fatal, unless a debugger is attached.
     base::debug::StackTrace stack_trace;
diff --git a/chromium/base/memory/discardable_shared_memory.cc b/chromium/base/memory/discardable_shared_memory.cc
index c885b30..4aa6229 100644
--- a/chromium/base/memory/discardable_shared_memory.cc
+++ b/chromium/base/memory/discardable_shared_memory.cc
@@ -407,6 +407,8 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
 // reusable bit, which allows both Activity Monitor and memory-infra to
 // correctly track the pages.
 #define MADV_PURGE_ARGUMENT MADV_FREE_REUSABLE
+#elif defined(OS_HAIKU)
+#define MADV_PURGE_ARGUMENT POSIX_MADV_DONTNEED
 #else
 #define MADV_PURGE_ARGUMENT MADV_FREE
 #endif
diff --git a/chromium/base/memory/madv_free_discardable_memory_posix.cc b/chromium/base/memory/madv_free_discardable_memory_posix.cc
index 3cc1c8c..105ebeb 100644
--- a/chromium/base/memory/madv_free_discardable_memory_posix.cc
+++ b/chromium/base/memory/madv_free_discardable_memory_posix.cc
@@ -302,6 +302,7 @@ bool MadvFreeDiscardableMemoryPosix::IsResident() const {
   std::vector<unsigned char> vec(allocated_pages_);
 #endif
 
+#if !defined(OS_HAIKU)
   int retval =
       mincore(data_, allocated_pages_ * base::GetPageSize(), vec.data());
   DPCHECK(retval == 0 || errno == EAGAIN);
@@ -310,6 +311,7 @@ bool MadvFreeDiscardableMemoryPosix::IsResident() const {
     if (!(vec[i] & 1))
       return false;
   }
+#endif
   return true;
 }
 
diff --git a/chromium/base/memory/platform_shared_memory_region.h b/chromium/base/memory/platform_shared_memory_region.h
index 9b67c0e..6447162 100644
--- a/chromium/base/memory/platform_shared_memory_region.h
+++ b/chromium/base/memory/platform_shared_memory_region.h
@@ -27,7 +27,7 @@
 #include "base/files/scoped_file.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 namespace content {
 class SandboxIPCHandler;
 }
@@ -120,7 +120,7 @@ class BASE_EXPORT PlatformSharedMemoryRegion {
     kMaxValue = GET_SHMEM_TEMP_DIR_FAILURE
   };
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Structure to limit access to executable region creation.
   struct ExecutableRegion {
    private:
@@ -264,7 +264,7 @@ class BASE_EXPORT PlatformSharedMemoryRegion {
                            CheckPlatformHandlePermissionsCorrespondToMode);
   static PlatformSharedMemoryRegion Create(Mode mode,
                                            size_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
                                            ,
                                            bool executable = false
 #endif
diff --git a/chromium/base/memory/platform_shared_memory_region_posix.cc b/chromium/base/memory/platform_shared_memory_region_posix.cc
index f62a7d6..cabf383 100644
--- a/chromium/base/memory/platform_shared_memory_region_posix.cc
+++ b/chromium/base/memory/platform_shared_memory_region_posix.cc
@@ -70,7 +70,7 @@ FDPair ScopedFDPair::get() const {
   return {fd.get(), readonly_fd.get()};
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // static
 ScopedFD PlatformSharedMemoryRegion::ExecutableRegion::CreateFD(size_t size) {
   PlatformSharedMemoryRegion region =
@@ -79,7 +79,7 @@ ScopedFD PlatformSharedMemoryRegion::ExecutableRegion::CreateFD(size_t size) {
     return region.PassPlatformHandle().fd;
   return ScopedFD();
 }
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 // static
 PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Take(
@@ -204,7 +204,7 @@ bool PlatformSharedMemoryRegion::MapAtInternal(off_t offset,
 // static
 PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
                                                               size_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
                                                               ,
                                                               bool executable
 #endif
@@ -233,7 +233,7 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   // flag.
   FilePath directory;
   if (!GetShmemTempDir(
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
           executable,
 #else
           false /* executable */,
@@ -308,7 +308,7 @@ bool PlatformSharedMemoryRegion::CheckPlatformHandlePermissionsCorrespondToMode(
     PlatformHandle handle,
     Mode mode,
     size_t size) {
-#if !defined(OS_NACL)
+#if !defined(OS_NACL) && !defined(OS_HAIKU)
   if (!CheckFDAccessMode(handle.fd,
                          mode == Mode::kReadOnly ? O_RDONLY : O_RDWR)) {
     return false;
diff --git a/chromium/base/message_loop/message_pump_for_ui.h b/chromium/base/message_loop/message_pump_for_ui.h
index 1eb7da0..2843510 100644
--- a/chromium/base/message_loop/message_pump_for_ui.h
+++ b/chromium/base/message_loop/message_pump_for_ui.h
@@ -20,7 +20,7 @@
 // No MessagePumpForUI, see below.
 #elif defined(USE_GLIB)
 #include "base/message_loop/message_pump_glib.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD) || defined(OS_HAIKU)
 #include "base/message_loop/message_pump_libevent.h"
 #elif defined(OS_FUCHSIA)
 #include "base/message_loop/message_pump_fuchsia.h"
@@ -44,7 +44,7 @@ using MessagePumpForUI = MessagePump;
 // TODO(abarth): Figure out if we need this.
 #elif defined(USE_GLIB)
 using MessagePumpForUI = MessagePumpGlib;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD) || defined(OS_HAIKU)
 using MessagePumpForUI = MessagePumpLibevent;
 #elif defined(OS_FUCHSIA)
 using MessagePumpForUI = MessagePumpFuchsia;
diff --git a/chromium/base/path_service.cc b/chromium/base/path_service.cc
index 4750944..3ed2519 100644
--- a/chromium/base/path_service.cc
+++ b/chromium/base/path_service.cc
@@ -31,6 +31,8 @@ bool PathProviderMac(int key, FilePath* result);
 bool PathProviderAndroid(int key, FilePath* result);
 #elif defined(OS_FUCHSIA)
 bool PathProviderFuchsia(int key, FilePath* result);
+#elif defined(OS_HAIKU)
+bool PathProviderHaiku(int key, FilePath* result);
 #elif defined(OS_POSIX)
 // PathProviderPosix is the default path provider on POSIX OSes other than
 // Mac and Android.
@@ -103,8 +105,16 @@ Provider base_provider_fuchsia = {PathProviderFuchsia, &base_provider,
                                   true};
 #endif
 
+#if defined(OS_HAIKU)
+Provider base_provider_haiku = {PathProviderHaiku, &base_provider,
+#ifndef NDEBUG
+                                0, 0,
+#endif
+                                true};
+#endif
+
 #if defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_ANDROID) && \
-    !defined(OS_FUCHSIA)
+    !defined(OS_FUCHSIA) && !defined(OS_HAIKU)
 Provider base_provider_posix = {
   PathProviderPosix,
   &base_provider,
@@ -133,6 +143,8 @@ struct PathData {
     providers = &base_provider_android;
 #elif defined(OS_FUCHSIA)
     providers = &base_provider_fuchsia;
+#elif defined(OS_HAIKU)
+    providers = &base_provider_haiku;
 #elif defined(OS_POSIX)
     providers = &base_provider_posix;
 #endif
diff --git a/chromium/base/posix/can_lower_nice_to.cc b/chromium/base/posix/can_lower_nice_to.cc
index b1686dc..dc9661f 100644
--- a/chromium/base/posix/can_lower_nice_to.cc
+++ b/chromium/base/posix/can_lower_nice_to.cc
@@ -31,6 +31,9 @@ bool CanLowerNiceTo(int nice_value) {
   if (geteuid() == 0)
     return true;
 
+#if defined(OS_HAIKU)
+  return false;
+#else
   // 2. Skip checking the CAP_SYS_NICE permission because it would require
   // libcap.so.
 
@@ -54,6 +57,7 @@ bool CanLowerNiceTo(int nice_value) {
   // And lowering niceness to |nice_value| is allowed if it is greater than or
   // equal to the limit:
   return nice_value >= lowest_nice_allowed;
+#endif
 }
 
 }  // namespace internal
diff --git a/chromium/base/posix/unix_domain_socket.cc b/chromium/base/posix/unix_domain_socket.cc
index e4d052d..25da15c 100644
--- a/chromium/base/posix/unix_domain_socket.cc
+++ b/chromium/base/posix/unix_domain_socket.cc
@@ -57,7 +57,7 @@ bool CreateSocketPair(ScopedFD* one, ScopedFD* two) {
 
 // static
 bool UnixDomainSocket::EnableReceiveProcessId(int fd) {
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_HAIKU)
   const int enable = 1;
   return setsockopt(fd, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable)) == 0;
 #else
@@ -148,11 +148,11 @@ ssize_t UnixDomainSocket::RecvMsgWithFlags(int fd,
 
   const size_t kControlBufferSize =
       CMSG_SPACE(sizeof(int) * kMaxFileDescriptors)
-#if !defined(OS_NACL_NONSFI) && !defined(OS_APPLE)
+#if !defined(OS_NACL_NONSFI) && !defined(OS_APPLE) && !defined(OS_HAIKU)
       // The PNaCl toolchain for Non-SFI binary build and macOS do not support
       // ucred. macOS supports xucred, but this structure is insufficient.
       + CMSG_SPACE(sizeof(struct ucred))
-#endif  // !defined(OS_NACL_NONSFI) && !defined(OS_APPLE)
+#endif  // !defined(OS_NACL_NONSFI) && !defined(OS_APPLE) && !defined(OS_HAIKU)
       ;
   char control_buffer[kControlBufferSize];
   msg.msg_control = control_buffer;
@@ -176,7 +176,7 @@ ssize_t UnixDomainSocket::RecvMsgWithFlags(int fd,
         wire_fds = reinterpret_cast<int*>(CMSG_DATA(cmsg));
         wire_fds_len = payload_len / sizeof(int);
       }
-#if !defined(OS_NACL_NONSFI) && !defined(OS_APPLE)
+#if !defined(OS_NACL_NONSFI) && !defined(OS_APPLE) && !defined(OS_HAIKU)
       // The PNaCl toolchain for Non-SFI binary build and macOS do not support
       // SCM_CREDENTIALS.
       if (cmsg->cmsg_level == SOL_SOCKET &&
@@ -185,7 +185,7 @@ ssize_t UnixDomainSocket::RecvMsgWithFlags(int fd,
         DCHECK_EQ(pid, -1);
         pid = reinterpret_cast<struct ucred*>(CMSG_DATA(cmsg))->pid;
       }
-#endif  // !defined(OS_NACL_NONSFI) && !defined(OS_APPLE)
+#endif  // !defined(OS_NACL_NONSFI) && !defined(OS_APPLE) && !defined(OS_HAIKU)
     }
   }
 
diff --git a/chromium/base/process/kill.h b/chromium/base/process/kill.h
index a7d23bd..f7082d5 100644
--- a/chromium/base/process/kill.h
+++ b/chromium/base/process/kill.h
@@ -113,7 +113,7 @@ BASE_EXPORT TerminationStatus GetTerminationStatus(ProcessHandle handle,
 BASE_EXPORT TerminationStatus GetKnownDeadTerminationStatus(
     ProcessHandle handle, int* exit_code);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // Spawns a thread to wait asynchronously for the child |process| to exit
 // and then reaps it.
 BASE_EXPORT void EnsureProcessGetsReaped(Process process);
diff --git a/chromium/base/process/kill_posix.cc b/chromium/base/process/kill_posix.cc
index 0fa6edb..eadf830 100644
--- a/chromium/base/process/kill_posix.cc
+++ b/chromium/base/process/kill_posix.cc
@@ -160,7 +160,7 @@ void EnsureProcessTerminated(Process process) {
       0, new BackgroundReaper(std::move(process), TimeDelta::FromSeconds(2)));
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 void EnsureProcessGetsReaped(Process process) {
   DCHECK(!process.is_current());
 
diff --git a/chromium/base/process/launch.cc b/chromium/base/process/launch.cc
index a643828..9845344 100644
--- a/chromium/base/process/launch.cc
+++ b/chromium/base/process/launch.cc
@@ -15,7 +15,7 @@ LaunchOptions::~LaunchOptions() = default;
 
 LaunchOptions LaunchOptionsForTest() {
   LaunchOptions options;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // To prevent accidental privilege sharing to an untrusted child, processes
   // are started with PR_SET_NO_NEW_PRIVS. Do not set that here, since this
   // new child will be used for testing only.
diff --git a/chromium/base/process/launch.h b/chromium/base/process/launch.h
index 6cf6eac..486b793 100644
--- a/chromium/base/process/launch.h
+++ b/chromium/base/process/launch.h
@@ -180,7 +180,7 @@ struct BASE_EXPORT LaunchOptions {
   bool clear_environment = false;
 #endif  // OS_WIN || OS_POSIX || OS_FUCHSIA
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // If non-zero, start the process using clone(), using flags as provided.
   // Unlike in clone, clone_flags may not contain a custom termination signal
   // that is sent to the parent when the child dies. The termination signal will
@@ -193,7 +193,7 @@ struct BASE_EXPORT LaunchOptions {
 
   // Sets parent process death signal to SIGKILL.
   bool kill_on_parent_death = false;
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 #if defined(OS_MAC)
   // Mach ports that will be accessible to the child process. These are not
@@ -408,7 +408,7 @@ BASE_EXPORT void RaiseProcessToHighPriority();
 // binary. This should not be called in production/released code.
 BASE_EXPORT LaunchOptions LaunchOptionsForTest();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_NACL_NONSFI)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_NACL_NONSFI) || defined(OS_HAIKU)
 // A wrapper for clone with fork-like behavior, meaning that it returns the
 // child's pid in the parent and 0 in the child. |flags|, |ptid|, and |ctid| are
 // as in the clone system call (the CLONE_VM flag is not supported).
diff --git a/chromium/base/process/launch_posix.cc b/chromium/base/process/launch_posix.cc
index a8b1f0b..bb8718a 100644
--- a/chromium/base/process/launch_posix.cc
+++ b/chromium/base/process/launch_posix.cc
@@ -14,7 +14,9 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <sys/resource.h>
+#if !defined(OS_HAIKU)
 #include <sys/syscall.h>
+#endif
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -221,7 +223,7 @@ static const char kFDDir[] = "/proc/self/fd";
 void CloseSuperfluousFds(const base::InjectiveMultimap& saved_mapping) {
   // DANGER: no calls to malloc or locks are allowed from now on:
   // http://crbug.com/36678
-
+#if !defined(OS_HAIKU)
   // Get the maximum number of FDs possible.
   size_t max_fds = GetMaxFds();
 
@@ -276,6 +278,7 @@ void CloseSuperfluousFds(const base::InjectiveMultimap& saved_mapping) {
     int ret = IGNORE_EINTR(close(fd));
     DPCHECK(ret == 0);
   }
+  #endif
 }
 
 Process LaunchProcess(const CommandLine& cmdline,
diff --git a/chromium/base/process/memory.cc b/chromium/base/process/memory.cc
index 4454e32..83a0723 100644
--- a/chromium/base/process/memory.cc
+++ b/chromium/base/process/memory.cc
@@ -55,7 +55,7 @@ NOINLINE void OnNoMemoryInternal(size_t size) {
 }  // namespace internal
 
 // Defined in memory_win.cc for Windows.
-#if !defined(OS_WIN)
+#if !defined(OS_WIN) && !defined(OS_HAIKU)
 
 namespace {
 
@@ -74,7 +74,7 @@ void TerminateBecauseOutOfMemory(size_t size) {
 #endif  // !defined(OS_WIN)
 
 // Defined in memory_mac.mm for Mac.
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_HAIKU)
 
 bool UncheckedCalloc(size_t num_items, size_t size, void** result) {
   const size_t alloc_size = num_items * size;
diff --git a/chromium/base/process/memory.h b/chromium/base/process/memory.h
index 2d313ed..eb7b17a 100644
--- a/chromium/base/process/memory.h
+++ b/chromium/base/process/memory.h
@@ -25,7 +25,7 @@ BASE_EXPORT void EnableTerminationOnOutOfMemory();
 BASE_EXPORT void TerminateBecauseOutOfMemory(size_t size);
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
 BASE_EXPORT extern size_t g_oom_size;
 
 // The maximum allowed value for the OOM score.
diff --git a/chromium/base/process/process_handle.h b/chromium/base/process/process_handle.h
index 3640351..d7e185a 100644
--- a/chromium/base/process/process_handle.h
+++ b/chromium/base/process/process_handle.h
@@ -103,7 +103,7 @@ BASE_EXPORT ProcessId GetCurrentProcId();
 // processes may be reused.
 BASE_EXPORT UniqueProcId GetUniqueIdForProcess();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // When a process is started in a different PID namespace from the browser
 // process, this function must be called with the process's PID in the browser's
 // PID namespace in order to initialize its unique ID. Not thread safe.
diff --git a/chromium/base/process/process_handle_haiku.cc b/chromium/base/process/process_handle_haiku.cc
new file mode 100644
index 0000000..bc17cab
--- /dev/null
+++ b/chromium/base/process/process_handle_haiku.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/logging.h"
+#include "base/process/process_handle.h"
+
+#include "base/files/file_util.h"
+
+#define PARENT_ID 3
+extern "C" pid_t _kern_process_info(pid_t, int);
+
+namespace base {
+
+ProcessId GetParentProcessId(ProcessHandle process) {
+  return _kern_process_info(process, PARENT_ID);
+}
+
+FilePath GetProcessExecutablePath(ProcessHandle process) {
+  NOTIMPLEMENTED();
+  return FilePath();
+}
+
+}  // namespace base
diff --git a/chromium/base/process/process_iterator_haiku.cc b/chromium/base/process/process_iterator_haiku.cc
new file mode 100644
index 0000000..6d411ba
--- /dev/null
+++ b/chromium/base/process/process_iterator_haiku.cc
@@ -0,0 +1,26 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/process/process_iterator.h"
+
+namespace base {
+
+ProcessIterator::ProcessIterator(const ProcessFilter* filter) {
+  // TODO(fuchsia): There's no Fuchsia API to iterate processes currently.
+  NOTREACHED();
+}
+
+ProcessIterator::~ProcessIterator() {}
+
+bool ProcessIterator::CheckForNextProcess() {
+  // TODO(fuchsia): There's no Fuchsia API to iterate processes currently.
+  return false;
+}
+
+bool NamedProcessIterator::IncludeEntry() {
+  // TODO(fuchsia): There's no Fuchsia API to iterate processes currently.
+  return false;
+}
+
+}  // namespace base
diff --git a/chromium/base/process/process_metrics.h b/chromium/base/process/process_metrics.h
index bbf88c5..def2511 100644
--- a/chromium/base/process/process_metrics.h
+++ b/chromium/base/process/process_metrics.h
@@ -47,7 +47,7 @@ namespace base {
 // Full declaration is in process_metrics_iocounters.h.
 struct IoCounters;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 // Minor and major page fault counts since the process creation.
 // Both counts are process-wide, and exclude child processes.
 //
@@ -57,7 +57,7 @@ struct PageFaultCounts {
   int64_t minor;
   int64_t major;
 };
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 
 // Convert a POSIX timeval to microseconds.
 BASE_EXPORT int64_t TimeValToMicroseconds(const struct timeval& tv);
@@ -98,7 +98,7 @@ class BASE_EXPORT ProcessMetrics {
   // convenience wrapper for CreateProcessMetrics().
   static std::unique_ptr<ProcessMetrics> CreateCurrentProcessMetrics();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
   // Resident Set Size is a Linux/Android specific memory concept. Do not
   // attempt to extend this to other platforms.
   BASE_EXPORT size_t GetResidentSetSize() const;
@@ -125,7 +125,7 @@ class BASE_EXPORT ProcessMetrics {
   TimeDelta GetCumulativeCPUUsage();
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
   // Emits the cumulative CPU usage for all currently active threads since they
   // were started into the output parameter (replacing its current contents).
   // Threads that have already terminated will not be reported. Thus, the sum of
@@ -160,7 +160,7 @@ class BASE_EXPORT ProcessMetrics {
                             PlatformThreadId tid,
                             TimeInStatePerThread& time_in_state_per_thread);
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) ||
-        // defined(OS_AIX)
+        // defined(OS_AIX) || defined(OS_HAIKU)
 
   // Returns the number of average idle cpu wakeups per second since the last
   // call.
@@ -216,14 +216,14 @@ class BASE_EXPORT ProcessMetrics {
   int GetOpenFdSoftLimit() const;
 #endif  // defined(OS_POSIX)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
   // Bytes of swap as reported by /proc/[pid]/status.
   uint64_t GetVmSwapBytes() const;
 
   // Minor and major page fault count as reported by /proc/[pid]/stat.
   // Returns true for success.
   bool GetPageFaultCounts(PageFaultCounts* counts) const;
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 
   // Returns total memory usage of malloc.
   size_t GetMallocUsage();
@@ -236,7 +236,7 @@ class BASE_EXPORT ProcessMetrics {
 #endif  // !defined(OS_MAC)
 
 #if defined(OS_APPLE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
   int CalculateIdleWakeupsPerSecond(uint64_t absolute_idle_wakeups);
 #endif
 #if defined(OS_APPLE)
@@ -247,10 +247,10 @@ class BASE_EXPORT ProcessMetrics {
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
   CPU::CoreType GetCoreType(int core_index);
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) ||
-        // defined(OS_AIX)
+        // defined(OS_AIX) || defined(OS_HAIKU)
 
 #if defined(OS_WIN)
   win::ScopedHandle process_;
@@ -272,7 +272,7 @@ class BASE_EXPORT ProcessMetrics {
   uint64_t last_cumulative_disk_usage_ = 0;
 
 #if defined(OS_APPLE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
   // Same thing for idle wakeups.
   TimeTicks last_idle_wakeups_time_;
   uint64_t last_absolute_idle_wakeups_;
@@ -325,7 +325,7 @@ BASE_EXPORT void IncreaseFdLimitTo(unsigned int max_descriptors);
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) ||      \
     defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_AIX) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
 // Data about system-wide memory consumption. Values are in KB. Available on
 // Windows, Mac, Linux, Android and Chrome OS.
 //
@@ -359,7 +359,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
   // This provides an estimate of available memory as described here:
   // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773
   // NOTE: this is ONLY valid in kernels 3.14 and up.  Its value will always
@@ -374,7 +374,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
 #endif
 
 #if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_AIX) || defined(OS_FUCHSIA)
+    defined(OS_AIX) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
   int buffers = 0;
   int cached = 0;
   int active_anon = 0;
@@ -384,7 +384,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
   int dirty = 0;
   int reclaimable = 0;
 #endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) ||
-        // defined(OS_AIX) defined(OS_FUCHSIA)
+        // defined(OS_AIX) defined(OS_FUCHSIA) || defined(OS_HAIKU)
 
 #if defined(OS_CHROMEOS) || BUILDFLAG(IS_LACROS)
   int shmem = 0;
@@ -408,10 +408,10 @@ BASE_EXPORT bool GetSystemMemoryInfo(SystemMemoryInfoKB* meminfo);
 
 #endif  // defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) ||
         // defined(OS_CHROMEOS) defined(OS_ANDROID) || defined(OS_AIX) ||
-        // defined(OS_FUCHSIA)
+        // defined(OS_FUCHSIA) || defined(OS_HAIKU)
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
 // Parse the data found in /proc/<pid>/stat and return the sum of the
 // CPU-related ticks.  Returns -1 on parse error.
 // Exposed for testing.
@@ -486,7 +486,7 @@ BASE_EXPORT bool GetSystemDiskInfo(SystemDiskInfo* diskinfo);
 BASE_EXPORT TimeDelta GetUserCpuTimeSinceBoot();
 
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) ||
-        // defined(OS_AIX)
+        // defined(OS_AIX) || defined(OS_HAIKU)
 
 #if defined(OS_CHROMEOS) || BUILDFLAG(IS_LACROS)
 // Data from files in directory /sys/block/zram0 about ZRAM usage.
@@ -597,7 +597,7 @@ class BASE_EXPORT SystemMetrics {
   FRIEND_TEST_ALL_PREFIXES(SystemMetricsTest, SystemMetrics);
 
   size_t committed_memory_;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
   SystemMemoryInfoKB memory_info_;
   VmStatInfo vmstat_info_;
   SystemDiskInfo disk_info_;
diff --git a/chromium/base/process/process_metrics_haiku.cc b/chromium/base/process/process_metrics_haiku.cc
new file mode 100644
index 0000000..2a73cc1
--- /dev/null
+++ b/chromium/base/process/process_metrics_haiku.cc
@@ -0,0 +1,43 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/process/process_metrics.h"
+
+namespace base {
+
+size_t GetSystemCommitCharge() {
+  // Not available, doesn't seem likely that it will be (for the whole system).
+  NOTIMPLEMENTED();
+  return 0;
+}
+
+// static
+std::unique_ptr<ProcessMetrics> ProcessMetrics::CreateProcessMetrics(
+    ProcessHandle process) {
+  NOTIMPLEMENTED();  // TODO(fuchsia): https://crbug.com/706592.
+  return nullptr;
+}
+
+size_t ProcessMetrics::GetResidentSetSize() const {
+  NOTIMPLEMENTED();  // TODO(fuchsia): https://crbug.com/706592.
+  return 0;
+}
+
+TimeDelta ProcessMetrics::GetCumulativeCPUUsage() {
+  NOTIMPLEMENTED();  // TODO(fuchsia): https://crbug.com/706592.
+  return TimeDelta();
+}
+
+bool GetSystemMemoryInfo(SystemMemoryInfoKB* meminfo) {
+  NOTIMPLEMENTED();  // TODO(fuchsia): https://crbug.com/706592.
+  return false;
+}
+
+uint64_t ProcessMetrics::GetVmSwapBytes() const {
+  NOTIMPLEMENTED();  // TODO(fuchsia): https://crbug.com/706592.
+  return 0;
+}
+
+
+}  // namespace base
diff --git a/chromium/base/process/process_metrics_posix.cc b/chromium/base/process/process_metrics_posix.cc
index 9d12c42..d29e675 100644
--- a/chromium/base/process/process_metrics_posix.cc
+++ b/chromium/base/process/process_metrics_posix.cc
@@ -53,6 +53,8 @@ static const rlim_t kSystemDefaultMaxFds = 256;
 static const rlim_t kSystemDefaultMaxFds = 1024;
 #elif defined(OS_AIX)
 static const rlim_t kSystemDefaultMaxFds = 8192;
+#elif defined(OS_HAIKU)
+static const rlim_t kSystemDefaultMaxFds = 4096;
 #endif
 
 size_t GetMaxFds() {
@@ -126,7 +128,7 @@ size_t ProcessMetrics::GetMallocUsage() {
 #else
   return minfo.hblkhd + minfo.arena;
 #endif
-#elif defined(OS_FUCHSIA)
+#elif defined(OS_FUCHSIA) || defined(OS_HAIKU)
   // TODO(fuchsia): Not currently exposed. https://crbug.com/735087.
   return 0;
 #endif
diff --git a/chromium/base/process/process_posix.cc b/chromium/base/process/process_posix.cc
index fc771b3..4c34d41 100644
--- a/chromium/base/process/process_posix.cc
+++ b/chromium/base/process/process_posix.cc
@@ -268,13 +268,13 @@ Process Process::DeprecatedGetProcessFromHandle(ProcessHandle handle) {
 }
 
 #if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_MAC) && \
-    !defined(OS_AIX)
+    !defined(OS_AIX) && !defined(OS_HAIKU)
 // static
 bool Process::CanBackgroundProcesses() {
   return false;
 }
 #endif  // !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_MAC) &&
-        // !defined(OS_AIX)
+        // !defined(OS_AIX) && !defined(OS_HAIKU)
 
 // static
 void Process::TerminateCurrentProcessImmediately(int exit_code) {
@@ -365,7 +365,7 @@ bool Process::WaitForExitWithTimeout(TimeDelta timeout, int* exit_code) const {
 void Process::Exited(int exit_code) const {}
 
 #if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_MAC) && \
-    !defined(OS_AIX)
+    !defined(OS_AIX) && !defined(OS_HAIKU)
 bool Process::IsProcessBackgrounded() const {
   // See SetProcessBackgrounded().
   DCHECK(IsValid());
@@ -380,7 +380,7 @@ bool Process::SetProcessBackgrounded(bool value) {
   return false;
 }
 #endif  // !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_MAC) &&
-        // !defined(OS_AIX)
+        // !defined(OS_AIX) && !defined(OS_HAIKU)
 
 int Process::GetPriority() const {
   DCHECK(IsValid());
diff --git a/chromium/base/profiler/module_cache_posix.cc b/chromium/base/profiler/module_cache_posix.cc
index 310ab39..6e0f72c 100644
--- a/chromium/base/profiler/module_cache_posix.cc
+++ b/chromium/base/profiler/module_cache_posix.cc
@@ -6,6 +6,11 @@
 
 #include <dlfcn.h>
 #include <elf.h>
+#ifdef __HAIKU__
+#define PF_X		0x1
+#define PF_W		0x2
+#define PF_R		0x4
+#endif
 
 #include "base/debug/elf_reader.h"
 #include "build/build_config.h"
diff --git a/chromium/base/system/sys_info.h b/chromium/base/system/sys_info.h
index eee730e..3f36569 100644
--- a/chromium/base/system/sys_info.h
+++ b/chromium/base/system/sys_info.h
@@ -212,7 +212,7 @@ class BASE_EXPORT SysInfo {
   static HardwareInfo GetHardwareInfoSync();
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_HAIKU)
   static int64_t AmountOfAvailablePhysicalMemory(
       const SystemMemoryInfoKB& meminfo);
 #endif
diff --git a/chromium/base/system/sys_info_haiku.cc b/chromium/base/system/sys_info_haiku.cc
new file mode 100644
index 0000000..e4cf2f0
--- /dev/null
+++ b/chromium/base/system/sys_info_haiku.cc
@@ -0,0 +1,35 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/system/sys_info.h"
+
+#include "base/notreached.h"
+
+#include <kernel/OS.h>
+
+namespace base {
+
+// static
+int64_t SysInfo::AmountOfPhysicalMemoryImpl() {
+    system_info systemInfo;
+    get_system_info(&systemInfo);
+    return static_cast<int64_t>(systemInfo.max_pages * B_PAGE_SIZE + 0.5f);
+}
+
+// static
+int64_t SysInfo::AmountOfAvailablePhysicalMemoryImpl() {
+    system_info systemInfo;
+    get_system_info(&systemInfo);
+    return static_cast<int64_t>((systemInfo.max_pages - systemInfo.used_pages)
+        * B_PAGE_SIZE + 0.5f);
+}
+
+// static
+std::string SysInfo::CPUModelName() {
+    system_info systemInfo;
+  NOTIMPLEMENTED();
+  return std::string();
+}
+
+}  // namespace base
diff --git a/chromium/base/third_party/libevent/BUILD.gn b/chromium/base/third_party/libevent/BUILD.gn
index 3628030..2e1bd65 100644
--- a/chromium/base/third_party/libevent/BUILD.gn
+++ b/chromium/base/third_party/libevent/BUILD.gn
@@ -48,7 +48,7 @@ static_library("bundled_libevent") {
       "mac/event-config.h",
     ]
     include_dirs = [ "mac" ]
-  } else if (is_linux || is_chromeos) {
+  } else if ((is_linux && !is_haiku) || is_chromeos) {
     sources += [
       "epoll.c",
       "linux/config.h",
@@ -78,6 +78,13 @@ static_library("bundled_libevent") {
       "nacl_nonsfi/signal_stub.c",
     ]
     include_dirs = [ "nacl_nonsfi" ]
+  } else if (is_haiku) {
+    sources += [
+      "haiku/config.h",
+      "haiku/event-config.h",
+    ]
+    include_dirs = [ "haiku", "compat" ]
+    libs = [ "network" ]
   }
 
   configs -= [ "//build/config/compiler:chromium_code" ]
diff --git a/chromium/base/third_party/libevent/event-config.h b/chromium/base/third_party/libevent/event-config.h
index bbd23f1..f01bea2 100644
--- a/chromium/base/third_party/libevent/event-config.h
+++ b/chromium/base/third_party/libevent/event-config.h
@@ -19,6 +19,8 @@
 #include "base/third_party/libevent/solaris/event-config.h"
 #elif defined(_AIX)
 #include "base/third_party/libevent/aix/event-config.h"
+#elif defined(__HAIKU__)
+#include "base/third_party/libevent/haiku/event-config.h"
 #else
 #error generate event-config.h for your platform
 #endif
diff --git a/chromium/base/third_party/libevent/haiku/config.h b/chromium/base/third_party/libevent/haiku/config.h
new file mode 100644
index 0000000..5990ae7
--- /dev/null
+++ b/chromium/base/third_party/libevent/haiku/config.h
@@ -0,0 +1,272 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if clock_gettime is available in libc */
+#define DNS_USE_CPU_CLOCK_FOR_ID 1
+
+/* Define is no secure id variant is available */
+/* #undef DNS_USE_GETTIMEOFDAY_FOR_ID */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define HAVE_CLOCK_GETTIME 1
+
+/* Define if /dev/poll is available */
+/* #undef HAVE_DEVPOLL */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if your system supports the epoll system calls */
+/* #undef HAVE_EPOLL */
+
+/* Define to 1 if you have the `epoll_ctl' function. */
+/* #undef HAVE_EPOLL_CTL */
+
+/* Define if your system supports event ports */
+/* #undef HAVE_EVENT_PORTS */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if the system has the type `fd_mask'. */
+/* #undef HAVE_FD_MASK */
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getegid' function. */
+#define HAVE_GETEGID 1
+
+/* Define to 1 if you have the `geteuid' function. */
+#define HAVE_GETEUID 1
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `issetugid' function. */
+/* #undef HAVE_ISSETUGID */
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef HAVE_KQUEUE */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef HAVE_LIBNSL */
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+/* #undef HAVE_LIBRESOLV */
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+/* #undef HAVE_LIBRT */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in6.h> header file. */
+/* #undef HAVE_NETINET_IN6_H */
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the `port_create' function. */
+/* #undef HAVE_PORT_CREATE */
+
+/* Define to 1 if you have the <port.h> header file. */
+/* #undef HAVE_PORT_H */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define if F_SETFD is defined in <fcntl.h> */
+#define HAVE_SETFD 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `signal' function. */
+#define HAVE_SIGNAL 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+#define HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define HAVE_STRSEP 1
+
+/* Define to 1 if you have the `strtok_r' function. */
+#define HAVE_STRTOK_R 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define HAVE_STRTOLL 1
+
+/* Define to 1 if the system has the type `struct in6_addr'. */
+#define HAVE_STRUCT_IN6_ADDR 1
+
+/* Define to 1 if you have the <sys/devpoll.h> header file. */
+/* #undef HAVE_SYS_DEVPOLL_H */
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+/* #undef HAVE_SYS_EPOLL_H */
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+/* #undef HAVE_SYS_EVENT_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/queue.h> header file. */
+#define HAVE_SYS_QUEUE_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define if TAILQ_FOREACH is defined in <sys/queue.h> */
+/* #undef HAVE_TAILQFOREACH */
+
+/* Define if timeradd is defined in <sys/time.h> */
+#define HAVE_TIMERADD 1
+
+/* Define if timerclear is defined in <sys/time.h> */
+#define HAVE_TIMERCLEAR 1
+
+/* Define if timercmp is defined in <sys/time.h> */
+#define HAVE_TIMERCMP 1
+
+/* Define if timerisset is defined in <sys/time.h> */
+#define HAVE_TIMERISSET 1
+
+/* Define to 1 if the system has the type `uint16_t'. */
+#define HAVE_UINT16_T 1
+
+/* Define to 1 if the system has the type `uint32_t'. */
+#define HAVE_UINT32_T 1
+
+/* Define to 1 if the system has the type `uint64_t'. */
+#define HAVE_UINT64_T 1
+
+/* Define to 1 if the system has the type `uint8_t'. */
+#define HAVE_UINT8_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define if kqueue works correctly with pipes */
+/* #undef HAVE_WORKING_KQUEUE */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Numeric representation of the version */
+#define NUMERIC_VERSION 0x01040e00
+
+/* Name of package */
+#define PACKAGE "libevent"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 8
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The size of `short', as computed by sizeof. */
+#define SIZEOF_SHORT 2
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define VERSION "1.4.14b-stable"
+
+/* Define to appropriate substitue if compiler doesnt have __func__ */
+/* #undef __func__ */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to unsigned int if you dont have it */
+/* #undef socklen_t */
diff --git a/chromium/base/third_party/libevent/haiku/event-config.h b/chromium/base/third_party/libevent/haiku/event-config.h
new file mode 100644
index 0000000..0a77f14
--- /dev/null
+++ b/chromium/base/third_party/libevent/haiku/event-config.h
@@ -0,0 +1,280 @@
+/* event-config.h
+ * Generated by autoconf; post-processed by libevent.
+ * Do not edit this file.
+ * Do not rely on macros in this file existing in later versions.
+ */
+#ifndef _EVENT_CONFIG_H_
+#define _EVENT_CONFIG_H_
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if clock_gettime is available in libc */
+#define _EVENT_DNS_USE_CPU_CLOCK_FOR_ID 1
+
+/* Define is no secure id variant is available */
+/* #undef _EVENT_DNS_USE_GETTIMEOFDAY_FOR_ID */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define _EVENT_HAVE_CLOCK_GETTIME 1
+
+/* Define if /dev/poll is available */
+/* #undef _EVENT_HAVE_DEVPOLL */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define _EVENT_HAVE_DLFCN_H 1
+
+/* Define if your system supports the epoll system calls */
+/* #undef _EVENT_HAVE_EPOLL */
+
+/* Define to 1 if you have the `epoll_ctl' function. */
+/* #undef _EVENT_HAVE_EPOLL_CTL */
+
+/* Define if your system supports event ports */
+/* #undef _EVENT_HAVE_EVENT_PORTS */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define _EVENT_HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define _EVENT_HAVE_FCNTL_H 1
+
+/* Define to 1 if the system has the type `fd_mask'. */
+#define _EVENT_HAVE_FD_MASK
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define _EVENT_HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getegid' function. */
+#define _EVENT_HAVE_GETEGID 1
+
+/* Define to 1 if you have the `geteuid' function. */
+#define _EVENT_HAVE_GETEUID 1
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define _EVENT_HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define _EVENT_HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define _EVENT_HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define _EVENT_HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `issetugid' function. */
+/* #undef _EVENT_HAVE_ISSETUGID */
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef _EVENT_HAVE_KQUEUE */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef _EVENT_HAVE_LIBNSL */
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+/* #undef _EVENT_HAVE_LIBRESOLV */
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+/* #undef _EVENT_HAVE_LIBRT */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define _EVENT_HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in6.h> header file. */
+/* #undef _EVENT_HAVE_NETINET_IN6_H */
+
+/* Define to 1 if you have the `poll' function. */
+#define _EVENT_HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define _EVENT_HAVE_POLL_H 1
+
+/* Define to 1 if you have the `port_create' function. */
+/* #undef _EVENT_HAVE_PORT_CREATE */
+
+/* Define to 1 if you have the <port.h> header file. */
+/* #undef _EVENT_HAVE_PORT_H */
+
+/* Define to 1 if you have the `select' function. */
+#define _EVENT_HAVE_SELECT 1
+
+/* Define if F_SETFD is defined in <fcntl.h> */
+#define _EVENT_HAVE_SETFD 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define _EVENT_HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `signal' function. */
+#define _EVENT_HAVE_SIGNAL 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define _EVENT_HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define _EVENT_HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define _EVENT_HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define _EVENT_HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define _EVENT_HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define _EVENT_HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+#define _EVENT_HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strsep' function. */
+/* #undef _EVENT_HAVE_STRSEP */
+
+/* Define to 1 if you have the `strtok_r' function. */
+#define _EVENT_HAVE_STRTOK_R 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define _EVENT_HAVE_STRTOLL 1
+
+/* Define to 1 if the system has the type `struct in6_addr'. */
+#define _EVENT_HAVE_STRUCT_IN6_ADDR 1
+
+/* Define to 1 if you have the <sys/devpoll.h> header file. */
+/* #undef _EVENT_HAVE_SYS_DEVPOLL_H */
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+/* #undef _EVENT_HAVE_SYS_EPOLL_H */
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+/* #undef _EVENT_HAVE_SYS_EVENT_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define _EVENT_HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define _EVENT_HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/queue.h> header file. */
+#define _EVENT_HAVE_SYS_QUEUE_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define _EVENT_HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define _EVENT_HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define _EVENT_HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define _EVENT_HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define _EVENT_HAVE_SYS_TYPES_H 1
+
+/* Define if TAILQ_FOREACH is defined in <sys/queue.h> */
+/* #undef _EVENT_HAVE_TAILQFOREACH */
+
+/* Define if timeradd is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERADD 1
+
+/* Define if timerclear is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERCLEAR 1
+
+/* Define if timercmp is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERCMP 1
+
+/* Define if timerisset is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERISSET 1
+
+/* Define to 1 if the system has the type `uint16_t'. */
+#define _EVENT_HAVE_UINT16_T 1
+
+/* Define to 1 if the system has the type `uint32_t'. */
+#define _EVENT_HAVE_UINT32_T 1
+
+/* Define to 1 if the system has the type `uint64_t'. */
+#define _EVENT_HAVE_UINT64_T 1
+
+/* Define to 1 if the system has the type `uint8_t'. */
+#define _EVENT_HAVE_UINT8_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define _EVENT_HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define _EVENT_HAVE_VASPRINTF 1
+
+/* Define if kqueue works correctly with pipes */
+/* #undef _EVENT_HAVE_WORKING_KQUEUE */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define _EVENT_LT_OBJDIR ".libs/"
+
+/* Numeric representation of the version */
+#define _EVENT_NUMERIC_VERSION 0x01040e00
+
+/* Name of package */
+#define _EVENT_PACKAGE "libevent"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define _EVENT_PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define _EVENT_PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define _EVENT_PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define _EVENT_PACKAGE_TARNAME ""
+
+/* Define to the home page for this package. */
+#define _EVENT_PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define _EVENT_PACKAGE_VERSION ""
+
+/* The size of `int', as computed by sizeof. */
+#define _EVENT_SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define _EVENT_SIZEOF_LONG 8
+
+/* The size of `long long', as computed by sizeof. */
+#define _EVENT_SIZEOF_LONG_LONG 8
+
+/* The size of `short', as computed by sizeof. */
+#define _EVENT_SIZEOF_SHORT 2
+
+/* Define to 1 if you have the ANSI C header files. */
+#define _EVENT_STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define _EVENT_TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define _EVENT_VERSION "1.4.14b-stable"
+
+/* Define to appropriate substitue if compiler doesnt have __func__ */
+/* #undef _EVENT___func__ */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef _EVENT_const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef _EVENT___cplusplus
+/* #undef _EVENT_inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef _EVENT_pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef _EVENT_size_t */
+
+/* Define to unsigned int if you dont have it */
+/* #undef _EVENT_socklen_t */
+#endif
diff --git a/chromium/base/threading/platform_thread.h b/chromium/base/threading/platform_thread.h
index 76e53d3..465542c 100644
--- a/chromium/base/threading/platform_thread.h
+++ b/chromium/base/threading/platform_thread.h
@@ -230,7 +230,7 @@ class BASE_EXPORT PlatformThread {
   // Returns a realtime period provided by |delegate|.
   static TimeDelta GetRealtimePeriod(Delegate* delegate);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Toggles a specific thread's priority at runtime. This can be used to
   // change the priority of a thread in a different process and will fail
   // if the calling process does not have proper permissions. The
diff --git a/chromium/base/threading/platform_thread_haiku.cc b/chromium/base/threading/platform_thread_haiku.cc
new file mode 100644
index 0000000..6bfe285
--- /dev/null
+++ b/chromium/base/threading/platform_thread_haiku.cc
@@ -0,0 +1,79 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/threading/platform_thread.h"
+
+#include <pthread.h>
+#include <sched.h>
+
+#include "base/threading/platform_thread_internal_posix.h"
+#include "base/threading/thread_id_name_manager.h"
+
+namespace base {
+
+namespace internal {
+
+const ThreadPriorityToNiceValuePair kThreadPriorityToNiceValueMap[4] = {
+    {ThreadPriority::BACKGROUND, 10},
+    {ThreadPriority::NORMAL, 0},
+    {ThreadPriority::DISPLAY, -8},
+    {ThreadPriority::REALTIME_AUDIO, -10},
+};
+
+Optional<bool> CanIncreaseCurrentThreadPriorityForPlatform(
+    ThreadPriority priority) {
+  return base::nullopt;
+}
+
+bool SetCurrentThreadPriorityForPlatform(ThreadPriority priority) {
+  sched_param prio = {0};
+  prio.sched_priority = ThreadPriorityToNiceValue(priority);
+  return pthread_setschedparam(pthread_self(), SCHED_OTHER, &prio) == 0;
+}
+
+Optional<ThreadPriority> GetCurrentThreadPriorityForPlatform() {
+  int maybe_sched_rr = 0;
+  struct sched_param maybe_realtime_prio = {0};
+  if (pthread_getschedparam(pthread_self(), &maybe_sched_rr,
+                            &maybe_realtime_prio) == 0 &&
+      maybe_sched_rr == SCHED_RR &&
+      maybe_realtime_prio.sched_priority >= 100) {
+    return base::make_optional(ThreadPriority::REALTIME_AUDIO);
+  }
+  return base::nullopt;
+}
+
+}  // namespace internal
+
+
+// static
+void PlatformThread::SetThreadPriority(PlatformThreadId process_id,
+                                       PlatformThreadId thread_id,
+                                       ThreadPriority priority) {
+  // Changing current main threads' priority is not permitted in favor of
+  // security, this interface is restricted to change only non-main thread
+  // priority.
+  CHECK_NE(thread_id, process_id);
+
+  const int nice_setting = internal::ThreadPriorityToNiceValue(priority);
+  if (setpriority(PRIO_PROCESS, thread_id, nice_setting)) {
+    DVPLOG(1) << "Failed to set nice value of thread (" << thread_id << ") to "
+              << nice_setting;
+  }
+}
+
+void InitThreading() {}
+
+void TerminateOnThread() {}
+
+size_t GetDefaultThreadStackSize(const pthread_attr_t& attributes) {
+  return 0;
+}
+
+// static
+void PlatformThread::SetName(const std::string& name) {
+  
+}
+
+}  // namespace base
diff --git a/chromium/base/threading/platform_thread_linux.cc b/chromium/base/threading/platform_thread_linux.cc
index c1a705e..146a7d9 100644
--- a/chromium/base/threading/platform_thread_linux.cc
+++ b/chromium/base/threading/platform_thread_linux.cc
@@ -24,7 +24,9 @@
 
 #if !defined(OS_NACL) && !defined(OS_AIX)
 #include <pthread.h>
+#if !defined(OS_HAIKU)
 #include <sys/prctl.h>
+#endif
 #include <sys/resource.h>
 #include <sys/time.h>
 #include <sys/types.h>
@@ -264,7 +266,7 @@ const ThreadPriorityToNiceValuePair kThreadPriorityToNiceValueMap[4] = {
 
 Optional<bool> CanIncreaseCurrentThreadPriorityForPlatform(
     ThreadPriority priority) {
-#if !defined(OS_NACL)
+#if !defined(OS_NACL) && !defined(OS_HAIKU)
   // A non-zero soft-limit on RLIMIT_RTPRIO is required to be allowed to invoke
   // pthread_setschedparam in SetCurrentThreadPriorityForPlatform().
   struct rlimit rlim;
@@ -314,7 +316,7 @@ Optional<ThreadPriority> GetCurrentThreadPriorityForPlatform() {
 void PlatformThread::SetName(const std::string& name) {
   ThreadIdNameManager::GetInstance()->SetName(name);
 
-#if !defined(OS_NACL) && !defined(OS_AIX)
+#if !defined(OS_NACL) && !defined(OS_AIX) && !defined(OS_HAIKU)
   // On linux we can get the thread names to show up in the debugger by setting
   // the process name for the LWP.  We don't want to do this for the main
   // thread because that would rename the process, causing tools like killall
diff --git a/chromium/base/threading/platform_thread_posix.cc b/chromium/base/threading/platform_thread_posix.cc
index 550454c..9d57348 100644
--- a/chromium/base/threading/platform_thread_posix.cc
+++ b/chromium/base/threading/platform_thread_posix.cc
@@ -66,7 +66,7 @@ void* ThreadFunc(void* params) {
     if (!thread_params->joinable)
       base::ThreadRestrictions::SetSingletonAllowed(false);
 
-#if !defined(OS_NACL)
+#if !defined(OS_NACL) && !defined(OS_HAIKU)
 
 #if defined(OS_APPLE)
     PlatformThread::SetCurrentThreadRealtimePeriodValue(
@@ -309,7 +309,7 @@ bool PlatformThread::CanIncreaseThreadPriority(ThreadPriority priority) {
 
 // static
 void PlatformThread::SetCurrentThreadPriorityImpl(ThreadPriority priority) {
-#if defined(OS_NACL)
+#if defined(OS_NACL) || defined(OS_HAIKU)
   NOTIMPLEMENTED();
 #else
   if (internal::SetCurrentThreadPriorityForPlatform(priority))
@@ -331,7 +331,7 @@ void PlatformThread::SetCurrentThreadPriorityImpl(ThreadPriority priority) {
 
 // static
 ThreadPriority PlatformThread::GetCurrentThreadPriority() {
-#if defined(OS_NACL)
+#if defined(OS_NACL) || defined(OS_HAIKU)
   NOTIMPLEMENTED();
   return ThreadPriority::NORMAL;
 #else
diff --git a/chromium/base/trace_event/malloc_dump_provider.cc b/chromium/base/trace_event/malloc_dump_provider.cc
index c327f48..1b90c08 100644
--- a/chromium/base/trace_event/malloc_dump_provider.cc
+++ b/chromium/base/trace_event/malloc_dump_provider.cc
@@ -130,7 +130,7 @@ bool MallocDumpProvider::OnMemoryDump(const MemoryDumpArgs& args,
     allocated_objects_size = main_heap_info.allocated_size;
     allocated_objects_count = main_heap_info.block_count;
   }
-#elif defined(OS_FUCHSIA)
+#elif defined(OS_FUCHSIA) || defined(OS_HAIKU)
 // TODO(fuchsia): Port, see https://crbug.com/706592.
 #else
   struct mallinfo info = mallinfo();
diff --git a/chromium/base/trace_event/process_memory_dump.cc b/chromium/base/trace_event/process_memory_dump.cc
index b757168..95c2088 100644
--- a/chromium/base/trace_event/process_memory_dump.cc
+++ b/chromium/base/trace_event/process_memory_dump.cc
@@ -117,7 +117,7 @@ size_t ProcessMemoryDump::CountResidentBytes(void* start_address,
 
     for (size_t i = 0; i < page_count; i++)
       resident_page_count += vec[i].VirtualAttributes.Valid;
-#elif defined(OS_FUCHSIA)
+#elif defined(OS_FUCHSIA) || defined(OS_HAIKU)
     // TODO(fuchsia): Port, see https://crbug.com/706592.
     ALLOW_UNUSED_LOCAL(chunk_start);
     ALLOW_UNUSED_LOCAL(page_count);
diff --git a/chromium/build/build_config.h b/chromium/build/build_config.h
index 2c3e81e..f0e1ded 100644
--- a/chromium/build/build_config.h
+++ b/chromium/build/build_config.h
@@ -86,6 +86,8 @@
 #define OS_AIX 1
 #elif defined(__asmjs__) || defined(__wasm__)
 #define OS_ASMJS 1
+#elif defined(__HAIKU__)
+#define OS_HAIKU 1
 #else
 #error Please add support for your platform in build/build_config.h
 #endif
@@ -108,7 +110,7 @@
     defined(OS_FREEBSD) || defined(OS_IOS) || defined(OS_LINUX) ||  \
     defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_NACL) ||  \
     defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(OS_QNX) || \
-    defined(OS_SOLARIS)
+    defined(OS_SOLARIS) || defined(OS_HAIKU)
 #define OS_POSIX 1
 #endif
 
diff --git a/chromium/build/config/BUILD.gn b/chromium/build/config/BUILD.gn
index f88c691..df87c89 100644
--- a/chromium/build/config/BUILD.gn
+++ b/chromium/build/config/BUILD.gn
@@ -233,7 +233,7 @@ config("default_libs") {
       "CoreText.framework",
       "Foundation.framework",
     ]
-  } else if (is_linux || is_chromeos) {
+  } else if ((is_linux && !is_haiku) || is_chromeos) {
     libs = [
       "dl",
       "pthread",
diff --git a/chromium/build/config/BUILDCONFIG.gn b/chromium/build/config/BUILDCONFIG.gn
index 3815dd6..2dc0602 100644
--- a/chromium/build/config/BUILDCONFIG.gn
+++ b/chromium/build/config/BUILDCONFIG.gn
@@ -131,13 +131,13 @@ declare_args() {
   is_official_build = false
 
   # Whether we're a traditional desktop unix.
-  is_desktop_linux = current_os == "linux"
+  is_desktop_linux = current_os == "linux" || current_os == "haiku"
 
   # Set to true when compiling with the Clang compiler.
-  is_clang = current_os != "linux" ||
+  is_clang = current_os != "haiku" && (current_os != "linux" ||
              (current_cpu != "s390x" && current_cpu != "s390" &&
               current_cpu != "ppc64" && current_cpu != "ppc" &&
-              current_cpu != "mips" && current_cpu != "mips64")
+              current_cpu != "mips" && current_cpu != "mips64"))
 
   # Allows the path to a custom target toolchain to be injected as a single
   # argument, and set as the default toolchain.
@@ -191,8 +191,8 @@ if (host_toolchain == "") {
   # TODO(dpranke): Add some sort of assert here that verifies that
   # no toolchain omitted host_toolchain from its toolchain_args().
 
-  if (host_os == "linux") {
-    if (target_os != "linux") {
+  if (host_os == "linux" || host_os == "haiku") {
+    if (target_os != "linux" && target_os != "haiku") {
       host_toolchain = "//build/toolchain/linux:clang_$host_cpu"
     } else if (is_clang) {
       host_toolchain = "//build/toolchain/linux:clang_$host_cpu"
@@ -218,6 +218,8 @@ if (host_toolchain == "") {
     }
   } else if (host_os == "aix") {
     host_toolchain = "//build/toolchain/aix:$host_cpu"
+  } else if (host_os == "haiku") {
+    host_toolchain = "//build/toolchain/haiku:$host_cpu"
   } else {
     assert(false, "Unsupported host_os: $host_os")
   }
@@ -229,7 +231,7 @@ if (target_os == "android") {
   assert(host_os == "linux" || host_os == "mac",
          "Android builds are only supported on Linux and Mac hosts.")
   _default_toolchain = "//build/toolchain/android:android_clang_$target_cpu"
-} else if (target_os == "chromeos" || target_os == "linux") {
+} else if (target_os == "chromeos" || target_os == "linux" || target_os == "haiku") {
   # See comments in build/toolchain/cros/BUILD.gn about board compiles.
   if (is_clang) {
     _default_toolchain = "//build/toolchain/linux:clang_$target_cpu"
@@ -293,10 +295,11 @@ is_android = current_os == "android"
 is_chromeos = current_os == "chromeos"
 is_fuchsia = current_os == "fuchsia"
 is_ios = current_os == "ios"
-is_linux = current_os == "linux"
+is_linux = current_os == "linux" || current_os == "haiku"
 is_mac = current_os == "mac"
 is_nacl = current_os == "nacl"
 is_win = current_os == "win" || current_os == "winuwp"
+is_haiku = current_os == "haiku"
 
 is_apple = is_ios || is_mac
 is_posix = !is_win && !is_fuchsia
diff --git a/chromium/build/config/compiler/BUILD.gn b/chromium/build/config/compiler/BUILD.gn
index b511a58..49f2a71 100644
--- a/chromium/build/config/compiler/BUILD.gn
+++ b/chromium/build/config/compiler/BUILD.gn
@@ -256,6 +256,8 @@ config("compiler") {
     configs += [ "//build/config/fuchsia:compiler" ]
   } else if (current_os == "aix") {
     configs += [ "//build/config/aix:compiler" ]
+  } else if (is_haiku) {
+    configs += [ "//build/config/haiku:compiler" ]
   }
 
   configs += [
@@ -290,7 +292,7 @@ config("compiler") {
       # The x86 toolchain currently has problems with stack-protector.
       if (is_android && current_cpu == "x86") {
         cflags += [ "-fno-stack-protector" ]
-      } else if (current_os != "aix") {
+      } else if (current_os != "aix" && current_os != "haiku") {
         # Not available on aix.
         cflags += [ "-fstack-protector" ]
       }
@@ -459,7 +461,7 @@ config("compiler") {
     ldflags += [ "-Wl,--icf=all" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     cflags += [ "-pthread" ]
     # Do not use the -pthread ldflag here since it becomes a no-op
     # when using -nodefaultlibs, which would cause an unused argument
@@ -1262,6 +1264,8 @@ config("runtime_library") {
     configs += [ "//build/config/mac:runtime_library" ]
   } else if (is_android) {
     configs += [ "//build/config/android:runtime_library" ]
+  } else if (is_haiku) {
+    configs += [ "//build/config/haiku:runtime_library" ]
   }
 
   if (is_component_build) {
@@ -1507,7 +1511,9 @@ config("default_warnings") {
       cflags_cc += [ "-Wno-subobject-linkage" ]
       cflags_cc += [ "-Wno-invalid-offsetof" ]
       cflags_cc += [ "-Wno-return-type" ]
-      cflags_cc += [ "-Wno-deprecated-copy" ]
+      if (!is_haiku) {
+        cflags_cc += [ "-Wno-deprecated-copy" ]
+      }
     }
   }
 
@@ -1780,7 +1786,7 @@ config("no_rtti") {
 # (de)allocate memory on a different heap, which would spell trouble if pointers
 # to heap-allocated memory are passed over shared library boundaries.
 config("export_dynamic") {
-  if (is_desktop_linux || export_libcxxabi_from_executables) {
+  if (is_desktop_linux && !is_haiku || export_libcxxabi_from_executables) {
     ldflags = [ "-rdynamic" ]
   }
 }
diff --git a/chromium/build/config/crypto.gni b/chromium/build/config/crypto.gni
index 093c353..74a776f 100644
--- a/chromium/build/config/crypto.gni
+++ b/chromium/build/config/crypto.gni
@@ -13,5 +13,5 @@
 
 declare_args() {
   # True if NSS is used for certificate handling.
-  use_nss_certs = is_linux || is_chromeos
+  use_nss_certs = is_linux || is_chromeos || is_haiku
 }
diff --git a/chromium/build/config/features.gni b/chromium/build/config/features.gni
index 95c766f..24b7d16 100644
--- a/chromium/build/config/features.gni
+++ b/chromium/build/config/features.gni
@@ -26,11 +26,11 @@ declare_args() {
   proprietary_codecs = is_chrome_branded || is_chromecast
 
   # libudev usage. This currently only affects the content layer.
-  use_udev = (is_linux || is_chromeos) && !is_chromecast
+  use_udev = (is_linux || is_chromeos) && !is_chromecast && !is_haiku
 
-  use_dbus = (is_linux || is_chromeos) && !is_chromecast
+  use_dbus = (is_linux || is_chromeos) && !is_chromecast && !is_haiku
 
-  use_gio = is_linux && !is_chromeos && !is_chromecast
+  use_gio = is_linux && !is_chromeos && !is_chromecast && !is_haiku
 
   use_qt = false
 }
diff --git a/chromium/build/config/gcc/BUILD.gn b/chromium/build/config/gcc/BUILD.gn
index 154b259..d917146 100644
--- a/chromium/build/config/gcc/BUILD.gn
+++ b/chromium/build/config/gcc/BUILD.gn
@@ -91,7 +91,10 @@ if (is_component_build && !is_android) {
 # Settings for executables.
 config("executable_config") {
   configs = executable_and_shared_library_configs_
-  ldflags = [ "-pie" ]
+  ldflags = []
+  if (!is_haiku) {
+    ldflags += [ "-pie" ]
+  }
   if (is_android) {
     ldflags += [
       "-Bdynamic",
diff --git a/chromium/build/config/haiku/BUILD.gn b/chromium/build/config/haiku/BUILD.gn
new file mode 100644
index 0000000..95fed9d
--- /dev/null
+++ b/chromium/build/config/haiku/BUILD.gn
@@ -0,0 +1,37 @@
+# Copyright (c) 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/c++/c++.gni")
+import("//build/config/linux/pkg_config.gni")
+import("//build/config/ui.gni")
+
+# This is included by reference in the //build/config/compiler config that
+# is applied to all targets. It is here to separate out the logic that is
+# Linux-only. This is not applied to Android, but is applied to ChromeOS.
+config("compiler") {
+}
+
+# This is included by reference in the //build/config/compiler:runtime_library
+# config that is applied to all targets. It is here to separate out the logic
+# that is Linux-only. Please see that target for advice on what should go in
+# :runtime_library vs. :compiler.
+config("runtime_library") {
+  libs = [ "be" ]
+}
+
+if (use_glib) {
+  pkg_config("glib") {
+    packages = [
+      "glib-2.0",
+      "gmodule-2.0",
+      "gobject-2.0",
+      "gthread-2.0",
+    ]
+    defines = [
+      "GLIB_VERSION_MAX_ALLOWED=GLIB_VERSION_2_40",
+      "GLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_40",
+    ]
+  }
+}
+
diff --git a/chromium/build/config/linux/pkg-config.py b/chromium/build/config/linux/pkg-config.py
index 5adf70c..520e970 100755
--- a/chromium/build/config/linux/pkg-config.py
+++ b/chromium/build/config/linux/pkg-config.py
@@ -109,7 +109,7 @@ def main():
   # If this is run on non-Linux platforms, just return nothing and indicate
   # success. This allows us to "kind of emulate" a Linux build from other
   # platforms.
-  if "linux" not in sys.platform:
+  if "linux" not in sys.platform and "haiku" not in sys.platform:
     print("[[],[],[],[],[]]")
     return 0
 
diff --git a/chromium/build/config/logging.gni b/chromium/build/config/logging.gni
index b0ae9e8..7c4a0bc 100644
--- a/chromium/build/config/logging.gni
+++ b/chromium/build/config/logging.gni
@@ -6,5 +6,5 @@ import("//build/config/dcheck_always_on.gni")
 
 declare_args() {
   # Use LogErrorNotReached() for NOTREACHED().
-  enable_log_error_not_reached = is_chromeos && !(is_debug || dcheck_always_on)
+  enable_log_error_not_reached = is_haiku || is_chromeos && !(is_debug || dcheck_always_on)
 }
diff --git a/chromium/build/config/ui.gni b/chromium/build/config/ui.gni
index a67d5a4..3ed9b6f 100644
--- a/chromium/build/config/ui.gni
+++ b/chromium/build/config/ui.gni
@@ -35,7 +35,7 @@ declare_args() {
 
   # Indicates if Aura is enabled. Aura is a low-level windowing library, sort
   # of a replacement for GDI or GTK.
-  use_aura = is_win || is_linux || is_chromeos || is_fuchsia
+  use_aura = is_win || is_linux || is_chromeos || is_fuchsia || is_haiku
 }
 
 declare_args() {
diff --git a/chromium/build/toolchain/haiku/BUILD.gn b/chromium/build/toolchain/haiku/BUILD.gn
new file mode 100644
index 0000000..2e3d230
--- /dev/null
+++ b/chromium/build/toolchain/haiku/BUILD.gn
@@ -0,0 +1,54 @@
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/sysroot.gni")
+import("//build/toolchain/gcc_toolchain.gni")
+
+gcc_toolchain("x86") {
+  cc = "gcc"
+  cxx = "g++"
+
+  readelf = "readelf"
+  nm = "nm"
+  ar = "ar"
+  ld = cxx
+
+  # Output linker map files for binary size analysis.
+  enable_linker_map = true
+
+  toolchain_args = {
+    current_cpu = "x86"
+    current_os = "haiku"
+    is_clang = false
+  }
+}
+
+clang_toolchain("clang_x64") {
+  # Output linker map files for binary size analysis.
+  enable_linker_map = true
+
+  toolchain_args = {
+    current_cpu = "x64"
+    current_os = "haiku"
+  }
+}
+
+gcc_toolchain("x64") {
+  cc = "gcc"
+  cxx = "g++"
+
+  readelf = "readelf"
+  nm = "nm"
+  ar = "ar"
+  ld = cxx
+
+  # Output linker map files for binary size analysis.
+  enable_linker_map = true
+
+  toolchain_args = {
+    current_cpu = "x64"
+    current_os = "haiku"
+    is_clang = false
+  }
+}
diff --git a/chromium/chrome/browser/BUILD.gn b/chromium/chrome/browser/BUILD.gn
index 8b31283..7b306fc 100644
--- a/chromium/chrome/browser/BUILD.gn
+++ b/chromium/chrome/browser/BUILD.gn
@@ -4938,7 +4938,7 @@ static_library("browser") {
     ]
   }
 
-  if (is_posix && !is_mac) {
+  if (is_posix && !is_mac && !is_haiku) {
     # TODO(crbug.com / 753619): Enable crash reporting on Fuchsia.
     sources += [
       "//chrome/app/chrome_crash_reporter_client.cc",
diff --git a/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc b/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
index 59cc5e1..7ede6cd 100644
--- a/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
+++ b/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
@@ -42,6 +42,8 @@ const char kProduct[] = "Chrome_Mac";
 const char kProduct[] = "Chrome_ChromeOS";
 #elif defined(OS_LINUX)
 const char kProduct[] = "Chrome_Linux";
+#elif defined(OS_HAIKU)
+const char kProduct[] = "Chrome_Haiku";
 #elif defined(OS_ANDROID)
 const char kProduct[] = "Chrome_Android";
 #else
diff --git a/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc b/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc
index a96250c..9cc616d 100644
--- a/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc
+++ b/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc
@@ -359,6 +359,8 @@ void WebRtcLogUploader::SetupMultipart(
   const char product[] = "Chrome_Android";
 #elif defined(OS_CHROMEOS)
   const char product[] = "Chrome_ChromeOS";
+#elif defined(OS_HAIKU)
+  const char product[] = "Chrome_Haiku";
 #else
 #error Platform not supported.
 #endif
diff --git a/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.cc b/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.cc
index 2e29002..b67a659 100644
--- a/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.cc
+++ b/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.cc
@@ -23,10 +23,10 @@
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/render_process_host.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "content/public/browser/child_process_security_policy.h"
 #include "storage/browser/file_system/isolated_context.h"
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)s
 
 using webrtc_event_logging::WebRtcEventLogManager;
 
@@ -273,7 +273,7 @@ void WebRtcLoggingController::StartEventLogging(
         web_app_id, callback);
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 void WebRtcLoggingController::GetLogsDirectory(
     LogsDirectoryCallback callback,
     LogsDirectoryErrorCallback error_callback) {
@@ -319,7 +319,7 @@ void WebRtcLoggingController::GrantLogsDirectoryAccess(
       FROM_HERE,
       base::BindOnce(std::move(callback), file_system.id(), registered_name));
 }
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 void WebRtcLoggingController::OnRtpPacket(
     std::unique_ptr<uint8_t[]> packet_header,
diff --git a/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.h b/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.h
index cb235c9..1106677 100644
--- a/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.h
+++ b/chromium/chrome/browser/media/webrtc/webrtc_logging_controller.h
@@ -133,13 +133,13 @@ class WebRtcLoggingController
                          size_t web_app_id,
                          const StartEventLoggingCallback& callback);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Ensures that the WebRTC Logs directory exists and then grants render
   // process access to the 'WebRTC Logs' directory, and invokes |callback| with
   // the ids necessary to create a DirectoryEntry object.
   void GetLogsDirectory(LogsDirectoryCallback callback,
                         LogsDirectoryErrorCallback error_callback);
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
   // chrome::mojom::WebRtcLoggingClient methods:
   void OnAddMessages(
@@ -192,7 +192,7 @@ class WebRtcLoggingController
       bool success,
       const std::string& error_message);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Grants the render process access to the 'WebRTC Logs' directory, and
   // invokes |callback| with the ids necessary to create a DirectoryEntry
   // object. If the |logs_path| couldn't be created or found, |error_callback|
@@ -200,7 +200,7 @@ class WebRtcLoggingController
   void GrantLogsDirectoryAccess(LogsDirectoryCallback callback,
                                 LogsDirectoryErrorCallback error_callback,
                                 const base::FilePath& logs_path);
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
   static base::FilePath GetLogDirectoryAndEnsureExists(
       const base::FilePath& browser_context_directory_path);
diff --git a/chromium/chrome/common/webui_url_constants.cc b/chromium/chrome/common/webui_url_constants.cc
index 2584f68..25a04b6 100644
--- a/chromium/chrome/common/webui_url_constants.cc
+++ b/chromium/chrome/common/webui_url_constants.cc
@@ -341,7 +341,7 @@ bool IsSystemWebUIHost(base::StringPiece host) {
 #endif  // defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_HAIKU)
 const char kChromeUIDiscardsHost[] = "discards";
 const char kChromeUIDiscardsURL[] = "chrome://discards/";
 const char kChromeUIHatsHost[] = "hats";
@@ -363,17 +363,17 @@ const char kChromeUILinuxProxyConfigHost[] = "linux-proxy-config";
 #endif
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || defined(OS_HAIKU)
 const char kChromeUISandboxHost[] = "sandbox";
 #endif
 
 #if defined(OS_WIN) || defined(OS_MAC) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
 const char kChromeUIBrowserSwitchHost[] = "browser-switch";
 const char kChromeUIBrowserSwitchURL[] = "chrome://browser-switch/";
 #endif
 
-#if ((defined(OS_LINUX) || defined(OS_CHROMEOS)) && defined(TOOLKIT_VIEWS)) || \
+#if ((defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)) && defined(TOOLKIT_VIEWS)) || \
     defined(USE_AURA)
 const char kChromeUITabModalConfirmDialogHost[] = "tab-modal-confirm-dialog";
 #endif
diff --git a/chromium/chrome/common/webui_url_constants.h b/chromium/chrome/common/webui_url_constants.h
index a72ca75..585a062 100644
--- a/chromium/chrome/common/webui_url_constants.h
+++ b/chromium/chrome/common/webui_url_constants.h
@@ -292,7 +292,7 @@ bool IsSystemWebUIHost(base::StringPiece host);
 #endif  // defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_HAIKU)
 extern const char kChromeUIDiscardsHost[];
 extern const char kChromeUIDiscardsURL[];
 extern const char kChromeUIHatsHost[];
@@ -312,17 +312,17 @@ extern const char kChromeUILinuxProxyConfigHost[];
 #endif
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || defined(OS_HAIKU)
 extern const char kChromeUISandboxHost[];
 #endif
 
 #if defined(OS_WIN) || defined(OS_MAC) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
 extern const char kChromeUIBrowserSwitchHost[];
 extern const char kChromeUIBrowserSwitchURL[];
 #endif
 
-#if ((defined(OS_LINUX) || defined(OS_CHROMEOS)) && defined(TOOLKIT_VIEWS)) || \
+#if ((defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)) && defined(TOOLKIT_VIEWS)) || \
     defined(USE_AURA)
 extern const char kChromeUITabModalConfirmDialogHost[];
 #endif
diff --git a/chromium/chrome/test/BUILD.gn b/chromium/chrome/test/BUILD.gn
index 1a369fa..3c53323 100644
--- a/chromium/chrome/test/BUILD.gn
+++ b/chromium/chrome/test/BUILD.gn
@@ -6606,7 +6606,7 @@ test("chrome_app_unittests") {
     "//components/safe_browsing:buildflags",
     "//pdf:pdf_ppapi",
   ]
-  if (!is_fuchsia) {
+  if (!is_fuchsia && !is_haiku) {
     # TODO(crbug.com/753619): Enable crash reporting on Fuchsia.
     deps += [ "//third_party/breakpad:client" ]
   }
diff --git a/chromium/components/BUILD.gn b/chromium/components/BUILD.gn
index 830a35c..2f15af0 100644
--- a/chromium/components/BUILD.gn
+++ b/chromium/components/BUILD.gn
@@ -312,7 +312,7 @@ test("components_unittests") {
       ]
     }
 
-    if (!is_fuchsia) {  # !iOS and !Fuchsia
+    if (!is_fuchsia && !is_haiku) {  # !iOS and !Fuchsia
       deps += [
         "//components/crash/content/browser:unit_tests",
         "//components/crash/content/browser/error_reporting:unit_tests",
diff --git a/chromium/components/crash/content/browser/BUILD.gn b/chromium/components/crash/content/browser/BUILD.gn
index efc8041..35aab55 100644
--- a/chromium/components/crash/content/browser/BUILD.gn
+++ b/chromium/components/crash/content/browser/BUILD.gn
@@ -14,7 +14,7 @@ import("//build/config/deprecated_default_sources_assignment_filter.gni")
 set_sources_assignment_filter(deprecated_default_sources_assignment_filter)
 
 # TODO(crbug.com/753619): Enable crash reporting on Fuchsia.
-assert(!is_fuchsia)
+assert(!is_fuchsia && !is_haiku)
 
 source_set("browser") {
   sources = [
@@ -35,7 +35,7 @@ source_set("browser") {
     "//content/public/common",
   ]
 
-  if (is_linux || is_chromeos || is_android) {
+  if ((is_linux && !is_haiku) || is_chromeos || is_android) {
     set_sources_assignment_filter([])
 
     # Want this file on both Linux and Android.
@@ -49,13 +49,13 @@ source_set("browser") {
     deps += [ "//third_party/crashpad/crashpad/client" ]
   }
 
-  if (!is_android) {
+  if (!is_android && !is_haiku) {
     deps += [ "//third_party/breakpad:client" ]
   }
 
   # This is not in the GYP build but this target includes breakpad client
   # headers, so add the dependency here.
-  if ((is_posix && !is_ios) || is_fuchsia) {
+  if ((is_posix && !is_ios && !is_haiku) || is_fuchsia) {
     configs += [ "//third_party/breakpad:client_config" ]
     public_configs = [ "//third_party/breakpad:client_config" ]
   }
diff --git a/chromium/components/crash/core/common/BUILD.gn b/chromium/components/crash/core/common/BUILD.gn
index 6dbaaea..e0ca272 100644
--- a/chromium/components/crash/core/common/BUILD.gn
+++ b/chromium/components/crash/core/common/BUILD.gn
@@ -7,7 +7,7 @@ import("//components/gwp_asan/buildflags/buildflags.gni")
 
 declare_args() {
   # If set to true, this will stub out and disable the entire crash key system.
-  use_crash_key_stubs = is_fuchsia
+  use_crash_key_stubs = is_fuchsia || is_haiku
 }
 
 group("common") {
@@ -108,7 +108,9 @@ target(crash_key_target_type, "crash_key_lib") {
       ]
     }
 
-    deps += [ "//third_party/breakpad:client" ]
+    if (!is_haiku) {
+      deps += [ "//third_party/breakpad:client" ]
+    }
     if (use_combined_annotations) {
       public_deps += [ "//third_party/crashpad/crashpad/client" ]
     }
@@ -184,7 +186,7 @@ source_set("unit_tests") {
     sources += [ "crash_key_breakpad_ios_unittest.cc" ]
     deps += [ "//third_party/breakpad:client" ]
     include_dirs = [ "//third_party/breakpad/breakpad/src/" ]
-  } else if (!is_mac && !is_win && !is_fuchsia && !is_android) {
+  } else if (!is_mac && !is_win && !is_fuchsia && !is_android && !is_haiku) {
     include_dirs = [ "//third_party/breakpad/breakpad/src/" ]
     sources += [ "crash_key_breakpad_unittest.cc" ]
   }
diff --git a/chromium/components/metrics/BUILD.gn b/chromium/components/metrics/BUILD.gn
index dd63573..93cdccc 100644
--- a/chromium/components/metrics/BUILD.gn
+++ b/chromium/components/metrics/BUILD.gn
@@ -190,6 +190,9 @@ jumbo_static_library("metrics") {
   if (is_fuchsia) {
     sources += [ "drive_metrics_provider_fuchsia.cc" ]
   }
+  if (is_haiku) {
+    sources -= [ "drive_metrics_provider_linux.cc" ]
+  }
 }
 
 if (is_android) {
diff --git a/chromium/components/os_crypt/os_crypt.h b/chromium/components/os_crypt/os_crypt.h
index a061ca2..8cc834e 100644
--- a/chromium/components/os_crypt/os_crypt.h
+++ b/chromium/components/os_crypt/os_crypt.h
@@ -15,7 +15,7 @@
 #include "base/strings/string16.h"
 #include "build/build_config.h"
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
 class KeyStorageLinux;
 #endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
 
@@ -34,13 +34,13 @@ struct Config;
 // true for Linux, if a password management tool is available.
 class OSCrypt {
  public:
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Set the configuration of OSCrypt.
   static COMPONENT_EXPORT(OS_CRYPT) void SetConfig(
       std::unique_ptr<os_crypt::Config> config);
 #endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
 
-#if defined(OS_APPLE) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if defined(OS_APPLE) || (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
   // On Linux returns true iff the real secret key (not hardcoded one) is
   // available. On MacOS returns true if Keychain is available (for mock
   // Keychain it returns true if not using locked Keychain, false if using
@@ -131,7 +131,7 @@ class OSCrypt {
   DISALLOW_IMPLICIT_CONSTRUCTORS(OSCrypt);
 };
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // For unit testing purposes, inject methods to be used.
 // |get_key_storage_mock| provides the desired |KeyStorage| implementation.
 // If the provider returns |nullptr|, a hardcoded password will be used.
diff --git a/chromium/components/os_crypt/os_crypt_unittest.cc b/chromium/components/os_crypt/os_crypt_unittest.cc
index 44bb54c..04b97dc 100644
--- a/chromium/components/os_crypt/os_crypt_unittest.cc
+++ b/chromium/components/os_crypt/os_crypt_unittest.cc
@@ -18,7 +18,7 @@
 #include "components/os_crypt/os_crypt_mocker.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "components/os_crypt/os_crypt_mocker_linux.h"
 #endif
 
diff --git a/chromium/components/system_media_controls/linux/buildflags/buildflags.gni b/chromium/components/system_media_controls/linux/buildflags/buildflags.gni
index cc386df..3f6de76 100644
--- a/chromium/components/system_media_controls/linux/buildflags/buildflags.gni
+++ b/chromium/components/system_media_controls/linux/buildflags/buildflags.gni
@@ -7,5 +7,5 @@ import("//build/config/features.gni")
 declare_args() {
   # Enables Chromium implementation of the MPRIS D-Bus interface for controlling
   # media playback. See ../README.md for details.
-  use_mpris = is_desktop_linux && use_dbus
+  use_mpris = is_desktop_linux && use_dbus && !is_haiku
 }
diff --git a/chromium/components/variations/client_filterable_state.cc b/chromium/components/variations/client_filterable_state.cc
index 42c57b4..f3846e2 100644
--- a/chromium/components/variations/client_filterable_state.cc
+++ b/chromium/components/variations/client_filterable_state.cc
@@ -25,7 +25,7 @@ Study::Platform ClientFilterableState::GetCurrentPlatform() {
   return Study::PLATFORM_ANDROID;
 #elif defined(OS_FUCHSIA)
   return Study::PLATFORM_FUCHSIA;
-#elif defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
+#elif defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS) || defined(OS_HAIKU)
   // Default BSD and SOLARIS to Linux to not break those builds, although these
   // platforms are not officially supported by Chrome.
   return Study::PLATFORM_LINUX;
diff --git a/chromium/content/app/content_main_runner_impl.cc b/chromium/content/app/content_main_runner_impl.cc
index a8c7d44..fdfc614 100644
--- a/chromium/content/app/content_main_runner_impl.cc
+++ b/chromium/content/app/content_main_runner_impl.cc
@@ -461,7 +461,9 @@ int RunZygote(ContentMainDelegate* delegate) {
   };
 
   std::vector<std::unique_ptr<ZygoteForkDelegate>> zygote_fork_delegates;
+#if defined(OS_LINUX)
   delegate->ZygoteStarting(&zygote_fork_delegates);
+#endif
   media::InitializeMediaLibrary();
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
@@ -473,7 +475,9 @@ int RunZygote(ContentMainDelegate* delegate) {
     return 1;
   }
 
+#if defined(OS_LINUX)
   delegate->ZygoteForked();
+#endif
 
   // Zygote::HandleForkRequest may have reallocated the command
   // line so update it here with the new version.
diff --git a/chromium/content/browser/BUILD.gn b/chromium/content/browser/BUILD.gn
index ae459c2..43533cd 100644
--- a/chromium/content/browser/BUILD.gn
+++ b/chromium/content/browser/BUILD.gn
@@ -2068,7 +2068,7 @@ jumbo_static_library("browser") {
     deps += [ "//ui/events" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_haiku) {
     sources += [
       "font_access/font_enumeration_cache_fontconfig.cc",
       "font_access/font_enumeration_cache_fontconfig.h",
diff --git a/chromium/content/browser/child_process_launcher_helper_linux.cc b/chromium/content/browser/child_process_launcher_helper_linux.cc
index f3d40b6..16c5cc1 100644
--- a/chromium/content/browser/child_process_launcher_helper_linux.cc
+++ b/chromium/content/browser/child_process_launcher_helper_linux.cc
@@ -19,7 +19,9 @@
 #include "content/public/common/result_codes.h"
 #include "content/public/common/sandboxed_process_launcher_delegate.h"
 #include "content/public/common/zygote/sandbox_support_linux.h"
+#if !defined(OS_HAIKU)
 #include "content/public/common/zygote/zygote_handle.h"
+#endif
 #include "sandbox/policy/linux/sandbox_linux.h"
 
 namespace content {
@@ -50,10 +52,12 @@ bool ChildProcessLauncherHelper::BeforeLaunchOnLauncherThread(
   options->fds_to_remap = files_to_register.GetMappingWithIDAdjustment(
       base::GlobalDescriptors::kBaseDescriptor);
 
+#if !defined(OS_HAIKU)
   if (GetProcessType() == switches::kRendererProcess) {
     const int sandbox_fd = SandboxHostLinux::GetInstance()->GetChildSocket();
     options->fds_to_remap.push_back(std::make_pair(sandbox_fd, GetSandboxFD()));
   }
+#endif
 
   options->environment = delegate_->GetEnvironment();
 
@@ -68,6 +72,7 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
     int* launch_result) {
   *is_synchronous_launch = true;
 
+#if !defined(OS_HAIKU)
   ZygoteHandle zygote_handle =
       base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kNoZygote)
           ? nullptr
@@ -81,7 +86,6 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
         GetProcessType());
     *launch_result = LAUNCH_RESULT_SUCCESS;
 
-#if !defined(OS_OPENBSD)
     if (handle) {
       // It could be a renderer process or an utility process.
       int oom_score = content::kMiscOomScore;
@@ -90,13 +94,13 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
         oom_score = content::kLowestRendererOomScore;
       ZygoteHostImpl::GetInstance()->AdjustRendererOOMScore(handle, oom_score);
     }
-#endif
 
     Process process;
     process.process = base::Process(handle);
     process.zygote = zygote_handle;
     return process;
   }
+#endif
 
   Process process;
   process.process = base::LaunchProcess(*command_line(), options);
@@ -114,10 +118,14 @@ ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(
     const ChildProcessLauncherHelper::Process& process,
     bool known_dead) {
   ChildProcessTerminationInfo info;
+#if !defined(OS_HAIKU)
   if (process.zygote) {
     info.status = process.zygote->GetTerminationStatus(
         process.process.Handle(), known_dead, &info.exit_code);
   } else if (known_dead) {
+#else
+  if (known_dead) {
+#endif
     info.status = base::GetKnownDeadTerminationStatus(process.process.Handle(),
                                                       &info.exit_code);
   } else {
@@ -141,13 +149,17 @@ void ChildProcessLauncherHelper::ForceNormalProcessTerminationSync(
   DCHECK(CurrentlyOnProcessLauncherTaskRunner());
   process.process.Terminate(RESULT_CODE_NORMAL_EXIT, false);
   // On POSIX, we must additionally reap the child.
+#if !defined(OS_HAIKU)
   if (process.zygote) {
     // If the renderer was created via a zygote, we have to proxy the reaping
     // through the zygote process.
     process.zygote->EnsureProcessTerminated(process.process.Handle());
   } else {
+#endif
     base::EnsureProcessTerminated(std::move(process.process));
+#if !defined(OS_HAIKU)
   }
+#endif
 }
 
 void ChildProcessLauncherHelper::SetProcessPriorityOnLauncherThread(
diff --git a/chromium/content/browser/compositor/viz_process_transport_factory.cc b/chromium/content/browser/compositor/viz_process_transport_factory.cc
index 4d64a50..a105c69 100644
--- a/chromium/content/browser/compositor/viz_process_transport_factory.cc
+++ b/chromium/content/browser/compositor/viz_process_transport_factory.cc
@@ -108,7 +108,7 @@ class HostDisplayClient : public viz::HostDisplayClient {
   HostDisplayClient& operator=(const HostDisplayClient&) = delete;
 
   // viz::HostDisplayClient:
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
   void DidCompleteSwapWithNewSize(const gfx::Size& size) override {
     compositor_->OnCompleteSwapWithNewSize(size);
   }
diff --git a/chromium/content/browser/gpu/gpu_process_host.cc b/chromium/content/browser/gpu/gpu_process_host.cc
index eec6c13..90fe57e 100644
--- a/chromium/content/browser/gpu/gpu_process_host.cc
+++ b/chromium/content/browser/gpu/gpu_process_host.cc
@@ -226,7 +226,7 @@ static const char* const kSwitchNames[] = {
     sandbox::policy::switches::kGpuSandboxFailuresFatal,
     sandbox::policy::switches::kDisableGpuSandbox,
     sandbox::policy::switches::kNoSandbox,
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
+#if (defined(OS_LINUX) || defined(OS_HAIKU)) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
     switches::kDisableDevShmUsage,
 #endif
 #if defined(OS_WIN)
diff --git a/chromium/content/browser/memory/swap_metrics_driver_impl_linux.cc b/chromium/content/browser/memory/swap_metrics_driver_impl_linux.cc
index 1b04510..6754828 100644
--- a/chromium/content/browser/memory/swap_metrics_driver_impl_linux.cc
+++ b/chromium/content/browser/memory/swap_metrics_driver_impl_linux.cc
@@ -43,6 +43,7 @@ SwapMetricsDriverImplLinux::~SwapMetricsDriverImplLinux() = default;
 
 SwapMetricsDriver::SwapMetricsUpdateResult
 SwapMetricsDriverImplLinux::UpdateMetricsInternal(base::TimeDelta interval) {
+#if !defined(OS_HAIKU)
   base::VmStatInfo vmstat;
   if (!base::GetVmStatInfo(&vmstat)) {
     return SwapMetricsDriver::SwapMetricsUpdateResult::kSwapMetricsUpdateFailed;
@@ -61,6 +62,9 @@ SwapMetricsDriverImplLinux::UpdateMetricsInternal(base::TimeDelta interval) {
   delegate_->OnSwapOutCount(out_counts, interval);
 
   return SwapMetricsDriver::SwapMetricsUpdateResult::kSwapMetricsUpdateSuccess;
+#else
+  return SwapMetricsDriver::SwapMetricsUpdateResult::kSwapMetricsUpdateFailed;
+#endif
 }
 
 }  // namespace content
diff --git a/chromium/content/browser/renderer_host/render_message_filter.cc b/chromium/content/browser/renderer_host/render_message_filter.cc
index 758ed53..b481c29 100644
--- a/chromium/content/browser/renderer_host/render_message_filter.cc
+++ b/chromium/content/browser/renderer_host/render_message_filter.cc
@@ -70,7 +70,7 @@
 #if defined(OS_MAC)
 #include "ui/accelerated_widget_mac/window_resize_helper_mac.h"
 #endif
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "base/linux_util.h"
 #include "base/threading/platform_thread.h"
 #endif
@@ -117,7 +117,7 @@ void RenderMessageFilter::GenerateRoutingID(
   std::move(callback).Run(render_widget_helper_->GetNextRoutingID());
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 void RenderMessageFilter::SetThreadPriorityOnFileThread(
     base::PlatformThreadId ns_tid,
     base::ThreadPriority priority) {
@@ -138,7 +138,7 @@ void RenderMessageFilter::SetThreadPriorityOnFileThread(
 }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 void RenderMessageFilter::SetThreadPriority(int32_t ns_tid,
                                             base::ThreadPriority priority) {
   constexpr base::TaskTraits kTraits = {
diff --git a/chromium/content/browser/renderer_host/render_message_filter.h b/chromium/content/browser/renderer_host/render_message_filter.h
index 0528188..d6ed752 100644
--- a/chromium/content/browser/renderer_host/render_message_filter.h
+++ b/chromium/content/browser/renderer_host/render_message_filter.h
@@ -79,14 +79,14 @@ class CONTENT_EXPORT RenderMessageFilter
   // mojom::RenderMessageFilter:
   void GenerateRoutingID(GenerateRoutingIDCallback routing_id) override;
   void HasGpuProcess(HasGpuProcessCallback callback) override;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   void SetThreadPriority(int32_t ns_tid,
                          base::ThreadPriority priority) override;
 #endif
 
   void OnResolveProxy(const GURL& url, IPC::Message* reply_msg);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   void SetThreadPriorityOnFileThread(base::PlatformThreadId ns_tid,
                                      base::ThreadPriority priority);
 #endif
diff --git a/chromium/content/browser/renderer_host/render_process_host_impl.cc b/chromium/content/browser/renderer_host/render_process_host_impl.cc
index 5c19edf..f007384 100644
--- a/chromium/content/browser/renderer_host/render_process_host_impl.cc
+++ b/chromium/content/browser/renderer_host/render_process_host_impl.cc
@@ -234,7 +234,7 @@
 #include "third_party/blink/public/mojom/android_font_lookup/android_font_lookup.mojom.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include <sys/resource.h>
 #include <sys/time.h>
 
@@ -1325,7 +1325,7 @@ void RenderProcessHostImpl::IOThreadHostImpl::BindHostReceiver(mojo::GenericPend
       return;
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (auto font_receiver = receiver.As<font_service::mojom::FontService>()) {
     ConnectToFontService(std::move(font_receiver));
     return;
@@ -1751,7 +1751,7 @@ bool RenderProcessHostImpl::Init() {
   renderer_prefix =
       browser_command_line.GetSwitchValueNative(switches::kRendererCmdPrefix);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   int flags = renderer_prefix.empty() ? ChildProcessHost::CHILD_ALLOW_SELF
                                       : ChildProcessHost::CHILD_NORMAL;
 #elif defined(OS_MAC)
@@ -3320,7 +3320,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kDisableInProcessStackTraces,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
     sandbox::policy::switches::kNoSandbox,
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
+#if (defined(OS_LINUX) || defined(OS_HAIKU)) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
     switches::kDisableDevShmUsage,
 #endif
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
diff --git a/chromium/content/browser/renderer_host/render_process_host_impl.h b/chromium/content/browser/renderer_host/render_process_host_impl.h
index dd0774b..57dbbb1 100644
--- a/chromium/content/browser/renderer_host/render_process_host_impl.h
+++ b/chromium/content/browser/renderer_host/render_process_host_impl.h
@@ -477,10 +477,10 @@ class CONTENT_EXPORT RenderProcessHostImpl
     is_for_guests_only_ = is_for_guests_only;
   }
 
-#if defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MAC)
+#if defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MAC) && !defined(OS_HAIKU)
   // Launch the zygote early in the browser startup.
   static void EarlyZygoteLaunch();
-#endif  // defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MAC)
+#endif  // defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MAC) && !defined(OS_HAIKU)
 
   // Called when a video capture stream or an audio stream is added or removed
   // and used to determine if the process should be backgrounded or not.
diff --git a/chromium/content/browser/utility_process_host.cc b/chromium/content/browser/utility_process_host.cc
index 09c7b69..0af6eba 100644
--- a/chromium/content/browser/utility_process_host.cc
+++ b/chromium/content/browser/utility_process_host.cc
@@ -230,7 +230,7 @@ bool UtilityProcessHost::StartProcess() {
       network::switches::kNetLogCaptureMode,
       network::switches::kExplicitlyAllowedPorts,
       sandbox::policy::switches::kNoSandbox,
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
+#if (defined(OS_LINUX) || defined(OS_HAIKU)) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_LACROS)
       switches::kDisableDevShmUsage,
 #endif
 #if defined(OS_MAC)
diff --git a/chromium/content/child/BUILD.gn b/chromium/content/child/BUILD.gn
index cdaf2b2..a914951 100644
--- a/chromium/content/child/BUILD.gn
+++ b/chromium/content/child/BUILD.gn
@@ -155,6 +155,11 @@ target(link_target_type, "child") {
       "//components/services/font/public/cpp",
       "//components/services/font/public/mojom",
     ]
+    if (!is_haiku) {
+      deps += [
+        "//services/service_manager/zygote",
+      ]
+    }
   }
 
   if (is_win) {
diff --git a/chromium/content/common/common_sandbox_support_linux.cc b/chromium/content/common/common_sandbox_support_linux.cc
index 507c355..c4f32af 100644
--- a/chromium/content/common/common_sandbox_support_linux.cc
+++ b/chromium/content/common/common_sandbox_support_linux.cc
@@ -5,6 +5,7 @@
 #include "content/public/common/common_sandbox_support_linux.h"
 
 #include <sys/stat.h>
+#include <unistd.h>
 
 #include <limits>
 #include <memory>
diff --git a/chromium/content/common/set_process_title.cc b/chromium/content/common/set_process_title.cc
index 8b829a4..c813423 100644
--- a/chromium/content/common/set_process_title.cc
+++ b/chromium/content/common/set_process_title.cc
@@ -44,7 +44,7 @@ namespace content {
 
 // TODO(jrg): Find out if setproctitle or equivalent is available on Android.
 #if defined(OS_POSIX) && !defined(OS_MAC) && !defined(OS_SOLARIS) && \
-    !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
+    !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && !defined(OS_HAIKU)
 
 void SetProcessTitleFromCommandLine(const char** main_argv) {
   // Build a single string which consists of all the arguments separated
diff --git a/chromium/content/gpu/BUILD.gn b/chromium/content/gpu/BUILD.gn
index 2c2c1e8..bc93e0a 100644
--- a/chromium/content/gpu/BUILD.gn
+++ b/chromium/content/gpu/BUILD.gn
@@ -132,7 +132,7 @@ target(link_target_type, "gpu_sources") {
 
   # Use DRI on desktop Linux builds.
   if (current_cpu != "s390x" && current_cpu != "ppc64" && is_desktop_linux &&
-      (!is_chromecast || is_cast_desktop_build) && !use_qt) {
+      (!is_chromecast || is_cast_desktop_build) && !use_qt && !is_haiku) {
     configs += [ "//build/config/linux/dri" ]
   }
 }
diff --git a/chromium/content/gpu/gpu_sandbox_hook_linux.cc b/chromium/content/gpu/gpu_sandbox_hook_linux.cc
index eb69d52..aac94fa 100644
--- a/chromium/content/gpu/gpu_sandbox_hook_linux.cc
+++ b/chromium/content/gpu/gpu_sandbox_hook_linux.cc
@@ -98,8 +98,9 @@ static const char kLibV4lEncPluginPath[] =
     "/usr/lib/libv4l/plugins/libv4l-encplugin.so";
 #endif
 
-constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL;
 
+#if !defined(OS_HAIKU)
 void AddV4L2GpuPermissions(
     std::vector<BrokerFilePermission>* permissions,
     const sandbox::policy::SandboxSeccompBPF::Options& options) {
@@ -414,12 +415,14 @@ void LoadV4L2Libraries(
 }
 
 void LoadChromecastV4L2Libraries() {
+#if !defined(OS_HAIKU)
   for (const char* path : kAllowedChromecastPaths) {
     const std::string library_path(std::string(path) +
                                    std::string("libvpcodec.so"));
     if (dlopen(library_path.c_str(), dlopen_flag))
       break;
   }
+#endif
 }
 
 bool LoadLibrariesForGpu(
@@ -440,6 +443,7 @@ bool LoadLibrariesForGpu(
   }
   return true;
 }
+#endif
 
 sandbox::syscall_broker::BrokerCommandSet CommandSetForGPU(
     const sandbox::policy::SandboxLinux::Options& options) {
@@ -466,6 +470,7 @@ bool BrokerProcessPreSandboxHook(
 }  // namespace
 
 bool GpuProcessPreSandboxHook(sandbox::policy::SandboxLinux::Options options) {
+#if !defined(OS_HAIKU)
   sandbox::policy::SandboxLinux::GetInstance()->StartBrokerProcess(
       CommandSetForGPU(options), FilePermissionsForGpu(options),
       base::BindOnce(BrokerProcessPreSandboxHook), options);
@@ -477,6 +482,7 @@ bool GpuProcessPreSandboxHook(sandbox::policy::SandboxLinux::Options options) {
 
   errno = 0;
   return true;
+#endif
 }
 
 }  // namespace content
diff --git a/chromium/content/public/common/child_process_host.h b/chromium/content/public/common/child_process_host.h
index f7c4add..795419d 100644
--- a/chromium/content/public/common/child_process_host.h
+++ b/chromium/content/public/common/child_process_host.h
@@ -81,7 +81,7 @@ class CONTENT_EXPORT ChildProcessHost : public IPC::Sender {
     // No special behavior requested.
     CHILD_NORMAL = 0,
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     // Indicates that the child execed after forking may be execced from
     // /proc/self/exe rather than using the "real" app path. This prevents
     // autoupdate from confusing us if it changes the file out from under us.
diff --git a/chromium/content/public/common/zygote/features.gni b/chromium/content/public/common/zygote/features.gni
index c7580b3..ae0c131 100644
--- a/chromium/content/public/common/zygote/features.gni
+++ b/chromium/content/public/common/zygote/features.gni
@@ -2,4 +2,4 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-use_zygote_handle = is_posix && !is_android && !is_mac
+use_zygote_handle = is_posix && !is_android && !is_mac && !is_haiku
diff --git a/chromium/content/renderer/render_process_impl.cc b/chromium/content/renderer/render_process_impl.cc
index ab0a696..566d324 100644
--- a/chromium/content/renderer/render_process_impl.cc
+++ b/chromium/content/renderer/render_process_impl.cc
@@ -44,7 +44,7 @@
 #if defined(OS_WIN)
 #include "base/win/win_util.h"
 #endif
-#if (defined(OS_LINUX) || defined(OS_CHROMEOS)) && defined(ARCH_CPU_X86_64)
+#if (defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)) && defined(ARCH_CPU_X86_64)
 #include "v8/include/v8-wasm-trap-handler-posix.h"
 #endif
 namespace {
@@ -177,7 +177,7 @@ RenderProcessImpl::RenderProcessImpl()
 
   SetV8FlagIfNotFeature(features::kWebAssemblyTrapHandler,
                         "--no-wasm-trap-handler");
-#if (defined(OS_LINUX) || defined(OS_CHROMEOS)) && defined(ARCH_CPU_X86_64)
+#if (defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)) && defined(ARCH_CPU_X86_64)
   if (base::FeatureList::IsEnabled(features::kWebAssemblyTrapHandler)) {
     base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
     if (!command_line->HasSwitch(switches::kDisableInProcessStackTraces)) {
diff --git a/chromium/content/renderer/render_thread_impl.cc b/chromium/content/renderer/render_thread_impl.cc
index 6f2c8c5..04da65b 100644
--- a/chromium/content/renderer/render_thread_impl.cc
+++ b/chromium/content/renderer/render_thread_impl.cc
@@ -715,7 +715,7 @@ void RenderThreadImpl::Init() {
   DCHECK(parsed_num_raster_threads) << string_value;
   DCHECK_GT(num_raster_threads, 0);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   categorized_worker_pool_->SetBackgroundingCallback(
       main_thread_scheduler_->DefaultTaskRunner(),
       base::BindOnce(
@@ -738,7 +738,7 @@ void RenderThreadImpl::Init() {
   base::DiscardableMemoryAllocator::SetInstance(
       discardable_memory_allocator_.get());
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (base::FeatureList::IsEnabled(
           blink::features::kBlinkCompositorUseDisplayThreadPriority)) {
     render_message_filter()->SetThreadPriority(
diff --git a/chromium/content/renderer/renderer_blink_platform_impl.cc b/chromium/content/renderer/renderer_blink_platform_impl.cc
index 119e70d..7c056d3 100644
--- a/chromium/content/renderer/renderer_blink_platform_impl.cc
+++ b/chromium/content/renderer/renderer_blink_platform_impl.cc
@@ -97,7 +97,7 @@
 
 #if defined(OS_MAC)
 #include "content/child/child_process_sandbox_support_impl_mac.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "content/child/child_process_sandbox_support_impl_linux.h"
 #endif
 
@@ -169,7 +169,7 @@ RendererBlinkPlatformImpl::RendererBlinkPlatformImpl(
       main_thread_scheduler_(main_thread_scheduler) {
   // RenderThread may not exist in some tests.
   if (RenderThreadImpl::current()) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     mojo::PendingRemote<font_service::mojom::FontService> font_service;
     RenderThreadImpl::current()->BindHostReceiver(
         font_service.InitWithNewPipeAndPassReceiver());
@@ -179,7 +179,7 @@ RendererBlinkPlatformImpl::RendererBlinkPlatformImpl(
 #endif
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_HAIKU)
   if (sandboxEnabled()) {
 #if defined(OS_MAC)
     sandbox_support_ = std::make_unique<WebSandboxSupportMac>();
@@ -232,7 +232,7 @@ RendererBlinkPlatformImpl::WrapSharedURLLoaderFactory(
 
 void RendererBlinkPlatformImpl::SetDisplayThreadPriority(
     base::PlatformThreadId thread_id) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (RenderThreadImpl* render_thread = RenderThreadImpl::current()) {
     render_thread->render_message_filter()->SetThreadPriority(
         thread_id, base::ThreadPriority::DISPLAY);
@@ -245,7 +245,7 @@ blink::BlameContext* RendererBlinkPlatformImpl::GetTopLevelBlameContext() {
 }
 
 blink::WebSandboxSupport* RendererBlinkPlatformImpl::GetSandboxSupport() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_HAIKU)
   return sandbox_support_.get();
 #else
   // These platforms do not require sandbox support.
diff --git a/chromium/content/renderer/renderer_blink_platform_impl.h b/chromium/content/renderer/renderer_blink_platform_impl.h
index 823ae98..2ddf57f 100644
--- a/chromium/content/renderer/renderer_blink_platform_impl.h
+++ b/chromium/content/renderer/renderer_blink_platform_impl.h
@@ -30,7 +30,7 @@
 #include "third_party/blink/public/mojom/cache_storage/cache_storage.mojom.h"
 #include "third_party/blink/public/mojom/loader/code_cache.mojom.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "components/services/font/public/cpp/font_loader.h"  // nogncheck
 #include "third_party/skia/include/core/SkRefCnt.h"           // nogncheck
 #endif
@@ -224,7 +224,7 @@ class CONTENT_EXPORT RendererBlinkPlatformImpl : public BlinkPlatformImpl {
   // Return the mojo interface for making CodeCache calls.
   blink::mojom::CodeCacheHost& GetCodeCacheHost();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_HAIKU)
   std::unique_ptr<blink::WebSandboxSupport> sandbox_support_;
 #endif
 
@@ -245,7 +245,7 @@ class CONTENT_EXPORT RendererBlinkPlatformImpl : public BlinkPlatformImpl {
   mojo::PendingRemote<blink::mojom::CodeCacheHost> code_cache_host_remote_;
   mojo::SharedRemote<blink::mojom::CodeCacheHost> code_cache_host_;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   sk_sp<font_service::FontLoader> font_loader_;
 #endif
 
diff --git a/chromium/content/renderer/renderer_main_platform_delegate_linux.cc b/chromium/content/renderer/renderer_main_platform_delegate_linux.cc
index e97f908..3bfc65b 100644
--- a/chromium/content/renderer/renderer_main_platform_delegate_linux.cc
+++ b/chromium/content/renderer/renderer_main_platform_delegate_linux.cc
@@ -30,6 +30,7 @@ void RendererMainPlatformDelegate::PlatformUninitialize() {
 }
 
 bool RendererMainPlatformDelegate::EnableSandbox() {
+#if !defined(OS_HAIKU)
   // The setuid sandbox is started in the zygote process: zygote_main_linux.cc
   // https://chromium.googlesource.com/chromium/src/+/master/docs/linux/suid_sandbox.md
   //
@@ -66,6 +67,7 @@ bool RendererMainPlatformDelegate::EnableSandbox() {
   }
 #endif  // __x86_64__
 
+#endif
   return true;
 }
 
diff --git a/chromium/content/shell/BUILD.gn b/chromium/content/shell/BUILD.gn
index 56c0e8b..f7a0c95 100644
--- a/chromium/content/shell/BUILD.gn
+++ b/chromium/content/shell/BUILD.gn
@@ -94,7 +94,7 @@ static_library("content_shell_app") {
       "//content/web_test:web_test_renderer",
     ]
   }
-  if (!is_fuchsia) {
+  if (!is_fuchsia && !is_haiku) {
     deps += [
       "//components/crash/core/app",
       "//components/crash/core/app:test_support",
@@ -259,6 +259,12 @@ static_library("content_shell_lib") {
       "//components/crash/core/app",
     ]
   }
+  if (is_haiku) {
+    deps -= [
+      "//components/crash/content/browser",
+      "//components/crash/core/app",
+    ]
+  }
 
   if (enable_plugins) {
     sources += [
@@ -791,7 +797,7 @@ group("content_shell_crash_test") {
       mac_bin_path + "otool",
     ]
   }
-  if (is_posix) {
+  if (is_posix && !is_haiku) {
     data += [
       "//components/crash/content/tools/generate_breakpad_symbols.py",
       "//components/crash/content/tools/dmp2minidump.py",
@@ -800,7 +806,7 @@ group("content_shell_crash_test") {
   if (is_win) {
     data_deps += [ "//build/win:copy_cdb_to_output" ]
   }
-  if (is_posix) {
+  if (is_posix && !is_haiku) {
     data_deps += [
       "//third_party/breakpad:dump_syms",
       "//third_party/breakpad:minidump_stackwalk",
diff --git a/chromium/content/utility/BUILD.gn b/chromium/content/utility/BUILD.gn
index 69b834c..d94d0f0 100644
--- a/chromium/content/utility/BUILD.gn
+++ b/chromium/content/utility/BUILD.gn
@@ -85,7 +85,7 @@ jumbo_source_set("utility") {
     deps += [ "//services/proxy_resolver:lib" ]
   }
 
-  if ((is_linux || is_chromeos) && !use_qt) {
+  if ((is_linux || is_chromeos) && !use_qt && !is_haiku) {
     deps += [ "//content/utility/speech:speech_recognition_sandbox_hook" ]
   }
 
diff --git a/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.cc b/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.cc
index f61fcf8..0f123ab 100644
--- a/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.cc
+++ b/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.cc
@@ -9,7 +9,7 @@
 
 #if defined(OS_MAC)
 #include "content/child/child_process_sandbox_support_impl_mac.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "content/child/child_process_sandbox_support_impl_linux.h"
 #endif
 
@@ -17,7 +17,7 @@ namespace content {
 
 UtilityBlinkPlatformWithSandboxSupportImpl::
     UtilityBlinkPlatformWithSandboxSupportImpl() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   mojo::PendingRemote<font_service::mojom::FontService> font_service;
   UtilityThread::Get()->BindHostReceiver(
       font_service.InitWithNewPipeAndPassReceiver());
@@ -34,7 +34,7 @@ UtilityBlinkPlatformWithSandboxSupportImpl::
 
 blink::WebSandboxSupport*
 UtilityBlinkPlatformWithSandboxSupportImpl::GetSandboxSupport() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_HAIKU)
   return sandbox_support_.get();
 #else
   return nullptr;
diff --git a/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.h b/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.h
index fcba9fe..e07bc53 100644
--- a/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.h
+++ b/chromium/content/utility/utility_blink_platform_with_sandbox_support_impl.h
@@ -11,7 +11,7 @@
 #include "build/build_config.h"
 #include "third_party/blink/public/platform/platform.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "components/services/font/public/cpp/font_loader.h"  // nogncheck
 #include "third_party/skia/include/core/SkRefCnt.h"           // nogncheck
 #endif
@@ -33,10 +33,10 @@ class UtilityBlinkPlatformWithSandboxSupportImpl : public blink::Platform {
   blink::WebSandboxSupport* GetSandboxSupport() override;
 
  private:
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_HAIKU)
   std::unique_ptr<blink::WebSandboxSupport> sandbox_support_;
 #endif
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   sk_sp<font_service::FontLoader> font_loader_;
 #endif
 
diff --git a/chromium/content/zygote/zygote_main_linux.cc b/chromium/content/zygote/zygote_main_linux.cc
index bbffdd4..5f3b018 100644
--- a/chromium/content/zygote/zygote_main_linux.cc
+++ b/chromium/content/zygote/zygote_main_linux.cc
@@ -11,7 +11,9 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
+#if !defined(OS_HAIKU)
 #include <sys/prctl.h>
+#endif
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -99,6 +101,7 @@ static bool CreateInitProcessReaper(
 // created through the setuid sandbox.
 static bool EnterSuidSandbox(sandbox::SetuidSandboxClient* setuid_sandbox,
                              base::OnceClosure post_fork_parent_callback) {
+#if !defined(OS_HAIKU)
   DCHECK(setuid_sandbox);
   DCHECK(setuid_sandbox->IsSuidSandboxChild());
 
@@ -131,6 +134,9 @@ static bool EnterSuidSandbox(sandbox::SetuidSandboxClient* setuid_sandbox,
 
   CHECK(sandbox::policy::SandboxDebugHandling::SetDumpableStatusAndHandlers());
   return true;
+#else
+  return false;
+#endif
 }
 
 static void DropAllCapabilities(int proc_fd) {
@@ -178,6 +184,7 @@ static void EnterLayerOneSandbox(sandbox::policy::SandboxLinux* linux_sandbox,
 
 bool ZygoteMain(
     std::vector<std::unique_ptr<ZygoteForkDelegate>> fork_delegates) {
+#if !defined(OS_HAIKU)
   sandbox::SetAmZygoteOrRenderer(true, GetSandboxFD());
 
   auto* linux_sandbox = sandbox::policy::SandboxLinux::GetInstance();
@@ -243,6 +250,9 @@ bool ZygoteMain(
 
   // This function call can return multiple times, once per fork().
   return zygote.ProcessRequests();
+#else
+  return false;
+#endif
 }
 
 }  // namespace content
diff --git a/chromium/device/bluetooth/BUILD.gn b/chromium/device/bluetooth/BUILD.gn
index 5f7d3f3..6e37cde 100644
--- a/chromium/device/bluetooth/BUILD.gn
+++ b/chromium/device/bluetooth/BUILD.gn
@@ -295,7 +295,7 @@ component("bluetooth") {
     ]
   }
 
-  if (is_chromeos || is_linux) {
+  if (is_chromeos || is_linux && !is_haiku) {
     if (use_dbus && is_chromeos) {
       # This crap uses ChromeOS specific system API
       sources += [
diff --git a/chromium/device/gamepad/gamepad_provider.cc b/chromium/device/gamepad/gamepad_provider.cc
index ecc5837..4aa6a6ff 100644
--- a/chromium/device/gamepad/gamepad_provider.cc
+++ b/chromium/device/gamepad/gamepad_provider.cc
@@ -149,7 +149,7 @@ void GamepadProvider::Initialize(std::unique_ptr<GamepadDataFetcher> fetcher) {
 
   if (!polling_thread_)
     polling_thread_.reset(new base::Thread("Gamepad polling thread"));
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // On Linux, the data fetcher needs to watch file descriptors, so the message
   // loop needs to be a libevent loop.
   const base::MessagePumpType kMessageLoopType = base::MessagePumpType::IO;
diff --git a/chromium/device/gamepad/hid_writer_linux.cc b/chromium/device/gamepad/hid_writer_linux.cc
index eb87897..77d4180 100644
--- a/chromium/device/gamepad/hid_writer_linux.cc
+++ b/chromium/device/gamepad/hid_writer_linux.cc
@@ -4,6 +4,8 @@
 
 #include "device/gamepad/hid_writer_linux.h"
 
+#include <unistd.h>
+
 #include "base/posix/eintr_wrapper.h"
 
 namespace device {
diff --git a/chromium/gpu/command_buffer/common/gpu_memory_buffer_support.cc b/chromium/gpu/command_buffer/common/gpu_memory_buffer_support.cc
index 388de9f..dc8efe6 100644
--- a/chromium/gpu/command_buffer/common/gpu_memory_buffer_support.cc
+++ b/chromium/gpu/command_buffer/common/gpu_memory_buffer_support.cc
@@ -57,7 +57,7 @@ uint32_t GetPlatformSpecificTextureTarget() {
   return macos_specific_texture_target;
 #elif defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
   return GL_TEXTURE_EXTERNAL_OES;
-#elif defined(OS_WIN) || defined(OS_FUCHSIA)
+#elif defined(OS_WIN) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
   return GL_TEXTURE_2D;
 #elif defined(OS_NACL)
   NOTREACHED();
@@ -85,7 +85,7 @@ GPU_EXPORT uint32_t GetBufferTextureTarget(gfx::BufferUsage usage,
 
 GPU_EXPORT bool NativeBufferNeedsPlatformSpecificTextureTarget(
     gfx::BufferFormat format) {
-#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Always use GL_TEXTURE_2D as the target for RGB textures.
   // https://crbug.com/916728
   if (format == gfx::BufferFormat::R_8 || format == gfx::BufferFormat::RG_88 ||
diff --git a/chromium/gpu/config/gpu_test_config.cc b/chromium/gpu/config/gpu_test_config.cc
index 49219e4..c7e860d 100644
--- a/chromium/gpu/config/gpu_test_config.cc
+++ b/chromium/gpu/config/gpu_test_config.cc
@@ -27,7 +27,7 @@ namespace {
 GPUTestConfig::OS GetCurrentOS() {
 #if defined(OS_CHROMEOS)
   return GPUTestConfig::kOsChromeOS;
-#elif defined(OS_LINUX) || defined(OS_OPENBSD)
+#elif defined(OS_LINUX) || defined(OS_HAIKU)
   return GPUTestConfig::kOsLinux;
 #elif defined(OS_WIN)
   int32_t major_version = 0;
diff --git a/chromium/gpu/ipc/common/gpu_memory_buffer_support.cc b/chromium/gpu/ipc/common/gpu_memory_buffer_support.cc
index 19c1f56..82ef91b 100644
--- a/chromium/gpu/ipc/common/gpu_memory_buffer_support.cc
+++ b/chromium/gpu/ipc/common/gpu_memory_buffer_support.cc
@@ -16,7 +16,7 @@
 #include "gpu/ipc/common/gpu_memory_buffer_impl_io_surface.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "ui/gfx/client_native_pixmap_factory.h"
 #include "ui/gfx/linux/client_native_pixmap_factory_dmabuf.h"
 #endif
@@ -26,7 +26,7 @@
 #include "ui/ozone/public/ozone_platform.h"
 #endif
 
-#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h"
 #endif
 
diff --git a/chromium/gpu/ipc/common/surface_handle.h b/chromium/gpu/ipc/common/surface_handle.h
index 64c4e12..b30c372 100644
--- a/chromium/gpu/ipc/common/surface_handle.h
+++ b/chromium/gpu/ipc/common/surface_handle.h
@@ -11,7 +11,7 @@
 
 #if (defined(OS_MAC) || defined(OS_WIN) || defined(USE_X11) || \
      defined(USE_OZONE)) &&                                      \
-    !defined(OS_NACL)
+    !defined(OS_NACL) && !defined(OS_HAIKU)
 #include "ui/gfx/native_widget_types.h"
 #define GPU_SURFACE_HANDLE_IS_ACCELERATED_WINDOW
 #endif
@@ -33,7 +33,8 @@ namespace gpu {
 #if defined(GPU_SURFACE_HANDLE_IS_ACCELERATED_WINDOW)
 using SurfaceHandle = gfx::AcceleratedWidget;
 constexpr SurfaceHandle kNullSurfaceHandle = gfx::kNullAcceleratedWidget;
-#elif defined(OS_ANDROID) || defined(OS_NACL) || defined(OS_FUCHSIA)
+#elif defined(OS_ANDROID) || defined(OS_NACL) || defined(OS_FUCHSIA) || \
+    defined(OS_HAIKU)
 using SurfaceHandle = int32_t;
 constexpr SurfaceHandle kNullSurfaceHandle = 0;
 #else
diff --git a/chromium/gpu/vulkan/features.gni b/chromium/gpu/vulkan/features.gni
index 7a98011..74a043d 100644
--- a/chromium/gpu/vulkan/features.gni
+++ b/chromium/gpu/vulkan/features.gni
@@ -8,7 +8,7 @@ import("//build/config/ui.gni")
 # For details see declare_args() in build/config/BUILDCONFIG.gn.
 declare_args() {
   # Enable experimental vulkan backend.
-  enable_vulkan = is_linux || is_chromeos || is_android || is_fuchsia || is_win
+  enable_vulkan = (is_linux && !is_haiku) || is_chromeos || is_android || is_fuchsia || is_win
 
   # Enable swiftshader vulkan. Disabling it can save build time, however
   # --use-vulkan=swiftshader and some tests which use swiftshader vulkan will
diff --git a/chromium/headless/BUILD.gn b/chromium/headless/BUILD.gn
index d2ab76a..fb3cfde 100644
--- a/chromium/headless/BUILD.gn
+++ b/chromium/headless/BUILD.gn
@@ -275,7 +275,7 @@ source_set("headless_shared_sources") {
   sources += generated_devtools_api
   sources += get_target_outputs(":protocol_sources")
 
-  if (!is_fuchsia) {
+  if (!is_fuchsia && !is_haiku) {
     sources += [
       "lib/headless_crash_reporter_client.cc",
       "lib/headless_crash_reporter_client.h",
@@ -295,7 +295,7 @@ source_set("headless_shared_sources") {
     "//url",
   ]
 
-  if (!is_fuchsia) {
+  if (!is_fuchsia && !is_haiku) {
     deps += [ "//components/crash/content/browser" ]
   }
   if (is_component_build && is_win) {
@@ -448,7 +448,7 @@ component("headless_non_renderer") {
       "//v8",
     ]
 
-    if (!is_fuchsia) {
+    if (!is_fuchsia && !is_haiku) {
       deps += [ "//components/crash/content/browser" ]
     }
     if (is_win) {
@@ -732,7 +732,7 @@ static_library("headless_shell_lib") {
     public_deps += [ ":headless_non_renderer" ]
   }
 
-  if (!is_fuchsia) {
+  if (!is_fuchsia && !is_haiku) {
     deps += [ "//components/crash/content/browser" ]
   }
 
diff --git a/chromium/ipc/ipc_channel.h b/chromium/ipc/ipc_channel.h
index 72e130e..4704cbc 100644
--- a/chromium/ipc/ipc_channel.h
+++ b/chromium/ipc/ipc_channel.h
@@ -245,7 +245,7 @@ class COMPONENT_EXPORT(IPC) Channel : public Sender {
   static std::string GenerateUniqueRandomChannelID();
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Sandboxed processes live in a PID namespace, so when sending the IPC hello
   // message from client to server we need to send the PID from the global
   // PID namespace.
diff --git a/chromium/ipc/ipc_channel_common.cc b/chromium/ipc/ipc_channel_common.cc
index 8990eee..db4cac4 100644
--- a/chromium/ipc/ipc_channel_common.cc
+++ b/chromium/ipc/ipc_channel_common.cc
@@ -10,7 +10,7 @@
 
 namespace IPC {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 namespace {
 int g_global_pid = 0;
@@ -26,7 +26,7 @@ int Channel::GetGlobalPid() {
   return g_global_pid;
 }
 
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 // static
 std::unique_ptr<Channel> Channel::CreateClient(
diff --git a/chromium/ipc/ipc_channel_mojo.cc b/chromium/ipc/ipc_channel_mojo.cc
index 798172a..74bb4d1 100644
--- a/chromium/ipc/ipc_channel_mojo.cc
+++ b/chromium/ipc/ipc_channel_mojo.cc
@@ -74,10 +74,10 @@ class MojoChannelFactory : public ChannelFactory {
 };
 
 base::ProcessId GetSelfPID() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (int global_pid = Channel::GetGlobalPid())
     return global_pid;
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #if defined(OS_NACL)
   return -1;
 #else
diff --git a/chromium/ipc/ipc_message_utils.cc b/chromium/ipc/ipc_message_utils.cc
index 54d49ec..46c9dea 100644
--- a/chromium/ipc/ipc_message_utils.cc
+++ b/chromium/ipc/ipc_message_utils.cc
@@ -357,7 +357,7 @@ void ParamTraits<unsigned int>::Log(const param_type& p, std::string* l) {
 }
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
+    defined(OS_FUCHSIA) || defined(OS_HAIKU) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 void ParamTraits<long>::Log(const param_type& p, std::string* l) {
   l->append(base::NumberToString(p));
 }
diff --git a/chromium/ipc/ipc_message_utils.h b/chromium/ipc/ipc_message_utils.h
index ad2596a..97f6415 100644
--- a/chromium/ipc/ipc_message_utils.h
+++ b/chromium/ipc/ipc_message_utils.h
@@ -210,7 +210,7 @@ struct ParamTraits<unsigned int> {
 // Since we want to support Android 32<>64 bit IPC, as long as we don't have
 // these traits for 32 bit ARM then that'll catch any errors.
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
+    defined(OS_FUCHSIA) || defined(OS_HAIKU) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 template <>
 struct ParamTraits<long> {
   typedef long param_type;
diff --git a/chromium/media/audio/BUILD.gn b/chromium/media/audio/BUILD.gn
index 63dce70..12b1c1c 100644
--- a/chromium/media/audio/BUILD.gn
+++ b/chromium/media/audio/BUILD.gn
@@ -234,7 +234,7 @@ source_set("audio") {
     ]
   }
 
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     sources += [ "linux/audio_manager_linux.cc" ]
   }
 
@@ -312,6 +312,21 @@ source_set("audio") {
     ]
   }
 
+  if (is_haiku) {
+    sources += [
+      "haiku/audio_input_stream_haiku.cc",
+      "haiku/audio_input_stream_haiku.h",
+      "haiku/audio_manager_haiku.cc",
+      "haiku/audio_manager_haiku.h",
+      "haiku/audio_output_stream_haiku.cc",
+      "haiku/audio_output_stream_haiku.h",
+    ]
+    libs += [
+      "be",
+      "media",
+    ]
+  }
+
   if (enable_webrtc) {
     sources += [
       "audio_input_stream_data_interceptor.cc",
diff --git a/chromium/media/audio/haiku/audio_input_stream_haiku.cc b/chromium/media/audio/haiku/audio_input_stream_haiku.cc
new file mode 100644
index 0000000..944023f
--- /dev/null
+++ b/chromium/media/audio/haiku/audio_input_stream_haiku.cc
@@ -0,0 +1,309 @@
+// Copyright 2021 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/haiku/audio_input_stream_haiku.h"
+
+#include "base/logging.h"
+#include "media/audio/audio_device_description.h"
+#include "media/audio/haiku/audio_manager_haiku.h"
+
+namespace media {
+	
+const int kNumberOfBlocksBufferInFifo = 2;
+
+HaikuAudioRecorder::HaikuAudioRecorder(const char *node_name)
+    : node_name_(node_name) {
+  if (node_name == NULL) {
+      node_name_.SetTo("QtWebEngine");
+      app_info appInfo;
+      if (be_app->GetAppInfo(&appInfo) == B_OK) {
+          BPath path(&appInfo.ref);
+          node_name_.SetTo(path.Leaf());
+      }
+  }
+  status_t error;
+  media_roster_ = BMediaRoster::Roster(&error);
+  if (error == B_OK)
+      is_inited_ = true;
+}
+
+HaikuAudioRecorder::~HaikuAudioRecorder() {
+  Close();
+}
+
+bool HaikuAudioRecorder::SetCallbacks(BMediaRecorder::ProcessFunc record_func,
+                                      BMediaRecorder::NotifyFunc notify_func, void* cookie) {
+  if (recorder_->SetHooks(record_func, notify_func, cookie) < B_OK) {
+      recorder_->SetHooks(NULL, NULL, NULL);
+      return false;
+  }
+  return true;
+}
+
+bool HaikuAudioRecorder::Open() {
+  if (!is_inited_ || is_opened_)
+      return false;
+
+  status_t error;
+
+  error = media_roster_->GetAudioInput(&audio_input_node_);
+  if (error < B_OK)
+      return false;
+
+  error = media_roster_->GetAudioMixer(&audio_mixer_node_);
+  if (error < B_OK)
+      return false;
+
+  recorder_ = new BMediaRecorder(node_name_, B_MEDIA_RAW_AUDIO);
+  if (recorder_->InitCheck() < B_OK) {
+      delete recorder_;
+      recorder_ = nullptr;
+      return false;
+  }
+
+  media_format output_format;
+  output_format.type = B_MEDIA_RAW_AUDIO;
+  output_format.u.raw_audio = media_raw_audio_format::wildcard;
+  recorder_->SetAcceptedFormat(output_format);
+
+  const int maxInputCount = 64;
+  dormant_node_info dni[maxInputCount];
+
+  int32 real_count = maxInputCount;
+
+  error = media_roster_->GetDormantNodes(dni, &real_count, 0, &output_format,
+                                         0, B_BUFFER_PRODUCER | B_PHYSICAL_INPUT);
+  if (real_count > maxInputCount)
+      real_count = maxInputCount;
+  char selected_name[B_MEDIA_NAME_LENGTH] = "Default input";
+
+  for (int i = 0; i < real_count; i++) {
+      media_node_id ni[12];
+      int32 ni_count = 12;
+      error = media_roster_->GetInstancesFor(dni[i].addon, dni[i].flavor_id, ni, &ni_count);
+      if (error == B_OK) {
+           for (int j = 0; j < ni_count; j++) {
+               if (ni[j] == audio_input_node_.node) {
+                   strcpy(selected_name, dni[i].name);
+                   break;
+               }
+           }
+      }
+  }
+  
+  if (!recorder_->IsConnected()) {
+      int32 count = 0;
+      error = media_roster_->GetFreeOutputsFor(audio_input_node_,
+                                               &audio_output_, 1, &count, B_MEDIA_RAW_AUDIO);
+      if (error < B_OK || count < 1) {
+          delete recorder_;
+          recorder_ = nullptr;
+          return false;
+      }
+
+      record_format_.u.raw_audio = audio_output_.format.u.raw_audio;
+  } else {
+      record_format_.u.raw_audio = recorder_->AcceptedFormat().u.raw_audio;
+  }
+
+  record_format_.type = B_MEDIA_RAW_AUDIO;
+
+  is_opened_ = true;
+
+  return true;
+}
+
+void HaikuAudioRecorder::Close() {
+  if (!is_opened_)
+      return;
+  is_opened_ = false;
+
+  if (is_recording_)
+      Stop();
+
+  if (recorder_)
+      delete recorder_;
+
+  recorder_ = nullptr;
+}
+
+void HaikuAudioRecorder::Start() {
+  if (recorder_ == NULL || !is_inited_ || is_recording_)
+      return;
+
+  if (!recorder_->IsConnected()) {
+      if (recorder_->Connect(audio_input_node_, &audio_output_, &record_format_) < B_OK) {
+           recorder_->SetHooks(NULL, NULL, NULL);
+           return;
+      }
+  }
+
+  is_recording_ = true;
+  recorder_->Start();
+}
+
+void HaikuAudioRecorder::Stop() {
+  is_recording_ = false;
+
+  if (recorder_->IsConnected())
+      recorder_->Disconnect();
+
+  recorder_->Stop();
+}
+
+base::TimeDelta HaikuAudioRecorder::Latency() {
+  bigtime_t latency;
+  if (media_roster_->GetLatencyFor(audio_input_node_, &latency) == B_OK && is_recording_)
+      return base::TimeDelta::FromMicroseconds(latency);
+  return base::TimeDelta::FromMicroseconds(0);
+}
+
+SampleFormat HaikuAudioRecorder::Format() {
+  SampleFormat sample_format = kUnknownSampleFormat;
+
+  switch(record_format_.u.raw_audio.format) {
+      case media_raw_audio_format::B_AUDIO_UCHAR:
+          sample_format = kSampleFormatU8;
+          break;
+      case media_raw_audio_format::B_AUDIO_SHORT:
+          sample_format = kSampleFormatS16;
+          break;
+      case media_raw_audio_format::B_AUDIO_INT:
+          sample_format = kSampleFormatS32;
+          break;
+      case media_raw_audio_format::B_AUDIO_FLOAT:
+          sample_format = kSampleFormatF32;
+          break;
+  }
+  return sample_format;
+}
+
+ChannelLayout HaikuAudioRecorder::Channels() {
+  ChannelLayout layout = CHANNEL_LAYOUT_UNSUPPORTED;
+  
+  switch(record_format_.u.raw_audio.channel_count) {
+      case 1:
+          layout = CHANNEL_LAYOUT_MONO;
+          break;
+      case 2:
+          layout = CHANNEL_LAYOUT_STEREO;
+          break;
+  }
+
+  return layout;
+}
+
+
+AudioInputStreamHaiku::AudioInputStreamHaiku(
+    AudioManagerHaiku* manager,
+    const AudioParameters& parameters)
+    : manager_(manager),
+      parameters_(parameters),
+      recorder_(new HaikuAudioRecorder()),
+      callback_(nullptr),
+      fifo_(parameters.channels(),
+            parameters.frames_per_buffer(),
+            kNumberOfBlocksBufferInFifo),
+      audio_bus_(media::AudioBus::Create(parameters)) {
+}
+
+AudioInputStreamHaiku::~AudioInputStreamHaiku() {
+	delete recorder_;
+}
+
+bool AudioInputStreamHaiku::Open() {
+  return recorder_->Open();
+}
+
+void AudioInputStreamHaiku::Start(AudioInputCallback* callback) {
+  callback_ = callback;
+  if (!recorder_->IsOpened() || recorder_->IsRecording())
+      return;
+
+  if (!recorder_->SetCallbacks(_read_callback, NULL, this)) {
+      recorder_->Close();
+      return;
+  }
+
+  StartAgc();
+  recorder_->Start();
+}
+
+void AudioInputStreamHaiku::Stop() {
+  StopAgc();
+  recorder_->Stop();
+  fifo_.Clear();
+}
+
+void AudioInputStreamHaiku::Close() {
+  recorder_->Close();
+  manager_->ReleaseInputStream(this);
+}
+
+double AudioInputStreamHaiku::GetMaxVolume() {
+  return 1.0;
+}
+
+void AudioInputStreamHaiku::SetVolume(double volume) {
+  UpdateAgcVolume();
+}
+
+double AudioInputStreamHaiku::GetVolume() {
+  return 1.0;
+}
+
+bool AudioInputStreamHaiku::SetAutomaticGainControl(bool enabled) {
+  return false;
+}
+
+bool AudioInputStreamHaiku::GetAutomaticGainControl() {
+  return false;
+}
+
+bool AudioInputStreamHaiku::IsMuted() {
+  return false;
+}
+
+void AudioInputStreamHaiku::SetOutputDeviceForAec(
+    const std::string& output_device_id) {
+}
+
+void AudioInputStreamHaiku::ReadCallback(void* buffer, size_t size,
+                                         const media_format &format) noexcept
+{
+  double normalized_volume = 0.0;
+  GetAgcVolume(&normalized_volume);
+
+  SampleFormat sample_format = recorder_->Format();
+
+  base::TimeTicks capture_time =
+      base::TimeTicks::Now() - (recorder_->Latency() +
+      AudioTimestampHelper::FramesToTime(fifo_.GetAvailableFrames(),
+      parameters_.sample_rate()));
+
+  const int number_of_frames = size / parameters_.GetBytesPerFrame(sample_format);
+
+  if (number_of_frames > fifo_.GetUnfilledFrames()) {
+      const int increase_blocks_of_buffer =
+          static_cast<int>((number_of_frames - fifo_.GetUnfilledFrames()) /
+                           parameters_.frames_per_buffer()) + 1;
+      fifo_.IncreaseCapacity(increase_blocks_of_buffer);
+  }
+
+  fifo_.Push(buffer, number_of_frames, SampleFormatToBytesPerChannel(sample_format));
+
+  while (fifo_.available_blocks()) {
+    const AudioBus* audio_bus = fifo_.Consume();
+
+    callback_->OnData(audio_bus, capture_time, normalized_volume);
+
+    capture_time += AudioTimestampHelper::FramesToTime(audio_bus->frames(),
+                                                       parameters_.sample_rate());
+
+    if (fifo_.available_blocks())
+      base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(5));
+  }
+}
+
+}  // namespace media
diff --git a/chromium/media/audio/haiku/audio_input_stream_haiku.h b/chromium/media/audio/haiku/audio_input_stream_haiku.h
new file mode 100644
index 0000000..2cd96dc
--- /dev/null
+++ b/chromium/media/audio/haiku/audio_input_stream_haiku.h
@@ -0,0 +1,112 @@
+// Copyright 2021 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_HAIKU_AUDIO_INPUT_STREAM_HAIKU_H_
+#define MEDIA_AUDIO_HAIKU_AUDIO_INPUT_STREAM_HAIKU_H_
+
+#include "media/audio/audio_io.h"
+#include "media/audio/agc_audio_stream.h"
+#include "media/base/audio_block_fifo.h"
+#include "media/base/audio_parameters.h"
+#include "media/base/audio_timestamp_helper.h"
+
+#include <OS.h>
+#include <Path.h>
+#include <Roster.h>
+#include <String.h>
+#include <Application.h>
+#include <MediaAddOn.h>
+#include <MediaFile.h>
+#include <MediaNode.h>
+#include <MediaRecorder.h>
+#include <MediaRoster.h>
+#include <MediaTrack.h>
+#include <TimeSource.h>
+#include <NodeInfo.h>
+
+namespace media {
+
+class AudioManagerHaiku;
+
+class HaikuAudioRecorder {
+public:
+  HaikuAudioRecorder(const char *node_name = NULL);
+  ~HaikuAudioRecorder();
+
+  bool SetCallbacks(BMediaRecorder::ProcessFunc recordFunc = NULL,
+                    BMediaRecorder::NotifyFunc notifyFunc = NULL,
+                    void* cookie = NULL);
+
+  bool Open();
+  void Close();
+  void Start();
+  void Stop();
+
+  base::TimeDelta Latency();
+  BMediaRoster *MediaRoster() { return media_roster_; }
+
+  SampleFormat Format();
+  ChannelLayout Channels();
+  int SampleRate() { return static_cast<int>(record_format_.u.raw_audio.frame_rate); }
+
+  bool IsOpened() { return is_opened_; }
+  bool IsRecording() { return is_recording_; }
+  bool InitCheck() { return is_inited_; }
+
+private:
+  BString node_name_;
+
+  BMediaRoster *media_roster_{0u};
+  BMediaRecorder *recorder_{0u};
+
+  media_format record_format_;
+  media_node audio_input_node_;
+  media_node audio_mixer_node_;
+  media_output audio_output_;
+
+  bool is_inited_{false};
+  bool is_opened_{false};
+  bool is_recording_{false};
+};
+
+
+class AudioInputStreamHaiku : public AgcAudioStream<AudioInputStream> {
+ public:
+  AudioInputStreamHaiku(AudioManagerHaiku* manager,
+                          const AudioParameters& parameters);
+  ~AudioInputStreamHaiku() override;
+
+  bool Open() override;
+  void Start(AudioInputCallback* callback) override;
+  void Stop() override;
+  void Close() override;
+  double GetMaxVolume() override;
+  void SetVolume(double volume) override;
+  double GetVolume() override;
+  bool SetAutomaticGainControl(bool enabled) override;
+  bool GetAutomaticGainControl() override;
+  bool IsMuted() override;
+  void SetOutputDeviceForAec(const std::string& output_device_id) override;
+
+  void ReadCallback(void* data, size_t size, const media_format &format) noexcept;
+
+ private:
+  static void _read_callback(void* cookie, bigtime_t, void* data, size_t size, const media_format &format) noexcept {
+      return static_cast<AudioInputStreamHaiku*>(cookie)->ReadCallback(data, size, format);
+  }
+
+  AudioManagerHaiku* const manager_;
+  AudioParameters parameters_;
+  HaikuAudioRecorder* recorder_;
+  AudioInputCallback* callback_;
+  AudioBlockFifo fifo_;
+
+  std::unique_ptr<AudioBus> audio_bus_;
+
+  DISALLOW_COPY_AND_ASSIGN(AudioInputStreamHaiku);
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_HAIKU_AUDIO_INPUT_STREAM_HAIKU_H_
diff --git a/chromium/media/audio/haiku/audio_manager_haiku.cc b/chromium/media/audio/haiku/audio_manager_haiku.cc
new file mode 100644
index 0000000..186319c
--- /dev/null
+++ b/chromium/media/audio/haiku/audio_manager_haiku.cc
@@ -0,0 +1,103 @@
+// Copyright 2021 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/haiku/audio_manager_haiku.h"
+
+#include <memory>
+
+#include "media/audio/haiku/audio_input_stream_haiku.h"
+#include "media/audio/haiku/audio_output_stream_haiku.h"
+
+namespace media {
+
+AudioManagerHaiku::AudioManagerHaiku(
+    std::unique_ptr<AudioThread> audio_thread,
+    AudioLogFactory* audio_log_factory)
+    : AudioManagerBase(std::move(audio_thread), audio_log_factory) {}
+
+AudioManagerHaiku::~AudioManagerHaiku() = default;
+
+bool AudioManagerHaiku::HasAudioOutputDevices() {
+  return true;
+}
+
+bool AudioManagerHaiku::HasAudioInputDevices() {
+  return true;
+}
+
+void AudioManagerHaiku::GetAudioInputDeviceNames(
+    AudioDeviceNames* device_names) {
+  *device_names = {AudioDeviceName::CreateDefault()};
+}
+
+void AudioManagerHaiku::GetAudioOutputDeviceNames(
+    AudioDeviceNames* device_names) {
+  *device_names = {AudioDeviceName::CreateDefault()};
+}
+
+AudioParameters AudioManagerHaiku::GetInputStreamParameters(
+    const std::string& device_id) {
+  HaikuAudioRecorder recorder;
+  if (recorder.Open()) {
+      AudioParameters params(AudioParameters::AUDIO_PCM_LOW_LATENCY,
+                             recorder.Channels(), recorder.SampleRate(),
+                             recorder.SampleRate() / 100);
+      params.set_effects(AudioParameters::NO_EFFECTS);
+      return params;
+  }
+
+  return AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
+                         CHANNEL_LAYOUT_STEREO, 48000, 480);
+}
+
+AudioParameters AudioManagerHaiku::GetPreferredOutputStreamParameters(
+    const std::string& output_device_id,
+    const AudioParameters& input_params) {
+  return AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
+                         CHANNEL_LAYOUT_STEREO, 48000, 480);
+}
+
+const char* AudioManagerHaiku::GetName() {
+  return "Haiku";
+}
+
+AudioOutputStream* AudioManagerHaiku::MakeLinearOutputStream(
+    const AudioParameters& params,
+    const LogCallback& log_callback) {
+  DCHECK_EQ(AudioParameters::AUDIO_PCM_LINEAR, params.format());
+  return new AudioOutputStreamHaiku(this, params);
+}
+
+AudioOutputStream* AudioManagerHaiku::MakeLowLatencyOutputStream(
+    const AudioParameters& params,
+    const std::string& device_id,
+    const LogCallback& log_callback) {
+  DCHECK_EQ(AudioParameters::AUDIO_PCM_LOW_LATENCY, params.format());
+  return new AudioOutputStreamHaiku(this, params);
+}
+
+AudioInputStream* AudioManagerHaiku::MakeLinearInputStream(
+    const AudioParameters& params,
+    const std::string& device_id,
+    const LogCallback& log_callback) {
+  DCHECK_EQ(AudioParameters::AUDIO_PCM_LINEAR, params.format());
+  return new AudioInputStreamHaiku(this, params);
+}
+
+AudioInputStream* AudioManagerHaiku::MakeLowLatencyInputStream(
+    const AudioParameters& params,
+    const std::string& device_id,
+    const LogCallback& log_callback) {
+  DCHECK_EQ(AudioParameters::AUDIO_PCM_LOW_LATENCY, params.format());
+  return new AudioInputStreamHaiku(this, params);
+}
+
+std::unique_ptr<AudioManager> CreateAudioManager(
+    std::unique_ptr<AudioThread> audio_thread,
+    AudioLogFactory* audio_log_factory) {
+  return std::make_unique<AudioManagerHaiku>(std::move(audio_thread),
+                                               audio_log_factory);
+}
+
+}  // namespace media
diff --git a/chromium/media/audio/haiku/audio_manager_haiku.h b/chromium/media/audio/haiku/audio_manager_haiku.h
new file mode 100644
index 0000000..2a3eba9
--- /dev/null
+++ b/chromium/media/audio/haiku/audio_manager_haiku.h
@@ -0,0 +1,55 @@
+// Copyright 2021 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_HAIKU_AUDIO_MANAGER_HAIKU_H_
+#define MEDIA_AUDIO_HAIKU_AUDIO_MANAGER_HAIKU_H_
+
+#include "media/audio/audio_manager_base.h"
+
+namespace media {
+
+class AudioManagerHaiku : public AudioManagerBase {
+ public:
+  AudioManagerHaiku(std::unique_ptr<AudioThread> audio_thread,
+                      AudioLogFactory* audio_log_factory);
+  ~AudioManagerHaiku() override;
+
+  // Implementation of AudioManager.
+  bool HasAudioOutputDevices() override;
+  bool HasAudioInputDevices() override;
+  void GetAudioInputDeviceNames(AudioDeviceNames* device_names) override;
+  void GetAudioOutputDeviceNames(AudioDeviceNames* device_names) override;
+  AudioParameters GetInputStreamParameters(
+      const std::string& device_id) override;
+  const char* GetName() override;
+
+  // Implementation of AudioManagerBase.
+  AudioOutputStream* MakeLinearOutputStream(
+      const AudioParameters& params,
+      const LogCallback& log_callback) override;
+  AudioOutputStream* MakeLowLatencyOutputStream(
+      const AudioParameters& params,
+      const std::string& device_id,
+      const LogCallback& log_callback) override;
+  AudioInputStream* MakeLinearInputStream(
+      const AudioParameters& params,
+      const std::string& device_id,
+      const LogCallback& log_callback) override;
+  AudioInputStream* MakeLowLatencyInputStream(
+      const AudioParameters& params,
+      const std::string& device_id,
+      const LogCallback& log_callback) override;
+
+ protected:
+  AudioParameters GetPreferredOutputStreamParameters(
+      const std::string& output_device_id,
+      const AudioParameters& input_params) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(AudioManagerHaiku);
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_HAIKU_AUDIO_MANAGER_HAIKU_H_
diff --git a/chromium/media/audio/haiku/audio_output_stream_haiku.cc b/chromium/media/audio/haiku/audio_output_stream_haiku.cc
new file mode 100644
index 0000000..c4e3c97
--- /dev/null
+++ b/chromium/media/audio/haiku/audio_output_stream_haiku.cc
@@ -0,0 +1,94 @@
+// Copyright 2021 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/haiku/audio_output_stream_haiku.h"
+
+#include "base/bind.h"
+#include "base/memory/writable_shared_memory_region.h"
+#include "media/audio/haiku/audio_manager_haiku.h"
+#include "media/base/audio_sample_types.h"
+#include "media/base/audio_timestamp_helper.h"
+
+namespace media {
+
+AudioOutputStreamHaiku::AudioOutputStreamHaiku(
+    AudioManagerHaiku* manager,
+    const AudioParameters& parameters)
+    : manager_(manager),
+      parameters_(parameters),
+      player_(NULL),
+      audio_bus_(AudioBus::Create(parameters)) {
+  process_name_.SetTo("QtWebEngine");
+  app_info appInfo;
+  if (be_app->GetAppInfo(&appInfo) == B_OK) {
+      BPath path(&appInfo.ref);
+      process_name_.SetTo(path.Leaf());
+  }
+}
+
+AudioOutputStreamHaiku::~AudioOutputStreamHaiku() {}
+
+bool AudioOutputStreamHaiku::Open() {
+  media_raw_audio_format format;
+  format = {
+      parameters_.sample_rate(),
+      parameters_.channels(),
+      media_raw_audio_format::B_AUDIO_FLOAT,
+      B_MEDIA_LITTLE_ENDIAN,
+      parameters_.GetBytesPerBuffer(kSampleFormatF32)
+  };
+
+  player_ = new BSoundPlayer(&format, process_name_.String(), audio_callback,
+      NULL, static_cast<void*>(this));
+
+  return true;
+}
+
+void AudioOutputStreamHaiku::Start(AudioSourceCallback* callback) {
+  DCHECK(!callback_);
+  callback_ = callback;
+
+  player_->Start();
+  player_->SetHasData(true);
+}
+
+void AudioOutputStreamHaiku::Stop() {
+  callback_ = nullptr;
+
+  player_->SetHasData(false);
+  player_->Stop();
+}
+
+void AudioOutputStreamHaiku::Flush() {}
+
+void AudioOutputStreamHaiku::SetVolume(double volume) {
+  DCHECK(0.0 <= volume && volume <= 1.0) << volume;
+  player_->SetVolume(volume);
+}
+
+void AudioOutputStreamHaiku::GetVolume(double* volume) {
+  *volume = player_->Volume();
+}
+
+void AudioOutputStreamHaiku::Close() {
+  Stop();
+
+  delete player_;
+
+  manager_->ReleaseOutputStream(this);
+}
+
+void AudioOutputStreamHaiku::AudioCallback(void *stream, size_t len) noexcept
+{
+  int frames_filled = callback_->OnMoreData(base::TimeDelta::FromMicroseconds(0), base::TimeTicks::Now(), 0, audio_bus_.get());
+  if (frames_filled <= 0) {
+  	memset(stream, 0, len);
+    return;
+  }
+
+  audio_bus_->ToInterleaved<Float32SampleTypeTraitsNoClip>(
+      frames_filled, reinterpret_cast<float*>(stream));
+}
+
+}  // namespace media
diff --git a/chromium/media/audio/haiku/audio_output_stream_haiku.h b/chromium/media/audio/haiku/audio_output_stream_haiku.h
new file mode 100644
index 0000000..0e97029
--- /dev/null
+++ b/chromium/media/audio/haiku/audio_output_stream_haiku.h
@@ -0,0 +1,64 @@
+// Copyright 2021 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_HAIKU_AUDIO_OUTPUT_STREAM_HAIKU_H_
+#define MEDIA_AUDIO_HAIKU_AUDIO_OUTPUT_STREAM_HAIKU_H_
+
+#include <OS.h>
+#include <Application.h>
+#include <SoundPlayer.h>
+#include <Roster.h>
+#include <String.h>
+#include <NodeInfo.h>
+#include <Path.h>
+
+#include "base/memory/shared_memory_mapping.h"
+#include "base/optional.h"
+#include "base/timer/timer.h"
+#include "media/audio/audio_io.h"
+#include "media/base/audio_parameters.h"
+
+namespace media {
+
+class AudioManagerHaiku;
+
+class AudioOutputStreamHaiku : public AudioOutputStream {
+ public:
+  // Caller must ensure that manager outlives the stream.
+  AudioOutputStreamHaiku(AudioManagerHaiku* manager,
+                           const AudioParameters& parameters);
+
+  // AudioOutputStream interface.
+  bool Open() override;
+  void Start(AudioSourceCallback* callback) override;
+  void Stop() override;
+  void Flush() override;
+  void SetVolume(double volume) override;
+  void GetVolume(double* volume) override;
+  void Close() override;
+
+ private:
+  ~AudioOutputStreamHaiku() override;
+
+  AudioManagerHaiku* manager_;
+  AudioParameters parameters_;
+
+  BSoundPlayer *player_;
+  BString process_name_;
+
+  std::unique_ptr<AudioBus> audio_bus_;
+
+  void AudioCallback(void *stream, size_t len) noexcept;
+  static void audio_callback(void *cookie, void *buffer, size_t len, const media_raw_audio_format &) noexcept {
+       static_cast<AudioOutputStreamHaiku*>(cookie)->AudioCallback(buffer, len);
+  }
+
+  AudioSourceCallback* callback_ = nullptr;
+
+  DISALLOW_COPY_AND_ASSIGN(AudioOutputStreamHaiku);
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_HAIKU_AUDIO_OUTPUT_STREAM_HAIKU_H_
diff --git a/chromium/media/base/scopedfd_helper.h b/chromium/media/base/scopedfd_helper.h
index 5cc8086..295586e 100644
--- a/chromium/media/base/scopedfd_helper.h
+++ b/chromium/media/base/scopedfd_helper.h
@@ -14,14 +14,14 @@ namespace media {
 // since the only current user is V4L2 we are limiting the scope to OS_LINUX so
 // the binary size does not inflate on non-using systems. Feel free to adapt
 // this and BUILD.gn as our needs evolve.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 // Return a new vector containing duplicates of |fds|, or PCHECKs in case of an
 // error.
 MEDIA_EXPORT std::vector<base::ScopedFD> DuplicateFDs(
     const std::vector<base::ScopedFD>& fds);
 
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 }  // namespace media
 
diff --git a/chromium/media/capture/BUILD.gn b/chromium/media/capture/BUILD.gn
index c9986f3..ad19c64 100644
--- a/chromium/media/capture/BUILD.gn
+++ b/chromium/media/capture/BUILD.gn
@@ -250,7 +250,7 @@ jumbo_component("capture_lib") {
   # This includes the case of ChromeOS
   # TODO: As we move to separately version Chrome from ChromeOS, we may need to split
   # these sources into linux, chromeos, and common.
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     sources += [
       "video/linux/camera_config_chromeos.cc",
       "video/linux/camera_config_chromeos.h",
@@ -345,6 +345,20 @@ jumbo_component("capture_lib") {
       "//third_party/libyuv",
     ]
   }
+
+  if (is_haiku) {
+    sources += [
+      "video/haiku/video_capture_device_factory_haiku.cc",
+      "video/haiku/video_capture_device_factory_haiku.h",
+      "video/haiku/video_capture_device_consumer_haiku.cc",
+      "video/haiku/video_capture_device_consumer_haiku.h",
+      "video/haiku/video_capture_device_haiku.cc",
+      "video/haiku/video_capture_device_haiku.h",
+    ]
+    libs = [
+      "media",
+    ]
+  }
 }
 
 source_set("test_support") {
diff --git a/chromium/media/capture/video/create_video_capture_device_factory.cc b/chromium/media/capture/video/create_video_capture_device_factory.cc
index 8d0f977..5d6e232 100644
--- a/chromium/media/capture/video/create_video_capture_device_factory.cc
+++ b/chromium/media/capture/video/create_video_capture_device_factory.cc
@@ -25,6 +25,8 @@
 #include "media/capture/video/android/video_capture_device_factory_android.h"
 #elif defined(OS_FUCHSIA)
 #include "media/capture/video/fuchsia/video_capture_device_factory_fuchsia.h"
+#elif defined(OS_HAIKU)
+#include "media/capture/video/haiku/video_capture_device_factory_haiku.h"
 #endif
 
 namespace media {
@@ -94,6 +96,8 @@ CreatePlatformSpecificVideoCaptureDeviceFactory(
   return std::make_unique<VideoCaptureDeviceFactoryAndroid>();
 #elif defined(OS_FUCHSIA)
   return std::make_unique<VideoCaptureDeviceFactoryFuchsia>();
+#elif defined(OS_HAIKU)
+  return std::make_unique<VideoCaptureDeviceFactoryHaiku>();
 #else
   NOTIMPLEMENTED();
   return nullptr;
diff --git a/chromium/media/capture/video/fake_video_capture_device_factory.cc b/chromium/media/capture/video/fake_video_capture_device_factory.cc
index b96840f..6233375 100644
--- a/chromium/media/capture/video/fake_video_capture_device_factory.cc
+++ b/chromium/media/capture/video/fake_video_capture_device_factory.cc
@@ -218,6 +218,8 @@ void FakeVideoCaptureDeviceFactory::GetDevicesInfo(
         VideoCaptureApi::ANDROID_API2_LEGACY;
 #elif defined(OS_FUCHSIA)
         VideoCaptureApi::FUCHSIA_CAMERA3;
+#elif defined(OS_HAIKU)
+        VideoCaptureApi::HAIKU_MEDIAKIT;
 #else
 #error Unsupported platform
 #endif
diff --git a/chromium/media/capture/video/file_video_capture_device_factory.cc b/chromium/media/capture/video/file_video_capture_device_factory.cc
index d899c50..9417271 100644
--- a/chromium/media/capture/video/file_video_capture_device_factory.cc
+++ b/chromium/media/capture/video/file_video_capture_device_factory.cc
@@ -54,6 +54,8 @@ void FileVideoCaptureDeviceFactory::GetDevicesInfo(
       VideoCaptureApi::MACOSX_AVFOUNDATION;
 #elif defined(OS_LINUX) || defined(OS_CHROMEOS)
       VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
+#elif defined(OS_HAIKU)
+      VideoCaptureApi::HAIKU_MEDIAKIT;
 #else
       VideoCaptureApi::UNKNOWN;
 #endif
diff --git a/chromium/media/capture/video/haiku/video_capture_device_consumer_haiku.cc b/chromium/media/capture/video/haiku/video_capture_device_consumer_haiku.cc
new file mode 100644
index 0000000..8419d99
--- /dev/null
+++ b/chromium/media/capture/video/haiku/video_capture_device_consumer_haiku.cc
@@ -0,0 +1,485 @@
+// Copyright 2021-2023 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <Buffer.h>
+#include <BufferGroup.h>
+#include <NodeInfo.h>
+#include <Bitmap.h>
+#include <View.h>
+#include <scheduler.h>
+#include <TimeSource.h>
+#include <MediaRoster.h>
+
+#include "video_capture_device_consumer_haiku.h"
+
+namespace media {
+
+VideoConsumer::VideoConsumer(const char* name, BMediaAddOn* addon,
+		const uint32 internal_id)
+	: BMediaNode(name),
+	  BMediaEventLooper(),
+	  BBufferConsumer(B_MEDIA_RAW_VIDEO),
+	  fInternalID(internal_id),
+	  fAddOn(addon),
+	  fConnectionActive(false),
+	  fMyLatency(3000),
+	  fOurBuffers(false),
+	  fBuffers(NULL),
+	  fLastBufferIndex(-1)
+{
+	printf("VideoConsumer::VideoConsumer\n");
+	AddNodeKind(B_PHYSICAL_OUTPUT);
+	SetEventLatency(0);
+
+	for (uint32 i = 0; i < kBufferCount; i++) {
+		fBitmap[i] = NULL;
+		fBufferMap[i] = NULL;
+	}
+
+	SetPriority(B_DISPLAY_PRIORITY);
+}
+
+
+VideoConsumer::~VideoConsumer()
+{
+	Quit();
+	DeleteBuffers();
+}
+
+
+void
+VideoConsumer::SetClient(std::unique_ptr<VideoCaptureDevice::Client> client)
+{
+	printf("VideoConsumer::SetClient\n");
+	client_ = std::move(client);
+}
+
+
+BMediaAddOn*
+VideoConsumer::AddOn(int32* cookie) const
+{
+	*cookie = fInternalID;
+	return fAddOn;
+}
+
+
+void
+VideoConsumer::NodeRegistered()
+{
+	printf("VideoConsumer::NodeRegistered\n");
+	fIn.destination.port = ControlPort();
+	fIn.destination.id = 0;
+	fIn.source = media_source::null;
+	fIn.format.type = B_MEDIA_RAW_VIDEO;
+	// wild cards yet
+	fIn.format.u.raw_video = media_raw_video_format::wildcard;
+	fIn.format.u.raw_video.interlace = 1;
+	fIn.format.u.raw_video.display.format = B_NO_COLOR_SPACE;
+	fIn.format.u.raw_video.display.bytes_per_row = 0;
+	fIn.format.u.raw_video.display.line_width = 0;
+	fIn.format.u.raw_video.display.line_count = 0;
+	printf("VideoConsumer::NodeRegistered: Run\n");
+	//Run();
+}
+
+
+status_t
+VideoConsumer::RequestCompleted(const media_request_info& info)
+{
+	switch(info.what) {
+		case media_request_info::B_SET_OUTPUT_BUFFERS_FOR:
+			if (info.status != B_OK)
+				fprintf(stderr, "VideoConsumer::RequestCompleted: Not using our buffers!\n");
+			break;
+		default:
+			break;
+	}
+	return B_OK;
+}
+
+
+status_t
+VideoConsumer::HandleMessage(int32 message, const void* data, size_t size)
+{
+	return B_OK;
+}
+
+
+void
+VideoConsumer::BufferReceived(BBuffer* buffer)
+{
+	if (RunState() == B_STOPPED) {		
+		buffer->Recycle();
+		return;
+	}
+	media_timed_event event(buffer->Header()->start_time,
+		BTimedEventQueue::B_HANDLE_BUFFER, buffer,
+		BTimedEventQueue::B_RECYCLE_BUFFER);
+	EventQueue()->AddEvent(event);
+}
+
+
+void
+VideoConsumer::ProducerDataStatus(const media_destination& forWhom,
+	int32 status, bigtime_t atMediaTime)
+{
+	if (forWhom != fIn.destination)
+		return;
+}
+
+
+status_t
+VideoConsumer::CreateBuffers(const media_format& format)
+{
+	DeleteBuffers();	
+
+	status_t status = B_OK;
+
+	uint32 width = format.u.raw_video.display.line_width;
+	uint32 height = format.u.raw_video.display.line_count;	
+	color_space colorSpace = format.u.raw_video.display.format;
+
+	fBuffers = new BBufferGroup();
+	status = fBuffers->InitCheck();
+	if (B_OK != status)
+		return status;
+
+	BRect bounds(0, 0, width - 1, height - 1);
+	for (uint32 i = 0; i < kBufferCount; i++) {
+		uint32 bitmapFlags = 0;
+		bitmapFlags = B_BITMAP_IS_LOCKED;
+			
+		fBitmap[i] = new BBitmap(bounds, bitmapFlags, colorSpace);
+		status = fBitmap[i]->InitCheck();
+		if (status >= B_OK) {
+			buffer_clone_info info;
+
+			uint8* bits = (uint8*)fBitmap[i]->Bits();
+			info.area = area_for(bits);
+			area_info bitmapAreaInfo;
+			status = get_area_info(info.area, &bitmapAreaInfo);
+			if (status != B_OK) {
+				fprintf(stderr, "VideoConsumer::CreateBuffers() - "
+					"get_area_info(): %s\n", strerror(status));
+				return status;
+			}
+
+			info.offset = bits - (uint8*)bitmapAreaInfo.address;
+			info.size = (size_t)fBitmap[i]->BitsLength();
+			info.flags = 0;
+			info.buffer = 0;
+
+			BBuffer* buffer = NULL;
+			if ((status = fBuffers->AddBuffer(info, &buffer)) != B_OK) {
+				fprintf(stderr, "VideoConsumer::CreateBuffers - ERROR ADDING BUFFER "
+					"TO GROUP (%" B_PRId32 "): %s\n", i, strerror(status));
+				return status;
+			}
+			fBufferMap[i] = buffer;
+		} else {
+			fprintf(stderr, "VideoConsumer::CreateBuffers - ERROR CREATING VIDEO RING "
+				"BUFFER (Index %" B_PRId32 " Width %" B_PRId32 " Height %"
+				B_PRId32 " Colorspace %d: %s\n", i, width, height, colorSpace,
+				strerror(status));
+			return status;
+		}
+	}
+
+	return status;
+}
+
+
+void
+VideoConsumer::DeleteBuffers()
+{
+	if (fBuffers) {
+		fTargetLock.Lock();
+		if (fLastBufferIndex >= 0) {
+			fLastBufferIndex = -1;
+		}
+		fTargetLock.Unlock();
+
+		delete fBuffers;
+		fBuffers = NULL;
+
+		for (uint32 i = 0; i < kBufferCount; i++) {
+			snooze(20000);
+			delete fBitmap[i];
+			fBitmap[i] = NULL;
+		}
+	}
+}
+
+
+status_t
+VideoConsumer::Connected(const media_source& producer,
+	const media_destination& where, const media_format& format,
+	media_input* outInput)
+{
+	fIn.source = producer;
+	fIn.format = format;
+	fIn.node = Node();
+	sprintf(fIn.name, "Video Consumer");
+	*outInput = fIn;
+
+	uint32 userData = 0;
+	int32 changeTag = 1;
+	status_t ret = CreateBuffers(format);
+	if (ret == B_OK) {
+		ret = SetOutputBuffersFor(producer, fIn.destination, 
+			fBuffers, &userData, &changeTag, true);
+		if (ret != B_OK)
+			fprintf(stderr, "SetOutputBuffersFor() failed: %s\n", strerror(ret));
+
+		fIn.format.u.raw_video.display.bytes_per_row
+			= fBitmap[0]->BytesPerRow();
+	} else {
+		fprintf(stderr, "VideoConsumer::Connected - COULDN'T CREATE BUFFERS\n");
+		return ret;
+	}
+
+	*outInput = fIn;
+	fConnectionActive = true;
+
+	return B_OK;
+}
+
+
+void
+VideoConsumer::Disconnected(const media_source& producer,
+	const media_destination& where)
+{
+	if (where != fIn.destination || producer != fIn.source)
+		return;
+
+	int32 changeTag = 0;
+	SetOutputBuffersFor(producer, fIn.destination, NULL, NULL, &changeTag,
+		false);
+	if (fOurBuffers) {
+		status_t reclaimError = fBuffers->ReclaimAllBuffers();
+		if (reclaimError != B_OK) {
+			fprintf(stderr, "VideoConsumer::Disconnected() - Failed to "
+				"reclaim our buffers: %s\n", strerror(reclaimError));
+		}
+	}
+	// disconnect the connection
+	fIn.source = media_source::null;
+	fConnectionActive = false;
+
+	_UnsetTargetBuffer();
+}
+
+
+status_t
+VideoConsumer::AcceptFormat(const media_destination& dest, media_format* format)
+{
+	if (dest != fIn.destination) {
+		fprintf(stderr, "VideoConsumer::AcceptFormat - BAD DESTINATION\n");
+		return B_MEDIA_BAD_DESTINATION;	
+	}
+	
+	if (format->type == B_MEDIA_NO_TYPE)
+		format->type = B_MEDIA_RAW_VIDEO;
+	
+	if (format->type != B_MEDIA_RAW_VIDEO) {
+		fprintf(stderr, "VideoConsumer::AcceptFormat - BAD FORMAT\n");
+		return B_MEDIA_BAD_FORMAT;
+	}
+
+	if (format->u.raw_video.display.format
+			!= media_raw_video_format::wildcard.display.format) {
+		uint32 flags = 0;
+		bool supported = bitmaps_support_space(
+			format->u.raw_video.display.format, &flags);
+
+		if (!supported) {
+			fprintf(stderr, "AcceptFormat - unsupported color space for BBitmaps !\n");
+			return B_MEDIA_BAD_FORMAT;
+		}
+		if (flags & B_VIEWS_SUPPORT_DRAW_BITMAP == 0) {
+			fprintf(stderr, "AcceptFormat - BViews cannot draw bitmaps in given colorspace !\n");
+			return B_MEDIA_BAD_FORMAT;
+		}
+	}
+
+	return B_OK;
+}
+
+
+status_t
+VideoConsumer::GetNextInput(int32* cookie, media_input* outInput)
+{
+	if (*cookie < 1) {
+		fIn.node = Node();
+		fIn.destination.id = *cookie;
+		sprintf(fIn.name, "Video Consumer");
+		*outInput = fIn;
+		(*cookie)++;
+		return B_OK;
+	}
+	return B_MEDIA_BAD_DESTINATION;
+}
+
+
+void
+VideoConsumer::DisposeInputCookie(int32 /*cookie*/)
+{
+}
+
+
+status_t
+VideoConsumer::GetLatencyFor(const media_destination& whom,
+	bigtime_t* _latency, media_node_id* _timeSource)
+{
+	if (whom != fIn.destination)
+		return B_MEDIA_BAD_DESTINATION;
+	
+	*_latency = fMyLatency;
+	*_timeSource = TimeSource()->ID();
+	return B_OK;
+}
+
+
+status_t
+VideoConsumer::FormatChanged(const media_source& producer,
+	const media_destination& consumer, int32 fromChangeCount,
+	const media_format& format)
+{
+	if (consumer != fIn.destination)
+		return B_MEDIA_BAD_DESTINATION;
+
+	if (producer != fIn.source)
+		return B_MEDIA_BAD_SOURCE;
+
+	fIn.format = format;
+
+	return CreateBuffers(format);
+}
+
+
+void
+VideoConsumer::HandleEvent(const media_timed_event* event, bigtime_t lateness,
+	bool realTimeEvent)
+{
+	switch (event->type) {
+		case BTimedEventQueue::B_START:
+			_SetPerformanceTimeBase(event->event_time);
+			break;
+		case BTimedEventQueue::B_WARP:
+		case BTimedEventQueue::B_SEEK:
+			_SetPerformanceTimeBase(event->bigdata);
+			break;
+		case BTimedEventQueue::B_STOP:
+			EventQueue()->FlushEvents(event->event_time, BTimedEventQueue::B_ALWAYS,
+				true, BTimedEventQueue::B_HANDLE_BUFFER);
+			_UnsetTargetBuffer();
+			break;
+		case BTimedEventQueue::B_HANDLE_BUFFER:
+			_HandleBuffer(static_cast<BBuffer*>(event->pointer));
+			break;
+		default:
+			fprintf(stderr, "VideoConsumer::HandleEvent - BAD EVENT\n");
+			break;
+	}			
+}
+
+
+void
+VideoConsumer::_SetPerformanceTimeBase(bigtime_t performanceTime)
+{
+	fPerformanceTimeBase = performanceTime;
+}
+
+
+void
+VideoConsumer::_HandleBuffer(BBuffer* buffer)
+{
+	if (RunState() != B_STARTED || !fConnectionActive) {
+		buffer->Recycle();
+		return;
+	}
+
+	uint32 index = 0;
+	fOurBuffers = true;
+	while (index < kBufferCount) {
+		if (buffer->ID() == fBufferMap[index]->ID())
+			break;
+		else
+			index++;
+	}
+	if (index == kBufferCount) {
+		fOurBuffers = false;
+		index = (fLastBufferIndex + 1) % kBufferCount;
+	}
+
+	bool recycle = true;
+	bigtime_t now = TimeSource()->Now();
+
+	if (!fOurBuffers) {
+		memcpy(fBitmap[index]->Bits(), buffer->Data(),
+			fBitmap[index]->BitsLength());
+	}
+
+	bigtime_t tooEarly = buffer->Header()->start_time - now;
+	if (tooEarly > 3000)
+		snooze(tooEarly);
+
+	fTargetLock.Lock();
+
+//	VideoCaptureCapability frameInfo;
+//	frameInfo.width = fBitmap[index]->Bounds().Width() + 1;
+//	frameInfo.height = fBitmap[index]->Bounds().Height() + 1;
+//	frameInfo.videoType = VideoType::kARGB;
+
+//	fVideoCapture->IncomingFrame((unsigned char*)fBitmap[index]->Bits(),
+//		fBitmap[index]->BitsLength(), frameInfo);
+
+  if (client_) {
+  const int64_t absolute_micro =
+      buffer->Header()->start_time / base::Time::kNanosecondsPerMicrosecond;
+  const base::TimeDelta capture_time =
+      base::TimeDelta::FromMicroseconds(absolute_micro);
+
+  const base::TimeTicks current_time = base::TimeTicks::Now();
+
+  media::VideoCaptureFormat kSupportedFormat(gfx::Size(640, 480),
+					25.0f, media::PIXEL_FORMAT_ARGB);
+
+	  client_->OnIncomingCapturedData(
+    	  (unsigned char*)fBitmap[index]->Bits(), fBitmap[index]->BitsLength(), kSupportedFormat, gfx::ColorSpace(), 0,
+      	  false /* flip_y */, current_time, capture_time);
+  }
+
+	if (fOurBuffers) {
+		if (fLastBufferIndex >= 0)
+			fBufferMap[fLastBufferIndex]->Recycle();
+		recycle = false;
+	}
+	fLastBufferIndex = index;
+
+	fTargetLock.Unlock();
+
+	if (recycle)
+		buffer->Recycle();
+}
+
+
+void
+VideoConsumer::_UnsetTargetBuffer()
+{
+	fTargetLock.Lock();
+	if (fLastBufferIndex >= 0) {
+		if (fOurBuffers)
+			fBufferMap[fLastBufferIndex]->Recycle();
+		fLastBufferIndex = -1;
+	}
+	fTargetLock.Unlock();
+}
+
+} //namespace media
diff --git a/chromium/media/capture/video/haiku/video_capture_device_consumer_haiku.h b/chromium/media/capture/video/haiku/video_capture_device_consumer_haiku.h
new file mode 100644
index 0000000..45cff12
--- /dev/null
+++ b/chromium/media/capture/video/haiku/video_capture_device_consumer_haiku.h
@@ -0,0 +1,117 @@
+// Copyright 2021-2023 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_CONSUMER_HAIKU_H_
+#define MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_CONSUMER_HAIKU_H_
+
+#include "base/macros.h"
+#include "media/capture/capture_export.h"
+#include "media/capture/video/video_capture_device.h"
+#include "video_capture_device_haiku.h"
+
+#include <BufferConsumer.h>
+#include <Locker.h>
+#include <MediaEventLooper.h>
+
+class BBitmap;
+
+namespace media {
+
+static const unsigned int kBufferCount = 4;
+
+
+class VideoConsumer : public BMediaEventLooper, public BBufferConsumer {
+public:
+								VideoConsumer(
+									const char* name,
+									BMediaAddOn* addon,
+									const uint32 internal_id);
+								~VideoConsumer();
+public:
+	void						SetClient(std::unique_ptr<VideoCaptureDevice::Client> client);
+	// BMediaNode interface
+public:
+	virtual	BMediaAddOn*		AddOn(int32* cookie) const;
+	
+protected:
+	virtual void				NodeRegistered();
+	virtual	status_t		 	RequestCompleted(
+									const media_request_info& info);
+							
+	virtual	status_t 			HandleMessage(int32 message, const void* data,
+									size_t size);
+
+	// BMediaEventLooper interface
+protected:
+	virtual void				HandleEvent(const media_timed_event* event,
+									bigtime_t lateness, bool realTimeEvent);
+
+	// BBufferConsumer interface
+public:
+	virtual	status_t			AcceptFormat(const media_destination& dest,
+									media_format* format);
+	virtual	status_t			GetNextInput(int32* cookie,
+									media_input* _input);
+							
+	virtual	void				DisposeInputCookie(int32 cookie);
+	
+protected:
+	virtual	void				BufferReceived(BBuffer* buffer);
+	
+private:
+	virtual	void				ProducerDataStatus(
+									const media_destination& forWhom,
+									int32 status,
+									bigtime_t atMediaTime);									
+	virtual	status_t			GetLatencyFor(
+									const media_destination& forWhom,
+									bigtime_t* outLatency,
+									media_node_id* outId);	
+	virtual	status_t			Connected(const media_source& producer,
+									const media_destination& where,
+									const media_format& withFormat,
+									media_input* outInput);
+	virtual	void				Disconnected(const media_source& producer,
+									const media_destination& where);							
+	virtual	status_t			FormatChanged(const media_source& producer,
+									const media_destination& consumer, 
+									int32 from_change_count,
+									const media_format& format);
+							
+	// VideoConsumer
+public:
+			status_t			CreateBuffers(
+									const media_format& withFormat);
+							
+			void				DeleteBuffers();
+
+private:
+			void				_SetPerformanceTimeBase(
+									bigtime_t performanceTime);
+			void				_HandleBuffer(BBuffer* buffer);
+			void				_UnsetTargetBuffer();
+
+private:
+			int32				fInternalID;
+			BMediaAddOn*		fAddOn;
+
+			bool				fConnectionActive;
+			media_input			fIn;
+			bigtime_t			fMyLatency;
+			bigtime_t			fPerformanceTimeBase;
+
+			BBitmap*			fBitmap[kBufferCount];
+			bool				fOurBuffers;
+			BBufferGroup*		fBuffers;
+			BBuffer*			fBufferMap[kBufferCount];	
+
+			BLocker				fTargetLock;
+			int32				fLastBufferIndex;
+
+			std::unique_ptr<VideoCaptureDevice::Client> client_;
+};
+
+}  // namespace media
+
+#endif // MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_CONSUMER_HAIKU_H_
diff --git a/chromium/media/capture/video/haiku/video_capture_device_factory_haiku.cc b/chromium/media/capture/video/haiku/video_capture_device_factory_haiku.cc
new file mode 100644
index 0000000..9df67fe
--- /dev/null
+++ b/chromium/media/capture/video/haiku/video_capture_device_factory_haiku.cc
@@ -0,0 +1,96 @@
+// Copyright 2021-2023 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/check_op.h"
+#include "base/location.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/time/time.h"
+
+#include "media/capture/video/haiku/video_capture_device_factory_haiku.h"
+#include "media/capture/video/haiku/video_capture_device_haiku.h"
+
+namespace media {
+
+VideoCaptureDeviceFactoryHaiku::VideoCaptureDeviceFactoryHaiku() {
+}
+
+VideoCaptureDeviceFactoryHaiku::~VideoCaptureDeviceFactoryHaiku() {
+}
+
+std::unique_ptr<VideoCaptureDevice>
+VideoCaptureDeviceFactoryHaiku::CreateDevice(
+    const VideoCaptureDeviceDescriptor& device_descriptor) {
+  int id;
+  if (!base::StringToInt(device_descriptor.device_id, &id))
+    return std::unique_ptr<VideoCaptureDevice>();
+
+  std::unique_ptr<VideoCaptureDeviceHaiku> video_capture_device(
+      new VideoCaptureDeviceHaiku(device_descriptor));
+
+  return std::move(video_capture_device);
+}
+
+void VideoCaptureDeviceFactoryHaiku::GetDevicesInfo(
+    GetDevicesInfoCallback callback) {
+	status_t err = B_OK;
+
+	int32_t countDevices = 0;
+
+	media_output videoOutput;
+
+	dormant_node_info dni[30];
+	int32 ioCount = 30;
+	media_format out;
+	out.type = B_MEDIA_RAW_VIDEO;
+	err = BMediaRoster::Roster()->GetDormantNodes(dni, &ioCount, 0, &out, 0, B_BUFFER_PRODUCER);
+	if (err < B_OK)
+		return;
+
+	err = B_ERROR;
+	
+	std::vector<VideoCaptureDeviceInfo> devices_info;
+
+	for (int ix=0; ix<ioCount; ix++) {
+		media_node_id running = -1;
+		if ((B_OK == BMediaRoster::CurrentRoster()->GetInstancesFor(
+				dni[ix].addon, dni[ix].flavor_id, &running)) && (running > -1)) {
+			media_node node;
+			BMediaRoster::CurrentRoster()->GetNodeFor(running, &node);
+			int32 count = 1;
+			BMediaRoster::CurrentRoster()->GetAllOutputsFor(node, &videoOutput, 1, &count);
+			BMediaRoster::CurrentRoster()->ReleaseNode(node);
+			if (count > 0) {
+				VideoCaptureControlSupport control_support;
+				control_support.pan = false;
+				control_support.tilt = false;
+				control_support.zoom = false;
+
+				VideoCaptureDeviceInfo device_info(VideoCaptureDeviceDescriptor(
+			        videoOutput.name, std::to_string(videoOutput.node.node), "",
+			        VideoCaptureApi::HAIKU_MEDIAKIT, control_support,
+			        VideoCaptureTransportType::OTHER_TRANSPORT,
+			        VideoFacingMode::MEDIA_VIDEO_FACING_NONE));
+
+				media::VideoCaptureFormat kSupportedFormat(gfx::Size(640, 480),
+					8.0f, media::PIXEL_FORMAT_ARGB);
+
+				device_info.supported_formats.push_back(kSupportedFormat);
+
+				devices_info.emplace_back(std::move(device_info));
+				
+				countDevices++;
+			}
+			BMediaRoster::CurrentRoster()->ReleaseNode(node);
+		}
+	}
+
+	std::move(callback).Run(std::move(devices_info));
+}
+
+void VideoCaptureDeviceFactoryHaiku::Initialize() {
+}
+
+}  // namespace media
diff --git a/chromium/media/capture/video/haiku/video_capture_device_factory_haiku.h b/chromium/media/capture/video/haiku/video_capture_device_factory_haiku.h
new file mode 100644
index 0000000..1560e74
--- /dev/null
+++ b/chromium/media/capture/video/haiku/video_capture_device_factory_haiku.h
@@ -0,0 +1,44 @@
+// Copyright 2021-2023 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_FACTORY_HAIKU_H_
+#define MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_FACTORY_HAIKU_H_
+
+#include <stdint.h>
+#include <MediaKit.h>
+
+#include "base/containers/small_map.h"
+#include "base/optional.h"
+#include "media/capture/video/video_capture_device_factory.h"
+
+namespace media {
+
+class CAPTURE_EXPORT VideoCaptureDeviceFactoryHaiku
+    : public VideoCaptureDeviceFactory {
+ public:
+  VideoCaptureDeviceFactoryHaiku();
+  ~VideoCaptureDeviceFactoryHaiku() override;
+
+  VideoCaptureDeviceFactoryHaiku(const VideoCaptureDeviceFactoryHaiku&) =
+      delete;
+  VideoCaptureDeviceFactoryHaiku& operator=(
+      const VideoCaptureDeviceFactoryHaiku&) = delete;
+
+  // VideoCaptureDeviceFactory implementation.
+  std::unique_ptr<VideoCaptureDevice> CreateDevice(
+      const VideoCaptureDeviceDescriptor& device_descriptor) override;
+  void GetDevicesInfo(GetDevicesInfoCallback callback) override;
+
+ private:
+  // Helper class used to fetch per-device information.
+  class DeviceConfigFetcher;
+
+  void Initialize();
+
+  base::WeakPtrFactory<VideoCaptureDeviceFactoryHaiku> weak_factory_{this};
+};
+
+}  // namespace media
+
+#endif  // MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_FACTORY_HAIKU_H_
diff --git a/chromium/media/capture/video/haiku/video_capture_device_haiku.cc b/chromium/media/capture/video/haiku/video_capture_device_haiku.cc
new file mode 100644
index 0000000..8502fb2
--- /dev/null
+++ b/chromium/media/capture/video/haiku/video_capture_device_haiku.cc
@@ -0,0 +1,59 @@
+// Copyright 2021-2023 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/capture/video/haiku/video_capture_device_haiku.h"
+
+#include "base/strings/stringprintf.h"
+#include "base/time/time.h"
+#include "media/base/video_types.h"
+#include "third_party/libyuv/include/libyuv/convert.h"
+#include "third_party/libyuv/include/libyuv/video_common.h"
+#include "ui/gfx/buffer_format_util.h"
+
+#include <OS.h>
+
+namespace media {
+	
+namespace {
+
+VideoCaptureDeviceHaiku::VideoCaptureDeviceHaiku(
+    const media::VideoCaptureDeviceDescriptor& device_descriptor)
+    : device_descriptor_(device_descriptor)
+    , frame_thread_("HaikuCaptureThread") {
+}
+
+VideoCaptureDeviceHaiku::~VideoCaptureDeviceHaiku()  {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(!frame_thread_.IsRunning());
+  frame_thread_.Stop();
+}
+
+void VideoCaptureDeviceHaiku::AllocateAndStart(
+    const VideoCaptureParams& params,
+    std::unique_ptr<Client> client) {
+  client_ = std::move(client);
+
+  if (frame_thread_.IsRunning())
+    return;  // Wrong state.
+    
+  frame_thread_.Start();
+
+  should_quit_frame_production_loop_.UnsafeResetForTesting();
+  frame_thread_.task_runner()->PostTask(
+        FROM_HERE,
+        base::BindOnce(&VideoCaptureDeviceHaiku::RunFrameProductionLoop,
+                       base::Unretained(this)));
+
+}
+
+void VideoCaptureDeviceHaiku::StopAndDeAllocate() {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  should_quit_frame_production_loop_.Set();
+  frame_thread_.Stop();
+  client_.reset();
+}
+
+}
+
+}  // namespace media
diff --git a/chromium/media/capture/video/haiku/video_capture_device_haiku.h b/chromium/media/capture/video/haiku/video_capture_device_haiku.h
new file mode 100644
index 0000000..a78bf16
--- /dev/null
+++ b/chromium/media/capture/video/haiku/video_capture_device_haiku.h
@@ -0,0 +1,109 @@
+// Copyright 2021-2023 Gerasim Troeglazov. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_HAIKU_H_
+#define MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_HAIKU_H_
+
+#include <memory>
+
+#include <MediaKit.h>
+
+#include "media/capture/video/haiku/video_capture_device_consumer_haiku.h"
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/synchronization/lock.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/threading/thread.h"
+#include "base/threading/thread_checker.h"
+#include "base/time/time.h"
+#include "media/capture/capture_export.h"
+#include "media/capture/video/video_capture_device.h"
+
+namespace media {
+
+namespace {
+
+class CAPTURE_EXPORT VideoCaptureDeviceHaiku : public VideoCaptureDevice {
+ public:
+  explicit VideoCaptureDeviceHaiku(const media::VideoCaptureDeviceDescriptor& device_descriptor);
+  ~VideoCaptureDeviceHaiku() override;
+
+  VideoCaptureDeviceHaiku(const VideoCaptureDeviceHaiku&) = delete;
+  VideoCaptureDeviceHaiku& operator=(const VideoCaptureDeviceHaiku&) =
+      delete;
+
+  // VideoCaptureDevice implementation.
+  void AllocateAndStart(const VideoCaptureParams& params,
+                        std::unique_ptr<Client> client) final;
+  void StopAndDeAllocate() final;
+
+ private:
+
+  unsigned char buff[640*480*4];
+
+  void RunFrameProductionLoop() {
+  	int n=0;
+    while (!should_quit_frame_production_loop_.IsSet()) {
+
+	  if (client_) {
+      printf("RunFrameProductionLoop %d\n", n++);
+
+	  unsigned char *ptr = buff;
+	  for(int y=0;y<480;y++)
+	  	for(int x=0;x<640;x++) {
+	  		*ptr++ = (x*y) % 256;
+	  		*ptr++ = (x+y) % 256;
+	  		*ptr++ = (x*y*n) % 256;
+	  		*ptr++ = 0;
+	  	}
+      
+      const base::TimeDelta capture_time = base::TimeDelta::FromMicroseconds(1000);
+
+	  const base::TimeTicks current_time = base::TimeTicks::Now();
+
+	media::VideoCaptureFormat capture_format_;
+
+  capture_format_.frame_size.SetSize(640, 480);
+  capture_format_.frame_rate = 8.0f;
+  capture_format_.pixel_format = media::PIXEL_FORMAT_ARGB;
+	
+		  client_->OnIncomingCapturedData(
+	    	  buff, 640*480*4, capture_format_, gfx::ColorSpace(), 0,
+	      	  false, current_time, capture_time);
+	  }
+      base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(1000/8));
+    }
+  }
+
+  base::TimeTicks start_time_;
+
+  bool started_ = false;
+
+  size_t frames_received_ = 0;
+  
+  //std::unique_ptr<VideoCaptureDevice::Client> client_;
+
+  const media::VideoCaptureDeviceDescriptor device_descriptor_;
+  std::unique_ptr<VideoCaptureDevice::Client> client_;
+
+	BMediaRoster *fMediaRoster;
+	VideoConsumer *fVideoConsumer;
+	BTimeSource* timeSource;
+	media_node fProducerNode;
+	media_node fConsumerNode;
+	media_input videoInput;
+	media_output videoOutput;
+
+	base::Thread frame_thread_;
+	base::AtomicFlag should_quit_frame_production_loop_;
+
+  THREAD_CHECKER(thread_checker_);
+};
+
+}
+
+}  // namespace media
+
+#endif  // MEDIA_CAPTURE_VIDEO_HAIKU_VIDEO_CAPTURE_DEVICE_HAIKU_H_
diff --git a/chromium/media/capture/video/video_capture_device_descriptor.cc b/chromium/media/capture/video/video_capture_device_descriptor.cc
index e044b4e..d5a0700 100644
--- a/chromium/media/capture/video/video_capture_device_descriptor.cc
+++ b/chromium/media/capture/video/video_capture_device_descriptor.cc
@@ -95,6 +95,8 @@ const char* VideoCaptureDeviceDescriptor::GetCaptureApiTypeString() const {
       return "Camera API2 Limited";
     case VideoCaptureApi::FUCHSIA_CAMERA3:
       return "fuchsia.camera3 API";
+    case VideoCaptureApi::HAIKU_MEDIAKIT:
+      return "Haiku MediaKit";
     case VideoCaptureApi::VIRTUAL_DEVICE:
       return "Virtual Device";
     case VideoCaptureApi::UNKNOWN:
diff --git a/chromium/media/capture/video/video_capture_device_descriptor.h b/chromium/media/capture/video/video_capture_device_descriptor.h
index f73d893..1548d95 100644
--- a/chromium/media/capture/video/video_capture_device_descriptor.h
+++ b/chromium/media/capture/video/video_capture_device_descriptor.h
@@ -28,6 +28,7 @@ enum class VideoCaptureApi {
   ANDROID_API2_FULL,
   ANDROID_API2_LIMITED,
   FUCHSIA_CAMERA3,
+  HAIKU_MEDIAKIT,
   VIRTUAL_DEVICE,
   UNKNOWN
 };
diff --git a/chromium/media/filters/audio_file_reader.cc b/chromium/media/filters/audio_file_reader.cc
index cb81d92..bd73908 100644
--- a/chromium/media/filters/audio_file_reader.cc
+++ b/chromium/media/filters/audio_file_reader.cc
@@ -85,7 +85,7 @@ bool AudioFileReader::OpenDemuxer() {
 }
 
 bool AudioFileReader::OpenDecoder() {
-  AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+  const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
   if (codec) {
     // MP3 decodes to S16P which we don't support, tell it to use S16 instead.
     if (codec_context_->sample_fmt == AV_SAMPLE_FMT_S16P)
diff --git a/chromium/net/BUILD.gn b/chromium/net/BUILD.gn
index c399590..b01504d 100644
--- a/chromium/net/BUILD.gn
+++ b/chromium/net/BUILD.gn
@@ -99,7 +99,7 @@ net_configs = [
   "//build/config/compiler:wexit_time_destructors",
 ]
 
-if (is_linux || is_chromeos) {
+if ((is_linux && !is_haiku) || is_chromeos) {
   net_configs += [ "//build/config/linux:libresolv" ]
 }
 
@@ -1261,6 +1261,16 @@ component("net") {
       ]
     }
 
+    if (is_haiku) {
+      sources -= [
+        "base/address_tracker_linux.cc",
+        "base/address_tracker_linux.h",
+        "base/network_change_notifier_linux.cc",
+        "base/network_change_notifier_linux.h",
+        "base/network_interfaces_linux.cc",
+      ]
+    }
+
     if (is_mac) {
       sources += [
         "base/network_notification_thread_mac.cc",
@@ -1397,7 +1407,7 @@ component("net") {
       }
     }
 
-    if (is_android || is_chromeos) {
+    if (is_android || is_chromeos || is_haiku) {
       sources += [
         "base/network_change_notifier_posix.cc",
         "base/network_change_notifier_posix.h",
@@ -1430,7 +1440,7 @@ component("net") {
     }
 
     # Use getifaddrs() on POSIX platforms, except Linux.
-    if (is_posix && !is_linux && !is_chromeos) {
+    if (is_posix && (!is_linux || is_haiku) && !is_chromeos) {
       sources += [
         "base/network_interfaces_getifaddrs.cc",
         "base/network_interfaces_getifaddrs.h",
diff --git a/chromium/net/base/address_tracker_linux.cc b/chromium/net/base/address_tracker_linux.cc
index 2daccb4..8796a77 100644
--- a/chromium/net/base/address_tracker_linux.cc
+++ b/chromium/net/base/address_tracker_linux.cc
@@ -5,7 +5,9 @@
 #include "net/base/address_tracker_linux.h"
 
 #include <errno.h>
+#ifndef OS_HAIKU
 #include <linux/if.h>
+#endif
 #include <stdint.h>
 #include <sys/ioctl.h>
 #include <utility>
@@ -190,6 +192,7 @@ void AddressTrackerLinux::Init() {
   DCHECK_LT(base::android::BuildInfo::GetInstance()->sdk_int(),
             base::android::SDK_VERSION_P);
 #endif
+#if !defined(OS_HAIKU)
   netlink_fd_.reset(socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE));
   if (!netlink_fd_.is_valid()) {
     PLOG(ERROR) << "Could not create NETLINK socket";
@@ -274,6 +277,7 @@ void AddressTrackerLinux::Init() {
         base::BindRepeating(&AddressTrackerLinux::OnFileCanReadWithoutBlocking,
                             base::Unretained(this)));
   }
+#endif
 }
 
 void AddressTrackerLinux::AbortAndForceOnline() {
@@ -361,6 +365,7 @@ void AddressTrackerLinux::HandleMessage(const char* buffer,
                                         bool* address_changed,
                                         bool* link_changed,
                                         bool* tunnel_changed) {
+#if !defined(OS_HAIKU)
   DCHECK(buffer);
   // Note that NLMSG_NEXT decrements |length| to reflect the number of bytes
   // remaining in |buffer|.
@@ -473,6 +478,10 @@ void AddressTrackerLinux::HandleMessage(const char* buffer,
         break;
     }
   }
+#else
+	NOTIMPLEMENTED();
+	AbortAndForceOnline();
+#endif
 }
 
 void AddressTrackerLinux::OnFileCanReadWithoutBlocking() {
@@ -500,31 +509,7 @@ bool AddressTrackerLinux::IsTunnelInterfaceName(const char* name) {
 }
 
 void AddressTrackerLinux::UpdateCurrentConnectionType() {
-  AddressTrackerLinux::AddressMap address_map = GetAddressMap();
-  std::unordered_set<int> online_links = GetOnlineLinks();
-
-  // Strip out tunnel interfaces from online_links
-  for (auto it = online_links.cbegin(); it != online_links.cend();) {
-    if (IsTunnelInterface(*it)) {
-      it = online_links.erase(it);
-    } else {
-      ++it;
-    }
-  }
-
-  NetworkInterfaceList networks;
-  NetworkChangeNotifier::ConnectionType type =
-      NetworkChangeNotifier::CONNECTION_NONE;
-  if (GetNetworkListImpl(&networks, 0, online_links, address_map,
-                         get_interface_name_)) {
-    type = NetworkChangeNotifier::ConnectionTypeFromInterfaceList(networks);
-  } else {
-    type = online_links.empty() ? NetworkChangeNotifier::CONNECTION_NONE
-                                : NetworkChangeNotifier::CONNECTION_UNKNOWN;
-  }
-
-  AddressTrackerAutoLock lock(*this, connection_type_lock_);
-  current_connection_type_ = type;
+  NOTIMPLEMENTED();  
 }
 
 int AddressTrackerLinux::GetThreadsWaitingForConnectionTypeInitForTesting() {
diff --git a/chromium/net/base/address_tracker_linux.h b/chromium/net/base/address_tracker_linux.h
index a18450d..45cf157 100644
--- a/chromium/net/base/address_tracker_linux.h
+++ b/chromium/net/base/address_tracker_linux.h
@@ -7,9 +7,6 @@
 
 #include <sys/socket.h>  // Needed to include netlink.
 // Mask superfluous definition of |struct net|. This is fixed in Linux 2.6.38.
-#define net net_kernel
-#include <linux/rtnetlink.h>
-#undef net
 #include <stddef.h>
 
 #include <map>
diff --git a/chromium/net/base/net_errors_posix.cc b/chromium/net/base/net_errors_posix.cc
index 2e4fd24..21d4211 100644
--- a/chromium/net/base/net_errors_posix.cc
+++ b/chromium/net/base/net_errors_posix.cc
@@ -107,8 +107,10 @@ Error MapSystemError(logging::SystemErrorCode os_error) {
       return ERR_ACCESS_DENIED;
     case ETXTBSY:  // Text file busy.
       return ERR_ACCESS_DENIED;
+#if !defined(OS_HAIKU)
     case EUSERS:  // Too many users.
       return ERR_INSUFFICIENT_RESOURCES;
+#endif
     case EMFILE:  // Too many open files.
       return ERR_INSUFFICIENT_RESOURCES;
     case ENOPROTOOPT:  // Protocol option not supported.
diff --git a/chromium/net/base/network_interfaces_getifaddrs.cc b/chromium/net/base/network_interfaces_getifaddrs.cc
index a848dec..10a3925 100644
--- a/chromium/net/base/network_interfaces_getifaddrs.cc
+++ b/chromium/net/base/network_interfaces_getifaddrs.cc
@@ -30,6 +30,10 @@
 #include <sys/ioctl.h>
 #endif  // !OS_IOS
 
+#if defined(OS_HAIKU)
+#define IFF_RUNNING IFF_LINK
+#endif
+
 #if defined(OS_ANDROID)
 #include "base/android/build_info.h"
 // Declare getifaddrs() and freeifaddrs() weakly as they're only available
diff --git a/chromium/net/cert/cert_verifier.cc b/chromium/net/cert/cert_verifier.cc
index 6504721..e151f7e 100644
--- a/chromium/net/cert/cert_verifier.cc
+++ b/chromium/net/cert/cert_verifier.cc
@@ -87,7 +87,7 @@ std::unique_ptr<CertVerifier> CertVerifier::CreateDefaultWithoutCaching(
   return std::unique_ptr<CertVerifier>();
 #else
   scoped_refptr<CertVerifyProc> verify_proc;
-#if defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   verify_proc =
       CertVerifyProc::CreateBuiltinVerifyProc(std::move(cert_net_fetcher));
 #elif BUILDFLAG(BUILTIN_CERT_VERIFIER_FEATURE_SUPPORTED)
diff --git a/chromium/net/cert/cert_verify_proc.cc b/chromium/net/cert/cert_verify_proc.cc
index 10cd48b..7350662 100644
--- a/chromium/net/cert/cert_verify_proc.cc
+++ b/chromium/net/cert/cert_verify_proc.cc
@@ -493,7 +493,7 @@ base::Value CertVerifyParams(X509Certificate* cert,
 
 }  // namespace
 
-#if !(defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS))
+#if !(defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU))
 // static
 scoped_refptr<CertVerifyProc> CertVerifyProc::CreateSystemVerifyProc(
     scoped_refptr<CertNetFetcher> cert_net_fetcher) {
diff --git a/chromium/net/cert/test_root_certs.h b/chromium/net/cert/test_root_certs.h
index 836f29f..c475e76 100644
--- a/chromium/net/cert/test_root_certs.h
+++ b/chromium/net/cert/test_root_certs.h
@@ -75,7 +75,7 @@ class NET_EXPORT TestRootCerts {
   // engine is appropriate. The caller is responsible for freeing the
   // returned HCERTCHAINENGINE.
   HCERTCHAINENGINE GetChainEngine() const;
-#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   TrustStore* test_trust_store() { return &test_trust_store_; }
 #endif
 
@@ -93,12 +93,12 @@ class NET_EXPORT TestRootCerts {
 #elif defined(OS_APPLE)
   base::ScopedCFTypeRef<CFMutableArrayRef> temporary_roots_;
   TrustStoreInMemory test_trust_store_;
-#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   TrustStoreInMemory test_trust_store_;
 #endif
 
 #if defined(OS_WIN) || defined(OS_ANDROID) || defined(OS_FUCHSIA) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // True if there are no temporarily trusted root certificates.
   bool empty_ = true;
 #endif
diff --git a/chromium/net/proxy_resolution/proxy_config_service_linux.cc b/chromium/net/proxy_resolution/proxy_config_service_linux.cc
index c11685f..6990a4c 100644
--- a/chromium/net/proxy_resolution/proxy_config_service_linux.cc
+++ b/chromium/net/proxy_resolution/proxy_config_service_linux.cc
@@ -6,7 +6,9 @@
 
 #include <errno.h>
 #include <limits.h>
+#if !defined(OS_HAIKU)
 #include <sys/inotify.h>
+#endif
 #include <unistd.h>
 
 #include <map>
@@ -511,6 +513,7 @@ int StringToIntOrDefault(base::StringPiece value, int default_value) {
   return default_value;
 }
 
+#if !defined(OS_HAIKU)
 // This is the KDE version that reads kioslaverc and simulates gsettings.
 // Doing this allows the main Delegate code, as well as the unit tests
 // for it, to stay the same - and the settings map fairly well besides.
@@ -1001,6 +1004,7 @@ class SettingGetterImplKDE : public ProxyConfigServiceLinux::SettingGetter {
 
   DISALLOW_COPY_AND_ASSIGN(SettingGetterImplKDE);
 };
+#endif
 
 }  // namespace
 
@@ -1215,7 +1219,9 @@ ProxyConfigServiceLinux::Delegate::Delegate(
     case base::nix::DESKTOP_ENVIRONMENT_KDE3:
     case base::nix::DESKTOP_ENVIRONMENT_KDE4:
     case base::nix::DESKTOP_ENVIRONMENT_KDE5:
+#if !defined(OS_HAIKU)
       setting_getter_.reset(new SettingGetterImplKDE(env_var_getter_.get()));
+#endif
       break;
     case base::nix::DESKTOP_ENVIRONMENT_XFCE:
     case base::nix::DESKTOP_ENVIRONMENT_OTHER:
diff --git a/chromium/net/socket/udp_socket_posix.cc b/chromium/net/socket/udp_socket_posix.cc
index 7126556..046a6ad 100644
--- a/chromium/net/socket/udp_socket_posix.cc
+++ b/chromium/net/socket/udp_socket_posix.cc
@@ -51,6 +51,12 @@
 #include "base/strings/utf_string_conversions.h"
 #endif  // defined(OS_ANDROID)
 
+#if defined(OS_HAIKU)
+#include <sys/sockio.h>
+#define IPV6_TCLASS 61
+#define IP_DEFAULT_MULTICAST_TTL 1
+#endif
+
 #if defined(OS_MAC)
 // This was needed to debug crbug.com/640281.
 // TODO(zhongyi): Remove once the bug is resolved.
@@ -70,6 +76,37 @@ const int kActivityMonitorMinimumSamplesForThroughputEstimate = 2;
 const base::TimeDelta kActivityMonitorMsThreshold =
     base::TimeDelta::FromMilliseconds(100);
 
+#if defined(OS_HAIKU)
+// When enabling multicast using setsockopt(IP_MULTICAST_IF) MacOS
+// requires passing IPv4 address instead of interface index. This function
+// resolves IPv4 address by interface index. The |address| is returned in
+// network order.
+int GetIPv4AddressFromIndex(int socket, uint32_t index, uint32_t* address) {
+  if (!index) {
+    *address = htonl(INADDR_ANY);
+    return OK;
+  }
+
+  sockaddr_in* result = nullptr;
+
+  ifreq ifr;
+  ifr.ifr_addr.sa_family = AF_INET;
+  if (!if_indextoname(index, ifr.ifr_name))
+    return MapSystemError(errno);
+  int rv = ioctl(socket, SIOCGIFADDR, &ifr);
+  if (rv == -1)
+    return MapSystemError(errno);
+  result = reinterpret_cast<sockaddr_in*>(&ifr.ifr_addr);
+
+  if (!result)
+    return ERR_ADDRESS_INVALID;
+
+  *address = result->sin_addr.s_addr;
+  return OK;
+}
+
+#endif  // defined(OS_HAIKU)
+
 #if defined(OS_MAC)
 
 // On OSX the file descriptor is guarded to detect the cause of
@@ -622,13 +659,13 @@ int UDPSocketPosix::SetDoNotFragment() {
 }
 
 void UDPSocketPosix::SetMsgConfirm(bool confirm) {
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_HAIKU)
   if (confirm) {
     sendto_flags_ |= MSG_CONFIRM;
   } else {
     sendto_flags_ &= ~MSG_CONFIRM;
   }
-#endif  // !defined(OS_APPLE)
+#endif  // !defined(OS_APPLE) && !defined(OS_HAIKU)
 }
 
 int UDPSocketPosix::AllowAddressReuse() {
@@ -913,9 +950,17 @@ int UDPSocketPosix::SetMulticastOptions() {
   if (multicast_interface_ != 0) {
     switch (addr_family_) {
       case AF_INET: {
+#if defined(OS_HAIKU)
+        ip_mreq mreq = {};
+        int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
+                                            &mreq.imr_interface.s_addr);
+        if (error != OK)
+          return error;
+#else   //  defined(OS_HAIKU)
         ip_mreqn mreq = {};
         mreq.imr_ifindex = multicast_interface_;
         mreq.imr_address.s_addr = htonl(INADDR_ANY);
+#endif  //  defined(OS_HAIKU)
         int rv = setsockopt(socket_, IPPROTO_IP, IP_MULTICAST_IF,
                             reinterpret_cast<const char*>(&mreq), sizeof(mreq));
         if (rv)
@@ -978,9 +1023,18 @@ int UDPSocketPosix::JoinGroup(const IPAddress& group_address) const {
     case IPAddress::kIPv4AddressSize: {
       if (addr_family_ != AF_INET)
         return ERR_ADDRESS_INVALID;
+
+#if defined(OS_HAIKU)
+      ip_mreq mreq = {};
+      int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
+                                          &mreq.imr_interface.s_addr);
+      if (error != OK)
+        return error;
+#else
       ip_mreqn mreq = {};
       mreq.imr_ifindex = multicast_interface_;
       mreq.imr_address.s_addr = htonl(INADDR_ANY);
+#endif // !defined(OS_HAIKU)
       memcpy(&mreq.imr_multiaddr, group_address.bytes().data(),
              IPAddress::kIPv4AddressSize);
       int rv = setsockopt(socket_, IPPROTO_IP, IP_ADD_MEMBERSHIP,
@@ -1018,9 +1072,18 @@ int UDPSocketPosix::LeaveGroup(const IPAddress& group_address) const {
     case IPAddress::kIPv4AddressSize: {
       if (addr_family_ != AF_INET)
         return ERR_ADDRESS_INVALID;
+
+#if defined(OS_HAIKU)
+      ip_mreq mreq = {};
+      int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
+                                          &mreq.imr_interface.s_addr);
+      if (error != OK)
+        return error;
+#else
       ip_mreqn mreq = {};
       mreq.imr_ifindex = multicast_interface_;
       mreq.imr_address.s_addr = INADDR_ANY;
+#endif
       memcpy(&mreq.imr_multiaddr, group_address.bytes().data(),
              IPAddress::kIPv4AddressSize);
       int rv = setsockopt(socket_, IPPROTO_IP, IP_DROP_MEMBERSHIP,
diff --git a/chromium/net/socket/unix_domain_server_socket_posix.cc b/chromium/net/socket/unix_domain_server_socket_posix.cc
index 8b2e29b..353f2d1 100644
--- a/chromium/net/socket/unix_domain_server_socket_posix.cc
+++ b/chromium/net/socket/unix_domain_server_socket_posix.cc
@@ -34,7 +34,7 @@ UnixDomainServerSocket::~UnixDomainServerSocket() = default;
 bool UnixDomainServerSocket::GetPeerCredentials(SocketDescriptor socket,
                                                 Credentials* credentials) {
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
   struct ucred user_cred;
   socklen_t len = sizeof(user_cred);
   if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &user_cred, &len) < 0)
diff --git a/chromium/net/socket/unix_domain_server_socket_posix.h b/chromium/net/socket/unix_domain_server_socket_posix.h
index 9da6bc0..340b861 100644
--- a/chromium/net/socket/unix_domain_server_socket_posix.h
+++ b/chromium/net/socket/unix_domain_server_socket_posix.h
@@ -30,7 +30,7 @@ class NET_EXPORT UnixDomainServerSocket : public ServerSocket {
   // Credentials of a peer process connected to the socket.
   struct NET_EXPORT Credentials {
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
     // Linux and Fuchsia provide more information about the connected peer
     // than Windows/OS X. It's useful for permission-based authorization on
     // Android.
diff --git a/chromium/net/tools/cert_verify_tool/cert_verify_tool.cc b/chromium/net/tools/cert_verify_tool/cert_verify_tool.cc
index 88f5ee4..c0d5f71 100644
--- a/chromium/net/tools/cert_verify_tool/cert_verify_tool.cc
+++ b/chromium/net/tools/cert_verify_tool/cert_verify_tool.cc
@@ -29,7 +29,7 @@
 #include "net/url_request/url_request_context_builder.h"
 #include "net/url_request/url_request_context_getter.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "net/proxy_resolution/proxy_config.h"
 #include "net/proxy_resolution/proxy_config_service_fixed.h"
 #endif
@@ -46,7 +46,7 @@ void SetUpOnNetworkThread(
     base::WaitableEvent* initialization_complete_event) {
   net::URLRequestContextBuilder url_request_context_builder;
   url_request_context_builder.set_user_agent(GetUserAgent());
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // On Linux, use a fixed ProxyConfigService, since the default one
   // depends on glib.
   //
diff --git a/chromium/sandbox/features.gni b/chromium/sandbox/features.gni
index db30ae6..68985ed 100644
--- a/chromium/sandbox/features.gni
+++ b/chromium/sandbox/features.gni
@@ -8,7 +8,7 @@ import("//build/config/nacl/config.gni")
 # currently.
 # Do not disable seccomp_bpf anywhere without talking to
 # security@chromium.org!
-use_seccomp_bpf = (is_linux || is_chromeos || is_android) &&
+use_seccomp_bpf = (is_linux || is_chromeos || is_android) && !is_haiku &&
                   (current_cpu == "x86" || current_cpu == "x64" ||
                    current_cpu == "arm" || current_cpu == "arm64" ||
                    current_cpu == "mipsel" || current_cpu == "mips64el")
diff --git a/chromium/sandbox/linux/BUILD.gn b/chromium/sandbox/linux/BUILD.gn
index 1d080c0..2015d06 100644
--- a/chromium/sandbox/linux/BUILD.gn
+++ b/chromium/sandbox/linux/BUILD.gn
@@ -19,12 +19,12 @@ import("//build/config/deprecated_default_sources_assignment_filter.gni")
 set_sources_assignment_filter(deprecated_default_sources_assignment_filter)
 
 declare_args() {
-  compile_suid_client = is_linux || is_chromeos
+  compile_suid_client = (is_linux && !is_haiku) || is_chromeos
 
-  compile_credentials = is_linux || is_chromeos
+  compile_credentials = (is_linux && !is_haiku) || is_chromeos
 
   # On Android, use plain GTest.
-  use_base_test_suite = is_linux || is_chromeos
+  use_base_test_suite = (is_linux && !is_haiku) || is_chromeos
 }
 
 if (is_nacl_nonsfi) {
@@ -386,14 +386,17 @@ component("sandbox_services") {
     public_deps += [ ":sandbox_services_headers" ]
   }
 
-  if (is_nacl_nonsfi) {
-    cflags = [ "-fgnu-inline-asm" ]
-
+  if (is_nacl_nonsfi || is_haiku) {
+    if (is_nacl_nonsfi) {
+      cflags = [ "-fgnu-inline-asm" ]
+    }
     sources -= [
       "services/init_process_reaper.cc",
       "services/init_process_reaper.h",
       "services/scoped_process.cc",
       "services/scoped_process.h",
+      "services/syscall_wrappers.cc",
+      "services/syscall_wrappers.h",
       "services/yama.cc",
       "services/yama.h",
       "syscall_broker/broker_channel.cc",
@@ -417,6 +420,10 @@ component("sandbox_services") {
       "syscall_broker/syscall_dispatcher.cc",
       "syscall_broker/syscall_dispatcher.h",
     ]
+    sources += [
+      "services/libc_interceptor.cc",
+      "services/libc_interceptor.h",
+    ]
   } else if (!is_android) {
     sources += [
       "services/libc_interceptor.cc",
diff --git a/chromium/sandbox/linux/services/libc_interceptor.cc b/chromium/sandbox/linux/services/libc_interceptor.cc
index 7c73b7e..91f79f5 100644
--- a/chromium/sandbox/linux/services/libc_interceptor.cc
+++ b/chromium/sandbox/linux/services/libc_interceptor.cc
@@ -11,7 +11,9 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
+#if !defined(OS_HAIKU)
 #include <sys/prctl.h>
+#endif
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <time.h>
@@ -93,7 +95,7 @@ bool ReadTimeStruct(base::PickleIterator* iter,
   } else {
     base::AutoLock lock(g_timezones_lock.Get());
     auto ret_pair = g_timezones.Get().insert(timezone);
-    output->tm_zone = ret_pair.first->c_str();
+    output->tm_zone = (char*)ret_pair.first->c_str();
   }
 
   return true;
diff --git a/chromium/sandbox/policy/BUILD.gn b/chromium/sandbox/policy/BUILD.gn
index ccb1bd1..db1fa75 100644
--- a/chromium/sandbox/policy/BUILD.gn
+++ b/chromium/sandbox/policy/BUILD.gn
@@ -27,7 +27,7 @@ component("policy") {
     "//sandbox:common",
   ]
   public_deps = []
-  if (is_linux || is_chromeos) {
+  if ((is_linux || is_chromeos) && !is_haiku) {
     sources += [
       "linux/bpf_audio_policy_linux.cc",
       "linux/bpf_audio_policy_linux.h",
diff --git a/chromium/sandbox/policy/switches.cc b/chromium/sandbox/policy/switches.cc
index 3afb876..2c8efbe 100644
--- a/chromium/sandbox/policy/switches.cc
+++ b/chromium/sandbox/policy/switches.cc
@@ -81,7 +81,7 @@ const char kGpuSandboxFailuresFatal[] = "gpu-sandbox-failures-fatal";
 // Meant to be used as a browser-level switch for testing purposes only.
 const char kNoSandbox[] = "no-sandbox";
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // Instructs the zygote to launch without a sandbox. Processes forked from this
 // type of zygote will apply their own custom sandboxes later.
 const char kNoZygoteSandbox[] = "no-zygote-sandbox";
diff --git a/chromium/sandbox/policy/switches.h b/chromium/sandbox/policy/switches.h
index e096e96..6d25e2c 100644
--- a/chromium/sandbox/policy/switches.h
+++ b/chromium/sandbox/policy/switches.h
@@ -53,7 +53,7 @@ SANDBOX_POLICY_EXPORT extern const char kDisableSetuidSandbox[];
 SANDBOX_POLICY_EXPORT extern const char kGpuSandboxAllowSysVShm[];
 SANDBOX_POLICY_EXPORT extern const char kGpuSandboxFailuresFatal[];
 SANDBOX_POLICY_EXPORT extern const char kNoSandbox[];
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 SANDBOX_POLICY_EXPORT extern const char kNoZygoteSandbox[];
 #endif
 #if defined(OS_WIN)
diff --git a/chromium/services/audio/BUILD.gn b/chromium/services/audio/BUILD.gn
index 84b197a..865fca1 100644
--- a/chromium/services/audio/BUILD.gn
+++ b/chromium/services/audio/BUILD.gn
@@ -73,7 +73,7 @@ source_set("audio") {
     "//services/audio/public/mojom",
   ]
 
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     sources += [
       "audio_sandbox_hook_linux.cc",
       "audio_sandbox_hook_linux.h",
diff --git a/chromium/services/device/geolocation/location_arbitrator.cc b/chromium/services/device/geolocation/location_arbitrator.cc
index 7da9b47..fd4d3ca 100644
--- a/chromium/services/device/geolocation/location_arbitrator.cc
+++ b/chromium/services/device/geolocation/location_arbitrator.cc
@@ -159,7 +159,7 @@ LocationArbitrator::NewNetworkLocationProvider(
 
 std::unique_ptr<LocationProvider>
 LocationArbitrator::NewSystemLocationProvider() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
   return nullptr;
 #else
   return device::NewSystemLocationProvider();
diff --git a/chromium/services/device/usb/BUILD.gn b/chromium/services/device/usb/BUILD.gn
index f2d4524..50bb41c 100644
--- a/chromium/services/device/usb/BUILD.gn
+++ b/chromium/services/device/usb/BUILD.gn
@@ -125,7 +125,7 @@ static_library("usb") {
     deps += [ "//third_party/re2" ]
   }
 
-  if (is_android || is_chromeos || is_linux) {
+  if ((is_android || is_chromeos || is_linux) && !is_haiku) {
     sources += [
       "usb_device_handle_usbfs.cc",
       "usb_device_handle_usbfs.h",
diff --git a/chromium/services/network/BUILD.gn b/chromium/services/network/BUILD.gn
index da00765..691c791 100644
--- a/chromium/services/network/BUILD.gn
+++ b/chromium/services/network/BUILD.gn
@@ -268,6 +268,11 @@ jumbo_component("network_service") {
       "//sandbox/policy",
     ]
   }
+  if (is_haiku) {
+    deps -= [
+      "//sandbox/linux:sandbox_services",
+    ]
+  }
 
   if (is_android) {
     deps += [
diff --git a/chromium/services/network/network_context.cc b/chromium/services/network/network_context.cc
index 035ee94..7b57b5d 100644
--- a/chromium/services/network/network_context.cc
+++ b/chromium/services/network/network_context.cc
@@ -1932,7 +1932,7 @@ URLRequestContextOwner NetworkContext::MakeURLRequestContext(
 
     net::CookieCryptoDelegate* crypto_delegate = nullptr;
     if (params_->enable_encrypted_cookies) {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_CHROMECAST)
+#if (defined(OS_LINUX) || defined(OS_HAIKU)) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_CHROMECAST)
       DCHECK(network_service_->os_crypt_config_set())
           << "NetworkService::SetCryptConfig must be called before creating a "
              "NetworkContext with encrypted cookies.";
diff --git a/chromium/services/network/network_sandbox_hook_linux.cc b/chromium/services/network/network_sandbox_hook_linux.cc
index feb61a7..0a1950f 100644
--- a/chromium/services/network/network_sandbox_hook_linux.cc
+++ b/chromium/services/network/network_sandbox_hook_linux.cc
@@ -14,6 +14,7 @@ using sandbox::syscall_broker::MakeBrokerCommandSet;
 namespace network {
 
 bool NetworkPreSandboxHook(sandbox::policy::SandboxLinux::Options options) {
+#if !defined(OS_HAIKU)
   auto* instance = sandbox::policy::SandboxLinux::GetInstance();
 
   // TODO(tsepez): remove universal permission under filesytem root.
@@ -32,6 +33,7 @@ bool NetworkPreSandboxHook(sandbox::policy::SandboxLinux::Options options) {
       sandbox::policy::SandboxLinux::PreSandboxHook(), options);
 
   instance->EngageNamespaceSandboxIfPossible();
+#endif
   return true;
 }
 
diff --git a/chromium/services/network/network_service.cc b/chromium/services/network/network_service.cc
index ed5edbf..0eb3727 100644
--- a/chromium/services/network/network_service.cc
+++ b/chromium/services/network/network_service.cc
@@ -70,7 +70,7 @@
 #include "third_party/boringssl/src/include/openssl/cpu.h"
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_CHROMECAST)
+#if (defined(OS_LINUX) || defined(OS_HAIKU)) && !defined(OS_CHROMEOS) && !BUILDFLAG(IS_CHROMECAST)
 #include "components/os_crypt/key_storage_config_linux.h"
 #endif
 
@@ -670,7 +670,7 @@ void NetworkService::OnCertDBChanged() {
   net::CertDatabase::GetInstance()->NotifyObserversCertDBChanged();
 }
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
 void NetworkService::SetCryptConfig(mojom::CryptConfigPtr crypt_config) {
 #if !BUILDFLAG(IS_CHROMECAST) && !defined(TOOLKIT_QT)
   DCHECK(!os_crypt_config_set_);
diff --git a/chromium/services/network/network_service.h b/chromium/services/network/network_service.h
index 21b8da7..3f92e23 100644
--- a/chromium/services/network/network_service.h
+++ b/chromium/services/network/network_service.h
@@ -196,7 +196,7 @@ class COMPONENT_EXPORT(NETWORK_SERVICE) NetworkService
       base::span<const uint8_t> config,
       mojom::NetworkService::UpdateLegacyTLSConfigCallback callback) override;
   void OnCertDBChanged() override;
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
   void SetCryptConfig(mojom::CryptConfigPtr crypt_config) override;
 #endif
 #if defined(OS_WIN) || defined(OS_MAC)
diff --git a/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h b/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
index 1fdd28f..2f2b0fa 100644
--- a/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
+++ b/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
@@ -45,9 +45,9 @@ class COMPONENT_EXPORT(
                                     mojom::RawOSMemDump*);
   static std::vector<mojom::VmRegionPtr> GetProcessMemoryMaps(base::ProcessId);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)  || defined(OS_HAIKU)
   static void SetProcSmapsForTesting(FILE*);
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 
  private:
   FRIEND_TEST_ALL_PREFIXES(OSMetricsTest, ParseProcSmaps);
@@ -61,7 +61,7 @@ class COMPONENT_EXPORT(
   static std::vector<mojom::VmRegionPtr> GetProcessModules(base::ProcessId);
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
   // Provides information on the dump state of resident pages. These values are
   // written to logs. New enum values can be added, but existing enums must
   // never be renumbered or deleted and reused.
@@ -96,7 +96,7 @@ class COMPONENT_EXPORT(
   // TODO(chiniforooshan): move to /base/process/process_metrics_linux.cc after
   // making sure that peak RSS is useful.
   static size_t GetPeakResidentSetSize(base::ProcessId pid);
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 };
 
 }  // namespace memory_instrumentation
diff --git a/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc b/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc
index 9c329cb..e598c3d 100644
--- a/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc
+++ b/chromium/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc
@@ -5,7 +5,6 @@
 #include <dlfcn.h>
 #include <fcntl.h>
 #include <stdint.h>
-#include <sys/prctl.h>
 
 #include <memory>
 
@@ -27,8 +26,14 @@
 #include "build/build_config.h"
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h"
 
+#if !defined(OS_HAIKU)
+#include <sys/prctl.h>
+#endif
+
 // Symbol with virtual address of the start of ELF header of the current binary.
+#if !defined(OS_HAIKU)
 extern char __ehdr_start;
+#endif
 
 namespace memory_instrumentation {
 
@@ -91,6 +96,7 @@ struct ModuleData {
 
 ModuleData GetMainModuleData() {
   ModuleData module_data;
+#if !defined(OS_HAIKU)
   Dl_info dl_info;
   if (dladdr(&__ehdr_start, &dl_info)) {
     base::debug::ElfBuildIdBuffer build_id;
@@ -101,6 +107,7 @@ ModuleData GetMainModuleData() {
       module_data.build_id = std::string(build_id, build_id_length);
     }
   }
+#endif
   return module_data;
 }
 
@@ -148,14 +155,14 @@ bool ParseSmapsHeader(const char* header_line,
   // Build ID is needed to symbolize heap profiles, and is generated only on
   // official builds. Build ID is only added for the current library (chrome)
   // since it is racy to read other libraries which can be unmapped any time.
-#if defined(OFFICIAL_BUILD)
+#if defined(OFFICIAL_BUILD) && !defined(OS_HAIKU)
   if (!region->mapped_file.empty() &&
       base::StartsWith(main_module_data.path, region->mapped_file,
                        base::CompareCase::SENSITIVE) &&
       !main_module_data.build_id.empty()) {
     region->module_debugid = main_module_data.build_id;
   }
-#endif  // defined(OFFICIAL_BUILD)
+#endif  // defined(OFFICIAL_BUILD) && !defined(OS_HAIKU)
 
   return res;
 }
@@ -238,6 +245,7 @@ uint32_t ReadLinuxProcSmapsFile(FILE* smaps_file,
 class ScopedProcessSetDumpable {
  public:
   ScopedProcessSetDumpable() {
+#if !defined(OS_HAIKU)
     int result = prctl(PR_GET_DUMPABLE, 0, 0, 0, 0);
     if (result < 0) {
       PLOG(ERROR) << "prctl";
@@ -253,15 +261,20 @@ class ScopedProcessSetDumpable {
         AvoidPrctlOnDestruction();
       }
     }
+#else
+    was_dumpable_ = true;
+#endif
   }
 
   ScopedProcessSetDumpable(const ScopedProcessSetDumpable&) = delete;
   ScopedProcessSetDumpable& operator=(const ScopedProcessSetDumpable&) = delete;
 
   ~ScopedProcessSetDumpable() {
+#if !defined(OS_HAIKU)
     if (!was_dumpable_) {
       PCHECK(prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) == 0) << "prctl";
     }
+#endif
   }
 
  private:
@@ -284,6 +297,7 @@ bool OSMetrics::FillOSMemoryDump(base::ProcessId pid,
                                  mojom::RawOSMemDump* dump) {
   // TODO(chiniforooshan): There is no need to read both /statm and /status
   // files. Refactor to get everything from /status using ProcessMetric.
+#if !defined(OS_HAIKU)
   auto statm_file = GetProcPidDir(pid).Append("statm");
   auto autoclose = base::ScopedFD(open(statm_file.value().c_str(), O_RDONLY));
   int statm_fd = autoclose.get();
@@ -298,7 +312,10 @@ bool OSMetrics::FillOSMemoryDump(base::ProcessId pid,
 
   if (!success)
     return false;
-
+#else
+  uint64_t resident_pages = 0;
+  uint64_t shared_pages = 0;
+#endif
   auto process_metrics = CreateProcessMetrics(pid);
 
   const static size_t page_size = base::GetPageSize();
@@ -366,6 +383,10 @@ OSMetrics::MappedAndResidentPagesDumpState OSMetrics::GetMappedAndResidentPages(
     const size_t start_address,
     const size_t end_address,
     std::vector<uint8_t>* accessed_pages_bitmap) {
+#if defined(OS_HAIKU)
+  NOTIMPLEMENTED();
+  return OSMetrics::MappedAndResidentPagesDumpState::kFailure;
+#else
   const char* kPagemap = "/proc/self/pagemap";
 
   base::ScopedFILE pagemap_file(fopen(kPagemap, "r"));
@@ -413,6 +434,7 @@ OSMetrics::MappedAndResidentPagesDumpState OSMetrics::GetMappedAndResidentPages(
     }
   }
   return OSMetrics::MappedAndResidentPagesDumpState::kSuccess;
+#endif
 }
 
 // static
diff --git a/chromium/services/service_manager/public/cpp/service_executable/BUILD.gn b/chromium/services/service_manager/public/cpp/service_executable/BUILD.gn
index 4c1c496..85897a8 100644
--- a/chromium/services/service_manager/public/cpp/service_executable/BUILD.gn
+++ b/chromium/services/service_manager/public/cpp/service_executable/BUILD.gn
@@ -29,6 +29,12 @@ source_set("support") {
       "//sandbox/linux:seccomp_bpf",
     ]
   }
+  if (is_haiku) {
+    deps -= [
+      "//sandbox/linux:seccomp_bpf",
+    ]
+  }
+
 }
 
 source_set("switches") {
diff --git a/chromium/skia/ext/platform_canvas.h b/chromium/skia/ext/platform_canvas.h
index dd6d354..1269913 100644
--- a/chromium/skia/ext/platform_canvas.h
+++ b/chromium/skia/ext/platform_canvas.h
@@ -58,7 +58,7 @@ SK_API HDC GetNativeDrawingContext(SkCanvas* canvas);
 
 #elif defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__) || \
     defined(__sun) || defined(ANDROID) || defined(__APPLE__) ||             \
-    defined(__Fuchsia__)
+    defined(__Fuchsia__) || defined(__HAIKU__)
 // Construct a canvas from the given memory region. The memory is not cleared
 // first. @data must be, at least, @height * StrideForWidth(@width) bytes.
 SK_API std::unique_ptr<SkCanvas> CreatePlatformCanvasWithPixels(
diff --git a/chromium/third_party/abseil-cpp/absl/base/config.h b/chromium/third_party/abseil-cpp/absl/base/config.h
index 84fa893..62c0989 100644
--- a/chromium/third_party/abseil-cpp/absl/base/config.h
+++ b/chromium/third_party/abseil-cpp/absl/base/config.h
@@ -377,7 +377,7 @@ static_assert(ABSL_INTERNAL_INLINE_NAMESPACE_STR[0] != 'h' ||
 #elif defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) ||   \
     defined(__ros__) || defined(__native_client__) || defined(__asmjs__) || \
     defined(__wasm__) || defined(__Fuchsia__) || defined(__sun) || \
-    defined(__ASYLO__)
+    defined(__ASYLO__) || defined(__HAIKU__)
 #define ABSL_HAVE_MMAP 1
 #endif
 
diff --git a/chromium/third_party/angle/BUILD.gn b/chromium/third_party/angle/BUILD.gn
index fb57176..6079c31 100644
--- a/chromium/third_party/angle/BUILD.gn
+++ b/chromium/third_party/angle/BUILD.gn
@@ -272,8 +272,8 @@ config("angle_no_cfi_unrelated_cast") {
 
 angle_source_set("angle_system_utils") {
   sources = angle_system_utils_sources
-  if (is_linux || is_chromeos) {
-    libs = [ "dl" ]
+  if ((is_linux && !is_haiku) || is_chromeos) {
+    libs = [ "dl15" ]
   }
 }
 
diff --git a/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.cpp b/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.cpp
index 5db5784..035e011 100644
--- a/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.cpp
+++ b/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.cpp
@@ -17,7 +17,7 @@
 #    include <sys/system_properties.h>
 #endif
 
-#if defined(ANGLE_PLATFORM_LINUX)
+#if defined(ANGLE_PLATFORM_POSIX)
 #    include <sys/utsname.h>
 #endif
 
@@ -207,7 +207,7 @@ OSVersion GetMacOSVersion()
 }
 #endif
 
-#if defined(ANGLE_PLATFORM_LINUX)
+#if defined(ANGLE_PLATFORM_POSIX)
 bool ParseLinuxOSVersion(const char *version, int *major, int *minor, int *patch)
 {
     errno = 0;  // reset global error flag.
@@ -219,6 +219,13 @@ bool ParseLinuxOSVersion(const char *version, int *major, int *minor, int *patch
     }
 
     *minor = static_cast<int>(strtol(next + 1, &next, 10));
+#ifdef __HAIKU__
+    if (next == nullptr || *next != '.' || errno != 0)
+    {
+        return false;
+    }
+	*patch = 0;
+#else
     if (next == nullptr || *next != '.' || errno != 0)
     {
         return false;
@@ -229,7 +236,7 @@ bool ParseLinuxOSVersion(const char *version, int *major, int *minor, int *patch
     {
         return false;
     }
-
+#endif
     return true;
 }
 #endif
diff --git a/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.h b/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.h
index 054a8a9..8b0ce4d 100644
--- a/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.h
+++ b/chromium/third_party/angle/src/libANGLE/renderer/driver_utils.h
@@ -145,7 +145,7 @@ inline bool IsWindows()
 
 inline bool IsLinux()
 {
-#if defined(ANGLE_PLATFORM_LINUX)
+#if defined(ANGLE_PLATFORM_POSIX)
     return true;
 #else
     return false;
diff --git a/chromium/third_party/angle/src/libANGLE/renderer/vulkan/DisplayVk_api.h b/chromium/third_party/angle/src/libANGLE/renderer/vulkan/DisplayVk_api.h
index 21e36a7..7565f55 100644
--- a/chromium/third_party/angle/src/libANGLE/renderer/vulkan/DisplayVk_api.h
+++ b/chromium/third_party/angle/src/libANGLE/renderer/vulkan/DisplayVk_api.h
@@ -19,10 +19,10 @@ bool IsVulkanWin32DisplayAvailable();
 DisplayImpl *CreateVulkanWin32Display(const egl::DisplayState &state);
 #endif  // defined(ANGLE_PLATFORM_WINDOWS)
 
-#if defined(ANGLE_PLATFORM_LINUX)
+#if defined(ANGLE_PLATFORM_POSIX)
 bool IsVulkanXcbDisplayAvailable();
 DisplayImpl *CreateVulkanXcbDisplay(const egl::DisplayState &state);
-#endif  // defined(ANGLE_PLATFORM_LINUX)
+#endif  // defined(ANGLE_PLATFORM_POSIX)
 
 #if defined(ANGLE_PLATFORM_ANDROID)
 bool IsVulkanAndroidDisplayAvailable();
diff --git a/chromium/third_party/angle/third_party/vulkan-loader/src/loader/loader.c b/chromium/third_party/angle/third_party/vulkan-loader/src/loader/loader.c
index 4d8865e..589c674 100644
--- a/chromium/third_party/angle/third_party/vulkan-loader/src/loader/loader.c
+++ b/chromium/third_party/angle/third_party/vulkan-loader/src/loader/loader.c
@@ -250,7 +250,7 @@ void *loader_device_heap_realloc(const struct loader_device *device, void *pMemo
 }
 
 // Environment variables
-#if defined(__linux__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__APPLE__) || defined(__HAIKU__)
 
 static inline bool IsHighIntegrity() {
     return geteuid() != getuid() || getegid() != getgid();
diff --git a/chromium/third_party/angle/third_party/vulkan-loader/src/loader/vk_loader_platform.h b/chromium/third_party/angle/third_party/vulkan-loader/src/loader/vk_loader_platform.h
index e227bf0..a7a03d8 100644
--- a/chromium/third_party/angle/third_party/vulkan-loader/src/loader/vk_loader_platform.h
+++ b/chromium/third_party/angle/third_party/vulkan-loader/src/loader/vk_loader_platform.h
@@ -31,7 +31,7 @@
 #include "vulkan/vk_platform.h"
 #include "vulkan/vk_sdk_platform.h"
 
-#if defined(__linux__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__APPLE__) || defined (__HAIKU__)
 /* Linux-specific common code: */
 
 // Headers:
diff --git a/chromium/third_party/blink/renderer/BUILD.gn b/chromium/third_party/blink/renderer/BUILD.gn
index d36c9cd..00a1ed7 100644
--- a/chromium/third_party/blink/renderer/BUILD.gn
+++ b/chromium/third_party/blink/renderer/BUILD.gn
@@ -55,8 +55,8 @@ config("inside_blink") {
       "-Wconversion",
       "-Wno-float-conversion",
       "-Wno-sign-conversion",
-      "-Wno-implicit-float-conversion",
-      "-Wno-implicit-int-conversion",
+#      "-Wno-implicit-float-conversion",
+#      "-Wno-implicit-int-conversion",
     ]
 
     if (!is_chromeos || default_toolchain != "//build/toolchain/cros:target") {
diff --git a/chromium/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc b/chromium/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
index ec7bcf3..f5f761a 100644
--- a/chromium/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
+++ b/chromium/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
@@ -438,9 +438,11 @@ ScriptEvaluationResult V8ScriptRunner::CompileAndRunScript(
             .ToLocal(&script)) {
       maybe_result =
           V8ScriptRunner::RunCompiledScript(isolate, script, execution_context);
+#ifndef Q_OS_HAIKU
       probe::ProduceCompilationCache(probe::ToCoreProbeSink(execution_context),
                                      source, script);
       V8CodeCache::ProduceCache(isolate, script, source, produce_cache_options);
+#endif
     }
 
     // TODO(crbug/1114601): Investigate whether to check CanContinue() in other
diff --git a/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py b/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py
index 017d3d4..899a85e 100644
--- a/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py
+++ b/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py
@@ -29,6 +29,9 @@ def init(root_src_dir):
     elif sys.platform.startswith(("cygwin", "win")):
         platform = "win"
         exe_suffix = ".exe"
+    elif sys.platform.startswith("haiku"):
+        platform = "haiku"
+        exe_suffix = ""
     else:
         assert False, "Unknown platform: {}".format(sys.platform)
     buildtools_platform_dir = os.path.join(root_src_dir, "buildtools",
diff --git a/chromium/third_party/blink/renderer/controller/blink_initializer.cc b/chromium/third_party/blink/renderer/controller/blink_initializer.cc
index 0231bcf..dee9523 100644
--- a/chromium/third_party/blink/renderer/controller/blink_initializer.cc
+++ b/chromium/third_party/blink/renderer/controller/blink_initializer.cc
@@ -68,11 +68,12 @@
 #include "third_party/blink/renderer/controller/oom_intervention_impl.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "third_party/blink/renderer/controller/memory_usage_monitor_posix.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU) || \
     defined(OS_MAC) || defined(OS_WIN)
 #include "third_party/blink/renderer/controller/highest_pmf_reporter.h"
 #include "third_party/blink/renderer/controller/user_level_memory_pressure_signal_generator.h"
@@ -154,7 +155,7 @@ void InitializeCommon(Platform* platform, mojo::BinderMap* binders) {
   CrashMemoryMetricsReporterImpl::Instance();
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU) || \
     defined(OS_MAC) || defined(OS_WIN)
   // Initialize UserLevelMemoryPressureSignalGenerator so it starts monitoring.
   if (UserLevelMemoryPressureSignalGenerator::Enabled())
@@ -212,7 +213,7 @@ void BlinkInitializer::RegisterInterfaces(mojo::BinderMap& binders) {
               main_thread->GetTaskRunner());
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   binders.Add(ConvertToBaseRepeatingCallback(
                   CrossThreadBindRepeating(&MemoryUsageMonitorPosix::Bind)),
               main_thread->GetTaskRunner());
diff --git a/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.cc b/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.cc
index 27b6056..f437dea 100644
--- a/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.cc
+++ b/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.cc
@@ -134,7 +134,7 @@ void MemoryUsageMonitorPosix::SetProcFiles(base::File statm_file,
   status_fd_.reset(status_file.TakePlatformFile());
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // static
 void MemoryUsageMonitorPosix::Bind(
     mojo::PendingReceiver<mojom::blink::MemoryUsageMonitorLinux> receiver) {
diff --git a/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.h b/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.h
index 5e338d6..4165132 100644
--- a/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.h
+++ b/chromium/third_party/blink/renderer/controller/memory_usage_monitor_posix.h
@@ -12,7 +12,7 @@
 #include "third_party/blink/renderer/controller/controller_export.h"
 #include "third_party/blink/renderer/controller/memory_usage_monitor.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "third_party/blink/public/mojom/memory_usage_monitor_linux.mojom-blink.h"
 #endif
 
@@ -21,7 +21,7 @@ namespace blink {
 // MemoryUsageMonitor implementation for Android and Linux.
 class CONTROLLER_EXPORT MemoryUsageMonitorPosix
     : public MemoryUsageMonitor
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     ,
       public mojom::blink::MemoryUsageMonitorLinux
 #endif
@@ -29,7 +29,7 @@ class CONTROLLER_EXPORT MemoryUsageMonitorPosix
  public:
   MemoryUsageMonitorPosix() = default;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   static void Bind(
       mojo::PendingReceiver<mojom::blink::MemoryUsageMonitorLinux> receiver);
 #endif
@@ -47,7 +47,7 @@ class CONTROLLER_EXPORT MemoryUsageMonitorPosix
                                               uint64_t* vm_size,
                                               uint64_t* vm_hwm_size);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // mojom::MemoryUsageMonitorLinux implementations:
   void SetProcFiles(base::File statm_file, base::File status_file) override;
 #endif
@@ -65,7 +65,7 @@ class CONTROLLER_EXPORT MemoryUsageMonitorPosix
   base::ScopedFD statm_fd_;
   base::ScopedFD status_fd_;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   mojo::Receiver<mojom::blink::MemoryUsageMonitorLinux> receiver_{this};
 #endif
 };
diff --git a/chromium/third_party/blink/renderer/core/editing/editing_behavior.cc b/chromium/third_party/blink/renderer/core/editing/editing_behavior.cc
index f1406f4..bf47396 100644
--- a/chromium/third_party/blink/renderer/core/editing/editing_behavior.cc
+++ b/chromium/third_party/blink/renderer/core/editing/editing_behavior.cc
@@ -274,7 +274,7 @@ bool EditingBehavior::ShouldInsertCharacter(const KeyboardEvent& event) const {
   // unexpected behaviour
   if (ch < ' ')
     return false;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // According to XKB map no keyboard combinations with ctrl key are mapped to
   // printable characters, however we need the filter as the DomKey/text could
   // contain printable characters.
diff --git a/chromium/third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc b/chromium/third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
index 9b16d60..b98ca1a 100644
--- a/chromium/third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
+++ b/chromium/third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
@@ -44,7 +44,7 @@ constexpr base::TimeDelta kEncodeRowSlackBeforeDeadline =
 
 /* The value is based on user statistics on Nov 2017. */
 #if (defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-     defined(OS_WIN))
+     defined(OS_WIN)) || defined(OS_HAIKU)
 const double kIdleTaskStartTimeoutDelayMs = 1000.0;
 #else
 const double kIdleTaskStartTimeoutDelayMs = 4000.0;  // For ChromeOS, Mobile
diff --git a/chromium/third_party/blink/renderer/core/html/forms/internal_popup_menu.cc b/chromium/third_party/blink/renderer/core/html/forms/internal_popup_menu.cc
index 49400d6..3ea2e10 100644
--- a/chromium/third_party/blink/renderer/core/html/forms/internal_popup_menu.cc
+++ b/chromium/third_party/blink/renderer/core/html/forms/internal_popup_menu.cc
@@ -155,7 +155,7 @@ class InternalPopupMenu::ItemIterationContext {
         is_in_group_(false),
         buffer_(buffer) {
     DCHECK(buffer_);
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     // On other platforms, the <option> background color is the same as the
     // <select> background color. On Linux, that makes the <option>
     // background color very dark, so by default, try to use a lighter
diff --git a/chromium/third_party/blink/renderer/core/inspector/inspector_memory_agent.cc b/chromium/third_party/blink/renderer/core/inspector/inspector_memory_agent.cc
index d475b44..e25ff1f 100644
--- a/chromium/third_party/blink/renderer/core/inspector/inspector_memory_agent.cc
+++ b/chromium/third_party/blink/renderer/core/inspector/inspector_memory_agent.cc
@@ -186,7 +186,7 @@ InspectorMemoryAgent::GetSamplingProfileById(uint32_t id) {
 
 Vector<String> InspectorMemoryAgent::Symbolize(
     const WebVector<void*>& addresses) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // TODO(alph): Move symbolization to the client.
   Vector<void*> addresses_to_symbolize;
   for (size_t i = 0; i < addresses.size(); i++) {
diff --git a/chromium/third_party/blink/renderer/core/layout/layout_view.cc b/chromium/third_party/blink/renderer/core/layout/layout_view.cc
index d5fedf7..2ed4d00 100644
--- a/chromium/third_party/blink/renderer/core/layout/layout_view.cc
+++ b/chromium/third_party/blink/renderer/core/layout/layout_view.cc
@@ -62,7 +62,7 @@
 #include "third_party/blink/renderer/platform/instrumentation/tracing/traced_value.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #endif
 
@@ -347,7 +347,7 @@ void LayoutView::UpdateLayout() {
   DCHECK(!layout_state_);
   LayoutState root_layout_state(*this);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // The font code in FontPlatformData does not have a direct connection to the
   // document, the frame or anything from which we could retrieve the device
   // scale factor. After using zoom for DSF, the GraphicsContext does only ever
diff --git a/chromium/third_party/blink/renderer/core/paint/paint_layer.cc b/chromium/third_party/blink/renderer/core/paint/paint_layer.cc
index 9a84838..02e558a 100644
--- a/chromium/third_party/blink/renderer/core/paint/paint_layer.cc
+++ b/chromium/third_party/blink/renderer/core/paint/paint_layer.cc
@@ -110,7 +110,7 @@ namespace {
 static CompositingQueryMode g_compositing_query_mode =
     kCompositingQueriesAreOnlyAllowedInCertainDocumentLifecyclePhases;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 struct SameSizeAsPaintLayer : DisplayItemClient {
   // The bit fields may fit into the machine word of DisplayItemClient which
   // has only 8-bit data.
diff --git a/chromium/third_party/blink/renderer/core/scroll/scrollbar_theme_aura.cc b/chromium/third_party/blink/renderer/core/scroll/scrollbar_theme_aura.cc
index adc5e22..6800258 100644
--- a/chromium/third_party/blink/renderer/core/scroll/scrollbar_theme_aura.cc
+++ b/chromium/third_party/blink/renderer/core/scroll/scrollbar_theme_aura.cc
@@ -137,7 +137,7 @@ bool ScrollbarThemeAura::SupportsDragSnapBack() const {
 // Disable snapback on desktop Linux to better integrate with the desktop
 // behavior. Typically, Linux apps do not implement scrollbar snapback (this
 // is true for at least GTK and QT apps).
-#if (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
   return false;
 #else
   return true;
@@ -303,7 +303,7 @@ ScrollbarPart ScrollbarThemeAura::PartsToInvalidateOnThumbPositionChange(
 
 bool ScrollbarThemeAura::ShouldCenterOnThumb(const Scrollbar& scrollbar,
                                              const WebMouseEvent& event) {
-#if (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if ((defined(OS_HAIKU) || defined(OS_LINUX)) && !defined(OS_CHROMEOS))
   if (event.button == WebPointerProperties::Button::kMiddle)
     return true;
 #endif
diff --git a/chromium/third_party/blink/renderer/modules/mediastream/processed_local_audio_source.cc b/chromium/third_party/blink/renderer/modules/mediastream/processed_local_audio_source.cc
index 8678c7b..c7d7556 100644
--- a/chromium/third_party/blink/renderer/modules/mediastream/processed_local_audio_source.cc
+++ b/chromium/third_party/blink/renderer/modules/mediastream/processed_local_audio_source.cc
@@ -417,7 +417,7 @@ void ProcessedLocalAudioSource::CaptureUsingProcessor(
     bool key_pressed) {
 #if defined(OS_WIN) || defined(OS_MAC)
   DCHECK_LE(volume, 1.0);
-#elif (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_OPENBSD)
+#elif (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
   // We have a special situation on Linux where the microphone volume can be
   // "higher than maximum". The input volume slider in the sound preference
   // allows the user to set a scaling that is higher than 100%. It means that
diff --git a/chromium/third_party/blink/renderer/platform/fonts/font_cache.cc b/chromium/third_party/blink/renderer/platform/fonts/font_cache.cc
index 1ef0557..f5cde13 100644
--- a/chromium/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/chromium/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -80,7 +80,7 @@ const char kColorEmojiLocale[] = "und-Zsye";
 
 SkFontMgr* FontCache::static_font_manager_ = nullptr;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 float FontCache::device_scale_factor_ = 1.0;
 #endif
 
@@ -120,7 +120,7 @@ FontCache::FontCache()
 FontPlatformData* FontCache::SystemFontPlatformData(
     const FontDescription& font_description) {
   const AtomicString& family = FontCache::SystemFontFamily();
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
   if (family.IsEmpty() || family == font_family_names::kSystemUi)
     return nullptr;
 #else
diff --git a/chromium/third_party/blink/renderer/platform/fonts/font_cache.h b/chromium/third_party/blink/renderer/platform/fonts/font_cache.h
index 8706277..07e2f3a 100644
--- a/chromium/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/chromium/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -58,7 +58,7 @@
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "ui/gfx/font_fallback_linux.h"
 #endif
 
@@ -167,7 +167,7 @@ class PLATFORM_EXPORT FontCache {
   sk_sp<SkFontMgr> FontManager() { return font_manager_; }
   static void SetFontManager(sk_sp<SkFontMgr>);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // These are needed for calling QueryRenderStyleForStrike, since
   // gfx::GetFontRenderParams makes distinctions based on DSF.
   static float DeviceScaleFactor() { return device_scale_factor_; }
@@ -242,11 +242,11 @@ class PLATFORM_EXPORT FontCache {
       const FontDescription&);
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   static bool GetFontForCharacter(UChar32,
                                   const char* preferred_locale,
                                   gfx::FallbackFontData*);
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
   scoped_refptr<SimpleFontData> FontDataFromFontPlatformData(
       const FontPlatformData*,
@@ -320,12 +320,12 @@ class PLATFORM_EXPORT FontCache {
                                    const FontFaceCreationParams&,
                                    std::string& name);
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   static AtomicString GetFamilyNameForCharacter(SkFontMgr*,
                                                 UChar32,
                                                 const FontDescription&,
                                                 FontFallbackPriority);
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
   scoped_refptr<SimpleFontData> FallbackOnStandardFontStyle(
       const FontDescription&,
@@ -365,7 +365,7 @@ class PLATFORM_EXPORT FontCache {
   std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // defined(OS_WIN)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   static float device_scale_factor_;
 #endif
 
diff --git a/chromium/third_party/blink/renderer/platform/fonts/font_description.cc b/chromium/third_party/blink/renderer/platform/fonts/font_description.cc
index 4b2592e..6eb2025 100644
--- a/chromium/third_party/blink/renderer/platform/fonts/font_description.cc
+++ b/chromium/third_party/blink/renderer/platform/fonts/font_description.cc
@@ -39,7 +39,7 @@
 #include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_hasher.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #endif
 
@@ -239,7 +239,7 @@ FontCacheKey FontDescription::CacheKey(
       static_cast<unsigned>(fields_.orientation_) << 1 |          // bit 2-3
       static_cast<unsigned>(fields_.subpixel_text_position_);     // bit 1
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   float device_scale_factor_for_key = FontCache::DeviceScaleFactor();
 #else
   float device_scale_factor_for_key = 1.0f;
diff --git a/chromium/third_party/blink/renderer/platform/fonts/font_metrics.cc b/chromium/third_party/blink/renderer/platform/fonts/font_metrics.cc
index 52ba187..5b1e119 100644
--- a/chromium/third_party/blink/renderer/platform/fonts/font_metrics.cc
+++ b/chromium/third_party/blink/renderer/platform/fonts/font_metrics.cc
@@ -39,7 +39,7 @@
 namespace blink {
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
 // This is the largest VDMX table which we'll try to load and parse.
 static const size_t kMaxVDMXTableSize = 1024 * 1024;  // 1 MB
 #endif
@@ -69,7 +69,7 @@ void FontMetrics::AscentDescentWithHacks(
   bool is_vdmx_valid = false;
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
   // Manually digging up VDMX metrics is only applicable when bytecode hinting
   // using FreeType.  With DirectWrite or CoreText, no bytecode hinting is ever
   // done.  This code should be pushed into FreeType (hinted font metrics).
@@ -117,7 +117,7 @@ void FontMetrics::AscentDescentWithHacks(
     if (descent < metrics.fDescent) {
       visual_overflow_inflation_for_descent = 1;
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
       // When subpixel positioning is enabled, if the descent is rounded down,
       // the descent part of the glyph may be truncated when displayed in a
       // 'overflow: hidden' container.  To avoid that, borrow 1 unit from the
diff --git a/chromium/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.cc b/chromium/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.cc
index 6fce7e2..41c30b2 100644
--- a/chromium/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.cc
+++ b/chromium/third_party/blink/renderer/platform/fonts/font_unique_name_lookup.cc
@@ -8,7 +8,7 @@
 #if defined(OS_ANDROID)
 #include "third_party/blink/public/mojom/font_unique_name_lookup/font_unique_name_lookup.mojom-blink.h"
 #include "third_party/blink/renderer/platform/fonts/android/font_unique_name_lookup_android.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "third_party/blink/renderer/platform/fonts/linux/font_unique_name_lookup_linux.h"
 #elif defined(OS_WIN)
 #include "third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h"
@@ -23,7 +23,7 @@ std::unique_ptr<FontUniqueNameLookup>
 FontUniqueNameLookup::GetPlatformUniqueNameLookup() {
 #if defined(OS_ANDROID)
   return std::make_unique<FontUniqueNameLookupAndroid>();
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   return std::make_unique<FontUniqueNameLookupLinux>();
 #elif defined(OS_WIN)
   return std::make_unique<FontUniqueNameLookupWin>();
diff --git a/chromium/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/chromium/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index b962b21..9a13134 100644
--- a/chromium/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/chromium/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -61,7 +61,7 @@ AtomicString ToAtomicString(const SkString& str) {
   return AtomicString::FromUTF8(str.c_str(), str.size());
 }
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // This function is called on android or when we are emulating android fonts on
 // linux and the embedder has overriden the default fontManager with
 // WebFontRendering::setSkiaFontMgr.
@@ -84,7 +84,7 @@ AtomicString FontCache::GetFamilyNameForCharacter(
   typeface->getFamilyName(&skia_family_name);
   return ToAtomicString(skia_family_name);
 }
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 void FontCache::PlatformInit() {}
 
@@ -229,7 +229,7 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_WIN) || defined(OS_HAIKU)
   // On linux if the fontManager has been overridden then we should be calling
   // the embedder provided font Manager rather than calling
   // SkTypeface::CreateFromName which may redirect the call to the default font
@@ -256,7 +256,7 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
   std::string name;
 
   sk_sp<SkTypeface> typeface;
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (alternate_name == AlternateFontName::kLocalUniqueFace &&
       RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
     typeface = CreateTypefaceFromUniqueName(creation_params);
diff --git a/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc b/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
index c951d17..7b6cc51 100644
--- a/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
+++ b/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
@@ -897,8 +897,8 @@ void Unpack<WebGLImageConversion::kDataFormatBGRA8, uint8_t, uint8_t>(
   for (unsigned i = 0; i < pixels_per_row; ++i) {
     uint32_t bgra = source32[i];
 #if defined(ARCH_CPU_BIG_ENDIAN)
-    uint32_t brMask = 0xff00ff00;
-    uint32_t gaMask = 0x00ff00ff;
+    uint32_t br_mask = 0xff00ff00;
+    uint32_t ga_mask = 0x00ff00ff;
 #else
     uint32_t br_mask = 0x00ff00ff;
     uint32_t ga_mask = 0xff00ff00;
diff --git a/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc b/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc
index e315615..7f3599c 100644
--- a/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc
+++ b/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc
@@ -76,9 +76,9 @@ TEST_F(WebGLImageConversionTest, convertBGRA8toRGBA8) {
                              0x34567888, 0x12345678, 0x34567888,
                              0x12345678, 0x34567888, 0x12345678};
 #if defined(ARCH_CPU_BIG_ENDIAN)
-  uint32_t expectedData[9] = {0x56341278, 0x78563488, 0x56341278,
-                              0x78563488, 0x56341278, 0x78563488,
-                              0x56341278, 0x78563488, 0x56341278};
+  uint32_t expected_data[9] = {0x56341278, 0x78563488, 0x56341278,
+			       0x78563488, 0x56341278, 0x78563488,
+			       0x56341278, 0x78563488, 0x56341278};
 #else
   uint32_t expected_data[9] = {0x12785634, 0x34887856, 0x12785634,
                                0x34887856, 0x12785634, 0x34887856,
diff --git a/chromium/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc b/chromium/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc
index 7a51d09..137ecab 100644
--- a/chromium/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc
+++ b/chromium/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc
@@ -192,7 +192,7 @@ void VideoFrameSubmitter::OnBeginFrame(
     if (viz::FrameTokenGT(pair.key, *next_frame_token_))
       continue;
     auto& feedback = pair.value.presentation_feedback;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     // TODO: On Linux failure flag is unreliable, and perfectly rendered frames
     // are reported as failures all the time.
     bool presentation_failure = false;
diff --git a/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc b/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
index 33e1690..8ab66b3 100644
--- a/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
+++ b/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
@@ -54,23 +54,30 @@ extern "C" {
 #include <setjmp.h>
 }
 
-#if defined(ARCH_CPU_BIG_ENDIAN)
-#error Blink assumes a little-endian target.
-#endif
-
 #if defined(JCS_ALPHA_EXTENSIONS)
 #define TURBO_JPEG_RGB_SWIZZLE
-#if SK_B32_SHIFT  // Output little-endian RGBA pixels (Android).
+#if SK_PMCOLOR_BYTE_ORDER(R, G, B, A)
 inline J_COLOR_SPACE rgbOutputColorSpace() {
   return JCS_EXT_RGBA;
 }
-#else  // Output little-endian BGRA pixels.
+#elif SK_PMCOLOR_BYTE_ORDER(B, G, R, A)
 inline J_COLOR_SPACE rgbOutputColorSpace() {
   return JCS_EXT_BGRA;
 }
+#elif SK_PMCOLOR_BYTE_ORDER(A, R, G, B)
+inline J_COLOR_SPACE rgbOutputColorSpace() {
+  return JCS_EXT_ARGB;
+}
+#elif SK_PMCOLOR_BYTE_ORDER(A, B, G, R)
+inline J_COLOR_SPACE rgbOutputColorSpace() {
+  return JCS_EXT_ABGR;
+}
+#else
+#error Component order not supported by libjpeg_turbo
 #endif
 inline bool turboSwizzled(J_COLOR_SPACE colorSpace) {
-  return colorSpace == JCS_EXT_RGBA || colorSpace == JCS_EXT_BGRA;
+  return colorSpace == JCS_EXT_RGBA || colorSpace == JCS_EXT_BGRA ||
+    colorSpace == JCS_EXT_ABGR || colorSpace == JCS_EXT_ARGB;
 }
 #else
 inline J_COLOR_SPACE rgbOutputColorSpace() {
diff --git a/chromium/third_party/blink/renderer/platform/wtf/container_annotations.h b/chromium/third_party/blink/renderer/platform/wtf/container_annotations.h
index 584b905..03d9f83 100644
--- a/chromium/third_party/blink/renderer/platform/wtf/container_annotations.h
+++ b/chromium/third_party/blink/renderer/platform/wtf/container_annotations.h
@@ -11,7 +11,7 @@
 // TODO(ochang): Remove the ARCH_CPU_X86_64 condition to enable this for X86
 // once the crashes there have been fixed: http://crbug.com/461406
 #if defined(ADDRESS_SANITIZER) && \
-    (defined(OS_LINUX) || defined(OS_CHROMEOS)) && defined(ARCH_CPU_X86_64)
+    (defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)) && defined(ARCH_CPU_X86_64)
 #define ANNOTATE_CONTIGUOUS_CONTAINER
 #define ANNOTATE_NEW_BUFFER(buffer, capacity, newSize)                       \
   if (buffer) {                                                              \
@@ -36,13 +36,13 @@
   ANNOTATE_NEW_BUFFER(buffer, newCapacity, bufferSize);
 // Annotations require buffers to begin on an 8-byte boundary.
 
-#else  // ADDRESS_SANITIZER && (OS_LINUX || OS_CHROMEOS) && ARCH_CPU_X86_64
+#else  // ADDRESS_SANITIZER && (OS_LINUX || OS_CHROMEOS || defined(OS_HAIKU)) && ARCH_CPU_X86_64
 
 #define ANNOTATE_NEW_BUFFER(buffer, capacity, newSize)
 #define ANNOTATE_DELETE_BUFFER(buffer, capacity, oldSize)
 #define ANNOTATE_CHANGE_SIZE(buffer, capacity, oldSize, newSize)
 #define ANNOTATE_CHANGE_CAPACITY(buffer, oldCapacity, bufferSize, newCapacity)
 
-#endif  // ADDRESS_SANITIZER && (OS_LINUX || OS_CHROMEOS) && ARCH_CPU_X86_64
+#endif  // ADDRESS_SANITIZER && (OS_LINUX || OS_CHROMEOS || defined(OS_HAIKU)) && ARCH_CPU_X86_64
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_WTF_CONTAINER_ANNOTATIONS_H_
diff --git a/chromium/third_party/blink/renderer/platform/wtf/stack_util.cc b/chromium/third_party/blink/renderer/platform/wtf/stack_util.cc
index 71b901f..693dc37 100644
--- a/chromium/third_party/blink/renderer/platform/wtf/stack_util.cc
+++ b/chromium/third_party/blink/renderer/platform/wtf/stack_util.cc
@@ -14,10 +14,17 @@
 #include <stddef.h>
 #include <windows.h>
 #include <winnt.h>
+#elif defined(OS_HAIKU)
+#include <OS.h>
 #elif defined(__GLIBC__)
 extern "C" void* __libc_stack_end;  // NOLINT
 #endif
 
+#if defined(OS_HAIKU)
+#include <signal.h>
+#include <pthread.h>
+#endif
+
 namespace WTF {
 
 size_t GetUnderestimatedStackSize() {
@@ -89,7 +96,11 @@ size_t GetUnderestimatedStackSize() {
   }
   return pthread_get_stacksize_np(pthread_self());
 #elif defined(OS_WIN) && defined(COMPILER_MSVC)
-return Threading::ThreadStackSize();
+return WTF::internal::ThreadStackSize();
+#elif defined(OS_HAIKU)
+  thread_info threadInfo;
+  get_thread_info(find_thread(NULL), &threadInfo);
+  return (size_t)threadInfo.stack_end - (size_t)threadInfo.stack_base;
 #else
 #error "Stack frame size estimation not supported on this platform."
   return 0;
@@ -147,6 +158,10 @@ void* GetStackStart() {
   ::GetCurrentThreadStackLimits(&lowLimit, &highLimit);
   return reinterpret_cast<void*>(highLimit);
 #endif
+#elif defined(OS_HAIKU)
+  thread_info threadInfo;
+  get_thread_info(find_thread(NULL), &threadInfo);
+  return threadInfo.stack_end;
 #else
 #error Unsupported getStackStart on this platform.
 #endif
@@ -210,6 +225,21 @@ size_t ThreadStackSize() {
   thread_stack_size -= 4 * 0x1000;
   return thread_stack_size;
 }
+#elif defined(OS_HAIKU)
+size_t ThreadStackSize() {
+  thread_info threadInfo;
+  get_thread_info(find_thread(NULL), &threadInfo);
+  uint8_t* stack_end = reinterpret_cast<uint8_t*>(threadInfo.stack_end);
+  uint8_t* stack_start = reinterpret_cast<uint8_t*>(threadInfo.stack_base);
+  CHECK(stack_start);
+  // From BeBook (thread_info):
+  // The two stack pointers are currently inverted such that
+  // stack_base is less than stack_end.
+  // (In a stack-grows-down world, the base should be greater than the end.)
+  CHECK_GT(stack_end, stack_start);
+  size_t thread_stack_size = static_cast<size_t>(stack_start - stack_end);
+  return thread_stack_size;
+}
 #endif
 
 }  // namespace internal
diff --git a/chromium/third_party/blink/renderer/platform/wtf/stack_util.h b/chromium/third_party/blink/renderer/platform/wtf/stack_util.h
index c9c423c..f03d604 100644
--- a/chromium/third_party/blink/renderer/platform/wtf/stack_util.h
+++ b/chromium/third_party/blink/renderer/platform/wtf/stack_util.h
@@ -29,7 +29,7 @@ WTF_EXPORT extern uintptr_t g_main_thread_underestimated_stack_size;
 
 WTF_EXPORT void InitializeMainThreadStackEstimate();
 
-#if defined(OS_WIN) && defined(COMPILER_MSVC)
+#if defined(OS_HAIKU) || (defined(OS_WIN) && defined(COMPILER_MSVC))
 size_t ThreadStackSize();
 #endif
 
diff --git a/chromium/third_party/blink/renderer/platform/wtf/thread_specific.h b/chromium/third_party/blink/renderer/platform/wtf/thread_specific.h
index d691242..be111ad 100644
--- a/chromium/third_party/blink/renderer/platform/wtf/thread_specific.h
+++ b/chromium/third_party/blink/renderer/platform/wtf/thread_specific.h
@@ -105,7 +105,7 @@ inline bool ThreadSpecific<T>::IsSet() {
 template <typename T>
 inline ThreadSpecific<T>::operator T*() {
   T* off_thread_ptr;
-#if defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD)
+#if defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD) || defined(OS_HAIKU)
   // TLS is fast on these platforms.
   // TODO(csharrison): Qualify this statement for Android.
   const bool kMainThreadAlwaysChecksTLS = true;
diff --git a/chromium/third_party/blink/renderer/platform/wtf/threading_pthreads.cc b/chromium/third_party/blink/renderer/platform/wtf/threading_pthreads.cc
index 090489c..792a302 100644
--- a/chromium/third_party/blink/renderer/platform/wtf/threading_pthreads.cc
+++ b/chromium/third_party/blink/renderer/platform/wtf/threading_pthreads.cc
@@ -54,10 +54,15 @@
 #include <sys/syscall.h>
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 #include <unistd.h>
 #endif
 
+#if defined(OS_HAIKU)
+#include <signal.h>
+#include <pthread.h>
+#endif
+
 namespace WTF {
 
 MutexBase::MutexBase(bool recursive) {
diff --git a/chromium/third_party/boringssl/BUILD.gn b/chromium/third_party/boringssl/BUILD.gn
index fab8905..73e5251 100644
--- a/chromium/third_party/boringssl/BUILD.gn
+++ b/chromium/third_party/boringssl/BUILD.gn
@@ -72,7 +72,7 @@ if (is_win && !is_msan && current_cpu != "arm64") {
     } else if (current_cpu == "x64") {
       if (is_mac) {
         sources += crypto_sources_mac_x86_64
-      } else if (is_linux || is_chromeos || is_android) {
+      } else if (is_linux || is_haiku || is_chromeos || is_android) {
         sources += crypto_sources_linux_x86_64
       } else {
         public_configs = [ ":no_asm_config" ]
@@ -80,13 +80,13 @@ if (is_win && !is_msan && current_cpu != "arm64") {
     } else if (current_cpu == "x86") {
       if (is_mac) {
         sources += crypto_sources_mac_x86
-      } else if (is_linux || is_chromeos || is_android) {
+      } else if (is_linux || is_haiku || is_chromeos || is_android) {
         sources += crypto_sources_linux_x86
       } else {
         public_configs = [ ":no_asm_config" ]
       }
     } else if (current_cpu == "arm") {
-      if (is_linux || is_chromeos || is_android) {
+      if (is_linux || is_haiku || is_chromeos || is_android) {
         sources += crypto_sources_linux_arm
       } else if (is_ios) {
         sources += crypto_sources_ios_arm
@@ -94,13 +94,20 @@ if (is_win && !is_msan && current_cpu != "arm64") {
         public_configs = [ ":no_asm_config" ]
       }
     } else if (current_cpu == "arm64") {
-      if (is_linux || is_chromeos || is_android) {
+      if (is_linux || is_haiku || is_chromeos || is_android) {
         sources += crypto_sources_linux_aarch64
       } else if (is_ios) {
         sources += crypto_sources_ios_aarch64
       } else {
         public_configs = [ ":no_asm_config" ]
       }
+    } else if (current_cpu == "ppc64") {
+      if (is_linux || is_haiku) {
+        # TODO: ppc64 (be) check
+        sources += crypto_sources_linux_ppc64le
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
     } else {
       public_configs = [ ":no_asm_config" ]
     }
diff --git a/chromium/third_party/boringssl/src/crypto/asn1/a_int.c b/chromium/third_party/boringssl/src/crypto/asn1/a_int.c
index 2eda6c0..a5b162a 100644
--- a/chromium/third_party/boringssl/src/crypto/asn1/a_int.c
+++ b/chromium/third_party/boringssl/src/crypto/asn1/a_int.c
@@ -310,7 +310,9 @@ int ASN1_INTEGER_set_uint64(ASN1_INTEGER *out, uint64_t v)
 
     OPENSSL_free(out->data);
     out->data = newdata;
+#ifndef OPENSSL_BIGENDIAN
     v = CRYPTO_bswap8(v);
+#endif
     memcpy(out->data, &v, sizeof(v));
 
     out->type = V_ASN1_INTEGER;
diff --git a/chromium/third_party/boringssl/src/crypto/chacha/chacha.c b/chromium/third_party/boringssl/src/crypto/chacha/chacha.c
index b539f99..abc56df 100644
--- a/chromium/third_party/boringssl/src/crypto/chacha/chacha.c
+++ b/chromium/third_party/boringssl/src/crypto/chacha/chacha.c
@@ -29,6 +29,14 @@
   (((uint32_t)((p)[0])) | ((uint32_t)((p)[1]) << 8) | \
    ((uint32_t)((p)[2]) << 16) | ((uint32_t)((p)[3]) << 24))
 
+#define U32TO8_LITTLE(p, v)    \
+  {                            \
+    (p)[0] = (v >> 0) & 0xff;  \
+    (p)[1] = (v >> 8) & 0xff;  \
+    (p)[2] = (v >> 16) & 0xff; \
+    (p)[3] = (v >> 24) & 0xff; \
+  }
+
 // sigma contains the ChaCha constants, which happen to be an ASCII string.
 static const uint8_t sigma[16] = { 'e', 'x', 'p', 'a', 'n', 'd', ' ', '3',
                                    '2', '-', 'b', 'y', 't', 'e', ' ', 'k' };
@@ -45,9 +53,27 @@ static const uint8_t sigma[16] = { 'e', 'x', 'p', 'a', 'n', 'd', ' ', '3',
 void CRYPTO_hchacha20(uint8_t out[32], const uint8_t key[32],
                       const uint8_t nonce[16]) {
   uint32_t x[16];
-  OPENSSL_memcpy(x, sigma, sizeof(sigma));
-  OPENSSL_memcpy(&x[4], key, 32);
-  OPENSSL_memcpy(&x[12], nonce, 16);
+  int i;
+
+  x[0] = U8TO32_LITTLE(sigma + 0);
+  x[1] = U8TO32_LITTLE(sigma + 4);
+  x[2] = U8TO32_LITTLE(sigma + 8);
+  x[3] = U8TO32_LITTLE(sigma + 12);
+
+  x[4] = U8TO32_LITTLE(key + 0);
+  x[5] = U8TO32_LITTLE(key + 4);
+  x[6] = U8TO32_LITTLE(key + 8);
+  x[7] = U8TO32_LITTLE(key + 12);
+
+  x[8] = U8TO32_LITTLE(key + 16);
+  x[9] = U8TO32_LITTLE(key + 20);
+  x[10] = U8TO32_LITTLE(key + 24);
+  x[11] = U8TO32_LITTLE(key + 28);
+
+  x[12] = U8TO32_LITTLE(nonce + 0);
+  x[13] = U8TO32_LITTLE(nonce + 4);
+  x[14] = U8TO32_LITTLE(nonce + 8);
+  x[15] = U8TO32_LITTLE(nonce + 12);
 
   for (size_t i = 0; i < 20; i += 2) {
     QUARTERROUND(0, 4, 8, 12)
@@ -60,8 +86,10 @@ void CRYPTO_hchacha20(uint8_t out[32], const uint8_t key[32],
     QUARTERROUND(3, 4, 9, 14)
   }
 
-  OPENSSL_memcpy(out, &x[0], sizeof(uint32_t) * 4);
-  OPENSSL_memcpy(&out[16], &x[12], sizeof(uint32_t) * 4);
+  for (i = 0; i < 4; ++i) {
+    U32TO8_LITTLE(out + 4 * i, x[i]);
+    U32TO8_LITTLE(&out[16] + 4 * i, x[12+i]);
+  }
 }
 
 #if defined(CHACHA20_ASM)
@@ -99,14 +127,6 @@ void CRYPTO_chacha_20(uint8_t *out, const uint8_t *in, size_t in_len,
 
 #else
 
-#define U32TO8_LITTLE(p, v)    \
-  {                            \
-    (p)[0] = (v >> 0) & 0xff;  \
-    (p)[1] = (v >> 8) & 0xff;  \
-    (p)[2] = (v >> 16) & 0xff; \
-    (p)[3] = (v >> 24) & 0xff; \
-  }
-
 // chacha_core performs 20 rounds of ChaCha on the input words in
 // |input| and writes the 64 output bytes to |output|.
 static void chacha_core(uint8_t output[64], const uint32_t input[16]) {
diff --git a/chromium/third_party/boringssl/src/crypto/cipher_extra/e_aesgcmsiv.c b/chromium/third_party/boringssl/src/crypto/cipher_extra/e_aesgcmsiv.c
index d717572..92f7dce 100644
--- a/chromium/third_party/boringssl/src/crypto/cipher_extra/e_aesgcmsiv.c
+++ b/chromium/third_party/boringssl/src/crypto/cipher_extra/e_aesgcmsiv.c
@@ -630,7 +630,11 @@ static void gcm_siv_crypt(uint8_t *out, const uint8_t *in, size_t in_len,
   for (size_t done = 0; done < in_len;) {
     uint8_t keystream[AES_BLOCK_SIZE];
     enc_block(counter.c, keystream, key);
+#ifdef OPENSSL_BIGENDIAN
+    counter.w[0] = CRYPTO_bswap4(CRYPTO_bswap4(counter.w[0]) + 1);
+#else
     counter.w[0]++;
+#endif
 
     size_t todo = AES_BLOCK_SIZE;
     if (in_len - done < todo) {
@@ -678,8 +682,13 @@ static void gcm_siv_polyval(
     } bitlens;
   } length_block;
 
+#ifdef OPENSSL_BIGENDIAN
+  length_block.bitlens.ad = CRYPTO_bswap8(ad_len * 8);
+  length_block.bitlens.in = CRYPTO_bswap8(in_len * 8);
+#else
   length_block.bitlens.ad = ad_len * 8;
   length_block.bitlens.in = in_len * 8;
+#endif
   CRYPTO_POLYVAL_update_blocks(&polyval_ctx, length_block.c,
                                sizeof(length_block));
 
diff --git a/chromium/third_party/boringssl/src/crypto/cpu-aarch64-linux.c b/chromium/third_party/boringssl/src/crypto/cpu-aarch64-linux.c
index 0184dd4..2726151 100644
--- a/chromium/third_party/boringssl/src/crypto/cpu-aarch64-linux.c
+++ b/chromium/third_party/boringssl/src/crypto/cpu-aarch64-linux.c
@@ -14,49 +14,47 @@
 
 #include <openssl/cpu.h>
 
-#if defined(OPENSSL_AARCH64) && defined(OPENSSL_LINUX) && \
-    !defined(OPENSSL_STATIC_ARMCAP)
-
-#include <sys/auxv.h>
+#if defined(OPENSSL_AARCH64)
 
 #include <openssl/arm_arch.h>
 
 #include "internal.h"
 
-
 extern uint32_t OPENSSL_armcap_P;
 
+#include <machine/armreg.h>
+
+#ifndef ID_AA64ISAR0_AES_VAL
+#define ID_AA64ISAR0_AES_VAL ID_AA64ISAR0_AES
+#endif
+#ifndef ID_AA64ISAR0_AES_VAL
+#define ID_AA64ISAR0_AES_VAL ID_AA64ISAR0_AES
+#endif
+#ifndef ID_AA64ISAR0_SHA1_VAL
+#define ID_AA64ISAR0_SHA1_VAL ID_AA64ISAR0_SHA1
+#endif
+#ifndef ID_AA64ISAR0_SHA2_VAL
+#define ID_AA64ISAR0_SHA2_VAL ID_AA64ISAR0_SHA2
+#endif
+
 void OPENSSL_cpuid_setup(void) {
-  unsigned long hwcap = getauxval(AT_HWCAP);
-
-  // See /usr/include/asm/hwcap.h on an aarch64 installation for the source of
-  // these values.
-  static const unsigned long kNEON = 1 << 1;
-  static const unsigned long kAES = 1 << 3;
-  static const unsigned long kPMULL = 1 << 4;
-  static const unsigned long kSHA1 = 1 << 5;
-  static const unsigned long kSHA256 = 1 << 6;
-
-  if ((hwcap & kNEON) == 0) {
-    // Matching OpenSSL, if NEON is missing, don't report other features
-    // either.
-    return;
-  }
+  uint64_t id_aa64isar0;
+
+  id_aa64isar0 = READ_SPECIALREG(id_aa64isar0_el1);
 
   OPENSSL_armcap_P |= ARMV7_NEON;
 
-  if (hwcap & kAES) {
+  if (ID_AA64ISAR0_AES_VAL(id_aa64isar0) >= ID_AA64ISAR0_AES_BASE) {
     OPENSSL_armcap_P |= ARMV8_AES;
   }
-  if (hwcap & kPMULL) {
+  if (ID_AA64ISAR0_AES_VAL(id_aa64isar0) == ID_AA64ISAR0_AES_PMULL) {
     OPENSSL_armcap_P |= ARMV8_PMULL;
   }
-  if (hwcap & kSHA1) {
+  if (ID_AA64ISAR0_SHA1_VAL(id_aa64isar0) == ID_AA64ISAR0_SHA1_BASE) {
     OPENSSL_armcap_P |= ARMV8_SHA1;
   }
-  if (hwcap & kSHA256) {
+  if(ID_AA64ISAR0_SHA2_VAL(id_aa64isar0) >= ID_AA64ISAR0_SHA2_BASE) {
     OPENSSL_armcap_P |= ARMV8_SHA256;
   }
 }
-
-#endif  // OPENSSL_AARCH64 && !OPENSSL_STATIC_ARMCAP
+#endif  // OPENSSL_AARCH64
diff --git a/chromium/third_party/boringssl/src/crypto/curve25519/spake25519.c b/chromium/third_party/boringssl/src/crypto/curve25519/spake25519.c
index f750911..c8b91cf 100644
--- a/chromium/third_party/boringssl/src/crypto/curve25519/spake25519.c
+++ b/chromium/third_party/boringssl/src/crypto/curve25519/spake25519.c
@@ -339,8 +339,17 @@ static void scalar_double(scalar *s) {
   uint32_t carry = 0;
 
   for (size_t i = 0; i < 8; i++) {
-    const uint32_t carry_out = s->words[i] >> 31;
-    s->words[i] = (s->words[i] << 1) | carry;
+#ifdef OPENSSL_BIGENDIAN
+    const uint32_t si = CRYPTO_bswap4(s->words[i]);
+#else
+    const uint32_t si = s->words[i];
+#endif
+    const uint32_t carry_out = si >> 31;
+#ifdef OPENSSL_BIGENDIAN
+    s->words[i] = CRYPTO_bswap4((si << 1) | carry);
+#else
+    s->words[i] = (si << 1) | carry;
+#endif
     carry = carry_out;
   }
 }
@@ -350,8 +359,13 @@ static void scalar_add(scalar *dest, const scalar *src) {
   uint32_t carry = 0;
 
   for (size_t i = 0; i < 8; i++) {
+#ifdef OPENSSL_BIGENDIAN
+    uint64_t tmp = ((uint64_t)CRYPTO_bswap4(dest->words[i]) + CRYPTO_bswap4(src->words[i])) + carry;
+    dest->words[i] = CRYPTO_bswap4((uint32_t)tmp);
+#else
     uint64_t tmp = ((uint64_t)dest->words[i] + src->words[i]) + carry;
     dest->words[i] = (uint32_t)tmp;
+#endif
     carry = (uint32_t)(tmp >> 32);
   }
 }
diff --git a/chromium/third_party/boringssl/src/crypto/evp/scrypt.c b/chromium/third_party/boringssl/src/crypto/evp/scrypt.c
index 2feb650..d3dd725 100644
--- a/chromium/third_party/boringssl/src/crypto/evp/scrypt.c
+++ b/chromium/third_party/boringssl/src/crypto/evp/scrypt.c
@@ -196,10 +196,28 @@ int EVP_PBE_scrypt(const char *password, size_t password_len,
     goto err;
   }
 
+#ifdef OPENSSL_BIGENDIAN
+  uint32_t *B32 = B->words;
+  size_t B_words = B_bytes >> 2;
+  do {
+    *B32 = CRYPTO_bswap4(*B32);
+    B32++;
+  } while(--B_words);
+#endif
+
   for (uint64_t i = 0; i < p; i++) {
     scryptROMix(B + 2 * r * i, r, N, T, V);
   }
 
+#ifdef OPENSSL_BIGENDIAN
+  B32 = B->words;
+  B_words = B_bytes >> 2;
+  do {
+    *B32 = CRYPTO_bswap4(*B32);
+    B32++;
+  } while(--B_words);
+#endif
+
   if (!PKCS5_PBKDF2_HMAC(password, password_len, (const uint8_t *)B, B_bytes, 1,
                          EVP_sha256(), key_len, out_key)) {
     goto err;
diff --git a/chromium/third_party/boringssl/src/crypto/ex_data.c b/chromium/third_party/boringssl/src/crypto/ex_data.c
index 71d60a5..7ffea5a 100644
--- a/chromium/third_party/boringssl/src/crypto/ex_data.c
+++ b/chromium/third_party/boringssl/src/crypto/ex_data.c
@@ -186,7 +186,9 @@ int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int index, void *val) {
     }
   }
 
-  sk_void_set(ad->sk, index, val);
+  // expression result unused; should this cast be to 'void'?
+  // seems it should, feel free to investigate those #def
+  (void) sk_void_set(ad->sk, index, val);
   return 1;
 }
 
diff --git a/chromium/third_party/boringssl/src/crypto/fipsmodule/bn/bytes.c b/chromium/third_party/boringssl/src/crypto/fipsmodule/bn/bytes.c
index 56241e3..bba4939 100644
--- a/chromium/third_party/boringssl/src/crypto/fipsmodule/bn/bytes.c
+++ b/chromium/third_party/boringssl/src/crypto/fipsmodule/bn/bytes.c
@@ -136,9 +136,13 @@ BIGNUM *BN_le2bn(const uint8_t *in, size_t len, BIGNUM *ret) {
   // Make sure the top bytes will be zeroed.
   ret->d[num_words - 1] = 0;
 
-  // We only support little-endian platforms, so we can simply memcpy the
-  // internal representation.
+#ifdef OPENSSL_BIGENDIAN
+  uint8_t *out = (uint8_t *)ret->d;
+  for (size_t i = 0; i < len; i++)
+    out[i ^ (BN_BYTES-1)] = in[i];
+#else
   OPENSSL_memcpy(ret->d, in, len);
+#endif
   return ret;
 }
 
@@ -157,7 +161,11 @@ size_t BN_bn2bin(const BIGNUM *in, uint8_t *out) {
 static int fits_in_bytes(const uint8_t *bytes, size_t num_bytes, size_t len) {
   uint8_t mask = 0;
   for (size_t i = len; i < num_bytes; i++) {
+#ifdef OPENSSL_BIGENDIAN
+    mask |= bytes[i ^ (BN_BYTES-1)];
+#else
     mask |= bytes[i];
+#endif
   }
   return mask == 0;
 }
@@ -172,9 +180,13 @@ int BN_bn2le_padded(uint8_t *out, size_t len, const BIGNUM *in) {
     num_bytes = len;
   }
 
-  // We only support little-endian platforms, so we can simply memcpy into the
-  // internal representation.
+#ifdef OPENSSL_BIGENDIAN
+  for (size_t i = 0; i < num_bytes; i++) {
+    out[i] = bytes[i ^ (BN_BYTES-1)];
+  }
+#else
   OPENSSL_memcpy(out, bytes, num_bytes);
+#endif
   // Pad out the rest of the buffer with zeroes.
   OPENSSL_memset(out + num_bytes, 0, len - num_bytes);
   return 1;
@@ -190,11 +202,15 @@ int BN_bn2bin_padded(uint8_t *out, size_t len, const BIGNUM *in) {
     num_bytes = len;
   }
 
-  // We only support little-endian platforms, so we can simply write the buffer
-  // in reverse.
+#ifdef OPENSSL_BIGENDIAN
+  for (size_t i = 0; i < num_bytes; i++) {
+    out[len - i - 1] = bytes[i ^ (BN_BYTES-1)];
+  }
+#else
   for (size_t i = 0; i < num_bytes; i++) {
     out[len - i - 1] = bytes[i];
   }
+#endif
   // Pad out the rest of the buffer with zeroes.
   OPENSSL_memset(out, 0, len - num_bytes);
   return 1;
diff --git a/chromium/third_party/boringssl/src/crypto/fipsmodule/ecdsa/ecdsa.c b/chromium/third_party/boringssl/src/crypto/fipsmodule/ecdsa/ecdsa.c
index 096b615..1f8d7a2 100644
--- a/chromium/third_party/boringssl/src/crypto/fipsmodule/ecdsa/ecdsa.c
+++ b/chromium/third_party/boringssl/src/crypto/fipsmodule/ecdsa/ecdsa.c
@@ -80,7 +80,11 @@ static void digest_to_scalar(const EC_GROUP *group, EC_SCALAR *out,
   }
   OPENSSL_memset(out, 0, sizeof(EC_SCALAR));
   for (size_t i = 0; i < digest_len; i++) {
+#ifdef OPENSSL_BIGENDIAN
+    out->bytes[i ^ (BN_BYTES-1)] = digest[digest_len - 1 - i];
+#else
     out->bytes[i] = digest[digest_len - 1 - i];
+#endif
   }
 
   // If it is still too long, truncate remaining bits with a shift.
diff --git a/chromium/third_party/boringssl/src/crypto/fipsmodule/modes/polyval.c b/chromium/third_party/boringssl/src/crypto/fipsmodule/modes/polyval.c
index 857dc0e..b5349a8 100644
--- a/chromium/third_party/boringssl/src/crypto/fipsmodule/modes/polyval.c
+++ b/chromium/third_party/boringssl/src/crypto/fipsmodule/modes/polyval.c
@@ -32,16 +32,26 @@ static void byte_reverse(polyval_block *b) {
 // the GHASH field, multiplies that by 'x' and serialises the result back into
 // |b|, but with GHASH's backwards bit ordering.
 static void reverse_and_mulX_ghash(polyval_block *b) {
+#ifdef OPENSSL_BIGENDIAN
+  uint64_t hi = CRYPTO_bswap8(b->u[0]);
+  uint64_t lo = CRYPTO_bswap8(b->u[1]);
+#else
   uint64_t hi = b->u[0];
   uint64_t lo = b->u[1];
+#endif
   const crypto_word_t carry = constant_time_eq_w(hi & 1, 1);
   hi >>= 1;
   hi |= lo << 63;
   lo >>= 1;
   lo ^= ((uint64_t) constant_time_select_w(carry, 0xe1, 0)) << 56;
 
+#ifdef OPENSSL_BIGENDIAN
+  b->u[0] = lo;
+  b->u[1] = hi;
+#else
   b->u[0] = CRYPTO_bswap8(lo);
   b->u[1] = CRYPTO_bswap8(hi);
+#endif
 }
 
 // POLYVAL(H, X_1, ..., X_n) =
diff --git a/chromium/third_party/boringssl/src/crypto/fipsmodule/rand/ctrdrbg.c b/chromium/third_party/boringssl/src/crypto/fipsmodule/rand/ctrdrbg.c
index b2fda1d..84822a5 100644
--- a/chromium/third_party/boringssl/src/crypto/fipsmodule/rand/ctrdrbg.c
+++ b/chromium/third_party/boringssl/src/crypto/fipsmodule/rand/ctrdrbg.c
@@ -70,8 +70,12 @@ OPENSSL_STATIC_ASSERT(CTR_DRBG_ENTROPY_LEN % AES_BLOCK_SIZE == 0,
 // ctr_inc adds |n| to the last four bytes of |drbg->counter|, treated as a
 // big-endian number.
 static void ctr32_add(CTR_DRBG_STATE *drbg, uint32_t n) {
+#ifdef OPENSSL_BIGENDIAN
+  drbg->counter.words[3] += n;
+#else
   drbg->counter.words[3] =
       CRYPTO_bswap4(CRYPTO_bswap4(drbg->counter.words[3]) + n);
+#endif
 }
 
 static int ctr_drbg_update(CTR_DRBG_STATE *drbg, const uint8_t *data,
diff --git a/chromium/third_party/boringssl/src/crypto/mem.c b/chromium/third_party/boringssl/src/crypto/mem.c
index 0491f15..8c89bca 100644
--- a/chromium/third_party/boringssl/src/crypto/mem.c
+++ b/chromium/third_party/boringssl/src/crypto/mem.c
@@ -86,7 +86,7 @@ static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
 // Windows doesn't really support weak symbols as of May 2019, and Clang on
 // Windows will emit strong symbols instead. See
 // https://bugs.llvm.org/show_bug.cgi?id=37598
-#if defined(__ELF__) && defined(__GNUC__)
+#if defined(__ELF__) && defined(__GNUC__) && !defined(__HAIKU__)
 #define WEAK_SYMBOL_FUNC(rettype, name, args) \
   rettype name args __attribute__((weak));
 #else
diff --git a/chromium/third_party/boringssl/src/crypto/poly1305/poly1305.c b/chromium/third_party/boringssl/src/crypto/poly1305/poly1305.c
index a6dd145..5c3f7e8 100644
--- a/chromium/third_party/boringssl/src/crypto/poly1305/poly1305.c
+++ b/chromium/third_party/boringssl/src/crypto/poly1305/poly1305.c
@@ -32,10 +32,16 @@
 static uint32_t U8TO32_LE(const uint8_t *m) {
   uint32_t r;
   OPENSSL_memcpy(&r, m, sizeof(r));
+#ifdef OPENSSL_BIGENDIAN
+  r = CRYPTO_bswap4(r);
+#endif
   return r;
 }
 
 static void U32TO8_LE(uint8_t *m, uint32_t v) {
+#ifdef OPENSSL_BIGENDIAN
+  v = CRYPTO_bswap4(v);
+#endif
   OPENSSL_memcpy(m, &v, sizeof(v));
 }
 
diff --git a/chromium/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni b/chromium/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
index 51b99c3..cf63d6d 100644
--- a/chromium/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
+++ b/chromium/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
@@ -38,7 +38,7 @@ if (crashpad_is_in_chromium) {
   crashpad_is_mac = is_mac
   crashpad_is_ios = is_ios
   crashpad_is_win = is_win
-  crashpad_is_linux = is_linux || is_chromeos
+  crashpad_is_linux = is_linux && !is_haiku || is_chromeos
   crashpad_is_android = is_android
   crashpad_is_fuchsia = is_fuchsia
 
diff --git a/chromium/third_party/crashpad/crashpad/client/BUILD.gn b/chromium/third_party/crashpad/crashpad/client/BUILD.gn
index ca55ad4..798bd45 100644
--- a/chromium/third_party/crashpad/crashpad/client/BUILD.gn
+++ b/chromium/third_party/crashpad/crashpad/client/BUILD.gn
@@ -82,6 +82,12 @@ crashpad_static_library("client") {
     sources += [ "crashpad_client_fuchsia.cc" ]
   }
 
+  if (crashpad_is_posix) {
+    sources += [
+      "crashpad_client_posix.cc",
+    ]
+  }
+
   if (crashpad_is_linux || crashpad_is_android || crashpad_is_fuchsia) {
     sources += [ "crash_report_database_generic.cc" ]
   }
diff --git a/chromium/third_party/crashpad/crashpad/client/crashpad_client_posix.cc b/chromium/third_party/crashpad/crashpad/client/crashpad_client_posix.cc
new file mode 100644
index 0000000..c9449e4
--- /dev/null
+++ b/chromium/third_party/crashpad/crashpad/client/crashpad_client_posix.cc
@@ -0,0 +1,40 @@
+// Copyright 2017 The Crashpad Authors. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "client/crashpad_client.h"
+
+#include "base/logging.h"
+#include "base/notreached.h"
+
+namespace crashpad {
+
+CrashpadClient::CrashpadClient() {}
+
+CrashpadClient::~CrashpadClient() {}
+
+bool CrashpadClient::StartHandler(
+    const base::FilePath& handler,
+    const base::FilePath& database,
+    const base::FilePath& metrics_dir,
+    const std::string& url,
+    const std::map<std::string, std::string>& annotations,
+    const std::vector<std::string>& arguments,
+    bool restartable,
+    bool asynchronous_start,
+    const std::vector<base::FilePath>& attachments) {
+  NOTREACHED();  // TODO(scottmg): https://crashpad.chromium.org/bug/196
+  return false;
+}
+
+}  // namespace crashpad
diff --git a/chromium/third_party/crashpad/crashpad/util/misc/address_types.h b/chromium/third_party/crashpad/crashpad/util/misc/address_types.h
index 14942bd..e1047dd 100644
--- a/chromium/third_party/crashpad/crashpad/util/misc/address_types.h
+++ b/chromium/third_party/crashpad/crashpad/util/misc/address_types.h
@@ -25,7 +25,7 @@
 #include <mach/mach_types.h>
 #elif defined(OS_WIN)
 #include "util/win/address_types.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 #include "util/linux/address_types.h"
 #elif defined(OS_FUCHSIA)
 #include <zircon/types.h>
@@ -55,7 +55,7 @@ using VMSize = mach_vm_size_t;
 using VMAddress = WinVMAddress;
 using VMSize = WinVMSize;
 
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 
 using VMAddress = LinuxVMAddress;
 using VMSize = LinuxVMSize;
diff --git a/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h b/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
index d21a24f..091eadb 100644
--- a/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
+++ b/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
@@ -38,7 +38,7 @@ using NativeCPUContext = arm_unified_thread_state;
 #elif defined(OS_WIN)
 using NativeCPUContext = CONTEXT;
 #elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
 using NativeCPUContext = ucontext_t;
 #endif  // OS_APPLE
 
diff --git a/chromium/third_party/crashpad/crashpad/util/misc/metrics.cc b/chromium/third_party/crashpad/crashpad/util/misc/metrics.cc
index 4b87f10..545d148 100644
--- a/chromium/third_party/crashpad/crashpad/util/misc/metrics.cc
+++ b/chromium/third_party/crashpad/crashpad/util/misc/metrics.cc
@@ -25,7 +25,7 @@
 #define METRICS_OS_NAME "Win"
 #elif defined(OS_ANDROID)
 #define METRICS_OS_NAME "Android"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #define METRICS_OS_NAME "Linux"
 #elif defined(OS_FUCHSIA)
 #define METRICS_OS_NAME "Fuchsia"
diff --git a/chromium/third_party/crashpad/crashpad/util/misc/uuid.cc b/chromium/third_party/crashpad/crashpad/util/misc/uuid.cc
index 32ffea5..0d357dc 100644
--- a/chromium/third_party/crashpad/crashpad/util/misc/uuid.cc
+++ b/chromium/third_party/crashpad/crashpad/util/misc/uuid.cc
@@ -96,7 +96,7 @@ bool UUID::InitializeWithNew() {
   InitializeFromBytes(uuid);
   return true;
 #elif defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID) || defined(OS_FUCHSIA)
+    defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
   // Linux, Android, and Fuchsia do not provide a UUID generator in a
   // widely-available system library. On Linux and Android, uuid_generate()
   // from libuuid is not available everywhere.
diff --git a/chromium/third_party/crashpad/crashpad/util/posix/close_multiple.cc b/chromium/third_party/crashpad/crashpad/util/posix/close_multiple.cc
index 0c07832..df3eb7f 100644
--- a/chromium/third_party/crashpad/crashpad/util/posix/close_multiple.cc
+++ b/chromium/third_party/crashpad/crashpad/util/posix/close_multiple.cc
@@ -31,7 +31,7 @@
 #include "util/file/directory_reader.h"
 #include "util/misc/implicit_cast.h"
 
-#if defined(OS_APPLE)
+#if defined(OS_APPLE) || defined(OS_BSD)
 #include <sys/sysctl.h>
 #endif
 
@@ -72,12 +72,15 @@ void CloseNowOrOnExec(int fd, bool ebadf_ok) {
 // This is an advantage over looping over all possible file descriptors, because
 // no attempt needs to be made to close file descriptors that are not open.
 bool CloseMultipleNowOrOnExecUsingFDDir(int min_fd, int preserve_fd) {
-#if defined(OS_APPLE)
+#if defined(OS_APPLE) || defined(OS_BSD)
   static constexpr char kFDDir[] = "/dev/fd";
 #elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
   static constexpr char kFDDir[] = "/proc/self/fd";
 #endif
 
+#if defined(OS_HAIKU)
+  return false;
+#else
   DirectoryReader reader;
   if (!reader.Open(base::FilePath(kFDDir))) {
     return false;
@@ -104,6 +107,7 @@ bool CloseMultipleNowOrOnExecUsingFDDir(int min_fd, int preserve_fd) {
   }
 
   return true;
+#endif
 }
 
 }  // namespace
@@ -147,7 +151,7 @@ void CloseMultipleNowOrOnExec(int fd, int preserve_fd) {
   // while the system is running, but its still a better upper bound than the
   // current RLIMIT_NOFILE value.
 
-#if defined(OS_APPLE)
+#if defined(OS_APPLE) || defined(OS_BSD)
   // See 10.11.6 xnu-3248.60.10/bsd/kern/kern_resource.c maxfilesperproc,
   // referenced by dosetrlimit().
   int oid[] = {CTL_KERN, KERN_MAXFILESPERPROC};
diff --git a/chromium/third_party/crashpad/crashpad/util/posix/double_fork_and_exec.cc b/chromium/third_party/crashpad/crashpad/util/posix/double_fork_and_exec.cc
index 1960430..4e7ac81 100644
--- a/chromium/third_party/crashpad/crashpad/util/posix/double_fork_and_exec.cc
+++ b/chromium/third_party/crashpad/crashpad/util/posix/double_fork_and_exec.cc
@@ -25,6 +25,10 @@
 #include "base/strings/stringprintf.h"
 #include "util/posix/close_multiple.h"
 
+#if defined(OS_HAIKU)
+#define WCOREDUMP(x) WIFCORED(x)
+#endif
+
 namespace crashpad {
 
 bool DoubleForkAndExec(const std::vector<std::string>& argv,
diff --git a/chromium/third_party/crashpad/crashpad/util/posix/drop_privileges.cc b/chromium/third_party/crashpad/crashpad/util/posix/drop_privileges.cc
index 75650d5..f238fa9 100644
--- a/chromium/third_party/crashpad/crashpad/util/posix/drop_privileges.cc
+++ b/chromium/third_party/crashpad/crashpad/util/posix/drop_privileges.cc
@@ -25,7 +25,7 @@ void DropPrivileges() {
   gid_t gid = getgid();
   uid_t uid = getuid();
 
-#if defined(OS_APPLE)
+#if defined(OS_APPLE) || defined(OS_HAIKU)
   // Based on the POSIX.1-2008 2013 edition documentation for setreuid() and
   // setregid(), setreuid() and setregid() alone should be sufficient to drop
   // privileges. The standard specifies that the saved ID should be set to the
diff --git a/chromium/third_party/crashpad/crashpad/util/posix/signals.cc b/chromium/third_party/crashpad/crashpad/util/posix/signals.cc
index 5ba66a3..aa71652 100644
--- a/chromium/third_party/crashpad/crashpad/util/posix/signals.cc
+++ b/chromium/third_party/crashpad/crashpad/util/posix/signals.cc
@@ -46,10 +46,10 @@ constexpr int kCrashSignals[] = {
 #if defined(SIGEMT)
     SIGEMT,
 #endif  // defined(SIGEMT)
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     SIGXCPU,
     SIGXFSZ,
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 };
 
 // These are the non-core-generating but terminating signals.
@@ -228,8 +228,12 @@ bool Signals::WillSignalReraiseAutonomously(const siginfo_t* siginfo) {
          // remains. See 10.12.3 xnu-3789.41.3/bsd/kern/kern_sig.c
          // psignal_internal().
          (code > 0 &&
+#if defined(SI_ASYNCIO)
           code != SI_ASYNCIO &&
+#endif
+#if defined(SI_MESGQ)
           code != SI_MESGQ &&
+#endif
           code != SI_QUEUE &&
           code != SI_TIMER &&
           code != SI_USER &&
diff --git a/chromium/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc b/chromium/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
index c6e0fec..e835e68 100644
--- a/chromium/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
+++ b/chromium/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
@@ -64,7 +64,7 @@ constexpr const char* kSignalNames[] = {
     "INFO",
     "USR1",
     "USR2",
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 #if defined(ARCH_CPU_MIPS_FAMILY)
     "HUP",
     "INT",
@@ -135,7 +135,7 @@ constexpr const char* kSignalNames[] = {
 #endif  // defined(ARCH_CPU_MIPS_FAMILY)
 #endif
 };
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 // NSIG is 64 to account for real-time signals.
 static_assert(base::size(kSignalNames) == 32, "kSignalNames length");
 #else
diff --git a/chromium/third_party/khronos/EGL/eglplatform.h b/chromium/third_party/khronos/EGL/eglplatform.h
index af5ef0c..83f5a15 100644
--- a/chromium/third_party/khronos/EGL/eglplatform.h
+++ b/chromium/third_party/khronos/EGL/eglplatform.h
@@ -99,6 +99,13 @@ typedef intptr_t EGLNativeDisplayType;
 typedef intptr_t EGLNativeWindowType;
 typedef intptr_t EGLNativePixmapType;
 
+#elif defined(__HAIKU__)
+
+#include <kernel/image.h>
+typedef void				*EGLNativeDisplayType;
+typedef uintptr_t			EGLNativePixmapType;
+typedef uintptr_t			EGLNativeWindowType;
+
 #elif defined(__unix__)
 
 /* X11 (tentative)  */
diff --git a/chromium/third_party/libxml/BUILD.gn b/chromium/third_party/libxml/BUILD.gn
index 242f3a7..26a9349 100644
--- a/chromium/third_party/libxml/BUILD.gn
+++ b/chromium/third_party/libxml/BUILD.gn
@@ -4,7 +4,7 @@
 
 # Define an "os_include" variable that points at the OS-specific generated
 # headers.  These were generated by running the configure script offline.
-if (is_linux || is_chromeos || is_android || is_nacl || is_fuchsia) {
+if (is_linux || is_chromeos || is_android || is_nacl || is_fuchsia || is_haiku) {
   os_include = "linux"
 } else if (is_apple) {
   os_include = "mac"
diff --git a/chromium/third_party/nasm/config/config-linux.h b/chromium/third_party/nasm/config/config-linux.h
index 9e59df4..4ee3409 100644
--- a/chromium/third_party/nasm/config/config-linux.h
+++ b/chromium/third_party/nasm/config/config-linux.h
@@ -139,7 +139,7 @@
 #define HAVE_ACCESS 1
 
 /* Define to 1 if you have the `canonicalize_file_name' function. */
-#define HAVE_CANONICALIZE_FILE_NAME 1
+/*#undef HAVE_CANONICALIZE_FILE_NAME */
 
 /* Define to 1 if you have the `cpu_to_le16' intrinsic function. */
 /* #undef HAVE_CPU_TO_LE16 */
@@ -180,7 +180,7 @@
 
 /* Define to 1 if you have the declaration of `strsep', and to 0 if you don't.
    */
-#define HAVE_DECL_STRSEP 1
+#define HAVE_DECL_STRSEP 0
 
 /* Define to 1 if you have the <endian.h> header file. */
 #define HAVE_ENDIAN_H 1
@@ -357,7 +357,7 @@
 #define HAVE_STDARG_H 1
 
 /* Define to 1 if stdbool.h conforms to C99. */
-/* #undef HAVE_STDBOOL_H */
+#define HAVE_STDBOOL_H 1
 
 /* Define to 1 if your compiler supports C99 extern inline */
 #define HAVE_STDC_INLINE 1
@@ -399,7 +399,7 @@
 /* #undef HAVE_STRRCHRNUL */
 
 /* Define to 1 if you have the `strsep' function. */
-#define HAVE_STRSEP 1
+/* #undef HAVE_STRSEP */
 
 /* Define to 1 if the system has the type `struct stat'. */
 #define HAVE_STRUCT_STAT 1
diff --git a/chromium/third_party/openh264/src/codec/common/src/WelsThreadLib.cpp b/chromium/third_party/openh264/src/codec/common/src/WelsThreadLib.cpp
index 4477e34..cfb6a01 100644
--- a/chromium/third_party/openh264/src/codec/common/src/WelsThreadLib.cpp
+++ b/chromium/third_party/openh264/src/codec/common/src/WelsThreadLib.cpp
@@ -48,7 +48,7 @@
 #include <sys/types.h>
 #include <sys/param.h>
 #include <unistd.h>
-#ifndef __Fuchsia__
+#if !defined(__Fuchsia__) && !defined(__HAIKU__)
 #include <sys/sysctl.h>
 #endif
 #ifdef __APPLE__
@@ -63,6 +63,9 @@
 #ifdef __ANDROID__
 #include <android/api-level.h>
 #endif
+#ifdef __HAIKU__
+#include <OS.h>
+#endif
 
 #include "WelsThreadLib.h"
 #include <stdio.h>
@@ -232,7 +235,7 @@ WELS_THREAD_ERROR_CODE    WelsThreadCreate (WELS_THREAD_HANDLE* thread,  LPWELS_
   err = pthread_attr_init (&at);
   if (err)
     return err;
-#if !defined(__ANDROID__) && !defined(__Fuchsia__)
+#if !defined(__ANDROID__) && !defined(__Fuchsia__) && !defined(__HAIKU__)
   err = pthread_attr_setscope (&at, PTHREAD_SCOPE_SYSTEM);
   if (err)
     return err;
@@ -511,6 +514,13 @@ WELS_THREAD_ERROR_CODE    WelsQueryLogicalProcessInfo (WelsLogicalProcessInfo* p
   pInfo->ProcessorCount = 1;
   return WELS_THREAD_ERROR_OK;
 
+#elif defined(__HAIKU__)
+
+  system_info info;
+  get_system_info(&info);
+  pInfo->ProcessorCount = info.cpu_count;
+  return WELS_THREAD_ERROR_OK;
+
 #elif defined(__Fuchsia__)
 
   pInfo->ProcessorCount = sysconf(_SC_NPROCESSORS_ONLN);
diff --git a/chromium/third_party/pdfium/core/fxcrt/cfx_datetime.cpp b/chromium/third_party/pdfium/core/fxcrt/cfx_datetime.cpp
index 3db9a98..d67905e 100644
--- a/chromium/third_party/pdfium/core/fxcrt/cfx_datetime.cpp
+++ b/chromium/third_party/pdfium/core/fxcrt/cfx_datetime.cpp
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 #include "core/fxcrt/fx_system.h"
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU) || \
     defined(OS_APPLE) || defined(OS_ASMJS)
 #include <sys/time.h>
 #include <time.h>
diff --git a/chromium/third_party/pdfium/core/fxge/fx_ge_linux.cpp b/chromium/third_party/pdfium/core/fxge/fx_ge_linux.cpp
index d568813..adb27fc 100644
--- a/chromium/third_party/pdfium/core/fxge/fx_ge_linux.cpp
+++ b/chromium/third_party/pdfium/core/fxge/fx_ge_linux.cpp
@@ -16,7 +16,7 @@
 #include "core/fxge/systemfontinfo_iface.h"
 #include "third_party/base/stl_util.h"
 
-#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_ASMJS)
+#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_ASMJS) && !defined(OS_HAIKU)
 #error "Included on the wrong platform"
 #endif
 
@@ -165,9 +165,8 @@ class CLinuxPlatform : public CFX_GEModule::PlatformIface {
   std::unique_ptr<SystemFontInfoIface> CreateDefaultSystemFontInfo() override {
     auto pInfo = std::make_unique<CFX_LinuxFontInfo>();
     if (!pInfo->ParseFontCfg(CFX_GEModule::Get()->GetUserFontPaths())) {
-      pInfo->AddPath("/usr/share/fonts");
-      pInfo->AddPath("/usr/share/X11/fonts/Type1");
-      pInfo->AddPath("/usr/share/X11/fonts/TTF");
+      pInfo->AddPath("%%LOCALBASE%%/data/fonts/otfonts");
+      pInfo->AddPath("%%LOCALBASE%%/data/fonts/ttfonts");
       pInfo->AddPath("/usr/local/share/fonts");
     }
     return pInfo;
diff --git a/chromium/third_party/pdfium/fxjs/cjs_publicmethods.cpp b/chromium/third_party/pdfium/fxjs/cjs_publicmethods.cpp
index 02dced8..117bddb 100644
--- a/chromium/third_party/pdfium/fxjs/cjs_publicmethods.cpp
+++ b/chromium/third_party/pdfium/fxjs/cjs_publicmethods.cpp
@@ -87,6 +87,103 @@ constexpr const wchar_t* kDateFormats[] = {L"m/d",
 constexpr const wchar_t* kTimeFormats[] = {L"HH:MM", L"h:MM tt", L"HH:MM:ss",
                                            L"h:MM:ss tt"};
 
+#if defined(__HAIKU__)
+/*
+ * cvt.c - IEEE floating point formatting routines for FreeBSD
+ * from GNU libc-4.6.27
+ */
+
+/*
+ *    ap_ecvt converts to decimal
+ *      the number of digits is specified by ndigit
+ *      decpt is set to the position of the decimal point
+ *      sign is set to 0 for positive, 1 for negative
+ */
+
+#define	NDIG	80
+
+static char *
+     ap_cvt(double arg, int ndigits, int *decpt, int *sign, int eflag)
+{
+    register int r2;
+    double fi, fj;
+    register char *p, *p1;
+    static char buf[NDIG];
+
+    if (ndigits >= NDIG - 1)
+	ndigits = NDIG - 2;
+    r2 = 0;
+    *sign = 0;
+    p = &buf[0];
+    if (arg < 0) {
+	*sign = 1;
+	arg = -arg;
+    }
+    arg = modf(arg, &fi);
+    p1 = &buf[NDIG];
+    /*
+     * Do integer part
+     */
+    if (fi != 0) {
+	p1 = &buf[NDIG];
+	while (fi != 0) {
+	    fj = modf(fi / 10, &fi);
+	    *--p1 = (int) ((fj + .03) * 10) + '0';
+	    r2++;
+	}
+	while (p1 < &buf[NDIG])
+	    *p++ = *p1++;
+    }
+    else if (arg > 0) {
+	while ((fj = arg * 10) < 1) {
+	    arg = fj;
+	    r2--;
+	}
+    }
+    p1 = &buf[ndigits];
+    if (eflag == 0)
+	p1 += r2;
+    *decpt = r2;
+    if (p1 < &buf[0]) {
+	buf[0] = '\0';
+        return (buf);
+    }
+    while (p <= p1 && p < &buf[NDIG]) {
+	arg *= 10;
+	arg = modf(arg, &fj);
+	*p++ = (int) fj + '0';
+    }
+    if (p1 >= &buf[NDIG]) {
+	buf[NDIG - 1] = '\0';
+	return (buf);
+    }
+    p = p1;
+    *p1 += 5;
+    while (*p1 > '9') {
+	*p1 = '0';
+	if (p1 > buf)
+	    ++ * --p1;
+	else {
+	    *p1 = '1';
+	    (*decpt)++;
+	    if (eflag == 0) {
+		if (p > buf)
+		    *p = '0';
+		p++;
+	    }
+	}
+    }
+    *p = '\0';
+    return (buf);
+}
+
+static char *
+     fcvt(double arg, int ndigits, int *decpt, int *sign)
+{
+     return (ap_cvt(arg, ndigits, decpt, sign, 0));
+}
+#endif // defined(__FreeBSD__)
+
 template <typename T>
 T StrTrim(const T& str) {
   T result = str;
diff --git a/chromium/third_party/pdfium/fxjs/fx_date_helpers.cpp b/chromium/third_party/pdfium/fxjs/fx_date_helpers.cpp
index 24d6890..5774870 100644
--- a/chromium/third_party/pdfium/fxjs/fx_date_helpers.cpp
+++ b/chromium/third_party/pdfium/fxjs/fx_date_helpers.cpp
@@ -36,6 +36,11 @@ double GetLocalTZA() {
     return 0;
   time_t t = 0;
   FXSYS_time(&t);
+#ifdef __HAIKU__
+  struct tm lt;
+  localtime_r(&t, &lt);
+  return (double)(-(lt.tm_gmtoff * 1000));
+#else
   FXSYS_localtime(&t);
 #if defined(OS_WIN)
   // In gcc 'timezone' is a global variable declared in time.h. In VC++, that
@@ -44,6 +49,7 @@ double GetLocalTZA() {
   _get_timezone(&timezone);
 #endif
   return (double)(-(timezone * 1000));
+#endif // __HAIKU__
 }
 
 int GetDaylightSavingTA(double d) {
diff --git a/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h b/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h
index 6f2a38b..d6734e1 100644
--- a/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h
+++ b/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h
@@ -75,7 +75,7 @@ PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE int PageAllocationGranu
   // compiled for 64kB are likely to work on 4kB systems, 64kB is a good choice
   // here.
   return 16;  // 64kB
-#elif defined(_MIPS_ARCH_LOONGSON)
+#elif defined(_MIPS_ARCH_LOONGSON) || defined(ARCH_CPU_PPC64)
   return 14;  // 16kB
 #elif defined(OS_LINUX) && defined(ARCH_CPU_ARM64)
   // arm64 supports 4kb (shift = 12), 16kb (shift = 14), and 64kb (shift = 16)
diff --git a/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_internals_posix.h b/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_internals_posix.h
index 8136ad2..8fa847f 100644
--- a/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_internals_posix.h
+++ b/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_internals_posix.h
@@ -16,7 +16,7 @@
 #if defined(OS_ANDROID)
 #include <sys/prctl.h>
 #endif
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include <sys/resource.h>
 
 #include <algorithm>
diff --git a/chromium/third_party/perfetto/buildtools/BUILD.gn b/chromium/third_party/perfetto/buildtools/BUILD.gn
index fa03107..99ed2b3 100644
--- a/chromium/third_party/perfetto/buildtools/BUILD.gn
+++ b/chromium/third_party/perfetto/buildtools/BUILD.gn
@@ -51,8 +51,12 @@ config("test_warning_suppressions") {
   } else {
     cflags = [
       "-Wno-unknown-warning-option",
-      "-Wno-deprecated-copy",
     ]
+    if (!is_haiku) {
+      cflags = [
+        "-Wno-deprecated-copy",
+      ]
+    }
   }
 }
 
diff --git a/chromium/third_party/perfetto/include/perfetto/base/build_config.h b/chromium/third_party/perfetto/include/perfetto/base/build_config.h
index bd3623f..40f6a6c 100644
--- a/chromium/third_party/perfetto/include/perfetto/base/build_config.h
+++ b/chromium/third_party/perfetto/include/perfetto/base/build_config.h
@@ -27,6 +27,7 @@
 #if defined(__ANDROID__)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
@@ -38,6 +39,7 @@
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
@@ -54,6 +56,17 @@
 #elif defined(__linux__)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_NACL() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_IOS() 0
+#elif defined(__HAIKU__)
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
@@ -64,6 +77,7 @@
 #elif defined(_WIN32)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
@@ -74,6 +88,7 @@
 #elif defined(__EMSCRIPTEN__)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
@@ -87,6 +102,7 @@
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_IOS() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 1
@@ -94,6 +110,7 @@
 #elif defined(__native_client__)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_HAIKU() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
diff --git a/chromium/third_party/perfetto/include/perfetto/base/thread_utils.h b/chromium/third_party/perfetto/include/perfetto/base/thread_utils.h
index 48a6508..539bcaa 100644
--- a/chromium/third_party/perfetto/include/perfetto/base/thread_utils.h
+++ b/chromium/third_party/perfetto/include/perfetto/base/thread_utils.h
@@ -29,7 +29,11 @@
 #include <zircon/types.h>
 #elif PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
+#if PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
+#include <OS.h>
+#else
 #include <sys/syscall.h>
+#endif
 #include <sys/types.h>
 #include <unistd.h>
 #else
@@ -44,6 +48,11 @@ using PlatformThreadId = pid_t;
 inline PlatformThreadId GetThreadId() {
   return gettid();
 }
+#elif PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
+using PlatformThreadId = thread_id;
+inline PlatformThreadId GetThreadId() {
+  return find_thread(NULL);
+}
 #elif PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX)
 using PlatformThreadId = pid_t;
 inline PlatformThreadId GetThreadId() {
diff --git a/chromium/third_party/perfetto/include/perfetto/base/time.h b/chromium/third_party/perfetto/include/perfetto/base/time.h
index a9aaf65..ea87197 100644
--- a/chromium/third_party/perfetto/include/perfetto/base/time.h
+++ b/chromium/third_party/perfetto/include/perfetto/base/time.h
@@ -141,6 +141,9 @@ inline TimeNanos GetTimeInternalNs(clockid_t clk_id) {
 // Return ns from boot. Conversely to GetWallTimeNs, this clock counts also time
 // during suspend (when supported).
 inline TimeNanos GetBootTimeNs() {
+#if PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
+  return GetTimeInternalNs(kWallTimeClockSource);
+#else
   // Determine if CLOCK_BOOTTIME is available on the first call.
   static const clockid_t kBootTimeClockSource = [] {
     struct timespec ts = {};
@@ -148,6 +151,7 @@ inline TimeNanos GetBootTimeNs() {
     return res == 0 ? CLOCK_BOOTTIME : kWallTimeClockSource;
   }();
   return GetTimeInternalNs(kBootTimeClockSource);
+#endif
 }
 
 inline TimeNanos GetWallTimeNs() {
diff --git a/chromium/third_party/perfetto/include/perfetto/ext/base/event_fd.h b/chromium/third_party/perfetto/include/perfetto/ext/base/event_fd.h
index 9e1715b..55854d9 100644
--- a/chromium/third_party/perfetto/include/perfetto/ext/base/event_fd.h
+++ b/chromium/third_party/perfetto/include/perfetto/ext/base/event_fd.h
@@ -20,8 +20,8 @@
 #include "perfetto/base/build_config.h"
 #include "perfetto/ext/base/scoped_file.h"
 
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
-    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
+#if !PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU) && (PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
+    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID))
 #define PERFETTO_USE_EVENTFD() 1
 #else
 #define PERFETTO_USE_EVENTFD() 0
diff --git a/chromium/third_party/perfetto/include/perfetto/ext/base/thread_utils.h b/chromium/third_party/perfetto/include/perfetto/ext/base/thread_utils.h
index 26fadb9..7520f24 100644
--- a/chromium/third_party/perfetto/include/perfetto/ext/base/thread_utils.h
+++ b/chromium/third_party/perfetto/include/perfetto/ext/base/thread_utils.h
@@ -23,7 +23,8 @@
 
 #if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) ||   \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) || \
-    PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE)
+    PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE) || \
+    PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
 #include <pthread.h>
 #include <string.h>
 #include <algorithm>
@@ -37,7 +38,8 @@ namespace base {
 
 #if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) ||   \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) || \
-    PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE)
+    PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE) || \
+    PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
 // Sets the "comm" of the calling thread to the first 15 chars of the given
 // string.
 inline bool MaybeSetThreadName(const std::string& name) {
@@ -47,6 +49,8 @@ inline bool MaybeSetThreadName(const std::string& name) {
 
 #if PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE)
   return pthread_setname_np(buf) == 0;
+#elif PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
+  return rename_thread(find_thread(NULL), buf) == B_OK;
 #else
   return pthread_setname_np(pthread_self(), buf) == 0;
 #endif
diff --git a/chromium/third_party/perfetto/include/perfetto/ext/base/utils.h b/chromium/third_party/perfetto/include/perfetto/ext/base/utils.h
index b702d4f..57996be 100644
--- a/chromium/third_party/perfetto/include/perfetto/ext/base/utils.h
+++ b/chromium/third_party/perfetto/include/perfetto/ext/base/utils.h
@@ -23,6 +23,7 @@
 #include <errno.h>
 #include <stddef.h>
 #include <stdlib.h>
+#include <type_traits>
 #if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
 #include <sys/types.h>
 #endif
@@ -109,7 +110,7 @@ struct FreeDeleter {
 
 template <typename T>
 constexpr T AssumeLittleEndian(T value) {
-  static_assert(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__,
+  static_assert(std::is_same<T,T>::value && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__,
                 "Unimplemented on big-endian archs");
   return value;
 }
diff --git a/chromium/third_party/perfetto/include/perfetto/protozero/message.h b/chromium/third_party/perfetto/include/perfetto/protozero/message.h
index a47db7e..41c41d0 100644
--- a/chromium/third_party/perfetto/include/perfetto/protozero/message.h
+++ b/chromium/third_party/perfetto/include/perfetto/protozero/message.h
@@ -135,6 +135,13 @@ class PERFETTO_EXPORT Message {
 
     pos = proto_utils::WriteVarInt(proto_utils::MakeTagFixed<T>(field_id), pos);
     memcpy(pos, &value, sizeof(T));
+#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
+    for (size_t i = sizeof(T)/2; i--; ) {
+      uint8_t tmp = pos[i];
+      pos[i] = pos[sizeof(T)-1-i];
+      pos[sizeof(T)-1-i] = tmp;
+    }
+#endif
     pos += sizeof(T);
     // TODO: Optimize memcpy performance, see http://crbug.com/624311 .
     WriteToStream(buffer, pos);
diff --git a/chromium/third_party/perfetto/src/base/file_utils.cc b/chromium/third_party/perfetto/src/base/file_utils.cc
index b8020ad..622bd7d 100644
--- a/chromium/third_party/perfetto/src/base/file_utils.cc
+++ b/chromium/third_party/perfetto/src/base/file_utils.cc
@@ -89,7 +89,7 @@ ssize_t WriteAll(int fd, const void* buf, size_t count) {
 
 bool FlushFile(int fd) {
   PERFETTO_DCHECK(fd != 0);
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
+#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) && !PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU) || \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
   return !PERFETTO_EINTR(fdatasync(fd));
 #elif PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
diff --git a/chromium/third_party/perfetto/src/base/paged_memory.cc b/chromium/third_party/perfetto/src/base/paged_memory.cc
index 551c5ca..300a411 100644
--- a/chromium/third_party/perfetto/src/base/paged_memory.cc
+++ b/chromium/third_party/perfetto/src/base/paged_memory.cc
@@ -121,7 +121,8 @@ bool PagedMemory::AdviseDontNeed(void* p, size_t size) {
   PERFETTO_DCHECK(p_);
   PERFETTO_DCHECK(p >= p_);
   PERFETTO_DCHECK(static_cast<char*>(p) + size <= p_ + size_);
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) || PERFETTO_BUILDFLAG(PERFETTO_OS_NACL)
+#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) || PERFETTO_BUILDFLAG(PERFETTO_OS_NACL) \
+	 || PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
   // Discarding pages on Windows has more CPU cost than is justified for the
   // possible memory savings.
   return false;
diff --git a/chromium/third_party/perfetto/src/base/subprocess.cc b/chromium/third_party/perfetto/src/base/subprocess.cc
index b5c886a..8614379 100644
--- a/chromium/third_party/perfetto/src/base/subprocess.cc
+++ b/chromium/third_party/perfetto/src/base/subprocess.cc
@@ -35,8 +35,8 @@
 #include "perfetto/base/time.h"
 #include "perfetto/ext/base/utils.h"
 
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
-    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
+#if !PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU) && (PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
+    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID))
 #include <sys/prctl.h>
 #endif
 
@@ -60,8 +60,8 @@ struct ChildProcessArgs {
 // Don't add any dynamic allocation in this function. This will be invoked
 // under a fork(), potentially in a state where the allocator lock is held.
 void __attribute__((noreturn)) ChildProcess(ChildProcessArgs* args) {
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
-    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
+#if !PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU) && (PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
+    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID))
   // In no case we want a child process to outlive its parent process. This is
   // relevant for tests, so that a test failure/crash doesn't leave child
   // processes around that get reparented to init.
diff --git a/chromium/third_party/perfetto/src/base/thread_task_runner.cc b/chromium/third_party/perfetto/src/base/thread_task_runner.cc
index bed6b72..6d185f3 100644
--- a/chromium/third_party/perfetto/src/base/thread_task_runner.cc
+++ b/chromium/third_party/perfetto/src/base/thread_task_runner.cc
@@ -28,7 +28,7 @@
 #include "perfetto/ext/base/thread_utils.h"
 #include "perfetto/ext/base/unix_task_runner.h"
 
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
+#if (PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) && !PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)) || \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
 #include <sys/prctl.h>
 #endif
diff --git a/chromium/third_party/perfetto/src/base/unix_socket.cc b/chromium/third_party/perfetto/src/base/unix_socket.cc
index 09a5530..acd0424 100644
--- a/chromium/third_party/perfetto/src/base/unix_socket.cc
+++ b/chromium/third_party/perfetto/src/base/unix_socket.cc
@@ -625,7 +625,7 @@ void UnixSocket::ReadPeerCredentials() {
   if (sock_raw_.family() != SockFamily::kUnix)
     return;
 
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
+#if (PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX)) || \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
   struct ucred user_cred;
   socklen_t len = sizeof(user_cred);
diff --git a/chromium/third_party/perfetto/src/protozero/message.cc b/chromium/third_party/perfetto/src/protozero/message.cc
index cfc9b37..66801e0 100644
--- a/chromium/third_party/perfetto/src/protozero/message.cc
+++ b/chromium/third_party/perfetto/src/protozero/message.cc
@@ -23,12 +23,6 @@
 #include "perfetto/protozero/message_arena.h"
 #include "perfetto/protozero/message_handle.h"
 
-#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
-// The memcpy() for float and double below needs to be adjusted if we want to
-// support big endian CPUs. There doesn't seem to be a compelling need today.
-#error Unimplemented for big endian archs.
-#endif
-
 namespace protozero {
 
 namespace {
diff --git a/chromium/third_party/perfetto/src/protozero/proto_decoder.cc b/chromium/third_party/perfetto/src/protozero/proto_decoder.cc
index b606818..6b5b308 100644
--- a/chromium/third_party/perfetto/src/protozero/proto_decoder.cc
+++ b/chromium/third_party/perfetto/src/protozero/proto_decoder.cc
@@ -28,7 +28,8 @@ namespace protozero {
 using namespace proto_utils;
 
 #if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
-#error Unimplemented for big endian archs.
+#define BYTE_SWAP_TO_LE32(x) __builtin_bswap32(x)
+#define BYTE_SWAP_TO_LE64(x) __builtin_bswap64(x)
 #endif
 
 namespace {
diff --git a/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.h b/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.h
index 6b76b74..1655d35 100644
--- a/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.h
+++ b/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.h
@@ -21,6 +21,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include <limits>
 #include <unordered_map>
 #include <vector>
 
diff --git a/chromium/third_party/perfetto/src/tracing/core/tracing_service_impl.cc b/chromium/third_party/perfetto/src/tracing/core/tracing_service_impl.cc
index 9618933..0e22bc2 100644
--- a/chromium/third_party/perfetto/src/tracing/core/tracing_service_impl.cc
+++ b/chromium/third_party/perfetto/src/tracing/core/tracing_service_impl.cc
@@ -2571,6 +2571,7 @@ bool TracingServiceImpl::SnapshotClocks(
 
 #if !PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE) && \
     !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) &&   \
+    !PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU) && \
     !PERFETTO_BUILDFLAG(PERFETTO_OS_NACL)
   struct {
     clockid_t id;
diff --git a/chromium/third_party/perfetto/src/tracing/ipc/memfd.cc b/chromium/third_party/perfetto/src/tracing/ipc/memfd.cc
index 64025bf..d0a85d4 100644
--- a/chromium/third_party/perfetto/src/tracing/ipc/memfd.cc
+++ b/chromium/third_party/perfetto/src/tracing/ipc/memfd.cc
@@ -19,8 +19,9 @@
 #include <errno.h>
 
 #define PERFETTO_MEMFD_ENABLED()             \
-  PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) || \
-      PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX)
+  (PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) || \
+      PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX)) \
+      	&& !PERFETTO_BUILDFLAG(PERFETTO_OS_HAIKU)
 
 #if PERFETTO_MEMFD_ENABLED()
 
diff --git a/chromium/third_party/protobuf/src/google/protobuf/port_def.inc b/chromium/third_party/protobuf/src/google/protobuf/port_def.inc
index f1bd85d..e126473 100644
--- a/chromium/third_party/protobuf/src/google/protobuf/port_def.inc
+++ b/chromium/third_party/protobuf/src/google/protobuf/port_def.inc
@@ -510,7 +510,9 @@
 
 PROTOBUF_EXPORT_TEMPLATE_TEST(DEFAULT, );
 PROTOBUF_EXPORT_TEMPLATE_TEST(DEFAULT, __attribute__((visibility("default"))));
+#ifndef __HAIKU__
 PROTOBUF_EXPORT_TEMPLATE_TEST(MSVC_HACK, __declspec(dllexport));
+#endif
 PROTOBUF_EXPORT_TEMPLATE_TEST(DEFAULT, __declspec(dllimport));
 
 #undef PROTOBUF_EXPORT_TEMPLATE_TEST
diff --git a/chromium/third_party/skia/include/core/SkTypes.h b/chromium/third_party/skia/include/core/SkTypes.h
index 9f7c1d7..fbaf9f3 100644
--- a/chromium/third_party/skia/include/core/SkTypes.h
+++ b/chromium/third_party/skia/include/core/SkTypes.h
@@ -33,7 +33,7 @@
     #elif defined(linux) || defined(__linux) || defined(__FreeBSD__) || \
           defined(__OpenBSD__) || defined(__sun) || defined(__NetBSD__) || \
           defined(__DragonFly__) || defined(__Fuchsia__) || \
-          defined(__GLIBC__) || defined(__GNU__) || defined(__unix__)
+          defined(__GLIBC__) || defined(__GNU__) || defined(__unix__) || defined(__HAIKU__)
         #define SK_BUILD_FOR_UNIX
     #elif TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR
         #define SK_BUILD_FOR_IOS
diff --git a/chromium/third_party/skia/src/gpu/GrAutoLocaleSetter.h b/chromium/third_party/skia/src/gpu/GrAutoLocaleSetter.h
index aa24177..bbaeb81 100644
--- a/chromium/third_party/skia/src/gpu/GrAutoLocaleSetter.h
+++ b/chromium/third_party/skia/src/gpu/GrAutoLocaleSetter.h
@@ -27,7 +27,7 @@
 #define HAVE_XLOCALE 0
 #endif
 
-#if defined(SK_BUILD_FOR_ANDROID) || defined(__UCLIBC__) || defined(_NEWLIB_VERSION)
+#if defined(SK_BUILD_FOR_ANDROID) || defined(__UCLIBC__) || defined(_NEWLIB_VERSION) || defined(__HAIKU__)
 #define HAVE_LOCALE_T 0
 #else
 #define HAVE_LOCALE_T 1
diff --git a/chromium/third_party/skia/src/utils/SkParseColor.cpp b/chromium/third_party/skia/src/utils/SkParseColor.cpp
index 0dc3497..25e63f7 100644
--- a/chromium/third_party/skia/src/utils/SkParseColor.cpp
+++ b/chromium/third_party/skia/src/utils/SkParseColor.cpp
@@ -5,6 +5,7 @@
  * found in the LICENSE file.
  */
 
+#include <iterator>
 
 #include "include/utils/SkParse.h"
 
diff --git a/chromium/third_party/sqlite/BUILD.gn b/chromium/third_party/sqlite/BUILD.gn
index 60cb0d0..317723e 100644
--- a/chromium/third_party/sqlite/BUILD.gn
+++ b/chromium/third_party/sqlite/BUILD.gn
@@ -142,7 +142,7 @@ config("sqlite_warnings") {
       ]
     }
   }
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     cflags += [
       # SQLite doesn't believe in compiler warnings, preferring testing.
       # http://www.sqlite.org/faq.html#q17
@@ -195,7 +195,7 @@ component("chromium_sqlite3") {
     }
   }
 
-  if (is_linux || is_chromeos || is_android) {
+  if ((is_linux && !is_haiku) || is_chromeos || is_android) {
     defines += [
       # Linux provides fdatasync(), a faster equivalent of fsync().
       "fdatasync=fdatasync",
diff --git a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h
index 3a9407a..5bb391e 100755
--- a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h
+++ b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h
@@ -1132,7 +1132,7 @@ sctp_get_mbuf_for_msg(unsigned int space_needed, int want_header, int how, int a
 
 #define SCTP_IS_LISTENING(inp) ((inp->sctp_flags & SCTP_PCB_FLAGS_ACCEPTING) != 0)
 
-#if defined(__APPLE__) || defined(__DragonFly__) || defined(__linux__) || defined(__native_client__) || defined(__NetBSD__) || defined(_WIN32) || defined(__Fuchsia__)
+#if defined(__APPLE__) || defined(__DragonFly__) || defined(__linux__) || defined(__native_client__) || defined(__NetBSD__) || defined(_WIN32) || defined(__Fuchsia__) || defined(__HAIKU__)
 int
 timingsafe_bcmp(const void *, const void *, size_t);
 #endif
diff --git a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_userspace.c b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_userspace.c
index 8e2ebf4..750e1bf 100755
--- a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_userspace.c
+++ b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_userspace.c
@@ -43,6 +43,9 @@
 #if defined(__linux__)
 #include <sys/prctl.h>
 #endif
+#if defined(__HAIKU__)
+#include <sys/sockio.h>
+#endif
 
 #if defined(_WIN32)
 /* Adapter to translate Unix thread start routines to Windows thread start
@@ -92,6 +95,9 @@ sctp_userspace_set_threadname(const char *name)
 #if defined(__FreeBSD__)
 	pthread_set_name_np(pthread_self(), name);
 #endif
+#if defined(__HAIKU__)
+	rename_thread(find_thread(NULL), name);
+#endif
 }
 
 #if !defined(_WIN32) && !defined(__native_client__)
@@ -126,7 +132,7 @@ sctp_userspace_get_mtu_from_ifn(uint32_t if_index, int af)
 }
 #endif
 
-#if defined(__APPLE__) || defined(__DragonFly__) || defined(__linux__) || defined(__native_client__) || defined(__NetBSD__) || defined(_WIN32) || defined(__Fuchsia__)
+#if defined(__APPLE__) || defined(__DragonFly__) || defined(__linux__) || defined(__native_client__) || defined(__NetBSD__) || defined(_WIN32) || defined(__Fuchsia__) || defined(__HAIKU__)
 int
 timingsafe_bcmp(const void *b1, const void *b2, size_t n)
 {
diff --git a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socket.c b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socket.c
index 7eb2470..3274a0f 100755
--- a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socket.c
+++ b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socket.c
@@ -594,6 +594,9 @@ copyiniov(struct iovec *iovp, u_int iovcnt, struct iovec **iov, int error)
 	u_int iovlen;
 
 	*iov = NULL;
+#ifndef UIO_MAXIOV
+#define UIO_MAXIOV IOV_MAX
+#endif
 	if (iovcnt > UIO_MAXIOV)
 		return (error);
 	iovlen = iovcnt * sizeof (struct iovec);
@@ -1035,7 +1038,7 @@ userspace_sctp_recvmsg(struct socket *so,
 	if (error) {
 		if ((auio.uio_resid != ulen) &&
 		    (error == EINTR ||
-#if !defined(__NetBSD__)
+#if !defined(__NetBSD__) && !defined(__HAIKU__)
 		     error == ERESTART ||
 #endif
 		     error == EWOULDBLOCK)) {
@@ -1128,7 +1131,7 @@ usrsctp_recvv(struct socket *so,
 	if (errno) {
 		if ((auio.uio_resid != ulen) &&
 		    (errno == EINTR ||
-#if !defined(__NetBSD__)
+#if !defined(__NetBSD__) && !defined(__HAIKU__)
 		     errno == ERESTART ||
 #endif
 		     errno == EWOULDBLOCK)) {
@@ -1944,7 +1947,7 @@ int user_connect(struct socket *so, struct sockaddr *sa)
 		error = pthread_cond_wait(SOCK_COND(so), SOCK_MTX(so));
 #endif
 		if (error) {
-#if defined(__NetBSD__)
+#if defined(__NetBSD__) || defined(__HAIKU__)
 			if (error == EINTR) {
 #else
 			if (error == EINTR || error == ERESTART) {
@@ -1964,7 +1967,7 @@ bad:
 	if (!interrupted) {
 		so->so_state &= ~SS_ISCONNECTING;
 	}
-#if !defined(__NetBSD__)
+#if !defined(__NetBSD__) && !defined(__HAIKU__)
 	if (error == ERESTART) {
 		error = EINTR;
 	}
diff --git a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socketvar.h b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socketvar.h
index 6b79b59..6081cd1 100755
--- a/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socketvar.h
+++ b/chromium/third_party/usrsctp/usrsctplib/usrsctplib/user_socketvar.h
@@ -155,7 +155,11 @@ struct socket {
 	short	so_timeo;		/* (g) connection timeout */
 	userland_cond_t timeo_cond;      /* timeo_cond condition variable being used in wakeup */
 
+#ifdef __HAIKU__
+	int	so_error;		/* (f) error affecting connection */
+#else
 	u_short	so_error;		/* (f) error affecting connection */
+#endif
 	struct	sigio *so_sigio;	/* [sg] information for async I/O or
 					   out of band data (SIGURG) */
 	u_long	so_oobmark;		/* (c) chars to oob mark */
diff --git a/chromium/third_party/webrtc/BUILD.gn b/chromium/third_party/webrtc/BUILD.gn
index cec97c5..75d7add 100644
--- a/chromium/third_party/webrtc/BUILD.gn
+++ b/chromium/third_party/webrtc/BUILD.gn
@@ -164,7 +164,7 @@ config("common_inherited_config") {
       target_gen_dir,
     ]
   }
-  if (is_posix || is_fuchsia) {
+  if (is_posix || is_fuchsia || is_haiku) {
     defines += [ "WEBRTC_POSIX" ]
   }
   if (is_ios) {
@@ -173,7 +173,7 @@ config("common_inherited_config") {
       "WEBRTC_IOS",
     ]
   }
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     defines += [ "WEBRTC_LINUX" ]
   }
   if (is_mac) {
@@ -182,6 +182,9 @@ config("common_inherited_config") {
   if (is_fuchsia) {
     defines += [ "WEBRTC_FUCHSIA" ]
   }
+  if (is_haiku) {
+    defines += [ "WEBRTC_HAIKU", "_BSD_SOURCE" ]
+  }
   if (is_win) {
     defines += [ "WEBRTC_WIN" ]
   }
diff --git a/chromium/third_party/webrtc/rtc_base/BUILD.gn b/chromium/third_party/webrtc/rtc_base/BUILD.gn
index 77bff8d..2c89c63 100644
--- a/chromium/third_party/webrtc/rtc_base/BUILD.gn
+++ b/chromium/third_party/webrtc/rtc_base/BUILD.gn
@@ -1004,7 +1004,7 @@ rtc_library("rtc_base") {
     deps += [ "system:cocoa_threading" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     libs += [
       "dl",
       "rt",
@@ -1032,6 +1032,10 @@ rtc_library("rtc_base") {
     ]
   }
 
+  if (is_haiku) {
+    defines += [ "_BSD_SOURCE" ]
+  }
+
   if (is_nacl) {
     public_deps +=  # no-presubmit-check TODO(webrtc:8603)
         [ "//native_client_sdk/src/libraries/nacl_io" ]
diff --git a/chromium/third_party/webrtc/rtc_base/ip_address.cc b/chromium/third_party/webrtc/rtc_base/ip_address.cc
index 9dd534c..77db2e1 100644
--- a/chromium/third_party/webrtc/rtc_base/ip_address.cc
+++ b/chromium/third_party/webrtc/rtc_base/ip_address.cc
@@ -33,12 +33,12 @@ namespace rtc {
 
 // Prefixes used for categorizing IPv6 addresses.
 static const in6_addr kV4MappedPrefix = {
-    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0}}};
-static const in6_addr k6To4Prefix = {{{0x20, 0x02, 0}}};
-static const in6_addr kTeredoPrefix = {{{0x20, 0x01, 0x00, 0x00}}};
-static const in6_addr kV4CompatibilityPrefix = {{{0}}};
-static const in6_addr k6BonePrefix = {{{0x3f, 0xfe, 0}}};
-static const in6_addr kPrivateNetworkPrefix = {{{0xFD}}};
+    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0}};
+static const in6_addr k6To4Prefix = {{0x20, 0x02, 0}};
+static const in6_addr kTeredoPrefix = {{0x20, 0x01, 0x00, 0x00}};
+static const in6_addr kV4CompatibilityPrefix = {{0}};
+static const in6_addr k6BonePrefix = {{0x3f, 0xfe, 0}};
+static const in6_addr kPrivateNetworkPrefix = {{0xFD}};
 
 static bool IPIsHelper(const IPAddress& ip,
                        const in6_addr& tomatch,
diff --git a/chromium/third_party/webrtc/rtc_base/network.cc b/chromium/third_party/webrtc/rtc_base/network.cc
index 8aabdcb..ad8b7e5 100644
--- a/chromium/third_party/webrtc/rtc_base/network.cc
+++ b/chromium/third_party/webrtc/rtc_base/network.cc
@@ -12,6 +12,10 @@
 
 #if defined(WEBRTC_POSIX)
 #include <net/if.h>
+#ifdef __HAIKU__
+#include <ifaddrs.h>
+#define IFF_RUNNING IFF_LINK
+#endif
 #endif  // WEBRTC_POSIX
 
 #if defined(WEBRTC_WIN)
diff --git a/chromium/third_party/webrtc/rtc_base/physical_socket_server.cc b/chromium/third_party/webrtc/rtc_base/physical_socket_server.cc
index cf6e792..dabcaa6 100644
--- a/chromium/third_party/webrtc/rtc_base/physical_socket_server.cc
+++ b/chromium/third_party/webrtc/rtc_base/physical_socket_server.cc
@@ -69,7 +69,7 @@ typedef void* SockOptArg;
 
 #endif  // WEBRTC_POSIX
 
-#if defined(WEBRTC_POSIX) && !defined(WEBRTC_MAC) && !defined(__native_client__)
+#if defined(WEBRTC_POSIX) && !defined(WEBRTC_MAC) && !defined(__native_client__) && !defined(__HAIKU__)
 
 int64_t GetSocketRecvTimestamp(int socket) {
   struct timeval tv_ioctl;
@@ -332,7 +332,7 @@ int PhysicalSocket::SetOption(Option opt, int value) {
     value <<= 2;
 #endif
   }
-#if defined(WEBRTC_POSIX)
+#if defined(WEBRTC_POSIX) && !defined(__HAIKU__)
   if (sopt == IPV6_TCLASS) {
     // Set the IPv4 option in all cases to support dual-stack sockets.
     ::setsockopt(s_, IPPROTO_IP, IP_TOS, (SockOptArg)&value, sizeof(value));
@@ -567,7 +567,7 @@ int PhysicalSocket::TranslateOption(Option opt, int* slevel, int* sopt) {
 #elif defined(WEBRTC_MAC) || defined(BSD) || defined(__native_client__)
       RTC_LOG(LS_WARNING) << "Socket::OPT_DONTFRAGMENT not supported.";
       return -1;
-#elif defined(WEBRTC_POSIX)
+#elif defined(WEBRTC_POSIX) && !defined(__HAIKU__)
       *slevel = IPPROTO_IP;
       *sopt = IP_MTU_DISCOVER;
       break;
@@ -585,7 +585,7 @@ int PhysicalSocket::TranslateOption(Option opt, int* slevel, int* sopt) {
       *sopt = TCP_NODELAY;
       break;
     case OPT_DSCP:
-#if defined(WEBRTC_POSIX)
+#if defined(WEBRTC_POSIX) && !defined(__HAIKU__)
       if (family_ == AF_INET6) {
         *slevel = IPPROTO_IPV6;
         *sopt = IPV6_TCLASS;
diff --git a/chromium/third_party/webrtc/rtc_base/platform_thread_types.cc b/chromium/third_party/webrtc/rtc_base/platform_thread_types.cc
index b0243b4..e97d934 100644
--- a/chromium/third_party/webrtc/rtc_base/platform_thread_types.cc
+++ b/chromium/third_party/webrtc/rtc_base/platform_thread_types.cc
@@ -13,6 +13,8 @@
 #if defined(WEBRTC_LINUX)
 #include <sys/prctl.h>
 #include <sys/syscall.h>
+#elif defined(WEBRTC_HAIKU)
+#include <OS.h>
 #endif
 
 #if defined(WEBRTC_WIN)
@@ -37,6 +39,8 @@ PlatformThreadId CurrentThreadId() {
   return gettid();
 #elif defined(WEBRTC_FUCHSIA)
   return zx_thread_self();
+#elif defined(WEBRTC_HAIKU)
+  return find_thread(NULL);
 #elif defined(WEBRTC_LINUX)
   return syscall(__NR_gettid);
 #elif defined(__EMSCRIPTEN__)
@@ -109,6 +113,8 @@ void SetCurrentThreadName(const char* name) {
   prctl(PR_SET_NAME, reinterpret_cast<unsigned long>(name));  // NOLINT
 #elif defined(WEBRTC_MAC) || defined(WEBRTC_IOS)
   pthread_setname_np(name);
+#elif defined(WEBRTC_HAIKU)
+  rename_thread(find_thread(NULL), name);
 #endif
 }
 
diff --git a/chromium/third_party/webrtc/rtc_base/system/rtc_export_template.h b/chromium/third_party/webrtc/rtc_base/system/rtc_export_template.h
index 4ac7043..65a9234 100644
--- a/chromium/third_party/webrtc/rtc_base/system/rtc_export_template.h
+++ b/chromium/third_party/webrtc/rtc_base/system/rtc_export_template.h
@@ -185,7 +185,9 @@
 
 RTC_EXPORT_TEMPLATE_TEST(DEFAULT, );  // NOLINT
 RTC_EXPORT_TEMPLATE_TEST(DEFAULT, __attribute__((visibility("default"))));
+#ifndef __HAIKU__
 RTC_EXPORT_TEMPLATE_TEST(MSVC_HACK, __declspec(dllexport));
+#endif
 RTC_EXPORT_TEMPLATE_TEST(DEFAULT, __declspec(dllimport));
 
 #undef RTC_EXPORT_TEMPLATE_TEST
diff --git a/chromium/third_party/webrtc/system_wrappers/BUILD.gn b/chromium/third_party/webrtc/system_wrappers/BUILD.gn
index b446648..c30cd76 100644
--- a/chromium/third_party/webrtc/system_wrappers/BUILD.gn
+++ b/chromium/third_party/webrtc/system_wrappers/BUILD.gn
@@ -64,6 +64,10 @@ rtc_library("system_wrappers") {
     }
 
     libs += [ "rt" ]
+
+    if (is_haiku) {
+      libs -= [ "rt" ]
+    }
   }
 
   if (is_win) {
diff --git a/chromium/third_party/webrtc/system_wrappers/source/cpu_info.cc b/chromium/third_party/webrtc/system_wrappers/source/cpu_info.cc
index 7288c67..ce72c96 100644
--- a/chromium/third_party/webrtc/system_wrappers/source/cpu_info.cc
+++ b/chromium/third_party/webrtc/system_wrappers/source/cpu_info.cc
@@ -12,7 +12,7 @@
 
 #if defined(WEBRTC_WIN)
 #include <windows.h>
-#elif defined(WEBRTC_LINUX)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_HAIKU)
 #include <unistd.h>
 #elif defined(WEBRTC_MAC)
 #include <sys/sysctl.h>
@@ -30,7 +30,7 @@ static int DetectNumberOfCores() {
   SYSTEM_INFO si;
   GetNativeSystemInfo(&si);
   number_of_cores = static_cast<int>(si.dwNumberOfProcessors);
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_ANDROID)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_ANDROID) || defined(WEBRTC_HAIKU)
   number_of_cores = static_cast<int>(sysconf(_SC_NPROCESSORS_ONLN));
   if (number_of_cores < 0) {
     RTC_LOG(LS_ERROR) << "Failed to get number of cores";
diff --git a/chromium/third_party/yasm/source/config/haiku/config.h b/chromium/third_party/yasm/source/config/haiku/config.h
new file mode 100644
index 0000000..21eb088
--- /dev/null
+++ b/chromium/third_party/yasm/source/config/haiku/config.h
@@ -0,0 +1,173 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Command name to run C preprocessor */
+#define CPP_PROG "cc -E"
+
+/* */
+#define ENABLE_NLS 1
+
+/* Define to 1 if you have the `abort' function. */
+#define HAVE_ABORT 1
+
+/* */
+/* #undef HAVE_CATGETS */
+
+/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the <direct.h> header file. */
+/* #undef HAVE_DIRECT_H */
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* */
+#define HAVE_GETTEXT 1
+
+/* Define to 1 if you have the GNU C Library */
+/* #undef HAVE_GNU_C_LIBRARY */
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* */
+/* #undef HAVE_LC_MESSAGES */
+
+/* Define to 1 if you have the <libgen.h> header file. */
+#define HAVE_LIBGEN_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mergesort' function. */
+#define HAVE_MERGESORT 1
+
+/* Define to 1 if you have the `popen' function. */
+#define HAVE_POPEN 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* */
+/* #undef HAVE_STPCPY */
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strcmpi' function. */
+/* #undef HAVE_STRCMPI */
+
+/* Define to 1 if you have the `stricmp' function. */
+/* #undef HAVE_STRICMP */
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#define HAVE_STRNCASECMP 1
+
+/* Define to 1 if you have the `strsep' function. */
+/* #undef HAVE_STRSEP */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the `toascii' function. */
+#define HAVE_TOASCII 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Define to 1 if you have the `_stricmp' function. */
+/* #undef HAVE__STRICMP */
+
+/* Name of package */
+#define PACKAGE "yasm"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "bug-yasm@tortall.net"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "yasm"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "yasm 1.3.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "yasm"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.3.0"
+
+/* Define to 1 if the C compiler supports function prototypes. */
+#define PROTOTYPES 1
+
+/* The size of `char', as computed by sizeof. */
+/* #undef SIZEOF_CHAR */
+
+/* The size of `int', as computed by sizeof. */
+/* #undef SIZEOF_INT */
+
+/* The size of `long', as computed by sizeof. */
+/* #undef SIZEOF_LONG */
+
+/* The size of `short', as computed by sizeof. */
+/* #undef SIZEOF_SHORT */
+
+/* The size of `void*', as computed by sizeof. */
+/* #undef SIZEOF_VOIDP */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "1.3.0"
+
+/* Define if using the dmalloc debugging malloc package */
+/* #undef WITH_DMALLOC */
+
+/* Define like PROTOTYPES; this can be used by system headers. */
+#define __PROTOTYPES 1
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
diff --git a/chromium/third_party/yasm/source/config/haiku/libyasm-stdint.h b/chromium/third_party/yasm/source/config/haiku/libyasm-stdint.h
new file mode 100644
index 0000000..5780da8
--- /dev/null
+++ b/chromium/third_party/yasm/source/config/haiku/libyasm-stdint.h
@@ -0,0 +1,9 @@
+#ifndef _YASM_LIBYASM_STDINT_H
+#define _YASM_LIBYASM_STDINT_H 1
+#ifndef _GENERATED_STDINT_H
+#define _GENERATED_STDINT_H "yasm 1.3.0"
+/* generated using gcc */
+#define _STDINT_HAVE_STDINT_H 1
+#include <stdint.h>
+#endif
+#endif
diff --git a/chromium/tools/grit/grit/node/base.py b/chromium/tools/grit/grit/node/base.py
index 521f779..b5c60c2 100644
--- a/chromium/tools/grit/grit/node/base.py
+++ b/chromium/tools/grit/grit/node/base.py
@@ -498,9 +498,11 @@ class Node(object):
         value = target_platform == 'ios'
       elif name == 'is_bsd':
         value = 'bsd' in target_platform
+      elif name == 'is_haiku':
+        value = target_platform.startswith('haiku')
       elif name == 'is_posix':
         value = (target_platform in ('darwin', 'linux2', 'linux3', 'sunos5',
-                                     'android', 'ios')
+                                     'android', 'ios', 'haiku1')
                  or 'bsd' in target_platform)
 
       elif name == 'pp_ifdef':
diff --git a/chromium/tools/perf/chrome_telemetry_build/BUILD.gn b/chromium/tools/perf/chrome_telemetry_build/BUILD.gn
index 280bb75..4868810 100644
--- a/chromium/tools/perf/chrome_telemetry_build/BUILD.gn
+++ b/chromium/tools/perf/chrome_telemetry_build/BUILD.gn
@@ -43,7 +43,7 @@ group("telemetry_chrome_test") {
     data_deps += [ "//chrome:reorder_imports" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if ((is_linux && !is_haiku) || is_chromeos) {
     data_deps += [ "//third_party/breakpad:dump_syms($host_toolchain)" ]
 
     # CrOS currently has issues with the locally compiled version of
diff --git a/chromium/ui/base/ui_features.gni b/chromium/ui/base/ui_features.gni
index e5203cd..2aa6413 100644
--- a/chromium/ui/base/ui_features.gni
+++ b/chromium/ui/base/ui_features.gni
@@ -6,7 +6,7 @@ import("//build/config/ui.gni")
 
 declare_args() {
   # Optional system library.
-  use_xkbcommon = use_ozone && (is_linux || is_chromeos) && !is_chromecast
+  use_xkbcommon = use_ozone && (is_linux || is_chromeos) && !is_chromecast && !is_haiku
 
   # Whether the platform provides a native accessibility toolkit.
   has_native_accessibility = use_atk || is_win || is_mac
diff --git a/chromium/ui/compositor/compositor.cc b/chromium/ui/compositor/compositor.cc
index 975f772..ebc00da 100644
--- a/chromium/ui/compositor/compositor.cc
+++ b/chromium/ui/compositor/compositor.cc
@@ -730,7 +730,7 @@ void Compositor::CancelThroughtputTracker(TrackerId tracker_id) {
   throughput_tracker_map_.erase(tracker_id);
 }
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
 void Compositor::OnCompleteSwapWithNewSize(const gfx::Size& size) {
   for (auto& observer : observer_list_)
     observer.OnCompositingCompleteSwapWithNewSize(this, size);
diff --git a/chromium/ui/compositor/compositor.h b/chromium/ui/compositor/compositor.h
index 32cdffd..204ccb3 100644
--- a/chromium/ui/compositor/compositor.h
+++ b/chromium/ui/compositor/compositor.h
@@ -366,7 +366,7 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
   void StopThroughtputTracker(TrackerId tracker_id) override;
   void CancelThroughtputTracker(TrackerId tracker_id) override;
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_HAIKU)
   void OnCompleteSwapWithNewSize(const gfx::Size& size);
 #endif
 
diff --git a/chromium/ui/compositor/compositor_observer.h b/chromium/ui/compositor/compositor_observer.h
index a5d845d..cfe3fe9 100644
--- a/chromium/ui/compositor/compositor_observer.h
+++ b/chromium/ui/compositor/compositor_observer.h
@@ -42,11 +42,11 @@ class COMPOSITOR_EXPORT CompositorObserver {
   // Called when a child of the compositor is resizing.
   virtual void OnCompositingChildResizing(Compositor* compositor) {}
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
   // Called when a swap with new size is completed.
   virtual void OnCompositingCompleteSwapWithNewSize(ui::Compositor* compositor,
                                                     const gfx::Size& size) {}
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
 
   // Called at the top of the compositor's destructor, to give observers a
   // chance to remove themselves.
diff --git a/chromium/ui/events/keycodes/dom/keycode_converter.cc b/chromium/ui/events/keycodes/dom/keycode_converter.cc
index 1840608..6d66230 100644
--- a/chromium/ui/events/keycodes/dom/keycode_converter.cc
+++ b/chromium/ui/events/keycodes/dom/keycode_converter.cc
@@ -20,7 +20,7 @@ namespace {
 #if defined(OS_WIN)
 #define DOM_CODE(usb, evdev, xkb, win, mac, code, id) \
   { usb, win, code }
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #define DOM_CODE(usb, evdev, xkb, win, mac, code, id) \
   { usb, xkb, code }
 #elif defined(OS_APPLE)
diff --git a/chromium/ui/events/ozone/keyboard_hook_ozone.cc b/chromium/ui/events/ozone/keyboard_hook_ozone.cc
index f7853ef..4293bae 100644
--- a/chromium/ui/events/ozone/keyboard_hook_ozone.cc
+++ b/chromium/ui/events/ozone/keyboard_hook_ozone.cc
@@ -29,7 +29,7 @@ bool KeyboardHookOzone::RegisterHook() {
   return true;
 }
 
-#if !defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_HAIKU)
 // static
 std::unique_ptr<KeyboardHook> KeyboardHook::CreateModifierKeyboardHook(
     base::Optional<base::flat_set<DomCode>> dom_codes,
diff --git a/chromium/ui/gfx/BUILD.gn b/chromium/ui/gfx/BUILD.gn
index a368ec1..e3b1f58 100644
--- a/chromium/ui/gfx/BUILD.gn
+++ b/chromium/ui/gfx/BUILD.gn
@@ -560,7 +560,7 @@ jumbo_source_set("memory_buffer_sources") {
     "//ui/gfx/geometry",
   ]
 
-  if ((is_linux || is_chromeos) && !use_qt) {
+  if ((is_linux || is_chromeos) && !is_haiku && !use_qt) {
     sources += [
       "linux/client_native_pixmap_dmabuf.cc",
       "linux/client_native_pixmap_dmabuf.h",
@@ -573,7 +573,7 @@ jumbo_source_set("memory_buffer_sources") {
     deps += [ "//build/config/linux/libdrm" ]
   }
 
-  if (is_linux || is_chromeos || is_android) {
+  if ((is_linux || is_chromeos || is_android) && !is_haiku) {
     deps += [ "//third_party/libsync" ]
   }
 
diff --git a/chromium/ui/gfx/font_render_params.h b/chromium/ui/gfx/font_render_params.h
index 5043313..3ff42ce 100644
--- a/chromium/ui/gfx/font_render_params.h
+++ b/chromium/ui/gfx/font_render_params.h
@@ -111,7 +111,7 @@ GFX_EXPORT FontRenderParams GetFontRenderParams(
     const FontRenderParamsQuery& query,
     std::string* family_out);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // Clears GetFontRenderParams()'s cache. Intended to be called by tests that are
 // changing Fontconfig's configuration.
 GFX_EXPORT void ClearFontRenderParamsCacheForTest();
@@ -121,7 +121,7 @@ GFX_EXPORT void ClearFontRenderParamsCacheForTest();
 GFX_EXPORT float GetFontRenderParamsDeviceScaleFactor();
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID) || defined(OS_FUCHSIA)
+    defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
 // Sets the device scale factor for FontRenderParams to decide
 // if it should enable subpixel positioning.
 GFX_EXPORT void SetFontRenderParamsDeviceScaleFactor(
diff --git a/chromium/ui/gfx/gpu_memory_buffer.h b/chromium/ui/gfx/gpu_memory_buffer.h
index 259e142..ab9a828 100644
--- a/chromium/ui/gfx/gpu_memory_buffer.h
+++ b/chromium/ui/gfx/gpu_memory_buffer.h
@@ -15,7 +15,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/gfx_export.h"
 
-#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "ui/gfx/native_pixmap_handle.h"
 #elif defined(OS_MAC)
 #include "ui/gfx/mac/io_surface.h"
@@ -69,7 +69,7 @@ struct GFX_EXPORT GpuMemoryBufferHandle {
   base::UnsafeSharedMemoryRegion region;
   uint32_t offset = 0;
   int32_t stride = 0;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
   NativePixmapHandle native_pixmap_handle;
 #elif defined(OS_MAC)
   ScopedRefCountedIOSurfaceMachPort mach_port;
diff --git a/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.cc b/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.cc
index 15e5b8b..dac303c 100644
--- a/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.cc
+++ b/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.cc
@@ -8,15 +8,15 @@
 
 namespace mojo {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_HAIKU)
 mojo::PlatformHandle StructTraits<
     gfx::mojom::NativePixmapPlaneDataView,
     gfx::NativePixmapPlane>::buffer_handle(gfx::NativePixmapPlane& plane) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   return mojo::PlatformHandle(std::move(plane.fd));
 #elif defined(OS_FUCHSIA)
   return mojo::PlatformHandle(std::move(plane.vmo));
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 }
 
 bool StructTraits<
@@ -28,7 +28,7 @@ bool StructTraits<
   out->size = data.size();
 
   mojo::PlatformHandle handle = data.TakeBufferHandle();
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (!handle.is_fd())
     return false;
   out->fd = handle.TakeFD();
@@ -36,7 +36,7 @@ bool StructTraits<
   if (!handle.is_handle())
     return false;
   out->vmo = zx::vmo(handle.TakeHandle());
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
   return true;
 }
@@ -45,7 +45,7 @@ bool StructTraits<
     gfx::mojom::NativePixmapHandleDataView,
     gfx::NativePixmapHandle>::Read(gfx::mojom::NativePixmapHandleDataView data,
                                    gfx::NativePixmapHandle* out) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   out->modifier = data.modifier();
 #endif
 
@@ -58,6 +58,6 @@ bool StructTraits<
 
   return data.ReadPlanes(&out->planes);
 }
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_HAIKU)
 
 }  // namespace mojo
diff --git a/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.h b/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.h
index 6e9ed3d..9dcdd6e 100644
--- a/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.h
+++ b/chromium/ui/gfx/mojom/native_handle_types_mojom_traits.h
@@ -14,13 +14,13 @@
 #include "mojo/public/cpp/system/platform_handle.h"
 #include "ui/gfx/mojom/native_handle_types.mojom-shared.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_HAIKU)
 #include "ui/gfx/native_pixmap_handle.h"
 #endif
 
 namespace mojo {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_HAIKU)
 template <>
 struct COMPONENT_EXPORT(GFX_NATIVE_HANDLE_TYPES_SHARED_MOJOM_TRAITS)
     StructTraits<gfx::mojom::NativePixmapPlaneDataView,
@@ -48,7 +48,7 @@ struct COMPONENT_EXPORT(GFX_NATIVE_HANDLE_TYPES_SHARED_MOJOM_TRAITS)
     return pixmap_handle.planes;
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   static uint64_t modifier(const gfx::NativePixmapHandle& pixmap_handle) {
     return pixmap_handle.modifier;
   }
@@ -72,7 +72,7 @@ struct COMPONENT_EXPORT(GFX_NATIVE_HANDLE_TYPES_SHARED_MOJOM_TRAITS)
   static bool Read(gfx::mojom::NativePixmapHandleDataView data,
                    gfx::NativePixmapHandle* out);
 };
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_HAIKU)
 
 }  // namespace mojo
 
diff --git a/chromium/ui/gfx/native_pixmap_handle.cc b/chromium/ui/gfx/native_pixmap_handle.cc
index da02186..5bcb27a 100644
--- a/chromium/ui/gfx/native_pixmap_handle.cc
+++ b/chromium/ui/gfx/native_pixmap_handle.cc
@@ -34,7 +34,7 @@ NativePixmapPlane::NativePixmapPlane() : stride(0), offset(0), size(0) {}
 NativePixmapPlane::NativePixmapPlane(int stride,
                                      int offset,
                                      uint64_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
                                      ,
                                      base::ScopedFD fd
 #elif defined(OS_FUCHSIA)
@@ -45,7 +45,7 @@ NativePixmapPlane::NativePixmapPlane(int stride,
     : stride(stride),
       offset(offset),
       size(size)
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
       ,
       fd(std::move(fd))
 #elif defined(OS_FUCHSIA)
@@ -73,7 +73,7 @@ NativePixmapHandle& NativePixmapHandle::operator=(NativePixmapHandle&& other) =
 NativePixmapHandle CloneHandleForIPC(const NativePixmapHandle& handle) {
   NativePixmapHandle clone;
   for (auto& plane : handle.planes) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     DCHECK(plane.fd.is_valid());
     base::ScopedFD fd_dup(HANDLE_EINTR(dup(plane.fd.get())));
     if (!fd_dup.is_valid()) {
@@ -99,7 +99,7 @@ NativePixmapHandle CloneHandleForIPC(const NativePixmapHandle& handle) {
 #endif
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   clone.modifier = handle.modifier;
 #endif
 
diff --git a/chromium/ui/gfx/native_pixmap_handle.h b/chromium/ui/gfx/native_pixmap_handle.h
index 1748dd3..2b12dd1 100644
--- a/chromium/ui/gfx/native_pixmap_handle.h
+++ b/chromium/ui/gfx/native_pixmap_handle.h
@@ -15,7 +15,7 @@
 #include "build/build_config.h"
 #include "ui/gfx/gfx_export.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "base/files/scoped_file.h"
 #endif
 
@@ -32,7 +32,7 @@ struct GFX_EXPORT NativePixmapPlane {
   NativePixmapPlane(int stride,
                     int offset,
                     uint64_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
                     ,
                     base::ScopedFD fd
 #elif defined(OS_FUCHSIA)
@@ -53,7 +53,7 @@ struct GFX_EXPORT NativePixmapPlane {
   // This is necessary to map the buffers.
   uint64_t size;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // File descriptor for the underlying memory object (usually dmabuf).
   base::ScopedFD fd;
 #elif defined(OS_FUCHSIA)
@@ -82,7 +82,7 @@ struct GFX_EXPORT NativePixmapHandle {
 
   std::vector<NativePixmapPlane> planes;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // The modifier is retrieved from GBM library and passed to EGL driver.
   // Generally it's platform specific, and we don't need to modify it in
   // Chromium code. Also one per plane per entry.
diff --git a/chromium/ui/gfx/native_widget_types.h b/chromium/ui/gfx/native_widget_types.h
index f823bb3..551fbcf 100644
--- a/chromium/ui/gfx/native_widget_types.h
+++ b/chromium/ui/gfx/native_widget_types.h
@@ -191,6 +191,11 @@ typedef ui::WindowAndroid* NativeWindow;
 typedef base::android::ScopedJavaGlobalRef<jobject> NativeEvent;
 constexpr NativeView kNullNativeView = nullptr;
 constexpr NativeWindow kNullNativeWindow = nullptr;
+#elif defined(OS_HAIKU) // FIXME
+typedef void* NativeCursor;
+typedef void* NativeView;
+typedef void* NativeWindow;
+typedef void* NativeEvent;
 #else
 #error Unknown build environment.
 #endif
@@ -242,6 +247,9 @@ constexpr AcceleratedWidget kNullAcceleratedWidget = 0;
 #elif defined(OS_ANDROID)
 typedef ANativeWindow* AcceleratedWidget;
 constexpr AcceleratedWidget kNullAcceleratedWidget = 0;
+#elif defined(OS_HAIKU)
+typedef int32_t AcceleratedWidget;
+constexpr AcceleratedWidget kNullAcceleratedWidget = 0;
 #elif defined(USE_OZONE) || defined(USE_X11)
 typedef uint32_t AcceleratedWidget;
 constexpr AcceleratedWidget kNullAcceleratedWidget = 0;
diff --git a/chromium/ui/gl/BUILD.gn b/chromium/ui/gl/BUILD.gn
index cfcac64..02b0d9b 100644
--- a/chromium/ui/gl/BUILD.gn
+++ b/chromium/ui/gl/BUILD.gn
@@ -224,7 +224,7 @@ jumbo_component("gl") {
       ]
     }
 
-    if (is_posix && !is_fuchsia && !is_mac) {
+    if (is_posix && !is_fuchsia && !is_mac && !is_haiku) {
       # Windows has USE_EGL but doesn't support base::FileDescriptor.
       # libsync isn't supported or needed on MacOSX.
       # Fuchsia is excluded due to a libsync dependency and because it's
@@ -545,7 +545,7 @@ jumbo_static_library("test_support") {
     ]
   }
 
-  if (use_ozone) {
+  if (use_ozone && !is_haiku) {
     deps += [ "//ui/ozone" ]
   }
 }
diff --git a/chromium/ui/gl/features.gni b/chromium/ui/gl/features.gni
index 8d67693..748c327 100644
--- a/chromium/ui/gl/features.gni
+++ b/chromium/ui/gl/features.gni
@@ -13,7 +13,7 @@ declare_args() {
 
   # Should EGL support be compiled?
   # Can be overriden to test during bring up of EGL support on other platforms.
-  use_egl = is_win || is_android || is_linux || is_chromeos || is_fuchsia || is_mac
+  use_egl = is_win || is_android || is_linux || is_chromeos || is_fuchsia || is_mac || is_haiku
 
   # Should Dawn support be compiled to back the WebGPU implementation?
   # Also controls linking Dawn depedencies in such as SPIRV-Tools/SPIRV-Cross.
diff --git a/chromium/ui/gl/gl_fence.cc b/chromium/ui/gl/gl_fence.cc
index cecdbd1..189443d 100644
--- a/chromium/ui/gl/gl_fence.cc
+++ b/chromium/ui/gl/gl_fence.cc
@@ -18,7 +18,7 @@
 #include "ui/gl/gl_fence_apple.h"
 #endif
 
-#if defined(USE_EGL) && defined(OS_POSIX) && !defined(OS_APPLE)
+#if defined(USE_EGL) && defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_HAIKU)
 #define USE_GL_FENCE_ANDROID_NATIVE_FENCE_SYNC
 #include "ui/gl/gl_fence_android_native_fence_sync.h"
 #include "ui/gl/gl_surface_egl.h"
diff --git a/chromium/ui/gl/init/BUILD.gn b/chromium/ui/gl/init/BUILD.gn
index 0eadfaa..4fce67a 100644
--- a/chromium/ui/gl/init/BUILD.gn
+++ b/chromium/ui/gl/init/BUILD.gn
@@ -32,7 +32,13 @@ jumbo_component("init") {
 
   public_deps = [ "//ui/gl" ]
 
-  if (is_android) {
+  if (is_haiku && !use_ozone) {
+    sources += [
+      "gl_factory_haiku.cc",
+      "gl_initializer_haiku.cc",
+    ]
+    libs = [ "GL" ]
+  } else if (is_android) {
     sources += [
       "gl_factory_android.cc",
       "gl_initializer_android.cc",
diff --git a/chromium/ui/gl/init/gl_factory_haiku.cc b/chromium/ui/gl/init/gl_factory_haiku.cc
new file mode 100644
index 0000000..c5fb0ec
--- /dev/null
+++ b/chromium/ui/gl/init/gl_factory_haiku.cc
@@ -0,0 +1,138 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gl/init/gl_factory.h"
+
+#include "base/trace_event/trace_event.h"
+#include "ui/gl/gl_context.h"
+#include "ui/gl/gl_context_egl.h"
+#include "ui/gl/gl_context_stub.h"
+#include "ui/gl/gl_egl_api_implementation.h"
+#include "ui/gl/gl_implementation.h"
+#include "ui/gl/gl_share_group.h"
+#include "ui/gl/gl_surface.h"
+#include "ui/gl/gl_surface_egl.h"
+#include "ui/gl/gl_surface_stub.h"
+
+namespace gl {
+namespace init {
+
+std::vector<GLImplementation> GetAllowedGLImplementations() {
+  std::vector<GLImplementation> impls;
+  //impls.push_back(kGLImplementationDesktopGL);
+  impls.push_back(kGLImplementationEGLGLES2);
+  impls.push_back(kGLImplementationSwiftShaderGL);
+  return impls;
+}
+
+bool GetGLWindowSystemBindingInfo(GLWindowSystemBindingInfo* info) {
+  switch (GetGLImplementation()) {
+    case kGLImplementationDesktopGL:
+    case kGLImplementationEGLGLES2:
+      return GetGLWindowSystemBindingInfoEGL(info);
+    default:
+      return false;
+  }
+}
+
+scoped_refptr<GLContext> CreateGLContext(GLShareGroup* share_group,
+                                         GLSurface* compatible_surface,
+                                         const GLContextAttribs& attribs) {
+  TRACE_EVENT0("gpu", "gl::init::CreateGLContext");
+  switch (GetGLImplementation()) {
+    case kGLImplementationDesktopGL:
+    case kGLImplementationSwiftShaderGL:
+    case kGLImplementationEGLGLES2:
+      return InitializeGLContext(new GLContextEGL(share_group),
+                                 compatible_surface, attribs);
+    case kGLImplementationMockGL:
+      return new GLContextStub(share_group);
+    case kGLImplementationStubGL: {
+      scoped_refptr<GLContextStub> stub_context =
+          new GLContextStub(share_group);
+      stub_context->SetUseStubApi(true);
+      return stub_context;
+    }
+    default:
+      NOTREACHED();
+      return nullptr;
+  }
+}
+
+scoped_refptr<GLSurface> CreateViewGLSurface(gfx::AcceleratedWidget window) {
+  TRACE_EVENT0("gpu", "gl::init::CreateViewGLSurface");
+  switch (GetGLImplementation()) {
+    case kGLImplementationDesktopGL:
+    case kGLImplementationSwiftShaderGL:
+    case kGLImplementationEGLGLES2:
+      DCHECK(window != gfx::kNullAcceleratedWidget);
+      return InitializeGLSurface(new NativeViewGLSurfaceEGL(0, nullptr));
+    case kGLImplementationMockGL:
+    case kGLImplementationStubGL:
+      return new GLSurfaceStub;
+    default:
+      NOTREACHED();
+      return nullptr;
+  }
+}
+
+scoped_refptr<GLSurface> CreateOffscreenGLSurfaceWithFormat(
+    const gfx::Size& size, GLSurfaceFormat format) {
+  TRACE_EVENT0("gpu", "gl::init::CreateOffscreenGLSurface");
+  switch (GetGLImplementation()) {
+    case kGLImplementationDesktopGL:
+    case kGLImplementationSwiftShaderGL:
+    case kGLImplementationEGLGLES2:
+      if (GLSurfaceEGL::IsEGLSurfacelessContextSupported() &&
+          size.width() == 0 && size.height() == 0) {
+        return InitializeGLSurfaceWithFormat(new SurfacelessEGL(size), format);
+      } else {
+        return InitializeGLSurfaceWithFormat(new PbufferGLSurfaceEGL(size),
+                                             format);
+      }
+    case kGLImplementationMockGL:
+    case kGLImplementationStubGL:
+      return new GLSurfaceStub;
+    default:
+      NOTREACHED();
+      return nullptr;
+  }
+}
+
+void SetDisabledExtensionsPlatform(const std::string& disabled_extensions) {
+  GLImplementation implementation = GetGLImplementation();
+  DCHECK_NE(kGLImplementationNone, implementation);
+  switch (implementation) {
+    case kGLImplementationDesktopGL:
+    case kGLImplementationEGLGLES2:
+      SetDisabledExtensionsEGL(disabled_extensions);
+      break;
+    case kGLImplementationSwiftShaderGL:
+    case kGLImplementationMockGL:
+    case kGLImplementationStubGL:
+      break;
+    default:
+      NOTREACHED();
+  }
+}
+
+bool InitializeExtensionSettingsOneOffPlatform() {
+  GLImplementation implementation = GetGLImplementation();
+  DCHECK_NE(kGLImplementationNone, implementation);
+  switch (implementation) {
+    case kGLImplementationDesktopGL:
+    case kGLImplementationEGLGLES2:
+      return InitializeExtensionSettingsOneOffEGL();
+    case kGLImplementationSwiftShaderGL:
+    case kGLImplementationMockGL:
+    case kGLImplementationStubGL:
+      return true;
+    default:
+      NOTREACHED();
+      return false;
+  }
+}
+
+}  // namespace init
+}  // namespace gl
diff --git a/chromium/ui/gl/init/gl_initializer_haiku.cc b/chromium/ui/gl/init/gl_initializer_haiku.cc
new file mode 100644
index 0000000..bbffdaf
--- /dev/null
+++ b/chromium/ui/gl/init/gl_initializer_haiku.cc
@@ -0,0 +1,155 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gl/init/gl_initializer.h"
+
+#include "base/command_line.h"
+#include "base/logging.h"
+#include "base/path_service.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "ui/gfx/switches.h"
+#include "ui/gl/buildflags.h"
+#include "ui/gl/gl_bindings.h"
+#include "ui/gl/gl_egl_api_implementation.h"
+#include "ui/gl/gl_gl_api_implementation.h"
+#include "ui/gl/gl_surface_egl.h"
+#include "ui/gl/gl_switches.h"
+
+namespace gl {
+namespace init {
+
+namespace {
+
+#if defined(OS_OPENBSD) || defined(OS_HAIKU)
+const char kGLLibraryName[] = "libGL.so";
+#else
+const char kGLLibraryName[] = "libGL.so.1";
+#endif
+
+const char kGLESv2LibraryName[] = "libGLESv2.so.2";
+const char kEGLLibraryName[] = "libEGL.so.1";
+
+const char kGLESv2ANGLELibraryName[] = "libGLESv2.so";
+const char kEGLANGLELibraryName[] = "libEGL.so";
+
+#if BUILDFLAG(ENABLE_SWIFTSHADER)
+const char kGLESv2SwiftShaderLibraryName[] = "libGLESv2.so";
+const char kEGLSwiftShaderLibraryName[] = "libEGL.so";
+#endif
+
+bool InitializeStaticEGLInternal(GLImplementation implementation) {
+  base::FilePath glesv2_path(kGLESv2LibraryName);
+  base::FilePath egl_path(kEGLLibraryName);
+
+  const base::CommandLine* cmd = base::CommandLine::ForCurrentProcess();
+
+  if (implementation == kGLImplementationSwiftShaderGL) {
+#if BUILDFLAG(ENABLE_SWIFTSHADER)
+    base::FilePath module_path;
+    if (!base::PathService::Get(base::DIR_MODULE, &module_path))
+      return false;
+    module_path = module_path.Append("swiftshader/");
+
+    glesv2_path = module_path.Append(kGLESv2SwiftShaderLibraryName);
+    egl_path = module_path.Append(kEGLSwiftShaderLibraryName);
+#else
+    return false;
+#endif
+  } else if (cmd->GetSwitchValueASCII(switches::kUseGL) ==
+             kGLImplementationANGLEName) {
+    base::FilePath module_path;
+    if (!base::PathService::Get(base::DIR_MODULE, &module_path))
+      return false;
+
+    glesv2_path = module_path.Append(kGLESv2ANGLELibraryName);
+    egl_path = module_path.Append(kEGLANGLELibraryName);
+  }
+
+  base::NativeLibrary gles_library = LoadLibraryAndPrintError(glesv2_path);
+  if (!gles_library)
+    return false;
+  base::NativeLibrary egl_library = LoadLibraryAndPrintError(egl_path);
+  if (!egl_library) {
+    base::UnloadNativeLibrary(gles_library);
+    return false;
+  }
+
+  GLGetProcAddressProc get_proc_address =
+      reinterpret_cast<GLGetProcAddressProc>(
+          base::GetFunctionPointerFromNativeLibrary(egl_library,
+                                                    "eglGetProcAddress"));
+  if (!get_proc_address) {
+    LOG(ERROR) << "eglGetProcAddress not found.";
+    base::UnloadNativeLibrary(egl_library);
+    base::UnloadNativeLibrary(gles_library);
+    return false;
+  }
+
+  SetGLGetProcAddressProc(get_proc_address);
+  AddGLNativeLibrary(egl_library);
+  AddGLNativeLibrary(gles_library);
+  SetGLImplementation(kGLImplementationEGLGLES2);
+
+  InitializeStaticGLBindingsGL();
+  InitializeStaticGLBindingsEGL();
+
+  return true;
+}
+
+}  // namespace
+
+bool InitializeGLOneOffPlatform() {
+  switch (GetGLImplementation()) {
+    case kGLImplementationDesktopGL:
+      return true;
+    case kGLImplementationSwiftShaderGL:
+    case kGLImplementationEGLGLES2:
+      /*if (!GLSurfaceEGL::InitializeOneOff(gfx::GetXDisplay())) {
+        LOG(ERROR) << "GLSurfaceEGL::InitializeOneOff failed.";
+        return false;
+      }*/
+      return true;
+    default:
+      return true;
+  }
+}
+
+bool InitializeStaticGLBindings(GLImplementation implementation) {
+  // Prevent reinitialization with a different implementation. Once the gpu
+  // unit tests have initialized with kGLImplementationMock, we don't want to
+  // later switch to another GL implementation.
+  DCHECK_EQ(kGLImplementationNone, GetGLImplementation());
+
+  // Allow the main thread or another to initialize these bindings
+  // after instituting restrictions on I/O. Going forward they will
+  // likely be used in the browser process on most platforms. The
+  // one-time initialization cost is small, between 2 and 5 ms.
+  base::ThreadRestrictions::ScopedAllowIO allow_io;
+
+  switch (implementation) {
+    case kGLImplementationDesktopGL:
+    case kGLImplementationSwiftShaderGL:
+    case kGLImplementationEGLGLES2:
+      return InitializeStaticEGLInternal(implementation);
+    case kGLImplementationMockGL:
+    case kGLImplementationStubGL:
+      SetGLImplementation(implementation);
+      InitializeStaticGLBindingsGL();
+      return true;
+    default:
+      NOTREACHED();
+  }
+
+  return false;
+}
+
+void ShutdownGLPlatform() {
+  GLSurfaceEGL::ShutdownOneOff();
+  ClearBindingsEGL();
+  ClearBindingsGL();
+}
+
+}  // namespace init
+}  // namespace gl
diff --git a/chromium/ui/ozone/BUILD.gn b/chromium/ui/ozone/BUILD.gn
index 0820a47..5536634 100644
--- a/chromium/ui/ozone/BUILD.gn
+++ b/chromium/ui/ozone/BUILD.gn
@@ -136,7 +136,7 @@ jumbo_component("ozone_base") {
     "//ui/ozone/platform/*",
     "//ui/ozone/public/mojom",
   ]
-
+  
   configs += [ "//third_party/khronos:khronos_headers" ]
 
   # Out of tree platforms can depend on this.
diff --git a/chromium/ui/ozone/ozone.gni b/chromium/ui/ozone/ozone.gni
index 1cc62a1..e2e228a 100644
--- a/chromium/ui/ozone/ozone.gni
+++ b/chromium/ui/ozone/ozone.gni
@@ -72,7 +72,7 @@ declare_args() {
       ozone_platform = "x11"
       ozone_platform_drm = true
       ozone_platform_x11 = true
-    } else if (is_desktop_linux) {
+    } else if (is_desktop_linux && !is_haiku) {
       ozone_platform = "x11"
       ozone_platform_wayland = true
       ozone_platform_x11 = true
diff --git a/chromium/ui/ozone/public/surface_factory_ozone.h b/chromium/ui/ozone/public/surface_factory_ozone.h
index 773537d..be5a202 100644
--- a/chromium/ui/ozone/public/surface_factory_ozone.h
+++ b/chromium/ui/ozone/public/surface_factory_ozone.h
@@ -27,6 +27,8 @@
 #include "gpu/vulkan/vulkan_implementation.h"
 #endif
 
+#include <vulkan/vulkan_core.h>
+
 namespace gfx {
 class NativePixmap;
 }
diff --git a/chromium/v8/BUILD.gn b/chromium/v8/BUILD.gn
index ba99c75..fc157ba 100644
--- a/chromium/v8/BUILD.gn
+++ b/chromium/v8/BUILD.gn
@@ -308,7 +308,7 @@ if (v8_enable_snapshot_native_code_counters == "") {
 }
 if (v8_enable_pointer_compression == "") {
   v8_enable_pointer_compression =
-      v8_current_cpu == "arm64" || v8_current_cpu == "x64"
+      (v8_current_cpu == "arm64" || v8_current_cpu == "x64") && !is_haiku
 }
 if (v8_enable_fast_torque == "") {
   v8_enable_fast_torque = v8_enable_fast_mksnapshot
@@ -3861,7 +3861,6 @@ v8_source_set("v8_base_without_compiler") {
   # to implement atomic memory access
   if (v8_current_cpu == "mips" || v8_current_cpu == "mipsel" ||
       v8_current_cpu == "mips64" || v8_current_cpu == "mips64el" ||
-      v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" ||
       v8_current_cpu == "s390" || v8_current_cpu == "s390x") {
     libs += [ "atomic" ]
   }
@@ -4116,7 +4115,7 @@ v8_component("v8_libbase") {
     }
   }
 
-  if (is_linux || is_chromeos) {
+  if ((is_linux || is_chromeos) && !is_haiku) {
     sources += [
       "src/base/debug/stack_trace_posix.cc",
       "src/base/platform/platform-linux.cc",
@@ -4136,6 +4135,12 @@ v8_component("v8_libbase") {
       "dl",
       "rt",
     ]
+  } else if (is_haiku) {
+    sources += [
+      "src/base/debug/stack_trace_posix.cc",
+      "src/base/platform/platform-haiku.cc",
+    ]
+    libs = [ "execinfo" ]
   } else if (is_android) {
     if (current_toolchain == host_toolchain) {
       libs = [
@@ -4479,6 +4484,7 @@ if (v8_monolithic) {
       ":v8_libsampler",
       "//build/win:default_exe_manifest",
     ]
+    libs = ["execinfo"]
 
     configs = [ ":internal_config" ]
   }
diff --git a/chromium/v8/gni/v8.gni b/chromium/v8/gni/v8.gni
index 13ffc2c..e33b7bd 100644
--- a/chromium/v8/gni/v8.gni
+++ b/chromium/v8/gni/v8.gni
@@ -222,7 +222,7 @@ template("v8_executable") {
       configs -= invoker.remove_configs
     }
     configs += invoker.configs
-    if (is_linux || is_chromeos) {
+    if ((is_linux || is_chromeos) && !is_haiku) {
       # For enabling ASLR.
       ldflags = [ "-pie" ]
     }
diff --git a/chromium/v8/include/v8config.h b/chromium/v8/include/v8config.h
index a047874..257a36e 100644
--- a/chromium/v8/include/v8config.h
+++ b/chromium/v8/include/v8config.h
@@ -123,6 +123,9 @@
 # define V8_OS_QNX 1
 #elif defined(_WIN32)
 # define V8_OS_WIN 1
+#elif defined(__HAIKU__)
+# define V8_OS_HAIKU 1
+# define V8_OS_POSIX 1
 #endif
 
 // -----------------------------------------------------------------------------
@@ -276,7 +279,18 @@
 # define V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT \
     (__has_attribute(warn_unused_result))
 
+// Work around Clang bug present in 9.0.1, at least.
+//
+// Clang stores alignment as a 32-bit unsigned integer, but V8 only uses
+// V8_ASSUME_ALIGNED() for a 4GB (2^32) alignment
+// (kPtrComprIsolateRootAlignment).  As such, the alignment overflows and
+// becomes zero, triggering an internal Clang assertion that alignment must not
+// be zero.
+#if 0
 # define V8_HAS_BUILTIN_ASSUME_ALIGNED (__has_builtin(__builtin_assume_aligned))
+#else
+# define V8_HAS_BUILTIN_ASSUME_ALIGNED 0
+#endif
 # define V8_HAS_BUILTIN_BSWAP16 (__has_builtin(__builtin_bswap16))
 # define V8_HAS_BUILTIN_BSWAP32 (__has_builtin(__builtin_bswap32))
 # define V8_HAS_BUILTIN_BSWAP64 (__has_builtin(__builtin_bswap64))
diff --git a/chromium/v8/src/api/api.cc b/chromium/v8/src/api/api.cc
index 851a6fb..d22bfa2 100644
--- a/chromium/v8/src/api/api.cc
+++ b/chromium/v8/src/api/api.cc
@@ -116,7 +116,7 @@
 #include "src/wasm/wasm-result.h"
 #include "src/wasm/wasm-serialization.h"
 
-#if V8_OS_LINUX || V8_OS_MACOSX || V8_OS_FREEBSD
+#if V8_OS_LINUX || V8_OS_MACOSX || V8_OS_FREEBSD || V8_OS_HAIKU
 #include <signal.h>
 #include "include/v8-wasm-trap-handler-posix.h"
 #include "src/trap-handler/handler-inside-posix.h"
@@ -5760,7 +5760,7 @@ bool v8::V8::Initialize(const int build_config) {
   return true;
 }
 
-#if V8_OS_LINUX || V8_OS_MACOSX
+#if V8_OS_LINUX || V8_OS_MACOSX || V8_OS_OPENBSD || V8_OS_HAIKU
 bool TryHandleWebAssemblyTrapPosix(int sig_code, siginfo_t* info,
                                    void* context) {
 #if V8_TARGET_ARCH_X64 && !V8_OS_ANDROID
diff --git a/chromium/v8/src/base/cpu.cc b/chromium/v8/src/base/cpu.cc
index c0e9e70..40dac85 100644
--- a/chromium/v8/src/base/cpu.cc
+++ b/chromium/v8/src/base/cpu.cc
@@ -534,6 +534,7 @@ CPU::CPU()
 
 #if V8_OS_LINUX
 
+#if V8_OS_LINUX
   CPUInfo cpu_info;
 
   // Extract implementor from the "CPU implementer" field.
@@ -567,6 +568,7 @@ CPU::CPU()
     }
     delete[] part;
   }
+#endif
 
   // Extract architecture from the "CPU Architecture" field.
   // The list is well-known, unlike the the output of
diff --git a/chromium/v8/src/base/export-template.h b/chromium/v8/src/base/export-template.h
index 861cfe4..4bf4281 100644
--- a/chromium/v8/src/base/export-template.h
+++ b/chromium/v8/src/base/export-template.h
@@ -150,6 +150,7 @@
                 #export)
 #define EXPORT_TEMPLATE_TEST_DEFAULT_DEFAULT(...) true
 #define EXPORT_TEMPLATE_TEST_MSVC_HACK_MSVC_HACK(...) true
+#define EXPORT_TEMPLATE_TEST_MSVC_HACK_DEFAULT(...) true
 
 EXPORT_TEMPLATE_TEST(DEFAULT, );
 EXPORT_TEMPLATE_TEST(DEFAULT, __attribute__((visibility("default"))));
@@ -159,5 +160,6 @@ EXPORT_TEMPLATE_TEST(DEFAULT, __declspec(dllimport));
 #undef EXPORT_TEMPLATE_TEST
 #undef EXPORT_TEMPLATE_TEST_DEFAULT_DEFAULT
 #undef EXPORT_TEMPLATE_TEST_MSVC_HACK_MSVC_HACK
+#undef EXPORT_TEMPLATE_TEST_MSVC_HACK_DEFAULT
 
 #endif  // V8_BASE_EXPORT_TEMPLATE_H_
diff --git a/chromium/v8/src/base/platform/platform-freebsd.cc b/chromium/v8/src/base/platform/platform-freebsd.cc
deleted file mode 100644
index ed16ad0..0000000
--- a/chromium/v8/src/base/platform/platform-freebsd.cc
+++ /dev/null
@@ -1,119 +0,0 @@
-// Copyright 2012 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-// Platform-specific code for FreeBSD goes here. For the POSIX-compatible
-// parts, the implementation is in platform-posix.cc.
-
-#include <pthread.h>
-#include <pthread_np.h>
-#include <semaphore.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <sys/resource.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/ucontext.h>
-#include <sys/user.h>
-
-#include <sys/fcntl.h>  // open
-#include <sys/mman.h>   // mmap & munmap
-#include <sys/stat.h>   // open
-#include <sys/sysctl.h>
-#include <unistd.h>     // getpagesize
-// If you don't have execinfo.h then you need devel/libexecinfo from ports.
-#include <errno.h>
-#include <limits.h>
-#include <stdarg.h>
-#include <strings.h>    // index
-
-#include <cmath>
-
-#undef MAP_TYPE
-
-#include "src/base/macros.h"
-#include "src/base/platform/platform-posix-time.h"
-#include "src/base/platform/platform-posix.h"
-#include "src/base/platform/platform.h"
-
-namespace v8 {
-namespace base {
-
-TimezoneCache* OS::CreateTimezoneCache() {
-  return new PosixDefaultTimezoneCache();
-}
-
-static unsigned StringToLong(char* buffer) {
-  return static_cast<unsigned>(strtol(buffer, nullptr, 16));  // NOLINT
-}
-
-std::vector<OS::SharedLibraryAddress> OS::GetSharedLibraryAddresses() {
-  std::vector<SharedLibraryAddress> result;
-  int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_VMMAP, getpid()};
-  size_t miblen = sizeof(mib) / sizeof(mib[0]);
-  size_t buffer_size;
-  if (sysctl(mib, miblen, nullptr, &buffer_size, nullptr, 0) == 0) {
-    // Overallocate the buffer by 1/3 to account for concurrent
-    // kinfo_vmentry change. 1/3 is an arbitrary constant that
-    // works in practice.
-    buffer_size = buffer_size * 4 / 3;
-    std::vector<char> buffer(buffer_size);
-    int ret = sysctl(mib, miblen, buffer.data(), &buffer_size, nullptr, 0);
-
-    if (ret == 0 || (ret == -1 && errno == ENOMEM)) {
-      char* start = buffer.data();
-      char* end = start + buffer_size;
-
-      while (start < end) {
-        struct kinfo_vmentry* map =
-            reinterpret_cast<struct kinfo_vmentry*>(start);
-        const size_t ssize = map->kve_structsize;
-        char* path = map->kve_path;
-
-        CHECK_NE(0, ssize);
-
-        if ((map->kve_protection & KVME_PROT_READ) != 0 &&
-            (map->kve_protection & KVME_PROT_EXEC) != 0 && path[0] != '\0') {
-          char* sep = strrchr(path, '/');
-          std::string lib_name;
-          if (sep != nullptr) {
-            lib_name = std::string(++sep);
-          } else {
-            lib_name = std::string(path);
-          }
-          result.push_back(SharedLibraryAddress(
-              lib_name, reinterpret_cast<uintptr_t>(map->kve_start),
-              reinterpret_cast<uintptr_t>(map->kve_end)));
-        }
-
-        start += ssize;
-      }
-    }
-  }
-  return result;
-}
-
-void OS::SignalCodeMovingGC() {}
-
-void OS::AdjustSchedulingParams() {}
-
-// static
-void* Stack::GetStackStart() {
-  pthread_attr_t attr;
-  int error;
-  pthread_attr_init(&attr);
-  error = pthread_attr_get_np(pthread_self(), &attr);
-  if (!error) {
-    void* base;
-    size_t size;
-    error = pthread_attr_getstack(&attr, &base, &size);
-    CHECK(!error);
-    pthread_attr_destroy(&attr);
-    return reinterpret_cast<uint8_t*>(base) + size;
-  }
-  pthread_attr_destroy(&attr);
-  return nullptr;
-}
-
-}  // namespace base
-}  // namespace v8
diff --git a/chromium/v8/src/base/platform/platform-haiku.cc b/chromium/v8/src/base/platform/platform-haiku.cc
new file mode 100644
index 0000000..5697eb0
--- /dev/null
+++ b/chromium/v8/src/base/platform/platform-haiku.cc
@@ -0,0 +1,64 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Platform-specific code for FreeBSD goes here. For the POSIX-compatible
+// parts, the implementation is in platform-posix.cc.
+
+#include <pthread.h>
+#include <semaphore.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <sys/resource.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include <fcntl.h>  // open
+#include <sys/mman.h>   // mmap & munmap
+#include <sys/stat.h>   // open
+#include <unistd.h>     // getpagesize
+// If you don't have execinfo.h then you need devel/libexecinfo from ports.
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <strings.h>    // index
+
+#include <cmath>
+
+#include <OS.h>
+
+#undef MAP_TYPE
+
+#include "src/base/macros.h"
+#include "src/base/platform/platform-posix-time.h"
+#include "src/base/platform/platform-posix.h"
+#include "src/base/platform/platform.h"
+
+namespace v8 {
+namespace base {
+
+TimezoneCache* OS::CreateTimezoneCache() {
+  return new PosixDefaultTimezoneCache();
+}
+
+static unsigned StringToLong(char* buffer) {
+  return static_cast<unsigned>(strtol(buffer, nullptr, 16));  // NOLINT
+}
+
+std::vector<OS::SharedLibraryAddress> OS::GetSharedLibraryAddresses() {
+  return std::vector<SharedLibraryAddress>();
+}
+
+void OS::SignalCodeMovingGC() {}
+
+void OS::AdjustSchedulingParams() {}
+
+// static
+void* Stack::GetStackStart() {
+  thread_info threadInfo;
+  get_thread_info(find_thread(NULL), &threadInfo);
+  return threadInfo.stack_end;
+}
+
+}  // namespace base
+}  // namespace v8
diff --git a/chromium/v8/src/base/platform/platform-posix.cc b/chromium/v8/src/base/platform/platform-posix.cc
index 89173b5..8bcd1d2 100644
--- a/chromium/v8/src/base/platform/platform-posix.cc
+++ b/chromium/v8/src/base/platform/platform-posix.cc
@@ -61,7 +61,7 @@
 #include <sys/resource.h>
 #endif
 
-#if !defined(_AIX) && !defined(V8_OS_FUCHSIA)
+#if !defined(_AIX) && !defined(V8_OS_FUCHSIA) && !defined(V8_OS_HAIKU)
 #include <sys/syscall.h>
 #endif
 
@@ -466,7 +466,7 @@ bool OS::DiscardSystemPages(void* address, size_t size) {
 
 // static
 bool OS::HasLazyCommits() {
-#if V8_OS_AIX || V8_OS_LINUX || V8_OS_MACOSX
+#if V8_OS_AIX || V8_OS_LINUX || V8_OS_MACOSX || V8_OS_HAIKU
   return true;
 #else
   // TODO(bbudge) Return true for all POSIX platforms.
@@ -1002,7 +1002,7 @@ void Thread::SetThreadLocal(LocalStorageKey key, void* value) {
 // keep this version in POSIX as most Linux-compatible derivatives will
 // support it. MacOS and FreeBSD are different here.
 #if !defined(V8_OS_FREEBSD) && !defined(V8_OS_MACOSX) && !defined(_AIX) && \
-    !defined(V8_OS_SOLARIS)
+    !defined(V8_OS_SOLARIS) && !defined(V8_OS_HAIKU)
 
 // static
 void* Stack::GetStackStart() {
diff --git a/chromium/v8/src/libsampler/sampler.cc b/chromium/v8/src/libsampler/sampler.cc
index 9631d2f..6d95a0f 100644
--- a/chromium/v8/src/libsampler/sampler.cc
+++ b/chromium/v8/src/libsampler/sampler.cc
@@ -12,7 +12,7 @@
 #include <sys/time.h>
 #include <atomic>
 
-#if !V8_OS_QNX && !V8_OS_AIX
+#if !V8_OS_QNX && !V8_OS_AIX && !V8_OS_HAIKU
 #include <sys/syscall.h>  // NOLINT
 #endif
 
@@ -20,7 +20,7 @@
 #include <mach/mach.h>
 // OpenBSD doesn't have <ucontext.h>. ucontext_t lives in <signal.h>
 // and is a typedef for struct sigcontext. There is no uc_mcontext.
-#elif !V8_OS_OPENBSD
+#elif !V8_OS_OPENBSD && !V8_OS_HAIKU
 #include <ucontext.h>
 #endif
 
@@ -529,7 +529,21 @@ void SignalHandler::FillRegisterState(void* context, RegisterState* state) {
   state->sp = reinterpret_cast<void*>(mcontext.jmp_context.gpr[1]);
   state->fp = reinterpret_cast<void*>(mcontext.jmp_context.gpr[31]);
   state->lr = reinterpret_cast<void*>(mcontext.jmp_context.lr);
-#endif  // V8_OS_AIX
+#elif V8_OS_HAIKU
+#if V8_HOST_ARCH_IA32
+  state->pc = reinterpret_cast<void*>(mcontext.eip);
+  state->sp = reinterpret_cast<void*>(mcontext.esp);
+  state->fp = reinterpret_cast<void*>(mcontext.ebp);
+#elif V8_HOST_ARCH_X64
+  state->pc = reinterpret_cast<void*>(mcontext.rip);
+  state->sp = reinterpret_cast<void*>(mcontext.rsp);
+  state->fp = reinterpret_cast<void*>(mcontext.rbp);
+#elif V8_HOST_ARCH_ARM
+  state->pc = reinterpret_cast<void*>(mcontext.r15);
+  state->sp = reinterpret_cast<void*>(mcontext.r13);
+  state->fp = reinterpret_cast<void*>(mcontext.r11);
+#endif  // V8_HOST_ARCH_*
+#endif  // V8_OS_HAIKU
 }
 
 #endif  // USE_SIGNALS
diff --git a/chromium/v8/src/trap-handler/handler-inside-posix.cc b/chromium/v8/src/trap-handler/handler-inside-posix.cc
index 807a946..0077a70 100644
--- a/chromium/v8/src/trap-handler/handler-inside-posix.cc
+++ b/chromium/v8/src/trap-handler/handler-inside-posix.cc
@@ -120,6 +120,8 @@ bool TryHandleSignal(int signum, siginfo_t* info, void* context) {
     auto* context_ip = &uc->uc_mcontext.mc_rip;
 #elif V8_OS_FREEBSD && V8_HOST_ARCH_ARM64
     auto* context_ip = &uc->uc_mcontext.mc_pc;
+#elif V8_OS_HAIKU && V8_HOST_ARCH_X64
+    auto* context_ip = &uc->uc_mcontext.rip;
 #else
 #error Unsupported platform
 #endif
diff --git a/chromium/v8/src/trap-handler/handler-inside-posix.h b/chromium/v8/src/trap-handler/handler-inside-posix.h
index 49fe23a..9fc916f 100644
--- a/chromium/v8/src/trap-handler/handler-inside-posix.h
+++ b/chromium/v8/src/trap-handler/handler-inside-posix.h
@@ -12,7 +12,7 @@ namespace v8 {
 namespace internal {
 namespace trap_handler {
 
-#if V8_OS_LINUX || V8_OS_FREEBSD
+#if V8_OS_LINUX || V8_OS_FREEBSD || V8_OS_HAIKU
 constexpr int kOobSignal = SIGSEGV;
 #elif V8_OS_MACOSX
 constexpr int kOobSignal = SIGBUS;
diff --git a/chromium/v8/src/trap-handler/trap-handler.h b/chromium/v8/src/trap-handler/trap-handler.h
index f6fdca5..30786fb 100644
--- a/chromium/v8/src/trap-handler/trap-handler.h
+++ b/chromium/v8/src/trap-handler/trap-handler.h
@@ -25,6 +25,8 @@ namespace trap_handler {
 #define V8_TRAP_HANDLER_SUPPORTED true
 #elif V8_TARGET_ARCH_X64 && V8_OS_FREEBSD
 #define V8_TRAP_HANDLER_SUPPORTED true
+#elif V8_TARGET_ARCH_X64 && V8_OS_HAIKU
+#define V8_TRAP_HANDLER_SUPPORTED true
 #else
 #define V8_TRAP_HANDLER_SUPPORTED false
 #endif
diff --git a/chromium/v8/test/BUILD.gn b/chromium/v8/test/BUILD.gn
index c6045d1..ca562ec 100644
--- a/chromium/v8/test/BUILD.gn
+++ b/chromium/v8/test/BUILD.gn
@@ -36,7 +36,7 @@ group("gn_all") {
       "benchmarks/cpp:gn_all",
       "cctest:cctest",
       "cctest:generate-bytecode-expectations",
-      "unittests:unittests",
+      #"unittests:unittests",
     ]
   }
 }
@@ -78,10 +78,10 @@ group("v8_bot_default") {
     "message:v8_message",
     "mjsunit:v8_mjsunit",
     "mkgrokdump:mkgrokdump",
-    "unittests:unittests",
+    #"unittests:unittests",
     "wasm-api-tests:wasm_api_tests",
     "wasm-js:v8_wasm_js",
-    "wasm-spec-tests:v8_wasm_spec_tests",
+    #"wasm-spec-tests:v8_wasm_spec_tests",
     "webkit:v8_webkit",
   ]
 }
@@ -98,10 +98,10 @@ group("v8_default") {
     "message:v8_message",
     "mjsunit:v8_mjsunit",
     "mkgrokdump:mkgrokdump",
-    "unittests:unittests",
+    #"unittests:unittests",
     "wasm-api-tests:wasm_api_tests",
-    "wasm-js:v8_wasm_js",
-    "wasm-spec-tests:v8_wasm_spec_tests",
+    #"wasm-js:v8_wasm_js",
+    #"wasm-spec-tests:v8_wasm_spec_tests",
   ]
 }
 
diff --git a/gn/base/files/file.h b/gn/base/files/file.h
index 61239ad..4a4485a 100644
--- a/gn/base/files/file.h
+++ b/gn/base/files/file.h
@@ -23,7 +23,7 @@
 namespace base {
 
 #if defined(OS_BSD) || defined(OS_MACOSX) || defined(OS_NACL) || \
-    defined(OS_ANDROID) && __ANDROID_API__ < 21
+    defined(OS_ANDROID) && __ANDROID_API__ < 21 || defined(OS_HAIKU)
 typedef struct stat stat_wrapper_t;
 #elif defined(OS_POSIX) || defined(OS_FUCHSIA)
 typedef struct stat64 stat_wrapper_t;
diff --git a/gn/base/files/file_posix.cc b/gn/base/files/file_posix.cc
index ed9a5e2..49bd48f 100644
--- a/gn/base/files/file_posix.cc
+++ b/gn/base/files/file_posix.cc
@@ -25,7 +25,7 @@ static_assert(File::FROM_BEGIN == SEEK_SET && File::FROM_CURRENT == SEEK_CUR &&
 namespace {
 
 #if defined(OS_BSD) || defined(OS_MACOSX) || defined(OS_NACL) || \
-    defined(OS_ANDROID) && __ANDROID_API__ < 21
+    defined(OS_ANDROID) && __ANDROID_API__ < 21 || defined(OS_HAIKU)
 int CallFstat(int fd, stat_wrapper_t* sb) {
   return fstat(fd, sb);
 }
diff --git a/gn/base/files/file_util.h b/gn/base/files/file_util.h
index e22f40f..1a48cd9 100644
--- a/gn/base/files/file_util.h
+++ b/gn/base/files/file_util.h
@@ -361,7 +361,7 @@ bool VerifyPathControlledByAdmin(const base::FilePath& path);
 // the directory |path|, in the number of FilePath::CharType, or -1 on failure.
 int GetMaximumPathComponentLength(const base::FilePath& path);
 
-#if defined(OS_LINUX) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_AIX) || defined(OS_HAIKU)
 // Broad categories of file systems as returned by statfs() on Linux.
 enum FileSystemType {
   FILE_SYSTEM_UNKNOWN,   // statfs failed.
diff --git a/gn/base/files/file_util_posix.cc b/gn/base/files/file_util_posix.cc
index eb07e64..9058455 100644
--- a/gn/base/files/file_util_posix.cc
+++ b/gn/base/files/file_util_posix.cc
@@ -56,7 +56,7 @@ namespace base {
 namespace {
 
 #if defined(OS_BSD) || defined(OS_MACOSX) || defined(OS_NACL) || \
-    defined(OS_ANDROID) && __ANDROID_API__ < 21
+    defined(OS_ANDROID) && __ANDROID_API__ < 21 || defined(OS_HAIKU)
 int CallStat(const char* path, stat_wrapper_t* sb) {
   return stat(path, sb);
 }
diff --git a/gn/base/files/scoped_file.cc b/gn/base/files/scoped_file.cc
index 11afedd..31e4f60 100644
--- a/gn/base/files/scoped_file.cc
+++ b/gn/base/files/scoped_file.cc
@@ -31,7 +31,7 @@ void ScopedFDCloseTraits::Free(int fd) {
   int ret = IGNORE_EINTR(close(fd));
 
 #if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_FUCHSIA) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || defined(OS_HAIKU)
   // NB: Some file descriptors can return errors from close() e.g. network
   // filesystems such as NFS and Linux input devices. On Linux, macOS, and
   // Fuchsia's POSIX layer, errors from close other than EBADF do not indicate
diff --git a/gn/build/gen.py b/gn/build/gen.py
index 8c646be..9d430fa 100755
--- a/gn/build/gen.py
+++ b/gn/build/gen.py
@@ -43,10 +43,12 @@ class Platform(object):
       self._platform = 'freebsd'
     elif self._platform.startswith('openbsd'):
       self._platform = 'openbsd'
+    elif self._platform.startswith('haiku'):
+      self._platform = 'haiku'
 
   @staticmethod
   def known_platforms():
-    return ['linux', 'darwin', 'msvc', 'aix', 'fuchsia', 'freebsd', 'openbsd']
+    return ['linux', 'darwin', 'msvc', 'aix', 'fuchsia', 'freebsd', 'openbsd', 'haiku']
 
   def platform(self):
     return self._platform
@@ -69,8 +71,11 @@ class Platform(object):
   def is_aix(self):
     return self._platform == 'aix'
 
+  def is_haiku(self):
+    return self._platform == 'haiku'
+
   def is_posix(self):
-    return self._platform in ['linux', 'freebsd', 'darwin', 'aix', 'openbsd']
+    return self._platform in ['linux', 'freebsd', 'darwin', 'aix', 'openbsd', 'haiku']
 
 
 def main(argv):
@@ -189,6 +194,7 @@ def WriteGenericNinja(path, static_libraries, executables,
       'freebsd': 'build_linux.ninja.template',
       'aix': 'build_aix.ninja.template',
       'openbsd': 'build_openbsd.ninja.template',
+      'haiku': 'build_linux.ninja.template',
   }[platform.platform()])
 
   with open(template_filename) as f:
@@ -350,13 +356,19 @@ def WriteGNNinja(path, platform, host, options):
     cflags.extend([
         '-D_FILE_OFFSET_BITS=64',
         '-D__STDC_CONSTANT_MACROS', '-D__STDC_FORMAT_MACROS',
-        '-pthread',
         '-pipe',
         '-fno-exceptions',
         '-fno-rtti',
         '-fdiagnostics-color',
     ])
-    cflags_cc.extend(['-std=c++14', '-Wno-c++11-narrowing'])
+    if not platform.is_haiku():
+	    cflags.extend([
+	        '-pthread',
+    ])
+
+    cflags_cc.extend(['-std=c++14'])
+    if not platform.is_haiku():
+	    cflags_cc.extend(['-Wno-c++11-narrowing'])
 
     if platform.is_linux():
       ldflags.append('-Wl,--as-needed')
@@ -374,7 +386,7 @@ def WriteGNNinja(path, platform, host, options):
       cflags_cc.append('-maix64')
       ldflags.append('-maix64')
 
-    if platform.is_posix():
+    if platform.is_posix() and not platform.is_haiku():
       ldflags.append('-pthread')
 
     if options.use_lto:
diff --git a/gn/tools/gn/args.cc b/gn/tools/gn/args.cc
index d3491a4..a2f49b1 100644
--- a/gn/tools/gn/args.cc
+++ b/gn/tools/gn/args.cc
@@ -314,6 +314,8 @@ void Args::SetSystemVarsLocked(Scope* dest) const {
   os = "aix";
 #elif defined(OS_OPENBSD)
   os = "openbsd";
+#elif defined(OS_HAIKU)
+  os = "haiku";
 #else
 #error Unknown OS type.
 #endif
diff --git a/gn/tools/gn/exec_process.cc b/gn/tools/gn/exec_process.cc
index 6c13558..d359cb1 100644
--- a/gn/tools/gn/exec_process.cc
+++ b/gn/tools/gn/exec_process.cc
@@ -21,7 +21,12 @@
 #else
 #include <errno.h>
 #include <fcntl.h>
+#if !defined(OS_HAIKU)
 #include <sys/signal.h>
+#else
+#include <signal.h>
+#include <sys/select.h>
+#endif
 #include <sys/wait.h>
 #include <unistd.h>
 
diff --git a/gn/util/build_config.h b/gn/util/build_config.h
index addd7cf..74029bd 100644
--- a/gn/util/build_config.h
+++ b/gn/util/build_config.h
@@ -65,6 +65,8 @@
 #define OS_AIX 1
 #elif defined(__asmjs__)
 #define OS_ASMJS
+#elif defined(__HAIKU__)
+#define OS_HAIKU 1
 #else
 #error Please add support for your platform in build_config.h
 #endif
@@ -82,7 +84,7 @@
 #if defined(OS_AIX) || defined(OS_ANDROID) || defined(OS_ASMJS) ||    \
     defined(OS_FREEBSD) || defined(OS_LINUX) || defined(OS_MACOSX) || \
     defined(OS_NACL) || defined(OS_NETBSD) || defined(OS_OPENBSD) ||  \
-    defined(OS_QNX) || defined(OS_SOLARIS)
+    defined(OS_QNX) || defined(OS_SOLARIS) || defined(OS_HAIKU)
 #define OS_POSIX 1
 #endif
 
-- 
2.45.2


From 37363d55990a2119af6aea07f880a2da8a7e14fe Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Sun, 31 Dec 2023 23:28:53 +1000
Subject: Implement CloseSuperfluousFds


diff --git a/chromium/base/process/launch_posix.cc b/chromium/base/process/launch_posix.cc
index bb8718a..340a56f 100644
--- a/chromium/base/process/launch_posix.cc
+++ b/chromium/base/process/launch_posix.cc
@@ -63,6 +63,15 @@
 #include <sys/ucontext.h>
 #endif
 
+#if defined(OS_HAIKU)
+#include <OS.h>
+#include <fs_info.h>
+#include <private/system/vfs_defs.h>
+extern "C" {
+status_t _kern_get_next_fd_info(team_id team, uint32 *_cookie, struct fd_info *info, size_t infoSize);
+}
+#endif
+
 #if defined(OS_APPLE)
 #error "macOS should use launch_mac.cc"
 #endif
@@ -223,7 +232,25 @@ static const char kFDDir[] = "/proc/self/fd";
 void CloseSuperfluousFds(const base::InjectiveMultimap& saved_mapping) {
   // DANGER: no calls to malloc or locks are allowed from now on:
   // http://crbug.com/36678
-#if !defined(OS_HAIKU)
+#if defined(OS_HAIKU)
+  uint32 cookie = 0;
+  fd_info info;
+  while (_kern_get_next_fd_info(B_CURRENT_TEAM, &cookie, &info, sizeof(fd_info)) >= B_OK) {
+    const int fd = info.number;
+    if (fd == STDIN_FILENO || fd == STDOUT_FILENO || fd == STDERR_FILENO)
+      continue;
+    size_t i;
+    for (i = 0; i < saved_mapping.size(); i++) {
+      if (fd == saved_mapping[i].dest)
+        break;
+    }
+    if (i < saved_mapping.size())
+      continue;
+
+    int ret = IGNORE_EINTR(close(fd));
+    DPCHECK(ret == 0);
+  }
+#else
   // Get the maximum number of FDs possible.
   size_t max_fds = GetMaxFds();
 
diff --git a/chromium/base/process/process_metrics_posix.cc b/chromium/base/process/process_metrics_posix.cc
index d29e675..935d60c 100644
--- a/chromium/base/process/process_metrics_posix.cc
+++ b/chromium/base/process/process_metrics_posix.cc
@@ -54,7 +54,7 @@ static const rlim_t kSystemDefaultMaxFds = 1024;
 #elif defined(OS_AIX)
 static const rlim_t kSystemDefaultMaxFds = 8192;
 #elif defined(OS_HAIKU)
-static const rlim_t kSystemDefaultMaxFds = 4096;
+static const rlim_t kSystemDefaultMaxFds = 512;
 #endif
 
 size_t GetMaxFds() {
-- 
2.45.2


From 2aa4f0f06e45f6cc6555b5255ec5950db04e0aee Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Sun, 7 Jan 2024 12:12:49 +1000
Subject: Fix fstat


diff --git a/chromium/base/files/file_posix.cc b/chromium/base/files/file_posix.cc
index a521ef0..7ab80df 100644
--- a/chromium/base/files/file_posix.cc
+++ b/chromium/base/files/file_posix.cc
@@ -125,7 +125,7 @@ void File::Info::FromStat(const stat_wrapper_t& stat_info) {
   // creation time. However, other than on Mac & iOS where the actual file
   // creation time is included as st_birthtime, the rest of POSIX platforms have
   // no portable way to get the creation time.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
   time_t last_modified_sec = stat_info.st_mtim.tv_sec;
   int64_t last_modified_nsec = stat_info.st_mtim.tv_nsec;
   time_t last_accessed_sec = stat_info.st_atim.tv_sec;
-- 
2.45.2


From f781d8bd6a3c6e17bcd829391e75672048addad0 Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Sun, 7 Jan 2024 12:13:39 +1000
Subject: Check FD acess mode


diff --git a/chromium/base/memory/platform_shared_memory_region_posix.cc b/chromium/base/memory/platform_shared_memory_region_posix.cc
index cabf383..63feaad 100644
--- a/chromium/base/memory/platform_shared_memory_region_posix.cc
+++ b/chromium/base/memory/platform_shared_memory_region_posix.cc
@@ -308,7 +308,7 @@ bool PlatformSharedMemoryRegion::CheckPlatformHandlePermissionsCorrespondToMode(
     PlatformHandle handle,
     Mode mode,
     size_t size) {
-#if !defined(OS_NACL) && !defined(OS_HAIKU)
+#if !defined(OS_NACL)
   if (!CheckFDAccessMode(handle.fd,
                          mode == Mode::kReadOnly ? O_RDONLY : O_RDWR)) {
     return false;
-- 
2.45.2


From e904b0f406035ecf8fb866361b454538459223a8 Mon Sep 17 00:00:00 2001
From: Ken Moffat <ken@linuxfromscratch.org>
Date: Sat, 16 Dec 2023 18:57:13 +1000
Subject: patches from Arch via gentoo to use python3


diff --git a/chromium/BUILD.gn b/chromium/BUILD.gn
index 5f6954b..e69038f 100644
--- a/chromium/BUILD.gn
+++ b/chromium/BUILD.gn
@@ -239,7 +239,6 @@ group("gn_all") {
       "//media/capture:capture_unittests",
       "//media/cast:cast_unittests",
       "//third_party/angle/src/tests:angle_white_box_tests",
-      "//third_party/catapult/telemetry:bitmaptools($host_toolchain)",
     ]
   } else if (is_ios && !use_qt) {
     deps += [
@@ -354,7 +353,6 @@ group("gn_all") {
       "//net/android:net_junit_tests",
       "//services:services_junit_tests",
       "//testing/android/junit:junit_unit_tests",
-      "//third_party/catapult/devil",
       "//third_party/smhasher:murmurhash3",
       "//tools/android:android_tools",
       "//tools/android:memconsumer",
@@ -948,7 +946,6 @@ if (is_chromeos) {
       "//third_party/dawn/src/tests:dawn_unittests",
 
       # Blocked on https://github.com/catapult-project/catapult/issues/2297
-      #"//third_party/catapult/telemetry:bitmaptools",
       "//tools/perf/clear_system_cache",
       "//ui/ozone/gl:ozone_gl_unittests",
     ]
@@ -1026,7 +1023,6 @@ if (!is_ios && !use_qt) {
       data_deps = [
         "//chrome:chrome",
         "//chrome/test/chromedriver",
-        "//third_party/catapult/third_party/typ",
       ]
       if (is_win) {
         data_deps += [ "//build/win:copy_cdb_to_output" ]
@@ -1073,7 +1069,6 @@ if (!is_ios && !use_qt) {
       "//third_party/blink/public:blink_devtools_inspector_resources",
       "//third_party/blink/public/mojom:mojom_platform_js_data_deps",
       "//third_party/blink/renderer/core/html:js_files_for_form_controls_web_tests",
-      "//third_party/catapult/third_party/typ",
       "//third_party/mesa_headers",
       "//tools/imagediff",
     ]
@@ -1141,7 +1136,6 @@ if (!is_ios && !use_qt) {
 
     if (is_android) {
       data += [
-        "//third_party/catapult/",
         "//build/android/",
       ]
     }
@@ -1248,11 +1242,6 @@ if (!is_ios && !use_qt) {
       "//third_party/blink/web_tests/StaleTestExpectations",
       "//third_party/blink/web_tests/TestExpectations",
       "//third_party/blink/web_tests/VirtualTestSuites",
-      "//third_party/catapult/common/py_utils/",
-      "//third_party/catapult/devil/",
-      "//third_party/catapult/dependency_manager/",
-      "//third_party/catapult/third_party/zipfile/",
-      "//third_party/catapult/third_party/typ/",
       "//third_party/depot_tools/pylint",
       "//third_party/depot_tools/pylint-1.5",
       "//third_party/depot_tools/pylint_main.py",
diff --git a/chromium/build/print_python_deps.py b/chromium/build/print_python_deps.py
index 2a01185..22674c4 100755
--- a/chromium/build/print_python_deps.py
+++ b/chromium/build/print_python_deps.py
@@ -80,7 +80,7 @@ def _GetTargetPythonVersion(module):
   if shebang.startswith('#!'):
     # Examples:
     # '#!/usr/bin/python'
-    # '#!/usr/bin/python2.7'
+    # '#!/usr/bin/python'
     # '#!/usr/bin/python3'
     # '#!/usr/bin/env python3'
     # '#!/usr/bin/env vpython'
diff --git a/chromium/chrome/chrome_paks.gni b/chromium/chrome/chrome_paks.gni
index 9323a77..0362b65 100644
--- a/chromium/chrome/chrome_paks.gni
+++ b/chromium/chrome/chrome_paks.gni
@@ -94,7 +94,6 @@ template("chrome_extra_paks") {
       "$root_gen_dir/chrome/common_resources.pak",
       "$root_gen_dir/components/autofill/core/browser/autofill_address_rewriter_resources.pak",
       "$root_gen_dir/components/components_resources.pak",
-      "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
       "$root_gen_dir/content/content_resources.pak",
       "$root_gen_dir/mojo/public/js/mojo_bindings_resources.pak",
       "$root_gen_dir/net/net_resources.pak",
@@ -110,7 +109,6 @@ template("chrome_extra_paks") {
       "//components/autofill/core/browser:autofill_address_rewriter_resources",
       "//components/resources",
       "//content:content_resources",
-      "//content/browser/tracing:resources",
       "//mojo/public/js:resources",
       "//net:net_resources",
       "//skia:skia_resources",
diff --git a/chromium/chrome/test/BUILD.gn b/chromium/chrome/test/BUILD.gn
index 3c53323..38be116 100644
--- a/chromium/chrome/test/BUILD.gn
+++ b/chromium/chrome/test/BUILD.gn
@@ -7103,8 +7103,6 @@ if (!is_fuchsia && !is_android) {
       "//chrome/test/data/password/captured_sites/",
       "//chrome/test/data/web_page_replay_go_helper_scripts/automation_helper.js",
       "//components/test/data/autofill/web_page_replay_support_files/",
-      "//third_party/catapult/telemetry/telemetry/bin/",
-      "//third_party/catapult/web_page_replay_go/deterministic.js",
     ]
 
     if (is_linux || is_chromeos || is_win) {
@@ -7141,7 +7139,6 @@ if (!is_fuchsia && !is_android) {
 
       # TODO(uwyiming@chromium.org) create a gn target for Web Page Replay Go (WPR Go) and only WPR Go.
       # So that test targets requiring WPR Go does not pull down the whole telemetry tool chain.
-      "//third_party/catapult:telemetry_chrome_test_support",
       "//third_party/hunspell",
       "//third_party/icu",
       "//third_party/libpng",
@@ -7171,7 +7168,6 @@ if (!is_fuchsia && !is_android) {
     deps = [ "//tools/perf/chrome_telemetry_build:telemetry_chrome_test" ]
 
     data = [
-      "//third_party/catapult/telemetry/telemetry/internal/bin/",
       "//tools/perf/run_telemetry_tests",
 
       # For isolate contract.
@@ -7189,7 +7185,6 @@ if (!is_fuchsia && !is_android) {
   group("telemetry_gpu_unittests") {
     testonly = true
     deps = [
-      "//third_party/catapult:telemetry_chrome_test_support",
       "//tools/metrics:metrics_python_tests",
     ]
     data = [
@@ -7313,7 +7308,6 @@ if (is_mac || is_win || is_android) {
       "//testing/scripts",
       "//testing/test_env.py",
       "//testing/xvfb.py",
-      "//third_party/catapult",
       "//tools",
     ]
   }
diff --git a/chromium/components/bookmarks/browser/base_bookmark_model_observer.cc b/chromium/components/bookmarks/browser/base_bookmark_model_observer.cc
index 657a3c9..ad641a0 100644
--- a/chromium/components/bookmarks/browser/base_bookmark_model_observer.cc
+++ b/chromium/components/bookmarks/browser/base_bookmark_model_observer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <cstddef>
+
 #include "components/bookmarks/browser/base_bookmark_model_observer.h"
 
 namespace bookmarks {
diff --git a/chromium/components/bookmarks/browser/bookmark_expanded_state_tracker.cc b/chromium/components/bookmarks/browser/bookmark_expanded_state_tracker.cc
index 4ad2afa..5c4596e 100644
--- a/chromium/components/bookmarks/browser/bookmark_expanded_state_tracker.cc
+++ b/chromium/components/bookmarks/browser/bookmark_expanded_state_tracker.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <cstddef>
 #include "components/bookmarks/browser/bookmark_expanded_state_tracker.h"
 
 #include <stdint.h>
diff --git a/chromium/content/browser/BUILD.gn b/chromium/content/browser/BUILD.gn
index 43533cd..4878fa3 100644
--- a/chromium/content/browser/BUILD.gn
+++ b/chromium/content/browser/BUILD.gn
@@ -2170,7 +2170,6 @@ jumbo_static_library("browser") {
   if (!is_android) {
     deps += [
       "//components/vector_icons",
-      "//content/browser/tracing:resources",
     ]
   }
 
diff --git a/chromium/content/browser/tracing/BUILD.gn b/chromium/content/browser/tracing/BUILD.gn
deleted file mode 100644
index eac0599..0000000
--- a/chromium/content/browser/tracing/BUILD.gn
+++ /dev/null
@@ -1,51 +0,0 @@
-# Copyright 2014 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-import("//tools/grit/grit_rule.gni")
-
-# generate_about_tracing puts its files in this directory
-tracing_gen_dir = "$root_gen_dir/content/browser/tracing"
-
-# The script just writes filename with no dirs to the .grd, so we always need
-# this file to be in the same directory as the inputs.
-tracing_grd = "$tracing_gen_dir/tracing_resources.grd"
-
-action("generate_tracing_grd") {
-  visibility = [ ":*" ]  # Depend on ":resources" to get this.
-  script = "generate_trace_viewer_grd.py"
-
-  input_pages = [
-    "$tracing_gen_dir/about_tracing.html",
-    "$tracing_gen_dir/about_tracing.js",
-  ]
-  inputs = input_pages
-  outputs = [ tracing_grd ]
-
-  args = rebase_path(input_pages, target_gen_dir) + [
-           "--output",
-           rebase_path(tracing_grd, root_build_dir),
-         ]
-
-  deps = [ "//third_party/catapult/tracing:generate_about_tracing" ]
-}
-
-grit("resources") {
-  source = tracing_grd
-
-  # Required because the .grd is generated.
-  enable_input_discovery_for_gn_analyze = false
-
-  outputs = [
-    "grit/tracing_resources.h",
-    "tracing_resources.pak",
-  ]
-
-  # resource_ids has an entry for our .grd file that looks like:
-  # "<(SHARED_INTERMEDIATE_DIR)/content/browser/tracing/tracing_resources.grd"
-  # and what we pass here should make that resolve to our .grd file.
-  defines =
-      [ "SHARED_INTERMEDIATE_DIR=" + rebase_path(root_gen_dir, root_build_dir) ]
-
-  deps = [ ":generate_tracing_grd" ]
-}
diff --git a/chromium/content/browser/tracing/tracing_ui.cc b/chromium/content/browser/tracing/tracing_ui.cc
index 2bffb5e..8965922 100644
--- a/chromium/content/browser/tracing/tracing_ui.cc
+++ b/chromium/content/browser/tracing/tracing_ui.cc
@@ -27,7 +27,6 @@
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
 #include "base/values.h"
-#include "content/browser/tracing/grit/tracing_resources.h"
 #include "content/browser/tracing/tracing_controller_impl.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
@@ -242,8 +241,6 @@ TracingUI::TracingUI(WebUI* web_ui)
   WebUIDataSource* source = WebUIDataSource::Create(kChromeUITracingHost);
   source->DisableTrustedTypesCSP();
   source->UseStringsJs();
-  source->SetDefaultResource(IDR_TRACING_HTML);
-  source->AddResourcePath("tracing.js", IDR_TRACING_JS);
   source->SetRequestFilter(base::BindRepeating(OnShouldHandleRequest),
                            base::BindRepeating(OnTracingRequest));
   WebUIDataSource::Add(browser_context, source);
diff --git a/chromium/content/shell/BUILD.gn b/chromium/content/shell/BUILD.gn
index f7a0c95..e7e8932 100644
--- a/chromium/content/shell/BUILD.gn
+++ b/chromium/content/shell/BUILD.gn
@@ -396,7 +396,6 @@ repack("pak") {
   sources = [
     "$root_gen_dir/content/app/resources/content_resources_100_percent.pak",
     "$root_gen_dir/content/browser/resources/media/media_internals_resources.pak",
-    "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
     "$root_gen_dir/content/browser/webrtc/resources/webrtc_internals_resources.pak",
     "$root_gen_dir/content/content_resources.pak",
     "$root_gen_dir/content/dev_ui_content_resources.pak",
@@ -419,7 +418,6 @@ repack("pak") {
     "//content:dev_ui_content_resources",
     "//content/app/resources",
     "//content/browser/resources/media:media_internals_resources",
-    "//content/browser/tracing:resources",
     "//content/browser/webrtc/resources",
     "//mojo/public/js:resources",
     "//net:net_resources",
diff --git a/chromium/fuchsia/engine/BUILD.gn b/chromium/fuchsia/engine/BUILD.gn
index a502b7f..39df2a7 100644
--- a/chromium/fuchsia/engine/BUILD.gn
+++ b/chromium/fuchsia/engine/BUILD.gn
@@ -43,7 +43,6 @@ repack("web_engine_pak") {
     "$root_gen_dir/components/components_resources.pak",
     "$root_gen_dir/components/strings/components_strings_en-US.pak",
     "$root_gen_dir/content/app/resources/content_resources_100_percent.pak",
-    "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
     "$root_gen_dir/content/content_resources.pak",
     "$root_gen_dir/content/dev_ui_content_resources.pak",
     "$root_gen_dir/mojo/public/js/mojo_bindings_resources.pak",
@@ -66,7 +65,6 @@ repack("web_engine_pak") {
     "//content:content_resources",
     "//content:dev_ui_content_resources",
     "//content/app/resources",
-    "//content/browser/tracing:resources",
     "//gpu/command_buffer/service",
     "//mojo/public/js:resources",
     "//net:net_resources",
diff --git a/chromium/headless/BUILD.gn b/chromium/headless/BUILD.gn
index fb3cfde..fb54a15 100644
--- a/chromium/headless/BUILD.gn
+++ b/chromium/headless/BUILD.gn
@@ -37,7 +37,6 @@ repack("pak") {
     "$root_gen_dir/components/components_resources.pak",
     "$root_gen_dir/components/strings/components_strings_en-US.pak",
     "$root_gen_dir/content/app/resources/content_resources_100_percent.pak",
-    "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
     "$root_gen_dir/content/content_resources.pak",
     "$root_gen_dir/content/dev_ui_content_resources.pak",
     "$root_gen_dir/headless/headless_lib_resources.pak",
@@ -65,7 +64,6 @@ repack("pak") {
     "//content:content_resources",
     "//content:dev_ui_content_resources",
     "//content/app/resources",
-    "//content/browser/tracing:resources",
     "//mojo/public/js:resources",
     "//net:net_resources",
     "//third_party/blink/public:resources",
diff --git a/chromium/mojo/public/tools/BUILD.gn b/chromium/mojo/public/tools/BUILD.gn
index 4c68350..1cc0125 100644
--- a/chromium/mojo/public/tools/BUILD.gn
+++ b/chromium/mojo/public/tools/BUILD.gn
@@ -14,5 +14,4 @@ group("mojo_python_unittests") {
     "//testing/xvfb.py",
   ]
   deps = [ "//mojo/public/tools/mojom/mojom:tests" ]
-  data_deps = [ "//third_party/catapult/third_party/typ/" ]
 }
diff --git a/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc b/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
index 5e650d9..6ed415a 100644
--- a/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
+++ b/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
@@ -158,7 +158,15 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return Allow();
 #endif
 
-  if (SyscallSets::IsClockApi(sysno)) {
+  if (sysno == __NR_clock_gettime || sysno == __NR_clock_nanosleep
+#if defined(__NR_clock_gettime64)
+                                  || sysno == __NR_clock_gettime64
+#endif
+#if defined(__NR_clock_nanosleep_time64)
+                                  || sysno == __NR_clock_nanosleep_time64
+#endif
+  ) {
+
     return RestrictClockID();
   }
 
diff --git a/chromium/testing/BUILD.gn b/chromium/testing/BUILD.gn
index 56ebf8d..7d51bc0 100644
--- a/chromium/testing/BUILD.gn
+++ b/chromium/testing/BUILD.gn
@@ -27,7 +27,6 @@ group("run_perf_test") {
 
   data_deps = [
     ":test_scripts_shared",
-    "//third_party/catapult/tracing:convert_chart_json",
   ]
 
   if (is_android) {
diff --git a/chromium/third_party/angle/src/libANGLE/HandleAllocator.cpp b/chromium/third_party/angle/src/libANGLE/HandleAllocator.cpp
index 013f1df..3ce63c1 100644
--- a/chromium/third_party/angle/src/libANGLE/HandleAllocator.cpp
+++ b/chromium/third_party/angle/src/libANGLE/HandleAllocator.cpp
@@ -9,6 +9,7 @@
 
 #include "libANGLE/HandleAllocator.h"
 
+#include <limits>
 #include <algorithm>
 #include <functional>
 
diff --git a/chromium/third_party/libvpx/generate_gni.sh b/chromium/third_party/libvpx/generate_gni.sh
index 626d6a2..b1008cf 100755
--- a/chromium/third_party/libvpx/generate_gni.sh
+++ b/chromium/third_party/libvpx/generate_gni.sh
@@ -519,8 +519,3 @@ rm -rf $TEMP_DIR
 
 gn format --in-place $BASE_DIR/BUILD.gn
 gn format --in-place $BASE_DIR/libvpx_srcs.gni
-
-cd $BASE_DIR/$LIBVPX_SRC_DIR
-update_readme
-
-cd $BASE_DIR
diff --git a/chromium/third_party/libxml/src/encoding.c b/chromium/third_party/libxml/src/encoding.c
index 101eba9..085705b 100644
--- a/chromium/third_party/libxml/src/encoding.c
+++ b/chromium/third_party/libxml/src/encoding.c
@@ -40,6 +40,7 @@
 #include <libxml/globals.h>
 #include <libxml/xmlerror.h>
 
+#include <stdbool.h>
 #include "private/buf.h"
 #include "private/enc.h"
 #include "private/error.h"
@@ -1999,7 +2000,7 @@ xmlUconvWrapper(uconv_t *cd, int toUnicode, unsigned char *out, int *outlen,
     *inlen = ucv_in - (const char*) in;
     *outlen = ucv_out - (char *) out;
     if (U_SUCCESS(err)) {
-        /* reset pivot buf if this is the last call for input (flush==TRUE) */
+        /* reset pivot buf if this is the last call for input (flush==true) */
         if (flush)
             cd->pivot_source = cd->pivot_target = cd->pivot_buf;
         return 0;
diff --git a/chromium/third_party/nearby/src/cpp/core_v2/internal/base_pcp_handler_test.cc.orig b/chromium/third_party/nearby/src/cpp/core_v2/internal/base_pcp_handler_test.cc.orig
deleted file mode 100644
index c900941..0000000
--- a/chromium/third_party/nearby/src/cpp/core_v2/internal/base_pcp_handler_test.cc.orig
+++ /dev/null
@@ -1,538 +0,0 @@
-#include "core_v2/internal/base_pcp_handler.h"
-
-#include <atomic>
-#include <memory>
-
-#include "core_v2/internal/base_endpoint_channel.h"
-#include "core_v2/internal/client_proxy.h"
-#include "core_v2/internal/encryption_runner.h"
-#include "core_v2/internal/offline_frames.h"
-#include "core_v2/listeners.h"
-#include "core_v2/options.h"
-#include "core_v2/params.h"
-#include "proto/connections/offline_wire_formats.pb.h"
-#include "platform_v2/base/byte_array.h"
-#include "platform_v2/public/count_down_latch.h"
-#include "platform_v2/public/pipe.h"
-#include "gmock/gmock.h"
-#include "gtest/gtest.h"
-#include "absl/time/time.h"
-
-namespace location {
-namespace nearby {
-namespace connections {
-namespace {
-
-using ::location::nearby::proto::connections::Medium;
-using ::testing::_;
-using ::testing::AtLeast;
-using ::testing::Invoke;
-using ::testing::MockFunction;
-using ::testing::Return;
-using ::testing::StrictMock;
-
-constexpr BooleanMediumSelector kTestCases[] = {
-    BooleanMediumSelector{},
-    BooleanMediumSelector{
-        .bluetooth = true,
-    },
-    BooleanMediumSelector{
-        .wifi_lan = true,
-    },
-    BooleanMediumSelector{
-        .bluetooth = true,
-        .wifi_lan = true,
-    },
-};
-
-class MockEndpointChannel : public BaseEndpointChannel {
- public:
-  explicit MockEndpointChannel(Pipe* reader, Pipe* writer)
-      : BaseEndpointChannel("channel", &reader->GetInputStream(),
-                            &writer->GetOutputStream()) {}
-
-  ExceptionOr<ByteArray> DoRead() { return BaseEndpointChannel::Read(); }
-  Exception DoWrite(const ByteArray& data) {
-    return BaseEndpointChannel::Write(data);
-  }
-  absl::Time DoGetLastReadTimestamp() {
-    return BaseEndpointChannel::GetLastReadTimestamp();
-  }
-
-  MOCK_METHOD(ExceptionOr<ByteArray>, Read, (), (override));
-  MOCK_METHOD(Exception, Write, (const ByteArray& data), (override));
-  MOCK_METHOD(void, CloseImpl, (), (override));
-  MOCK_METHOD(proto::connections::Medium, GetMedium, (), (const override));
-  MOCK_METHOD(std::string, GetType, (), (const override));
-  MOCK_METHOD(std::string, GetName, (), (const override));
-  MOCK_METHOD(bool, IsPaused, (), (const override));
-  MOCK_METHOD(void, Pause, (), (override));
-  MOCK_METHOD(void, Resume, (), (override));
-  MOCK_METHOD(absl::Time, GetLastReadTimestamp, (), (const override));
-};
-
-class MockPcpHandler : public BasePcpHandler {
- public:
-  using DiscoveredEndpoint = BasePcpHandler::DiscoveredEndpoint;
-
-  MockPcpHandler(EndpointManager* em, EndpointChannelManager* ecm)
-      : BasePcpHandler(em, ecm, Pcp::kP2pCluster) {}
-
-  // Expose protected inner types of a base type for mocking.
-  using BasePcpHandler::ConnectImplResult;
-  using BasePcpHandler::DiscoveredEndpoint;
-  using BasePcpHandler::StartOperationResult;
-
-  MOCK_METHOD(Strategy, GetStrategy, (), (const override));
-  MOCK_METHOD(Pcp, GetPcp, (), (const override));
-
-  MOCK_METHOD(bool, HasOutgoingConnections, (ClientProxy * client),
-              (const, override));
-  MOCK_METHOD(bool, HasIncomingConnections, (ClientProxy * client),
-              (const, override));
-
-  MOCK_METHOD(bool, CanSendOutgoingConnection, (ClientProxy * client),
-              (const, override));
-  MOCK_METHOD(bool, CanReceiveIncomingConnection, (ClientProxy * client),
-              (const, override));
-
-  MOCK_METHOD(StartOperationResult, StartAdvertisingImpl,
-              (ClientProxy * client, const string& service_id,
-               const string& local_endpoint_id,
-               const string& local_endpoint_name,
-               const ConnectionOptions& options),
-              (override));
-  MOCK_METHOD(Status, StopAdvertisingImpl, (ClientProxy * client), (override));
-  MOCK_METHOD(StartOperationResult, StartDiscoveryImpl,
-              (ClientProxy * client, const string& service_id,
-               const ConnectionOptions& options),
-              (override));
-  MOCK_METHOD(Status, StopDiscoveryImpl, (ClientProxy * client), (override));
-  MOCK_METHOD(ConnectImplResult, ConnectImpl,
-              (ClientProxy * client, DiscoveredEndpoint* endpoint), (override));
-  MOCK_METHOD(proto::connections::Medium, GetDefaultUpgradeMedium, (),
-              (override));
-
-  std::vector<proto::connections::Medium> GetConnectionMediumsByPriority()
-      override {
-    return GetDiscoveryMediums();
-  }
-
-  // Mock adapters for protected non-virtual methods of a base class.
-  void OnEndpointFound(ClientProxy* client,
-                       std::shared_ptr<DiscoveredEndpoint> endpoint) {
-    BasePcpHandler::OnEndpointFound(client, std::move(endpoint));
-  }
-  void OnEndpointLost(ClientProxy* client, const DiscoveredEndpoint& endpoint) {
-    BasePcpHandler::OnEndpointLost(client, endpoint);
-  }
-
-  std::vector<proto::connections::Medium> GetDiscoveryMediums() {
-    std::vector<proto::connections::Medium> mediums;
-    auto allowed =
-        BasePcpHandler::GetDiscoveryOptions().CompatibleOptions().allowed;
-    // Mediums are sorted in order of decreasing preference.
-    if (allowed.wifi_lan)
-      mediums.push_back(proto::connections::Medium::WIFI_LAN);
-    if (allowed.web_rtc) mediums.push_back(proto::connections::Medium::WEB_RTC);
-    if (allowed.bluetooth)
-      mediums.push_back(proto::connections::Medium::BLUETOOTH);
-    return mediums;
-  }
-
-  std::vector<BasePcpHandler::DiscoveredEndpoint*> GetDiscoveredEndpoints(
-      const std::string& endpoint_id) {
-    return BasePcpHandler::GetDiscoveredEndpoints(endpoint_id);
-  }
-};
-
-class MockContext {
- public:
-  explicit MockContext(std::atomic_int* destroyed = nullptr) {
-    destroyed_ = destroyed;
-  }
-  MockContext(MockContext&&) = default;
-  MockContext& operator=(MockContext&&) = default;
-
-  ~MockContext() {
-    if (destroyed_) (*destroyed_)++;
-  }
-
- private:
-  Swapper<std::atomic_int> destroyed_{nullptr};
-};
-
-struct MockDiscoveredEndpoint : public MockPcpHandler::DiscoveredEndpoint {
-  MockDiscoveredEndpoint(DiscoveredEndpoint endpoint, MockContext context)
-      : DiscoveredEndpoint(std::move(endpoint)), context(std::move(context)) {}
-
-  MockContext context;
-};
-
-class BasePcpHandlerTest
-    : public ::testing::TestWithParam<BooleanMediumSelector> {
- protected:
-  struct MockConnectionListener {
-    StrictMock<MockFunction<void(const std::string& endpoint_id,
-                                 const ConnectionResponseInfo& info)>>
-        initiated_cb;
-    StrictMock<MockFunction<void(const std::string& endpoint_id)>> accepted_cb;
-    StrictMock<MockFunction<void(const std::string& endpoint_id,
-                                 const Status& status)>>
-        rejected_cb;
-    StrictMock<MockFunction<void(const std::string& endpoint_id)>>
-        disconnected_cb;
-    StrictMock<MockFunction<void(const std::string& endpoint_id,
-                                 std::int32_t quality)>>
-        bandwidth_changed_cb;
-  };
-  struct MockDiscoveryListener {
-    StrictMock<MockFunction<void(const std::string& endpoint_id,
-                                 const std::string& endpoint_name,
-                                 const std::string& service_id)>>
-        endpoint_found_cb;
-    StrictMock<MockFunction<void(const std::string& endpoint_id)>>
-        endpoint_lost_cb;
-    StrictMock<
-        MockFunction<void(const std::string& endpoint_id, DistanceInfo info)>>
-        endpoint_distance_changed_cb;
-  };
-
-  void StartAdvertising(ClientProxy* client, MockPcpHandler* pcp_handler,
-                        BooleanMediumSelector allowed = GetParam()) {
-    std::string service_id{"service"};
-    ConnectionOptions options{
-        .strategy = Strategy::kP2pCluster,
-        .allowed = allowed,
-        .auto_upgrade_bandwidth = true,
-        .enforce_topology_constraints = true,
-    };
-    ConnectionRequestInfo info{
-        .name = "remote_endpoint_name",
-        .listener = connection_listener_,
-    };
-    EXPECT_CALL(*pcp_handler,
-                StartAdvertisingImpl(client, service_id, _, info.name, _))
-        .WillOnce(Return(MockPcpHandler::StartOperationResult{
-            .status = {Status::kSuccess},
-            .mediums = {Medium::BLE},
-        }));
-    EXPECT_EQ(pcp_handler->StartAdvertising(client, service_id, options, info),
-              Status{Status::kSuccess});
-    EXPECT_TRUE(client->IsAdvertising());
-  }
-
-  void StartDiscovery(ClientProxy* client, MockPcpHandler* pcp_handler,
-                      BooleanMediumSelector allowed = GetParam()) {
-    std::string service_id{"service"};
-    ConnectionOptions options{
-        .strategy = Strategy::kP2pCluster,
-        .allowed = allowed,
-        .auto_upgrade_bandwidth = true,
-        .enforce_topology_constraints = true,
-    };
-    EXPECT_CALL(*pcp_handler, StartDiscoveryImpl(client, service_id, _))
-        .WillOnce(Return(MockPcpHandler::StartOperationResult{
-            .status = {Status::kSuccess},
-            .mediums = {Medium::BLE},
-        }));
-    EXPECT_EQ(pcp_handler->StartDiscovery(client, service_id, options,
-                                          discovery_listener_),
-              Status{Status::kSuccess});
-    EXPECT_TRUE(client->IsDiscovering());
-  }
-
-  std::pair<std::unique_ptr<MockEndpointChannel>,
-            std::unique_ptr<MockEndpointChannel>>
-  SetupConnection(Pipe& pipe_a, Pipe& pipe_b) {  // NOLINT
-    auto channel_a = std::make_unique<MockEndpointChannel>(&pipe_b, &pipe_a);
-    auto channel_b = std::make_unique<MockEndpointChannel>(&pipe_a, &pipe_b);
-    // On initiator (A) side, we drop the first write, since this is a
-    // connection establishment packet, and we don't have the peer entity, just
-    // the peer channel. The rest of the exchange must happen for the benefit of
-    // DH key exchange.
-    EXPECT_CALL(*channel_a, Read())
-        .WillRepeatedly(Invoke(
-            [channel = channel_a.get()]() { return channel->DoRead(); }));
-    EXPECT_CALL(*channel_a, Write(_))
-        .WillOnce(Return(Exception{Exception::kSuccess}))
-        .WillRepeatedly(
-            Invoke([channel = channel_a.get()](const ByteArray& data) {
-              return channel->DoWrite(data);
-            }));
-    EXPECT_CALL(*channel_a, GetMedium).WillRepeatedly(Return(Medium::BLE));
-    EXPECT_CALL(*channel_a, GetLastReadTimestamp)
-        .WillRepeatedly(Return(absl::Now()));
-    EXPECT_CALL(*channel_a, IsPaused).WillRepeatedly(Return(false));
-    EXPECT_CALL(*channel_b, Read())
-        .WillRepeatedly(Invoke(
-            [channel = channel_b.get()]() { return channel->DoRead(); }));
-    EXPECT_CALL(*channel_b, Write(_))
-        .WillRepeatedly(
-            Invoke([channel = channel_b.get()](const ByteArray& data) {
-              return channel->DoWrite(data);
-            }));
-    EXPECT_CALL(*channel_b, GetMedium).WillRepeatedly(Return(Medium::BLE));
-    EXPECT_CALL(*channel_b, GetLastReadTimestamp)
-        .WillRepeatedly(Return(absl::Now()));
-    EXPECT_CALL(*channel_b, IsPaused).WillRepeatedly(Return(false));
-    return std::make_pair(std::move(channel_a), std::move(channel_b));
-  }
-
-  void RequestConnection(const std::string& endpoint_id,
-                         std::unique_ptr<MockEndpointChannel> channel_a,
-                         MockEndpointChannel* channel_b, ClientProxy* client,
-                         MockPcpHandler* pcp_handler,
-                         std::atomic_int* flag = nullptr) {
-    ConnectionRequestInfo info{
-        .name = "ABCD",
-        .listener = connection_listener_,
-    };
-    EXPECT_CALL(mock_discovery_listener_.endpoint_found_cb, Call);
-    EXPECT_CALL(*pcp_handler, CanSendOutgoingConnection)
-        .WillRepeatedly(Return(true));
-    EXPECT_CALL(*pcp_handler, GetStrategy)
-        .WillRepeatedly(Return(Strategy::kP2pCluster));
-    EXPECT_CALL(mock_connection_listener_.initiated_cb, Call).Times(1);
-    // Simulate successful discovery.
-    auto encryption_runner = std::make_unique<EncryptionRunner>();
-    auto allowed_mediums = pcp_handler->GetDiscoveryMediums();
-
-    EXPECT_CALL(*pcp_handler, ConnectImpl)
-        .WillOnce(Invoke([&channel_a, medium = allowed_mediums[0]](
-                             ClientProxy* client,
-                             MockPcpHandler::DiscoveredEndpoint* endpoint) {
-          return MockPcpHandler::ConnectImplResult{
-              .medium = medium,
-              .status = {Status::kSuccess},
-              .endpoint_channel = std::move(channel_a),
-          };
-        }));
-
-    for (const auto& medium : allowed_mediums) {
-      pcp_handler->OnEndpointFound(
-          client,
-          std::make_shared<MockDiscoveredEndpoint>(MockDiscoveredEndpoint{
-              {
-                  endpoint_id,
-                  info.name,
-                  "service",
-                  medium,
-              },
-              MockContext{flag},
-          }));
-    }
-    auto other_client = std::make_unique<ClientProxy>();
-
-    // Run peer crypto in advance, if channel_b is provided.
-    // Otherwise stay in not-encrypted state.
-    if (channel_b != nullptr) {
-      encryption_runner->StartServer(other_client.get(), endpoint_id, channel_b,
-                                     {});
-    }
-    EXPECT_EQ(pcp_handler->RequestConnection(client, endpoint_id, info),
-              Status{Status::kSuccess});
-    NEARBY_LOG(INFO, "Stopping Encryption Runner");
-  }
-
-  Pipe pipe_a_;
-  Pipe pipe_b_;
-  MockConnectionListener mock_connection_listener_;
-  MockDiscoveryListener mock_discovery_listener_;
-  ConnectionListener connection_listener_{
-      .initiated_cb = mock_connection_listener_.initiated_cb.AsStdFunction(),
-      .accepted_cb = mock_connection_listener_.accepted_cb.AsStdFunction(),
-      .rejected_cb = mock_connection_listener_.rejected_cb.AsStdFunction(),
-      .disconnected_cb =
-          mock_connection_listener_.disconnected_cb.AsStdFunction(),
-      .bandwidth_changed_cb =
-          mock_connection_listener_.bandwidth_changed_cb.AsStdFunction(),
-  };
-  DiscoveryListener discovery_listener_{
-      .endpoint_found_cb =
-          mock_discovery_listener_.endpoint_found_cb.AsStdFunction(),
-      .endpoint_lost_cb =
-          mock_discovery_listener_.endpoint_lost_cb.AsStdFunction(),
-      .endpoint_distance_changed_cb =
-          mock_discovery_listener_.endpoint_distance_changed_cb.AsStdFunction(),
-  };
-};
-
-TEST_P(BasePcpHandlerTest, ConstructorDestructorWorks) {
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  SUCCEED();
-}
-
-TEST_P(BasePcpHandlerTest, StartAdvertisingChangesState) {
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartAdvertising(&client, &pcp_handler);
-}
-
-TEST_P(BasePcpHandlerTest, StopAdvertisingChangesState) {
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartAdvertising(&client, &pcp_handler);
-  EXPECT_CALL(pcp_handler, StopAdvertisingImpl(&client)).Times(1);
-  EXPECT_TRUE(client.IsAdvertising());
-  pcp_handler.StopAdvertising(&client);
-  EXPECT_FALSE(client.IsAdvertising());
-}
-
-TEST_P(BasePcpHandlerTest, StartDiscoveryChangesState) {
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartDiscovery(&client, &pcp_handler);
-}
-
-TEST_P(BasePcpHandlerTest, StopDiscoveryChangesState) {
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartDiscovery(&client, &pcp_handler);
-  EXPECT_CALL(pcp_handler, StopDiscoveryImpl(&client)).Times(1);
-  EXPECT_TRUE(client.IsDiscovering());
-  pcp_handler.StopDiscovery(&client);
-  EXPECT_FALSE(client.IsDiscovering());
-}
-
-TEST_P(BasePcpHandlerTest, RequestConnectionChangesState) {
-  std::string endpoint_id{"1234"};
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartDiscovery(&client, &pcp_handler);
-  auto channel_pair = SetupConnection(pipe_a_, pipe_b_);
-  auto& channel_a = channel_pair.first;
-  auto& channel_b = channel_pair.second;
-  EXPECT_CALL(*channel_a, CloseImpl).Times(1);
-  EXPECT_CALL(*channel_b, CloseImpl).Times(1);
-  EXPECT_CALL(mock_connection_listener_.rejected_cb, Call).Times(AtLeast(0));
-  RequestConnection(endpoint_id, std::move(channel_a), channel_b.get(), &client,
-                    &pcp_handler);
-  NEARBY_LOG(INFO, "RequestConnection complete");
-  channel_b->Close();
-  pcp_handler.DisconnectFromEndpointManager();
-}
-
-TEST_P(BasePcpHandlerTest, AcceptConnectionChangesState) {
-  std::string endpoint_id{"1234"};
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartDiscovery(&client, &pcp_handler);
-  auto channel_pair = SetupConnection(pipe_a_, pipe_b_);
-  auto& channel_a = channel_pair.first;
-  auto& channel_b = channel_pair.second;
-  EXPECT_CALL(*channel_a, CloseImpl).Times(1);
-  EXPECT_CALL(*channel_b, CloseImpl).Times(1);
-  RequestConnection(endpoint_id, std::move(channel_a), channel_b.get(), &client,
-                    &pcp_handler);
-  NEARBY_LOG(INFO, "Attempting to accept connection: id=%s",
-             endpoint_id.c_str());
-  EXPECT_EQ(pcp_handler.AcceptConnection(&client, endpoint_id, {}),
-            Status{Status::kSuccess});
-  EXPECT_CALL(mock_connection_listener_.rejected_cb, Call).Times(AtLeast(0));
-  NEARBY_LOGS(INFO) << "Closing connection: id=" << endpoint_id;
-  channel_b->Close();
-  pcp_handler.DisconnectFromEndpointManager();
-}
-
-TEST_P(BasePcpHandlerTest, RejectConnectionChangesState) {
-  std::string endpoint_id{"1234"};
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartDiscovery(&client, &pcp_handler);
-  auto channel_pair = SetupConnection(pipe_a_, pipe_b_);
-  auto& channel_b = channel_pair.second;
-  EXPECT_CALL(mock_connection_listener_.rejected_cb, Call).Times(1);
-  RequestConnection(endpoint_id, std::move(channel_pair.first), channel_b.get(),
-                    &client, &pcp_handler);
-  NEARBY_LOGS(INFO) << "Attempting to reject connection: id=" << endpoint_id;
-  EXPECT_EQ(pcp_handler.RejectConnection(&client, endpoint_id),
-            Status{Status::kSuccess});
-  NEARBY_LOGS(INFO) << "Closing connection: id=" << endpoint_id;
-  channel_b->Close();
-  pcp_handler.DisconnectFromEndpointManager();
-}
-
-TEST_P(BasePcpHandlerTest, OnIncomingFrameChangesState) {
-  std::string endpoint_id{"1234"};
-  ClientProxy client;
-  EndpointChannelManager ecm;
-  EndpointManager em(&ecm);
-  MockPcpHandler pcp_handler(&em, &ecm);
-  StartDiscovery(&client, &pcp_handler);
-  auto channel_pair = SetupConnection(pipe_a_, pipe_b_);
-  auto& channel_a = channel_pair.first;
-  auto& channel_b = channel_pair.second;
-  EXPECT_CALL(*channel_a, CloseImpl).Times(1);
-  EXPECT_CALL(*channel_b, CloseImpl).Times(1);
-  RequestConnection(endpoint_id, std::move(channel_a), channel_b.get(), &client,
-                    &pcp_handler);
-  NEARBY_LOGS(INFO) << "Attempting to accept connection: id=" << endpoint_id;
-  EXPECT_CALL(mock_connection_listener_.accepted_cb, Call).Times(1);
-  EXPECT_CALL(mock_connection_listener_.disconnected_cb, Call)
-      .Times(AtLeast(0));
-  EXPECT_EQ(pcp_handler.AcceptConnection(&client, endpoint_id, {}),
-            Status{Status::kSuccess});
-  NEARBY_LOG(INFO, "Simulating remote accept: id=%s", endpoint_id.c_str());
-  auto frame =
-      parser::FromBytes(parser::ForConnectionResponse(Status::kSuccess));
-  pcp_handler.OnIncomingFrame(frame.result(), endpoint_id, &client,
-                              Medium::BLE);
-  NEARBY_LOGS(INFO) << "Closing connection: id=" << endpoint_id;
-  channel_b->Close();
-  pcp_handler.DisconnectFromEndpointManager();
-}
-
-TEST_P(BasePcpHandlerTest, DestructorIsCalledOnProtocolEndpoint) {
-  std::atomic_int destroyed_flag = 0;
-  int mediums_count = 0;
-  {
-    std::string endpoint_id{"1234"};
-    ClientProxy client;
-    EndpointChannelManager ecm;
-    EndpointManager em(&ecm);
-    MockPcpHandler pcp_handler(&em, &ecm);
-    StartDiscovery(&client, &pcp_handler);
-    auto channel_pair = SetupConnection(pipe_a_, pipe_b_);
-    auto& channel_a = channel_pair.first;
-    auto& channel_b = channel_pair.second;
-    EXPECT_CALL(*channel_a, CloseImpl).Times(1);
-    EXPECT_CALL(*channel_b, CloseImpl).Times(1);
-    RequestConnection(endpoint_id, std::move(channel_a), channel_b.get(),
-                      &client, &pcp_handler, &destroyed_flag);
-    mediums_count = pcp_handler.GetDiscoveryMediums().size();
-    NEARBY_LOG(INFO, "Attempting to accept connection: id=%s",
-               endpoint_id.c_str());
-    EXPECT_EQ(pcp_handler.AcceptConnection(&client, endpoint_id, {}),
-              Status{Status::kSuccess});
-    EXPECT_CALL(mock_connection_listener_.rejected_cb, Call).Times(AtLeast(0));
-    NEARBY_LOG(INFO, "Closing connection: id=%s", endpoint_id.c_str());
-    channel_b->Close();
-    pcp_handler.DisconnectFromEndpointManager();
-  }
-  EXPECT_EQ(destroyed_flag.load(), mediums_count);
-}
-
-INSTANTIATE_TEST_SUITE_P(ParameterizedBasePcpHandlerTest, BasePcpHandlerTest,
-                         ::testing::ValuesIn(kTestCases));
-
-}  // namespace
-}  // namespace connections
-}  // namespace nearby
-}  // namespace location
diff --git a/chromium/third_party/nearby/src/cpp/core_v2/internal/offline_service_controller.h.orig b/chromium/third_party/nearby/src/cpp/core_v2/internal/offline_service_controller.h.orig
deleted file mode 100644
index 97517fa..0000000
--- a/chromium/third_party/nearby/src/cpp/core_v2/internal/offline_service_controller.h.orig
+++ /dev/null
@@ -1,81 +0,0 @@
-#ifndef CORE_V2_INTERNAL_OFFLINE_SERVICE_CONTROLLER_H_
-#define CORE_V2_INTERNAL_OFFLINE_SERVICE_CONTROLLER_H_
-
-#include <cstdint>
-#include <string>
-#include <vector>
-
-#include "core_v2/internal/client_proxy.h"
-#include "core_v2/internal/endpoint_channel_manager.h"
-#include "core_v2/internal/endpoint_manager.h"
-#include "core_v2/internal/mediums/mediums.h"
-#include "core_v2/internal/payload_manager.h"
-#include "core_v2/internal/pcp_manager.h"
-#include "core_v2/internal/service_controller.h"
-#include "core_v2/listeners.h"
-#include "core_v2/options.h"
-#include "core_v2/payload.h"
-#include "core_v2/status.h"
-
-namespace location {
-namespace nearby {
-namespace connections {
-
-class OfflineServiceController : public ServiceController {
- public:
-  OfflineServiceController() = default;
-  ~OfflineServiceController() override;
-
-  Status StartAdvertising(ClientProxy* client,
-                          const std::string& service_id,
-                          const ConnectionOptions& options,
-                          const ConnectionRequestInfo& info) override;
-  void StopAdvertising(ClientProxy* client) override;
-
-  Status StartDiscovery(ClientProxy* client,
-                        const std::string& service_id,
-                        const ConnectionOptions& options,
-                        const DiscoveryListener& listener) override;
-  void StopDiscovery(ClientProxy* client) override;
-
-  Status RequestConnection(ClientProxy* client,
-                           const std::string& endpoint_id,
-                           const ConnectionRequestInfo& info,
-                           const ConnectionOptions& options) override;
-  Status AcceptConnection(ClientProxy* client,
-                          const std::string& endpoint_id,
-                          const PayloadListener& listener) override;
-  Status RejectConnection(ClientProxy* client,
-                          const std::string& endpoint_id) override;
-
-  void InitiateBandwidthUpgrade(ClientProxy* client,
-                                const std::string& endpoint_id) override;
-
-  void SendPayload(ClientProxy* client,
-                   const std::vector<std::string>& endpoint_ids,
-                   Payload payload) override;
-  Status CancelPayload(ClientProxy* client,
-                       Payload::Id payload_id) override;
-
-  void DisconnectFromEndpoint(ClientProxy* client,
-                              const std::string& endpoint_id) override;
-
-  void Stop();
-
- private:
-  // Note that the order of declaration of these is crucial, because we depend
-  // on the destructors running (strictly) in the reverse order; a deviation
-  // from that will lead to crashes at runtime.
-  AtomicBoolean stop_{false};
-  Mediums mediums_;
-  EndpointChannelManager channel_manager_;
-  EndpointManager endpoint_manager_{&channel_manager_};
-  PayloadManager payload_manager_{endpoint_manager_};
-  PcpManager pcp_manager_{mediums_, channel_manager_, endpoint_manager_};
-};
-
-}  // namespace connections
-}  // namespace nearby
-}  // namespace location
-
-#endif  // CORE_V2_INTERNAL_OFFLINE_SERVICE_CONTROLLER_H_
diff --git a/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.cc b/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.cc
index fd65195..1e8d060 100644
--- a/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.cc
+++ b/chromium/third_party/perfetto/src/trace_processor/containers/string_pool.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
+#include <limits>
 #include "src/trace_processor/containers/string_pool.h"
 
-#include <limits>
 
 #include "perfetto/base/logging.h"
 #include "perfetto/ext/base/utils.h"
diff --git a/chromium/third_party/perfetto/src/trace_processor/db/column.cc b/chromium/third_party/perfetto/src/trace_processor/db/column.cc
index 00496b3..0dccfeb 100644
--- a/chromium/third_party/perfetto/src/trace_processor/db/column.cc
+++ b/chromium/third_party/perfetto/src/trace_processor/db/column.cc
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <limits>
 #include "src/trace_processor/db/column.h"
 
 #include "src/trace_processor/db/compare.h"
diff --git a/chromium/third_party/perfetto/src/trace_processor/types/variadic.cc b/chromium/third_party/perfetto/src/trace_processor/types/variadic.cc
index 837bfeb..cdd5681 100644
--- a/chromium/third_party/perfetto/src/trace_processor/types/variadic.cc
+++ b/chromium/third_party/perfetto/src/trace_processor/types/variadic.cc
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <limits>
 #include "src/trace_processor/types/variadic.h"
 
 namespace perfetto {
diff --git a/chromium/third_party/skia/src/utils/SkParseColor.cpp b/chromium/third_party/skia/src/utils/SkParseColor.cpp
index 25e63f7..deb5e38 100644
--- a/chromium/third_party/skia/src/utils/SkParseColor.cpp
+++ b/chromium/third_party/skia/src/utils/SkParseColor.cpp
@@ -7,6 +7,7 @@
 
 #include <iterator>
 
+#include <vector>
 #include "include/utils/SkParse.h"
 
 #include <algorithm> // std::lower_bound
diff --git a/chromium/third_party/webrtc/test/BUILD.gn b/chromium/third_party/webrtc/test/BUILD.gn
index 58d3dab..4832829 100644
--- a/chromium/third_party/webrtc/test/BUILD.gn
+++ b/chromium/third_party/webrtc/test/BUILD.gn
@@ -258,10 +258,6 @@ rtc_library("perf_test") {
   absl_deps = [ "//third_party/abseil-cpp/absl/types:optional" ]
   if (rtc_enable_protobuf) {
     sources += [ "testsupport/perf_test_histogram_writer.cc" ]
-    deps += [
-      "//third_party/catapult/tracing/tracing:histogram",
-      "//third_party/catapult/tracing/tracing:reserved_infos",
-    ]
   } else {
     sources += [ "testsupport/perf_test_histogram_writer_no_protobuf.cc" ]
   }
@@ -566,7 +562,6 @@ if (rtc_include_tests) {
 
     if (rtc_enable_protobuf) {
       sources += [ "testsupport/perf_test_histogram_writer_unittest.cc" ]
-      deps += [ "//third_party/catapult/tracing/tracing:histogram" ]
     }
 
     data = test_support_unittests_resources
diff --git a/chromium/tools/binary_size/BUILD.gn b/chromium/tools/binary_size/BUILD.gn
index e6806bf..2c985d1 100644
--- a/chromium/tools/binary_size/BUILD.gn
+++ b/chromium/tools/binary_size/BUILD.gn
@@ -18,7 +18,6 @@ python_library("binary_size_trybot_py") {
 python_library("sizes_py") {
   testonly = true
   pydeps_file = "sizes.pydeps"
-  data_deps = [ "//third_party/catapult/tracing:convert_chart_json" ]
 }
 
 if (is_linux || is_chromeos) {
diff --git a/chromium/tools/grit/BUILD.gn b/chromium/tools/grit/BUILD.gn
index 1cd3c75..60c4cf2 100644
--- a/chromium/tools/grit/BUILD.gn
+++ b/chromium/tools/grit/BUILD.gn
@@ -33,7 +33,6 @@ group("grit_python_unittests") {
     "//testing/scripts/run_isolated_script_test.py",
     "//testing/xvfb.py",
     "//tools/grit/",
-    "//third_party/catapult/third_party/typ/",
   ]
 }
 
diff --git a/chromium/tools/gritsettings/resource_ids.spec b/chromium/tools/gritsettings/resource_ids.spec
index d0a4545..80b0bf1 100644
--- a/chromium/tools/gritsettings/resource_ids.spec
+++ b/chromium/tools/gritsettings/resource_ids.spec
@@ -499,12 +499,6 @@
   "content/shell/shell_resources.grd": {
     "includes": [2940],
   },
-
-  # This file is generated during the build.
-  "<(SHARED_INTERMEDIATE_DIR)/content/browser/tracing/tracing_resources.grd": {
-    "META": {"sizes": {"includes": [20],}},
-    "includes": [2960],
-  },
   # END content/ section.
 
   # START ios/web/ section.
diff --git a/chromium/tools/metrics/BUILD.gn b/chromium/tools/metrics/BUILD.gn
index 846d524..cb57d2b 100644
--- a/chromium/tools/metrics/BUILD.gn
+++ b/chromium/tools/metrics/BUILD.gn
@@ -56,7 +56,6 @@ group("metrics_python_tests") {
     "//testing/scripts/common.py",
     "//testing/xvfb.py",
     "//testing/test_env.py",
-    "//third_party/catapult/third_party/typ/",
 
     # Scripts we depend on. Their unit tests are also included.
     "//tools/json_comment_eater/json_comment_eater.py",
diff --git a/chromium/tools/perf/chrome_telemetry_build/BUILD.gn b/chromium/tools/perf/chrome_telemetry_build/BUILD.gn
index 4868810..70ebd4d 100644
--- a/chromium/tools/perf/chrome_telemetry_build/BUILD.gn
+++ b/chromium/tools/perf/chrome_telemetry_build/BUILD.gn
@@ -107,7 +107,6 @@ group("telemetry_chrome_test_without_chrome") {
     "//tools/perf/core/",  # chrome_telemetry_build/ depends on core/
   ]
   data_deps = [
-    "//third_party/catapult:telemetry_chrome_test_support",
     "//tools/metrics:metrics_python_tests",
   ]
 
@@ -151,7 +150,5 @@ group("telemetry_chrome_test_without_chrome") {
       "//build/android:devil_chromium_py",
       "//build/android:stack_tools",
     ]
-  } else if (!is_fuchsia) {
-    data_deps += [ "//third_party/catapult/telemetry:bitmaptools" ]
   }
 }
diff --git a/chromium/tools/perf/core/perfetto_binary_roller/BUILD.gn b/chromium/tools/perf/core/perfetto_binary_roller/BUILD.gn
index 7fe48cb..e9c7f02 100644
--- a/chromium/tools/perf/core/perfetto_binary_roller/BUILD.gn
+++ b/chromium/tools/perf/core/perfetto_binary_roller/BUILD.gn
@@ -7,7 +7,6 @@ import("//build/util/generate_wrapper.gni")
 generate_wrapper("upload_trace_processor") {
   testonly = true
   data_deps = [
-    "//third_party/catapult:telemetry_chrome_test_support",
     "//third_party/perfetto/src/trace_processor:trace_processor_shell",
   ]
   data = [
diff --git a/chromium/tools/polymer/BUILD.gn b/chromium/tools/polymer/BUILD.gn
index 092066b..d115144 100644
--- a/chromium/tools/polymer/BUILD.gn
+++ b/chromium/tools/polymer/BUILD.gn
@@ -10,6 +10,5 @@ group("polymer_tools_python_unittests") {
     "//testing/scripts/run_isolated_script_test.py",
     "//testing/xvfb.py",
     "//tools/polymer/",
-    "//third_party/catapult/third_party/typ/",
   ]
 }
diff --git a/chromium/ui/accessibility/platform/ax_platform_atk_hyperlink.cc b/chromium/ui/accessibility/platform/ax_platform_atk_hyperlink.cc
index be91def..73f2023 100644
--- a/chromium/ui/accessibility/platform/ax_platform_atk_hyperlink.cc
+++ b/chromium/ui/accessibility/platform/ax_platform_atk_hyperlink.cc
@@ -245,7 +245,7 @@ static void AXPlatformAtkHyperlinkInit(AXPlatformAtkHyperlink* self, gpointer) {
 }
 
 GType ax_platform_atk_hyperlink_get_type() {
-  static volatile gsize type_volatile = 0;
+  static gsize type_volatile = 0;
 
   AXPlatformNodeAuraLinux::EnsureGTypeInit();
 
diff --git a/chromium/ui/accessibility/platform/ax_platform_node_auralinux.cc b/chromium/ui/accessibility/platform/ax_platform_node_auralinux.cc
index 5c51478..35d02ce 100644
--- a/chromium/ui/accessibility/platform/ax_platform_node_auralinux.cc
+++ b/chromium/ui/accessibility/platform/ax_platform_node_auralinux.cc
@@ -2274,7 +2274,7 @@ void ClassInit(gpointer class_pointer, gpointer /* class_data */) {
 GType GetType() {
   AXPlatformNodeAuraLinux::EnsureGTypeInit();
 
-  static volatile gsize type_volatile = 0;
+  static gsize type_volatile = 0;
   if (g_once_init_enter(&type_volatile)) {
     static const GTypeInfo type_info = {
         sizeof(AXPlatformNodeAuraLinuxClass),  // class_size
diff --git a/chromium/ui/gtk/gtk_key_bindings_handler.cc b/chromium/ui/gtk/gtk_key_bindings_handler.cc
index c663a20..38a3424 100644
--- a/chromium/ui/gtk/gtk_key_bindings_handler.cc
+++ b/chromium/ui/gtk/gtk_key_bindings_handler.cc
@@ -141,7 +141,7 @@ void GtkKeyBindingsHandler::HandlerClassInit(HandlerClass* klass) {
 }
 
 GType GtkKeyBindingsHandler::HandlerGetType() {
-  static volatile gsize type_id_volatile = 0;
+  static gsize type_id_volatile = 0;
   if (g_once_init_enter(&type_id_volatile)) {
     GType type_id = g_type_register_static_simple(
         GTK_TYPE_TEXT_VIEW, g_intern_static_string("GtkKeyBindingsHandler"),
diff --git a/chromium/v8/tools/BUILD.gn b/chromium/v8/tools/BUILD.gn
index 2f8197d..83304b6 100644
--- a/chromium/v8/tools/BUILD.gn
+++ b/chromium/v8/tools/BUILD.gn
@@ -31,10 +31,6 @@ group("v8_android_test_runner_deps") {
 
   if (is_android && !build_with_chromium) {
     data_deps = [ "//build/android:test_runner_py" ]
-    data = [
-      # This is used by android.py, but not included by test_runner_py above.
-      "//third_party/catapult/devil/devil/android/perf/",
-    ]
   }
 }
 
diff --git a/chromium/weblayer/shell/BUILD.gn b/chromium/weblayer/shell/BUILD.gn
index 66984a7..1815fad 100644
--- a/chromium/weblayer/shell/BUILD.gn
+++ b/chromium/weblayer/shell/BUILD.gn
@@ -161,7 +161,6 @@ repack("support_pak") {
     "$root_gen_dir/components/strings/components_locale_settings_en-US.pak",
     "$root_gen_dir/components/strings/components_strings_en-US.pak",
     "$root_gen_dir/content/app/resources/content_resources_100_percent.pak",
-    "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
     "$root_gen_dir/content/content_resources.pak",
     "$root_gen_dir/content/dev_ui_content_resources.pak",
     "$root_gen_dir/mojo/public/js/mojo_bindings_resources.pak",
@@ -182,7 +181,6 @@ repack("support_pak") {
     "//content:content_resources",
     "//content:dev_ui_content_resources",
     "//content/app/resources",
-    "//content/browser/tracing:resources",
     "//mojo/public/js:resources",
     "//net:net_resources",
     "//third_party/blink/public:resources",
-- 
2.45.2


From 2883607bbd5b6ac98154cf3bfbd07666269716cf Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Sat, 16 Dec 2023 18:56:29 +1000
Subject: Fixes build for x86 arch


diff --git a/chromium/base/atomicops.h b/chromium/base/atomicops.h
index 5fa27a4..1122b5f 100644
--- a/chromium/base/atomicops.h
+++ b/chromium/base/atomicops.h
@@ -57,7 +57,11 @@ typedef intptr_t Atomic64;
 
 // Use AtomicWord for a machine-sized pointer.  It will use the Atomic32 or
 // Atomic64 routines below, depending on your architecture.
+#if defined(ARCH_CPU_64_BITS)
 typedef intptr_t AtomicWord;
+#else
+typedef int32_t AtomicWord;
+#endif
 
 // Atomically execute:
 //      result = *ptr;
diff --git a/chromium/base/memory/discardable_shared_memory.cc b/chromium/base/memory/discardable_shared_memory.cc
index 4aa6229..cdfde4f 100644
--- a/chromium/base/memory/discardable_shared_memory.cc
+++ b/chromium/base/memory/discardable_shared_memory.cc
@@ -178,7 +178,11 @@ bool DiscardableSharedMemory::CreateAndMap(size_t size) {
   DCHECK(last_known_usage_.is_null());
   SharedState new_state(SharedState::LOCKED, Time());
   subtle::Release_Store(
+#if defined(ARCH_CPU_64_BITS)
       &SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#else
+      (base::subtle::Atomic32*)&SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#endif
       new_state.value.i);
   return true;
 }
@@ -239,7 +243,11 @@ DiscardableSharedMemory::LockResult DiscardableSharedMemory::Lock(
     SharedState old_state(SharedState::UNLOCKED, last_known_usage_);
     SharedState new_state(SharedState::LOCKED, Time());
     SharedState result(subtle::Acquire_CompareAndSwap(
+#if defined(ARCH_CPU_64_BITS)
         &SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#else
+        (base::subtle::Atomic32*)&SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#endif
         old_state.value.i, new_state.value.i));
     if (result.value.u != old_state.value.u) {
       // Update |last_known_usage_| in case the above CAS failed because of
@@ -354,7 +362,11 @@ void DiscardableSharedMemory::Unlock(size_t offset, size_t length) {
   DCHECK_EQ((new_state.GetTimestamp() - Time::UnixEpoch()).InSeconds(),
             (current_time - Time::UnixEpoch()).InSeconds());
   SharedState result(subtle::Release_CompareAndSwap(
+#if defined(ARCH_CPU_64_BITS)
       &SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#else
+      (base::subtle::Atomic32*)&SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#endif
       old_state.value.i, new_state.value.i));
 
   DCHECK_EQ(old_state.value.u, result.value.u);
@@ -375,7 +387,11 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
   SharedState old_state(SharedState::UNLOCKED, last_known_usage_);
   SharedState new_state(SharedState::UNLOCKED, Time());
   SharedState result(subtle::Acquire_CompareAndSwap(
+#if defined(ARCH_CPU_64_BITS)
       &SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#else
+      (base::subtle::Atomic32*)&SharedStateFromSharedMemory(shared_memory_mapping_)->value.i,
+#endif
       old_state.value.i, new_state.value.i));
 
   // Update |last_known_usage_| to |current_time| if the memory is locked. This
@@ -466,7 +482,11 @@ bool DiscardableSharedMemory::IsMemoryResident() const {
   DCHECK(shared_memory_mapping_.IsValid());
 
   SharedState result(subtle::NoBarrier_Load(
+#if defined(ARCH_CPU_64_BITS)
       &SharedStateFromSharedMemory(shared_memory_mapping_)->value.i));
+#else
+      (base::subtle::Atomic32*)&SharedStateFromSharedMemory(shared_memory_mapping_)->value.i));
+#endif
 
   return result.GetLockState() == SharedState::LOCKED ||
          !result.GetTimestamp().is_null();
@@ -476,7 +496,11 @@ bool DiscardableSharedMemory::IsMemoryLocked() const {
   DCHECK(shared_memory_mapping_.IsValid());
 
   SharedState result(subtle::NoBarrier_Load(
+#if defined(ARCH_CPU_64_BITS)
       &SharedStateFromSharedMemory(shared_memory_mapping_)->value.i));
+#else
+      (base::subtle::Atomic32*)&SharedStateFromSharedMemory(shared_memory_mapping_)->value.i));
+#endif
 
   return result.GetLockState() == SharedState::LOCKED;
 }
diff --git a/chromium/base/process/internal_linux.cc b/chromium/base/process/internal_linux.cc
index 41cae83..48f76d3 100644
--- a/chromium/base/process/internal_linux.cc
+++ b/chromium/base/process/internal_linux.cc
@@ -47,13 +47,17 @@ pid_t ProcDirSlotToPid(const char* d_name) {
     return 0;
 
   // Read the process's command line.
+#if defined(ARCH_CPU_64_BITS)
   pid_t pid;
+#else
+  int pid;
+#endif
   std::string pid_string(d_name);
   if (!StringToInt(pid_string, &pid)) {
     NOTREACHED();
     return 0;
   }
-  return pid;
+  return (pid_t)pid;
 }
 
 bool ReadProcFile(const FilePath& file, std::string* buffer) {
diff --git a/chromium/base/process/internal_linux.h b/chromium/base/process/internal_linux.h
index 10fa85a..cfd5647 100644
--- a/chromium/base/process/internal_linux.h
+++ b/chromium/base/process/internal_linux.h
@@ -121,8 +121,15 @@ void ForEachProcessTask(base::ProcessHandle process, Lambda&& lambda) {
       continue;
 
     PlatformThreadId tid;
+#if defined(ARCH_CPU_64_BITS)
     if (!StringToInt(tid_str, &tid))
       continue;
+#else
+	int tid_int;
+    if (!StringToInt(tid_str, &tid_int))
+      continue;
+    tid = (PlatformThreadId)tid_int;
+#endif
 
     FilePath task_path = fd_path.Append(tid_str);
     lambda(tid, task_path);
diff --git a/chromium/base/process/process_handle.h b/chromium/base/process/process_handle.h
index d7e185a..4b49da5 100644
--- a/chromium/base/process/process_handle.h
+++ b/chromium/base/process/process_handle.h
@@ -36,6 +36,11 @@ typedef zx_handle_t ProcessHandle;
 typedef zx_koid_t ProcessId;
 const ProcessHandle kNullProcessHandle = ZX_HANDLE_INVALID;
 const ProcessId kNullProcessId = ZX_KOID_INVALID;
+#elif defined(OS_HAIKU)
+typedef int32_t ProcessHandle;
+typedef int32_t ProcessId;
+const ProcessHandle kNullProcessHandle = 0;
+const ProcessId kNullProcessId = 0;
 #elif defined(OS_POSIX)
 // On POSIX, our ProcessHandle will just be the PID.
 typedef pid_t ProcessHandle;
diff --git a/chromium/base/system/sys_info_posix.cc b/chromium/base/system/sys_info_posix.cc
index 9a58b6d..e018730 100644
--- a/chromium/base/system/sys_info_posix.cc
+++ b/chromium/base/system/sys_info_posix.cc
@@ -219,7 +219,7 @@ std::string SysInfo::OperatingSystemArchitecture() {
     return std::string();
   }
   std::string arch(info.machine);
-  if (arch == "i386" || arch == "i486" || arch == "i586" || arch == "i686") {
+  if (arch == "i386" || arch == "i486" || arch == "i586" || arch == "i686" || arch == "BePC") {
     arch = "x86";
   } else if (arch == "amd64") {
     arch = "x86_64";
diff --git a/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc b/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc
index 6870307..2664266 100644
--- a/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc
+++ b/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc
@@ -177,7 +177,11 @@ pid_t ZygoteHostImpl::LaunchZygote(
   close(fds[1]);
   control_fd->reset(fds[0]);
 
+#if defined(ARCH_CPU_64_BITS)
   pid_t pid = process.Pid();
+#else
+  int32_t pid = process.Pid();
+#endif
 
   if (is_sandboxed_zygote && (use_namespace_sandbox_ || use_suid_sandbox_)) {
     // The namespace and SUID sandbox will execute the zygote in a new
@@ -200,7 +204,11 @@ pid_t ZygoteHostImpl::LaunchZygote(
 
     // Now receive the message that the zygote's ready to go, along with the
     // main zygote process's ID.
+#if defined(ARCH_CPU_64_BITS)
     pid_t real_pid;
+#else
+    int32_t real_pid;
+#endif
     CHECK(ReceiveFixedMessage(fds[0], kZygoteHelloMessage,
                               sizeof(kZygoteHelloMessage), &real_pid));
     CHECK_GT(real_pid, 1);
diff --git a/chromium/content/common/zygote/zygote_communication_linux.cc b/chromium/content/common/zygote/zygote_communication_linux.cc
index 474be46..9ec8402 100644
--- a/chromium/content/common/zygote/zygote_communication_linux.cc
+++ b/chromium/content/common/zygote/zygote_communication_linux.cc
@@ -123,7 +123,11 @@ pid_t ZygoteCommunication::ForkRequest(
   // Sanity check that we've populated |fds| correctly.
   DCHECK_EQ(num_fds_to_send, fds.size());
 
+#if defined(ARCH_CPU_64_BITS)
   pid_t pid;
+#else
+  int32_t pid;
+#endif
   {
     base::AutoLock lock(control_lock_);
     if (!SendMessage(pickle, &fds))
diff --git a/chromium/gpu/ipc/common/memory_stats_mojom_traits.h b/chromium/gpu/ipc/common/memory_stats_mojom_traits.h
index e76b61b..97a3e17 100644
--- a/chromium/gpu/ipc/common/memory_stats_mojom_traits.h
+++ b/chromium/gpu/ipc/common/memory_stats_mojom_traits.h
@@ -37,7 +37,7 @@ struct StructTraits<gpu::mojom::VideoMemoryUsageStatsDataView,
                     gpu::VideoMemoryUsageStats> {
   static std::map<int32_t, gpu::VideoMemoryUsageStats::ProcessStats>
   process_map(const gpu::VideoMemoryUsageStats& stats) {
-#if defined(OS_WIN) || defined(OS_FUCHSIA)
+#if defined(OS_WIN) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
     std::map<int32_t, gpu::VideoMemoryUsageStats::ProcessStats> map;
     for (const auto& pair : stats.process_map)
       map[static_cast<int32_t>(pair.first)] = pair.second;
@@ -53,7 +53,7 @@ struct StructTraits<gpu::mojom::VideoMemoryUsageStatsDataView,
 
   static bool Read(gpu::mojom::VideoMemoryUsageStatsDataView data,
                    gpu::VideoMemoryUsageStats* out) {
-#if defined(OS_WIN) || defined(OS_FUCHSIA)
+#if defined(OS_WIN) || defined(OS_FUCHSIA) || defined(OS_HAIKU)
     std::map<int32_t, gpu::VideoMemoryUsageStats::ProcessStats> process_map;
     if (!data.ReadProcessMap(&process_map))
       return false;
diff --git a/chromium/third_party/blink/public/platform/web_vector.h b/chromium/third_party/blink/public/platform/web_vector.h
index 2cc291d..83b2538 100644
--- a/chromium/third_party/blink/public/platform/web_vector.h
+++ b/chromium/third_party/blink/public/platform/web_vector.h
@@ -81,7 +81,7 @@ class WebVector {
   // The vector can be populated using reserve() and emplace_back().
   WebVector() = default;
 
-#if defined(ARCH_CPU_64_BITS)
+#if defined(ARCH_CPU_64_BITS) || defined(__HAIKU__)
   // Create a vector with |size| default-constructed elements. We define
   // a constructor with size_t otherwise we'd have a duplicate define.
   explicit WebVector(size_t size) : data_(size) {}
diff --git a/chromium/v8/src/base/atomicops.h b/chromium/v8/src/base/atomicops.h
index 5d6422b..9299d4c 100644
--- a/chromium/v8/src/base/atomicops.h
+++ b/chromium/v8/src/base/atomicops.h
@@ -73,6 +73,8 @@ using Atomic64 = intptr_t;
 // Atomic64 routines below, depending on your architecture.
 #if defined(V8_OS_STARBOARD)
 using AtomicWord = SbAtomicPtr;
+#elif defined(V8_TARGET_ARCH_IA32)
+using AtomicWord = int32_t;
 #else
 using AtomicWord = intptr_t;
 #endif
diff --git a/gn/tools/gn/args.cc b/gn/tools/gn/args.cc
index a2f49b1..0d79586 100644
--- a/gn/tools/gn/args.cc
+++ b/gn/tools/gn/args.cc
@@ -336,7 +336,7 @@ void Args::SetSystemVarsLocked(Scope* dest) const {
   // Set the host CPU architecture based on the underlying OS, not
   // whatever the current bit-tedness of the GN binary is.
   std::string os_arch = OperatingSystemArchitecture();
-  if (os_arch == "x86")
+  if (os_arch == "x86" || os_arch == "BePC")
     arch = kX86;
   else if (os_arch == "x86_64")
     arch = kX64;
-- 
2.45.2


From 771635155bd5a0f83511e62c7637344dbbb07cfd Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Thu, 29 Aug 2024 09:35:54 +1000
Subject: Use internal ffmpeg


diff --git a/chromium/media/audio/audio_features.cc b/chromium/media/audio/audio_features.cc
index af2faa4..e486542 100644
--- a/chromium/media/audio/audio_features.cc
+++ b/chromium/media/audio/audio_features.cc
@@ -12,7 +12,7 @@ namespace features {
 const base::Feature kAudioServiceOutOfProcessKillAtHang{
   "AudioServiceOutOfProcessKillAtHang",
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_HAIKU)
       base::FEATURE_ENABLED_BY_DEFAULT
 #else
       base::FEATURE_DISABLED_BY_DEFAULT
diff --git a/chromium/media/audio/audio_input_device.cc b/chromium/media/audio/audio_input_device.cc
index 64dadc3..e9c2a6f 100644
--- a/chromium/media/audio/audio_input_device.cc
+++ b/chromium/media/audio/audio_input_device.cc
@@ -253,7 +253,7 @@ void AudioInputDevice::OnStreamCreated(
 // here. See comments in AliveChecker and PowerObserverHelper for details and
 // todos.
   if (detect_dead_stream_ == DeadStreamDetection::kEnabled) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     const bool stop_at_first_alive_notification = true;
     const bool pause_check_during_suspend = false;
 #else
diff --git a/chromium/media/audio/audio_manager.cc b/chromium/media/audio/audio_manager.cc
index 01ccb57..1b469f6 100644
--- a/chromium/media/audio/audio_manager.cc
+++ b/chromium/media/audio/audio_manager.cc
@@ -48,7 +48,7 @@ class AudioManagerHelper {
   }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   void set_app_name(const std::string& app_name) { app_name_ = app_name; }
   const std::string& app_name() const { return app_name_; }
 #endif
@@ -59,7 +59,7 @@ class AudioManagerHelper {
   std::unique_ptr<base::win::ScopedCOMInitializer> com_initializer_for_testing_;
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   std::string app_name_;
 #endif
 
@@ -130,7 +130,7 @@ std::unique_ptr<AudioManager> AudioManager::CreateForTesting(
   return Create(std::move(audio_thread), GetHelper()->fake_log_factory());
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // static
 void AudioManager::SetGlobalAppName(const std::string& app_name) {
   GetHelper()->set_app_name(app_name);
diff --git a/chromium/media/audio/audio_manager.h b/chromium/media/audio/audio_manager.h
index c89151d..d7c60ac 100644
--- a/chromium/media/audio/audio_manager.h
+++ b/chromium/media/audio/audio_manager.h
@@ -60,7 +60,7 @@ class MEDIA_EXPORT AudioManager {
   static std::unique_ptr<AudioManager> CreateForTesting(
       std::unique_ptr<AudioThread> audio_thread);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Sets the name of the audio source as seen by external apps. Only actually
   // used with PulseAudio and MPRIS as of this writing.
   static void SetGlobalAppName(const std::string& app_name);
diff --git a/chromium/media/base/audio_latency.cc b/chromium/media/base/audio_latency.cc
index c181ec4..1e1e106 100644
--- a/chromium/media/base/audio_latency.cc
+++ b/chromium/media/base/audio_latency.cc
@@ -114,7 +114,7 @@ int AudioLatency::GetRtcBufferSize(int sample_rate, int hardware_buffer_size) {
   }
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_HAIKU)
   // On Linux, MacOS and Fuchsia, the low level IO implementations on the
   // browser side supports all buffer size the clients want. We use the native
   // peer connection buffer size (10ms) to achieve best possible performance.
diff --git a/chromium/media/base/media_switches.cc b/chromium/media/base/media_switches.cc
index 22101ed..94c9a82 100644
--- a/chromium/media/base/media_switches.cc
+++ b/chromium/media/base/media_switches.cc
@@ -361,7 +361,7 @@ const base::Feature kGav1VideoDecoder{"Gav1VideoDecoder",
 const base::Feature kGlobalMediaControls {
   "GlobalMediaControls",
 #if defined(OS_WIN) || defined(OS_MAC) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_HAIKU)
       base::FEATURE_ENABLED_BY_DEFAULT
 #else
       base::FEATURE_DISABLED_BY_DEFAULT
diff --git a/chromium/media/base/status.cc b/chromium/media/base/status.cc
index 1e30c22..9f9d902 100644
--- a/chromium/media/base/status.cc
+++ b/chromium/media/base/status.cc
@@ -70,7 +70,9 @@ Status&& Status::AddCause(Status&& cause) && {
 
 void Status::AddFrame(const base::Location& location) {
   DCHECK(data_);
+#if SUPPORTS_LOCATION_BUILTINS
   data_->frames.push_back(MediaSerialize(location));
+#endif
 }
 
 Status OkStatus() {
diff --git a/chromium/media/base/video_frame.cc b/chromium/media/base/video_frame.cc
index e889678..94cbeaa 100644
--- a/chromium/media/base/video_frame.cc
+++ b/chromium/media/base/video_frame.cc
@@ -60,7 +60,7 @@ std::string VideoFrame::StorageTypeToString(
       return "OWNED_MEMORY";
     case VideoFrame::STORAGE_SHMEM:
       return "SHMEM";
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     case VideoFrame::STORAGE_DMABUFS:
       return "DMABUFS";
 #endif
@@ -77,7 +77,7 @@ std::string VideoFrame::StorageTypeToString(
 // static
 bool VideoFrame::IsStorageTypeMappable(VideoFrame::StorageType storage_type) {
   return
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
       // This is not strictly needed but makes explicit that, at VideoFrame
       // level, DmaBufs are not mappable from userspace.
       storage_type != VideoFrame::STORAGE_DMABUFS &&
@@ -262,7 +262,7 @@ static base::Optional<VideoFrameLayout> GetDefaultLayout(
   return VideoFrameLayout::CreateWithPlanes(format, coded_size, planes);
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // This class allows us to embed a vector<ScopedFD> into a scoped_refptr, and
 // thus to have several VideoFrames share the same set of DMABUF FDs.
 class VideoFrame::DmabufHolder
@@ -607,7 +607,7 @@ scoped_refptr<VideoFrame> VideoFrame::WrapExternalGpuMemoryBuffer(
   }
 
   uint64_t modifier = gfx::NativePixmapHandle::kNoModifier;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (gpu_memory_buffer->GetType() == gfx::NATIVE_PIXMAP) {
     const auto gmb_handle = gpu_memory_buffer->CloneHandle();
     if (gmb_handle.is_null() ||
@@ -645,7 +645,7 @@ scoped_refptr<VideoFrame> VideoFrame::WrapExternalGpuMemoryBuffer(
   return frame;
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 // static
 scoped_refptr<VideoFrame> VideoFrame::WrapExternalDmabufs(
     const VideoFrameLayout& layout,
@@ -847,7 +847,7 @@ scoped_refptr<VideoFrame> VideoFrame::WrapVideoFrame(
     }
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   DCHECK(frame->dmabuf_fds_);
   // If there are any |dmabuf_fds_| plugged in, we should refer them too.
   wrapping_frame->dmabuf_fds_ = frame->dmabuf_fds_;
@@ -1190,7 +1190,7 @@ VideoFrame::mailbox_holder(size_t texture_index) const {
                         : mailbox_holders_[texture_index];
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 const std::vector<base::ScopedFD>& VideoFrame::DmabufFds() const {
   DCHECK_EQ(storage_type_, STORAGE_DMABUFS);
 
@@ -1273,7 +1273,7 @@ VideoFrame::VideoFrame(const VideoFrameLayout& layout,
       storage_type_(storage_type),
       visible_rect_(Intersection(visible_rect, gfx::Rect(layout.coded_size()))),
       natural_size_(natural_size),
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
       dmabuf_fds_(base::MakeRefCounted<DmabufHolder>()),
 #endif
       timestamp_(timestamp),
diff --git a/chromium/media/base/video_frame.h b/chromium/media/base/video_frame.h
index e31d70d..b61acc3 100644
--- a/chromium/media/base/video_frame.h
+++ b/chromium/media/base/video_frame.h
@@ -41,7 +41,7 @@
 #include "base/mac/scoped_cftyperef.h"
 #endif  // defined(OS_MAC)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "base/files/scoped_file.h"
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
@@ -83,7 +83,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
     STORAGE_UNOWNED_MEMORY = 2,  // External, non owned data pointers.
     STORAGE_OWNED_MEMORY = 3,  // VideoFrame has allocated its own data buffer.
     STORAGE_SHMEM = 4,         // Backed by unsafe (writable) shared memory.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
     // TODO(mcasas): Consider turning this type into STORAGE_NATIVE
     // based on the idea of using this same enum value for both DMA
     // buffers on Linux and CVPixelBuffers on Mac (which currently use
@@ -260,7 +260,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
       ReleaseMailboxCB mailbox_holder_release_cb,
       base::TimeDelta timestamp);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Wraps provided dmabufs
   // (https://www.kernel.org/doc/html/latest/driver-api/dma-buf.html) with a
   // VideoFrame. The frame will take ownership of |dmabuf_fds|, and will
@@ -507,7 +507,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // mailbox, the caller must wait for the included sync point.
   const gpu::MailboxHolder& mailbox_holder(size_t texture_index) const;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // Returns a vector containing the backing DmaBufs for this frame. The number
   // of returned DmaBufs will be equal or less than the number of planes of
   // the frame. If there are less, this means that the last FD contains the
@@ -696,7 +696,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // GPU memory buffer, if this frame is STORAGE_GPU_MEMORY_BUFFER.
   std::unique_ptr<gfx::GpuMemoryBuffer> gpu_memory_buffer_;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   class DmabufHolder;
 
   // Dmabufs for the frame, used when storage is STORAGE_DMABUFS. Size is either
diff --git a/chromium/media/blink/webmediaplayer_impl.cc b/chromium/media/blink/webmediaplayer_impl.cc
index 28ada62..d148d8d 100644
--- a/chromium/media/blink/webmediaplayer_impl.cc
+++ b/chromium/media/blink/webmediaplayer_impl.cc
@@ -280,8 +280,11 @@ void CreateAllocation(base::trace_event::ProcessMemoryDump* pmd,
 
   auto* std_allocator = base::trace_event::MemoryDumpManager::GetInstance()
                             ->system_allocator_pool_name();
-  if (std_allocator)
+  if (std_allocator == nullptr) {
+    pmd->AddSuballocation(dump->guid(), std::string());
+  } else {
     pmd->AddSuballocation(dump->guid(), std_allocator);
+  }
 }
 
 // Determine whether we should update MediaPosition in |delegate_|.
diff --git a/chromium/media/gpu/buffer_validation.cc b/chromium/media/gpu/buffer_validation.cc
index 3b7921b..8793774 100644
--- a/chromium/media/gpu/buffer_validation.cc
+++ b/chromium/media/gpu/buffer_validation.cc
@@ -12,7 +12,7 @@
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/gpu_memory_buffer.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include <sys/types.h>
 #include <unistd.h>
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
@@ -20,7 +20,7 @@
 namespace media {
 
 bool GetFileSize(const int fd, size_t* size) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (fd < 0) {
     VLOGF(1) << "Invalid file descriptor";
     return false;
@@ -56,7 +56,7 @@ bool VerifyGpuMemoryBufferHandle(media::VideoPixelFormat pixel_format,
     VLOGF(1) << "Unexpected GpuMemoryBufferType: " << gmb_handle.type;
     return false;
   }
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   const size_t num_planes = media::VideoFrame::NumPlanes(pixel_format);
   if (num_planes != gmb_handle.native_pixmap_handle.planes.size() ||
       num_planes == 0) {
diff --git a/chromium/media/mojo/clients/mojo_video_encode_accelerator.cc b/chromium/media/mojo/clients/mojo_video_encode_accelerator.cc
index 57e6015..be7246e 100644
--- a/chromium/media/mojo/clients/mojo_video_encode_accelerator.cc
+++ b/chromium/media/mojo/clients/mojo_video_encode_accelerator.cc
@@ -134,7 +134,7 @@ void MojoVideoEncodeAccelerator::Encode(scoped_refptr<VideoFrame> frame,
   DCHECK_EQ(num_planes, frame->layout().num_planes());
   DCHECK(vea_.is_bound());
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   // TODO(crbug.com/1003197): Remove this once we stop supporting STORAGE_DMABUF
   // in VideoEncodeAccelerator.
   if (frame->storage_type() == VideoFrame::STORAGE_DMABUFS) {
diff --git a/chromium/media/mojo/mojom/video_frame_mojom_traits.cc b/chromium/media/mojo/mojom/video_frame_mojom_traits.cc
index 1f50120..aa421a7 100644
--- a/chromium/media/mojo/mojom/video_frame_mojom_traits.cc
+++ b/chromium/media/mojo/mojom/video_frame_mojom_traits.cc
@@ -21,7 +21,7 @@
 #include "ui/gfx/mojom/color_space_mojom_traits.h"
 #include "ui/gl/mojom/hdr_metadata_mojom_traits.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include "base/posix/eintr_wrapper.h"
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
@@ -63,7 +63,7 @@ media::mojom::VideoFrameDataPtr MakeVideoFrameData(
             std::move(offsets)));
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (input->storage_type() == media::VideoFrame::STORAGE_DMABUFS) {
     std::vector<mojo::PlatformHandle> dmabuf_fds;
 
@@ -166,7 +166,7 @@ bool StructTraits<media::mojom::VideoFrameDataView,
         shared_buffer_data.TakeFrameData(),
         shared_buffer_data.frame_data_size(), std::move(offsets),
         std::move(strides), timestamp);
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   } else if (data.is_dmabuf_data()) {
     media::mojom::DmabufVideoFrameDataDataView dmabuf_data;
     data.GetDmabufDataDataView(&dmabuf_data);
diff --git a/chromium/media/mojo/services/gpu_mojo_media_client.cc b/chromium/media/mojo/services/gpu_mojo_media_client.cc
index b1f553c..0ca0ec0 100644
--- a/chromium/media/mojo/services/gpu_mojo_media_client.cc
+++ b/chromium/media/mojo/services/gpu_mojo_media_client.cc
@@ -67,7 +67,7 @@ namespace media {
 namespace {
 
 #if defined(OS_ANDROID) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_WIN) || defined(OS_LINUX)
+    defined(OS_WIN) || defined(OS_LINUX) || defined(OS_HAIKU)
 gpu::CommandBufferStub* GetCommandBufferStub(
     scoped_refptr<base::SingleThreadTaskRunner> gpu_task_runner,
     base::WeakPtr<MediaGpuChannelManager> media_gpu_channel_manager,
@@ -299,7 +299,7 @@ std::unique_ptr<VideoDecoder> GpuMojoMediaClient::CreateVideoDecoder(
       }
 
 #elif defined(OS_MAC) || defined(OS_WIN) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #if defined(OS_WIN)
       // Don't instantiate the DXVA decoder if it's not supported.
       if (gpu_workarounds_.disable_dxva_video_decoder)
diff --git a/chromium/media/video/fake_gpu_memory_buffer.cc b/chromium/media/video/fake_gpu_memory_buffer.cc
index 891bcbb..1abf309 100644
--- a/chromium/media/video/fake_gpu_memory_buffer.cc
+++ b/chromium/media/video/fake_gpu_memory_buffer.cc
@@ -10,7 +10,7 @@
 #include "media/base/format_utils.h"
 #include "media/base/video_frame.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -48,7 +48,7 @@ class FakeGpuMemoryBufferImpl : public gpu::GpuMemoryBufferImpl {
 
 }  // namespace
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 base::ScopedFD GetDummyFD() {
   base::ScopedFD fd(open("/dev/zero", O_RDWR));
   DCHECK(fd.is_valid());
@@ -78,7 +78,7 @@ FakeGpuMemoryBuffer::FakeGpuMemoryBuffer(const gfx::Size& size,
   static base::NoDestructor<base::AtomicSequenceNumber> buffer_id_generator;
   handle_.id = gfx::GpuMemoryBufferId(buffer_id_generator->GetNext());
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   for (size_t i = 0; i < VideoFrame::NumPlanes(video_pixel_format_); i++) {
     const gfx::Size plane_size_in_bytes =
         VideoFrame::PlaneSize(video_pixel_format_, i, size_);
@@ -135,7 +135,7 @@ gfx::GpuMemoryBufferHandle FakeGpuMemoryBuffer::CloneHandle() const {
   gfx::GpuMemoryBufferHandle handle;
   handle.type = gfx::NATIVE_PIXMAP;
   handle.id = handle_.id;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   handle.native_pixmap_handle =
       gfx::CloneHandleForIPC(handle_.native_pixmap_handle);
 #endif
diff --git a/chromium/media/video/gpu_memory_buffer_video_frame_pool.cc b/chromium/media/video/gpu_memory_buffer_video_frame_pool.cc
index cff6651..761c1c2 100644
--- a/chromium/media/video/gpu_memory_buffer_video_frame_pool.cc
+++ b/chromium/media/video/gpu_memory_buffer_video_frame_pool.cc
@@ -573,7 +573,7 @@ void GpuMemoryBufferVideoFramePool::PoolImpl::CreateHardwareFrame(
   }
 
   bool is_software_backed_video_frame = !video_frame->HasTextures();
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   is_software_backed_video_frame &= !video_frame->HasDmaBufs();
 #endif
 
diff --git a/chromium/third_party/ffmpeg/BUILD.gn b/chromium/third_party/ffmpeg/BUILD.gn
old mode 100755
new mode 100644
index 8dacfa7..4ebf9c2
--- a/chromium/third_party/ffmpeg/BUILD.gn
+++ b/chromium/third_party/ffmpeg/BUILD.gn
@@ -15,7 +15,7 @@ platform_config_root =
 
 has_nasm_deps =
     ffmpeg_asm_sources != [] &&
-    (current_cpu == "x86" || current_cpu == "x64") && os_config != "linux-noasm"
+    (current_cpu == "x86" || current_cpu == "x64") && os_config != "linux-noasm" && os_config != "haiku"
 if (has_nasm_deps) {
   import("//third_party/nasm/nasm_assemble.gni")
 
@@ -336,7 +336,7 @@ target(link_target_type, "ffmpeg_internal") {
       "-L",
       rebase_path(target_gen_dir, root_build_dir),
     ]
-    if (!is_android && !is_fuchsia) {
+    if (!is_android && !is_fuchsia && !is_haiku) {
       # OS=android requires that both -lz and -lm occur after
       # -lc++_shared on the link command line. Android link rules
       # already include -lm, and we get -lz as a transitive dependency
diff --git a/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py b/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py
index 0f606df..d774e17 100755
--- a/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py
+++ b/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py
@@ -54,7 +54,7 @@ ffmpeg_c_sources = []
 ffmpeg_gas_sources = []
 ffmpeg_asm_sources = []
 
-use_linux_config = is_linux || is_chromeos || is_fuchsia
+use_linux_config = is_linux || is_chromeos || is_fuchsia || is_haiku
 
 """
 GN_CONDITION_BEGIN = """if (%s) {
diff --git a/chromium/third_party/ffmpeg/ffmpeg_generated.gni b/chromium/third_party/ffmpeg/ffmpeg_generated.gni
index 41bccf9..8570592 100644
--- a/chromium/third_party/ffmpeg/ffmpeg_generated.gni
+++ b/chromium/third_party/ffmpeg/ffmpeg_generated.gni
@@ -12,7 +12,7 @@ ffmpeg_c_sources = []
 ffmpeg_gas_sources = []
 ffmpeg_asm_sources = []
 
-use_linux_config = is_linux || is_chromeos || is_fuchsia
+use_linux_config = is_linux || is_chromeos || is_fuchsia || is_haiku
 
 if ((is_android && current_cpu == "arm" && arm_use_neon) || (is_android && current_cpu == "arm64") || (is_android && current_cpu == "mips64el") || (is_android && current_cpu == "mipsel") || (is_android && current_cpu == "x64") || (is_android && current_cpu == "x86") || (is_mac) || (is_win) || (use_linux_config)) {
   ffmpeg_c_sources += [
diff --git a/chromium/third_party/ffmpeg/ffmpeg_options.gni b/chromium/third_party/ffmpeg/ffmpeg_options.gni
index 0654f3d..11704a0 100644
--- a/chromium/third_party/ffmpeg/ffmpeg_options.gni
+++ b/chromium/third_party/ffmpeg/ffmpeg_options.gni
@@ -66,7 +66,7 @@ if (current_cpu == "x86") {
 }
 
 os_config = current_os
-if ((is_linux || is_chromeos) && is_msan) {
+if ((is_linux || is_chromeos || is_haiku) && is_msan) {
   os_config = "linux-noasm"
 } else if (is_chromeos || is_fuchsia) {
   os_config = "linux"
diff --git a/chromium/third_party/ffmpeg/libavutil/cpu.c b/chromium/third_party/ffmpeg/libavutil/cpu.c
index 52f6b9a..9504fc2 100644
--- a/chromium/third_party/ffmpeg/libavutil/cpu.c
+++ b/chromium/third_party/ffmpeg/libavutil/cpu.c
@@ -41,8 +41,10 @@
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
+#ifndef __HAIKU__
 #include <sys/sysctl.h>
 #endif
+#endif
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-- 
2.45.2


From 5435e15f4378195514af81dedc05f1f59820131a Mon Sep 17 00:00:00 2001
From: Gerasim Troeglazov <3dEyes@gmail.com>
Date: Thu, 29 Aug 2024 09:38:00 +1000
Subject: Fix discardable memory


diff --git a/chromium/base/memory/discardable_memory.cc b/chromium/base/memory/discardable_memory.cc
index 6ef3f1f..c77288d 100644
--- a/chromium/base/memory/discardable_memory.cc
+++ b/chromium/base/memory/discardable_memory.cc
@@ -23,7 +23,7 @@ const base::Feature kMadvFreeDiscardableMemory{
     "MadvFreeDiscardableMemory", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif  // defined(OS_POSIX)
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 const base::Feature kDiscardableMemoryBackingTrial{
     "DiscardableMemoryBackingTrial", base::FEATURE_DISABLED_BY_DEFAULT};
 
@@ -41,13 +41,13 @@ const base::FeatureParam<DiscardableMemoryTrialGroup>
         DiscardableMemoryTrialGroup::kEmulatedSharedMemory,
         &kDiscardableMemoryBackingParamOptions};
 
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 }  // namespace features
 
 namespace {
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 DiscardableMemoryBacking GetBackingForFieldTrial() {
   DiscardableMemoryTrialGroup trial_group =
@@ -61,11 +61,11 @@ DiscardableMemoryBacking GetBackingForFieldTrial() {
   }
   NOTREACHED();
 }
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 }  // namespace
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 // Probe capabilities of this device to determine whether we should participate
 // in the discardable memory backing trial.
@@ -87,18 +87,18 @@ DiscardableMemoryTrialGroup GetDiscardableMemoryBackingFieldTrialGroup() {
   DCHECK(DiscardableMemoryBackingFieldTrialIsEnabled());
   return features::kDiscardableMemoryBackingParam.Get();
 }
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 DiscardableMemory::DiscardableMemory() = default;
 
 DiscardableMemory::~DiscardableMemory() = default;
 
 DiscardableMemoryBacking GetDiscardableMemoryBacking() {
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
   if (DiscardableMemoryBackingFieldTrialIsEnabled()) {
     return GetBackingForFieldTrial();
   }
-#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 #if defined(OS_ANDROID)
   if (ashmem_device_is_supported())
diff --git a/chromium/base/memory/discardable_memory_internal.h b/chromium/base/memory/discardable_memory_internal.h
index eccf20b..79f1fff 100644
--- a/chromium/base/memory/discardable_memory_internal.h
+++ b/chromium/base/memory/discardable_memory_internal.h
@@ -10,7 +10,7 @@
 #include "base/metrics/field_trial_params.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_HAIKU)
 
 namespace base {
 
@@ -47,6 +47,6 @@ GetDiscardableMemoryBackingFieldTrialGroup();
 
 }  // namespace base
 
-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_HAIKU)
 
 #endif  //  BASE_MEMORY_DISCARDABLE_MEMORY_INTERNAL_H_
-- 
2.45.2


From d43deccd3aab89e32434581330c993b302471880 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=A9r=C3=B4me=20Duval?= <jerome.duval@gmail.com>
Date: Thu, 28 Nov 2024 15:10:12 +0100
Subject: fix build on Haiku x86_64


diff --git a/chromium/base/process/process_handle_haiku.cc b/chromium/base/process/process_handle_haiku.cc
index bc17cab..34eaf05 100644
--- a/chromium/base/process/process_handle_haiku.cc
+++ b/chromium/base/process/process_handle_haiku.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "base/logging.h"
+#include "base/notreached.h"
 #include "base/process/process_handle.h"
 
 #include "base/files/file_util.h"
diff --git a/chromium/base/process/process_iterator_haiku.cc b/chromium/base/process/process_iterator_haiku.cc
index 6d411ba..04906a4 100644
--- a/chromium/base/process/process_iterator_haiku.cc
+++ b/chromium/base/process/process_iterator_haiku.cc
@@ -4,6 +4,8 @@
 
 #include "base/process/process_iterator.h"
 
+#include "base/notreached.h"
+
 namespace base {
 
 ProcessIterator::ProcessIterator(const ProcessFilter* filter) {
diff --git a/chromium/base/process/process_metrics_haiku.cc b/chromium/base/process/process_metrics_haiku.cc
index 2a73cc1..bab8f67 100644
--- a/chromium/base/process/process_metrics_haiku.cc
+++ b/chromium/base/process/process_metrics_haiku.cc
@@ -4,6 +4,9 @@
 
 #include "base/process/process_metrics.h"
 
+#include "base/logging.h"
+#include "base/notreached.h"
+
 namespace base {
 
 size_t GetSystemCommitCharge() {
diff --git a/chromium/third_party/ffmpeg/BUILD.gn b/chromium/third_party/ffmpeg/BUILD.gn
index 4ebf9c2..79701d7 100644
--- a/chromium/third_party/ffmpeg/BUILD.gn
+++ b/chromium/third_party/ffmpeg/BUILD.gn
@@ -10,12 +10,17 @@ import("//build/config/compiler/compiler.gni")
 import("//build/config/sanitizers/sanitizers.gni")
 
 # Path to platform configuration files.
-platform_config_root =
-    "chromium/config/$ffmpeg_branding/$os_config/$ffmpeg_arch"
+if (!is_haiku) {
+    platform_config_root =
+        "chromium/config/$ffmpeg_branding/$os_config/$ffmpeg_arch"
+} else {
+    platform_config_root =
+        "chromium/config/$ffmpeg_branding/linux/$ffmpeg_arch"
+}
 
 has_nasm_deps =
     ffmpeg_asm_sources != [] &&
-    (current_cpu == "x86" || current_cpu == "x64") && os_config != "linux-noasm" && os_config != "haiku"
+    (current_cpu == "x86" || current_cpu == "x64") && os_config != "linux-noasm"
 if (has_nasm_deps) {
   import("//third_party/nasm/nasm_assemble.gni")
 
-- 
2.45.2

