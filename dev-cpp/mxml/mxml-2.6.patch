diff -Naur mxml-2.6/ANNOUNCEMENT mxml-2.6-haiku/ANNOUNCEMENT
--- mxml-2.6/ANNOUNCEMENT	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/ANNOUNCEMENT	2007-11-23 02:15:07.000000000 +0000
@@ -0,0 +1,7 @@
+Mini-XML 2.4 is now available for download from:
+
+    http://www.easysw.com/~mike/mxml/software.php
+
+Mini-XML 2.4 fixes some build and XML parsing bugs, adds support
+for the apos character entity, and adds per-thread global settings.
+
diff -Naur mxml-2.6/CHANGES mxml-2.6-haiku/CHANGES
--- mxml-2.6/CHANGES	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/CHANGES	2009-05-17 17:31:51.000000000 +0000
@@ -0,0 +1,323 @@
+CHANGES - 2009-05-17
+--------------------
+
+CHANGES IN Mini-XML 2.6
+
+	- Documentation fixes (STR #91, STR #92)
+	- The mxmldoc program did not handle typedef comments properly (STR #72)
+	- Added support for "long long" printf formats.
+	- The XML parser now ignores BOMs in UTF-8 XML files (STR #89)
+	- The mxmldoc program now supports generating Xcode documentation sets.
+	- mxmlSave*() did not output UTF-8 correctly on some platforms.
+	- mxmlNewXML() now adds encoding="utf-8" in the ?xml directive to avoid
+	  problems with non-conformant XML parsers that assume something other
+	  than UTF-8 as the default encoding.
+	- Wrapping was not disabled when mxmlSetWrapMargin(0) was called, and
+	  "<?xml ... ?>" was always followed by a newline (STR #76)
+	- The mxml.pc.in file was broken (STR #79)
+	- The mxmldoc program now handles "typedef enum name {} name" correctly
+	  (STR #72)
+
+
+CHANGES IN Mini-XML 2.5
+
+	- The mxmldoc program now makes greater use of CSS and
+	  supports a --css option to embed an alternate stylesheet.
+	- The mxmldoc program now supports --header and --footer
+	  options to insert documentation content before and
+	  after the generated content.
+	- The mxmldoc program now supports a --framed option to
+	  generate framed HTML output.
+	- The mxmldoc program now creates a table of contents
+	  including any headings in the --intro file when
+	  generating HTML output.
+	- The man pages and man page output from mxmldoc did
+	  not use "\-" for dashes (STR #68)
+	- The debug version of the Mini-XML DLL could not be
+	  built (STR #65)
+	- Processing instructions and directives did not work
+	  when not at the top level of a document (STR #67)
+	- Spaces around the "=" in attributes were not supported
+	  (STR #67)
+
+
+CHANGES IN Mini-XML 2.4
+
+	- Fixed shared library build problems on HP-UX and Mac OS X.
+	- The mxmldoc program did not output argument descriptions
+	  for functions properly.
+	- All global settings (custom, error, and entity callbacks
+	  and the wrap margin) are now managed separately for each
+	  thread.
+	- Added mxmlElementDeleteAttr() function (STR #59)
+	- mxmlElementSetAttrf() did not work (STR #57)
+	- mxmlLoad*() incorrectly treated declarations as parent
+	  elements (STR #56)
+	- mxmlLoad*() incorrectly allowed attributes without values
+	  (STR #47)
+	- Fixed Visual C++ build problems (STR #49)
+	- mxmlLoad*() did not return NULL when an element contained
+	  an error (STR #46)
+	- Added support for the apos character entity (STR #54)
+	- Fixed whitespace detection with Unicode characters (STR
+	  #48)
+	- mxmlWalkNext() and mxmlWalkPrev() did not work correctly
+	  when called with a node with no children as the top node
+	  (STR #53)
+
+
+CHANGES IN Mini-XML 2.3
+
+	- Added two exceptions to the LGPL to support static
+	  linking of applications against Mini-XML
+	- The mxmldoc utility can now generate man pages, too.
+	- Added a mxmlNewXML() function
+	- Added a mxmlElementSetAttrf() function (STR #43)
+	- Added snprintf() emulation function for test program (STR
+	  #32)
+	- Added the _CRT_SECURE_NO_DEPRECATE definition when
+	  building on VC++ 2005 (STR #36)
+	- mxmlLoad*() did not detect missing > characters in
+	  elements (STR #41)
+	- mxmlLoad*() did not detect missing close tags at the end
+	  of an XML document (STR #45)
+	- Added user_data and ref_count members to mxml_node_t
+	  structure
+	- Added mxmlReleaseNode() and mxmlRetainNode() APIs for
+	  reference-counted nodes
+	- Added mxmlSetWrapMargin() to control the wrapping of XML
+	  output
+	- Added conditional check for EINTR error code for
+	  certain Windows compilers that do not define it (STR
+	  #33)
+	- The mxmldoc program now generates correct HTML 4.0
+	  output - previously it generated invalid XHTML
+	- The mxmldoc program now supports "@deprecated@,
+	  "@private@", and "@since version@" comments
+	- Fixed function and enumeration type bugs in mxmldoc.
+	- Fixed the XML schema for mxmldoc
+	- The mxmldoc program now supports --intro, --section,
+	  and --title options
+	- The mxmlLoad*() functions could leak a node on an error
+	  (STR #27)
+	- The mxml_vsnprintf() function could get in an infinite
+	  loop on a buffer overflow (STR #25)
+	- Added new mxmlNewCDATA() and mxmlSetCDATA() functions
+	  to create and set CDATA nodes, which are really just
+	  special element nodes
+	- Added new MXML_IGNORE type and MXML_IGNORE_CB callback
+	  to ignore non-element nodes, e.g. whitespace
+	- mxmlLoad*() crashed when reporting an error in some
+	  invalid XML (STR #23)
+
+
+CHANGES IN Mini-XML 2.2.2
+
+	- mxmlLoad*() did not treat custom data as opaque, so
+	  whitespace characters would be lost.
+
+
+CHANGES IN Mini-XML 2.2.1
+
+	- mxmlLoadFd(), mxmlLoadFile(), and mxmlLoadString() now
+	  correctly return NULL on error (STR #21)
+	- mxmlNewInteger(), mxmlNewOpaque(), mxmlNewReal(),
+	  mxmlNewText(), and mxmlNewTextf() incorrectly required
+	  a parent node (STR #22)
+	- Fixed an XML output bug in mxmldoc.
+	- The "make install" target now uses the install command
+	  to set the proper permissions on UNIX/Linux/OSX.
+	- Fixed a MingW/Cygwin compilation problem (STR #18)
+
+
+CHANGES IN Mini-XML 2.2
+
+	- Added shared library support (STR #17)
+	- mxmlLoad*() now returns an error when an XML stream
+	  contains illegal control characters (STR #10)
+	- mxmlLoad*() now returns an error when an element
+	  contains two attributes with the same name in
+	  conformance with the XML spec (STR #16)
+	- Added support for CDATA (STR #14, STR #15)
+	- Updated comment and processing instruction handling -
+	  no entity support per XML specification.
+	- Added checking for invalid comment termination ("--->"
+	  is not allowed)
+
+
+CHANGES IN Mini-XML 2.1
+
+	- Added support for custom data nodes (STR #6)
+	- Now treat UTF-8 sequences which are longer than
+	  necessary as an error (STR #4)
+	- Fixed entity number support (STR #8)
+	- Fixed mxmlLoadString() bug with UTF-8 (STR #7)
+	- Fixed entity lookup bug (STR #5)
+	- Added mxmlLoadFd() and mxmlSaveFd() functions.
+	- Fixed multi-word UTF-16 handling.
+
+
+CHANGES IN Mini-XML 2.0
+
+	- New programmers manual.
+	- Added Visual C++ project files for Microsoft Windows
+	  users.
+	- Added optimizations to mxmldoc, mxmlSaveFile(), and
+	  mxmlIndexNew() (STR #2)
+	- mxmlEntityAddCallback() now returns an integer status
+	  (STR #2)
+	- Added UTF-16 support (input only; all output is UTF-8)
+	- Added index functions to build a searchable index of
+	  XML nodes.
+	- Added character entity callback interface to support
+	  additional character entities beyond those defined in
+	  the XHTML specification.
+	- Added support for XHTML character entities.
+	- The mxmldoc utility now produces XML output which
+	  conforms to an updated XML schema, described in the file
+	  "doc/mxmldoc.xsd".
+	- Changed the whitespace callback interface to return
+	  strings instead of a single character, allowing for
+	  greater control over the formatting of XML files
+	  written using Mini-XML.  THIS CHANGE WILL REQUIRE
+	  CHANGES TO YOUR 1.x CODE IF YOU USE WHITESPACE
+	  CALLBACKS.
+	- The mxmldoc utility is now capable of documenting C++
+	  classes, functions, and structures, and correctly
+	  handles C++ comments.
+	- Added new modular tests for mxmldoc.
+	- Updated the mxmldoc output to be more compatible with
+	  embedding in manuals produced with HTMLDOC.
+	- The makefile incorrectly included a "/" separator
+	  between the destination path and install path.  This
+	  caused problems when building and installing with
+	  MingW.
+
+
+CHANGES IN Mini-XML 1.3
+
+	- Fixes for mxmldoc.
+	- Added support for reading standard HTML entity names.
+	- mxmlLoadString/File() did not decode character
+	  entities in element names, attribute names, or
+	  attribute values.
+	- mxmlLoadString/File() would crash when loading non-
+	  conformant XML data under an existing parent (top)
+	  node.
+	- Fixed several bugs in the mxmldoc utility.
+	- Added new error callback function to catch a variety
+	  of errors and log them to someplace other than stderr.
+	- The mxmlElementSetAttr() function now allows for NULL
+	  attribute values.
+	- The load and save functions now properly handle quoted
+	  element and attribute name strings properly, e.g. for
+	  !DOCTYPE declarations.
+
+
+CHANGES IN Mini-XML 1.2
+
+	- Added new "set" methods to set the value of a node.
+	- Added new formatted text methods mxmlNewTextf() and
+	  mxmlSetTextf() to create/set a text node value using
+	  printf-style formats.
+	- Added new standard callbacks for use with the mxmlLoad
+	  functions.
+	- Updated the HTML documentation to include examples of
+	  the walk and load function output.
+	- Added --with/without-ansi configure option to control
+	  the strdup() function check.
+	- Added --with/without-snprintf configure option to
+	  control the snprintf() and vsnprintf() function
+	  checks.
+
+
+CHANGES IN Mini-XML 1.1.2
+
+	- The mxml(3) man page wasn't updated for the string
+	  functions.
+	- mxmlSaveString() returned the wrong number of
+	  characters.
+	- mxml_add_char() updated the buffer pointer in the
+	  wrong place.
+
+
+CHANGES IN Mini-XML 1.1.1
+
+	- The private mxml_add_ch() function did not update the
+	  start-of-buffer pointer which could cause a crash when
+	  using mxmlSaveString().
+	- The private mxml_write_ws() function called putc()
+	  instead of using the proper callback which could cause
+	  a crash when using mxmlSaveString().
+	- Added a mxmlSaveAllocString() convenience function for
+	  saving an XML node tree to an allocated string.
+
+
+CHANGES IN Mini-XML 1.1
+
+	- The mxmlLoadFile() function now uses dynamically
+	  allocated string buffers for element names, attribute
+	  names, and attribute values.  Previously they were
+	  capped at 16383, 255, and 255 bytes, respectively.
+	- Added a new mxmlLoadString() function for loading an
+	  XML node tree from a string.
+	- Added a new mxmlSaveString() function for saving an
+	  XML node tree to a string.
+	- Add emulation of strdup() if the local platform does
+	  not provide the function.
+
+
+CHANGES IN Mini-XML 1.0
+
+	- The mxmldoc program now handles function arguments,
+	  structures, unions, enumerations, classes, and
+	  typedefs properly.
+	- Documentation provided via mxmldoc and more in-line
+	  comments in the code.
+	- Added man pages and packaging files.
+
+
+CHANGES IN Mini-XML 0.93
+
+	- New mxmldoc example program that is also used to
+	  create and update code documentation using XML and
+	  produce HTML reference pages.
+	- Added mxmlAdd() and mxmlRemove() functions to add and
+	  remove nodes from a tree.  This provides more
+	  flexibility over where the nodes are inserted and
+	  allows nodes to be moved within the tree as needed.
+	- mxmlLoadFile() now correctly handles comments.
+	- mxmlLoadFile() now supports the required "gt", "quot",
+	  and "nbsp" character entities.
+	- mxmlSaveFile() now uses newlines as whitespace
+	  when valid to do so.
+	- mxmlFindElement() now also takes attribute name and
+	  attribute value string arguments to limit the search
+	  to specific elements with attributes and/or values.
+	  NULL pointers can be used as "wildcards".
+	- Added uninstall target to makefile, and auto-reconfig
+	  if Makefile.in or configure.in are changed.
+	- mxmlFindElement(), mxmlWalkNext(), and mxmlWalkPrev()
+	  now all provide "descend" arguments to control whether
+	  they descend into child nodes in the tree.
+	- Fixed some whitespace issues in mxmlLoadFile().
+	- Fixed Unicode output and whitespace issues in
+	  mxmlSaveFile().
+	- mxmlSaveFile() now supports a whitespace callback to
+	  provide more human-readable XML output under program
+	  control.
+
+
+CHANGES IN Mini-XML 0.92
+
+	- mxmlSaveFile() didn't return a value on success.
+
+
+CHANGES IN Mini-XML 0.91
+
+	- mxmlWalkNext() would go into an infinite loop.
+
+
+CHANGES IN Mini-XML 0.9
+
+	- Initial public release.
diff -Naur mxml-2.6/COPYING mxml-2.6-haiku/COPYING
--- mxml-2.6/COPYING	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/COPYING	2005-10-18 19:26:08.000000000 +0000
@@ -0,0 +1,507 @@
+			   Mini-XML License
+			   October 18, 2005
+
+
+The Mini-XML library and included programs are provided under the
+terms of the GNU Library General Public License (LGPL) with the
+following exceptions:
+
+    1. Static linking of applications to the Mini-XML library
+       does not constitute a derivative work and does not require
+       the author to provide source code for the application, use
+       the shared Mini-XML libraries, or link their applications
+       against a user-supplied version of Mini-XML.
+
+       If you link the application to a modified version of
+       Mini-XML, then the changes to Mini-XML must be provided
+       under the terms of the LGPL in sections 1, 2, and 4.
+
+    2. You do not have to provide a copy of the Mini-XML license
+       with programs that are linked to the Mini-XML library, nor
+       do you have to identify the Mini-XML license in your
+       program or documentation as required by section 6 of the
+       LGPL.
+
+
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+			 Version 2, June 1991
+
+	  Copyright (C) 1991 Free Software Foundation, Inc.
+       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+     Everyone is permitted to copy and distribute verbatim copies
+      of this license document, but changing it is not allowed.
+
+    [This is the first released version of the library GPL.  It is
+   numbered 2 because it goes with version 2 of the ordinary GPL.]
+
+			       Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Library General Public License, applies to some
+specially designated Free Software Foundation software, and to any
+other libraries whose authors decide to use it.  You can use it for
+your libraries, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if
+you distribute copies of the library, or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link a program with the library, you must provide
+complete object files to the recipients so that they can relink them
+with the library, after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  Our method of protecting your rights has two steps: (1) copyright
+the library, and (2) offer you this license which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  Also, for each distributor's protection, we want to make certain
+that everyone understands that there is no warranty for this free
+library.  If the library is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original
+version, so that any problems introduced by others will not reflect on
+the original authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that companies distributing free
+software will individually obtain patent licenses, thus in effect
+transforming the program into proprietary software.  To prevent this,
+we have made it clear that any patent must be licensed for everyone's
+free use or not licensed at all.
+
+  Most GNU software, including some libraries, is covered by the ordinary
+GNU General Public License, which was designed for utility programs.  This
+license, the GNU Library General Public License, applies to certain
+designated libraries.  This license is quite different from the ordinary
+one; be sure to read it in full, and don't assume that anything in it is
+the same as in the ordinary license.
+
+  The reason we have a separate public license for some libraries is that
+they blur the distinction we usually make between modifying or adding to a
+program and simply using it.  Linking a program with a library, without
+changing the library, is in some sense simply using the library, and is
+analogous to running a utility program or application program.  However, in
+a textual and legal sense, the linked executable is a combined work, a
+derivative of the original library, and the ordinary General Public License
+treats it as such.
+
+  Because of this blurred distinction, using the ordinary General
+Public License for libraries did not effectively promote software
+sharing, because most developers did not use the libraries.  We
+concluded that weaker conditions might promote sharing better.
+
+  However, unrestricted linking of non-free programs would deprive the
+users of those programs of all benefit from the free status of the
+libraries themselves.  This Library General Public License is intended to
+permit developers of non-free programs to use free libraries, while
+preserving your freedom as a user of such programs to change the free
+libraries that are incorporated in them.  (We have not seen how to achieve
+this as regards changes in header files, but we have achieved it as regards
+changes in the actual functions of the Library.)  The hope is that this
+will lead to faster development of free libraries.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, while the latter only
+works together with the library.
+
+  Note that it is possible for a library to be covered by the ordinary
+General Public License rather than by this special one.
+
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library which
+contains a notice placed by the copyright holder or other authorized
+party saying it may be distributed under the terms of this Library
+General Public License (also called "this License").  Each licensee is
+addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also compile or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    c) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    d) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the source code distributed need not include anything that is normally
+distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Library General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+     Appendix: How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
diff -Naur mxml-2.6/Makefile.in mxml-2.6-haiku/Makefile.in
--- mxml-2.6/Makefile.in	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/Makefile.in	2008-12-06 04:20:38.000000000 +0000
@@ -0,0 +1,380 @@
+#
+# "$Id: Makefile.in 370 2008-12-06 04:20:38Z mike $"
+#
+# Makefile for Mini-XML, a small XML-like file parsing library.
+#
+# Copyright 2003-2008 by Michael Sweet.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+
+#
+# Compiler tools definitions...
+#
+
+AR		=	@AR@
+ARFLAGS		=	@ARFLAGS@
+ARCHFLAGS	=	@ARCHFLAGS@
+CC		=	@CC@
+CFLAGS		=	$(OPTIM) $(ARCHFLAGS) @CFLAGS@ @CPPFLAGS@ @PTHREAD_FLAGS@
+CP		=	@CP@
+DSO		=	@DSO@
+DSOFLAGS	=	@DSOFLAGS@
+LDFLAGS		=	$(OPTIM) $(ARCHFLAGS) @LDFLAGS@
+INSTALL		=	@INSTALL@
+LIBMXML		=	@LIBMXML@
+LIBS		=	@LIBS@ @PTHREAD_LIBS@
+LN		=	@LN@ -s
+MKDIR		=	@MKDIR@
+OPTIM		=	@OPTIM@
+RANLIB		=	@RANLIB@
+RM		=	@RM@ -f
+SHELL		=	/bin/sh
+
+
+#
+# Configured directories...
+#
+
+prefix		=	@prefix@
+exec_prefix	=	@exec_prefix@
+bindir		=	@bindir@
+datarootdir	=	@datarootdir@
+includedir	=	@includedir@
+libdir		=	@libdir@
+mandir		=	@mandir@
+docdir		=	@docdir@
+BUILDROOT	=	$(DSTROOT)
+
+
+#
+# Install commands...
+#
+
+INSTALL_BIN	=	$(LIBTOOL) $(INSTALL) -m 755 -s
+INSTALL_DATA	=	$(INSTALL) -m 644
+INSTALL_DIR	=	$(INSTALL) -d
+INSTALL_LIB	=	$(LIBTOOL) $(INSTALL) -m 755
+INSTALL_MAN	=	$(INSTALL) -m 644
+INSTALL_SCRIPT	=	$(INSTALL) -m 755
+
+
+#
+# Rules...
+#
+
+.SUFFIXES:	.c .man .o
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+
+#
+# Targets...
+#
+
+DOCFILES	=	doc/0.gif doc/1.gif doc/2.gif doc/3.gif doc/4.gif \
+			doc/A.gif doc/B.gif doc/C.gif doc/D.gif \
+			doc/mxml.html doc/mxmldoc.xsd \
+			README COPYING CHANGES
+PUBLIBOBJS	=	mxml-attr.o mxml-entity.o mxml-file.o mxml-index.o \
+			mxml-node.o mxml-search.o mxml-set.o
+LIBOBJS		=	$(PUBLIBOBJS) mxml-private.o mxml-string.o
+OBJS		=	mxmldoc.o testmxml.o $(LIBOBJS)
+TARGETS		=	$(LIBMXML) mxmldoc testmxml mxml.xml doc/mxml.man
+
+
+#
+# Make everything...
+#
+
+all:		Makefile config.h $(TARGETS)
+
+
+#
+# Clean everything...
+#
+
+clean:
+	$(RM) $(OBJS) $(TARGETS)
+	$(RM) mxmldoc-static libmxml.a
+
+
+#
+# Really clean everything...
+#
+
+distclean:	clean
+	$(RM) config.cache config.log config.status
+	$(RM) Makefile config.h
+	$(RM) -r autom4te*.cache
+	$(RM) *.bck *.bak
+	$(RM) -r clang
+
+
+#
+# Run the clang.llvm.org static code analysis tool on the C sources.
+#
+
+.PHONY: clang
+clang:
+	$(RM) -r clang
+	scan-build -k -V -o `pwd`/clang $(MAKE) $(MFLAGS) CC=ccc-analyzer clean all
+
+
+#
+# Install everything...
+#
+
+install:	$(TARGETS) install-$(LIBMXML) install-libmxml.a
+	$(INSTALL_DIR) $(BUILDROOT)$(bindir)
+	$(INSTALL_BIN) mxmldoc $(BUILDROOT)$(bindir) 
+	$(INSTALL_DIR) $(BUILDROOT)$(docdir)
+	for file in $(DOCFILES); do \
+		$(INSTALL_MAN) $$file $(BUILDROOT)$(docdir); \
+	done
+	$(INSTALL_DIR) $(BUILDROOT)$(includedir)
+	$(INSTALL_DATA) mxml.h $(BUILDROOT)$(includedir)
+	$(INSTALL_DIR) $(BUILDROOT)$(libdir)/pkgconfig
+	$(INSTALL_DATA) mxml.pc $(BUILDROOT)$(libdir)/pkgconfig
+	$(INSTALL_DIR) $(BUILDROOT)$(mandir)/man1
+	$(INSTALL_MAN) doc/mxmldoc.man $(BUILDROOT)$(mandir)/man1/mxmldoc.1
+	$(INSTALL_DIR) $(BUILDROOT)$(mandir)/man3
+	$(INSTALL_MAN) doc/mxml.man $(BUILDROOT)$(mandir)/man3/mxml.3
+
+install-libmxml.a:
+	$(INSTALL_DIR) $(BUILDROOT)$(libdir)
+	$(INSTALL_LIB) libmxml.a $(BUILDROOT)$(libdir)
+	$(RANLIB) $(BUILDROOT)$(libdir)/libmxml.a
+
+install-libmxml.so.1.4:
+	$(INSTALL_DIR) $(BUILDROOT)$(libdir)
+	$(INSTALL_LIB) libmxml.so.1.4 $(BUILDROOT)$(libdir)
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.so
+	$(LN) libmxml.so.1.4 $(BUILDROOT)$(libdir)/libmxml.so
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.so.1
+	$(LN) libmxml.so.1.4 $(BUILDROOT)$(libdir)/libmxml.so.1
+
+install-libmxml.sl.1:
+	$(INSTALL_DIR) $(BUILDROOT)$(libdir)
+	$(INSTALL_LIB) libmxml.sl.1 $(BUILDROOT)$(libdir)
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.so
+	$(LN) libmxml.sl.1 $(BUILDROOT)$(libdir)/libmxml.sl
+
+install-libmxml.1.dylib:
+	$(INSTALL_DIR) $(BUILDROOT)$(libdir)
+	$(INSTALL_LIB) libmxml.1.dylib $(BUILDROOT)$(libdir)
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.dylib
+	$(LN) libmxml.1.dylib $(BUILDROOT)$(libdir)/libmxml.dylib
+
+
+#
+# Uninstall everything...
+#
+
+uninstall: uninstall-$(LIBMXML) uninstall-libmxml.a
+	$(RM) $(BUILDROOT)$(bindir)/mxmldoc
+	$(RM) -r $(BUILDROOT)$(docdir)
+	$(RM) $(BUILDROOT)$(includedir)/mxml.h
+	$(RM) $(BUILDROOT)$(libdir)/pkgconfig/mxml.pc
+	$(RM) $(BUILDROOT)$(mandir)/man1/mxmldoc.1
+	$(RM) $(BUILDROOT)$(mandir)/man3/mxml.3
+
+uninstall-libmxml.a:
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.a
+
+uninstall-libmxml.so.1.4:
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.so
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.so.1
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.so.1.4
+
+uninstall-libmxml.sl.1:
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.sl
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.sl.1
+
+uninstall-libmxml.1.dylib:
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.dylib
+	$(RM) $(BUILDROOT)$(libdir)/libmxml.1.dylib
+
+
+#
+# Make packages using EPM (http://www.easysw.com/epm/)
+#
+
+epm:	all
+	epm --output-dir dist -v -f native mxml
+	epm --output-dir dist -v -f portable mxml
+
+
+#
+# autoconf stuff...
+#
+
+Makefile:	configure Makefile.in
+	if test -f config.status; then \
+		./config.status --recheck; \
+		./config.status; \
+	else \
+		./configure; \
+	fi
+	touch config.h
+
+
+config.h:	configure config.h.in
+	autoconf
+	if test -f config.status; then \
+		./config.status --recheck; \
+		./config.status; \
+	else \
+		./configure; \
+	fi
+	touch config.h
+
+
+#
+# libmxml.a
+#
+
+libmxml.a:	$(LIBOBJS)
+	$(RM) $@
+	$(AR) $(ARFLAGS) $@ $(LIBOBJS)
+	$(RANLIB) $@
+
+$(LIBOBJS):	mxml.h
+mxml-entity.o mxml-file.o mxml-private.o: mxml-private.h
+
+
+#
+# libmxml.so.1.4
+#
+
+libmxml.so.1.4:	$(LIBOBJS)
+	$(DSO) $(DSOFLAGS) -o libmxml.so.1.4 $(LIBOBJS)
+	$(RM) libmxml.so libmxml.so.1
+	$(LN) libmxml.so.1.4 libmxml.so
+	$(LN) libmxml.so.1.4 libmxml.so.1
+
+
+#
+# libmxml.sl.1
+#
+
+libmxml.sl.1:	$(LIBOBJS)
+	$(DSO) $(DSOFLAGS) -o libmxml.sl.1 $(LIBOBJS)
+	$(RM) libmxml.sl
+	$(LN) libmxml.sl.1 libmxml.sl
+
+
+#
+# libmxml.1.dylib
+#
+
+libmxml.1.dylib:	$(LIBOBJS)
+	$(DSO) $(DSOFLAGS) -o libmxml.1.dylib \
+		-install_name $(libdir)/libmxml.dylib \
+		-current_version 1.4.0 \
+		-compatibility_version 1.0.0 \
+		$(LIBOBJS)
+	$(RM) libmxml.dylib
+	$(LN) libmxml.1.dylib libmxml.dylib
+
+
+#
+# mxmldoc
+#
+
+mxmldoc:	$(LIBMXML) mxmldoc.o
+	$(CC) -L. $(LDFLAGS) -o $@ mxmldoc.o -lmxml $(LIBS)
+
+mxmldoc-static:	libmxml.a mxmldoc.o
+	$(CC) $(LDFLAGS) -o $@ mxmldoc.o libmxml.a $(LIBS)
+
+mxmldoc.o:	mxml.h
+
+
+#
+# testmxml
+#
+
+testmxml:	libmxml.a testmxml.o
+	$(CC) $(LDFLAGS) -o $@ testmxml.o libmxml.a $(LIBS)
+	@echo Testing library...
+	./testmxml test.xml >temp1.xml 2>temp1s.xml
+	./testmxml temp1.xml >temp2.xml 2>temp2s.xml
+	@if cmp temp1.xml temp2.xml; then \
+		echo Stdio file test passed!; \
+		$(RM) temp2.xml temp2s.xml; \
+	else \
+		echo Stdio file test failed!; \
+	fi
+	@if cmp temp1.xml temp1s.xml; then \
+		echo String test passed!; \
+		$(RM) temp1.xml temp1s.xml; \
+	else \
+		echo String test failed!; \
+	fi
+	@if cmp test.xml test.xmlfd; then \
+		echo File descriptor test passed!; \
+		$(RM) test.xmlfd; \
+	else \
+		echo File descriptor test failed!; \
+	fi
+
+testmxml.o:	mxml.h
+
+
+#
+# mxml.xml
+#
+
+mxml.xml:	mxmldoc-static mxml.h $(PUBLIBOBJS:.o=.c)
+	$(RM) mxml.xml
+	./mxmldoc-static --header doc/reference.heading mxml.xml mxml.h $(PUBLIBOBJS:.o=.c) >doc/reference.html
+	if test "x`uname`" = xDarwin; then \
+		./mxmldoc-static --docset org.minixml.docset \
+			--docversion @VERSION@ --feedname minixml.org \
+			--feedurl http://www.minixml.org/org.minixml.atom \
+			--header doc/docset.header --intro doc/docset.intro \
+			--css doc/docset.css --title "Mini-XML API Reference" \
+			mxml.xml || exit 1; \
+		/Developer/usr/bin/docsetutil package --output org.minixml.xar \
+			--atom org.minixml.atom \
+			--download-url http://www.minixml.org/org.minixml.xar \
+			org.minixml.docset || exit 1; \
+	fi
+
+valgrind:	mxmldoc-static
+	$(RM) valgrind.xml
+	valgrind --tool=memcheck --leak-check=yes ./mxmldoc-static \
+		valgrind.xml mxml.h $(PUBLIBOBJS:.o=.c) \
+		>valgrind.html 2>valgrind.out
+
+
+#
+# doc/mxml.man
+#
+
+doc/mxml.man: mxmldoc-static mxml.xml
+	$(RM) doc/mxml.man
+	./mxmldoc-static --man mxml --title "Mini-XML API" \
+		--intro doc/intro.man --footer doc/footer.man \
+		mxml.xml >doc/mxml.man
+
+
+#
+# All object files depend on the makefile...
+#
+
+$(OBJS):	Makefile config.h
+
+
+#
+# End of "$Id: Makefile.in 370 2008-12-06 04:20:38Z mike $".
+#
diff -Naur mxml-2.6/README mxml-2.6-haiku/README
--- mxml-2.6/README	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/README	2009-05-17 17:17:46.000000000 +0000
@@ -0,0 +1,177 @@
+README - 2009-05-17
+-------------------
+
+
+INTRODUCTION
+
+    This README file describes the Mini-XML library version 2.6.
+
+    Mini-XML is a small XML parsing library that you can use to read XML and
+    XML-like data files in your application without requiring large non-standard
+    libraries.  Mini-XML only requires an ANSI C compatible compiler (GCC works,
+    as do most vendors' ANSI C compilers) and a "make" program.
+
+    Mini-XML provides the following functionality:
+
+	- Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files and
+	  strings.
+	- Data is stored in a linked-list tree structure, preserving the XML
+	  data hierarchy.
+	- Supports arbitrary element names, attributes, and attribute values
+	  with no preset limits, just available memory.
+	- Supports integer, real, opaque ("cdata"), and text data types in
+	  "leaf" nodes.
+	- Functions for creating and managing trees of data.
+	- "Find" and "walk" functions for easily locating and navigating trees
+	  of data.
+
+    Mini-XML doesn't do validation or other types of processing on the data
+    based upon schema files or other sources of definition information.
+
+
+BUILDING Mini-XML
+
+    Mini-XML comes with an autoconf-based configure script; just type the
+    following command to get things going:
+
+        ./configure
+
+    The default install prefix is /usr/local, which can be overridden using the
+    --prefix option:
+
+        ./configure --prefix=/foo
+
+    Other configure options can be found using the --help option:
+
+        ./configure --help
+
+    Once you have configured the software, type "make" to do the build and run
+    the test program to verify that things are working, as follows:
+
+        make
+
+    If you are using Mini-XML under Microsoft Windows with Visual C++ 2008, use
+    the included project files in the "vcnet" subdirectory to build the library
+    instead.
+
+
+INSTALLING Mini-XML
+
+    The "install" target will install Mini-XML in the lib and include
+    directories:
+
+        make install
+
+    Once you have installed it, use the "-lmxml" option to link your application
+    against it.
+
+
+DOCUMENTATION
+
+    The documentation is available in the "doc" subdirectory in the files
+    "mxml.html" (HTML) and "mxml.pdf" (PDF). You can also look at the
+    "testmxml.c" and "mxmldoc.c" source files for examples of using Mini-XML.
+
+    Mini-XML provides a single header file which you include:
+
+        #include <mxml.h>
+
+    Nodes are defined by the "mxml_node_t" structure; the "type" member defines
+    the node type (element, integer, opaque, real, or text) which determines
+    which value you want to look at in the "value" union.  New nodes can be
+    created using the "mxmlNewElement()", "mxmlNewInteger()", "mxmlNewOpaque()",
+    "mxmlNewReal()", and "mxmlNewText()" functions.  Only elements can have
+    child nodes, and the top node must be an element, usually "?xml".
+
+    You load an XML file using the "mxmlLoadFile()" function:
+
+        FILE *fp;
+        mxml_node_t *tree;
+
+	fp = fopen("filename.xml", "r");
+	tree = mxmlLoadFile(NULL, fp, MXML_NO_CALLBACK);
+	fclose(fp);
+
+    Similarly, you save an XML file using the "mxmlSaveFile()" function:
+
+        FILE *fp;
+        mxml_node_t *tree;
+
+	fp = fopen("filename.xml", "w");
+	mxmlSaveFile(tree, fp, MXML_NO_CALLBACK);
+	fclose(fp);
+
+    The "mxmlLoadString()", "mxmlSaveAllocString()", and "mxmlSaveString()"
+    functions load XML node trees from and save XML node trees to strings:
+
+        char buffer[8192];
+	char *ptr;
+	mxml_node_t *tree;
+
+        ...
+	tree = mxmlLoadString(NULL, buffer, MXML_NO_CALLBACK);
+
+        ...
+        mxmlSaveString(tree, buffer, sizeof(buffer), MXML_NO_CALLBACK);
+
+        ...
+	ptr = mxmlSaveAllocString(tree, MXML_NO_CALLBACK);
+
+    You can find a named element/node using the "mxmlFindElement()" function:
+
+        mxml_node_t *node = mxmlFindElement(tree, tree, "name", "attr",
+	                                    "value", MXML_DESCEND);
+
+    The "name", "attr", and "value" arguments can be passed as NULL to act as
+    wildcards, e.g.:
+
+        /* Find the first "a" element */
+        node = mxmlFindElement(tree, tree, "a", NULL, NULL, MXML_DESCEND);
+
+        /* Find the first "a" element with "href" attribute */
+        node = mxmlFindElement(tree, tree, "a", "href", NULL, MXML_DESCEND);
+
+        /* Find the first "a" element with "href" to a URL */
+        node = mxmlFindElement(tree, tree, "a", "href",
+	                       "http://www.easysw.com/~mike/mxml/",
+			       MXML_DESCEND);
+
+        /* Find the first element with a "src" attribute*/
+        node = mxmlFindElement(tree, tree, NULL, "src", NULL, MXML_DESCEND);
+
+        /* Find the first element with a "src" = "foo.jpg" */
+        node = mxmlFindElement(tree, tree, NULL, "src", "foo.jpg",
+	                       MXML_DESCEND);
+
+    You can also iterate with the same function:
+
+        mxml_node_t *node;
+
+	for (node = mxmlFindElement(tree, tree, "name", NULL, NULL,
+	                            MXML_DESCEND);
+	     node != NULL;
+	     node = mxmlFindElement(node, tree, "name", NULL, NULL,
+	                            MXML_DESCEND))
+        {
+	  ... do something ...
+	}
+
+    Finally, once you are done with the XML data, use the "mxmlDelete()"
+    function to recursively free the memory that is used for a particular node
+    or the entire tree:
+
+        mxmlDelete(tree);
+
+
+GETTING HELP AND REPORTING PROBLEMS
+
+    The Mini-XML web site provides access to a discussion forum and bug
+    reporting page:
+
+        http://www.minixml.org/
+
+
+LEGAL STUFF
+
+    The Mini-XML library is Copyright 2003-2009 by Michael Sweet.  License terms
+    are described in the file "COPYING".
diff -Naur mxml-2.6/config.h.in mxml-2.6-haiku/config.h.in
--- mxml-2.6/config.h.in	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/config.h.in	2009-04-18 17:05:52.000000000 +0000
@@ -0,0 +1,97 @@
+/*
+ * "$Id: config.h.in 387 2009-04-18 17:05:52Z mike $"
+ *
+ * Configuration file for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2009 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <ctype.h>
+
+
+/*
+ * Version number...
+ */
+
+#define MXML_VERSION	""
+
+
+/*
+ * Inline function support...
+ */
+
+#define inline
+
+
+/*
+ * Long long support...
+ */
+
+#undef HAVE_LONG_LONG
+
+
+/*
+ * Do we have the snprintf() and vsnprintf() functions?
+ */
+
+#undef HAVE_SNPRINTF
+#undef HAVE_VSNPRINTF
+
+
+/*
+ * Do we have the strXXX() functions?
+ */
+
+#undef HAVE_STRDUP
+
+
+/*
+ * Do we have threading support?
+ */
+
+#undef HAVE_PTHREAD_H
+
+
+/*
+ * Define prototypes for string functions as needed...
+ */
+
+#  ifndef HAVE_STRDUP
+extern char	*_mxml_strdup(const char *);
+#    define strdup _mxml_strdup
+#  endif /* !HAVE_STRDUP */
+
+extern char	*_mxml_strdupf(const char *, ...);
+extern char	*_mxml_vstrdupf(const char *, va_list);
+
+#  ifndef HAVE_SNPRINTF
+extern int	_mxml_snprintf(char *, size_t, const char *, ...);
+#    define snprintf _mxml_snprintf
+#  endif /* !HAVE_SNPRINTF */
+
+#  ifndef HAVE_VSNPRINTF
+extern int	_mxml_vsnprintf(char *, size_t, const char *, va_list);
+#    define vsnprintf _mxml_vsnprintf
+#  endif /* !HAVE_VSNPRINTF */
+
+/*
+ * End of "$Id: config.h.in 387 2009-04-18 17:05:52Z mike $".
+ */
diff -Naur mxml-2.6/configure mxml-2.6-haiku/configure
--- mxml-2.6/configure	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/configure	2009-04-18 17:05:52.000000000 +0000
@@ -0,0 +1,5974 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.61.
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+as_nl='
+'
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+if test "x$CONFIG_SHELL" = x; then
+  if (eval ":") 2>/dev/null; then
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+
+  if test $as_have_required = yes && 	 (eval ":
+(as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=\$LINENO
+  as_lineno_2=\$LINENO
+  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
+  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
+") 2> /dev/null; then
+  :
+else
+  as_candidate_shells=
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  case $as_dir in
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
+	   done;;
+       esac
+done
+IFS=$as_save_IFS
+
+
+      for as_shell in $as_candidate_shells $SHELL; do
+	 # Try only shells that exist, to save several forks.
+	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		{ ("$as_shell") 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+_ASEOF
+}; then
+  CONFIG_SHELL=$as_shell
+	       as_have_required=yes
+	       if { "$as_shell" 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+(as_func_return () {
+  (exit $1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = "$1" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test $exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
+
+_ASEOF
+}; then
+  break
+fi
+
+fi
+
+      done
+
+      if test "x$CONFIG_SHELL" != x; then
+  for as_var in BASH_ENV ENV
+        do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+        done
+        export CONFIG_SHELL
+        exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+
+    if test $as_have_required = no; then
+  echo This script requires a shell more modern than all the
+      echo shells that I found on your system.  Please install a
+      echo modern shell, or manually run the script under such a
+      echo shell if you do have one.
+      { (exit 1); exit 1; }
+fi
+
+
+fi
+
+fi
+
+
+
+(eval "as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0") || {
+  echo No shell found that supports shell functions.
+  echo Please tell autoconf@gnu.org about your system,
+  echo including any error possibly output before this
+  echo message
+}
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir
+fi
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s='ln -s'
+  # ... but there are two gotchas:
+  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+  # In both cases, we have to default to `cp -p'.
+  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+    as_ln_s='cp -p'
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+        test -d "$1/.";
+      else
+	case $1 in
+        -*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+
+exec 7<&0 </dev/null 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="mxml.h"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL
+PATH_SEPARATOR
+PACKAGE_NAME
+PACKAGE_TARNAME
+PACKAGE_VERSION
+PACKAGE_STRING
+PACKAGE_BUGREPORT
+exec_prefix
+prefix
+program_transform_name
+bindir
+sbindir
+libexecdir
+datarootdir
+datadir
+sysconfdir
+sharedstatedir
+localstatedir
+includedir
+oldincludedir
+docdir
+infodir
+htmldir
+dvidir
+pdfdir
+psdir
+libdir
+localedir
+mandir
+DEFS
+ECHO_C
+ECHO_N
+ECHO_T
+LIBS
+build_alias
+host_alias
+target_alias
+VERSION
+LDFLAGS
+OPTIM
+ARCHFLAGS
+CC
+CFLAGS
+CPPFLAGS
+ac_ct_CC
+EXEEXT
+OBJEXT
+CXX
+CXXFLAGS
+ac_ct_CXX
+INSTALL_PROGRAM
+INSTALL_SCRIPT
+INSTALL_DATA
+RANLIB
+AR
+CP
+LN
+MKDIR
+RM
+ARFLAGS
+CPP
+GREP
+EGREP
+PTHREAD_FLAGS
+PTHREAD_LIBS
+DSO
+DSOFLAGS
+LIBMXML
+PICFLAG
+PC_CFLAGS
+PC_LIBS
+LIBOBJS
+LTLIBOBJS'
+ac_subst_files=''
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CXX
+CXXFLAGS
+CCC
+CPP'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
+    eval enable_$ac_feature=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
+    eval enable_$ac_feature=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
+    eval with_$ac_package=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
+    eval with_$ac_package=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute directory names.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; }
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  { echo "$as_me: error: Working directory cannot be determined" >&2
+   { (exit 1); exit 1; }; }
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  { echo "$as_me: error: pwd does not report name of working directory" >&2
+   { (exit 1); exit 1; }; }
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$0" ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || { echo "$as_me: error: $ac_msg" >&2
+   { (exit 1); exit 1; }; }
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --datarootdir=DIR      read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR          read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR          info documentation [DATAROOTDIR/info]
+  --localedir=DIR        locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR           man documentation [DATAROOTDIR/man]
+  --docdir=DIR           documentation root [DATAROOTDIR/doc/PACKAGE]
+  --htmldir=DIR          html documentation [DOCDIR]
+  --dvidir=DIR           dvi documentation [DOCDIR]
+  --pdfdir=DIR           pdf documentation [DOCDIR]
+  --psdir=DIR            ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-debug          turn on debugging, default=no
+  --enable-threads        enable multi-threading support
+  --enable-shared         turn on shared libraries, default=no
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-ansi             set full ANSI C mode, default=no
+  --with-archflags        set additional architecture flags, default=none
+  --with-docdir           set directory for documentation, default=${prefix}/share/doc/mxml
+  --with-vsnprintf        use vsnprintf emulation functions, default=auto
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" || continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+configure
+generated by GNU Autoconf 2.61
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args '$ac_arg'"
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
+echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------------- ##
+## File substitutions. ##
+## ------------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -n "$CONFIG_SITE"; then
+  set x "$CONFIG_SITE"
+elif test "x$prefix" != xNONE; then
+  set x "$prefix/share/config.site" "$prefix/etc/config.site"
+else
+  set x "$ac_default_prefix/share/config.site" \
+	"$ac_default_prefix/etc/config.site"
+fi
+shift
+for ac_site_file
+do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+ac_config_headers="$ac_config_headers config.h"
+
+
+VERSION=2.6
+
+cat >>confdefs.h <<_ACEOF
+#define MXML_VERSION "Mini-XML v$VERSION"
+_ACEOF
+
+
+CFLAGS="${CFLAGS:=}"
+CXXFLAGS="${CXXFLAGS:=}"
+LDFLAGS="${LDFLAGS:=}"
+
+OPTIM=""
+
+
+
+# Check whether --with-ansi was given.
+if test "${with_ansi+set}" = set; then
+  withval=$with_ansi; use_ansi="$withval"
+else
+  use_ansi="no"
+fi
+
+
+
+# Check whether --with-archflags was given.
+if test "${with_archflags+set}" = set; then
+  withval=$with_archflags; ARCHFLAGS="$withval"
+else
+  ARCHFLAGS=""
+fi
+
+
+
+# Check whether --enable-debug was given.
+if test "${enable_debug+set}" = set; then
+  enableval=$enable_debug; if eval "test x$enable_debug = xyes"; then
+ 	OPTIM="-g"
+fi
+fi
+
+
+
+# Check whether --with-docdir was given.
+if test "${with_docdir+set}" = set; then
+  withval=$with_docdir; docdir="$withval"
+else
+  docdir="NONE"
+fi
+
+
+
+
+
+# Check whether --with-vsnprintf was given.
+if test "${with_vsnprintf+set}" = set; then
+  withval=$with_vsnprintf; use_vsnprintf="$withval"
+else
+  use_vsnprintf="no"
+fi
+
+
+uname=`uname`
+uversion=`uname -r | sed -e '1,$s/[^0-9]//g'`
+if test x$uname = xIRIX64; then
+	uname="IRIX"
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO: checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6; }
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+#
+# List of possible output files, starting from the most likely.
+# The algorithm is not robust to junk in `.', hence go to wildcards (a.*)
+# only as a last resort.  b.out is created by i960 compilers.
+ac_files='a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out'
+#
+# The IRIX 6 linker writes into existing files which may not be
+# executable, retaining their permissions.  Remove them first so a
+# subsequent execution test works.
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { (ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+
+{ echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6; }
+if test -z "$ac_file"; then
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6; }
+{ echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6; }
+
+{ echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6; }
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+{ echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+{ echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6; }
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6; }
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+echo $ECHO_N "checking for $CC option to accept ISO C89... $ECHO_C" >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_c89=$ac_arg
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6; } ;;
+  xno)
+    { echo "$as_me:$LINENO: result: unsupported" >&5
+echo "${ECHO_T}unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CXX+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { echo "$as_me:$LINENO: result: $CXX" >&5
+echo "${ECHO_T}$CXX" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_CXX" >&5
+echo "${ECHO_T}$ac_ct_CXX" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CXX" && break
+done
+
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    CXX=$ac_ct_CXX
+  fi
+fi
+
+  fi
+fi
+# Provide some information about the compiler.
+echo "$as_me:$LINENO: checking for C++ compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+{ echo "$as_me:$LINENO: checking whether we are using the GNU C++ compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C++ compiler... $ECHO_C" >&6; }
+if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_cxx_compiler_gnu" >&6; }
+GXX=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ echo "$as_me:$LINENO: checking whether $CXX accepts -g" >&5
+echo $ECHO_N "checking whether $CXX accepts -g... $ECHO_C" >&6; }
+if test "${ac_cv_prog_cxx_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CXXFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cxx_g" >&6; }
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
+echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+IFS=$as_save_IFS
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+if test "$INSTALL" = "$ac_install_sh"; then
+	# Use full path to install-sh script...
+	INSTALL="`pwd`/install-sh -c"
+fi
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+# Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_path_AR+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $AR in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_AR="$AR" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_AR="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+AR=$ac_cv_path_AR
+if test -n "$AR"; then
+  { echo "$as_me:$LINENO: result: $AR" >&5
+echo "${ECHO_T}$AR" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+# Extract the first word of "cp", so it can be a program name with args.
+set dummy cp; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_path_CP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $CP in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_CP="$CP" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_CP="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+CP=$ac_cv_path_CP
+if test -n "$CP"; then
+  { echo "$as_me:$LINENO: result: $CP" >&5
+echo "${ECHO_T}$CP" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+# Extract the first word of "ln", so it can be a program name with args.
+set dummy ln; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_path_LN+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $LN in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_LN="$LN" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_LN="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+LN=$ac_cv_path_LN
+if test -n "$LN"; then
+  { echo "$as_me:$LINENO: result: $LN" >&5
+echo "${ECHO_T}$LN" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+# Extract the first word of "mkdir", so it can be a program name with args.
+set dummy mkdir; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_path_MKDIR+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $MKDIR in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_MKDIR="$MKDIR" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_MKDIR="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+MKDIR=$ac_cv_path_MKDIR
+if test -n "$MKDIR"; then
+  { echo "$as_me:$LINENO: result: $MKDIR" >&5
+echo "${ECHO_T}$MKDIR" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+# Extract the first word of "rm", so it can be a program name with args.
+set dummy rm; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_path_RM+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $RM in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_RM="$RM" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_RM="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+RM=$ac_cv_path_RM
+if test -n "$RM"; then
+  { echo "$as_me:$LINENO: result: $RM" >&5
+echo "${ECHO_T}$RM" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+
+case "$uname" in
+        Darwin* | *BSD*)
+                ARFLAGS="-rcv"
+                ;;
+        *)
+                ARFLAGS="crvs"
+                ;;
+esac
+
+
+
+
+{ echo "$as_me:$LINENO: checking for inline" >&5
+echo $ECHO_N "checking for inline... $ECHO_C" >&6; }
+if test "${ac_cv_c_inline+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_inline=$ac_kw
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  test "$ac_cv_c_inline" != no && break
+done
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+echo "${ECHO_T}$ac_cv_c_inline" >&6; }
+
+
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
+
+
+if test "x$use_ansi" != xyes; then
+
+for ac_func in strdup
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_var'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+fi
+
+if test "x$use_vsnprintf" != xyes; then
+
+
+for ac_func in snprintf vsnprintf
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_var'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+fi
+
+{ echo "$as_me:$LINENO: checking for long long int" >&5
+echo $ECHO_N "checking for long long int... $ECHO_C" >&6; }
+if test "${ac_cv_c_long_long+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$GCC" = yes; then
+		ac_cv_c_long_long=yes
+	else
+		cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+long long int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_long_long=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_c_long_long=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+	fi
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_c_long_long" >&5
+echo "${ECHO_T}$ac_cv_c_long_long" >&6; }
+
+if test $ac_cv_c_long_long = yes; then
+	cat >>confdefs.h <<\_ACEOF
+#define HAVE_LONG_LONG 1
+_ACEOF
+
+fi
+
+# Check whether --enable-threads was given.
+if test "${enable_threads+set}" = set; then
+  enableval=$enable_threads;
+fi
+
+
+have_pthread=no
+PTHREAD_FLAGS=""
+PTHREAD_LIBS=""
+
+if test "x$enable_threads" != xno; then
+	ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
+echo $ECHO_N "checking for grep that handles long lines and -e... $ECHO_C" >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # Extract the first word of "grep ggrep" to use in msg output
+if test -z "$GREP"; then
+set dummy grep ggrep; ac_prog_name=$2
+if test "${ac_cv_path_GREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_path_GREP_found=false
+# Loop through the user's path and test for each of PROGNAME-LIST
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in grep ggrep; do
+  for ac_exec_ext in '' $ac_executable_extensions; do
+    ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+    { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+    # Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+
+    $ac_path_GREP_found && break 3
+  done
+done
+
+done
+IFS=$as_save_IFS
+
+
+fi
+
+GREP="$ac_cv_path_GREP"
+if test -z "$GREP"; then
+  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
+echo "${ECHO_T}$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     # Extract the first word of "egrep" to use in msg output
+if test -z "$EGREP"; then
+set dummy egrep; ac_prog_name=$2
+if test "${ac_cv_path_EGREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_path_EGREP_found=false
+# Loop through the user's path and test for each of PROGNAME-LIST
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in egrep; do
+  for ac_exec_ext in '' $ac_executable_extensions; do
+    ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+    { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+    # Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+
+    $ac_path_EGREP_found && break 3
+  done
+done
+
+done
+IFS=$as_save_IFS
+
+
+fi
+
+EGREP="$ac_cv_path_EGREP"
+if test -z "$EGREP"; then
+  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+
+   fi
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
+echo "${ECHO_T}$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_stdc=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+if test "${ac_cv_header_pthread_h+set}" = set; then
+  { echo "$as_me:$LINENO: checking for pthread.h" >&5
+echo $ECHO_N "checking for pthread.h... $ECHO_C" >&6; }
+if test "${ac_cv_header_pthread_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_header_pthread_h" >&5
+echo "${ECHO_T}$ac_cv_header_pthread_h" >&6; }
+else
+  # Is the header compilable?
+{ echo "$as_me:$LINENO: checking pthread.h usability" >&5
+echo $ECHO_N "checking pthread.h usability... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <pthread.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ echo "$as_me:$LINENO: checking pthread.h presence" >&5
+echo $ECHO_N "checking pthread.h presence... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <pthread.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: pthread.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: pthread.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pthread.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: pthread.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: pthread.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: pthread.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pthread.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: pthread.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pthread.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: pthread.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pthread.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: pthread.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pthread.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: pthread.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pthread.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: pthread.h: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ echo "$as_me:$LINENO: checking for pthread.h" >&5
+echo $ECHO_N "checking for pthread.h... $ECHO_C" >&6; }
+if test "${ac_cv_header_pthread_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_pthread_h=$ac_header_preproc
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_header_pthread_h" >&5
+echo "${ECHO_T}$ac_cv_header_pthread_h" >&6; }
+
+fi
+if test $ac_cv_header_pthread_h = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_PTHREAD_H 1
+_ACEOF
+
+fi
+
+
+
+	if test x$ac_cv_header_pthread_h = xyes; then
+				for flag in -lpthreads -lpthread -pthread; do
+        		{ echo "$as_me:$LINENO: checking for pthread_create using $flag" >&5
+echo $ECHO_N "checking for pthread_create using $flag... $ECHO_C" >&6; }
+			SAVELIBS="$LIBS"
+			LIBS="$flag $LIBS"
+        		cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <pthread.h>
+int
+main ()
+{
+pthread_create(0, 0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  have_pthread=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+        		{ echo "$as_me:$LINENO: result: $have_pthread" >&5
+echo "${ECHO_T}$have_pthread" >&6; }
+			LIBS="$SAVELIBS"
+
+			if test $have_pthread = yes; then
+				PTHREAD_FLAGS="-D_THREAD_SAFE -D_REENTRANT"
+				PTHREAD_LIBS="$flag"
+
+				# Solaris requires -D_POSIX_PTHREAD_SEMANTICS to
+				# be POSIX-compliant... :(
+				if test $uname = SunOS; then
+					PTHREAD_FLAGS="$PTHREAD_FLAGS -D_POSIX_PTHREAD_SEMANTICS"
+				fi
+				break
+			fi
+		done
+	fi
+fi
+
+
+
+
+DSO="${DSO:=:}"
+DSOFLAGS="${DSOFLAGS:=}"
+
+# Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then
+  enableval=$enable_shared;
+fi
+
+
+if test x$enable_shared = xyes; then
+	{ echo "$as_me:$LINENO: checking for shared library support" >&5
+echo $ECHO_N "checking for shared library support... $ECHO_C" >&6; }
+	PICFLAG=1
+
+	case "$uname" in
+		SunOS* | UNIX_S*)
+			{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-h,libmxml.so.1 -G -R\$(libdir) \$(OPTIM)"
+			LDFLAGS="$LDFLAGS -R\$(libdir)"
+                	;;
+
+		HP-UX*)
+			{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+			LIBMXML="libmxml.sl.1"
+			DSO="ld"
+			DSOFLAGS="$DSOFLAGS -b -z +h libmxml.sl.1 +s +b \$(libdir)"
+			LDFLAGS="$LDFLAGS -Wl,+s,+b,\$(libdir)"
+			;;
+
+		IRIX)
+			{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-rpath,\$(libdir),-set_version,sgi1.0,-soname,libmxml.so.1 -shared \$(OPTIM)"
+			;;
+
+		OSF1* | Linux | GNU)
+			{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-soname,libmxml.so.1,-rpath,\$(libdir) -shared \$(OPTIM)"
+                        LDFLAGS="$LDFLAGS -Wl,-rpath,\$(libdir)"
+			;;
+
+		*BSD*)
+			{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-soname,libmxml.so.1,-R\$(libdir) -shared \$(OPTIM)"
+			LDFLAGS="$LDFLAGS -Wl,-R\$(libdir)"
+                        ;;
+
+		Darwin*)
+			{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+			LIBMXML="libmxml.1.dylib"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS \$(RC_CFLAGS) -dynamiclib -lc"
+			;;
+
+		*)
+			{ echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+			{ echo "$as_me:$LINENO: WARNING: shared libraries not supported on this platform." >&5
+echo "$as_me: WARNING: shared libraries not supported on this platform." >&2;}
+			PICFLAG=0
+			LIBMXML="libmxml.a"
+			;;
+	esac
+else
+	PICFLAG=0
+	LIBMXML="libmxml.a"
+fi
+
+
+
+
+
+
+if test -n "$GCC"; then
+	CFLAGS="-Wall $CFLAGS"
+
+	if test "x$OPTIM" = x; then
+		OPTIM="-Os -g"
+	fi
+
+	if test "x$use_ansi" = xyes; then
+		CFLAGS="-ansi -pedantic $CFLAGS"
+	fi
+
+	if test $PICFLAG = 1 -a $uname != AIX; then
+    		OPTIM="-fPIC $OPTIM"
+	fi
+else
+	case $uname in
+		HP-UX*)
+			CFLAGS="-Ae $CFLAGS"
+
+			if test "x$OPTIM" = x; then
+				OPTIM="-O"
+			fi
+
+			OPTIM="+DAportable $OPTIM"
+
+			if test $PICFLAG = 1; then
+				OPTIM="+z $OPTIM"
+			fi
+			;;
+
+		UNIX_SVR* | SunOS*)
+			if test "x$OPTIM" = x; then
+				OPTIM="-O"
+			fi
+
+			if test $PICFLAG = 1; then
+				OPTIM="-KPIC $OPTIM"
+			fi
+			;;
+
+		*)
+			if test "x$OPTIM" = x; then
+				OPTIM="-O"
+			fi
+			;;
+	esac
+fi
+
+if test "$prefix" = "NONE"; then
+	prefix="/usr/local"
+fi
+
+if test "$exec_prefix" = "NONE"; then
+	exec_prefix="$prefix"
+fi
+
+if test "$docdir" = "NONE"; then
+	docdir="$datadir/doc/mxml"
+fi
+
+if test "$mandir" = "\${prefix}/man" -a "$prefix" = "/usr"; then
+	case "$uname" in
+        	*BSD* | Darwin* | Linux*)
+        		# BSD, Darwin (MacOS X), and Linux
+        		mandir="/usr/share/man"
+        		;;
+        	IRIX*)
+        		# SGI IRIX
+        		mandir="/usr/share/catman/u_man"
+        		;;
+        	*)
+        		# All others
+        		mandir="/usr/man"
+        		;;
+	esac
+fi
+
+if test "$includedir" != /usr/include; then
+	PC_CFLAGS="-I$includedir"
+else
+	PC_CFLAGS=""
+fi
+
+if test "$libdir" != /usr/lib; then
+	PC_LIBS="-L$libdir -lmxml"
+else
+	PC_LIBS="-lmxml"
+fi
+
+
+
+
+ac_config_files="$ac_config_files Makefile mxml.list mxml.pc"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
+echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { echo "$as_me:$LINENO: updating cache $cache_file" >&5
+echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+as_nl='
+'
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir
+fi
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s='ln -s'
+  # ... but there are two gotchas:
+  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+  # In both cases, we have to default to `cp -p'.
+  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+    as_ln_s='cp -p'
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+        test -d "$1/.";
+      else
+	case $1 in
+        -*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+
+# Save the log message, to keep $[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Report bugs to <bug-autoconf@gnu.org>."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.61,
+  with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2006 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    { echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running CONFIG_SHELL=$SHELL $SHELL $0 "$ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  CONFIG_SHELL=$SHELL
+  export CONFIG_SHELL
+  exec $SHELL "$0"$ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "mxml.list") CONFIG_FILES="$CONFIG_FILES mxml.list" ;;
+    "mxml.pc") CONFIG_FILES="$CONFIG_FILES mxml.pc" ;;
+
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+#
+# Set up the sed scripts for CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "$CONFIG_FILES"; then
+
+_ACEOF
+
+
+
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  cat >conf$$subs.sed <<_ACEOF
+SHELL!$SHELL$ac_delim
+PATH_SEPARATOR!$PATH_SEPARATOR$ac_delim
+PACKAGE_NAME!$PACKAGE_NAME$ac_delim
+PACKAGE_TARNAME!$PACKAGE_TARNAME$ac_delim
+PACKAGE_VERSION!$PACKAGE_VERSION$ac_delim
+PACKAGE_STRING!$PACKAGE_STRING$ac_delim
+PACKAGE_BUGREPORT!$PACKAGE_BUGREPORT$ac_delim
+exec_prefix!$exec_prefix$ac_delim
+prefix!$prefix$ac_delim
+program_transform_name!$program_transform_name$ac_delim
+bindir!$bindir$ac_delim
+sbindir!$sbindir$ac_delim
+libexecdir!$libexecdir$ac_delim
+datarootdir!$datarootdir$ac_delim
+datadir!$datadir$ac_delim
+sysconfdir!$sysconfdir$ac_delim
+sharedstatedir!$sharedstatedir$ac_delim
+localstatedir!$localstatedir$ac_delim
+includedir!$includedir$ac_delim
+oldincludedir!$oldincludedir$ac_delim
+docdir!$docdir$ac_delim
+infodir!$infodir$ac_delim
+htmldir!$htmldir$ac_delim
+dvidir!$dvidir$ac_delim
+pdfdir!$pdfdir$ac_delim
+psdir!$psdir$ac_delim
+libdir!$libdir$ac_delim
+localedir!$localedir$ac_delim
+mandir!$mandir$ac_delim
+DEFS!$DEFS$ac_delim
+ECHO_C!$ECHO_C$ac_delim
+ECHO_N!$ECHO_N$ac_delim
+ECHO_T!$ECHO_T$ac_delim
+LIBS!$LIBS$ac_delim
+build_alias!$build_alias$ac_delim
+host_alias!$host_alias$ac_delim
+target_alias!$target_alias$ac_delim
+VERSION!$VERSION$ac_delim
+LDFLAGS!$LDFLAGS$ac_delim
+OPTIM!$OPTIM$ac_delim
+ARCHFLAGS!$ARCHFLAGS$ac_delim
+CC!$CC$ac_delim
+CFLAGS!$CFLAGS$ac_delim
+CPPFLAGS!$CPPFLAGS$ac_delim
+ac_ct_CC!$ac_ct_CC$ac_delim
+EXEEXT!$EXEEXT$ac_delim
+OBJEXT!$OBJEXT$ac_delim
+CXX!$CXX$ac_delim
+CXXFLAGS!$CXXFLAGS$ac_delim
+ac_ct_CXX!$ac_ct_CXX$ac_delim
+INSTALL_PROGRAM!$INSTALL_PROGRAM$ac_delim
+INSTALL_SCRIPT!$INSTALL_SCRIPT$ac_delim
+INSTALL_DATA!$INSTALL_DATA$ac_delim
+RANLIB!$RANLIB$ac_delim
+AR!$AR$ac_delim
+CP!$CP$ac_delim
+LN!$LN$ac_delim
+MKDIR!$MKDIR$ac_delim
+RM!$RM$ac_delim
+ARFLAGS!$ARFLAGS$ac_delim
+CPP!$CPP$ac_delim
+GREP!$GREP$ac_delim
+EGREP!$EGREP$ac_delim
+PTHREAD_FLAGS!$PTHREAD_FLAGS$ac_delim
+PTHREAD_LIBS!$PTHREAD_LIBS$ac_delim
+DSO!$DSO$ac_delim
+DSOFLAGS!$DSOFLAGS$ac_delim
+LIBMXML!$LIBMXML$ac_delim
+PICFLAG!$PICFLAG$ac_delim
+PC_CFLAGS!$PC_CFLAGS$ac_delim
+PC_LIBS!$PC_LIBS$ac_delim
+LIBOBJS!$LIBOBJS$ac_delim
+LTLIBOBJS!$LTLIBOBJS$ac_delim
+_ACEOF
+
+  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 73; then
+    break
+  elif $ac_last_try; then
+    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
+if test -n "$ac_eof"; then
+  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
+  ac_eof=`expr $ac_eof + 1`
+fi
+
+cat >>$CONFIG_STATUS <<_ACEOF
+cat >"\$tmp/subs-1.sed" <<\CEOF$ac_eof
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
+_ACEOF
+sed '
+s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
+s/^/s,@/; s/!/@,|#_!!_#|/
+:n
+t n
+s/'"$ac_delim"'$/,g/; t
+s/$/\\/; p
+N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
+' >>$CONFIG_STATUS <conf$$subs.sed
+rm -f conf$$subs.sed
+cat >>$CONFIG_STATUS <<_ACEOF
+:end
+s/|#_!!_#|//g
+CEOF$ac_eof
+_ACEOF
+
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+fi # test -n "$CONFIG_FILES"
+
+
+for ac_tag in  :F $CONFIG_FILES  :H $CONFIG_HEADERS
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) { { echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
+echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+   { (exit 1); exit 1; }; };;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
+echo "$as_me: error: cannot find input file: $ac_f" >&2;}
+   { (exit 1); exit 1; }; };;
+      esac
+      ac_file_inputs="$ac_file_inputs $ac_f"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input="Generated from "`IFS=:
+	  echo $* | sed 's|^[^:]*/||;s|:[^:]*/|, |g'`" by configure."
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    fi
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin";;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  { as_dir="$ac_dir"
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+
+case `sed -n '/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p
+' $ac_file_inputs` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+    s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s&@configure_input@&$configure_input&;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+$ac_datarootdir_hack
+" $ac_file_inputs | sed -f "$tmp/subs-1.sed" >$tmp/out
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out"; rm -f "$tmp/out";;
+  *) rm -f "$ac_file"; mv "$tmp/out" $ac_file;;
+  esac
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+_ACEOF
+
+# Transform confdefs.h into a sed script `conftest.defines', that
+# substitutes the proper values into config.h.in to produce config.h.
+rm -f conftest.defines conftest.tail
+# First, append a space to every undef/define line, to ease matching.
+echo 's/$/ /' >conftest.defines
+# Then, protect against being on the right side of a sed subst, or in
+# an unquoted here document, in config.status.  If some macros were
+# called several times there might be several #defines for the same
+# symbol, which is useless.  But do not sort them, since the last
+# AC_DEFINE must be honored.
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+# These sed commands are passed to sed as "A NAME B PARAMS C VALUE D", where
+# NAME is the cpp macro being defined, VALUE is the value it is being given.
+# PARAMS is the parameter list in the macro definition--in most cases, it's
+# just an empty string.
+ac_dA='s,^\\([	 #]*\\)[^	 ]*\\([	 ]*'
+ac_dB='\\)[	 (].*,\\1define\\2'
+ac_dC=' '
+ac_dD=' ,'
+
+uniq confdefs.h |
+  sed -n '
+	t rset
+	:rset
+	s/^[	 ]*#[	 ]*define[	 ][	 ]*//
+	t ok
+	d
+	:ok
+	s/[\\&,]/\\&/g
+	s/^\('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/ '"$ac_dA"'\1'"$ac_dB"'\2'"${ac_dC}"'\3'"$ac_dD"'/p
+	s/^\('"$ac_word_re"'\)[	 ]*\(.*\)/'"$ac_dA"'\1'"$ac_dB$ac_dC"'\2'"$ac_dD"'/p
+  ' >>conftest.defines
+
+# Remove the space that was appended to ease matching.
+# Then replace #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+# (The regexp can be short, since the line contains either #define or #undef.)
+echo 's/ $//
+s,^[	 #]*u.*,/* & */,' >>conftest.defines
+
+# Break up conftest.defines:
+ac_max_sed_lines=50
+
+# First sed command is:	 sed -f defines.sed $ac_file_inputs >"$tmp/out1"
+# Second one is:	 sed -f defines.sed "$tmp/out1" >"$tmp/out2"
+# Third one will be:	 sed -f defines.sed "$tmp/out2" >"$tmp/out1"
+# et cetera.
+ac_in='$ac_file_inputs'
+ac_out='"$tmp/out1"'
+ac_nxt='"$tmp/out2"'
+
+while :
+do
+  # Write a here document:
+    cat >>$CONFIG_STATUS <<_ACEOF
+    # First, check the format of the line:
+    cat >"\$tmp/defines.sed" <<\\CEOF
+/^[	 ]*#[	 ]*undef[	 ][	 ]*$ac_word_re[	 ]*\$/b def
+/^[	 ]*#[	 ]*define[	 ][	 ]*$ac_word_re[(	 ]/b def
+b
+:def
+_ACEOF
+  sed ${ac_max_sed_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+    sed -f "$tmp/defines.sed"' "$ac_in >$ac_out" >>$CONFIG_STATUS
+  ac_in=$ac_out; ac_out=$ac_nxt; ac_nxt=$ac_in
+  sed 1,${ac_max_sed_lines}d conftest.defines >conftest.tail
+  grep . conftest.tail >/dev/null || break
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines conftest.tail
+
+echo "ac_result=$ac_in" >>$CONFIG_STATUS
+cat >>$CONFIG_STATUS <<\_ACEOF
+  if test x"$ac_file" != x-; then
+    echo "/* $configure_input  */" >"$tmp/config.h"
+    cat "$ac_result" >>"$tmp/config.h"
+    if diff $ac_file "$tmp/config.h" >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f $ac_file
+      mv "$tmp/config.h" $ac_file
+    fi
+  else
+    echo "/* $configure_input  */"
+    cat "$ac_result"
+  fi
+  rm -f "$tmp/out12"
+ ;;
+
+
+  esac
+
+done # for ac_tag
+
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
diff -Naur mxml-2.6/configure.in mxml-2.6-haiku/configure.in
--- mxml-2.6/configure.in	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/configure.in	2009-04-18 17:05:52.000000000 +0000
@@ -0,0 +1,340 @@
+dnl
+dnl "$Id: configure.in 387 2009-04-18 17:05:52Z mike $"
+dnl
+dnl Configuration script for Mini-XML, a small XML-like file parsing library.
+dnl
+dnl Copyright 2003-2009 by Michael Sweet.
+dnl
+dnl This program is free software; you can redistribute it and/or
+dnl modify it under the terms of the GNU Library General Public
+dnl License as published by the Free Software Foundation; either
+dnl version 2, or (at your option) any later version.
+dnl
+dnl This program is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+dnl GNU General Public License for more details.
+dnl
+
+dnl Specify a source file from the distribution...
+AC_INIT(mxml.h)
+
+dnl Set the name of the config header file...
+AC_CONFIG_HEADER(config.h)
+
+dnl Version number...
+VERSION=2.6
+AC_SUBST(VERSION)
+AC_DEFINE_UNQUOTED(MXML_VERSION, "Mini-XML v$VERSION")
+
+dnl Clear default debugging options and set normal optimization by
+dnl default unless the user asks for debugging specifically.
+CFLAGS="${CFLAGS:=}"
+CXXFLAGS="${CXXFLAGS:=}"
+LDFLAGS="${LDFLAGS:=}"
+AC_SUBST(LDFLAGS)
+OPTIM=""
+AC_SUBST(OPTIM)
+
+AC_ARG_WITH(ansi, [  --with-ansi             set full ANSI C mode, default=no],
+	use_ansi="$withval",
+	use_ansi="no")
+
+AC_ARG_WITH(archflags, [  --with-archflags        set additional architecture flags, default=none],
+	ARCHFLAGS="$withval",
+	ARCHFLAGS="")
+AC_SUBST(ARCHFLAGS)
+
+AC_ARG_ENABLE(debug, [  --enable-debug          turn on debugging, default=no],
+if eval "test x$enable_debug = xyes"; then
+ 	OPTIM="-g"
+fi)
+
+AC_ARG_WITH(docdir, [  --with-docdir           set directory for documentation, default=${prefix}/share/doc/mxml],
+	docdir="$withval",
+	docdir="NONE")
+
+AC_SUBST(docdir)
+
+AC_ARG_WITH(vsnprintf, [  --with-vsnprintf        use vsnprintf emulation functions, default=auto],
+	use_vsnprintf="$withval",
+	use_vsnprintf="no")
+
+dnl Get the operating system and version number...
+uname=`uname`
+uversion=`uname -r | sed -e '1,$s/[[^0-9]]//g'`
+if test x$uname = xIRIX64; then
+	uname="IRIX"
+fi
+
+dnl Checks for programs...
+AC_PROG_CC
+AC_PROG_CXX
+AC_PROG_INSTALL
+if test "$INSTALL" = "$ac_install_sh"; then
+	# Use full path to install-sh script...
+	INSTALL="`pwd`/install-sh -c"
+fi
+AC_PROG_RANLIB
+AC_PATH_PROG(AR,ar)
+AC_PATH_PROG(CP,cp)
+AC_PATH_PROG(LN,ln)
+AC_PATH_PROG(MKDIR,mkdir)
+AC_PATH_PROG(RM,rm)
+
+dnl Flags for "ar" command...
+case "$uname" in
+        Darwin* | *BSD*)
+                ARFLAGS="-rcv"
+                ;;
+        *)
+                ARFLAGS="crvs"
+                ;;
+esac
+
+AC_SUBST(ARFLAGS)
+
+dnl Inline functions...
+AC_C_INLINE
+
+dnl Checks for string functions.
+if test "x$use_ansi" != xyes; then
+	AC_CHECK_FUNCS(strdup)
+fi
+
+if test "x$use_vsnprintf" != xyes; then
+	AC_CHECK_FUNCS(snprintf vsnprintf)
+fi
+
+dnl Check for "long long" support...
+AC_CACHE_CHECK(for long long int, ac_cv_c_long_long,
+	[if test "$GCC" = yes; then
+		ac_cv_c_long_long=yes
+	else
+		AC_TRY_COMPILE(,[long long int i;],
+			ac_cv_c_long_long=yes,
+			ac_cv_c_long_long=no)
+	fi])
+
+if test $ac_cv_c_long_long = yes; then
+	AC_DEFINE(HAVE_LONG_LONG)
+fi
+
+dnl Threading support
+AC_ARG_ENABLE(threads, [  --enable-threads        enable multi-threading support])
+
+have_pthread=no
+PTHREAD_FLAGS=""
+PTHREAD_LIBS=""
+
+if test "x$enable_threads" != xno; then
+	AC_CHECK_HEADER(pthread.h, AC_DEFINE(HAVE_PTHREAD_H))
+
+	if test x$ac_cv_header_pthread_h = xyes; then
+		dnl Check various threading options for the platforms we support
+		for flag in -lpthreads -lpthread -pthread; do
+        		AC_MSG_CHECKING([for pthread_create using $flag])
+			SAVELIBS="$LIBS"
+			LIBS="$flag $LIBS"
+        		AC_TRY_LINK([#include <pthread.h>],
+				[pthread_create(0, 0, 0, 0);],
+        			have_pthread=yes)
+        		AC_MSG_RESULT([$have_pthread])
+			LIBS="$SAVELIBS"
+
+			if test $have_pthread = yes; then
+				PTHREAD_FLAGS="-D_THREAD_SAFE -D_REENTRANT"
+				PTHREAD_LIBS="$flag"
+
+				# Solaris requires -D_POSIX_PTHREAD_SEMANTICS to
+				# be POSIX-compliant... :(
+				if test $uname = SunOS; then
+					PTHREAD_FLAGS="$PTHREAD_FLAGS -D_POSIX_PTHREAD_SEMANTICS"
+				fi
+				break
+			fi
+		done
+	fi
+fi
+
+AC_SUBST(PTHREAD_FLAGS)
+AC_SUBST(PTHREAD_LIBS)
+
+dnl Shared library support...
+DSO="${DSO:=:}"
+DSOFLAGS="${DSOFLAGS:=}"
+
+AC_ARG_ENABLE(shared, [  --enable-shared         turn on shared libraries, default=no])
+
+if test x$enable_shared = xyes; then
+	AC_MSG_CHECKING(for shared library support)
+	PICFLAG=1
+
+	case "$uname" in
+		SunOS* | UNIX_S*)
+			AC_MSG_RESULT(yes)
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-h,libmxml.so.1 -G -R\$(libdir) \$(OPTIM)"
+			LDFLAGS="$LDFLAGS -R\$(libdir)"
+                	;;
+
+		HP-UX*)
+			AC_MSG_RESULT(yes)
+			LIBMXML="libmxml.sl.1"
+			DSO="ld"
+			DSOFLAGS="$DSOFLAGS -b -z +h libmxml.sl.1 +s +b \$(libdir)"
+			LDFLAGS="$LDFLAGS -Wl,+s,+b,\$(libdir)"
+			;;
+
+		IRIX)
+			AC_MSG_RESULT(yes)
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-rpath,\$(libdir),-set_version,sgi1.0,-soname,libmxml.so.1 -shared \$(OPTIM)"
+			;;
+
+		OSF1* | Linux | GNU)
+			AC_MSG_RESULT(yes)
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-soname,libmxml.so.1,-rpath,\$(libdir) -shared \$(OPTIM)"
+                        LDFLAGS="$LDFLAGS -Wl,-rpath,\$(libdir)"
+			;;
+
+		*BSD*)
+			AC_MSG_RESULT(yes)
+			LIBMXML="libmxml.so.1.4"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS -Wl,-soname,libmxml.so.1,-R\$(libdir) -shared \$(OPTIM)"
+			LDFLAGS="$LDFLAGS -Wl,-R\$(libdir)"
+                        ;;
+
+		Darwin*)
+			AC_MSG_RESULT(yes)
+			LIBMXML="libmxml.1.dylib"
+			DSO="\$(CC)"
+			DSOFLAGS="$DSOFLAGS \$(RC_CFLAGS) -dynamiclib -lc"
+			;;
+
+		*)
+			AC_MSG_RESULT(no)
+			AC_MSG_WARN(shared libraries not supported on this platform.)
+			PICFLAG=0
+			LIBMXML="libmxml.a"
+			;;
+	esac
+else
+	PICFLAG=0
+	LIBMXML="libmxml.a"
+fi
+
+AC_SUBST(DSO)
+AC_SUBST(DSOFLAGS)
+AC_SUBST(LIBMXML)
+AC_SUBST(PICFLAG)
+
+dnl Add -Wall for GCC...
+if test -n "$GCC"; then
+	CFLAGS="-Wall $CFLAGS"
+
+	if test "x$OPTIM" = x; then
+		OPTIM="-Os -g"
+	fi
+
+	if test "x$use_ansi" = xyes; then
+		CFLAGS="-ansi -pedantic $CFLAGS"
+	fi
+
+	if test $PICFLAG = 1 -a $uname != AIX; then
+    		OPTIM="-fPIC $OPTIM"
+	fi
+else
+	case $uname in
+		HP-UX*)
+			CFLAGS="-Ae $CFLAGS"
+
+			if test "x$OPTIM" = x; then
+				OPTIM="-O"
+			fi
+
+			OPTIM="+DAportable $OPTIM"
+
+			if test $PICFLAG = 1; then
+				OPTIM="+z $OPTIM"
+			fi
+			;;
+
+		UNIX_SVR* | SunOS*)
+			if test "x$OPTIM" = x; then
+				OPTIM="-O"
+			fi
+
+			if test $PICFLAG = 1; then
+				OPTIM="-KPIC $OPTIM"
+			fi
+			;;
+
+		*)
+			if test "x$OPTIM" = x; then
+				OPTIM="-O"
+			fi
+			;;
+	esac
+fi
+
+dnl Fix "prefix" variable if it hasn't been specified...
+if test "$prefix" = "NONE"; then
+	prefix="/usr/local"
+fi
+
+dnl Fix "exec_prefix" variable if it hasn't been specified...
+if test "$exec_prefix" = "NONE"; then
+	exec_prefix="$prefix"
+fi
+
+dnl Fix "docdir" variable if it hasn't been specified...
+if test "$docdir" = "NONE"; then
+	docdir="$datadir/doc/mxml"
+fi
+
+dnl Fix "mandir" variable if it hasn't been specified...
+if test "$mandir" = "\${prefix}/man" -a "$prefix" = "/usr"; then
+	case "$uname" in
+        	*BSD* | Darwin* | Linux*)
+        		# BSD, Darwin (MacOS X), and Linux
+        		mandir="/usr/share/man"
+        		;;
+        	IRIX*)
+        		# SGI IRIX
+        		mandir="/usr/share/catman/u_man"
+        		;;
+        	*)
+        		# All others
+        		mandir="/usr/man"
+        		;;
+	esac
+fi
+
+dnl pkg-config stuff...
+if test "$includedir" != /usr/include; then
+	PC_CFLAGS="-I$includedir"
+else
+	PC_CFLAGS=""
+fi
+
+if test "$libdir" != /usr/lib; then
+	PC_LIBS="-L$libdir -lmxml"
+else
+	PC_LIBS="-lmxml"
+fi
+
+AC_SUBST(PC_CFLAGS)
+AC_SUBST(PC_LIBS)
+
+dnl Output the makefile, etc...
+AC_OUTPUT(Makefile mxml.list mxml.pc)
+
+dnl
+dnl End of "$Id: configure.in 387 2009-04-18 17:05:52Z mike $".
+dnl
diff -Naur mxml-2.6/doc/0.gif mxml-2.6-haiku/doc/0.gif
--- mxml-2.6/doc/0.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/0.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,5 @@
+GIF89ad d     			
+
+
+   !!!"""###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~,    d d   	H`A5*\#*TcI0h(\0;ay1i$tk(&4a]jJLD'	yd5MD*k,,)u]RU*oE?Rjdz{QC1,if9_<'DLbtQ+4{$d'uhD'nX(%o919\"K	!Dpc67Htz8_}|vW3GTC|	v&5&OG~sZ!r!FTl'v7o):bW/"n1.TU7&#f3Z;.	2!62:B(	YVCRWziRa	fjro:M+)eU""]rR,+d&fgc*&>B&+Q+qaB2
+H&S>*KlKKDDM*dN4TN:kmj!lVlB6D;L\~dL-R@hzTHX6Vuu]U)_]1 j	&]EqKOU=|VA%1J|b9oJVBa|ph,E ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/1.gif mxml-2.6-haiku/doc/1.gif
--- mxml-2.6/doc/1.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/1.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,7 @@
+GIF89ad d     			
+
+
+   !!!"""###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~,    d d   	H`A5*\#*TcI0h(\0;ay1i$tk(&4a]jJLD'`9Vtl6*`I
+r x\CP$Xi;.dX@6sD:ITEIPT}RbmQ\}[[lG\9A?Szj75c^yMar<y=!~~?W:^xB.x@BR(aqhHef	Ew`
+2u]M.%_P`9X@oiQ]vy@dZiojVBZ]TN4udq
+neo]sTzuE ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/2.gif mxml-2.6-haiku/doc/2.gif
--- mxml-2.6/doc/2.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/2.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,9 @@
+GIF89ad d     			
+
+
+   !!!"""###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~,    d d   	H`A5*\#*TcI0h(\0;ay1i$tk(&4a]jJLD'`9Vtv,u,RU:EwQj\H	KCc0K.x &2HjLhu=y)5M<W;fQQN97\'t<Xb0Jv&SW/?	>o_	
+z+oGO2A~H_vY
+{JDHY=jxw+Mv8bz,qbLxR-Q:a ID5F<HArP7Q=BAdD0
+dD59	59'\6dN[;R"BfB8gByg:sx,Y3(4spjwgwB'
+ap)n)}
+*s:J,[pztwE8jMk7J`kM-VpCz5CuBkB_m[Z]TTNtdifeNmeYkl*H] ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/3.gif mxml-2.6-haiku/doc/3.gif
--- mxml-2.6/doc/3.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/3.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,6 @@
+GIF89ad d     			
+
+
+   !!!"""###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~,    d d   	H`A5*\#*TcI0h(\0;ay1i$tk(&4a]jJLD'bU^gUX%V]4:UDB	Z$SGy-JU9)D("1oi(+
+4~K7e*,MjX^{R6?*(= Qg,$~<':F`y[wr93l2x#k?p}>~}_|$Q= N> 0=1!(419N,pXd8b`&'.)$-1*?59T=rA.xC V$GiT7[]BT]HfB.xyd`\)|j&I=vQC4{#AAp6
+zNOe|'UC`b$bDOdF=EK=,nU*>*hcLA1WQT|V	87EXag([rT]jYQeVdiuT*DHJ|S,\,T=k-jlRX@ ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/4.gif mxml-2.6-haiku/doc/4.gif
--- mxml-2.6/doc/4.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/4.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,6 @@
+GIF89ad d     			
+
+
+   !!!"""###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~,    d d   	H`A5*\#*TcI0h(\0;ay1i$tk(&4a]jJLD'`9Vtl2Hhj
+5r`\.| `{S9T`CwdB\fqZ2=}jMb2v##yH'W\\rw7y1Xx;P0xa
+-?_>CK`||		H>~9@`8]#=]psQE\~xUhp`\MG"w/FE@xT#jax-qQ_>"GkTfVjZnY^2VZI&``jdnvg-(e9gz^~xg%JghDQl?X&gZo>`N?KpQ]v$Ad*Zi:d}.ZU.EP{ U")US,%k+,zMZZx%X@ ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/5.gif mxml-2.6-haiku/doc/5.gif
--- mxml-2.6/doc/5.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/5.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,5 @@
+GIF89ad d   	
+	
+	
+ ! "! #"!$#"%$#&%#'&$'&$('%)(&*)'+*(,+)-,*.-,0/-10.21/320431542653665886997::8;;9<<:=<;>=<?>=@?>A@?BA@CBADCBEDCFEDGFEHGFIHHKJILKJMLKNMLONNQPORQPSRQTSRUTSUUTVVUWWVXXWYYY[[Z\\[]]\^^]__^``_a``baacbbdcbedcfedgfehgfihgjihkjilkjmlknmlonmponqporqpsrqtsrttsuutvvuwwvxxwyyxzzy{{z||{}}|~~}~,    d d   	H`A1 *\#*csIG 0(\I0;ay1it3(N#4U]jSJLD'`9Vtl"V`%jK}+PQB}nfQ(+VyY=6Zhh!am4ow+U#89_=\yT9"^U&Gl{D, 6yfBO`1`AxW@**9Ct4Q69RrG$hIzR=dc/ ed8.N>dbAIeS^ZJe9Y	di2	jJY|-+&FR	']:@GinFv#M<tPaZXty2YO(c?]<ZkHuQ=~X+Ss V
+`wIh:nGPUFEPU")%BNod8adiYa.mgl*GQ[ ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/6.gif mxml-2.6-haiku/doc/6.gif
--- mxml-2.6/doc/6.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/6.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,7 @@
+GIF89ad d   	
+	
+	
+ ! "! #"!$#"%$#'&$'&$('%)(&*)'+*(,+)-,*.-+/.,0/-10.21/320431542653664775886997::8;;9<<:=<;>=<?>=@?>A@?BA@CBADCBEDCFEDGFEHGFIHGJIHKJILKJMLKNMLONMPONQPORQPSRQTSRUTSUUTVVUWWVXXWYYXZZY[[Z\\[]]\^^]__^``_a``baacbbdcbedcfedgfehgfihgjihkjilkjmlknmlonmponqporqpsrqtsrttsuutvvuwwvxxwyyxzzy{{{}}|~~~,    d d   	H`A3 *\#*4c{IG 0((\/0;ay1itC(N$4U]jSJLD's0R6nR[\Yk
+YI-X1U98FC*F61BQ9p~6
+J`afRu6YD*,G8s\iJ=:zWL<a!+WgG#1I E2G.+ipCuPp</UX&!!m6,2<y1HS6d}^<:2^zl{B$K@I3DyETI`wI(dz,AHr#	^4wN)8D+^7:\b$[~5'FDK+aiEV`Zzo9z@H}JiG,pBTLG~9/,64)"M8tPE8mEue 7
+rRcFQDlv2.dWQZ1v%}rdrPaE]*$`V>-=IYKV$Q%R({T-s2K"Pg1g,lRLG` ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/7.gif mxml-2.6-haiku/doc/7.gif
--- mxml-2.6/doc/7.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/7.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,8 @@
+GIF89ad d   	
+	
+	
+ !  #"!$#"%$#&%#'&$'&$('%)(&*)'+*)-,*.-+/.,0/-10.21/320431542653664775886997::8;;9<<:=<;>==@?>A@ADCBEDFIHGJIHKJILKKNMLONMPONQPORQPSRQTSRUTSUUUWWWYYXZZY[[[]]\^^]__^``_a`acbbdcbedehgfihgjihkjilkjmlknmlonorqpsrqtsrttsuutvvuwwvxxwyyxzzy{{{}}|~~}~,    d d   	H`+ *\#*b3IG 0(\0;ay1itF(4Q]jJLD'`9Vtlm
+]Kf1	SsV+PZgj:~,}~ZV*8v]WJX-5<@6,zQ+Ac#y)!x#y	{J>#F?#'JDh]t8HB(:Hva
+%3-nta`|JCt8`~&BTcC(J\hJ`8!FF2d,%JHJ9X	OIEV)]T
+hnFU}i`RA#gYtFk}	w'XeD5hCyhBhhB_ZZ]TbNd
+^:^a~hij&G[ ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/8.gif mxml-2.6-haiku/doc/8.gif
--- mxml-2.6/doc/8.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/8.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,7 @@
+GIF89ad d   	
+	
+	
+ ! "! #"!$#"%$#&%#'&$'&$('%)(&*)'+*(,+)-,*.-+/.,0/-10.21/320431542653664775886997::8;;9<<:=<;>=<?>=@?>A@?BA@CBADCBEDCFEDGFEHGFIHGJIHKJILKJMLKNMLONMPONQPORQPSRQTSRUTSUUTVVUWWVXXXZZY[[Z\\[]]\^^]__^``_a``baacbbdcbedcfedgfehgfihgjihkjilkjmlknmlonmponqporqpsrqtsrttsuutvvuwwvxxwyyxzzy{{z||{}}|~~}~,    d d   	H`A3 *\#*4c}IG 08(\O0;ay1itK($4W]jsJLD'	yT
+-7YmMX%h: VhB	RZdTvy+:r`T-:PzEX+5,JF9L34Hyjzl:M=0,6,kxl`L'WoiFnwL<J/,fz	BQW?g?G}dJa 
+i0*a$	$Gz#SHp),P!JbBbcE8>-#DS HBT4q % PY-MAY BU42NHJpKtDq)Q,`0,~+M'615/	Pz,!:!k`{gG="Tl+sR	,J:*wC
+4}:9k_^v<C^B@&FWk8r @yOkEKAfkT ZqKT9U8=UeGo`pE_\JUaW&L[-T]1o^d(iuT<&FJS,m4DC,Sb3{F2+f/ ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/9.gif mxml-2.6-haiku/doc/9.gif
--- mxml-2.6/doc/9.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/9.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,6 @@
+GIF89ad d   	
+	
+	
+ ! "! #"!$#"%$#&%#'&$'&$('%)(&*)'+*(,+)-,*.-+/.,0/-10.21/320431542653664775886997::8;;9<<:=<;>=<?>=@?>A@?BA@CBADCCFEDGFEHGFIHGJIHKJILKKNMLONMPONQPORQPSRQTSRUTSUUTVVUWWVXXWYYXZZY[[Z\\[]]\^^]__^``_a``baacbbdcbedcfedgfehgfihgjihkjilkjmlknmlonmponqporqpsrqtsrttsuutvvuwwvxxwyyxzzy{{z||{}}|~~}~,    d d   	H`2 *\#*,c}IG 0(\/0;ay1it;(#4W]jsJLD' ~Xb]5MH.),xU,4]XUzoE5Wj\j;!-eXTFTs#1'|J0]}Rg;tZehn6G|GdyqAk]-v=(O;Fo	;xhhmCC`D>
+>HM	CaCg~l4akJ"t+sD:=+=9K876t C!	DC6%m]
+dBfir6fBz6F~1JHWP JEPw6(y.K(fMEjrP&jHjJSQ/clm#d9(rkT0EJ,)-g~YWmZdVi=1J%iO+Qm&60]gK)zSTvWU5w	AI%@.#B`Aml)<E2vU5EU"isDNH+MWY9X,fLRW@ ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/A.gif mxml-2.6-haiku/doc/A.gif
--- mxml-2.6/doc/A.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/A.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,6 @@
+GIF89ad d   	
+	
+	
+! "! #""%$#&%$'&$('%)(&*)'+*)-,*.-,0/-10.21/320431542653664775887::8;;9<<:=<;>=<?>=@?>A@?BA@CBADCBEDCFEDGFEHGFIHGJIHKJJMLKNMLONMPONQPPSRQTSRUTSUUTVVUWWVXXWYYY[[Z\\]__^``_a``babdcbedehgfihhkjknmmponqporqqtstvvuwwvxxwyyxzzz|||~~}~,    d d   	H`+ *\#*b9IG 0(\)m0;ay1i4tJ( 4K]jJLD'`9VtU(~,nbU9P]j"\CJw[~4,e-U2V,46zH(u]{l]}e,cY	+ /Y r|nRWQBs>r!#[j!yG3+Wx~:,{yC!<,+C^T	%`C~_sUhjM!BXQ#F,X^z,!f@J#u5)B	TeXOz&'ffb3-!'q)1Y\U*aihE:
+iRQ0)e$Oa*&%L4V+^E?*^DEW^QFK+nX.LiDuDF
+E&IM~+n(H{m=IG2,U~7\2EW]2eYVZjQ^d0iuTDHJUiOi,=Cc:r}|[[pw6+E~ ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/B.gif mxml-2.6-haiku/doc/B.gif
--- mxml-2.6/doc/B.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/B.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,4 @@
+GIF89ad d   	
+	
+	
+ !  #"!$#"%$#&%#'&$'&%)(&*)'+*(,+)-,*.-+/.,0/-10.21/320431542653664775886997::8;;9<<:=<;>=<?>=@??BA@CBADCBEDCFEDGFFIHGJIHKJJMLKNMLONMPONQPORQPSRQTSRUTSUUTVVUWWVXXWYYXZZY[[Z\\[]]\^^]__^``_a`acbbdcbeddgfehggjihkjilkjmlknmlonmponqporqpsrqtssuutvvuwwvxxwyyxzzy{{z||{}}|~~},    d d   	H`/ *\#*b]IG 0(\N0;ay1it#(N"4S]j3JLD'`9VtiR0Y-X$T9%~ =Ci7 gdZF93;{(lM/Dwj4?	c!tn10TK>_;JUO/<zwg9>vnV.U|XF49_A4Mb >a,I ltfzX &Exb{(	(xThP1640@}gRTFeG,uR|8yR[r	fWev4\kzu&Wi&Vqn`w9UuFII9U%}hC9t4pBEE2hAK~*P	@jcz8ftbmm	*K)kY"~BUi|5mru-Wl-}EVkV7[U").NNS	U.&)n-u /TdnKY ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/C.gif mxml-2.6-haiku/doc/C.gif
--- mxml-2.6/doc/C.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/C.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,9 @@
+GIF89ad d   	
+	
+	
+ ! "! #"!$#"%$#&%#'&$'&$('%)(&*)'+*(,+)-,*.-+/.,0/-10.21/320431542653664775886997::8;;9<<:=<;>=<?>=@?>A@?BA@CBADCBEDCFEDGFEHGFIHGJIHKJILKJMLKNMLONMPONQPQTSRUTSUUTVVUWWVXXWYYXZZY[[Z\\[]]\^^]__^``_a``baacbbdccfedgfehgfihgjihkjilkjmlknmlonmponqporqpsrqtsrttsuutvvuwwvxxwyyxzzy{{z||{}}|~~}~,    d d   	H`A2 *\#*$cwIG 0(\0;ay1itK($4W]jsJLD'VhvpK<tfAb``$Ss2_Q$)gr7!sb1Gb:`Fvm3wF:z+, G(j
+WZ/f)T!i=A)4mw)(=lYC3UQc~,\#9*K88]~>R R]2rEKZ&
+HaLba+2Hc3#:>ncIuFy+M1"]%GZn)Mf0JpELE	W	Kk%6WHKA9@OJL!8B$M>(l::aZzUbG6U!!z% Da !s^b
+D58bC@T8
+K
+aTcFuBk/8]W!vQmG#R((9Y^[/jPiVd&iuTwDHJUS,QCI* DFpGFof.*l ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/D.gif mxml-2.6-haiku/doc/D.gif
--- mxml-2.6/doc/D.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/D.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,8 @@
+GIF89ad d   	
+	
+	
+ ! "! #"!$#"%$#&%#'&$'&$('%)(&*)'+*(,+)-,*.--10.21/320432653664776997::8;;9<<:=<=@?>A@?BA@CBADCBEDCFEDGFEHGFIHGJIHKJILKJMLKNMLONMPONQPORQPSRQTSRUTTVVUWWVXXWYYXZZY[[Z\\[]]\^^]___a``baacbbdcbedcfedgfehgfihgjihkjilkjmlknmlonmponqporqpsrqtsrttsuutvvuwwwyyxzzy{{z|||~~}~,    d d   	H`/ *\#*baIG 0(\.0;ay1it(!4S]j3JLD'`9VtUu`Y5D-X$
+-U9%^T/!47O-_{Cx;{hJ3<YuBSk Q:vfi3P8NWAj68kf-t&_U\|W0i%IU_dq5h"W`OXK]@MYKp8Q4	 KQ_DKhQ'EJ iQo$m
+KD0IQd}ae]`csiR&,e)rfwvHM;g7iG8%C.ZK@Nt
+s"jf3\m'JZD4H+Shv!k/EQD@BeQ+
+5;,1\bLoem|en-[MYdQiuT EHJS,M/	*E;d20Eg ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/E.gif mxml-2.6-haiku/doc/E.gif
--- mxml-2.6/doc/E.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/E.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,3 @@
+GIF89ad d   		$'&&*)-100437:::=<KNMNQPRUTUWW_a`bdchkjknm|~~,    d d  @pH,'rl:rbZFtz 
+hxn}PzQz*xt	v	koX|gu_\UnfpsEhkpEegWojCoEBZha*H_NtIl	(pAL.J~B#q#j?aAtLDFe@k\9F>blEg=W|jEh<UCZDi(MOy#.Vn5
+Om"vfMMmZfnWZ^KH~*F#&x!/#ckph1[hots7ZljRb3XEHP(Gl;WMpw`tW*Or* ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/F.gif mxml-2.6-haiku/doc/F.gif
--- mxml-2.6/doc/F.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/F.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1 @@
+GIF89ad d   		$'&&*)-100437:::=<KNMNQPRUTUWW_a`bdchkjknm|~~,    d d  pH,%rl:RbZtzx.}Pz1z)xtvkoX|gu_\UntwsEgcxEefVxjChD}CZ}a)o~BH~yOMl$xg 8F[P Bpo#G|_) I,&OJX%s&6_\a->F	*tE"Vr)SN}*(.Df5jW_E:hYgbo!m8Wawi8"MR} F8bZ;DU;r]cf4b~jdt=h)5JbvMI`{ <o]rLnA*  ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/advanced.html mxml-2.6-haiku/doc/advanced.html
--- mxml-2.6/doc/advanced.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/advanced.html	2009-03-19 05:33:20.000000000 +0000
@@ -0,0 +1,633 @@
+<html>
+<body>
+
+<h1 align='right'><a name='ADVANCED'><img src="3.gif" align="right"
+hspace="10" width="100" height="100" alt="3"></a>More Mini-XML
+Programming Techniques</h1>
+
+<p>This chapter shows additional ways to use the Mini-XML
+library in your programs.</p>
+
+<h2><a name='LOAD_CALLBACKS'>Load Callbacks</a></h2>
+
+<p><a href='#LOAD_XML'>Chapter 2</a> introduced the <a
+href='#mxmlLoadFile'><tt>mxmlLoadFile()</tt></a> and <a
+href='#mxmlLoadString'><tt>mxmlLoadString()</tt></a> functions.
+The last argument to these functions is a callback function
+which is used to determine the value type of each data node in
+an XML document.</p>
+
+<p>Mini-XML defines several standard callbacks for simple
+XML data files:</p>
+
+<ul>
+
+        <li><tt>MXML_INTEGER_CALLBACK</tt> - All data nodes
+        contain whitespace-separated integers.</li>
+
+        <li><tt>MXML_OPAQUE_CALLBACK</tt> - All data nodes
+        contain opaque strings ("CDATA").</li>
+
+	<li><tt>MXML_REAL_CALLBACK</tt> - All data nodes contain
+	whitespace-separated floating-point numbers.</li>
+
+	<li><tt>MXML_TEXT_CALLBACK</tt> - All data nodes contain
+	whitespace-separated strings.</li>
+
+</ul>
+
+<p>You can provide your own callback functions for more complex
+XML documents. Your callback function will receive a pointer to
+the current element node and must return the value type of the
+immediate children for that element node: <tt>MXML_INTEGER</tt>,
+<tt>MXML_OPAQUE</tt>, <tt>MXML_REAL</tt>, or <tt>MXML_TEXT</tt>.
+The function is called <i>after</i> the element and its
+attributes have been read, so you can look at the element name,
+attributes, and attribute values to determine the proper value
+type to return.</p>
+
+<!-- NEED 2in -->
+<p>The following callback function looks for an attribute named
+"type" or the element name to determine the value type for its
+child nodes:</p>
+
+<pre>
+    mxml_type_t
+    type_cb(mxml_node_t *node)
+    {
+      const char *type;
+
+     /*
+      * You can lookup attributes and/or use the
+      * element name, hierarchy, etc...
+      */
+
+      type = mxmlElementGetAttr(node, "type");
+      if (type == NULL)
+	type = node->value.element.name;
+
+      if (!strcmp(type, "integer"))
+	return (MXML_INTEGER);
+      else if (!strcmp(type, "opaque"))
+	return (MXML_OPAQUE);
+      else if (!strcmp(type, "real"))
+	return (MXML_REAL);
+      else
+	return (MXML_TEXT);
+    }
+</pre>
+
+<p>To use this callback function, simply use the name when you
+call any of the load functions:</p>
+
+<pre>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen("filename.xml", "r");
+    tree = mxmlLoadFile(NULL, fp, <b>type_cb</b>);
+    fclose(fp);
+</pre>
+
+
+<h2><a name='SAVE_CALLBACKS'>Save Callbacks</a></h2>
+
+<p><a href='#LOAD_XML'>Chapter 2</a> also introduced the <a
+href='#mxmlSaveFile'><tt>mxmlSaveFile()</tt></a>, <a
+href='#mxmlSaveString'><tt>mxmlSaveString()</tt></a>, and <a
+href='#mxmlSaveAllocString'><tt>mxmlSaveAllocString()</tt></a>
+functions. The last argument to these functions is a callback
+function which is used to automatically insert whitespace in an
+XML document.</p>
+
+<p>Your callback function will be called up to four times for
+each element node with a pointer to the node and a "where" value
+of <tt>MXML_WS_BEFORE_OPEN</tt>, <tt>MXML_WS_AFTER_OPEN</tt>,
+<tt>MXML_WS_BEFORE_CLOSE</tt>, or <tt>MXML_WS_AFTER_CLOSE</tt>.
+The callback function should return <tt>NULL</tt> if no
+whitespace should be added and the string to insert (spaces,
+tabs, carriage returns, and newlines) otherwise.</p>
+
+<p>The following whitespace callback can be used to add
+whitespace to XHTML output to make it more readable in a standard
+text editor:</p>
+
+<pre>
+    const char *
+    whitespace_cb(mxml_node_t *node,
+                  int where)
+    {
+      const char *name;
+
+     /*
+      * We can conditionally break to a new line
+      * before or after any element. These are
+      * just common HTML elements...
+      */
+
+      name = node->value.element.name;
+
+      if (!strcmp(name, "html") ||
+          !strcmp(name, "head") ||
+          !strcmp(name, "body") ||
+	  !strcmp(name, "pre") ||
+          !strcmp(name, "p") ||
+	  !strcmp(name, "h1") ||
+          !strcmp(name, "h2") ||
+          !strcmp(name, "h3") ||
+	  !strcmp(name, "h4") ||
+          !strcmp(name, "h5") ||
+          !strcmp(name, "h6"))
+      {
+       /*
+	* Newlines before open and after
+        * close...
+	*/
+
+	if (where == MXML_WS_BEFORE_OPEN ||
+            where == MXML_WS_AFTER_CLOSE)
+	  return ("\n");
+      }
+      else if (!strcmp(name, "dl") ||
+               !strcmp(name, "ol") ||
+               !strcmp(name, "ul"))
+      {
+       /*
+	* Put a newline before and after list
+        * elements...
+	*/
+
+	return ("\n");
+      }
+      else if (!strcmp(name, "dd") ||
+               !strcmp(name, "dt") ||
+               !strcmp(name, "li"))
+      {
+       /*
+	* Put a tab before &lt;li>'s, * &lt;dd>'s,
+        * and &lt;dt>'s, and a newline after them...
+	*/
+
+	if (where == MXML_WS_BEFORE_OPEN)
+	  return ("\t");
+	else if (where == MXML_WS_AFTER_CLOSE)
+	  return ("\n");
+      }
+
+     /*
+      * Return NULL for no added whitespace...
+      */
+
+      return (NULL);
+    }
+</pre>
+
+<p>To use this callback function, simply use the name when you
+call any of the save functions:</p>
+
+<pre>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen("filename.xml", "w");
+    mxmlSaveFile(tree, fp, <b>whitespace_cb</b>);
+    fclose(fp);
+</pre>
+
+
+<!-- NEED 10 -->
+<h2>Custom Data Types</h2>
+
+<p>Mini-XML supports custom data types via global load and save
+callbacks. Only a single set of callbacks can be active at any
+time, however your callbacks can store additional information in
+order to support multiple custom data types as needed. The
+<tt>MXML_CUSTOM</tt> node type identifies custom data nodes.</p>
+
+<p>The load callback receives a pointer to the current data node
+and a string of opaque character data from the XML source with
+character entities converted to the corresponding UTF-8
+characters. For example, if we wanted to support a custom
+date/time type whose value is encoded as "yyyy-mm-ddThh:mm:ssZ"
+(ISO format), the load callback would look like the
+following:</p>
+
+<pre>
+    typedef struct
+    {
+      unsigned      year,    /* Year */
+                    month,   /* Month */
+                    day,     /* Day */
+                    hour,    /* Hour */
+                    minute,  /* Minute */
+                    second;  /* Second */
+      time_t        unix;    /* UNIX time */
+    } iso_date_time_t;
+
+    int
+    load_custom(mxml_node_t *node,
+                const char *data)
+    {
+      iso_date_time_t *dt;
+      struct tm tmdata;
+
+     /*
+      * Allocate data structure...
+      */
+
+      dt = calloc(1, sizeof(iso_date_time_t));
+
+     /*
+      * Try reading 6 unsigned integers from the
+      * data string...
+      */
+
+      if (sscanf(data, "%u-%u-%uT%u:%u:%uZ",
+                 &(dt->year), &(dt->month),
+                 &(dt->day), &(dt->hour),
+                 &(dt->minute),
+                 &(dt->second)) != 6)
+      {
+       /*
+        * Unable to read numbers, free the data
+        * structure and return an error...
+        */
+
+        free(dt);
+
+        return (-1);
+      }
+
+     /*
+      * Range check values...
+      */
+
+      if (dt->month < 1 || dt->month > 12 ||
+          dt->day < 1 || dt->day > 31 ||
+          dt->hour < 0 || dt->hour > 23 ||
+          dt->minute < 0 || dt->minute > 59 ||
+          dt->second < 0 || dt->second > 59)
+      {
+       /*
+        * Date information is out of range...
+        */
+
+        free(dt);
+
+        return (-1);
+      }
+
+     /*
+      * Convert ISO time to UNIX time in
+      * seconds...
+      */
+
+      tmdata.tm_year = dt->year - 1900;
+      tmdata.tm_mon  = dt->month - 1;
+      tmdata.tm_day  = dt->day;
+      tmdata.tm_hour = dt->hour;
+      tmdata.tm_min  = dt->minute;
+      tmdata.tm_sec  = dt->second;
+
+      dt->unix = gmtime(&amp;tmdata);
+
+     /*
+      * Assign custom node data and destroy
+      * function pointers...
+      */
+
+      node->value.custom.data    = dt;
+      node->value.custom.destroy = free;
+
+     /*
+      * Return with no errors...
+      */
+
+      return (0);
+    }
+</pre>
+
+<p>The function itself can return 0 on success or -1 if it is
+unable to decode the custom data or the data contains an error.
+Custom data nodes contain a <tt>void</tt> pointer to the
+allocated custom data for the node and a pointer to a destructor
+function which will free the custom data when the node is
+deleted.</p>
+
+<p>The save callback receives the node pointer and returns an
+allocated string containing the custom data value. The following
+save callback could be used for our ISO date/time type:</p>
+
+<pre>
+    char *
+    save_custom(mxml_node_t *node)
+    {
+      char data[255];
+      iso_date_time_t *dt;
+
+
+      dt = (iso_date_time_t *)node->custom.data;
+
+      snprintf(data, sizeof(data),
+               "%04u-%02u-%02uT%02u:%02u:%02uZ",
+               dt->year, dt->month, dt->day,
+               dt->hour, dt->minute, dt->second);
+
+      return (strdup(data));
+    }
+</pre>
+
+<p>You register the callback functions using the <a
+href='#mxmlSetCustomHandlers'><tt>mxmlSetCustomHandlers()</tt></a>
+function:</p>
+
+<pre>
+    mxmlSetCustomHandlers(<b>load_custom</b>,
+                          <b>save_custom</b>);
+</pre>
+
+
+<!-- NEED 20 -->
+<h2>Changing Node Values</h2>
+
+<p>All of the examples so far have concentrated on creating and
+loading new XML data nodes. Many applications, however, need to
+manipulate or change the nodes during their operation, so
+Mini-XML provides functions to change node values safely and
+without leaking memory.</p>
+
+<p>Existing nodes can be changed using the <a
+href='#mxmlSetElement'><tt>mxmlSetElement()</tt></a>, <a
+href='#mxmlSetInteger'><tt>mxmlSetInteger()</tt></a>, <a
+href='#mxmlSetOpaque'><tt>mxmlSetOpaque()</tt></a>, <a
+href='#mxmlSetReal'><tt>mxmlSetReal()</tt></a>, <a
+href='#mxmlSetText'><tt>mxmlSetText()</tt></a>, and <a
+href='#mxmlSetTextf'><tt>mxmlSetTextf()</tt></a> functions. For
+example, use the following function call to change a text node
+to contain the text "new" with leading whitespace:</p>
+
+<pre>
+    mxml_node_t *node;
+
+    mxmlSetText(node, 1, "new");
+</pre>
+
+
+<h2>Formatted Text</h2>
+
+<p>The <a href='#mxmlNewTextf'><tt>mxmlNewTextf()</tt></a> and <a
+href='#mxmlSetTextf'><tt>mxmlSetTextf()</tt></a> functions create
+and change text nodes, respectively, using <tt>printf</tt>-style
+format strings and arguments. For example, use the following
+function call to create a new text node containing a constructed
+filename:</p>
+
+<pre>
+    mxml_node_t</a> *node;
+
+    node = mxmlNewTextf(node, 1, "%s/%s",
+                        path, filename);
+</pre>
+
+
+<h2>Indexing</h2>
+
+<p>Mini-XML provides functions for managing indices of nodes.
+The current implementation provides the same functionality as
+<a href='#mxmlFindElement'><tt>mxmlFindElement()</tt></a>.
+The advantage of using an index is that searching and
+enumeration of elements is significantly faster. The only
+disadvantage is that each index is a static snapshot of the XML
+document, so indices are not well suited to XML data that is
+updated more often than it is searched. The overhead of creating
+an index is approximately equal to walking the XML document
+tree. Nodes in the index are sorted by element name and
+attribute value.</p>
+
+<p>Indices are stored in <a
+href='#mxml_index_t'><tt>mxml_index_t</tt></a> structures. The
+<a href='#mxmlIndexNew'><tt>mxmlIndexNew()</tt></a> function
+creates a new index:</p>
+
+<pre>
+    mxml_node_t *tree;
+    mxml_index_t *ind;
+
+    ind = mxmlIndexNew(tree, "element",
+                       "attribute");
+</pre>
+
+<p>The first argument is the XML node tree to index. Normally this
+will be a pointer to the <tt>?xml</tt> element.</p>
+
+<p>The second argument contains the element to index; passing
+<tt>NULL</tt> indexes all element nodes alphabetically.</p>
+
+<p>The third argument contains the attribute to index; passing
+<tt>NULL</tt> causes only the element name to be indexed.</p>
+
+<p>Once the index is created, the <a
+href='#mxmlIndexEnum'><tt>mxmlIndexEnum()</tt></a>,  <a
+href='#mxmlIndexFind'><tt>mxmlIndexFind()</tt></a>, and  <a
+href='#mxmlIndexReset'><tt>mxmlIndexReset()</tt></a> functions
+are used to access the nodes in the index. The <a
+href='#mxmlIndexReset'><tt>mxmlIndexReset()</tt></a> function
+resets the "current" node pointer in the index, allowing you to
+do new searches and enumerations on the same index. Typically
+you will call this function prior to your calls to <a
+href='#mxmlIndexEnum'><tt>mxmlIndexEnum()</tt></a> and <a
+href='#mxmlIndexFind'><tt>mxmlIndexFind()</tt></a>.</p>
+
+<p>The <a href='#mxmlIndexEnum'><tt>mxmlIndexEnum()</tt></a>
+function enumerates each of the nodes in the index and can be
+used in a loop as follows:</p>
+
+<pre>
+    mxml_node_t *node;
+
+    mxmlIndexReset(ind);
+
+    while ((node = mxmlIndexEnum(ind)) != NULL)
+    {
+      // do something with node
+    }
+</pre>
+
+<p>The <a href='#mxmlIndexFind'><tt>mxmlIndexFind()</tt></a>
+function locates the next occurrence of the named element and
+attribute value in the index. It can be used to find all
+matching elements in an index, as follows:</p>
+
+<pre>
+    mxml_node_t *node;
+
+    mxmlIndexReset(ind);
+
+    while ((node = mxmlIndexFind(ind, "element",
+                                 "attr-value"))
+                != NULL)
+    {
+      // do something with node
+    }
+</pre>
+
+<p>The second and third arguments represent the element name and
+attribute value, respectively. A <tt>NULL</tt> pointer is used
+to return all elements or attributes in the index. Passing
+<tt>NULL</tt> for both the element name and attribute value
+is equivalent to calling <tt>mxmlIndexEnum</tt>.</p>
+
+<p>When you are done using the index, delete it using the
+<a href='#mxmlIndexDelete()'><tt>mxmlIndexDelete()</tt></a>
+function:</p>
+
+<pre>
+    mxmlIndexDelete(ind);
+</pre>
+
+<h2>SAX (Stream) Loading of Documents</h2>
+
+<p>Mini-XML supports an implementation of the Simple API for XML
+(SAX) which allows you to load and process an XML document as a
+stream of nodes. Aside from allowing you to process XML documents of
+any size, the Mini-XML implementation also allows you to retain
+portions of the document in memory for later processing.</p>
+
+<p>The <a href='#mxmlSAXLoad'><tt>mxmlSAXLoadFd</tt></a>, <a
+href='#mxmlSAXLoadFile'><tt>mxmlSAXLoadFile</tt></a>, and <a
+href='#mxmlSAXLoadString'><tt>mxmlSAXLoadString</tt></a> functions
+provide the SAX loading APIs. Each function works like the
+corresponding <tt>mxmlLoad</tt> function but uses a callback to
+process each node as it is read.</p>
+
+<p>The callback function receives the node, an event code, and
+a user data pointer you supply:</p>
+
+<pre>
+    void
+    sax_cb(mxml_node_t *node,
+           mxml_sax_event_t event,
+           void *data)
+    {
+      ... do something ...
+    }
+</pre>
+
+<p>The event will be one of the following:</p>
+
+<ul>
+
+	<li><tt>MXML_SAX_CDATA</tt> - CDATA was just read</li>
+
+	<li><tt>MXML_SAX_COMMENT</tt> - A comment was just read</li>
+
+	<li><tt>MXML_SAX_DATA</tt> - Data (custom, integer, opaque, real, or text) was just read</li>
+
+	<li><tt>MXML_SAX_DIRECTIVE</tt> - A processing directive was just read</li>
+
+	<li><tt>MXML_SAX_ELEMENT_CLOSE</tt> - A close element was just read (<tt>&lt;/element&gt;</tt>)</li>
+
+	<li><tt>MXML_SAX_ELEMENT_OPEN</tt> - An open element was just read (<tt>&lt;element&gt;</tt>)</li>
+
+</ul>
+
+<p>Elements are <em>released</em> after the close element is
+processed. All other nodes are released after they are processed.
+The SAX callback can <em>retain</em> the node using the <a
+href='#mxmlRetain'><tt>mxmlRetain</tt></a> function. For example,
+the following SAX callback will retain all nodes, effectively
+simulating a normal in-memory load:</p>
+
+<pre>
+    void
+    sax_cb(mxml_node_t *node,
+           mxml_sax_event_t event,
+           void *data)
+    {
+      if (event != MXML_SAX_ELEMENT_CLOSE)
+        mxmlRetain(node);
+    }
+</pre>
+
+<p>More typically the SAX callback will only retain a small portion
+of the document that is needed for post-processing. For example, the
+following SAX callback will retain the title and headings in an
+XHTML file. It also retains the (parent) elements like <tt>&lt;html&gt;</tt>, <tt>&lt;head&gt;</tt>, and <tt>&lt;body&gt;</tt>, and processing
+directives like  <tt>&lt;?xml ... ?&gt;</tt> and  <tt>&lt;!DOCTYPE ... &gt;</tt>:</p>
+
+<!-- NEED 10 -->
+<pre>
+    void
+    sax_cb(mxml_node_t *node,
+           mxml_sax_event_t event,
+           void *data)
+    {
+      if (event == MXML_SAX_ELEMENT_OPEN)
+      {
+       /*
+        * Retain headings and titles...
+        */
+
+        char *name = node->value.element.name;
+
+        if (!strcmp(name, "html") ||
+            !strcmp(name, "head") ||
+            !strcmp(name, "title") ||
+            !strcmp(name, "body") ||
+            !strcmp(name, "h1") ||
+            !strcmp(name, "h2") ||
+            !strcmp(name, "h3") ||
+            !strcmp(name, "h4") ||
+            !strcmp(name, "h5") ||
+            !strcmp(name, "h6"))
+          mxmlRetain(node);
+      }
+      else if (event == MXML_SAX_DIRECTIVE)
+        mxmlRetain(node);
+      else if (event == MXML_SAX_DATA &amp;&amp;
+               node->parent->ref_count > 1)
+      {
+       /*
+        * If the parent was retained, then retain
+        * this data node as well.
+        */
+
+        mxmlRetain(node);
+      }
+    }
+</pre>
+
+<p>The resulting skeleton document tree can then be searched just
+like one loaded using the <tt>mxmlLoad</tt> functions. For example,
+a filter that reads an XHTML document from stdin and then shows the
+title and headings in the document would look like:</p>
+
+<pre>
+    mxml_node_t *doc, *title, *body, *heading;
+
+    doc = mxmlSAXLoadFd(NULL, 0,
+                        MXML_TEXT_CALLBACK,
+                        <b>sax_cb</b>, NULL);
+
+    title = mxmlFindElement(doc, doc, "title",
+                            NULL, NULL,
+                            MXML_DESCEND);
+
+    if (title)
+      print_children(title);
+
+    body = mxmlFindElement(doc, doc, "body",
+                           NULL, NULL,
+                           MXML_DESCEND);
+
+    if (body)
+    {
+      for (heading = body->child;
+           heading;
+           heading = heading->next)
+        print_children(heading);
+    }
+</pre>
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/basics.html mxml-2.6-haiku/doc/basics.html
--- mxml-2.6/doc/basics.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/basics.html	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,526 @@
+<html>
+<body>
+
+<h1 align='right'><a name='BASICS'><img src="2.gif" align="right"
+hspace="10" width="100" height="100" alt="2"></a>Getting Started
+with Mini-XML</h1>
+
+<p>This chapter describes how to write programs that use Mini-XML to
+access data in an XML file. Mini-XML provides the following
+functionality:</p>
+
+<ul>
+
+	<li>Functions for creating and managing XML documents
+	in memory.</li>
+
+	<li>Reading of UTF-8 and UTF-16 encoded XML files and
+	strings.</li>
+
+	<li>Writing of UTF-8 encoded XML files and strings.</li>
+
+	<li>Support for arbitrary element names, attributes, and
+	attribute values with no preset limits, just available
+	memory.</li>
+
+	<li>Support for integer, real, opaque ("cdata"), and text
+	data types in "leaf" nodes.</li>
+
+	<li>"Find", "index", and "walk" functions for easily
+	accessing data in an XML document.</li>
+
+</ul>
+
+<p>Mini-XML doesn't do validation or other types of processing
+on the data based upon schema files or other sources of
+definition information, nor does it support character entities
+other than those required by the XML specification.</p>
+
+
+<h2>The Basics</h2>
+
+<p>Mini-XML provides a single header file which you include:</p>
+
+<pre>
+    #include &lt;mxml.h&gt;
+</pre>
+
+<p>The Mini-XML library is included with your program using the
+<kbd>-lmxml</kbd> option:</p>
+
+<pre>
+    <kbd>gcc -o myprogram myprogram.c -lmxml ENTER</kbd>
+</pre>
+
+<p>If you have the <tt>pkg-config(1)</tt> software installed,
+you can use it to determine the proper compiler and linker options
+for your installation:</p>
+
+<pre>
+    <kbd>pkg-config --cflags mxml ENTER</kbd>
+    <kbd>pkg-config --libs mxml ENTER</kbd>
+</pre>
+
+<h2>Nodes</h2>
+
+<p>Every piece of information in an XML file (elements, text,
+numbers) is stored in memory in "nodes". Nodes are defined by
+the <a
+href='#mxml_node_t'><tt>mxml_node_t</tt></a>
+structure. The <a
+href='#mxml_type_t'><tt>type</tt></a> member
+defines the node type (element, integer, opaque, real, or text)
+which determines which value you want to look at in the <a
+href='#mxml_value_t'><tt>value</tt></a> union.</p>
+
+<!-- NEED 10 -->
+<center><table width="80%" border="1" cellpadding="5" cellspacing="0" summary="Mini-XML Node Value Members">
+<caption align="bottom"><i>Table 2-1: Mini-XML Node Value Members</i></caption>
+<tr bgcolor="#cccccc">
+	<th>Value</th>
+	<th>Type</th>
+	<th>Node member</th>
+</tr>
+<tr>
+	<td>Custom</td>
+	<td><tt>void *</tt></td>
+	<td><tt>node-&gt;value.custom.data</tt></td>
+</tr>
+<tr>
+	<td>Element</td>
+	<td><tt>char *</tt></td>
+	<td><tt>node-&gt;value.element.name</tt></td>
+</tr>
+<tr>
+	<td>Integer</td>
+	<td><tt>int</tt></td>
+	<td><tt>node-&gt;value.integer</tt></td>
+</tr>
+<tr>
+	<td>Opaque (string)</td>
+	<td><tt>char *</tt></td>
+	<td><tt>node-&gt;value.opaque</tt></td>
+</tr>
+<tr>
+	<td>Real</td>
+	<td><tt>double</tt></td>
+	<td><tt>node-&gt;value.real</tt></td>
+</tr>
+<tr>
+	<td>Text</td>
+	<td><tt>char *</tt></td>
+	<td><tt>node-&gt;value.text.string</tt></td>
+</tr>
+</table></center>
+
+<p>Each node also has a <tt>user_data</tt> member which allows you
+to associate application-specific data with each node as needed.</p>
+
+<p>New nodes are created using the <a
+href='#mxmlNewElement'><tt>mxmlNewElement</tt></a>, <a
+href='#mxmlNewInteger'><tt>mxmlNewInteger</tt></a>, <a
+href='#mxmlNewOpaque'><tt>mxmlNewOpaque</tt></a>, <a
+href='#mxmlNewReal'><tt>mxmlNewReal</tt></a>, <a
+href='#mxmlNewText'><tt>mxmlNewText</tt></a> <a
+href='#mxmlNewTextf'><tt>mxmlNewTextf</tt></a> <a
+href='#mxmlNewXML'><tt>mxmlNewXML</tt></a> functions. Only
+elements can have child nodes, and the top node must be an element,
+usually the <tt>&lt;?xml version="1.0"?&gt;</tt> node created by
+<tt>mxmlNewXML()</tt>.</p>
+
+<p>Nodes have pointers to the node above (<tt>parent</tt>), below
+(<tt>child</tt>), left (<tt>prev</tt>), and  right (<tt>next</tt>)
+of the current node. If you have an XML file like the following:</p>
+
+<pre>
+    &lt;?xml version="1.0"?&gt;
+    &lt;data&gt;
+        &lt;node&gt;val1&lt;/node&gt;
+        &lt;node&gt;val2&lt;/node&gt;
+        &lt;node&gt;val3&lt;/node&gt;
+        &lt;group&gt;
+            &lt;node&gt;val4&lt;/node&gt;
+            &lt;node&gt;val5&lt;/node&gt;
+            &lt;node&gt;val6&lt;/node&gt;
+        &lt;/group&gt;
+        &lt;node&gt;val7&lt;/node&gt;
+        &lt;node&gt;val8&lt;/node&gt;
+    &lt;/data&gt;
+</pre>
+
+<p>the node tree for the file would look like the following in
+memory:</p>
+
+<pre>
+    ?xml
+      |
+    data
+      |
+    node - node - node - group - node - node
+      |      |      |      |       |      |
+    val1   val2   val3     |     val7   val8
+                           |
+                         node - node - node
+                           |      |      |
+                         val4   val5   val6
+</pre>
+
+<p>where "-" is a pointer to the next node and "|" is a pointer
+to the first child node.</p>
+
+<p>Once you are done with the XML data, use the <a
+href='#mxmlDelete'><tt>mxmlDelete</tt></a> function to recursively
+free the memory that is used for a particular node or the entire
+tree:</p>
+
+<pre>
+    mxmlDelete(tree);
+</pre>
+
+<!-- NEW PAGE -->
+<h2>Creating XML Documents</h2>
+
+<p>You can create and update XML documents in memory using the
+various <tt>mxmlNew</tt> functions. The following code will
+create the XML document described in the previous section:</p>
+
+<pre>
+    mxml_node_t *xml;    /* &lt;?xml ... ?&gt; */
+    mxml_node_t *data;   /* &lt;data&gt; */
+    mxml_node_t *node;   /* &lt;node&gt; */
+    mxml_node_t *group;  /* &lt;group&gt; */
+
+    xml = mxmlNewXML("1.0");
+
+    data = mxmlNewElement(xml, "data");
+
+        node = mxmlNewElement(data, "node");
+        mxmlNewText(node, 0, "val1");
+        node = mxmlNewElement(data, "node");
+        mxmlNewText(node, 0, "val2");
+        node = mxmlNewElement(data, "node");
+        mxmlNewText(node, 0, "val3");
+
+        group = mxmlNewElement(data, "group");
+
+            node = mxmlNewElement(group, "node");
+            mxmlNewText(node, 0, "val4");
+            node = mxmlNewElement(group, "node");
+            mxmlNewText(node, 0, "val5");
+            node = mxmlNewElement(group, "node");
+            mxmlNewText(node, 0, "val6");
+
+        node = mxmlNewElement(data, "node");
+        mxmlNewText(node, 0, "val7");
+        node = mxmlNewElement(data, "node");
+        mxmlNewText(node, 0, "val8");
+</pre>
+
+<p>We start by creating the <tt>&lt;?xml version="1.0"?&gt;</tt>
+node common to all XML files using the <a
+href="#mxmlNewXML"><tt>mxmlNewXML</tt></a> function:</p>
+
+<pre>
+    xml = mxmlNewXML("1.0");
+</pre>
+
+<p>We then create the <tt>&lt;data&gt;</tt> node used for this
+document using the <a
+href="#mxmlNewElement"><tt>mxmlNewElement</tt></a> function. The
+first argument specifies the parent node (<tt>xml</tt>) while the
+second specifies the element name (<tt>data</tt>):</p>
+
+<pre>
+    data = mxmlNewElement(xml, "data");
+</pre>
+
+<p>Each <tt>&lt;node&gt;...&lt;/node&gt;</tt> in the file is
+created using the <tt>mxmlNewElement</tt> and <a
+href="#mxmlNewText"><tt>mxmlNewText</tt></a> functions. The first
+argument of <tt>mxmlNewText</tt> specifies the parent node
+(<tt>node</tt>). The second argument specifies whether whitespace
+appears before the text - 0 or false in this case. The last
+argument specifies the actual text to add:</p>
+
+<pre>
+    node = mxmlNewElement(data, "node");
+    mxmlNewText(node, 0, "val1");
+</pre>
+
+<p>The resulting in-memory XML document can then be saved or
+processed just like one loaded from disk or a string.</p>
+
+<!-- NEW PAGE -->
+<h2>Loading XML</h2>
+
+<p>You load an XML file using the <a
+href='#mxmlLoadFile'><tt>mxmlLoadFile</tt></a>
+function:</p>
+
+<pre>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen("filename.xml", "r");
+    tree = mxmlLoadFile(NULL, fp,
+                        MXML_TEXT_CALLBACK);
+    fclose(fp);
+</pre>
+
+<p>The first argument specifies an existing XML parent node, if
+any. Normally you will pass <tt>NULL</tt> for this argument
+unless you are combining multiple XML sources. The XML file must
+contain a complete XML document including the <tt>?xml</tt>
+element if the parent node is <tt>NULL</tt>.</p>
+
+<p>The second argument specifies the stdio file to read from, as
+opened by <tt>fopen()</tt> or <tt>popen()</tt>. You can also use
+<tt>stdin</tt> if you are implementing an XML filter
+program.</p>
+
+<p>The third argument specifies a callback function which returns
+the value type of the immediate children for a new element node:
+<tt>MXML_CUSTOM</tt>, <tt>MXML_IGNORE</tt>,
+<tt>MXML_INTEGER</tt>, <tt>MXML_OPAQUE</tt>, <tt>MXML_REAL</tt>,
+or <tt>MXML_TEXT</tt>. Load callbacks are described in detail in
+<a href='#LOAD_CALLBACKS'>Chapter 3</a>. The example code uses
+the <tt>MXML_TEXT_CALLBACK</tt> constant which specifies that all
+data nodes in the document contain whitespace-separated text
+values. Other standard callbacks include
+<tt>MXML_IGNORE_CALLBACK</tt>, <tt>MXML_INTEGER_CALLBACK</tt>,
+<tt>MXML_OPAQUE_CALLBACK</tt>, and 
+<tt>MXML_REAL_CALLBACK</tt>.</p>
+
+<p>The <a href='#mxmlLoadString'><tt>mxmlLoadString</tt></a>
+function loads XML node trees from a string:</p>
+
+<!-- NEED 10 -->
+<pre>
+    char buffer[8192];
+    mxml_node_t *tree;
+
+    ...
+    tree = mxmlLoadString(NULL, buffer,
+                          MXML_TEXT_CALLBACK);
+</pre>
+
+<p>The first and third arguments are the same as used for
+<tt>mxmlLoadFile()</tt>. The second argument specifies the
+string or character buffer to load and must be a complete XML
+document including the <tt>?xml</tt> element if the parent node
+is <tt>NULL</tt>.</p>
+
+
+<!-- NEW PAGE -->
+<h2>Saving XML</h2>
+
+<p>You save an XML file using the <a
+href='#mxmlSaveFile'><tt>mxmlSaveFile</tt></a> function:</p>
+
+<pre>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen("filename.xml", "w");
+    mxmlSaveFile(tree, fp, MXML_NO_CALLBACK);
+    fclose(fp);
+</pre>
+
+<p>The first argument is the XML node tree to save. It should
+normally be a pointer to the top-level <tt>?xml</tt> node in
+your XML document.</p>
+
+<p>The second argument is the stdio file to write to, as opened
+by <tt>fopen()</tt> or <tt>popen()</tt>. You can also use
+<tt>stdout</tt> if you are implementing an XML filter
+program.</p>
+
+<p>The third argument is the whitespace callback to use when
+saving the file. Whitespace callbacks are covered in detail in <a
+href='SAVE_CALLBACKS'>Chapter 3</a>. The previous example code
+uses the <tt>MXML_NO_CALLBACK</tt> constant to specify that no
+special whitespace handling is required.</p>
+
+<p>The <a
+href='#mxmlSaveAllocString'><tt>mxmlSaveAllocString</tt></a>,
+and <a href='#mxmlSaveString'><tt>mxmlSaveString</tt></a>
+functions save XML node trees to strings:</p>
+
+<pre>
+    char buffer[8192];
+    char *ptr;
+    mxml_node_t *tree;
+
+    ...
+    mxmlSaveString(tree, buffer, sizeof(buffer),
+                   MXML_NO_CALLBACK);
+
+    ...
+    ptr = mxmlSaveAllocString(tree, MXML_NO_CALLBACK);
+</pre>
+
+<p>The first and last arguments are the same as used for
+<tt>mxmlSaveFile()</tt>. The <tt>mxmlSaveString</tt> function
+takes pointer and size arguments for saving the XML document to
+a fixed-size buffer, while <tt>mxmlSaveAllocString()</tt>
+returns a string buffer that was allocated using
+<tt>malloc()</tt>.</p>
+
+<h3>Controlling Line Wrapping</h3>
+
+<p>When saving XML documents, Mini-XML normally wraps output
+lines at column 75 so that the text is readable in terminal
+windows. The <a
+href='#mxmlSetWrapMargin'><tt>mxmlSetWrapMargin</tt></a> function
+overrides the default wrap margin:</p>
+
+<pre>
+    /* Set the margin to 132 columns */
+    mxmlSetWrapMargin(132);
+
+    /* Disable wrapping */
+    mxmlSetWrapMargin(0);
+</pre>
+
+
+<!-- NEW PAGE-->
+<h2>Finding and Iterating Nodes</h2>
+
+<p>The <a
+href='#mxmlWalkPrev'><tt>mxmlWalkPrev</tt></a>
+and <a
+href='#mxmlWalkNext'><tt>mxmlWalkNext</tt></a>functions
+can be used to iterate through the XML node tree:</p>
+
+<pre>
+    mxml_node_t *node;
+    
+    node = mxmlWalkPrev(current, tree,
+                        MXML_DESCEND);
+
+    node = mxmlWalkNext(current, tree,
+                        MXML_DESCEND);
+</pre>
+
+<p>In addition, you can find a named element/node using the <a
+href='#mxmlFindElement'><tt>mxmlFindElement</tt></a>
+function:</p>
+
+<pre>
+    mxml_node_t *node;
+    
+    node = mxmlFindElement(tree, tree, "name",
+                           "attr", "value",
+                           MXML_DESCEND);
+</pre>
+
+<p>The <tt>name</tt>, <tt>attr</tt>, and <tt>value</tt>
+arguments can be passed as <tt>NULL</tt> to act as wildcards,
+e.g.:</p>
+
+<!-- NEED 4 -->
+<pre>
+    /* Find the first "a" element */
+    node = mxmlFindElement(tree, tree, "a",
+                           NULL, NULL,
+                           MXML_DESCEND);
+</pre>
+<!-- NEED 5 -->
+<pre>
+    /* Find the first "a" element with "href"
+       attribute */
+    node = mxmlFindElement(tree, tree, "a",
+                           "href", NULL,
+                           MXML_DESCEND);
+</pre>
+<!-- NEED 6 -->
+<pre>
+    /* Find the first "a" element with "href"
+       to a URL */
+    node = mxmlFindElement(tree, tree, "a",
+                           "href",
+                           "http://www.easysw.com/",
+                           MXML_DESCEND);
+</pre>
+<!-- NEED 5 -->
+<pre>
+    /* Find the first element with a "src"
+       attribute */
+    node = mxmlFindElement(tree, tree, NULL,
+                           "src", NULL,
+                           MXML_DESCEND);
+</pre>
+<!-- NEED 5 -->
+<pre>
+    /* Find the first element with a "src"
+       = "foo.jpg" */
+    node = mxmlFindElement(tree, tree, NULL,
+                           "src", "foo.jpg",
+                           MXML_DESCEND);
+</pre>
+
+<p>You can also iterate with the same function:</p>
+
+<pre>
+    mxml_node_t *node;
+
+    for (node = mxmlFindElement(tree, tree,
+                                "name",
+                                NULL, NULL,
+                                MXML_DESCEND);
+         node != NULL;
+         node = mxmlFindElement(node, tree,
+                                "name",
+                                NULL, NULL,
+                                MXML_DESCEND))
+    {
+      ... do something ...
+    }
+</pre>
+
+<!-- NEED 10 -->
+<p>The <tt>MXML_DESCEND</tt> argument can actually be one of
+three constants:</p>
+
+<ul>
+
+	<li><tt>MXML_NO_DESCEND</tt> means to not to look at any
+	child nodes in the element hierarchy, just look at
+	siblings at the same level or parent nodes until the top
+	node or top-of-tree is reached.
+
+        <p>The previous node from "group" would be the "node"
+        element to the left, while the next node from "group" would
+        be the "node" element to the right.<br><br></p></li>
+
+        <li><tt>MXML_DESCEND_FIRST</tt> means that it is OK to
+        descend to the first child of a node, but not to descend
+        further when searching. You'll normally use this when
+        iterating through direct children of a parent node, e.g. all
+        of the "node" and "group" elements under the "?xml" parent
+        node in the example above.
+
+        <p>This mode is only applicable to the search function; the
+        walk functions treat this as <tt>MXML_DESCEND</tt> since
+        every call is a first time.<br><br></p></li>
+
+        <li><tt>MXML_DESCEND</tt> means to keep descending until
+        you hit the bottom of the tree. The previous node from
+        "group" would be the "val3" node and the next node would
+        be the first node element under "group".
+
+        <p>If you were to walk from the root node "?xml" to the end
+        of the tree with <tt>mxmlWalkNext()</tt>, the order would
+        be:</p>
+
+        <p><tt>?xml data node val1 node val2 node val3 group node
+        val4 node val5 node val6 node val7 node val8</tt></p>
+
+	<p>If you started at "val8" and walked using
+	<tt>mxmlWalkPrev()</tt>, the order would be reversed,
+	ending at "?xml".</p></li>
+
+</ul>
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/chapters.xcf.gz mxml-2.6-haiku/doc/chapters.xcf.gz
--- mxml-2.6/doc/chapters.xcf.gz	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/chapters.xcf.gz	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,26 @@
+      Y	xLI		$'$8Z)A>UHBVkkom+]VPZm+m-V6t.6`Epfr}{_7UU:ct Mu3coG@+1n<`j}}wwG&ORcLgw:W1YquM6vo\1Ujuu7,4lXohG0	\zO-/omY[?s^}MVmy=3F23c<xG_x8{D3"1q.9?/-nmcJs}m7/jHVs;75JC]c}5*V[7oZOG8u{]ksK/nhXMp=cnsUy=a41[.`bGXzhg]5h,Y<`7[h=33wfD>](}zka_f6Tq7Y	#LeE%39fjvcLE}Z)2SY[v7LU>h&JXq)L~L4q
+0f2W
+SLlRvS	[L)a|Sm&05gT3 ZSk1U&dzIBG^[O3L-f:c<gpN:X=\|
+7x"? +)DoNkxWub
+R~:x8W"z 	b4ug?[ov?vy3rXv|aJY<WRk143a(3L|Fz&<uQ5"R,&zcGLt$4f,0y0hr-w=5t33h\tih4]7o Sa$*T9RcZ%S/RS\)V,CzS2fMJ#LQ+fUX%K3tnr?0z-P#l"Y9F=4@ D(=F 9ns^mA\/rgt%`fJr4+0C>/
+w@ufGh1bc2in?s(LE~)B>K6J"NAQEPhb4Er fa[Qez/`:*v3uL?F+|A
+HwP`:\^ =dR8-t~I>XI ,~z+Y
+u?R}98,F,;{M|poJ0Sz2i:{#6&g\YOGQ!1dtja&ivco2H#>"mT@1+8'A %83)i^eNyF.mk398=/O:9up&@QX-/;Lwk ,kc,MXWHGs-nq?EVKC.AQ/HAtHS4 /V4viQ5HsH~MEC2m9a),2}9Rbba4$H}.?/LoyS2,,qML+zEPKq):J}Es(ESc:))EQ	(8/\)H^~s:XMoV>Fz&>$-p"ROIq<\1j5mawy-,H43=PN?_)6d*cQnzou;v{eKn'DXMLjt].* T=SF	@e>ktXPY/C60}:4W;h_O9;(q tPAlvp <7WY#|>w Na g$4_e`)\@d}V}N ?I]1o0mVGOF )WD@=]:K,?Cw7zFWA!P '=5~(1znpz-Xjg:Xp^q rqO:79qpF WeZv:u!	GB$9wSAp
+Kdx
+du/F1$~.Q3Q6e#$,$ydl9r OgKq*,T15$[TOlP#WA]jAt);:J)/C'W`"J RaIb|yI{Tb:>VG!iffTe^wTM/.X=gK9rmGLiaiM{aEm|D}	kld[.II Kb~c %D^]E<o1g^y_w-Y^>j~g:Ll<on`f
+w8i65,~('yufmgDT_WSs(Un_;vdw7^qQ `f]1iy	!YYj XD38"F>="zTS=_v:NXe@N4?2|rdFAfzAbj{		':N Zs#
+*Ne!VU ?(#fD#k"g@b7#gw~so2{/2mt8&cM>?CM&U>Xho3V}Z+A^Eb8fnXFOZ3x:o2j.xw,`yf5<#__yQ^F=*Ly	4^F
+(|]|2/Go2yOD]+9rH:Ws|*jh5gr,y9	^y]=sx[C!Rz9k,yF?	.,d@-k X<G3,|.A# Gf^$rPN'`"2|>]_c}];/ %8S+,	Nl9y>LJpz`'VY,^Y"T#L=\9YIY!92.e+e$Nj	N/S%q,k$q:KJpzYItL bY/i25]es,!s3%8#%8=RnQY-gKM8 y@F 2s@AB 2-r.A3 G $AZ@v:N8 P]_`"N/t"]5BLd	tGNJ',PK8Ar*J8+!JqB	pLp-&ZIQ!l]T	t|1UMFVMNEzQ@WO.S hf[I1CPQ.f
+p[4
+^!f	pz-E+q*	V Sq q*,:-kwM T#vP NEA8`N|}_k/Db]W-l)N\//8 EDYaI4'2JkZ]Hi|0/fW?*F>Tx{4<"G]M:` Dk3y\)*O.^,ZG^pt/{ly(d\.,K${k{wQM`-k%Z;Bisi(Vcu3*s,G=dsEUmPzy\oV%
+J [U 8P/`8J|SJ3r{"R q9m&q}$K&Lz9;*
+<QK3 XQ|*C7`qp*4j4.ZBA:c:h u\~>I3e;R-=@Hj#U!v*CHCH<HHCJ&v$j/#bTjH5;8oz1CWvbO\&Q	z>z:BHJH`n #bGeL2-RtLi=4FA,Ztp	:]_@.PK,;BPU*iPjeG,;p`peGw;xwpKk-(iz&bG8v=,;C-;6h}_kk2nuWSFBZ<Ir= Hu}R%"J= u}RN"%+:l:96 1(AJ4(AJ4PfAaH	R!%hH	R!%hH	;2Y/0*AJ4*AJ4*aYOjT<Xc^JS\kKq+31zPkFxR^}/ep@%/ 	*.|*<\_`)Odj&Li]#D+	XfW{
+^VNl'
+C 2\-KdjNy_j*p+h#45/v$$<$LJ2xLijV[jJku
+[w{q`X%f
+bXOZ+ DRfZZXLUh~w7D=fYd\J~;sS[1 h!rJ2gS/('}{Ah?q^c]X~
+YjwxN5=`xG#.Rx{2	M0p`A
+fQ0`5)XQ
+VUR^VJ])lNKx{QwLF8xo$X%:	VJVx_&4.N0uL`S(D4JH)_)49);**5]iN}ky_:?@c&s{y>w%IL`bS#wDA;%+n	Kc=rtRO2:lz8QB!1Zh-o29S0'x)7a`:HN|99Hy	?wr	AI6F8/}Ko_<Th%|}}_/[(7<9"x70ow#!	nIpOBruj}+^_j8Vs(}]l_sW>C)JP?XNl2!&E0-AE(`/&}iM_v"4Dk_}9[_,E/C*Pa;T"/Cy_Z?@
+w>
+cd	1  
\ No newline at end of file
diff -Naur mxml-2.6/doc/docset.css mxml-2.6-haiku/doc/docset.css
--- mxml-2.6/doc/docset.css	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/docset.css	2008-11-28 10:56:50.000000000 +0000
@@ -0,0 +1,114 @@
+body {
+  background: white;
+  color: black;
+  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
+}
+
+h1, h2, h3, h4, h5, h6, p, td, th {
+  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
+}
+
+kbd {
+  color: #006600;
+  font-family: monaco, courier, monospace;
+  font-weight: bold;
+}
+
+pre {
+  font-family: monaco, courier, monospace;
+}
+
+pre.example {
+  background: white;
+  border: dotted thin #999999;
+  margin-left: 36pt;
+  padding: 10px;
+}
+
+pre.example em {
+  color: #3f0000;
+  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
+}
+
+div.summary table {
+  border: solid thin #999999;
+  border-collapse: collapse;
+  border-spacing: 0;
+  margin: 10px;
+  width: 33%;
+}
+
+div.summary table td, div.summary table th {
+  background: white;
+  border: solid thin #999999;
+  border-spacing: 0;
+  padding: 5px;
+  text-align: left;
+  vertical-align: top;
+}
+
+div.summary table thead th {
+  background: #f0f0f0;
+}
+
+div.body h1 {
+  margin: 0;
+}
+div.body h2 {
+  margin-top: 1.5em;
+}
+div.body h3, div.body h4, div.body h5 {
+  margin-bottom: 0.5em;
+  margin-top: 1.5em;
+}
+.class, .enumeration, .function, .struct, .typedef, .union {
+  border-bottom: solid thin #999999;
+  margin-bottom: 0;
+  margin-top: 2em;
+}
+.description {
+  margin-top: 0.5em;
+}
+code, p.code, pre, ul.code li {
+  font-family: monaco, courier, monospace;
+  font-size: 90%;
+}
+ul.code, ul.contents, ul.subcontents {
+  list-style-type: none;
+  margin: 0;
+  padding-left: 0;
+}
+ul.code li {
+  margin: 0;
+}
+ul.contents > li {
+  margin-top: 1em;
+}
+ul.contents li ul.code, ul.contents li ul.subcontents {
+  padding-left: 2em;
+}
+div.body dl {
+  margin-left: 0;
+  margin-top: 0;
+}
+div.body dt {
+  font-style: italic;
+  margin-left: 0;
+  margin-top: 0;
+}
+div.body dd {
+  margin-bottom: 0.5em;
+}
+span.info {
+  background: black;
+  border: thin solid black;
+  color: white;
+  font-size: 80%;
+  font-style: italic;
+  font-weight: bold;
+  white-space: nowrap;
+}
+h2 span.info, h3 span.info, h4 span.info {
+  float: right;
+  font-size: 100%;
+}
diff -Naur mxml-2.6/doc/docset.header mxml-2.6-haiku/doc/docset.header
--- mxml-2.6/doc/docset.header	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/docset.header	2008-11-28 10:56:50.000000000 +0000
@@ -0,0 +1,16 @@
+<h1>Mini-XML API Reference</h1>
+
+<div class='summary'><table summary='General Information'>
+<thead>
+<tr>
+	<th>Header</th>
+	<th>mxml.h</th>
+</tr>
+</thead>
+<tbody>
+<tr>
+	<th>Library</th>
+	<td>-lmxml</td>
+</tr>
+</tbody>
+</table></div>
diff -Naur mxml-2.6/doc/docset.intro mxml-2.6-haiku/doc/docset.intro
--- mxml-2.6/doc/docset.intro	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/docset.intro	2008-11-28 10:56:50.000000000 +0000
@@ -0,0 +1,155 @@
+<h2 class='title'><a name='INTRODUCTION'>Introduction</a></h2>
+
+<p>Mini-XML is a small XML parsing library that you can use to read XML and
+XML-like data files in your application without requiring large non-standard
+libraries.  Mini-XML only requires an ANSI C compatible compiler (GCC works,
+as do most vendors' ANSI C compilers) and a "make" program.</p>
+
+<p>Mini-XML provides the following functionality:</p>
+
+<ul>
+
+	<li>Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files
+	and strings.</li>
+
+	<li>Data is stored in a linked-list tree structure, preserving the XML
+	data hierarchy.</li>
+
+	<li>Supports arbitrary element names, attributes, and attribute values
+	with no preset limits, just available memory.</li>
+
+	<li>Supports integer, real, opaque ("cdata"), and text data types in
+	"leaf" nodes.</li>
+
+	<li>Functions for creating, indexing, and managing trees of data.</li>
+
+	<li>"Find" and "walk" functions for easily locating and navigating trees
+	of data.</li>
+
+</ul>
+
+<p>Mini-XML doesn't do validation or other types of processing on the data based
+upon schema files or other sources of definition information, nor does it
+support character entities other than those required by the XML
+specification.</p>
+
+<h2 class='title'><a name='USING'>Using Mini-XML</a></h2>
+
+<p>Mini-XML provides a single header file which you include:</p>
+
+<pre class='example'>
+#include &lt;mxml.h&gt;
+</pre>
+
+<p>Nodes are defined by the "<a href='#mxml_node_s'>mxml_node_t</a>" structure;
+the "type" member defines the node type (element, integer, opaque, real, or
+text) which determines which value you want to look at in the "value" union.
+New nodes can be created using the
+"<a href='#mxmlNewElement'>mxmlNewElement()</a>",
+"<a href='#mxmlNewInteger'>mxmlNewInteger()</a>",
+"<a href='#mxmlNewOpaque'>mxmlNewOpaque()</a>",
+"<a href='#mxmlNewReal'>mxmlNewReal()</a>", and
+"<a href='#mxmlNewText'>mxmlNewText()</a>" functions. Only elements can have
+child nodes, and the top node must be an element, usually "?xml".</p>
+
+<p>You load an XML file using the "mxmlLoadFile()" function:</p>
+
+<pre class='example'>
+FILE *fp;
+mxml_node_t *tree;
+
+fp = fopen("filename.xml", "r");
+tree = mxmlLoadFile(NULL, fp, MXML_NO_CALLBACK);
+fclose(fp);
+</pre>
+
+<p>Similarly, you save an XML file using the
+"<a href='#mxmlSaveFile'>mxmlSaveFile()</a>" function:
+
+<pre class='example'>
+FILE *fp;
+mxml_node_t *tree;
+
+fp = fopen("filename.xml", "w");
+mxmlSaveFile(tree, fp, MXML_NO_CALLBACK);
+fclose(fp);
+</pre>
+
+<p>The "<a href='#mxmlLoadString'>mxmlLoadString()</a>",
+"<a href='#mxmlSaveAllocString'>mxmlSaveAllocString()</a>", and
+"<a href='#mxmlSaveString'>mxmlSaveString()</a>" functions load XML node trees
+from and save XML node trees to strings:</p>
+
+<pre class='example'>
+char buffer[8192];
+char *ptr;
+mxml_node_t *tree;
+
+...
+tree = mxmlLoadString(NULL, buffer, MXML_NO_CALLBACK);
+
+...
+mxmlSaveString(tree, buffer, sizeof(buffer),
+	       MXML_NO_CALLBACK);
+
+...
+ptr = mxmlSaveAllocString(tree, MXML_NO_CALLBACK);
+</pre>
+
+<p>You can find a named element/node using the
+"<a href='#mxmlFindElement'>mxmlFindElement()</a>" function:</p>
+
+<pre class='example'>
+mxml_node_t *node = mxmlFindElement(tree, tree, "name",
+				    "attr", "value",
+				    MXML_DESCEND);
+</pre>
+
+<p>The "name", "attr", and "value" arguments can be passed as
+<code>NULL</code> to act as wildcards, e.g.:</p>
+
+<pre class='example'>
+/* Find the first "a" element */
+node = mxmlFindElement(tree, tree, "a", NULL, NULL,
+		       MXML_DESCEND);
+
+/* Find the first "a" element with "href" attribute */
+node = mxmlFindElement(tree, tree, "a", "href", NULL,
+		       MXML_DESCEND);
+
+/* Find the first "a" element with "href" to a URL */
+node = mxmlFindElement(tree, tree, "a", "href",
+		       "http://www.easysw.com/~mike/mxml/",
+		       MXML_DESCEND);
+
+/* Find the first element with a "src" attribute*/
+node = mxmlFindElement(tree, tree, NULL, "src", NULL,
+		       MXML_DESCEND);
+
+/* Find the first element with a "src" = "foo.jpg" */
+node = mxmlFindElement(tree, tree, NULL, "src",
+		       "foo.jpg", MXML_DESCEND);
+</pre>
+
+<p>You can also iterate with the same function:</p>
+
+<pre class='example'>
+mxml_node_t *node;
+
+for (node = mxmlFindElement(tree, tree, "name", NULL,
+			    NULL, MXML_DESCEND);
+     node != NULL;
+     node = mxmlFindElement(node, tree, "name", NULL,
+			    NULL, MXML_DESCEND))
+{
+  ... do something ...
+}
+</pre>
+
+<p>Finally, once you are done with the XML data, use the
+"<a href='#mxmlDelete'>mxmlDelete()</a>" function to recursively free the
+memory that is used for a particular node or the entire tree:</p>
+
+<pre class='example'>
+mxmlDelete(tree);
+</pre>
diff -Naur mxml-2.6/doc/footer.man mxml-2.6-haiku/doc/footer.man
--- mxml-2.6/doc/footer.man	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/footer.man	2008-01-29 05:28:31.000000000 +0000
@@ -0,0 +1,4 @@
+.SH SEE ALSO
+mxmldoc(1), Mini-XML Programmers Manual, http://www.minixml.org/
+.SH COPYRIGHT
+Copyright 2003-2008 by Michael Sweet.
diff -Naur mxml-2.6/doc/install.html mxml-2.6-haiku/doc/install.html
--- mxml-2.6/doc/install.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/install.html	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,119 @@
+<html>
+<body>
+
+<h1 align='right'><a name='INSTALL'><img src="1.gif" align="right"
+hspace="10" width="100" height="100" alt="1"></a>Building,
+Installing, and Packaging Mini-XML</h1>
+
+<p>This chapter describes how to build, install, and package
+Mini-XML on your system from the source archive. You will need an
+ANSI/ISO-C compatible compiler to build Mini-XML - GCC works, as
+do most vendors' C compilers. If you are building Mini-XML on
+Windows, we recommend using the Visual C++ environment with the
+supplied solution file. For other operating systems, you'll need a
+POSIX-compatible shell and <tt>make</tt> program in addition to
+the C compiler.</p>
+
+<h2>Compiling Mini-XML</h2>
+
+<p>Mini-XML comes with both an autoconf-based configure script
+and a Visual C++ solution that can be used to compile the library
+and associated tools.</p>
+
+<h3>Compiling with Visual C++</h3>
+
+<p>Open the <VAR>mxml.sln</VAR> solution in the <VAR>vcnet</VAR>
+folder. Choose the desired build configuration, "Debug" (the
+default) or "Release", and then choose <VAR>Build Solution</VAR>
+from the <VAR>Build</VAR> menu.</p>
+
+<h3>Compiling with Command-Line Tools</h3>
+
+<p>Type the following command to configure the Mini-XML source
+code for your system:</p>
+
+<pre>
+    <kbd>./configure ENTER</kbd>
+</pre>
+
+<p>The default install prefix is <var>/usr/local</var>, which
+can be overridden using the <kbd>--prefix</kbd> option:</p>
+
+<pre>
+    <kbd>./configure --prefix=/foo ENTER</kbd>
+</pre>
+
+<p>Other configure options can be found using the
+<kbd>--help</kbd> option:</p>
+
+<pre>
+    <kbd>./configure --help ENTER</kbd>
+</pre>
+
+<p>Once you have configured the software, use the
+<tt>make(1)</tt> program to do the build and run the test
+program to verify that things are working, as follows:</p>
+
+<pre>
+    <kbd>make ENTER</kbd>
+</pre>
+
+
+<h2>Installing Mini-XML</h2>
+
+<p>If you are using Visual C++, copy the <VAR>mxml.lib</VAR> and
+and <VAR>mxml.h</VAR> files to the Visual C++ <VAR>lib</VAR> and
+<VAR>include<VAR> directories, respectively.</p>
+
+<p>Otherwise, use the <tt>make</tt> command with the
+<kbd>install</kbd> target to install Mini-XML in the configured
+directories:</p>
+
+<pre>
+    <kbd>make install ENTER</kbd>
+</pre>
+
+
+<h2>Creating Mini-XML Packages</h2>
+
+<p>Mini-XML includes two files that can be used to create binary
+packages. The first file is <var>mxml.spec</var> which is used
+by the <tt>rpmbuild(8)</tt> software to create Red Hat Package
+Manager ("RPM") packages which are commonly used on Linux. Since
+<tt>rpmbuild</tt> wants to compile the software on its own, you
+can provide it with the Mini-XML tar file to build the
+package:</p>
+
+<pre>
+    <kbd>rpmbuild -ta mxml-<i>version</i>.tar.gz ENTER</kbd>
+</pre>
+
+<p>The second file is <var>mxml.list</var> which is used by the
+<tt>epm(1)</tt> program to create software packages in a variety
+of formats. The <tt>epm</tt> program is available from the
+following URL:</p>
+
+<pre>
+    <a href='http://www.easysw.com/epm/'>http://www.easysw.com/epm/</a>
+</pre>
+
+<p>Use the <tt>make</tt> command with the <kbd>epm</kbd> target
+to create portable and native packages for your system:</p>
+
+<pre>
+    <kbd>make epm ENTER</kbd>
+</pre>
+
+<p>The packages are stored in a subdirectory named
+<var>dist</var> for your convenience. The portable packages
+utilize scripts and tar files to install the software on the
+target system. After extracting the package archive, use the
+<var>mxml.install</var> script to install the software.</p>
+
+<p>The native packages will be in the local OS's native format:
+RPM for Red Hat Linux, DPKG for Debian Linux, PKG for Solaris,
+and so forth. Use the corresponding commands to install the
+native packages.</p>
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/intro.html mxml-2.6-haiku/doc/intro.html
--- mxml-2.6/doc/intro.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/intro.html	2009-05-17 06:04:58.000000000 +0000
@@ -0,0 +1,197 @@
+<html>
+<head>
+	<title>Mini-XML Programmers Manual, Version 2.6</title>
+	<meta name='copyright' content='Copyright 2003-2009'>
+	<meta name='author' content='Michael R. Sweet'>
+	<meta name='keywords' content='XML, C, C++, library'>
+</head>
+<body>
+
+<h1 align='right'><a name='INTRO'><img src="0.gif" align="right"
+hspace="10" width="100" height="100" alt="0"></a>Introduction</h1>
+
+<p>This programmers manual describes Mini-XML version 2.6, a small
+XML parsing library that you can use to read and write XML data
+files in your C and C++ applications.</p>
+
+<p>Mini-XML was initially developed for the <a
+href='http://gutenprint.sf.net/'>Gutenprint</a> project to replace
+the rather large and unwieldy <tt>libxml2</tt> library with
+something substantially smaller and easier-to-use. It all began one
+morning in June of 2003 when Robert posted the following sentence to
+the developer's list:</p>
+
+<blockquote><em>It's bad enough that we require libxml2, but rolling
+our own XML parser is a bit more than we can
+handle.</em></blockquote>
+
+<p>I then replied with:</p>
+
+<blockquote><em>Given the limited scope of what you use in XML, it
+should be trivial to code a mini-XML API in a few hundred lines of
+code.</em></blockquote>
+
+<p>I took my own challenge and coded furiously for two days to
+produced the initial public release of Mini-XML, total lines of
+code: 696. Robert promptly integrated Mini-XML into Gutenprint
+and removed libxml2.</p>
+
+<p>Thanks to lots of feedback and support from various
+developers, Mini-XML has evolved since then to provide a more
+complete XML implementation and now stands at a whopping 3,441
+lines of code, compared to 103,893 lines of code for libxml2
+version 2.6.9.</p>
+
+<p>Aside from Gutenprint, Mini-XML is used for the
+following projects/software applications:</p>
+
+<ul>
+
+	<li><a href='http://www.cups.org/'>Common UNIX Printing
+	System</a></li>
+
+	<li><a
+	href='http://zynaddsubfx.sourceforge.net'>ZynAddSubFX</a></li>
+
+</ul>
+
+<p>Please email me (mxml @ easysw . com) if you would like your
+project added or removed from this list, or if you have any
+comments/quotes you would like me to publish about your
+experiences with Mini-XML.</p>
+
+<!-- NEED 1in -->
+<h2>Organization of This Document</h2>
+
+<p>This manual is organized into the following chapters and
+appendices:</p>
+
+<ul>
+
+	<li>Chapter 1, "<a href='#INSTALL'>Building,
+	Installing, and Packaging Mini-XML</a>", provides
+	compilation, installation, and packaging instructions for
+	Mini-XML.</li>
+
+	<li>Chapter 2, "<a href='#BASICS'>Getting
+	Started with Mini-XML</a>", shows how to use the
+	Mini-XML library in your programs.</li>
+
+	<li>Chapter 3, "<a href='#ADVANCED'>More
+	Mini-XML Programming Techniques</a>", shows additional
+	ways to use the Mini-XML library.</li>
+
+	<li>Chapter 4, "<a href='#MXMLDOC'>Using the
+	mxmldoc Utility</a>", describes how to use the
+	<tt>mxmldoc(1)</tt> program to generate software
+	documentation.</li>
+
+        <li>Appendix A, "<a href='#LICENSE'>Mini-XML License</a>",
+        provides the terms and conditions for using and distributing
+        Mini-XML.</li>
+
+	<li>Appendix B, "<a href='#RELNOTES'>Release Notes</a>",
+	lists the changes in each release of Mini-XML.</li>
+
+	<li>Appendix C, "<a href='#REFERENCE'>Library
+	Reference</a>", contains a complete reference for
+	Mini-XML, generated by <tt>mxmldoc</tt>.</li>
+
+	<li>Appendix D, "<a href='#SCHEMA'>XML Schema</a>", shows
+	the XML schema used for the XML files produced by
+	<tt>mxmldoc</tt>.</li>
+
+</ul>
+
+<!-- NEED 10 -->
+<h2>Notation Conventions</h2>
+
+<p>Various font and syntax conventions are used in this guide.
+Examples and their meanings and uses are explained below:</p>
+
+<dl>
+
+	<dt><code>mxmldoc</code><br>
+	<code>mxmldoc(1)</code></dt>
+
+	<dd>The names of commands; the first mention of a command
+	or function in a chapter is followed by a manual page
+	section number.<br><br></dd>
+
+	<dt><var>/var</var><br>
+	<var>/etc/hosts</var></dt>
+
+	<dd>File and directory names.<br><br></dd>
+
+	<dt><tt>Request ID is Printer-123</tt></dt>
+
+	<dd>Screen output.<br><br></dd>
+
+	<dt><kbd>lp -d printer filename ENTER</kbd></dt>
+
+	<dd>Literal user input; special keys like
+	<kbd>ENTER</kbd> are in ALL CAPS.<br><br></dd>
+
+	<dt>12.3</dt>
+
+	<dd>Numbers in the text are written using the period (.)
+	to indicate the decimal point.<br><br></dd>
+
+</dl>
+
+<!-- NEED 10 -->
+<h2>Abbreviations</h2>
+
+<p>The following abbreviations are used throughout this
+manual:</p>
+
+<dl>
+
+	<dt>Gb</dt>
+	<dd>Gigabytes, or 1073741824 bytes<br><br></dd>
+
+	<dt>kb</dt>
+	<dd>Kilobytes, or 1024 bytes<br><br></dd>
+
+	<dt>Mb</dt>
+	<dd>Megabytes, or 1048576 bytes<br><br></dd>
+
+	<dt>UTF-8, UTF-16</dt>
+	<dd>Unicode Transformation Format, 8-bit or 16-bit<br><br></dd>
+
+	<dt>W3C</dt>
+	<dd>World Wide Web Consortium<br><br></dd>
+
+	<dt>XML</dt>
+	<dd>Extensible Markup Language<br><br></dd>
+
+</dl>
+
+<!-- NEED 12 -->
+<h2>Other References</h2>
+
+<dl>
+
+	<dt>The Unicode Standard, Version 4.0, Addison-Wesley,
+	ISBN 0-321-18578-1</dt>
+
+	<dd>The definition of the Unicode character set which is
+	used for XML.<br><br></dd>
+
+	<dt><a
+	href='http://www.w3.org/TR/2004/REC-xml-20040204/'>Extensible
+	Markup Language (XML) 1.0 (Third Edition)</a></dt>
+
+	<dd>The XML specification from the World Wide Web
+	Consortium (W3C)<br><br></dd>
+
+</dl>
+
+<!-- NEED 6 -->
+<h2>Legal Stuff</h2>
+
+<p>The Mini-XML library is copyright 2003-2009 by Michael Sweet. License terms
+are described in <a href='#LICENSE'>Appendix A - Mini-XML License</a>.</p>
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/intro.man mxml-2.6-haiku/doc/intro.man
--- mxml-2.6/doc/intro.man	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/intro.man	2008-01-29 05:28:31.000000000 +0000
@@ -0,0 +1,150 @@
+.SH INCLUDE FILE
+#include <mxml.h>
+.SH LIBRARY
+\-lmxml
+.SH DESCRIPTION
+Mini-XML is a small XML parsing library that you can use to
+read XML and XML-like data files in your application without
+requiring large non-standard libraries.  Mini-XML only
+requires an ANSI C compatible compiler (GCC works, as do
+most vendors' ANSI C compilers) and a "make" program.
+.PP
+Mini-XML provides the following functionality:
+.IP \(bu 4
+Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files and strings.
+.IP \(bu 4
+Data is stored in a linked-list tree structure,
+preserving the XML data hierarchy.
+.IP \(bu 4
+Supports arbitrary element names, attributes, and attribute
+values with no preset limits, just available memory.
+.IP \(bu 4
+Supports integer, real, opaque ("cdata"), and text data types in
+"leaf" nodes.
+.IP \(bu 4
+Functions for creating, indexing, and managing trees of data.
+.IP \(bu 4
+"Find" and "walk" functions for easily locating and navigating
+trees of data.
+.PP
+Mini-XML doesn't do validation or other types of processing
+on the data based upon schema files or other sources of
+definition information, nor does it support character
+entities other than those required by the XML
+specification.
+.SH USING MINI-XML
+Mini-XML provides a single header file which you include:
+.nf
+
+    #include <mxml.h>
+.fi
+.PP
+Nodes are defined by the "mxml_node_t" structure; the "type"
+member defines the node type (element, integer, opaque,
+real, or text) which determines which value you want to look
+at in the "value" union.  New nodes can be created using the
+"mxmlNewElement()", "mxmlNewInteger()", "mxmlNewOpaque()",
+"mxmlNewReal()", and "mxmlNewText()" functions.  Only
+elements can have child nodes, and the top node must be an
+element, usually "?xml".
+.PP
+You load an XML file using the "mxmlLoadFile()" function:
+.nf
+
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen("filename.xml", "r");
+    tree = mxmlLoadFile(NULL, fp, MXML_NO_CALLBACK);
+    fclose(fp);
+.fi
+.PP
+Similarly, you save an XML file using the "mxmlSaveFile()"
+function:
+.nf
+
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen("filename.xml", "w");
+    mxmlSaveFile(tree, fp, MXML_NO_CALLBACK);
+    fclose(fp);
+.fi
+.PP
+The "mxmlLoadString()", "mxmlSaveAllocString()", and
+"mxmlSaveString()" functions load XML node trees from and save
+XML node trees to strings:
+.nf
+
+    char buffer[8192];
+    char *ptr;
+    mxml_node_t *tree;
+
+    ...
+    tree = mxmlLoadString(NULL, buffer, MXML_NO_CALLBACK);
+
+    ...
+    mxmlSaveString(tree, buffer, sizeof(buffer),
+                   MXML_NO_CALLBACK);
+
+    ...
+    ptr = mxmlSaveAllocString(tree, MXML_NO_CALLBACK);
+.fi
+.PP
+You can find a named element/node using the "mxmlFindElement()"
+function:
+.nf
+
+    mxml_node_t *node = mxmlFindElement(tree, tree, "name",
+                                        "attr", "value",
+                                        MXML_DESCEND);
+.fi
+.PP
+The "name", "attr", and "value" arguments can be passed as
+NULL to act as wildcards, e.g.:
+.nf
+
+    /* Find the first "a" element */
+    node = mxmlFindElement(tree, tree, "a", NULL, NULL,
+                           MXML_DESCEND);
+
+    /* Find the first "a" element with "href" attribute */
+    node = mxmlFindElement(tree, tree, "a", "href", NULL,
+                           MXML_DESCEND);
+
+    /* Find the first "a" element with "href" to a URL */
+    node = mxmlFindElement(tree, tree, "a", "href",
+                           "http://www.easysw.com/~mike/mxml/",
+                           MXML_DESCEND);
+
+    /* Find the first element with a "src" attribute*/
+    node = mxmlFindElement(tree, tree, NULL, "src", NULL,
+                           MXML_DESCEND);
+
+    /* Find the first element with a "src" = "foo.jpg" */
+    node = mxmlFindElement(tree, tree, NULL, "src",
+                           "foo.jpg", MXML_DESCEND);
+.fi
+.PP
+You can also iterate with the same function:
+.nf
+
+    mxml_node_t *node;
+
+    for (node = mxmlFindElement(tree, tree, "name", NULL,
+                                NULL, MXML_DESCEND);
+         node != NULL;
+         node = mxmlFindElement(node, tree, "name", NULL,
+                                NULL, MXML_DESCEND))
+    {
+      ... do something ...
+    }
+.fi
+.PP
+Finally, once you are done with the XML data, use the
+"mxmlDelete()" function to recursively free the memory that
+is used for a particular node or the entire tree:
+.nf
+
+    mxmlDelete(tree);
+.fi
diff -Naur mxml-2.6/doc/license.html mxml-2.6-haiku/doc/license.html
--- mxml-2.6/doc/license.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/license.html	2009-05-17 06:04:58.000000000 +0000
@@ -0,0 +1,598 @@
+<html>
+<body>
+
+<h1 align='right'><a name='LICENSE'><img src="A.gif" align="right"
+hspace="10" width="100" height="100" alt="A"></a>Mini-XML
+License</h1>
+
+<p>The Mini-XML library and included programs are provided under
+the terms of the GNU Library General Public License (LGPL) with
+the following exceptions:</p>
+
+<ol>
+
+	<li>Static linking of applications to the Mini-XML
+	library does not constitute a derivative work and does
+	not require the author to provide source code for the
+	application, use the shared Mini-XML libraries, or link
+	their applications against a user-supplied version of
+	Mini-XML.
+
+	<p><i>If you link the application to a modified version
+	of Mini-XML, then the changes to Mini-XML must be
+	provided under the terms of the LGPL in sections 1, 2,
+	and 4.</i></p>
+	</li>
+
+	<li>You do not have to provide a copy of the Mini-XML
+	license with programs that are linked to the Mini-XML
+	library, nor do you have to identify the Mini-XML license
+	in your program or documentation as required by section 6
+	of the LGPL.</li>
+
+</ol>
+
+<!-- NEW PAGE -->
+<p align=center><b>GNU LIBRARY GENERAL PUBLIC LICENSE</b></p>
+<p align='center'>Version 2, June 1991
+<br />Copyright (C) 1991 Free Software Foundation, Inc.
+<br />59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+<br />Everyone is permitted to copy and distribute verbatim copies of
+this license document, but changing it is not allowed.
+<br />[This is the first released version of the library GPL. It is
+numbered 2 because it goes with version 2 of the ordinary GPL.]</p>
+
+<p><b>Preamble</b></p>
+
+<p>The licenses for most software are designed to take away your freedom
+to share and change it. By contrast, the GNU General Public Licenses
+are intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.</p>
+
+<p>This license, the Library General Public License, applies to some
+specially designated Free Software Foundation software, and to any
+other libraries whose authors decide to use it. You can use it for
+your libraries, too.</p>
+
+<p>When we speak of free software, we are referring to freedom,
+not price. Our General Public Licenses are designed to make sure
+that you have the freedom to distribute copies of free software
+(and charge for this service if you wish), that you receive
+source code or can get it if you want it, that you can change
+the software or use pieces of it in new free programs; and that
+you know you can do these things.</p>
+
+<p>To protect your rights, we need to make restrictions that
+forbid anyone to deny you these rights or to ask you to
+surrender the rights. These restrictions translate to certain
+responsibilities for you if you distribute copies of the
+library, or if you modify it.</p>
+
+<p>For example, if you distribute copies of the library, whether
+gratis or for a fee, you must give the recipients all the rights
+that we gave you. You must make sure that they, too, receive or
+can get the source code. If you link a program with the library,
+you must provide complete object files to the recipients so that
+they can relink them with the library, after making changes to
+the library and recompiling it. And you must show them these
+terms so they know their rights.</p>
+
+<p>Our method of protecting your rights has two steps: (1)
+copyright the library, and (2) offer you this license which
+gives you legal permission to copy, distribute and/or modify the
+library.</p>
+
+<p>Also, for each distributor's protection, we want to make
+certain that everyone understands that there is no warranty for
+this free library. If the library is modified by someone else
+and passed on, we want its recipients to know that what they
+have is not the original version, so that any problems
+introduced by others will not reflect on the original authors'
+reputations.</p>
+
+<p>Finally, any free program is threatened constantly by
+software patents. We wish to avoid the danger that companies
+distributing free software will individually obtain patent
+licenses, thus in effect transforming the program into
+proprietary software. To prevent this, we have made it clear
+that any patent must be licensed for everyone's free use or not
+licensed at all.</p>
+
+<p>Most GNU software, including some libraries, is covered by
+the ordinary GNU General Public License, which was designed for
+utility programs. This license, the GNU Library General Public
+License, applies to certain designated libraries. This license
+is quite different from the ordinary one; be sure to read it in
+full, and don't assume that anything in it is the same as in the
+ordinary license.</p>
+
+<p>The reason we have a separate public license for some
+libraries is that they blur the distinction we usually make
+between modifying or adding to a program and simply using it.
+Linking a program with a library, without changing the library,
+is in some sense simply using the library, and is analogous to
+running a utility program or application program. However, in a
+textual and legal sense, the linked executable is a combined
+work, a derivative of the original library, and the ordinary
+General Public License treats it as such.</p>
+
+<p>Because of this blurred distinction, using the ordinary
+General Public License for libraries did not effectively promote
+software sharing, because most developers did not use the
+libraries. We concluded that weaker conditions might promote
+sharing better.</p>
+
+<p>However, unrestricted linking of non-free programs would
+deprive the users of those programs of all benefit from the free
+status of the libraries themselves. This Library General Public
+License is intended to permit developers of non-free programs to
+use free libraries, while preserving your freedom as a user of
+such programs to change the free libraries that are incorporated
+in them. (We have not seen how to achieve this as regards
+changes in header files, but we have achieved it as regards
+changes in the actual functions of the Library.) The hope is
+that this will lead to faster development of free libraries.</p>
+
+<p>The precise terms and conditions for copying, distribution
+and modification follow. Pay close attention to the difference
+between a &quot;work based on the libary&quot; and a &quot;work
+that uses the library&quot;. The former contains code derived
+from the library, while the latter only works together with the
+library.</p>
+
+<p>Note that it is possible for a library to be covered by the
+ordinary General Public License rather than by this special
+one.</p>
+
+<p align='center'><b>TERMS AND CONDITIONS FOR COPYING,
+DISTRIBUTION AND MODIFICATION</b></p>
+
+<p><strong>0.</strong> This License Agreement applies to any
+software library which contains a notice placed by the copyright
+holder or other authorized party saying it may be distributed
+under the terms of this Library General Public License (also
+called &quot;this License&quot;). Each licensee is addressed as
+&quot;you&quot;.
+
+<p>A &quot;library&quot; means a collection of software
+functions and/or data prepared so as to be conveniently linked
+with application programs (which use some of those functions and
+data) to form executables.</p>
+
+<p>The &quot;Library&quot;, below, refers to any such software
+library or work which has been distributed under these terms. A
+&quot;work based on the Library&quot; means either the Library
+or any derivative work under copyright law: that is to say, a
+work containing the Library or a portion of it, either verbatim
+or with modifications and/or translated straightforwardly into
+another language. (Hereinafter, translation is included without
+limitation in the term &quot;modification&quot;.)</p>
+
+<p>&quot;Source code&quot; for a work means the preferred form
+of the work for making modifications to it. For a library,
+complete source code means all the source code for all modules
+it contains, plus any associated interface definition files,
+plus the scripts used to control compilation and installation of
+the library.</p>
+
+<p>Activities other than copying, distribution and modification
+are not covered by this License; they are outside its scope. The
+act of running a program using the Library is not restricted,
+and output from such a program is covered only if its contents
+constitute a work based on the Library (independent of the use
+of the Library in a tool for writing it). Whether that is true
+depends on what the Library does and what the program that uses
+the Library does.</p>
+
+<p><strong>1.</strong> You may copy and distribute verbatim
+copies of the Library's complete source code as you receive it,
+in any medium, provided that you conspicuously and appropriately
+publish on each copy an appropriate copyright notice and
+disclaimer of warranty; keep intact all the notices that refer
+to this License and to the absence of any warranty; and
+distribute a copy of this License along with the Library.</p>
+
+<p>You may charge a fee for the physical act of transferring a
+copy, and you may at your option offer warranty protection in
+exchange for a fee.</p>
+
+<p><strong>2.</strong> You may modify your copy or copies of the
+Library or any portion of it, thus forming a work based on the
+Library, and copy and distribute such modifications or work
+under the terms of Section 1 above, provided that you also meet
+all of these conditions:</p>
+
+<ul>
+
+	<p><strong>a)</strong> The modified work must itself be
+	a software library.
+
+	<p><strong>b)</strong> You must cause the files modified
+	to carry prominent notices stating that you changed the
+	files and the date of any change.</p>
+
+	<p><strong>c)</strong> You must cause the whole of the
+	work to be licensed at no charge to all third parties
+	under the terms of this License.</p>
+
+	<p><strong>d)</strong> If a facility in the modified
+	Library refers to a function or a table of data to be
+	supplied by an application program that uses the
+	facility, other than as an argument passed when the
+	facility is invoked, then you must make a good faith
+	effort to ensure that, in the event an application does
+	not supply such function or table, the facility still
+	operates, and performs whatever part of its purpose
+	remains meaningful.</p>
+
+	<p>(For example, a function in a library to compute
+	square roots has a purpose that is entirely well-defined
+	independent of the application. Therefore, Subsection 2d
+	requires that any application-supplied function or table
+	used by this function must be optional: if the
+	application does not supply it, the square root function
+	must still compute square roots.)</p>
+
+</ul>
+
+<p>These requirements apply to the modified work as a whole. If
+identifiable sections of that work are not derived from the
+Library, and can be reasonably considered independent and
+separate works in themselves, then this License, and its terms,
+do not apply to those sections when you distribute them as
+separate works. But when you distribute the same sections as
+part of a whole which is a work based on the Library, the
+distribution of the whole must be on the terms of this License,
+whose permissions for other licensees extend to the entire
+whole, and thus to each and every part regardless of who wrote
+it.</p>
+
+<p>Thus, it is not the intent of this section to claim rights or
+contest your rights to work written entirely by you; rather, the
+intent is to exercise the right to control the distribution of
+derivative or collective works based on the Library.</p>
+
+<p>In addition, mere aggregation of another work not based on
+the Library with the Library (or with a work based on the
+Library) on a volume of a storage or distribution medium does
+not bring the other work under the scope of this License.</p>
+
+<p><strong>3.</strong> You may opt to apply the terms of the
+ordinary GNU General Public License instead of this License to a
+given copy of the Library. To do this, you must alter all the
+notices that refer to this License, so that they refer to the
+ordinary GNU General Public License, version 2, instead of to
+this License. (If a newer version than version 2 of the ordinary
+GNU General Public License has appeared, then you can specify
+that version instead if you wish.) Do not make any other change
+in these notices.</p>
+
+<p>Once this change is made in a given copy, it is irreversible
+for that copy, so the ordinary GNU General Public License
+applies to all subsequent copies and derivative works made from
+that copy.</p>
+
+<p>This option is useful when you wish to copy part of the code
+of the Library into a program that is not a library.</p>
+
+<p><strong>4.</strong> You may copy and distribute the Library
+(or a portion or derivative of it, under Section 2) in object
+code or executable form under the terms of Sections 1 and 2
+above provided that you accompany it with the complete
+corresponding machine-readable source code, which must be
+distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.</p>
+
+<p>If distribution of object code is made by offering access to
+copy from a designated place, then offering equivalent access to
+copy the source code from the same place satisfies the
+requirement to distribute the source code, even though third
+parties are not compelled to copy the source along with the
+object code.</p>
+
+<p><strong>5.</strong> A program that contains no derivative of
+any portion of the Library, but is designed to work with the
+Library by being compiled or linked with it, is called a
+&quot;work that uses the Library&quot;. Such a work, in
+isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.</p>
+
+<p>However, linking a &quot;work that uses the Library&quot;
+with the Library creates an executable that is a derivative of
+the Library (because it contains portions of the Library),
+rather than a &quot;work that uses the library&quot;. The
+executable is therefore covered by this License. Section 6
+states terms for distribution of such executables.</p>
+
+<p>When a &quot;work that uses the Library&quot; uses material
+from a header file that is part of the Library, the object code
+for the work may be a derivative work of the Library even though
+the source code is not. Whether this is true is especially
+significant if the work can be linked without the Library, or if
+the work is itself a library. The threshold for this to be true
+is not precisely defined by law.</p>
+
+<p>If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small
+inline functions (ten lines or less in length), then the use of
+the object file is unrestricted, regardless of whether it is
+legally a derivative work. (Executables containing this object
+code plus portions of the Library will still fall under Section
+6.)</p>
+
+<p>Otherwise, if the work is a derivative of the Library, you
+may distribute the object code for the work under the terms of
+Section 6. Any executables containing that work also fall under
+Section 6, whether or not they are linked directly with the
+Library itself.</p>
+
+<p><strong>6.</strong> As an exception to the Sections above,
+you may also compile or link a &quot;work that uses the
+Library&quot; with the Library to produce a work containing
+portions of the Library, and distribute that work under terms of
+your choice, provided that the terms permit modification of the
+work for the customer's own use and reverse engineering for
+debugging such modifications.</p>
+
+<p>You must give prominent notice with each copy of the work
+that the Library is used in it and that the Library and its use
+are covered by this License. You must supply a copy of this
+License. If the work during execution displays copyright
+notices, you must include the copyright notice for the Library
+among them, as well as a reference directing the user to the
+copy of this License. Also, you must do one of these things:</p>
+
+<ul>
+
+	<strong>a)</strong> Accompany the work with the complete
+	corresponding machine-readable source code for the
+	Library including whatever changes were used in the work
+	(which must be distributed under Sections 1 and 2
+	above); and, if the work is an executable linked with
+	the Library, with the complete machine-readable
+	&quot;work that uses the Library&quot;, as object code
+	and/or source code, so that the user can modify the
+	Library and then relink to produce a modified executable
+	containing the modified Library. (It is understood that
+	the user who changes the contents of definitions files
+	in the Library will not necessarily be able to recompile
+	the application to use the modified definitions.)
+
+	<p><strong>b)</strong> Accompany the work with a written
+	offer, valid for at least three years, to give the same
+	user the materials specified in Subsection 6a, above,
+	for a charge no more than the cost of performing this
+	distribution.</p>
+
+	<p><strong>c)</strong> If distribution of the work is
+	made by offering access to copy from a designated place,
+	offer equivalent access to copy the above specified
+	materials from the same place.</p>
+
+	<p><strong>d)</strong> Verify that the user has already
+	received a copy of these materials or that you have
+	already sent this user a copy.</p>
+
+</ul>
+
+<p>For an executable, the required form of the &quot;work that
+uses the Library&quot; must include any data and utility
+programs needed for reproducing the executable from it. However,
+as a special exception, the source code distributed need not
+include anything that is normally distributed (in either source
+or binary form) with the major components (compiler, kernel, and
+so on) of the operating system on which the executable runs,
+unless that component itself accompanies the executable.</p>
+
+<p>It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system. Such a contradiction means you
+cannot use both them and the Library together in an executable
+that you distribute.</p>
+
+<p><strong>7.</strong> You may place library facilities that are
+a work based on the Library side-by-side in a single library
+together with other library facilities not covered by this
+License, and distribute such a combined library, provided that
+the separate distribution of the work based on the Library and
+of the other library facilities is otherwise permitted, and
+provided that you do these two things:</p>
+
+<ul>
+
+	<strong>a)</strong> Accompany the combined library with
+	a copy of the same work based on the Library, uncombined
+	with any other library facilities. This must be
+	distributed under the terms of the Sections above.
+
+	<p><strong>b)</strong> Give prominent notice with the
+	combined library of the fact that part of it is a work
+	based on the Library, and explaining where to find the
+	accompanying uncombined form of the same work.</p>
+
+</ul>
+
+<p><strong>8.</strong> You may not copy, modify, sublicense,
+link with, or distribute the Library except as expressly
+provided under this License. Any attempt otherwise to copy,
+modify, sublicense, link with, or distribute the Library is
+void, and will automatically terminate your rights under this
+License. However, parties who have received copies, or rights,
+from you under this License will not have their licenses
+terminated so long as such parties remain in full
+compliance.</p>
+
+<p><strong>9.</strong> You are not required to accept this
+License, since you have not signed it. However, nothing else
+grants you permission to modify or distribute the Library or its
+derivative works. These actions are prohibited by law if you do
+not accept this License. Therefore, by modifying or distributing
+the Library (or any work based on the Library), you indicate
+your acceptance of this License to do so, and all its terms and
+conditions for copying, distributing or modifying the Library or
+works based on it.</p>
+
+<p><strong>10.</strong> Each time you redistribute the Library
+(or any work based on the Library), the recipient automatically
+receives a license from the original licensor to copy,
+distribute, link with or modify the Library subject to these
+terms and conditions. You may not impose any further
+restrictions on the recipients' exercise of the rights granted
+herein. You are not responsible for enforcing compliance by
+third parties to this License.</p>
+
+<p><strong>11.</strong> If, as a consequence of a court judgment
+or allegation of patent infringement or for any other reason
+(not limited to patent issues), conditions are imposed on you
+(whether by court order, agreement or otherwise) that contradict
+the conditions of this License, they do not excuse you from the
+conditions of this License. If you cannot distribute so as to
+satisfy simultaneously your obligations under this License and
+any other pertinent obligations, then as a consequence you may
+not distribute the Library at all. For example, if a patent
+license would not permit royalty-free redistribution of the
+Library by all those who receive copies directly or indirectly
+through you, then the only way you could satisfy both it and
+this License would be to refrain entirely from distribution of
+the Library.</p>
+
+<p>If any portion of this section is held invalid or
+unenforceable under any particular circumstance, the balance of
+the section is intended to apply, and the section as a whole is
+intended to apply in other circumstances.</p>
+
+<p>It is not the purpose of this section to induce you to
+infringe any patents or other property right claims or to
+contest validity of any such claims; this section has the sole
+purpose of protecting the integrity of the free software
+distribution system which is implemented by public license
+practices. Many people have made generous contributions to the
+wide range of software distributed through that system in
+reliance on consistent application of that system; it is up to
+the author/donor to decide if he or she is willing to distribute
+software through any other system and a licensee cannot impose
+that choice.</p>
+
+<p>This section is intended to make thoroughly clear what is
+believed to be a consequence of the rest of this License.</p>
+
+<p><strong>12.</strong> If the distribution and/or use of the
+Library is restricted in certain countries either by patents or
+by copyrighted interfaces, the original copyright holder who
+places the Library under this License may add an explicit
+geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not
+thus excluded. In such case, this License incorporates the
+limitation as if written in the body of this License.</p>
+
+<p><strong>13.</strong> The Free Software Foundation may publish
+revised and/or new versions of the Library General Public
+License from time to time. Such new versions will be similar in
+spirit to the present version, but may differ in detail to
+address new problems or concerns.</p>
+
+<p>Each version is given a distinguishing version number. If the
+Library specifies a version number of this License which applies
+to it and &quot;any later version&quot;, you have the option of
+following the terms and conditions either of that version or of
+any later version published by the Free Software Foundation. If
+the Library does not specify a license version number, you may
+choose any version ever published by the Free Software
+Foundation.</p>
+
+<p><strong>14.</strong> If you wish to incorporate parts of the
+Library into other free programs whose distribution conditions
+are incompatible with these, write to the author to ask for
+permission. For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we
+sometimes make exceptions for this. Our decision will be guided
+by the two goals of preserving the free status of all
+derivatives of our free software and of promoting the sharing
+and reuse of software generally.</p>
+
+<p align='center'><b>NO WARRANTY</b></p>
+
+<p><strong>15.</strong> BECAUSE THE LIBRARY IS LICENSED FREE OF
+CHARGE, THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT
+PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN
+WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE
+LIBRARY &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF
+THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU
+ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
+CORRECTION.</p>
+
+<p><strong>16.</strong> IN NO EVENT UNLESS REQUIRED BY
+APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT
+HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE
+THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
+DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY
+(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
+OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.</p>
+
+<p align='center'><b>END OF TERMS AND CONDITIONS</b></p>
+
+<p><b>How to Apply These Terms to Your New Libraries</b></p>
+
+<p>If you develop a new library, and you want it to be of the
+greatest possible use to the public, we recommend making it free
+software that everyone can redistribute and change.  You can do so
+by permitting redistribution under these terms (or, alternatively,
+under the terms of the ordinary General Public License).
+
+<p>To apply these terms, attach the following notices to the
+library.  It is safest to attach them to the start of each source
+file to most effectively convey the exclusion of warranty; and each
+file should have at least the "copyright" line and a pointer to
+where the full notice is found.
+
+<ul>
+
+<p><var>one line to give the library's name and an idea of what it
+does.</var><br>
+Copyright (C) <var>year</var>  <var>name of author</var>
+
+<p>This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public License
+as published by the Free Software Foundation; either version 2.1 of
+the License, or (at your option) any later version.
+
+<p>This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+<p>You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+02111-1307  USA
+
+</ul>
+
+<p>Also add information on how to contact you by electronic and paper mail.
+
+<p>You should also get your employer (if you work as a programmer)
+or your school, if any, to sign a "copyright disclaimer" for the
+library, if necessary.  Here is a sample; alter the names:
+
+<ul>
+
+<p>Yoyodyne, Inc., hereby disclaims all copyright interest in the
+library `Frob' (a library for tweaking knobs) written by James
+Random Hacker.
+
+<p><var>signature of Ty Coon</var>, 1 April 1990 Ty Coon, President
+of Vice
+
+</ul>
+
+<p>That's all there is to it!
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/logo.gif mxml-2.6-haiku/doc/logo.gif
--- mxml-2.6/doc/logo.gif	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/logo.gif	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,54 @@
+GIF87a,,L    			
+
+
+   !!!"""###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~,    ,,@ 	H*DN)DlpB2j CI%4*lRn8sI#(
+JHPXje^{5Jh66pKo\G6K8+'.Lm 4MVT5* l
+TlNnfn3gn36\Vdv8-7{Ev]ayMz?z!ziP!`zMvVH4 gxP%Uh!yXqqB$n$"A-bx H9*H2@@HBGG
+MdXf\v`)dih/EN`eTW1jk5?9RR"9B_1mL\[YNN('=Bx fFpp0t	u@1
+Qq Iz W#;kU
+
+#
+	QIq;
+Qqd91'9BP#a@(Bxow8%+Vi`ON"H@[g:i+0:AdJ^!^<A,4$dOuC'}Po)mU2`5\HkpM#A(v
+Hq:pw;TR/7?'*;nP"@T]VXvL/B }]FkYA=}yF@&NS2Cnt+|ay5$8g=dNW/3GsD(MN/{2`>/!
+b?)._Xm`G&x5G#DaF<'ZL@duB;h(>w@H"HL@B'tb$/D&& 9>"xm	CPN oy 7&(
+NF8z$
+##!pH45dd=*!= m+2BH#oPH&2cirF` J)6R #tdj7i$$3A(J<Qc@_ $PGNM+$
+nLfz;>D
+GMN1	Z#y%0mw.5G6InM2QNQ	,Do&G J H lj`JOFl8%H;T,*@*xOKN4e;F9IFz&Y2
+.,#YOlNc]+8 %Cr[
+x4v
+:ay;bDEBDtA!R%Z65sl	m]!BV!"0P(qt$ ,QU~%`0*F?jU"\/J2jO1PY6`YN {p<P9tlB	~	<'a|r0DBC Nc'7h`Bv"fp
+q$Q(?@\c"F'XKxp!x|!BA%0S~A^lCDA.W2t]cJ7svgygVZh{Nf9x:%zegPf2z3=\Yd4<f'C o\]a>3}kH+x>%f;Mj[n{`"B=]E7  l<k(TTM"A'8qbVG%DyXk$r9Y;_`C[FDN08yS4&	~i,`(
+]Be;(0_TZBvcX:@7|CEF$
+19v"PA0#G)g
+Z=3T M5zds:?3MO. NIH7C+{Ru#)nc[}/cgWbpB[z{8oQ($>+oD 3q"w}
+$%Ia=a#qNP]sdF:B[^r[##T7iw6P:8kb7Uy{Qt s8~q<MWTC?@@uN81nD7gw JoFg9sz27euV ~8!X,'w>BM0>m^5Apy4`1	Th4/p m3pS7Us,9`v:3y&#cRp_CZ2gu>p
+VE%}auVop!9Z! 
+|HmYx PuMM`nXHUsS77{xS5"QSv8aBHq6D6Ee!RsX5 cVXq1R
+Y%9~S5iZ7mQ%~8P4(I -)#{5YQ88%uxG[46B%oxlGY;	qjld4LZjp7!HiQPW	E"iaRMhqo2"h9Ead.(br
+"u1!0|	`  	8$`Oy
+QP%)`=@o<	-Sb;h@E`+3k|s q^O  Yly {m18~q'OZW3RflW3&x}h}ikk
+!gk6G7yR6j9Jq x ng@eqqQp|(8c91
+$!9P	*Z,:wr #/&X&Y"x{71'AgDkk7'Gy#V	QB(&'2-CJEnA>dk'Xdf';>(;Wqz:l
+zl0
+jY?[B*
+kJljlJz
+6zZz*4jN6
+)bgwK+*::Q&k/"
+5kzj.{
+r[6[4kPY\\%!^;[k&!dfK!i$mBqktwk|~;[{;[ :QVU-E[;+DtC
+
+Gak';D B7$kWG+`rCDN& )qU6qE	DP9IPswOyH;DG0$<ARD$9<BD67A96J(AD07(91y(L$@8dAj&
+a7T{DlB*gu\G9
+
+C7%	qv:p'v9
+"[*H pq
+Q! WDjI	`5 Jb
+a#qd%.PM
+!GA+PG`"U.a<%2	~!dl#mJ6WD[G 8 (yjg eO`4G@ZQazDZ`*}I.A8{ 
+qCKT81
+QXA"QHwD@6!	 r/c	1Dw 7(|f5~	QE=|DI\6pk<wiEt9 h$	
+0|JjA sdc
+!q	1{	q}k%97#1
+92PA$\e LK<{m1;1kPHzqFI/5gC	p8tA9Qc};'Mq8fA><P7q6;b-O<-~m'e=8d0C1t:WKAGPMrg:!H}$0;~]s{!<{A,pEsK[Y!\NZfnWGmH:At>(:QW~^8 EqW{U6EJ7pt8bAk>imRcTbefS!]aZ^5c!UkU>!B@T#T<8[ca^6;ShTCFQS*.2A ;
\ No newline at end of file
diff -Naur mxml-2.6/doc/logo.xcf.gz mxml-2.6-haiku/doc/logo.xcf.gz
--- mxml-2.6/doc/logo.xcf.gz	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/logo.xcf.gz	2007-05-23 21:38:42.000000000 +0000
@@ -0,0 +1,50 @@
+      	xTEN	IY	@B}EAGB#u8">Q#".#s@Q}Ug3D?}ANSv3s'NO.^JDx_"$;D	Irr_K?;X1cFiy.PslFYeByKeU*K'VUW5<ebY\)JEE[G'|o"Y2|Q9*CueUh'WV?*[Qh=049!CF(+/S
+]OBu]WZ{CC~?tnU`zYu?WY1%ZQfL]YR^?bk3?f-.
+Ag_2BjV22T^R>e6\UZ>nH	%IeWBq*<?TX4P8=P170bReCUWnz&	9HF@r!=! CBBn,, y#G&@Blg+cGF G =q8skZ%J{$jNEv QD?(>,LD9:|H{#Q^7^!Bp>
+wCx |@q(Q r5Q!4YeD]`nhwD#4Q??QD`YgO#:7|#6Sa5D@_Ht	D!U~q8c0zHWN<E4At1{OA`BFC @nA\O,'M};RmS9pJiYg6njigT{=mG/@nYnC'N{\,:s9L4
+Fx(YBv\tEO 9{-O+j?qzgp1o8F-"Q#I%E*;A!"j85U0ROs7QFRCTSOw{qpe}]zu8">bX -?CGY=~3:Rq[vkfSRQwqVwR\Na:2Ol3$'K9Rr<#KzT=HE8V'}#7g;RPr
+E{cXB6Fs9ffAOS'	M-B,*"u1/S6  	jy:S0h2w]?:q{?,=w_ET %7~nu&5rgz"1but0\Nus*ynp0X;B{E( *q^^*WN+y+g^ 3K>nMms_G>)\sde[gqP;z:`k5'$0jAhBs'e[.a4ogQ:'S{VX+7P?.1z
+J,0^{gZ7*q2rc/co->>cb1i<RyFkz0LOznI~g aP*`Z Z("
+ Yb<Gm0~+z@}fu$4pXbC+O'/yWKlZIc_.eA0J1/u =s=sDCj*@_+rlVK8]My7gd>#wE;,ZjatZ|A	@KR}i	)F6|kMGlN|8!'A(V~ 9/ELNzOp/~y9!
+c9]XG#:~U>=d,Y+{3~DeJ#Rb8Ej<uM&Cv8.Vcj"mAZ+AXo}c=kdL46h?h:lom>oBumkc^_@nC+\v>^T5Gi7y{%Hxn`E@~{04P<xQ8:Q K2!=@aNx8{jc'GJSD96l@9LeSKGk	7p ."V7</>29@hu2?
+GD#Td`CCCUzF"-i*4s:g-fX( Zb%3NCrju"	H-X4P!#D8@}\1A3 Ldb:YdTMu/g@2VHROZ|b-Pd1F-Yc3G,jrWM3~M-m&ywn"""kg/_dEMuE g/8I}[4}z>-oZX3h7jp ?bi}K.KykSM-?\:F\}OMi}TGIb3{4hqS/-YS*72dVMqEBZ)5vV*#hpq2}(.2PqGzr^T\7PQ@z0u1gHHxq8!G^Djw3MsxE^7P5'@^DEkf t-zOxH}VLK8Mu>$e:zk1L#%%[R^&7Kj\qJOrChW.7.k> /g?>]-Z-I4q1-6(PlT[1PGV^vJc?y-\a 4}9APe6m9Qp\RZC3--T	CH]J9?|WI$QmO]J}dfGO@7.Pkvmv3(v=!y}nnE~l7>G>aTJ&{d#5g@9r*gr
+#{[q{}jL?s\_ y7T(U#;$qys!ZN3PQrI4bs4c,{]@$`<opw'p9{@[QO(g5{|ncC])%XO4P;FK,	:'Gzt6!)rWrnE|rZ
+VtEg~0msO<pQ9+`xPG}ULY SYCMPW)Or,D2"^p4u:SN<y7Px@eTF~tKPaNC	$^93E0}rb!HJ-WkbXK9+?eXUmZ)rhA9gW/U`W/$z^!]Y*^d0LV/3=^=XVOuFXz/b,	W{m<W-D/bdaRPF$E=-(Z7"9@/Q}(C,0	&xd`KC]z%_A;:|=PYYe0R5@=0|wSZ;c)pLY)*x
+N$ <-{tjfb9:l'm[!$8lm.\:UVljs^pC}&dA6s	gS8,.H
+d)8V~bE+s'c,M{z[le~Bc&,*-4DLcbR92O-H"&Z<l%	FX,Xo K5$#huWZz $VZdmP),Hac)G4%Gt]4SJkJA)0EDW4t+](u[!D6tdKJlS}\Rd,TeM*':uRT_[I1knMpkP)!dJKBqt11Hv%,^ratbla7Y|0lJ6b6 [z"i:,fz- H!Mrxs r`2H`F e2`Z*MHnB	^I. QPAC*EEGD(2t< 2qQqx:*FEteDAA`r>Nk]Osath#3>,=4Q
+Eoe'Y[l2%ulOfs%u4*AI20ibt`S6(@k%1y='7|~$5	)h@Bl?##D>(&B=||T=PL,uyj(%)D7/x1mqQ>tu`Y|v	?ileJaN"% :[vv@cU~\0h[k"jf>}k"a]+I>Bn/`y9DhGa\;eW\)-4n+}{'KqaSa"9uHi9h9M6Ojg?NnM{ vx?&Iof'c!H{fL_4cHt0Zl0oz![FAZg.s=?1&*7q"M0-WPaK_`wG"h?8`Nf sL1Ec39V@X8K}D68~?}t}>1n~uOUW*~J]#ULN(hcW@Z-,Dvm`9N?M!()4M^)4@0ioZh=^of}vzvI<O],=j7K5yrN3d0c-f{"U=n4.p&?j/{d=
+KEws%VM&s&U6<-&7/QUxmlii:{D'XM;M64MqCsbC]wm;+vk VPw6k)yMgt7GJ=qNh;#`iy\]mqikmzp4CjkpSE8h8OwcCf\Nf2442nwK>tTku^mOk1Eb:@1h<! $5whod"|$>e0e 9_l9w)cx7/O%%+U^$5|I')3B)LGj4|CR<Q/W:{;HGAJy	f2>yp\7L3|E8IM#\/L~IOOcR{R2(+SO2e8e:|0_kH-!UIR-NVlIe p-;Z*EyeHAqBKJ`&Eq
+n[lK6%WJPU	k0/y(F;|urX)Ddm4p#?
+^R?_8o/oz2On:bG41(N_sv~u
+8F8pwC3]Tcpce2rK+wl&56~vWLCc{PGm{R9w}[l/jKmo[I.Vwas(s>~@BmY	]gG^O_yVE+z$aIN&fh-w>Pe>b $2:'x}uz@bX;Bx~o9}1aW'P
+$hd@aF~GjX.0VXwAugg
+%I7Nu^,ft@A/Hs$c zC3XRD*H~0l=]$)Vwe=#?AAD)ILHN<cI ;A8;|ERcX]>/S[|?.-S$AMj%-?_Lh7u_E[??x,E>U	S"/Nt4@i.O e0B *	fD&Kk~MmM'k\Z-8!hFiPK`DKy.q:Wl0T#2{HL570|.{c{8s@L!(<)kWrJbM=xP*A"vmP&_xW}Etqqe?+W( g_x\be/3":_}!_be_*W==^)hc*|7-U4^Q{trP4MQo	Mz^}4q~lU+=F-
+_jVEk%E?V)an>!HuRcu/*5ho&(#MWGNiqFhY+W{T4QQ&a?ca=|'+2Mg:|F~31!>o!?<VLzPOOMX|vwuh2\sbp+3FXaZ*h9)*;L./'S/L_l%*vrI4f>lpcNG+?;XGX%*	mS=J/]27;ZVsfmDy[<hl-6rG5*rB3^=k1R5=CM]h$u'$n`rZ
+v]AEJV{NiF,K%kKc_$J''H
+B)M"-$~^nyu>Ek0/BDDb**e,x&g9%YyQ4q*v,Hj/Z'Z]OKOZMH]Q_MLy&9P`+,y_hhZ*VqW4-w^]Kw5_]#,MaJ9iVx(`G_B^6`i+&pM3o=]{#'Wsqir%y1Llx1Kcn5`1AvR@1 7 <xcLc9pv 8 85e~00 <;_ ^ )t-c|mbv|@1`$``nbC  /b/| _2Ae/| _2Ae/|9!_rC/|9!_rC/|+ _
+W@|+ _
+W@|%+!_	JWB|%+!_	JWB///WGU*Q
+}T>Z>Z>Z>Z>Z>Z>Z>Zv1++++++V0vVbYs_4^V  l;)cysiAIc`j5|CPo7K5f=a `06`l<[kGd]VcTVc?V^eI,t"(nxs0y8lXm	+MeZKO)P*%T6}M2fU b/}z``Mqn;`}LZo<6afm< :xsf	-Zmh))*l*u1t2N|5`1Bc,:a@0NvMOF	@IvbYv68l12]"!r(xbG'$0/!{rhA$-/-MhZ4tfz g[YH]ndm6_+.bk-b\kJ&M0MSucLSIw4%Z8KiNm9~tnc !4G>a4'Oz#&fy	Od;d5$UB'x.~*}e'	g/<DZ:LO[7rli_ogJMkQwm8|dc30trh;:
+{c\Pa;7EwMW-\{vmqd<Z!;3m-[Pq4RC"+ut
+?fQ%VA0 +I1V!  \/4gZ3B((M^/Mv.po:u$3LigwWiz1j"67>3)mI	7cUakos24h#SubxdKw!UbqxIl!k)QRit(o<ll&lM:aY	[&}O&lB&\C}u9t}cKO[2sWu4i.9pgj<PUp)a,ke0T)Q2Y[ugJ^Pq*7uyTkaLgEFCcYg{:N'qSsi2l5yxL"wvcU.${ZVv,`	X#sy.6M+Y{{0'*g9LXT?^%PlEJGxslY&>DH9**]10S1R,(reeU##!Q"#$bBOHS[D__6n9= X=i{Z=~,'y	{=#=SpBO$'w6kzrMia#4-,`wf-l$51$+Nd`5	l&$BOV_c8h`UhWkkL=`5k4l&>~n[g4k_,0wFhTk
+mb? `h-	7h4T}g8@=c<4(#kL>;6j[SI!2NBD
+"](MSJ.,"n.?YT42P,*^<iOJ>o}3E7)zxo=z;BGqa=;PQm^.7(yQ`ey{XKE)"o;rVX` 67fiKc>vq.T|w[n}cA$*
+	R1(lo1~["@?Z6dIA#Oy_[c(gsv9gv#e;=^?pMiLU{%j2g#(	Vznp}/<c^|/u{K]m3O?yZ3H=r%OF}BMvRv72}t]ow(Ezu]gw4p|u?&Ww)xhS]p9Oyb/5c-XeoZ cf/]vx) y~>r?yx o)OQ*aY;I'};>$m|b|f`os]i|'}o?oCm>h{`\*l.5v&M*m(m4-
+'A"]?!97
+mNOv?e.t>O|?.g| l;^{"gP`}`IN6dOuNv,ogiso||oG}}=o_3>n9jA
+NB5(egqbuUw.gQP>Do:Mj7|;E0@	MX8Q((Q2>,<JJ</(M(Em1Y{:5ZV:C#u:aX6)u$ZVzoe;Jee?A7QfPGEGAiGYBrexm{oxz7Ro4kdG3J(OQf&QMDYd	RUB$k"QbPe?YczjGqQQ,ElT(3QJf"A>&(P"MP2^wCe]|L=QMS/U*wJt;7mNhNxpPt:Z<--\zK.0=!_Y'[etKi7W5l:=O:V;n/{N/tu[tOg3 ~":~U_o&vd{?}iMRdUpMB79B4zt JvKc6-MK{4{a	lbKC2fZr1m65MM{fh1N9-Py=qv*]8U|fMvd37gb<o>`A
+?(<0Eaf7
+w(H rO#%K@1d	d& @:v
+	p"z?~ H @$&qMD9	v$I@(PDG	+%fJ*TU	e%*+!X1Dd	%NK[r	%Kxh_D	5,P1c	#M'0eN5W"V;n	#(fPB1bb&M,aDmDy')f-
+RL%Z%xK0cD{)v'xNph'@lI	*IY$It&YM8Iu$IS8(P$G
++%eJ*yTU
+e%JU+)X2$d%MKV-[rr%Kt`_dI&5LD c$PbL'J2p$3H<2u$a$Y<,{\Ce
+H
+H	O!!  vP+?{g~vm^4}Mk_g c %(Q@	`Ne(J:P&(GA
+YPr6(AyPr c"!gH;3;pgggggggZAV@UP@P@L"1 DqPQ1L(Cd$o W+8S-*% 
+W`aHq?N2B 
+Ae@Hzje1Be(@FD|zxvxRAAAAAAa&>]t'
+
+qq]3<9<Yzk\9)~Ms_3 `$%
+(a@J P"
+X%(@J@P"*f+9COdYVHRA e<<>t<[{_3jzuDMK$kBoXwIKe_?e~\W;||j  
\ No newline at end of file
diff -Naur mxml-2.6/doc/makedocs.sh mxml-2.6-haiku/doc/makedocs.sh
--- mxml-2.6/doc/makedocs.sh	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/makedocs.sh	2007-09-09 07:16:52.000000000 +0000
@@ -0,0 +1,30 @@
+#!/bin/sh
+#
+# "$Id: makedocs.sh 297 2007-09-09 07:16:52Z mike $"
+#
+# Script to make documentation...
+#
+# Copyright 2003-2007 by Michael Sweet.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+
+htmldoc --verbose --path "hires;." --batch mxml.book -f mxml.pdf
+
+htmldoc --verbose --batch mxml.book --no-title -f mxml.html
+
+rm -rf mxml.d
+mkdir mxml.d
+htmldoc --verbose --batch mxml.book --no-title -t html -d mxml.d
+
+#
+# End of "$Id: makedocs.sh 297 2007-09-09 07:16:52Z mike $".
+#
diff -Naur mxml-2.6/doc/mxml.book mxml-2.6-haiku/doc/mxml.book
--- mxml-2.6/doc/mxml.book	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/mxml.book	2008-01-25 07:50:40.000000000 +0000
@@ -0,0 +1,11 @@
+#HTMLDOC 1.8.27.1
+-t pdf14 -f "mxml.pdf" --book --toclevels 3 --no-numbered --toctitle "Table of Contents" --title --titleimage "title.html" --linkstyle plain --size 4.25x6.875in --left 0.750in --right 0.50in --top 0.50in --bottom 0.50in --header .t. --header1 ... --footer h.1 --nup 1 --tocheader .t. --tocfooter ..i --duplex --portrait --color --no-pscommands --no-xrxcomments --compression=9 --jpeg=95 --fontsize 9.0 --fontspacing 1.2 --headingfont Helvetica --bodyfont Helvetica --headfootsize 8.0 --headfootfont Helvetica-Oblique --charset iso-8859-1 --links --embedfonts --pagemode outline --pagelayout single --firstpage c1 --pageeffect none --pageduration 10 --effectduration 1.0 --no-encryption --permissions all  --owner-password ""  --user-password "" --browserwidth 300 --no-strict --no-overflow
+intro.html
+install.html
+basics.html
+advanced.html
+mxmldoc.html
+license.html
+relnotes.html
+reference.html
+schema.html
diff -Naur mxml-2.6/doc/mxml.html mxml-2.6-haiku/doc/mxml.html
--- mxml-2.6/doc/mxml.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/mxml.html	2009-05-17 17:31:51.000000000 +0000
@@ -0,0 +1,3952 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
+<HTML>
+<HEAD>
+<TITLE>Mini-XML Programmers Manual, Version 2.6</TITLE>
+<META NAME="author" CONTENT="Michael R. Sweet">
+<META NAME="copyright" CONTENT="Copyright 2003-2009">
+<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso-iso-8859-1">
+<STYLE TYPE="text/css"><!--
+BODY { font-family: sans-serif }
+H1 { font-family: sans-serif }
+H2 { font-family: sans-serif }
+H3 { font-family: sans-serif }
+H4 { font-family: sans-serif }
+H5 { font-family: sans-serif }
+H6 { font-family: sans-serif }
+SUB { font-size: smaller }
+SUP { font-size: smaller }
+PRE { font-family: monospace }
+A { text-decoration: none }
+--></STYLE>
+</HEAD>
+<BODY>
+<H1 ALIGN="CENTER"><A NAME="CONTENTS">Table of Contents</A></H1>
+<BR>
+<BR><B><A HREF="#INTRO">Introduction</A></B>
+<UL>
+<LI><A HREF="#1_1">Organization of This Document</A></LI>
+<LI><A HREF="#1_2">Notation Conventions</A></LI>
+<LI><A HREF="#1_3">Abbreviations</A></LI>
+<LI><A HREF="#1_4">Other References</A></LI>
+<LI><A HREF="#1_5">Legal Stuff</A></LI>
+</UL>
+<B><A HREF="#INSTALL">Building, Installing, and Packaging Mini-XML</A></B>
+<UL>
+<LI><A HREF="#2_1">Compiling Mini-XML</A>
+<UL>
+<LI><A HREF="#2_1_1">Compiling with Visual C++</A></LI>
+<LI><A HREF="#2_1_2">Compiling with Command-Line Tools</A></LI>
+</UL>
+</LI>
+<LI><A HREF="#2_2">Installing Mini-XML</A></LI>
+<LI><A HREF="#2_3">Creating Mini-XML Packages</A></LI>
+</UL>
+<B><A HREF="#BASICS">Getting Started with Mini-XML</A></B>
+<UL>
+<LI><A HREF="#3_1">The Basics</A></LI>
+<LI><A HREF="#3_2">Nodes</A></LI>
+<LI><A HREF="#3_3">Creating XML Documents</A></LI>
+<LI><A HREF="#3_4">Loading XML</A></LI>
+<LI><A HREF="#3_5">Saving XML</A>
+<UL>
+<LI><A HREF="#3_5_1">Controlling Line Wrapping</A></LI>
+</UL>
+</LI>
+<LI><A HREF="#3_6">Finding and Iterating Nodes</A></LI>
+</UL>
+<B><A HREF="#ADVANCED">More Mini-XML Programming Techniques</A></B>
+<UL>
+<LI><A HREF="#LOAD_CALLBACKS">Load Callbacks</A></LI>
+<LI><A HREF="#SAVE_CALLBACKS">Save Callbacks</A></LI>
+<LI><A HREF="#4_3">Custom Data Types</A></LI>
+<LI><A HREF="#4_4">Changing Node Values</A></LI>
+<LI><A HREF="#4_5">Formatted Text</A></LI>
+<LI><A HREF="#4_6">Indexing</A></LI>
+<LI><A HREF="#4_7">SAX (Stream) Loading of Documents</A></LI>
+</UL>
+<B><A HREF="#MXMLDOC">Using the mxmldoc Utility</A></B>
+<UL>
+<LI><A HREF="#5_1">The Basics</A>
+<UL>
+<LI><A HREF="#5_1_1">Creating Man Pages</A></LI>
+<LI><A HREF="#5_1_2">Creating Xcode Documentation Sets</A></LI>
+</UL>
+</LI>
+<LI><A HREF="#5_2">Commenting Your Code</A></LI>
+<LI><A HREF="#5_3">Titles, Sections, and Introductions</A></LI>
+</UL>
+<B><A HREF="#LICENSE">Mini-XML License</A></B>
+<BR>
+<BR><B><A HREF="#RELNOTES">Release Notes</A></B>
+<UL></UL>
+<B><A HREF="#REFERENCE">Library Reference</A></B>
+<UL>
+<LI><A HREF="#8_1">Contents</A></LI>
+<LI><A HREF="#FUNCTIONS">Functions</A>
+<UL>
+<LI><A HREF="#mxmlAdd">mxmlAdd</A></LI>
+<LI><A HREF="#mxmlDelete">mxmlDelete</A></LI>
+<LI><A HREF="#8_2_3">mxmlElementDeleteAttr</A></LI>
+<LI><A HREF="#mxmlElementGetAttr">mxmlElementGetAttr</A></LI>
+<LI><A HREF="#mxmlElementSetAttr">mxmlElementSetAttr</A></LI>
+<LI><A HREF="#8_2_6">mxmlElementSetAttrf</A></LI>
+<LI><A HREF="#mxmlEntityAddCallback">mxmlEntityAddCallback</A></LI>
+<LI><A HREF="#mxmlEntityGetName">mxmlEntityGetName</A></LI>
+<LI><A HREF="#mxmlEntityGetValue">mxmlEntityGetValue</A></LI>
+<LI><A HREF="#mxmlEntityRemoveCallback">mxmlEntityRemoveCallback</A></LI>
+<LI><A HREF="#mxmlFindElement">mxmlFindElement</A></LI>
+<LI><A HREF="#mxmlIndexDelete">mxmlIndexDelete</A></LI>
+<LI><A HREF="#mxmlIndexEnum">mxmlIndexEnum</A></LI>
+<LI><A HREF="#mxmlIndexFind">mxmlIndexFind</A></LI>
+<LI><A HREF="#mxmlIndexNew">mxmlIndexNew</A></LI>
+<LI><A HREF="#mxmlIndexReset">mxmlIndexReset</A></LI>
+<LI><A HREF="#mxmlLoadFd">mxmlLoadFd</A></LI>
+<LI><A HREF="#mxmlLoadFile">mxmlLoadFile</A></LI>
+<LI><A HREF="#mxmlLoadString">mxmlLoadString</A></LI>
+<LI><A HREF="#8_2_20">mxmlNewCDATA</A></LI>
+<LI><A HREF="#8_2_21">mxmlNewCustom</A></LI>
+<LI><A HREF="#mxmlNewElement">mxmlNewElement</A></LI>
+<LI><A HREF="#mxmlNewInteger">mxmlNewInteger</A></LI>
+<LI><A HREF="#mxmlNewOpaque">mxmlNewOpaque</A></LI>
+<LI><A HREF="#mxmlNewReal">mxmlNewReal</A></LI>
+<LI><A HREF="#mxmlNewText">mxmlNewText</A></LI>
+<LI><A HREF="#mxmlNewTextf">mxmlNewTextf</A></LI>
+<LI><A HREF="#8_2_28">mxmlNewXML</A></LI>
+<LI><A HREF="#8_2_29">mxmlRelease</A></LI>
+<LI><A HREF="#mxmlRemove">mxmlRemove</A></LI>
+<LI><A HREF="#8_2_31">mxmlRetain</A></LI>
+<LI><A HREF="#8_2_32">mxmlSAXLoadFd</A></LI>
+<LI><A HREF="#8_2_33">mxmlSAXLoadFile</A></LI>
+<LI><A HREF="#8_2_34">mxmlSAXLoadString</A></LI>
+<LI><A HREF="#mxmlSaveAllocString">mxmlSaveAllocString</A></LI>
+<LI><A HREF="#mxmlSaveFd">mxmlSaveFd</A></LI>
+<LI><A HREF="#mxmlSaveFile">mxmlSaveFile</A></LI>
+<LI><A HREF="#mxmlSaveString">mxmlSaveString</A></LI>
+<LI><A HREF="#8_2_39">mxmlSetCDATA</A></LI>
+<LI><A HREF="#8_2_40">mxmlSetCustom</A></LI>
+<LI><A HREF="#mxmlSetCustomHandlers">mxmlSetCustomHandlers</A></LI>
+<LI><A HREF="#mxmlSetElement">mxmlSetElement</A></LI>
+<LI><A HREF="#mxmlSetErrorCallback">mxmlSetErrorCallback</A></LI>
+<LI><A HREF="#mxmlSetInteger">mxmlSetInteger</A></LI>
+<LI><A HREF="#mxmlSetOpaque">mxmlSetOpaque</A></LI>
+<LI><A HREF="#mxmlSetReal">mxmlSetReal</A></LI>
+<LI><A HREF="#mxmlSetText">mxmlSetText</A></LI>
+<LI><A HREF="#mxmlSetTextf">mxmlSetTextf</A></LI>
+<LI><A HREF="#8_2_49">mxmlSetWrapMargin</A></LI>
+<LI><A HREF="#mxmlWalkNext">mxmlWalkNext</A></LI>
+<LI><A HREF="#mxmlWalkPrev">mxmlWalkPrev</A></LI>
+</UL>
+</LI>
+<LI><A HREF="#TYPES">Data Types</A>
+<UL>
+<LI><A HREF="#mxml_attr_t">mxml_attr_t</A></LI>
+<LI><A HREF="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</A></LI>
+<LI><A HREF="#mxml_custom_load_cb_t">mxml_custom_load_cb_t</A></LI>
+<LI><A HREF="#mxml_custom_save_cb_t">mxml_custom_save_cb_t</A></LI>
+<LI><A HREF="#8_3_5">mxml_custom_t</A></LI>
+<LI><A HREF="#mxml_element_t">mxml_element_t</A></LI>
+<LI><A HREF="#mxml_entity_cb_t">mxml_entity_cb_t</A></LI>
+<LI><A HREF="#mxml_error_cb_t">mxml_error_cb_t</A></LI>
+<LI><A HREF="#mxml_index_t">mxml_index_t</A></LI>
+<LI><A HREF="#mxml_load_cb_t">mxml_load_cb_t</A></LI>
+<LI><A HREF="#mxml_node_t">mxml_node_t</A></LI>
+<LI><A HREF="#mxml_save_cb_t">mxml_save_cb_t</A></LI>
+<LI><A HREF="#mxml_sax_cb_t">mxml_sax_cb_t</A></LI>
+<LI><A HREF="#mxml_sax_event_t">mxml_sax_event_t</A></LI>
+<LI><A HREF="#mxml_text_t">mxml_text_t</A></LI>
+<LI><A HREF="#mxml_type_t">mxml_type_t</A></LI>
+<LI><A HREF="#mxml_value_t">mxml_value_t</A></LI>
+</UL>
+</LI>
+<LI><A HREF="#STRUCTURES">Structures</A>
+<UL>
+<LI><A HREF="#mxml_attr_s">mxml_attr_s</A></LI>
+<LI><A HREF="#8_4_2">mxml_custom_s</A></LI>
+<LI><A HREF="#mxml_element_s">mxml_element_s</A></LI>
+<LI><A HREF="#mxml_index_s">mxml_index_s</A></LI>
+<LI><A HREF="#mxml_node_s">mxml_node_s</A></LI>
+<LI><A HREF="#mxml_text_s">mxml_text_s</A></LI>
+</UL>
+</LI>
+<LI><A HREF="#UNIONS">Unions</A>
+<UL>
+<LI><A HREF="#mxml_value_u">mxml_value_u</A></LI>
+</UL>
+</LI>
+<LI><A HREF="#ENUMERATIONS">Constants</A>
+<UL>
+<LI><A HREF="#mxml_sax_event_e">mxml_sax_event_e</A></LI>
+<LI><A HREF="#mxml_type_e">mxml_type_e</A></LI>
+</UL>
+</LI>
+</UL>
+<B><A HREF="#SCHEMA">XML Schema</A></B>
+<UL></UL>
+<HR NOSHADE>
+<H1 align="right"><A name="INTRO"><IMG align="right" alt="0" height="100"
+hspace="10" src="0.gif" width="100"></A>Introduction</H1>
+<P>This programmers manual describes Mini-XML version 2.6, a small XML
+ parsing library that you can use to read and write XML data files in
+ your C and C++ applications.</P>
+<P>Mini-XML was initially developed for the <A href="http://gutenprint.sf.net/">
+Gutenprint</A> project to replace the rather large and unwieldy <TT>
+libxml2</TT> library with something substantially smaller and
+ easier-to-use. It all began one morning in June of 2003 when Robert
+ posted the following sentence to the developer's list:</P>
+<BLOCKQUOTE><EM>It's bad enough that we require libxml2, but rolling our
+ own XML parser is a bit more than we can handle.</EM></BLOCKQUOTE>
+<P>I then replied with:</P>
+<BLOCKQUOTE><EM>Given the limited scope of what you use in XML, it
+ should be trivial to code a mini-XML API in a few hundred lines of
+ code.</EM></BLOCKQUOTE>
+<P>I took my own challenge and coded furiously for two days to produced
+ the initial public release of Mini-XML, total lines of code: 696.
+ Robert promptly integrated Mini-XML into Gutenprint and removed
+ libxml2.</P>
+<P>Thanks to lots of feedback and support from various developers,
+ Mini-XML has evolved since then to provide a more complete XML
+ implementation and now stands at a whopping 3,441 lines of code,
+ compared to 103,893 lines of code for libxml2 version 2.6.9.</P>
+<P>Aside from Gutenprint, Mini-XML is used for the following
+ projects/software applications:</P>
+<UL>
+<LI><A href="http://www.cups.org/">Common UNIX Printing System</A></LI>
+<LI><A href="http://zynaddsubfx.sourceforge.net">ZynAddSubFX</A></LI>
+</UL>
+<P>Please email me (mxml @ easysw . com) if you would like your project
+ added or removed from this list, or if you have any comments/quotes you
+ would like me to publish about your experiences with Mini-XML.</P>
+
+<!-- NEED 1in -->
+<H2><A NAME="1_1">Organization of This Document</A></H2>
+<P>This manual is organized into the following chapters and appendices:</P>
+<UL>
+<LI>Chapter 1, &quot;<A href="#INSTALL">Building, Installing, and Packaging
+ Mini-XML</A>&quot;, provides compilation, installation, and packaging
+ instructions for Mini-XML.</LI>
+<LI>Chapter 2, &quot;<A href="#BASICS">Getting Started with Mini-XML</A>&quot;,
+ shows how to use the Mini-XML library in your programs.</LI>
+<LI>Chapter 3, &quot;<A href="#ADVANCED">More Mini-XML Programming Techniques</A>
+&quot;, shows additional ways to use the Mini-XML library.</LI>
+<LI>Chapter 4, &quot;<A href="#MXMLDOC">Using the mxmldoc Utility</A>&quot;,
+ describes how to use the <TT>mxmldoc(1)</TT> program to generate
+ software documentation.</LI>
+<LI>Appendix A, &quot;<A href="#LICENSE">Mini-XML License</A>&quot;, provides the
+ terms and conditions for using and distributing Mini-XML.</LI>
+<LI>Appendix B, &quot;<A href="#RELNOTES">Release Notes</A>&quot;, lists the
+ changes in each release of Mini-XML.</LI>
+<LI>Appendix C, &quot;<A href="#REFERENCE">Library Reference</A>&quot;, contains a
+ complete reference for Mini-XML, generated by <TT>mxmldoc</TT>.</LI>
+<LI>Appendix D, &quot;<A href="#SCHEMA">XML Schema</A>&quot;, shows the XML schema
+ used for the XML files produced by <TT>mxmldoc</TT>.</LI>
+</UL>
+
+<!-- NEED 10 -->
+<H2><A NAME="1_2">Notation Conventions</A></H2>
+<P>Various font and syntax conventions are used in this guide. Examples
+ and their meanings and uses are explained below:</P>
+<DL>
+<DT><CODE>mxmldoc</CODE>
+<BR> <CODE>mxmldoc(1)</CODE></DT>
+<DD>The names of commands; the first mention of a command or function in
+ a chapter is followed by a manual page section number.
+<BR>
+<BR></DD>
+<DT><VAR>/var</VAR>
+<BR><VAR> /etc/hosts</VAR></DT>
+<DD>File and directory names.
+<BR>
+<BR></DD>
+<DT><TT>Request ID is Printer-123</TT></DT>
+<DD>Screen output.
+<BR>
+<BR></DD>
+<DT><KBD>lp -d printer filename ENTER</KBD></DT>
+<DD>Literal user input; special keys like <KBD>ENTER</KBD> are in ALL
+ CAPS.
+<BR>
+<BR></DD>
+<DT>12.3</DT>
+<DD>Numbers in the text are written using the period (.) to indicate the
+ decimal point.
+<BR>
+<BR></DD>
+</DL>
+
+<!-- NEED 10 -->
+<H2><A NAME="1_3">Abbreviations</A></H2>
+<P>The following abbreviations are used throughout this manual:</P>
+<DL>
+<DT>Gb</DT>
+<DD>Gigabytes, or 1073741824 bytes
+<BR>
+<BR></DD>
+<DT>kb</DT>
+<DD>Kilobytes, or 1024 bytes
+<BR>
+<BR></DD>
+<DT>Mb</DT>
+<DD>Megabytes, or 1048576 bytes
+<BR>
+<BR></DD>
+<DT>UTF-8, UTF-16</DT>
+<DD>Unicode Transformation Format, 8-bit or 16-bit
+<BR>
+<BR></DD>
+<DT>W3C</DT>
+<DD>World Wide Web Consortium
+<BR>
+<BR></DD>
+<DT>XML</DT>
+<DD>Extensible Markup Language
+<BR>
+<BR></DD>
+</DL>
+
+<!-- NEED 12 -->
+<H2><A NAME="1_4">Other References</A></H2>
+<DL>
+<DT>The Unicode Standard, Version 4.0, Addison-Wesley, ISBN
+ 0-321-18578-1</DT>
+<DD>The definition of the Unicode character set which is used for XML.
+<BR>
+<BR></DD>
+<DT><A href="http://www.w3.org/TR/2004/REC-xml-20040204/">Extensible
+ Markup Language (XML) 1.0 (Third Edition)</A></DT>
+<DD>The XML specification from the World Wide Web Consortium (W3C)
+<BR>
+<BR></DD>
+</DL>
+
+<!-- NEED 6 -->
+<H2><A NAME="1_5">Legal Stuff</A></H2>
+<P>The Mini-XML library is copyright 2003-2009 by Michael Sweet. License
+ terms are described in <A href="#LICENSE">Appendix A - Mini-XML License</A>
+.</P>
+<HR NOSHADE>
+<H1 align="right"><A name="INSTALL"><IMG align="right" alt="1" height="100"
+hspace="10" src="1.gif" width="100"></A>Building, Installing, and
+ Packaging Mini-XML</H1>
+<P>This chapter describes how to build, install, and package Mini-XML on
+ your system from the source archive. You will need an ANSI/ISO-C
+ compatible compiler to build Mini-XML - GCC works, as do most vendors'
+ C compilers. If you are building Mini-XML on Windows, we recommend
+ using the Visual C++ environment with the supplied solution file. For
+ other operating systems, you'll need a POSIX-compatible shell and <TT>
+make</TT> program in addition to the C compiler.</P>
+<H2><A NAME="2_1">Compiling Mini-XML</A></H2>
+<P>Mini-XML comes with both an autoconf-based configure script and a
+ Visual C++ solution that can be used to compile the library and
+ associated tools.</P>
+<H3><A NAME="2_1_1">Compiling with Visual C++</A></H3>
+<P>Open the<VAR> mxml.sln</VAR> solution in the<VAR> vcnet</VAR> folder.
+ Choose the desired build configuration, &quot;Debug&quot; (the default) or
+ &quot;Release&quot;, and then choose<VAR> Build Solution</VAR> from the<VAR>
+ Build</VAR> menu.</P>
+<H3><A NAME="2_1_2">Compiling with Command-Line Tools</A></H3>
+<P>Type the following command to configure the Mini-XML source code for
+ your system:</P>
+<PRE>
+    <KBD>./configure ENTER</KBD>
+</PRE>
+<P>The default install prefix is<VAR> /usr/local</VAR>, which can be
+ overridden using the <KBD>--prefix</KBD> option:</P>
+<PRE>
+    <KBD>./configure --prefix=/foo ENTER</KBD>
+</PRE>
+<P>Other configure options can be found using the <KBD>--help</KBD>
+ option:</P>
+<PRE>
+    <KBD>./configure --help ENTER</KBD>
+</PRE>
+<P>Once you have configured the software, use the <TT>make(1)</TT>
+ program to do the build and run the test program to verify that things
+ are working, as follows:</P>
+<PRE>
+    <KBD>make ENTER</KBD>
+</PRE>
+<H2><A NAME="2_2">Installing Mini-XML</A></H2>
+<P>If you are using Visual C++, copy the<VAR> mxml.lib</VAR> and and<VAR>
+ mxml.h</VAR> files to the Visual C++<VAR> lib</VAR> and<VAR> include<VAR>
+ directories, respectively.</VAR></VAR></P>
+<P>Otherwise, use the <TT>make</TT> command with the <KBD>install</KBD>
+ target to install Mini-XML in the configured directories:</P>
+<PRE>
+    <KBD>make install ENTER</KBD>
+</PRE>
+<H2><A NAME="2_3">Creating Mini-XML Packages</A></H2>
+<P>Mini-XML includes two files that can be used to create binary
+ packages. The first file is<VAR> mxml.spec</VAR> which is used by the <TT>
+rpmbuild(8)</TT> software to create Red Hat Package Manager (&quot;RPM&quot;)
+ packages which are commonly used on Linux. Since <TT>rpmbuild</TT>
+ wants to compile the software on its own, you can provide it with the
+ Mini-XML tar file to build the package:</P>
+<PRE>
+    <KBD>rpmbuild -ta mxml-<I>version</I>.tar.gz ENTER</KBD>
+</PRE>
+<P>The second file is<VAR> mxml.list</VAR> which is used by the <TT>
+epm(1)</TT> program to create software packages in a variety of formats.
+ The <TT>epm</TT> program is available from the following URL:</P>
+<PRE>
+    <A href="http://www.easysw.com/epm/">http://www.easysw.com/epm/</A>
+</PRE>
+<P>Use the <TT>make</TT> command with the <KBD>epm</KBD> target to
+ create portable and native packages for your system:</P>
+<PRE>
+    <KBD>make epm ENTER</KBD>
+</PRE>
+<P>The packages are stored in a subdirectory named<VAR> dist</VAR> for
+ your convenience. The portable packages utilize scripts and tar files
+ to install the software on the target system. After extracting the
+ package archive, use the<VAR> mxml.install</VAR> script to install the
+ software.</P>
+<P>The native packages will be in the local OS's native format: RPM for
+ Red Hat Linux, DPKG for Debian Linux, PKG for Solaris, and so forth.
+ Use the corresponding commands to install the native packages.</P>
+<HR NOSHADE>
+<H1 align="right"><A name="BASICS"><IMG align="right" alt="2" height="100"
+hspace="10" src="2.gif" width="100"></A>Getting Started with Mini-XML</H1>
+<P>This chapter describes how to write programs that use Mini-XML to
+ access data in an XML file. Mini-XML provides the following
+ functionality:</P>
+<UL>
+<LI>Functions for creating and managing XML documents in memory.</LI>
+<LI>Reading of UTF-8 and UTF-16 encoded XML files and strings.</LI>
+<LI>Writing of UTF-8 encoded XML files and strings.</LI>
+<LI>Support for arbitrary element names, attributes, and attribute
+ values with no preset limits, just available memory.</LI>
+<LI>Support for integer, real, opaque (&quot;cdata&quot;), and text data types in
+ &quot;leaf&quot; nodes.</LI>
+<LI>&quot;Find&quot;, &quot;index&quot;, and &quot;walk&quot; functions for easily accessing data in
+ an XML document.</LI>
+</UL>
+<P>Mini-XML doesn't do validation or other types of processing on the
+ data based upon schema files or other sources of definition
+ information, nor does it support character entities other than those
+ required by the XML specification.</P>
+<H2><A NAME="3_1">The Basics</A></H2>
+<P>Mini-XML provides a single header file which you include:</P>
+<PRE>
+    #include &lt;mxml.h&gt;
+</PRE>
+<P>The Mini-XML library is included with your program using the <KBD>
+-lmxml</KBD> option:</P>
+<PRE>
+    <KBD>gcc -o myprogram myprogram.c -lmxml ENTER</KBD>
+</PRE>
+<P>If you have the <TT>pkg-config(1)</TT> software installed, you can
+ use it to determine the proper compiler and linker options for your
+ installation:</P>
+<PRE>
+    <KBD>pkg-config --cflags mxml ENTER</KBD>
+    <KBD>pkg-config --libs mxml ENTER</KBD>
+</PRE>
+<H2><A NAME="3_2">Nodes</A></H2>
+<P>Every piece of information in an XML file (elements, text, numbers)
+ is stored in memory in &quot;nodes&quot;. Nodes are defined by the <A href="#mxml_node_t">
+<TT>mxml_node_t</TT></A> structure. The <A href="#mxml_type_t"><TT>type</TT>
+</A> member defines the node type (element, integer, opaque, real, or
+ text) which determines which value you want to look at in the <A href="#mxml_value_t">
+<TT>value</TT></A> union.</P>
+
+<!-- NEED 10 -->
+<CENTER>
+<TABLE border="1" cellpadding="5" cellspacing="0" summary="Mini-XML Node Value Members"
+width="80%"><CAPTION align="bottom"><I> Table 2-1: Mini-XML Node Value
+ Members</I></CAPTION>
+<TR bgcolor="#cccccc"><TH>Value</TH><TH>Type</TH><TH>Node member</TH></TR>
+<TR><TD>Custom</TD><TD><TT>void *</TT></TD><TD><TT>
+node-&gt;value.custom.data</TT></TD></TR>
+<TR><TD>Element</TD><TD><TT>char *</TT></TD><TD><TT>
+node-&gt;value.element.name</TT></TD></TR>
+<TR><TD>Integer</TD><TD><TT>int</TT></TD><TD><TT>node-&gt;value.integer</TT>
+</TD></TR>
+<TR><TD>Opaque (string)</TD><TD><TT>char *</TT></TD><TD><TT>
+node-&gt;value.opaque</TT></TD></TR>
+<TR><TD>Real</TD><TD><TT>double</TT></TD><TD><TT>node-&gt;value.real</TT></TD>
+</TR>
+<TR><TD>Text</TD><TD><TT>char *</TT></TD><TD><TT>node-&gt;value.text.string</TT>
+</TD></TR>
+</TABLE>
+</CENTER>
+<P>Each node also has a <TT>user_data</TT> member which allows you to
+ associate application-specific data with each node as needed.</P>
+<P>New nodes are created using the <A href="#mxmlNewElement"><TT>
+mxmlNewElement</TT></A>, <A href="#mxmlNewInteger"><TT>mxmlNewInteger</TT>
+</A>, <A href="#mxmlNewOpaque"><TT>mxmlNewOpaque</TT></A>, <A href="#mxmlNewReal">
+<TT>mxmlNewReal</TT></A>, <A href="#mxmlNewText"><TT>mxmlNewText</TT></A>
+ <A href="#mxmlNewTextf"><TT>mxmlNewTextf</TT></A> <A href="#mxmlNewXML">
+<TT>mxmlNewXML</TT></A> functions. Only elements can have child nodes,
+ and the top node must be an element, usually the <TT>&lt;?xml
+ version=&quot;1.0&quot;?&gt;</TT> node created by <TT>mxmlNewXML()</TT>.</P>
+<P>Nodes have pointers to the node above (<TT>parent</TT>), below (<TT>
+child</TT>), left (<TT>prev</TT>), and right (<TT>next</TT>) of the
+ current node. If you have an XML file like the following:</P>
+<PRE>
+    &lt;?xml version=&quot;1.0&quot;?&gt;
+    &lt;data&gt;
+        &lt;node&gt;val1&lt;/node&gt;
+        &lt;node&gt;val2&lt;/node&gt;
+        &lt;node&gt;val3&lt;/node&gt;
+        &lt;group&gt;
+            &lt;node&gt;val4&lt;/node&gt;
+            &lt;node&gt;val5&lt;/node&gt;
+            &lt;node&gt;val6&lt;/node&gt;
+        &lt;/group&gt;
+        &lt;node&gt;val7&lt;/node&gt;
+        &lt;node&gt;val8&lt;/node&gt;
+    &lt;/data&gt;
+</PRE>
+<P>the node tree for the file would look like the following in memory:</P>
+<PRE>
+    ?xml
+      |
+    data
+      |
+    node - node - node - group - node - node
+      |      |      |      |       |      |
+    val1   val2   val3     |     val7   val8
+                           |
+                         node - node - node
+                           |      |      |
+                         val4   val5   val6
+</PRE>
+<P>where &quot;-&quot; is a pointer to the next node and &quot;|&quot; is a pointer to the
+ first child node.</P>
+<P>Once you are done with the XML data, use the <A href="#mxmlDelete"><TT>
+mxmlDelete</TT></A> function to recursively free the memory that is used
+ for a particular node or the entire tree:</P>
+<PRE>
+    mxmlDelete(tree);
+</PRE>
+
+<!-- NEW PAGE -->
+<H2><A NAME="3_3">Creating XML Documents</A></H2>
+<P>You can create and update XML documents in memory using the various <TT>
+mxmlNew</TT> functions. The following code will create the XML document
+ described in the previous section:</P>
+<PRE>
+    mxml_node_t *xml;    /* &lt;?xml ... ?&gt; */
+    mxml_node_t *data;   /* &lt;data&gt; */
+    mxml_node_t *node;   /* &lt;node&gt; */
+    mxml_node_t *group;  /* &lt;group&gt; */
+
+    xml = mxmlNewXML(&quot;1.0&quot;);
+
+    data = mxmlNewElement(xml, &quot;data&quot;);
+
+        node = mxmlNewElement(data, &quot;node&quot;);
+        mxmlNewText(node, 0, &quot;val1&quot;);
+        node = mxmlNewElement(data, &quot;node&quot;);
+        mxmlNewText(node, 0, &quot;val2&quot;);
+        node = mxmlNewElement(data, &quot;node&quot;);
+        mxmlNewText(node, 0, &quot;val3&quot;);
+
+        group = mxmlNewElement(data, &quot;group&quot;);
+
+            node = mxmlNewElement(group, &quot;node&quot;);
+            mxmlNewText(node, 0, &quot;val4&quot;);
+            node = mxmlNewElement(group, &quot;node&quot;);
+            mxmlNewText(node, 0, &quot;val5&quot;);
+            node = mxmlNewElement(group, &quot;node&quot;);
+            mxmlNewText(node, 0, &quot;val6&quot;);
+
+        node = mxmlNewElement(data, &quot;node&quot;);
+        mxmlNewText(node, 0, &quot;val7&quot;);
+        node = mxmlNewElement(data, &quot;node&quot;);
+        mxmlNewText(node, 0, &quot;val8&quot;);
+</PRE>
+<P>We start by creating the <TT>&lt;?xml version=&quot;1.0&quot;?&gt;</TT> node common
+ to all XML files using the <A href="#mxmlNewXML"><TT>mxmlNewXML</TT></A>
+ function:</P>
+<PRE>
+    xml = mxmlNewXML(&quot;1.0&quot;);
+</PRE>
+<P>We then create the <TT>&lt;data&gt;</TT> node used for this document using
+ the <A href="#mxmlNewElement"><TT>mxmlNewElement</TT></A> function. The
+ first argument specifies the parent node (<TT>xml</TT>) while the
+ second specifies the element name (<TT>data</TT>):</P>
+<PRE>
+    data = mxmlNewElement(xml, &quot;data&quot;);
+</PRE>
+<P>Each <TT>&lt;node&gt;...&lt;/node&gt;</TT> in the file is created using the <TT>
+mxmlNewElement</TT> and <A href="#mxmlNewText"><TT>mxmlNewText</TT></A>
+ functions. The first argument of <TT>mxmlNewText</TT> specifies the
+ parent node (<TT>node</TT>). The second argument specifies whether
+ whitespace appears before the text - 0 or false in this case. The last
+ argument specifies the actual text to add:</P>
+<PRE>
+    node = mxmlNewElement(data, &quot;node&quot;);
+    mxmlNewText(node, 0, &quot;val1&quot;);
+</PRE>
+<P>The resulting in-memory XML document can then be saved or processed
+ just like one loaded from disk or a string.</P>
+
+<!-- NEW PAGE -->
+<H2><A NAME="3_4">Loading XML</A></H2>
+<P>You load an XML file using the <A href="#mxmlLoadFile"><TT>
+mxmlLoadFile</TT></A> function:</P>
+<PRE>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen(&quot;filename.xml&quot;, &quot;r&quot;);
+    tree = mxmlLoadFile(NULL, fp,
+                        MXML_TEXT_CALLBACK);
+    fclose(fp);
+</PRE>
+<P>The first argument specifies an existing XML parent node, if any.
+ Normally you will pass <TT>NULL</TT> for this argument unless you are
+ combining multiple XML sources. The XML file must contain a complete
+ XML document including the <TT>?xml</TT> element if the parent node is <TT>
+NULL</TT>.</P>
+<P>The second argument specifies the stdio file to read from, as opened
+ by <TT>fopen()</TT> or <TT>popen()</TT>. You can also use <TT>stdin</TT>
+ if you are implementing an XML filter program.</P>
+<P>The third argument specifies a callback function which returns the
+ value type of the immediate children for a new element node: <TT>
+MXML_CUSTOM</TT>, <TT>MXML_IGNORE</TT>, <TT>MXML_INTEGER</TT>, <TT>
+MXML_OPAQUE</TT>, <TT>MXML_REAL</TT>, or <TT>MXML_TEXT</TT>. Load
+ callbacks are described in detail in <A href="#LOAD_CALLBACKS">Chapter
+ 3</A>. The example code uses the <TT>MXML_TEXT_CALLBACK</TT> constant
+ which specifies that all data nodes in the document contain
+ whitespace-separated text values. Other standard callbacks include <TT>
+MXML_IGNORE_CALLBACK</TT>, <TT>MXML_INTEGER_CALLBACK</TT>, <TT>
+MXML_OPAQUE_CALLBACK</TT>, and <TT>MXML_REAL_CALLBACK</TT>.</P>
+<P>The <A href="#mxmlLoadString"><TT>mxmlLoadString</TT></A> function
+ loads XML node trees from a string:</P>
+
+<!-- NEED 10 -->
+<PRE>
+    char buffer[8192];
+    mxml_node_t *tree;
+
+    ...
+    tree = mxmlLoadString(NULL, buffer,
+                          MXML_TEXT_CALLBACK);
+</PRE>
+<P>The first and third arguments are the same as used for <TT>
+mxmlLoadFile()</TT>. The second argument specifies the string or
+ character buffer to load and must be a complete XML document including
+ the <TT>?xml</TT> element if the parent node is <TT>NULL</TT>.</P>
+
+<!-- NEW PAGE -->
+<H2><A NAME="3_5">Saving XML</A></H2>
+<P>You save an XML file using the <A href="#mxmlSaveFile"><TT>
+mxmlSaveFile</TT></A> function:</P>
+<PRE>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen(&quot;filename.xml&quot;, &quot;w&quot;);
+    mxmlSaveFile(tree, fp, MXML_NO_CALLBACK);
+    fclose(fp);
+</PRE>
+<P>The first argument is the XML node tree to save. It should normally
+ be a pointer to the top-level <TT>?xml</TT> node in your XML document.</P>
+<P>The second argument is the stdio file to write to, as opened by <TT>
+fopen()</TT> or <TT>popen()</TT>. You can also use <TT>stdout</TT> if
+ you are implementing an XML filter program.</P>
+<P>The third argument is the whitespace callback to use when saving the
+ file. Whitespace callbacks are covered in detail in <A href="SAVE_CALLBACKS">
+Chapter 3</A>. The previous example code uses the <TT>MXML_NO_CALLBACK</TT>
+ constant to specify that no special whitespace handling is required.</P>
+<P>The <A href="#mxmlSaveAllocString"><TT>mxmlSaveAllocString</TT></A>,
+ and <A href="#mxmlSaveString"><TT>mxmlSaveString</TT></A> functions
+ save XML node trees to strings:</P>
+<PRE>
+    char buffer[8192];
+    char *ptr;
+    mxml_node_t *tree;
+
+    ...
+    mxmlSaveString(tree, buffer, sizeof(buffer),
+                   MXML_NO_CALLBACK);
+
+    ...
+    ptr = mxmlSaveAllocString(tree, MXML_NO_CALLBACK);
+</PRE>
+<P>The first and last arguments are the same as used for <TT>
+mxmlSaveFile()</TT>. The <TT>mxmlSaveString</TT> function takes pointer
+ and size arguments for saving the XML document to a fixed-size buffer,
+ while <TT>mxmlSaveAllocString()</TT> returns a string buffer that was
+ allocated using <TT>malloc()</TT>.</P>
+<H3><A NAME="3_5_1">Controlling Line Wrapping</A></H3>
+<P>When saving XML documents, Mini-XML normally wraps output lines at
+ column 75 so that the text is readable in terminal windows. The <A href="#mxmlSetWrapMargin">
+<TT>mxmlSetWrapMargin</TT></A> function overrides the default wrap
+ margin:</P>
+<PRE>
+    /* Set the margin to 132 columns */
+    mxmlSetWrapMargin(132);
+
+    /* Disable wrapping */
+    mxmlSetWrapMargin(0);
+</PRE>
+
+<!-- NEW PAGE-->
+<H2><A NAME="3_6">Finding and Iterating Nodes</A></H2>
+<P>The <A href="#mxmlWalkPrev"><TT>mxmlWalkPrev</TT></A> and <A href="#mxmlWalkNext">
+<TT>mxmlWalkNext</TT></A>functions can be used to iterate through the
+ XML node tree:</P>
+<PRE>
+    mxml_node_t *node;
+    
+    node = mxmlWalkPrev(current, tree,
+                        MXML_DESCEND);
+
+    node = mxmlWalkNext(current, tree,
+                        MXML_DESCEND);
+</PRE>
+<P>In addition, you can find a named element/node using the <A href="#mxmlFindElement">
+<TT>mxmlFindElement</TT></A> function:</P>
+<PRE>
+    mxml_node_t *node;
+    
+    node = mxmlFindElement(tree, tree, &quot;name&quot;,
+                           &quot;attr&quot;, &quot;value&quot;,
+                           MXML_DESCEND);
+</PRE>
+<P>The <TT>name</TT>, <TT>attr</TT>, and <TT>value</TT> arguments can be
+ passed as <TT>NULL</TT> to act as wildcards, e.g.:</P>
+
+<!-- NEED 4 -->
+<PRE>
+    /* Find the first &quot;a&quot; element */
+    node = mxmlFindElement(tree, tree, &quot;a&quot;,
+                           NULL, NULL,
+                           MXML_DESCEND);
+</PRE>
+
+<!-- NEED 5 -->
+<PRE>
+    /* Find the first &quot;a&quot; element with &quot;href&quot;
+       attribute */
+    node = mxmlFindElement(tree, tree, &quot;a&quot;,
+                           &quot;href&quot;, NULL,
+                           MXML_DESCEND);
+</PRE>
+
+<!-- NEED 6 -->
+<PRE>
+    /* Find the first &quot;a&quot; element with &quot;href&quot;
+       to a URL */
+    node = mxmlFindElement(tree, tree, &quot;a&quot;,
+                           &quot;href&quot;,
+                           &quot;http://www.easysw.com/&quot;,
+                           MXML_DESCEND);
+</PRE>
+
+<!-- NEED 5 -->
+<PRE>
+    /* Find the first element with a &quot;src&quot;
+       attribute */
+    node = mxmlFindElement(tree, tree, NULL,
+                           &quot;src&quot;, NULL,
+                           MXML_DESCEND);
+</PRE>
+
+<!-- NEED 5 -->
+<PRE>
+    /* Find the first element with a &quot;src&quot;
+       = &quot;foo.jpg&quot; */
+    node = mxmlFindElement(tree, tree, NULL,
+                           &quot;src&quot;, &quot;foo.jpg&quot;,
+                           MXML_DESCEND);
+</PRE>
+<P>You can also iterate with the same function:</P>
+<PRE>
+    mxml_node_t *node;
+
+    for (node = mxmlFindElement(tree, tree,
+                                &quot;name&quot;,
+                                NULL, NULL,
+                                MXML_DESCEND);
+         node != NULL;
+         node = mxmlFindElement(node, tree,
+                                &quot;name&quot;,
+                                NULL, NULL,
+                                MXML_DESCEND))
+    {
+      ... do something ...
+    }
+</PRE>
+
+<!-- NEED 10 -->
+<P>The <TT>MXML_DESCEND</TT> argument can actually be one of three
+ constants:</P>
+<UL>
+<LI><TT>MXML_NO_DESCEND</TT> means to not to look at any child nodes in
+ the element hierarchy, just look at siblings at the same level or
+ parent nodes until the top node or top-of-tree is reached.
+<P>The previous node from &quot;group&quot; would be the &quot;node&quot; element to the
+ left, while the next node from &quot;group&quot; would be the &quot;node&quot; element to
+ the right.
+<BR>
+<BR></P>
+</LI>
+<LI><TT>MXML_DESCEND_FIRST</TT> means that it is OK to descend to the
+ first child of a node, but not to descend further when searching.
+ You'll normally use this when iterating through direct children of a
+ parent node, e.g. all of the &quot;node&quot; and &quot;group&quot; elements under the
+ &quot;?xml&quot; parent node in the example above.
+<P>This mode is only applicable to the search function; the walk
+ functions treat this as <TT>MXML_DESCEND</TT> since every call is a
+ first time.
+<BR>
+<BR></P>
+</LI>
+<LI><TT>MXML_DESCEND</TT> means to keep descending until you hit the
+ bottom of the tree. The previous node from &quot;group&quot; would be the &quot;val3&quot;
+ node and the next node would be the first node element under &quot;group&quot;.
+<P>If you were to walk from the root node &quot;?xml&quot; to the end of the tree
+ with <TT>mxmlWalkNext()</TT>, the order would be:</P>
+<P><TT>?xml data node val1 node val2 node val3 group node val4 node val5
+ node val6 node val7 node val8</TT></P>
+<P>If you started at &quot;val8&quot; and walked using <TT>mxmlWalkPrev()</TT>,
+ the order would be reversed, ending at &quot;?xml&quot;.</P>
+</LI>
+</UL>
+<HR NOSHADE>
+<H1 align="right"><A name="ADVANCED"><IMG align="right" alt="3" height="100"
+hspace="10" src="3.gif" width="100"></A>More Mini-XML Programming
+ Techniques</H1>
+<P>This chapter shows additional ways to use the Mini-XML library in
+ your programs.</P>
+<H2><A name="LOAD_CALLBACKS">Load Callbacks</A></H2>
+<P><A href="#LOAD_XML">Chapter 2</A> introduced the <A href="#mxmlLoadFile">
+<TT>mxmlLoadFile()</TT></A> and <A href="#mxmlLoadString"><TT>
+mxmlLoadString()</TT></A> functions. The last argument to these
+ functions is a callback function which is used to determine the value
+ type of each data node in an XML document.</P>
+<P>Mini-XML defines several standard callbacks for simple XML data
+ files:</P>
+<UL>
+<LI><TT>MXML_INTEGER_CALLBACK</TT> - All data nodes contain
+ whitespace-separated integers.</LI>
+<LI><TT>MXML_OPAQUE_CALLBACK</TT> - All data nodes contain opaque
+ strings (&quot;CDATA&quot;).</LI>
+<LI><TT>MXML_REAL_CALLBACK</TT> - All data nodes contain
+ whitespace-separated floating-point numbers.</LI>
+<LI><TT>MXML_TEXT_CALLBACK</TT> - All data nodes contain
+ whitespace-separated strings.</LI>
+</UL>
+<P>You can provide your own callback functions for more complex XML
+ documents. Your callback function will receive a pointer to the current
+ element node and must return the value type of the immediate children
+ for that element node: <TT>MXML_INTEGER</TT>, <TT>MXML_OPAQUE</TT>, <TT>
+MXML_REAL</TT>, or <TT>MXML_TEXT</TT>. The function is called<I> after</I>
+ the element and its attributes have been read, so you can look at the
+ element name, attributes, and attribute values to determine the proper
+ value type to return.</P>
+
+<!-- NEED 2in -->
+<P>The following callback function looks for an attribute named &quot;type&quot;
+ or the element name to determine the value type for its child nodes:</P>
+<PRE>
+    mxml_type_t
+    type_cb(mxml_node_t *node)
+    {
+      const char *type;
+
+     /*
+      * You can lookup attributes and/or use the
+      * element name, hierarchy, etc...
+      */
+
+      type = mxmlElementGetAttr(node, &quot;type&quot;);
+      if (type == NULL)
+	type = node-&gt;value.element.name;
+
+      if (!strcmp(type, &quot;integer&quot;))
+	return (MXML_INTEGER);
+      else if (!strcmp(type, &quot;opaque&quot;))
+	return (MXML_OPAQUE);
+      else if (!strcmp(type, &quot;real&quot;))
+	return (MXML_REAL);
+      else
+	return (MXML_TEXT);
+    }
+</PRE>
+<P>To use this callback function, simply use the name when you call any
+ of the load functions:</P>
+<PRE>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen(&quot;filename.xml&quot;, &quot;r&quot;);
+    tree = mxmlLoadFile(NULL, fp, <B>type_cb</B>);
+    fclose(fp);
+</PRE>
+<H2><A name="SAVE_CALLBACKS">Save Callbacks</A></H2>
+<P><A href="#LOAD_XML">Chapter 2</A> also introduced the <A href="#mxmlSaveFile">
+<TT>mxmlSaveFile()</TT></A>, <A href="#mxmlSaveString"><TT>
+mxmlSaveString()</TT></A>, and <A href="#mxmlSaveAllocString"><TT>
+mxmlSaveAllocString()</TT></A> functions. The last argument to these
+ functions is a callback function which is used to automatically insert
+ whitespace in an XML document.</P>
+<P>Your callback function will be called up to four times for each
+ element node with a pointer to the node and a &quot;where&quot; value of <TT>
+MXML_WS_BEFORE_OPEN</TT>, <TT>MXML_WS_AFTER_OPEN</TT>, <TT>
+MXML_WS_BEFORE_CLOSE</TT>, or <TT>MXML_WS_AFTER_CLOSE</TT>. The callback
+ function should return <TT>NULL</TT> if no whitespace should be added
+ and the string to insert (spaces, tabs, carriage returns, and newlines)
+ otherwise.</P>
+<P>The following whitespace callback can be used to add whitespace to
+ XHTML output to make it more readable in a standard text editor:</P>
+<PRE>
+    const char *
+    whitespace_cb(mxml_node_t *node,
+                  int where)
+    {
+      const char *name;
+
+     /*
+      * We can conditionally break to a new line
+      * before or after any element. These are
+      * just common HTML elements...
+      */
+
+      name = node-&gt;value.element.name;
+
+      if (!strcmp(name, &quot;html&quot;) ||
+          !strcmp(name, &quot;head&quot;) ||
+          !strcmp(name, &quot;body&quot;) ||
+	  !strcmp(name, &quot;pre&quot;) ||
+          !strcmp(name, &quot;p&quot;) ||
+	  !strcmp(name, &quot;h1&quot;) ||
+          !strcmp(name, &quot;h2&quot;) ||
+          !strcmp(name, &quot;h3&quot;) ||
+	  !strcmp(name, &quot;h4&quot;) ||
+          !strcmp(name, &quot;h5&quot;) ||
+          !strcmp(name, &quot;h6&quot;))
+      {
+       /*
+	* Newlines before open and after
+        * close...
+	*/
+
+	if (where == MXML_WS_BEFORE_OPEN ||
+            where == MXML_WS_AFTER_CLOSE)
+	  return (&quot;\n&quot;);
+      }
+      else if (!strcmp(name, &quot;dl&quot;) ||
+               !strcmp(name, &quot;ol&quot;) ||
+               !strcmp(name, &quot;ul&quot;))
+      {
+       /*
+	* Put a newline before and after list
+        * elements...
+	*/
+
+	return (&quot;\n&quot;);
+      }
+      else if (!strcmp(name, &quot;dd&quot;) ||
+               !strcmp(name, &quot;dt&quot;) ||
+               !strcmp(name, &quot;li&quot;))
+      {
+       /*
+	* Put a tab before &lt;li&gt;'s, * &lt;dd&gt;'s,
+        * and &lt;dt&gt;'s, and a newline after them...
+	*/
+
+	if (where == MXML_WS_BEFORE_OPEN)
+	  return (&quot;\t&quot;);
+	else if (where == MXML_WS_AFTER_CLOSE)
+	  return (&quot;\n&quot;);
+      }
+
+     /*
+      * Return NULL for no added whitespace...
+      */
+
+      return (NULL);
+    }
+</PRE>
+<P>To use this callback function, simply use the name when you call any
+ of the save functions:</P>
+<PRE>
+    FILE *fp;
+    mxml_node_t *tree;
+
+    fp = fopen(&quot;filename.xml&quot;, &quot;w&quot;);
+    mxmlSaveFile(tree, fp, <B>whitespace_cb</B>);
+    fclose(fp);
+</PRE>
+
+<!-- NEED 10 -->
+<H2><A NAME="4_3">Custom Data Types</A></H2>
+<P>Mini-XML supports custom data types via global load and save
+ callbacks. Only a single set of callbacks can be active at any time,
+ however your callbacks can store additional information in order to
+ support multiple custom data types as needed. The <TT>MXML_CUSTOM</TT>
+ node type identifies custom data nodes.</P>
+<P>The load callback receives a pointer to the current data node and a
+ string of opaque character data from the XML source with character
+ entities converted to the corresponding UTF-8 characters. For example,
+ if we wanted to support a custom date/time type whose value is encoded
+ as &quot;yyyy-mm-ddThh:mm:ssZ&quot; (ISO format), the load callback would look
+ like the following:</P>
+<PRE>
+    typedef struct
+    {
+      unsigned      year,    /* Year */
+                    month,   /* Month */
+                    day,     /* Day */
+                    hour,    /* Hour */
+                    minute,  /* Minute */
+                    second;  /* Second */
+      time_t        unix;    /* UNIX time */
+    } iso_date_time_t;
+
+    int
+    load_custom(mxml_node_t *node,
+                const char *data)
+    {
+      iso_date_time_t *dt;
+      struct tm tmdata;
+
+     /*
+      * Allocate data structure...
+      */
+
+      dt = calloc(1, sizeof(iso_date_time_t));
+
+     /*
+      * Try reading 6 unsigned integers from the
+      * data string...
+      */
+
+      if (sscanf(data, &quot;%u-%u-%uT%u:%u:%uZ&quot;,
+                 &amp;(dt-&gt;year), &amp;(dt-&gt;month),
+                 &amp;(dt-&gt;day), &amp;(dt-&gt;hour),
+                 &amp;(dt-&gt;minute),
+                 &amp;(dt-&gt;second)) != 6)
+      {
+       /*
+        * Unable to read numbers, free the data
+        * structure and return an error...
+        */
+
+        free(dt);
+
+        return (-1);
+      }
+
+     /*
+      * Range check values...
+      */
+
+      if (dt-&gt;month &lt;1 || dt-&gt;month &gt; 12 ||
+          dt-&gt;day  &lt;1 || dt-&gt;day &gt; 31 ||
+          dt-&gt;hour  &lt;0 || dt-&gt;hour &gt; 23 ||
+          dt-&gt;minute  &lt;0 || dt-&gt;minute &gt; 59 ||
+          dt-&gt;second  &lt;0 || dt-&gt;second &gt; 59)
+      {
+       /*
+        * Date information is out of range...
+        */
+
+        free(dt);
+
+        return (-1);
+      }
+
+     /*
+      * Convert ISO time to UNIX time in
+      * seconds...
+      */
+
+      tmdata.tm_year = dt-&gt;year - 1900;
+      tmdata.tm_mon  = dt-&gt;month - 1;
+      tmdata.tm_day  = dt-&gt;day;
+      tmdata.tm_hour = dt-&gt;hour;
+      tmdata.tm_min  = dt-&gt;minute;
+      tmdata.tm_sec  = dt-&gt;second;
+
+      dt-&gt;unix = gmtime(&amp;tmdata);
+
+     /*
+      * Assign custom node data and destroy
+      * function pointers...
+      */
+
+      node-&gt;value.custom.data    = dt;
+      node-&gt;value.custom.destroy = free;
+
+     /*
+      * Return with no errors...
+      */
+
+      return (0);
+    }
+</PRE>
+<P>The function itself can return 0 on success or -1 if it is unable to
+ decode the custom data or the data contains an error. Custom data nodes
+ contain a <TT>void</TT> pointer to the allocated custom data for the
+ node and a pointer to a destructor function which will free the custom
+ data when the node is deleted.</P>
+<P>The save callback receives the node pointer and returns an allocated
+ string containing the custom data value. The following save callback
+ could be used for our ISO date/time type:</P>
+<PRE>
+    char *
+    save_custom(mxml_node_t *node)
+    {
+      char data[255];
+      iso_date_time_t *dt;
+
+
+      dt = (iso_date_time_t *)node-&gt;custom.data;
+
+      snprintf(data, sizeof(data),
+               &quot;%04u-%02u-%02uT%02u:%02u:%02uZ&quot;,
+               dt-&gt;year, dt-&gt;month, dt-&gt;day,
+               dt-&gt;hour, dt-&gt;minute, dt-&gt;second);
+
+      return (strdup(data));
+    }
+</PRE>
+<P>You register the callback functions using the <A href="#mxmlSetCustomHandlers">
+<TT>mxmlSetCustomHandlers()</TT></A> function:</P>
+<PRE>
+    mxmlSetCustomHandlers(<B>load_custom</B>,
+                          <B>save_custom</B>);
+</PRE>
+
+<!-- NEED 20 -->
+<H2><A NAME="4_4">Changing Node Values</A></H2>
+<P>All of the examples so far have concentrated on creating and loading
+ new XML data nodes. Many applications, however, need to manipulate or
+ change the nodes during their operation, so Mini-XML provides functions
+ to change node values safely and without leaking memory.</P>
+<P>Existing nodes can be changed using the <A href="#mxmlSetElement"><TT>
+mxmlSetElement()</TT></A>, <A href="#mxmlSetInteger"><TT>
+mxmlSetInteger()</TT></A>, <A href="#mxmlSetOpaque"><TT>mxmlSetOpaque()</TT>
+</A>, <A href="#mxmlSetReal"><TT>mxmlSetReal()</TT></A>, <A href="#mxmlSetText">
+<TT>mxmlSetText()</TT></A>, and <A href="#mxmlSetTextf"><TT>
+mxmlSetTextf()</TT></A> functions. For example, use the following
+ function call to change a text node to contain the text &quot;new&quot; with
+ leading whitespace:</P>
+<PRE>
+    mxml_node_t *node;
+
+    mxmlSetText(node, 1, &quot;new&quot;);
+</PRE>
+<H2><A NAME="4_5">Formatted Text</A></H2>
+<P>The <A href="#mxmlNewTextf"><TT>mxmlNewTextf()</TT></A> and <A href="#mxmlSetTextf">
+<TT>mxmlSetTextf()</TT></A> functions create and change text nodes,
+ respectively, using <TT>printf</TT>-style format strings and arguments.
+ For example, use the following function call to create a new text node
+ containing a constructed filename:</P>
+<PRE>
+    mxml_node_t *node;
+
+    node = mxmlNewTextf(node, 1, &quot;%s/%s&quot;,
+                        path, filename);
+</PRE>
+<H2><A NAME="4_6">Indexing</A></H2>
+<P>Mini-XML provides functions for managing indices of nodes. The
+ current implementation provides the same functionality as <A href="#mxmlFindElement">
+<TT>mxmlFindElement()</TT></A>. The advantage of using an index is that
+ searching and enumeration of elements is significantly faster. The only
+ disadvantage is that each index is a static snapshot of the XML
+ document, so indices are not well suited to XML data that is updated
+ more often than it is searched. The overhead of creating an index is
+ approximately equal to walking the XML document tree. Nodes in the
+ index are sorted by element name and attribute value.</P>
+<P>Indices are stored in <A href="#mxml_index_t"><TT>mxml_index_t</TT></A>
+ structures. The <A href="#mxmlIndexNew"><TT>mxmlIndexNew()</TT></A>
+ function creates a new index:</P>
+<PRE>
+    mxml_node_t *tree;
+    mxml_index_t *ind;
+
+    ind = mxmlIndexNew(tree, &quot;element&quot;,
+                       &quot;attribute&quot;);
+</PRE>
+<P>The first argument is the XML node tree to index. Normally this will
+ be a pointer to the <TT>?xml</TT> element.</P>
+<P>The second argument contains the element to index; passing <TT>NULL</TT>
+ indexes all element nodes alphabetically.</P>
+<P>The third argument contains the attribute to index; passing <TT>NULL</TT>
+ causes only the element name to be indexed.</P>
+<P>Once the index is created, the <A href="#mxmlIndexEnum"><TT>
+mxmlIndexEnum()</TT></A>, <A href="#mxmlIndexFind"><TT>mxmlIndexFind()</TT>
+</A>, and <A href="#mxmlIndexReset"><TT>mxmlIndexReset()</TT></A>
+ functions are used to access the nodes in the index. The <A href="#mxmlIndexReset">
+<TT>mxmlIndexReset()</TT></A> function resets the &quot;current&quot; node pointer
+ in the index, allowing you to do new searches and enumerations on the
+ same index. Typically you will call this function prior to your calls
+ to <A href="#mxmlIndexEnum"><TT>mxmlIndexEnum()</TT></A> and <A href="#mxmlIndexFind">
+<TT>mxmlIndexFind()</TT></A>.</P>
+<P>The <A href="#mxmlIndexEnum"><TT>mxmlIndexEnum()</TT></A> function
+ enumerates each of the nodes in the index and can be used in a loop as
+ follows:</P>
+<PRE>
+    mxml_node_t *node;
+
+    mxmlIndexReset(ind);
+
+    while ((node = mxmlIndexEnum(ind)) != NULL)
+    {
+      // do something with node
+    }
+</PRE>
+<P>The <A href="#mxmlIndexFind"><TT>mxmlIndexFind()</TT></A> function
+ locates the next occurrence of the named element and attribute value in
+ the index. It can be used to find all matching elements in an index, as
+ follows:</P>
+<PRE>
+    mxml_node_t *node;
+
+    mxmlIndexReset(ind);
+
+    while ((node = mxmlIndexFind(ind, &quot;element&quot;,
+                                 &quot;attr-value&quot;))
+                != NULL)
+    {
+      // do something with node
+    }
+</PRE>
+<P>The second and third arguments represent the element name and
+ attribute value, respectively. A <TT>NULL</TT> pointer is used to
+ return all elements or attributes in the index. Passing <TT>NULL</TT>
+ for both the element name and attribute value is equivalent to calling <TT>
+mxmlIndexEnum</TT>.</P>
+<P>When you are done using the index, delete it using the <A href="#mxmlIndexDelete()">
+<TT>mxmlIndexDelete()</TT></A> function:</P>
+<PRE>
+    mxmlIndexDelete(ind);
+</PRE>
+<H2><A NAME="4_7">SAX (Stream) Loading of Documents</A></H2>
+<P>Mini-XML supports an implementation of the Simple API for XML (SAX)
+ which allows you to load and process an XML document as a stream of
+ nodes. Aside from allowing you to process XML documents of any size,
+ the Mini-XML implementation also allows you to retain portions of the
+ document in memory for later processing.</P>
+<P>The <A href="#mxmlSAXLoad"><TT>mxmlSAXLoadFd</TT></A>, <A href="#mxmlSAXLoadFile">
+<TT>mxmlSAXLoadFile</TT></A>, and <A href="#mxmlSAXLoadString"><TT>
+mxmlSAXLoadString</TT></A> functions provide the SAX loading APIs. Each
+ function works like the corresponding <TT>mxmlLoad</TT> function but
+ uses a callback to process each node as it is read.</P>
+<P>The callback function receives the node, an event code, and a user
+ data pointer you supply:</P>
+<PRE>
+    void
+    sax_cb(mxml_node_t *node,
+           mxml_sax_event_t event,
+           void *data)
+    {
+      ... do something ...
+    }
+</PRE>
+<P>The event will be one of the following:</P>
+<UL>
+<LI><TT>MXML_SAX_CDATA</TT> - CDATA was just read</LI>
+<LI><TT>MXML_SAX_COMMENT</TT> - A comment was just read</LI>
+<LI><TT>MXML_SAX_DATA</TT> - Data (custom, integer, opaque, real, or
+ text) was just read</LI>
+<LI><TT>MXML_SAX_DIRECTIVE</TT> - A processing directive was just read</LI>
+<LI><TT>MXML_SAX_ELEMENT_CLOSE</TT> - A close element was just read (<TT>
+&lt;/element&gt;</TT>)</LI>
+<LI><TT>MXML_SAX_ELEMENT_OPEN</TT> - An open element was just read (<TT>
+&lt;element&gt;</TT>)</LI>
+</UL>
+<P>Elements are<EM> released</EM> after the close element is processed.
+ All other nodes are released after they are processed. The SAX callback
+ can<EM> retain</EM> the node using the <A href="#mxmlRetain"><TT>
+mxmlRetain</TT></A> function. For example, the following SAX callback
+ will retain all nodes, effectively simulating a normal in-memory load:</P>
+<PRE>
+    void
+    sax_cb(mxml_node_t *node,
+           mxml_sax_event_t event,
+           void *data)
+    {
+      if (event != MXML_SAX_ELEMENT_CLOSE)
+        mxmlRetain(node);
+    }
+</PRE>
+<P>More typically the SAX callback will only retain a small portion of
+ the document that is needed for post-processing. For example, the
+ following SAX callback will retain the title and headings in an XHTML
+ file. It also retains the (parent) elements like <TT>&lt;html&gt;</TT>, <TT>
+&lt;head&gt;</TT>, and <TT>&lt;body&gt;</TT>, and processing directives like <TT>
+&lt;?xml ... ?&gt;</TT> and <TT>&lt;!DOCTYPE ... &gt;</TT>:</P>
+
+<!-- NEED 10 -->
+<PRE>
+    void
+    sax_cb(mxml_node_t *node,
+           mxml_sax_event_t event,
+           void *data)
+    {
+      if (event == MXML_SAX_ELEMENT_OPEN)
+      {
+       /*
+        * Retain headings and titles...
+        */
+
+        char *name = node-&gt;value.element.name;
+
+        if (!strcmp(name, &quot;html&quot;) ||
+            !strcmp(name, &quot;head&quot;) ||
+            !strcmp(name, &quot;title&quot;) ||
+            !strcmp(name, &quot;body&quot;) ||
+            !strcmp(name, &quot;h1&quot;) ||
+            !strcmp(name, &quot;h2&quot;) ||
+            !strcmp(name, &quot;h3&quot;) ||
+            !strcmp(name, &quot;h4&quot;) ||
+            !strcmp(name, &quot;h5&quot;) ||
+            !strcmp(name, &quot;h6&quot;))
+          mxmlRetain(node);
+      }
+      else if (event == MXML_SAX_DIRECTIVE)
+        mxmlRetain(node);
+      else if (event == MXML_SAX_DATA &amp;&amp;
+               node-&gt;parent-&gt;ref_count &gt; 1)
+      {
+       /*
+        * If the parent was retained, then retain
+        * this data node as well.
+        */
+
+        mxmlRetain(node);
+      }
+    }
+</PRE>
+<P>The resulting skeleton document tree can then be searched just like
+ one loaded using the <TT>mxmlLoad</TT> functions. For example, a filter
+ that reads an XHTML document from stdin and then shows the title and
+ headings in the document would look like:</P>
+<PRE>
+    mxml_node_t *doc, *title, *body, *heading;
+
+    doc = mxmlSAXLoadFd(NULL, 0,
+                        MXML_TEXT_CALLBACK,
+                        <B>sax_cb</B>, NULL);
+
+    title = mxmlFindElement(doc, doc, &quot;title&quot;,
+                            NULL, NULL,
+                            MXML_DESCEND);
+
+    if (title)
+      print_children(title);
+
+    body = mxmlFindElement(doc, doc, &quot;body&quot;,
+                           NULL, NULL,
+                           MXML_DESCEND);
+
+    if (body)
+    {
+      for (heading = body-&gt;child;
+           heading;
+           heading = heading-&gt;next)
+        print_children(heading);
+    }
+</PRE>
+<HR NOSHADE>
+<H1 align="right"><A name="MXMLDOC"><IMG align="right" alt="4" height="100"
+hspace="10" src="4.gif" width="100"></A>Using the mxmldoc Utility</H1>
+<P>This chapter describes how to use <TT>mxmldoc(1)</TT> program to
+ automatically generate documentation from C and C++ source files.</P>
+<H2><A NAME="5_1">The Basics</A></H2>
+<P>Originally developed to generate the Mini-XML and CUPS API
+ documentation, <TT>mxmldoc</TT> is now a general-purpose utility which
+ scans C and C++ source files to produce HTML and man page documentation
+ along with an XML file representing the functions, types, and
+ definitions in those source files. Unlike popular documentation
+ generators like Doxygen or Javadoc, <TT>mxmldoc</TT> uses in-line
+ comments rather than comment headers, allowing for more &quot;natural&quot; code
+ documentation.</P>
+<P>By default, <TT>mxmldoc</TT> produces HTML documentation. For
+ example, the following command will scan all of the C source and header
+ files in the current directory and produce a HTML documentation file
+ called<VAR> filename.html</VAR>:</P>
+<PRE>
+    <KBD>mxmldoc *.h *.c &gt;filename.html ENTER</KBD>
+</PRE>
+<P>You can also specify an XML file to create which contains all of the
+ information from the source files. For example, the following command
+ creates an XML file called<VAR> filename.xml</VAR> in addition to the
+ HTML file:</P>
+<PRE>
+    <KBD>mxmldoc filename.xml *.h *.c &gt;filename.html ENTER</KBD>
+</PRE>
+<P>The <TT>--no-output</TT> option disables the normal HTML output:</P>
+<PRE>
+    <KBD>mxmldoc --no-output filename.xml *.h *.c ENTER</KBD>
+</PRE>
+<P>You can then run <TT>mxmldoc</TT> again with the XML file alone to
+ generate the HTML documentation:</P>
+<PRE>
+    <KBD>mxmldoc filename.xml &gt;filename.html ENTER</KBD>
+</PRE>
+<H3><A NAME="5_1_1">Creating Man Pages</A></H3>
+<P>The <TT>--man filename</TT> option tells <TT>mxmldoc</TT> to create a
+ man page instead of HTML documentation, for example:</P>
+<PRE>
+    <KBD>mxmldoc --man filename filename.xml \
+        &gt;filename.man ENTER</KBD>
+
+    <KBD>mxmldoc --man filename *.h *.c \
+        &gt;filename.man ENTER</KBD>
+</PRE>
+<H3><A NAME="5_1_2">Creating Xcode Documentation Sets</A></H3>
+<P>The <TT>--docset directory.docset</TT> option tells <TT>mxmldoc</TT>
+ to create an Xcode documentation set containing the HTML documentation,
+ for example:</P>
+<PRE>
+    <KBD>mxmldoc --docset foo.docset *.h *.c foo.xml ENTER</KBD>
+</PRE>
+<P>Xcode documentation sets can only be built on Mac OS X with Xcode 3.0
+ or higher installed.</P>
+<H2><A NAME="5_2">Commenting Your Code</A></H2>
+<P>As noted previously, <TT>mxmldoc</TT> looks for in-line comments to
+ describe the functions, types, and constants in your code. <TT>Mxmldoc</TT>
+ will document all public names it finds in your source files - any
+ names starting with the underscore character (_) or names that are
+ documented with the <A HREF="#ATDIRECTIVES">@private@</A> directive are
+ treated as private and are undocumented.</P>
+<P>Comments appearing directly before a function or type definition are
+ used to document that function or type. Comments appearing after
+ argument, definition, return type, or variable declarations are used to
+ document that argument, definition, return type, or variable. For
+ example, the following code excerpt defines a key/value structure and a
+ function that creates a new instance of that structure:</P>
+<PRE>
+    /* A key/value pair. This is used with the
+       dictionary structure. */
+
+    struct keyval
+    {
+      char *key; /* Key string */
+      char *val; /* Value string */
+    };
+
+    /* Create a new key/value pair. */
+
+    struct keyval * /* New key/value pair */
+    new_keyval(
+        const char *key, /* Key string */
+	const char *val) /* Value string */
+    {
+      ...
+    }
+</PRE>
+<P><TT>Mxmldoc</TT> also knows to remove extra asterisks (*) from the
+ comment string, so the comment string:</P>
+<PRE>
+    /*
+     * Compute the value of PI.
+     *
+     * The function connects to an Internet server
+     * that streams audio of mathematical monks
+     * chanting the first 100 digits of PI.
+     */
+</PRE>
+<P>will be shown as:</P>
+<PRE>
+    Compute the value of PI.
+
+    The function connects to an Internet server
+    that streams audio of mathematical monks
+    chanting the first 100 digits of PI.
+</PRE>
+<P><A name="ATDIRECTIVES">Comments</A> can also include the following
+ special <TT>@name ...@</TT> directive strings:</P>
+<UL>
+<LI><TT>@deprecated@</TT> - flags the item as deprecated to discourage
+ its use</LI>
+<LI><TT>@private@</TT> - flags the item as private so it will not be
+ included in the documentation</LI>
+<LI><TT>@since ...@</TT> - flags the item as new since a particular
+ release. The text following the <TT>@since</TT> up to the closing <TT>@</TT>
+ is highlighted in the generated documentation, e.g. <TT>@since CUPS
+ 1.3@</TT>.</LI>
+</UL>
+
+<!-- NEED 10 -->
+<H2><A NAME="5_3">Titles, Sections, and Introductions</A></H2>
+<P><TT>Mxmldoc</TT> also provides options to set the title, section, and
+ introduction text for the generated documentation. The <TT>--title text</TT>
+ option specifies the title for the documentation. The title string is
+ usually put in quotes:</P>
+<PRE>
+    <KBD>mxmldoc filename.xml \
+        --title &quot;My Famous Documentation&quot; \
+        &gt;filename.html ENTER</KBD>
+</PRE>
+<P>The <TT>--section name</TT> option specifies the section for the
+ documentation. For HTML documentation, the name is placed in a HTML
+ comment such as:</P>
+<PRE>
+    &lt;!-- SECTION: name --&gt;
+</PRE>
+<P>For man pages, the section name is usually just a number (&quot;3&quot;), or a
+ number followed by a vendor name (&quot;3acme&quot;). The section name is used in
+ the <TT>.TH</TT> directive in the man page:</P>
+<PRE>
+    .TH mylibrary 3acme &quot;My Title&quot; ...
+</PRE>
+<P>The default section name for man page output is &quot;3&quot;. There is no
+ default section name for HTML output.</P>
+<P>Finally, the <TT>--intro filename</TT> option specifies a file to
+ embed after the title and section but before the generated
+ documentation. For HTML documentation, the file must consist of valid
+ HTML without the usual <TT>DOCTYPE</TT>, <TT>html</TT>, and <TT>body</TT>
+ elements. For man page documentation, the file must consist of valid <TT>
+nroff(1)</TT> text.</P>
+<HR NOSHADE>
+<H1 align="right"><A name="LICENSE"><IMG align="right" alt="A" height="100"
+hspace="10" src="A.gif" width="100"></A>Mini-XML License</H1>
+<P>The Mini-XML library and included programs are provided under the
+ terms of the GNU Library General Public License (LGPL) with the
+ following exceptions:</P>
+<OL>
+<LI>Static linking of applications to the Mini-XML library does not
+ constitute a derivative work and does not require the author to provide
+ source code for the application, use the shared Mini-XML libraries, or
+ link their applications against a user-supplied version of Mini-XML.
+<P><I>If you link the application to a modified version of Mini-XML,
+ then the changes to Mini-XML must be provided under the terms of the
+ LGPL in sections 1, 2, and 4.</I></P>
+</LI>
+<LI>You do not have to provide a copy of the Mini-XML license with
+ programs that are linked to the Mini-XML library, nor do you have to
+ identify the Mini-XML license in your program or documentation as
+ required by section 6 of the LGPL.</LI>
+</OL>
+
+<!-- NEW PAGE -->
+<P align="center"><B>GNU LIBRARY GENERAL PUBLIC LICENSE</B></P>
+<P align="center">Version 2, June 1991
+<BR> Copyright (C) 1991 Free Software Foundation, Inc.
+<BR> 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+<BR> Everyone is permitted to copy and distribute verbatim copies of
+ this license document, but changing it is not allowed.
+<BR> [This is the first released version of the library GPL. It is
+ numbered 2 because it goes with version 2 of the ordinary GPL.]</P>
+<P><B>Preamble</B></P>
+<P>The licenses for most software are designed to take away your freedom
+ to share and change it. By contrast, the GNU General Public Licenses
+ are intended to guarantee your freedom to share and change free
+ software--to make sure the software is free for all its users.</P>
+<P>This license, the Library General Public License, applies to some
+ specially designated Free Software Foundation software, and to any
+ other libraries whose authors decide to use it. You can use it for your
+ libraries, too.</P>
+<P>When we speak of free software, we are referring to freedom, not
+ price. Our General Public Licenses are designed to make sure that you
+ have the freedom to distribute copies of free software (and charge for
+ this service if you wish), that you receive source code or can get it
+ if you want it, that you can change the software or use pieces of it in
+ new free programs; and that you know you can do these things.</P>
+<P>To protect your rights, we need to make restrictions that forbid
+ anyone to deny you these rights or to ask you to surrender the rights.
+ These restrictions translate to certain responsibilities for you if you
+ distribute copies of the library, or if you modify it.</P>
+<P>For example, if you distribute copies of the library, whether gratis
+ or for a fee, you must give the recipients all the rights that we gave
+ you. You must make sure that they, too, receive or can get the source
+ code. If you link a program with the library, you must provide complete
+ object files to the recipients so that they can relink them with the
+ library, after making changes to the library and recompiling it. And
+ you must show them these terms so they know their rights.</P>
+<P>Our method of protecting your rights has two steps: (1) copyright the
+ library, and (2) offer you this license which gives you legal
+ permission to copy, distribute and/or modify the library.</P>
+<P>Also, for each distributor's protection, we want to make certain that
+ everyone understands that there is no warranty for this free library.
+ If the library is modified by someone else and passed on, we want its
+ recipients to know that what they have is not the original version, so
+ that any problems introduced by others will not reflect on the original
+ authors' reputations.</P>
+<P>Finally, any free program is threatened constantly by software
+ patents. We wish to avoid the danger that companies distributing free
+ software will individually obtain patent licenses, thus in effect
+ transforming the program into proprietary software. To prevent this, we
+ have made it clear that any patent must be licensed for everyone's free
+ use or not licensed at all.</P>
+<P>Most GNU software, including some libraries, is covered by the
+ ordinary GNU General Public License, which was designed for utility
+ programs. This license, the GNU Library General Public License, applies
+ to certain designated libraries. This license is quite different from
+ the ordinary one; be sure to read it in full, and don't assume that
+ anything in it is the same as in the ordinary license.</P>
+<P>The reason we have a separate public license for some libraries is
+ that they blur the distinction we usually make between modifying or
+ adding to a program and simply using it. Linking a program with a
+ library, without changing the library, is in some sense simply using
+ the library, and is analogous to running a utility program or
+ application program. However, in a textual and legal sense, the linked
+ executable is a combined work, a derivative of the original library,
+ and the ordinary General Public License treats it as such.</P>
+<P>Because of this blurred distinction, using the ordinary General
+ Public License for libraries did not effectively promote software
+ sharing, because most developers did not use the libraries. We
+ concluded that weaker conditions might promote sharing better.</P>
+<P>However, unrestricted linking of non-free programs would deprive the
+ users of those programs of all benefit from the free status of the
+ libraries themselves. This Library General Public License is intended
+ to permit developers of non-free programs to use free libraries, while
+ preserving your freedom as a user of such programs to change the free
+ libraries that are incorporated in them. (We have not seen how to
+ achieve this as regards changes in header files, but we have achieved
+ it as regards changes in the actual functions of the Library.) The hope
+ is that this will lead to faster development of free libraries.</P>
+<P>The precise terms and conditions for copying, distribution and
+ modification follow. Pay close attention to the difference between a
+ &quot;work based on the libary&quot; and a &quot;work that uses the library&quot;. The
+ former contains code derived from the library, while the latter only
+ works together with the library.</P>
+<P>Note that it is possible for a library to be covered by the ordinary
+ General Public License rather than by this special one.</P>
+<P align="center"><B>TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND
+ MODIFICATION</B></P>
+<P><STRONG>0.</STRONG> This License Agreement applies to any software
+ library which contains a notice placed by the copyright holder or other
+ authorized party saying it may be distributed under the terms of this
+ Library General Public License (also called &quot;this License&quot;). Each
+ licensee is addressed as &quot;you&quot;.</P>
+<P>A &quot;library&quot; means a collection of software functions and/or data
+ prepared so as to be conveniently linked with application programs
+ (which use some of those functions and data) to form executables.</P>
+<P>The &quot;Library&quot;, below, refers to any such software library or work
+ which has been distributed under these terms. A &quot;work based on the
+ Library&quot; means either the Library or any derivative work under
+ copyright law: that is to say, a work containing the Library or a
+ portion of it, either verbatim or with modifications and/or translated
+ straightforwardly into another language. (Hereinafter, translation is
+ included without limitation in the term &quot;modification&quot;.)</P>
+<P>&quot;Source code&quot; for a work means the preferred form of the work for
+ making modifications to it. For a library, complete source code means
+ all the source code for all modules it contains, plus any associated
+ interface definition files, plus the scripts used to control
+ compilation and installation of the library.</P>
+<P>Activities other than copying, distribution and modification are not
+ covered by this License; they are outside its scope. The act of running
+ a program using the Library is not restricted, and output from such a
+ program is covered only if its contents constitute a work based on the
+ Library (independent of the use of the Library in a tool for writing
+ it). Whether that is true depends on what the Library does and what the
+ program that uses the Library does.</P>
+<P><STRONG>1.</STRONG> You may copy and distribute verbatim copies of
+ the Library's complete source code as you receive it, in any medium,
+ provided that you conspicuously and appropriately publish on each copy
+ an appropriate copyright notice and disclaimer of warranty; keep intact
+ all the notices that refer to this License and to the absence of any
+ warranty; and distribute a copy of this License along with the Library.</P>
+<P>You may charge a fee for the physical act of transferring a copy, and
+ you may at your option offer warranty protection in exchange for a fee.</P>
+<P><STRONG>2.</STRONG> You may modify your copy or copies of the Library
+ or any portion of it, thus forming a work based on the Library, and
+ copy and distribute such modifications or work under the terms of
+ Section 1 above, provided that you also meet all of these conditions:</P>
+<UL>
+<P><STRONG>a)</STRONG> The modified work must itself be a software
+ library.</P>
+<P><STRONG>b)</STRONG> You must cause the files modified to carry
+ prominent notices stating that you changed the files and the date of
+ any change.</P>
+<P><STRONG>c)</STRONG> You must cause the whole of the work to be
+ licensed at no charge to all third parties under the terms of this
+ License.</P>
+<P><STRONG>d)</STRONG> If a facility in the modified Library refers to a
+ function or a table of data to be supplied by an application program
+ that uses the facility, other than as an argument passed when the
+ facility is invoked, then you must make a good faith effort to ensure
+ that, in the event an application does not supply such function or
+ table, the facility still operates, and performs whatever part of its
+ purpose remains meaningful.</P>
+<P>(For example, a function in a library to compute square roots has a
+ purpose that is entirely well-defined independent of the application.
+ Therefore, Subsection 2d requires that any application-supplied
+ function or table used by this function must be optional: if the
+ application does not supply it, the square root function must still
+ compute square roots.)</P>
+</UL>
+<P>These requirements apply to the modified work as a whole. If
+ identifiable sections of that work are not derived from the Library,
+ and can be reasonably considered independent and separate works in
+ themselves, then this License, and its terms, do not apply to those
+ sections when you distribute them as separate works. But when you
+ distribute the same sections as part of a whole which is a work based
+ on the Library, the distribution of the whole must be on the terms of
+ this License, whose permissions for other licensees extend to the
+ entire whole, and thus to each and every part regardless of who wrote
+ it.</P>
+<P>Thus, it is not the intent of this section to claim rights or contest
+ your rights to work written entirely by you; rather, the intent is to
+ exercise the right to control the distribution of derivative or
+ collective works based on the Library.</P>
+<P>In addition, mere aggregation of another work not based on the
+ Library with the Library (or with a work based on the Library) on a
+ volume of a storage or distribution medium does not bring the other
+ work under the scope of this License.</P>
+<P><STRONG>3.</STRONG> You may opt to apply the terms of the ordinary
+ GNU General Public License instead of this License to a given copy of
+ the Library. To do this, you must alter all the notices that refer to
+ this License, so that they refer to the ordinary GNU General Public
+ License, version 2, instead of to this License. (If a newer version
+ than version 2 of the ordinary GNU General Public License has appeared,
+ then you can specify that version instead if you wish.) Do not make any
+ other change in these notices.</P>
+<P>Once this change is made in a given copy, it is irreversible for that
+ copy, so the ordinary GNU General Public License applies to all
+ subsequent copies and derivative works made from that copy.</P>
+<P>This option is useful when you wish to copy part of the code of the
+ Library into a program that is not a library.</P>
+<P><STRONG>4.</STRONG> You may copy and distribute the Library (or a
+ portion or derivative of it, under Section 2) in object code or
+ executable form under the terms of Sections 1 and 2 above provided that
+ you accompany it with the complete corresponding machine-readable
+ source code, which must be distributed under the terms of Sections 1
+ and 2 above on a medium customarily used for software interchange.</P>
+<P>If distribution of object code is made by offering access to copy
+ from a designated place, then offering equivalent access to copy the
+ source code from the same place satisfies the requirement to distribute
+ the source code, even though third parties are not compelled to copy
+ the source along with the object code.</P>
+<P><STRONG>5.</STRONG> A program that contains no derivative of any
+ portion of the Library, but is designed to work with the Library by
+ being compiled or linked with it, is called a &quot;work that uses the
+ Library&quot;. Such a work, in isolation, is not a derivative work of the
+ Library, and therefore falls outside the scope of this License.</P>
+<P>However, linking a &quot;work that uses the Library&quot; with the Library
+ creates an executable that is a derivative of the Library (because it
+ contains portions of the Library), rather than a &quot;work that uses the
+ library&quot;. The executable is therefore covered by this License. Section
+ 6 states terms for distribution of such executables.</P>
+<P>When a &quot;work that uses the Library&quot; uses material from a header file
+ that is part of the Library, the object code for the work may be a
+ derivative work of the Library even though the source code is not.
+ Whether this is true is especially significant if the work can be
+ linked without the Library, or if the work is itself a library. The
+ threshold for this to be true is not precisely defined by law.</P>
+<P>If such an object file uses only numerical parameters, data structure
+ layouts and accessors, and small macros and small inline functions (ten
+ lines or less in length), then the use of the object file is
+ unrestricted, regardless of whether it is legally a derivative work.
+ (Executables containing this object code plus portions of the Library
+ will still fall under Section 6.)</P>
+<P>Otherwise, if the work is a derivative of the Library, you may
+ distribute the object code for the work under the terms of Section 6.
+ Any executables containing that work also fall under Section 6, whether
+ or not they are linked directly with the Library itself.</P>
+<P><STRONG>6.</STRONG> As an exception to the Sections above, you may
+ also compile or link a &quot;work that uses the Library&quot; with the Library to
+ produce a work containing portions of the Library, and distribute that
+ work under terms of your choice, provided that the terms permit
+ modification of the work for the customer's own use and reverse
+ engineering for debugging such modifications.</P>
+<P>You must give prominent notice with each copy of the work that the
+ Library is used in it and that the Library and its use are covered by
+ this License. You must supply a copy of this License. If the work
+ during execution displays copyright notices, you must include the
+ copyright notice for the Library among them, as well as a reference
+ directing the user to the copy of this License. Also, you must do one
+ of these things:</P>
+<UL><STRONG> a)</STRONG> Accompany the work with the complete
+ corresponding machine-readable source code for the Library including
+ whatever changes were used in the work (which must be distributed under
+ Sections 1 and 2 above); and, if the work is an executable linked with
+ the Library, with the complete machine-readable &quot;work that uses the
+ Library&quot;, as object code and/or source code, so that the user can
+ modify the Library and then relink to produce a modified executable
+ containing the modified Library. (It is understood that the user who
+ changes the contents of definitions files in the Library will not
+ necessarily be able to recompile the application to use the modified
+ definitions.)
+<P><STRONG>b)</STRONG> Accompany the work with a written offer, valid
+ for at least three years, to give the same user the materials specified
+ in Subsection 6a, above, for a charge no more than the cost of
+ performing this distribution.</P>
+<P><STRONG>c)</STRONG> If distribution of the work is made by offering
+ access to copy from a designated place, offer equivalent access to copy
+ the above specified materials from the same place.</P>
+<P><STRONG>d)</STRONG> Verify that the user has already received a copy
+ of these materials or that you have already sent this user a copy.</P>
+</UL>
+<P>For an executable, the required form of the &quot;work that uses the
+ Library&quot; must include any data and utility programs needed for
+ reproducing the executable from it. However, as a special exception,
+ the source code distributed need not include anything that is normally
+ distributed (in either source or binary form) with the major components
+ (compiler, kernel, and so on) of the operating system on which the
+ executable runs, unless that component itself accompanies the
+ executable.</P>
+<P>It may happen that this requirement contradicts the license
+ restrictions of other proprietary libraries that do not normally
+ accompany the operating system. Such a contradiction means you cannot
+ use both them and the Library together in an executable that you
+ distribute.</P>
+<P><STRONG>7.</STRONG> You may place library facilities that are a work
+ based on the Library side-by-side in a single library together with
+ other library facilities not covered by this License, and distribute
+ such a combined library, provided that the separate distribution of the
+ work based on the Library and of the other library facilities is
+ otherwise permitted, and provided that you do these two things:</P>
+<UL><STRONG> a)</STRONG> Accompany the combined library with a copy of
+ the same work based on the Library, uncombined with any other library
+ facilities. This must be distributed under the terms of the Sections
+ above.
+<P><STRONG>b)</STRONG> Give prominent notice with the combined library
+ of the fact that part of it is a work based on the Library, and
+ explaining where to find the accompanying uncombined form of the same
+ work.</P>
+</UL>
+<P><STRONG>8.</STRONG> You may not copy, modify, sublicense, link with,
+ or distribute the Library except as expressly provided under this
+ License. Any attempt otherwise to copy, modify, sublicense, link with,
+ or distribute the Library is void, and will automatically terminate
+ your rights under this License. However, parties who have received
+ copies, or rights, from you under this License will not have their
+ licenses terminated so long as such parties remain in full compliance.</P>
+<P><STRONG>9.</STRONG> You are not required to accept this License,
+ since you have not signed it. However, nothing else grants you
+ permission to modify or distribute the Library or its derivative works.
+ These actions are prohibited by law if you do not accept this License.
+ Therefore, by modifying or distributing the Library (or any work based
+ on the Library), you indicate your acceptance of this License to do so,
+ and all its terms and conditions for copying, distributing or modifying
+ the Library or works based on it.</P>
+<P><STRONG>10.</STRONG> Each time you redistribute the Library (or any
+ work based on the Library), the recipient automatically receives a
+ license from the original licensor to copy, distribute, link with or
+ modify the Library subject to these terms and conditions. You may not
+ impose any further restrictions on the recipients' exercise of the
+ rights granted herein. You are not responsible for enforcing compliance
+ by third parties to this License.</P>
+<P><STRONG>11.</STRONG> If, as a consequence of a court judgment or
+ allegation of patent infringement or for any other reason (not limited
+ to patent issues), conditions are imposed on you (whether by court
+ order, agreement or otherwise) that contradict the conditions of this
+ License, they do not excuse you from the conditions of this License. If
+ you cannot distribute so as to satisfy simultaneously your obligations
+ under this License and any other pertinent obligations, then as a
+ consequence you may not distribute the Library at all. For example, if
+ a patent license would not permit royalty-free redistribution of the
+ Library by all those who receive copies directly or indirectly through
+ you, then the only way you could satisfy both it and this License would
+ be to refrain entirely from distribution of the Library.</P>
+<P>If any portion of this section is held invalid or unenforceable under
+ any particular circumstance, the balance of the section is intended to
+ apply, and the section as a whole is intended to apply in other
+ circumstances.</P>
+<P>It is not the purpose of this section to induce you to infringe any
+ patents or other property right claims or to contest validity of any
+ such claims; this section has the sole purpose of protecting the
+ integrity of the free software distribution system which is implemented
+ by public license practices. Many people have made generous
+ contributions to the wide range of software distributed through that
+ system in reliance on consistent application of that system; it is up
+ to the author/donor to decide if he or she is willing to distribute
+ software through any other system and a licensee cannot impose that
+ choice.</P>
+<P>This section is intended to make thoroughly clear what is believed to
+ be a consequence of the rest of this License.</P>
+<P><STRONG>12.</STRONG> If the distribution and/or use of the Library is
+ restricted in certain countries either by patents or by copyrighted
+ interfaces, the original copyright holder who places the Library under
+ this License may add an explicit geographical distribution limitation
+ excluding those countries, so that distribution is permitted only in or
+ among countries not thus excluded. In such case, this License
+ incorporates the limitation as if written in the body of this License.</P>
+<P><STRONG>13.</STRONG> The Free Software Foundation may publish revised
+ and/or new versions of the Library General Public License from time to
+ time. Such new versions will be similar in spirit to the present
+ version, but may differ in detail to address new problems or concerns.</P>
+<P>Each version is given a distinguishing version number. If the Library
+ specifies a version number of this License which applies to it and &quot;any
+ later version&quot;, you have the option of following the terms and
+ conditions either of that version or of any later version published by
+ the Free Software Foundation. If the Library does not specify a license
+ version number, you may choose any version ever published by the Free
+ Software Foundation.</P>
+<P><STRONG>14.</STRONG> If you wish to incorporate parts of the Library
+ into other free programs whose distribution conditions are incompatible
+ with these, write to the author to ask for permission. For software
+ which is copyrighted by the Free Software Foundation, write to the Free
+ Software Foundation; we sometimes make exceptions for this. Our
+ decision will be guided by the two goals of preserving the free status
+ of all derivatives of our free software and of promoting the sharing
+ and reuse of software generally.</P>
+<P align="center"><B>NO WARRANTY</B></P>
+<P><STRONG>15.</STRONG> BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE,
+ THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY
+ APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+ HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY &quot;AS IS&quot; WITHOUT
+ WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
+ LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE
+ OF THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU
+ ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</P>
+<P><STRONG>16.</STRONG> IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR
+ AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO
+ MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE
+ LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL
+ OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+ LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+ RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+ FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+ SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ DAMAGES.</P>
+<P align="center"><B>END OF TERMS AND CONDITIONS</B></P>
+<P><B>How to Apply These Terms to Your New Libraries</B></P>
+<P>If you develop a new library, and you want it to be of the greatest
+ possible use to the public, we recommend making it free software that
+ everyone can redistribute and change. You can do so by permitting
+ redistribution under these terms (or, alternatively, under the terms of
+ the ordinary General Public License).</P>
+<P>To apply these terms, attach the following notices to the library. It
+ is safest to attach them to the start of each source file to most
+ effectively convey the exclusion of warranty; and each file should have
+ at least the &quot;copyright&quot; line and a pointer to where the full notice is
+ found.</P>
+<UL>
+<P><VAR>one line to give the library's name and an idea of what it does.</VAR>
+<BR> Copyright (C)<VAR> year</VAR><VAR> name of author</VAR></P>
+<P>This library is free software; you can redistribute it and/or modify
+ it under the terms of the GNU Lesser General Public License as
+ published by the Free Software Foundation; either version 2.1 of the
+ License, or (at your option) any later version.</P>
+<P>This library is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
+ General Public License for more details.</P>
+<P>You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</P>
+</UL>
+<P>Also add information on how to contact you by electronic and paper
+ mail.</P>
+<P>You should also get your employer (if you work as a programmer) or
+ your school, if any, to sign a &quot;copyright disclaimer&quot; for the library,
+ if necessary. Here is a sample; alter the names:</P>
+<UL>
+<P>Yoyodyne, Inc., hereby disclaims all copyright interest in the
+ library `Frob' (a library for tweaking knobs) written by James Random
+ Hacker.</P>
+<P><VAR>signature of Ty Coon</VAR>, 1 April 1990 Ty Coon, President of
+ Vice</P>
+</UL>
+<P>That's all there is to it!</P>
+<HR NOSHADE>
+<H1 align="right"><A name="RELNOTES"><IMG align="right" alt="B" height="100"
+hspace="10" src="B.gif" width="100"></A>Release Notes</H1>
+<H2><A NAME="7_1">Changes in Mini-XML 2.6</A></H2>
+<UL>
+<LI>Documentation fixes (STR #91, STR #92)</LI>
+<LI>The mxmldoc program did not handle typedef comments properly (STR
+ #72)</LI>
+<LI>Added support for &quot;long long&quot; printf formats.</LI>
+<LI>The XML parser now ignores BOMs in UTF-8 XML files (STR #89)</LI>
+<LI>The mxmldoc program now supports generating Xcode documentation
+ sets.</LI>
+<LI>mxmlSave*() did not output UTF-8 correctly on some platforms.</LI>
+<LI>mxmlNewXML() now adds encoding=&quot;utf-8&quot; in the ?xml directive to
+ avoid problems with non-conformant XML parsers that assume something
+ other than UTF-8 as the default encoding.</LI>
+<LI>Wrapping was not disabled when mxmlSetWrapMargin(0) was called, and
+ &quot;&lt;?xml ... ?&gt;&quot; was always followed by a newline (STR #76)</LI>
+<LI>The mxml.pc.in file was broken (STR #79)</LI>
+<LI>The mxmldoc program now handles &quot;typedef enum name {} name&quot;
+ correctly (STR #72)</LI>
+</UL>
+<H2><A NAME="7_2">Changes in Mini-XML 2.5</A></H2>
+<UL>
+<LI>The mxmldoc program now makes greater use of CSS and supports a
+ --css option to embed an alternate stylesheet.</LI>
+<LI>The mxmldoc program now supports --header and --footer options to
+ insert documentation content before and after the generated content.</LI>
+<LI>The mxmldoc program now supports a --framed option to generate
+ framed HTML output.</LI>
+<LI>The mxmldoc program now creates a table of contents including any
+ headings in the --intro file when generating HTML output.</LI>
+<LI>The man pages and man page output from mxmldoc did not use &quot;\-&quot; for
+ dashes (STR #68)</LI>
+<LI>The debug version of the Mini-XML DLL could not be built (STR #65)</LI>
+<LI>Processing instructions and directives did not work when not at the
+ top level of a document (STR #67)</LI>
+<LI>Spaces around the &quot;=&quot; in attributes were not supported (STR #67)</LI>
+</UL>
+<H2><A NAME="7_3">Changes in Mini-XML 2.4</A></H2>
+<UL>
+<LI>Fixed shared library build problems on HP-UX and Mac OS X.</LI>
+<LI>The mxmldoc program did not output argument descriptions for
+ functions properly.</LI>
+<LI>All global settings (custom, error, and entity callbacks and the
+ wrap margin) are now managed separately for each thread.</LI>
+<LI>Added mxmlElementDeleteAttr() function (STR #59)</LI>
+<LI>mxmlElementSetAttrf() did not work (STR #57)</LI>
+<LI>mxmlLoad*() incorrectly treated declarations as parent elements (STR
+ #56)</LI>
+<LI>mxmlLoad*() incorrectly allowed attributes without values (STR #47)</LI>
+<LI>Fixed Visual C++ build problems (STR #49)</LI>
+<LI>mxmlLoad*() did not return NULL when an element contained an error
+ (STR #46)</LI>
+<LI>Added support for the apos character entity (STR #54)</LI>
+<LI>Fixed whitespace detection with Unicode characters (STR #48)</LI>
+<LI>mxmlWalkNext() and mxmlWalkPrev() did not work correctly when called
+ with a node with no children as the top node (STR #53)</LI>
+</UL>
+<H2><A NAME="7_4">Changes in Mini-XML 2.3</A></H2>
+<UL>
+<LI>Added two exceptions to the LGPL to support static linking of
+ applications against Mini-XML</LI>
+<LI>The mxmldoc utility can now generate man pages, too.</LI>
+<LI>Added a mxmlNewXML() function</LI>
+<LI>Added a mxmlElementSetAttrf() function (STR #43)</LI>
+<LI>Added a snprintf() emulation function for the test program (STR #32)</LI>
+<LI>Added the _CRT_SECURE_NO_DEPRECATE definition when building on VC++
+ 2005 (STR #36)</LI>
+<LI>mxmlLoad*() did not detect missing &gt; characters in elements (STR
+ #41)</LI>
+<LI>mxmlLoad*() did not detect missing close tags at the end of an XML
+ document (STR #45)</LI>
+<LI>Added user_data and ref_count members to mxml_node_t structure</LI>
+<LI>Added mxmlReleaseNode() and mxmlRetainNode() APIs for
+ reference-counted nodes</LI>
+<LI>Added mxmlSetWrapMargin() to control the wrapping of XML output</LI>
+<LI>Added conditional check for EINTR error code for certain Windows
+ compilers that do not define it (STR #33)</LI>
+<LI>The mxmldoc program now generates correct HTML 4.0 output -
+ previously it generated invalid XHTML</LI>
+<LI>The mxmldoc program now supports &quot;@deprecated@, &quot;@private@&quot;, and
+ &quot;@since version@&quot; comments</LI>
+<LI>Fixed function and enumeration type bugs in mxmldoc</LI>
+<LI>Fixed the XML schema for mxmldoc</LI>
+<LI>The mxmldoc program now supports --intro, --section, and --title
+ options</LI>
+<LI>The mxmlLoad*() functions could leak a node on an error (STR #27)</LI>
+<LI>The mxml_vsnprintf() function could get in an infinite loop on a
+ buffer overflow (STR #25)</LI>
+<LI>Added new mxmlNewCDATA() and mxmlSetCDATA() functions to create and
+ set CDATA nodes, which are really just special element nodes</LI>
+<LI>Added new MXML_IGNORE type and MXML_IGNORE_CB callback to ignore
+ non-element nodes, e.g. whitespace</LI>
+<LI>mxmlLoad*() did not treat custom data as opaque, so whitespace
+ characters would be lost</LI>
+</UL>
+<H2><A NAME="7_5">Changes in Mini-XML 2.2.2</A></H2>
+<UL>
+<LI>mxmlLoad*() did not treat custom data as opaque, so whitespace
+ characters would be lost.</LI>
+</UL>
+<H2><A NAME="7_6">Changes in Mini-XML 2.2.1</A></H2>
+<UL>
+<LI>mxmlLoadFd(), mxmlLoadFile(), and mxmlLoadString() now correctly
+ return NULL on error (STR #21)</LI>
+<LI>mxmlNewInteger(), mxmlNewOpaque(), mxmlNewReal(), mxmlNewText(), and
+ mxmlNewTextf() incorrectly required a parent node (STR #22)</LI>
+<LI>Fixed an XML output bug in mxmldoc.</LI>
+<LI>The &quot;make install&quot; target now uses the install command to set the
+ proper permissions on UNIX/Linux/OSX.</LI>
+<LI>Fixed a MingW/Cygwin compilation problem (STR #18)</LI>
+</UL>
+<H2><A NAME="7_7">Changes in Mini-XML 2.2</A></H2>
+<UL>
+<LI>Added shared library support (STR #17)</LI>
+<LI>mxmlLoad*() now returns an error when an XML stream contains illegal
+ control characters (STR #10)</LI>
+<LI>mxmlLoad*() now returns an error when an element contains two
+ attributes with the same name in conformance with the XML spec (STR
+ #16)</LI>
+<LI>Added support for CDATA (STR #14, STR #15)</LI>
+<LI>Updated comment and processing instruction handling - no entity
+ support per XML specification.</LI>
+<LI>Added checking for invalid comment termination (&quot;---&gt;&quot; is not
+ allowed)</LI>
+</UL>
+<H2><A NAME="7_8">Changes in Mini-XML 2.1</A></H2>
+<UL>
+<LI>Added support for custom data nodes (STR #6)</LI>
+<LI>Now treat UTF-8 sequences which are longer than necessary as an
+ error (STR #4)</LI>
+<LI>Fixed entity number support (STR #8)</LI>
+<LI>Fixed mxmlLoadString() bug with UTF-8 (STR #7)</LI>
+<LI>Fixed entity lookup bug (STR #5)</LI>
+<LI>Added mxmlLoadFd() and mxmlSaveFd() functions.</LI>
+<LI>Fixed multi-word UTF-16 handling.</LI>
+</UL>
+<H2><A NAME="7_9">Changes in Mini-XML 2.0</A></H2>
+<UL>
+<LI>New programmers manual.</LI>
+<LI>Added Visual C++ project files for Microsoft Windows users.</LI>
+<LI>Added optimizations to mxmldoc, mxmlSaveFile(), and mxmlIndexNew()
+ (STR #2)</LI>
+<LI>mxmlEntityAddCallback() now returns an integer status (STR #2)</LI>
+<LI>Added UTF-16 support (input only; all output is UTF-8)</LI>
+<LI>Added index functions to build a searchable index of XML nodes.</LI>
+<LI>Added character entity callback interface to support additional
+ character entities beyond those defined in the XHTML specification.</LI>
+<LI>Added support for XHTML character entities.</LI>
+<LI>The mxmldoc utility now produces XML output which conforms to an
+ updated XML schema, described in the file &quot;doc/mxmldoc.xsd&quot;.</LI>
+<LI>Changed the whitespace callback interface to return strings instead
+ of a single character, allowing for greater control over the formatting
+ of XML files written using Mini-XML. THIS CHANGE WILL REQUIRE CHANGES
+ TO YOUR 1.x CODE IF YOU USE WHITESPACE CALLBACKS.</LI>
+<LI>The mxmldoc utility now produces XML output which conforms to an
+ updated XML schema, described in the file &quot;doc/mxmldoc.xsd&quot;.</LI>
+<LI>Changed the whitespace callback interface to return strings instead
+ of a single character, allowing for greater control over the formatting
+ of XML files written using Mini-XML. THIS CHANGE WILL REQUIRE CHANGES
+ TO YOUR 1.x CODE IF YOU USE WHITESPACE CALLBACKS.</LI>
+<LI>The mxmldoc utility is now capable of documenting C++ classes,
+ functions, and structures, and correctly handles C++ comments.</LI>
+<LI>Added new modular tests for mxmldoc.</LI>
+<LI>Updated the mxmldoc output to be more compatible with embedding in
+ manuals produced with HTMLDOC.</LI>
+<LI>The makefile incorrectly included a &quot;/&quot; separator between the
+ destination path and install path. This caused problems when building
+ and installing with MingW.</LI>
+</UL>
+<H2><A NAME="7_10">Changes in Mini-XML 1.3</A></H2>
+<UL>
+<LI>Fixes for mxmldoc.</LI>
+<LI>Added support for reading standard HTML entity names.</LI>
+<LI>mxmlLoadString/File() did not decode character entities in element
+ names, attribute names, or attribute values.</LI>
+<LI>mxmlLoadString/File() would crash when loading non- conformant XML
+ data under an existing parent (top) node.</LI>
+<LI>Fixed several bugs in the mxmldoc utility.</LI>
+<LI>Added new error callback function to catch a variety of errors and
+ log them to someplace other than stderr.</LI>
+<LI>The mxmlElementSetAttr() function now allows for NULL attribute
+ values.</LI>
+<LI>The load and save functions now properly handle quoted element and
+ attribute name strings properly, e.g. for !DOCTYPE declarations.</LI>
+</UL>
+<H2><A NAME="7_11">Changes in Mini-XML 1.2</A></H2>
+<UL>
+<LI>Added new &quot;set&quot; methods to set the value of a node.</LI>
+<LI>Added new formatted text methods mxmlNewTextf() and mxmlSetTextf()
+ to create/set a text node value using printf-style formats.</LI>
+<LI>Added new standard callbacks for use with the mxmlLoad functions.</LI>
+<LI>Updated the HTML documentation to include examples of the walk and
+ load function output.</LI>
+<LI>Added --with/without-ansi configure option to control the strdup()
+ function check.</LI>
+<LI>Added --with/without-snprintf configure option to control the
+ snprintf() and vsnprintf() function checks.</LI>
+</UL>
+<H2><A NAME="7_12">Changes in Mini-XML 1.1.2</A></H2>
+<UL>
+<LI>The mxml(3) man page wasn't updated for the string functions.</LI>
+<LI>mxmlSaveString() returned the wrong number of characters.</LI>
+<LI>mxml_add_char() updated the buffer pointer in the wrong place.</LI>
+</UL>
+<H2><A NAME="7_13">Changes in Mini-XML 1.1.1</A></H2>
+<UL>
+<LI>The private mxml_add_ch() function did not update the
+ start-of-buffer pointer which could cause a crash when using
+ mxmlSaveString().</LI>
+<LI>The private mxml_write_ws() function called putc() instead of using
+ the proper callback which could cause a crash when using
+ mxmlSaveString().</LI>
+<LI>Added a mxmlSaveAllocString() convenience function for saving an XML
+ node tree to an allocated string.</LI>
+</UL>
+<H2><A NAME="7_14">Changes in Mini-XML 1.1</A></H2>
+<UL>
+<LI>The mxmlLoadFile() function now uses dynamically allocated string
+ buffers for element names, attribute names, and attribute values.
+ Previously they were capped at 16383, 255, and 255 bytes, respectively.</LI>
+<LI>Added a new mxmlLoadString() function for loading an XML node tree
+ from a string.</LI>
+<LI>Added a new mxmlSaveString() function for saving an XML node tree to
+ a string.</LI>
+<LI>Add emulation of strdup() if the local platform does not provide the
+ function.</LI>
+</UL>
+<H2><A NAME="7_15">Changes in Mini-XML 1.0</A></H2>
+<UL>
+<LI>The mxmldoc program now handles function arguments, structures,
+ unions, enumerations, classes, and typedefs properly.</LI>
+<LI>Documentation provided via mxmldoc and more in-line comments in the
+ code.</LI>
+<LI>Added man pages and packaging files.</LI>
+</UL>
+<H2><A NAME="7_16">Changes in Mini-XML 0.93</A></H2>
+<UL>
+<LI>New mxmldoc example program that is also used to create and update
+ code documentation using XML and produce HTML reference pages.</LI>
+<LI>Added mxmlAdd() and mxmlRemove() functions to add and remove nodes
+ from a tree. This provides more flexibility over where the nodes are
+ inserted and allows nodes to be moved within the tree as needed.</LI>
+<LI>mxmlLoadFile() now correctly handles comments.</LI>
+<LI>mxmlLoadFile() now supports the required &quot;gt&quot;, &quot;quot&quot;, and &quot;nbsp&quot;
+ character entities.</LI>
+<LI>mxmlSaveFile() now uses newlines as whitespace when valid to do so.</LI>
+<LI>mxmlFindElement() now also takes attribute name and attribute value
+ string arguments to limit the search to specific elements with
+ attributes and/or values.</LI>
+ NULL pointers can be used as &quot;wildcards&quot;.
+<LI>Added uninstall target to makefile, and auto-reconfig if Makefile.in
+ or configure.in are changed.</LI>
+<LI>mxmlFindElement(), mxmlWalkNext(), and mxmlWalkPrev() now all
+ provide &quot;descend&quot; arguments to control whether they descend into child
+ nodes in the tree.</LI>
+<LI>Fixed some whitespace issues in mxmlLoadFile().</LI>
+<LI>Fixed Unicode output and whitespace issues in mxmlSaveFile().</LI>
+<LI>mxmlSaveFile() now supports a whitespace callback to provide more
+ human-readable XML output under program control.</LI>
+</UL>
+<H2><A NAME="7_17">Changes in Mini-XML 0.92</A></H2>
+<UL>
+<LI>mxmlSaveFile() didn't return a value on success.</LI>
+</UL>
+<H2><A NAME="7_18">Changes in Mini-XML 0.91</A></H2>
+<UL>
+<LI>mxmlWalkNext() would go into an infinite loop.</LI>
+</UL>
+<H2><A NAME="7_19">Changes in Mini-XML 0.9</A></H2>
+<UL>
+<LI>Initial public release.</LI>
+</UL>
+<HR NOSHADE>
+<DIV class="body">
+<H1 align="right"><A name="REFERENCE"><IMG align="right" alt="C" height="100"
+hspace="10" src="C.gif" width="100"></A>Library Reference</H1>
+<H2 class="title"><A NAME="8_1">Contents</A></H2>
+<UL class="contents">
+<LI><A href="#FUNCTIONS">Functions</A>
+<UL class="code">
+<LI><A href="#mxmlAdd" title="Add a node to a tree.">mxmlAdd</A></LI>
+<LI><A href="#mxmlDelete" title="Delete a node and all of its children.">
+mxmlDelete</A></LI>
+<LI><A href="#mxmlElementDeleteAttr" title="Delete an attribute.">
+mxmlElementDeleteAttr</A></LI>
+<LI><A href="#mxmlElementGetAttr" title="Get an attribute.">
+mxmlElementGetAttr</A></LI>
+<LI><A href="#mxmlElementSetAttr" title="Set an attribute.">
+mxmlElementSetAttr</A></LI>
+<LI><A href="#mxmlElementSetAttrf" title="Set an attribute with a formatted value.">
+mxmlElementSetAttrf</A></LI>
+<LI><A href="#mxmlEntityAddCallback" title="Add a callback to convert entities to Unicode.">
+mxmlEntityAddCallback</A></LI>
+<LI><A href="#mxmlEntityGetName" title="Get the name that corresponds to the character value.">
+mxmlEntityGetName</A></LI>
+<LI><A href="#mxmlEntityGetValue" title="Get the character corresponding to a named entity.">
+mxmlEntityGetValue</A></LI>
+<LI><A href="#mxmlEntityRemoveCallback" title="Remove a callback.">
+mxmlEntityRemoveCallback</A></LI>
+<LI><A href="#mxmlFindElement" title="Find the named element.">
+mxmlFindElement</A></LI>
+<LI><A href="#mxmlIndexDelete" title="Delete an index.">mxmlIndexDelete</A>
+</LI>
+<LI><A href="#mxmlIndexEnum" title="Return the next node in the index.">
+mxmlIndexEnum</A></LI>
+<LI><A href="#mxmlIndexFind" title="Find the next matching node.">
+mxmlIndexFind</A></LI>
+<LI><A href="#mxmlIndexNew" title="Create a new index.">mxmlIndexNew</A></LI>
+<LI><A href="#mxmlIndexReset" title="Reset the enumeration/find pointer in the index and return the first node in the index.">
+mxmlIndexReset</A></LI>
+<LI><A href="#mxmlLoadFd" title="Load a file descriptor into an XML node tree.">
+mxmlLoadFd</A></LI>
+<LI><A href="#mxmlLoadFile" title="Load a file into an XML node tree.">
+mxmlLoadFile</A></LI>
+<LI><A href="#mxmlLoadString" title="Load a string into an XML node tree.">
+mxmlLoadString</A></LI>
+<LI><A href="#mxmlNewCDATA" title="Create a new CDATA node.">
+mxmlNewCDATA</A></LI>
+<LI><A href="#mxmlNewCustom" title="Create a new custom data node.">
+mxmlNewCustom</A></LI>
+<LI><A href="#mxmlNewElement" title="Create a new element node.">
+mxmlNewElement</A></LI>
+<LI><A href="#mxmlNewInteger" title="Create a new integer node.">
+mxmlNewInteger</A></LI>
+<LI><A href="#mxmlNewOpaque" title="Create a new opaque string.">
+mxmlNewOpaque</A></LI>
+<LI><A href="#mxmlNewReal" title="Create a new real number node.">
+mxmlNewReal</A></LI>
+<LI><A href="#mxmlNewText" title="Create a new text fragment node.">
+mxmlNewText</A></LI>
+<LI><A href="#mxmlNewTextf" title="Create a new formatted text fragment node.">
+mxmlNewTextf</A></LI>
+<LI><A href="#mxmlNewXML" title="Create a new XML document tree.">
+mxmlNewXML</A></LI>
+<LI><A href="#mxmlRelease" title="Release a node.">mxmlRelease</A></LI>
+<LI><A href="#mxmlRemove" title="Remove a node from its parent.">
+mxmlRemove</A></LI>
+<LI><A href="#mxmlRetain" title="Retain a node.">mxmlRetain</A></LI>
+<LI><A href="#mxmlSAXLoadFd" title="Load a file descriptor into an XML node tree using a SAX callback.">
+mxmlSAXLoadFd</A></LI>
+<LI><A href="#mxmlSAXLoadFile" title="Load a file into an XML node tree using a SAX callback.">
+mxmlSAXLoadFile</A></LI>
+<LI><A href="#mxmlSAXLoadString" title="Load a string into an XML node tree using a SAX callback.">
+mxmlSAXLoadString</A></LI>
+<LI><A href="#mxmlSaveAllocString" title="Save an XML node tree to an allocated string.">
+mxmlSaveAllocString</A></LI>
+<LI><A href="#mxmlSaveFd" title="Save an XML tree to a file descriptor.">
+mxmlSaveFd</A></LI>
+<LI><A href="#mxmlSaveFile" title="Save an XML tree to a file.">
+mxmlSaveFile</A></LI>
+<LI><A href="#mxmlSaveString" title="Save an XML node tree to a string.">
+mxmlSaveString</A></LI>
+<LI><A href="#mxmlSetCDATA" title="Set the element name of a CDATA node.">
+mxmlSetCDATA</A></LI>
+<LI><A href="#mxmlSetCustom" title="Set the data and destructor of a custom data node.">
+mxmlSetCustom</A></LI>
+<LI><A href="#mxmlSetCustomHandlers" title="Set the handling functions for custom data.">
+mxmlSetCustomHandlers</A></LI>
+<LI><A href="#mxmlSetElement" title="Set the name of an element node.">
+mxmlSetElement</A></LI>
+<LI><A href="#mxmlSetErrorCallback" title="Set the error message callback.">
+mxmlSetErrorCallback</A></LI>
+<LI><A href="#mxmlSetInteger" title="Set the value of an integer node.">
+mxmlSetInteger</A></LI>
+<LI><A href="#mxmlSetOpaque" title="Set the value of an opaque node.">
+mxmlSetOpaque</A></LI>
+<LI><A href="#mxmlSetReal" title="Set the value of a real number node.">
+mxmlSetReal</A></LI>
+<LI><A href="#mxmlSetText" title="Set the value of a text node.">
+mxmlSetText</A></LI>
+<LI><A href="#mxmlSetTextf" title="Set the value of a text node to a formatted string.">
+mxmlSetTextf</A></LI>
+<LI><A href="#mxmlSetWrapMargin" title="Set the the wrap margin when saving XML data.">
+mxmlSetWrapMargin</A></LI>
+<LI><A href="#mxmlWalkNext" title="Walk to the next logical node in the tree.">
+mxmlWalkNext</A></LI>
+<LI><A href="#mxmlWalkPrev" title="Walk to the previous logical node in the tree.">
+mxmlWalkPrev</A></LI>
+</UL>
+</LI>
+<LI><A href="#TYPES">Data Types</A>
+<UL class="code">
+<LI><A href="#mxml_attr_t" title="An XML element attribute value.">
+mxml_attr_t</A></LI>
+<LI><A href="#mxml_custom_destroy_cb_t" title="Custom data destructor">
+mxml_custom_destroy_cb_t</A></LI>
+<LI><A href="#mxml_custom_load_cb_t" title="Custom data load callback function">
+mxml_custom_load_cb_t</A></LI>
+<LI><A href="#mxml_custom_save_cb_t" title="Custom data save callback function">
+mxml_custom_save_cb_t</A></LI>
+<LI><A href="#mxml_custom_t" title="An XML custom value. ">mxml_custom_t</A>
+</LI>
+<LI><A href="#mxml_element_t" title="An XML element value.">
+mxml_element_t</A></LI>
+<LI><A href="#mxml_entity_cb_t" title="Entity callback function">
+mxml_entity_cb_t</A></LI>
+<LI><A href="#mxml_error_cb_t" title="Error callback function">
+mxml_error_cb_t</A></LI>
+<LI><A href="#mxml_index_t" title="An XML node index.">mxml_index_t</A></LI>
+<LI><A href="#mxml_load_cb_t" title="Load callback function">
+mxml_load_cb_t</A></LI>
+<LI><A href="#mxml_node_t" title="An XML node.">mxml_node_t</A></LI>
+<LI><A href="#mxml_save_cb_t" title="Save callback function">
+mxml_save_cb_t</A></LI>
+<LI><A href="#mxml_sax_cb_t" title="SAX callback function">mxml_sax_cb_t</A>
+</LI>
+<LI><A href="#mxml_sax_event_t" title="SAX event type.">mxml_sax_event_t</A>
+</LI>
+<LI><A href="#mxml_text_t" title="An XML text value.">mxml_text_t</A></LI>
+<LI><A href="#mxml_type_t" title="The XML node type.">mxml_type_t</A></LI>
+<LI><A href="#mxml_value_t" title="An XML node value.">mxml_value_t</A></LI>
+</UL>
+</LI>
+<LI><A href="#STRUCTURES">Structures</A>
+<UL class="code">
+<LI><A href="#mxml_attr_s" title="An XML element attribute value.">
+mxml_attr_s</A></LI>
+<LI><A href="#mxml_custom_s" title="An XML custom value. ">mxml_custom_s</A>
+</LI>
+<LI><A href="#mxml_element_s" title="An XML element value.">
+mxml_element_s</A></LI>
+<LI><A href="#mxml_index_s" title="An XML node index.">mxml_index_s</A></LI>
+<LI><A href="#mxml_node_s" title="An XML node.">mxml_node_s</A></LI>
+<LI><A href="#mxml_text_s" title="An XML text value.">mxml_text_s</A></LI>
+</UL>
+</LI>
+<LI><A href="#UNIONS">Unions</A>
+<UL class="code">
+<LI><A href="#mxml_value_u" title="An XML node value.">mxml_value_u</A></LI>
+</UL>
+</LI>
+<LI><A href="#ENUMERATIONS">Constants</A>
+<UL class="code">
+<LI><A href="#mxml_sax_event_e" title="SAX event type.">mxml_sax_event_e</A>
+</LI>
+<LI><A href="#mxml_type_e" title="The XML node type.">mxml_type_e</A></LI>
+</UL>
+</LI>
+<H2 class="title"><A name="FUNCTIONS">Functions</A></H2>
+<H3 class="function"><A name="mxmlAdd">mxmlAdd</A></H3>
+<P class="description">Add a node to a tree.</P>
+<P class="code"> void mxmlAdd (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int where,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *child,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node</DD>
+<DT>where</DT>
+<DD class="description">Where to add, MXML_ADD_BEFORE or MXML_ADD_AFTER</DD>
+<DT>child</DT>
+<DD class="description">Child node for where or MXML_ADD_TO_PARENT</DD>
+<DT>node</DT>
+<DD class="description">Node to add</DD>
+</DL>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">Adds the specified node to the parent. If the
+ child argument is not NULL, puts the new node before or after the
+ specified child depending on the value of the where argument. If the
+ child argument is NULL, puts the new node at the beginning of the child
+ list (MXML_ADD_BEFORE) or at the end of the child list
+ (MXML_ADD_AFTER). The constant MXML_ADD_TO_PARENT can be used to
+ specify a NULL child pointer.</P>
+<H3 class="function"><A name="mxmlDelete">mxmlDelete</A></H3>
+<P class="description">Delete a node and all of its children.</P>
+<P class="code"> void mxmlDelete (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to delete</DD>
+</DL>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">If the specified node has a parent, this function
+ first removes the node from its parent using the mxmlRemove() function.</P>
+<H3 class="function"><A NAME="8_2_3">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.4&nbsp;<A name="mxmlElementDeleteAttr">mxmlElementDeleteAttr</A></A>
+</H3>
+<P class="description">Delete an attribute.</P>
+<P class="code"> void mxmlElementDeleteAttr (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Element</DD>
+<DT>name</DT>
+<DD class="description">Attribute name</DD>
+</DL>
+<H3 class="function"><A name="mxmlElementGetAttr">mxmlElementGetAttr</A></H3>
+<P class="description">Get an attribute.</P>
+<P class="code"> const char *mxmlElementGetAttr (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Element node</DD>
+<DT>name</DT>
+<DD class="description">Name of attribute</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Attribute value or NULL</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">This function returns NULL if the node is not an
+ element or the named attribute does not exist.</P>
+<H3 class="function"><A name="mxmlElementSetAttr">mxmlElementSetAttr</A></H3>
+<P class="description">Set an attribute.</P>
+<P class="code"> void mxmlElementSetAttr (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *value
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Element node</DD>
+<DT>name</DT>
+<DD class="description">Name of attribute</DD>
+<DT>value</DT>
+<DD class="description">Attribute value</DD>
+</DL>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">If the named attribute already exists, the value
+ of the attribute is replaced by the new string value. The string value
+ is copied into the element node. This function does nothing if the node
+ is not an element.</P>
+<H3 class="function"><A NAME="8_2_6">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlElementSetAttrf">mxmlElementSetAttrf</A></A></H3>
+<P class="description">Set an attribute with a formatted value.</P>
+<P class="code"> void mxmlElementSetAttrf (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *format,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;...
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Element node</DD>
+<DT>name</DT>
+<DD class="description">Name of attribute</DD>
+<DT>format</DT>
+<DD class="description">Printf-style attribute value</DD>
+<DT>...</DT>
+<DD class="description">Additional arguments as needed</DD>
+</DL>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">If the named attribute already exists, the value
+ of the attribute is replaced by the new formatted string. The formatted
+ string value is copied into the element node. This function does
+ nothing if the node is not an element.</P>
+<H3 class="function"><A name="mxmlEntityAddCallback">
+mxmlEntityAddCallback</A></H3>
+<P class="description">Add a callback to convert entities to Unicode.</P>
+<P class="code"> int mxmlEntityAddCallback (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_entity_cb_t">mxml_entity_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>cb</DT>
+<DD class="description">Callback function to add</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H3 class="function"><A name="mxmlEntityGetName">mxmlEntityGetName</A></H3>
+<P class="description">Get the name that corresponds to the character
+ value.</P>
+<P class="code"> const char *mxmlEntityGetName (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int val
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>val</DT>
+<DD class="description">Character value</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Entity name or NULL</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">If val does not need to be represented by a named
+ entity, NULL is returned.</P>
+<H3 class="function"><A name="mxmlEntityGetValue">mxmlEntityGetValue</A></H3>
+<P class="description">Get the character corresponding to a named
+ entity.</P>
+<P class="code"> int mxmlEntityGetValue (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>name</DT>
+<DD class="description">Entity name</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Character value or -1 on error</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The entity name can also be a numeric constant. -1
+ is returned if the name is not known.</P>
+<H3 class="function"><A name="mxmlEntityRemoveCallback">
+mxmlEntityRemoveCallback</A></H3>
+<P class="description">Remove a callback.</P>
+<P class="code"> void mxmlEntityRemoveCallback (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_entity_cb_t">mxml_entity_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>cb</DT>
+<DD class="description">Callback function to remove</DD>
+</DL>
+<H3 class="function"><A name="mxmlFindElement">mxmlFindElement</A></H3>
+<P class="description">Find the named element.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlFindElement
+ (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *attr,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *value,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int descend
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Current node</DD>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>name</DT>
+<DD class="description">Element name or NULL for any</DD>
+<DT>attr</DT>
+<DD class="description">Attribute name, or NULL for none</DD>
+<DT>value</DT>
+<DD class="description">Attribute value, or NULL for any</DD>
+<DT>descend</DT>
+<DD class="description">Descend into tree - MXML_DESCEND,
+ MXML_NO_DESCEND, or MXML_DESCEND_FIRST</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Element node or NULL</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The search is constrained by the name, attribute
+ name, and value; any NULL names or values are treated as wildcards, so
+ different kinds of searches can be implemented by looking for all
+ elements of a given name or all elements with a specific attribute. The
+ descend argument determines whether the search descends into child
+ nodes; normally you will use MXML_DESCEND_FIRST for the initial search
+ and MXML_NO_DESCEND to find additional direct descendents of the node.
+ The top node argument constrains the search to a particular node's
+ children.</P>
+<H3 class="function"><A name="mxmlIndexDelete">mxmlIndexDelete</A></H3>
+<P class="description">Delete an index.</P>
+<P class="code"> void mxmlIndexDelete (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_index_t">mxml_index_t</A> *ind
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>ind</DT>
+<DD class="description">Index to delete</DD>
+</DL>
+<H3 class="function"><A name="mxmlIndexEnum">mxmlIndexEnum</A></H3>
+<P class="description">Return the next node in the index.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlIndexEnum (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_index_t">mxml_index_t</A> *ind
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>ind</DT>
+<DD class="description">Index to enumerate</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Next node or NULL if there is none</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">Nodes are returned in the sorted order of the
+ index.</P>
+<H3 class="function"><A name="mxmlIndexFind">mxmlIndexFind</A></H3>
+<P class="description">Find the next matching node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlIndexFind (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_index_t">mxml_index_t</A> *ind,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *element,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *value
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>ind</DT>
+<DD class="description">Index to search</DD>
+<DT>element</DT>
+<DD class="description">Element name to find, if any</DD>
+<DT>value</DT>
+<DD class="description">Attribute value, if any</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Node or NULL if none found</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">You should call mxmlIndexReset() prior to using
+ this function for the first time with a particular set of &quot;element&quot; and
+ &quot;value&quot; strings. Passing NULL for both &quot;element&quot; and &quot;value&quot; is
+ equivalent to calling mxmlIndexEnum().</P>
+<H3 class="function"><A name="mxmlIndexNew">mxmlIndexNew</A></H3>
+<P class="description">Create a new index.</P>
+<P class="code"> <A href="#mxml_index_t">mxml_index_t</A> *mxmlIndexNew
+ (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *element,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *attr
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">XML node tree</DD>
+<DT>element</DT>
+<DD class="description">Element to index or NULL for all</DD>
+<DT>attr</DT>
+<DD class="description">Attribute to index or NULL for none</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New index</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The index will contain all nodes that contain the
+ named element and/or attribute. If both &quot;element&quot; and &quot;attr&quot; are NULL,
+ then the index will contain a sorted list of the elements in the node
+ tree. Nodes are sorted by element name and optionally by attribute
+ value if the &quot;attr&quot; argument is not NULL.</P>
+<H3 class="function"><A name="mxmlIndexReset">mxmlIndexReset</A></H3>
+<P class="description">Reset the enumeration/find pointer in the index
+ and return the first node in the index.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlIndexReset
+ (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_index_t">mxml_index_t</A> *ind
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>ind</DT>
+<DD class="description">Index to reset</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">First node or NULL if there is none</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">This function should be called prior to using
+ mxmlIndexEnum() or mxmlIndexFind() for the first time.</P>
+<H3 class="function"><A name="mxmlLoadFd">mxmlLoadFd</A></H3>
+<P class="description">Load a file descriptor into an XML node tree.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlLoadFd (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int fd,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>fd</DT>
+<DD class="description">File descriptor to read from</DD>
+<DT>cb</DT>
+<DD class="description">Callback function or MXML_NO_CALLBACK</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">First node or NULL if the file could not be read.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The nodes in the specified file are added to the
+ specified top node. If no top node is provided, the XML file MUST be
+ well-formed with a single parent node like &lt;?xml&gt; for the entire file.
+ The callback function returns the value type that should be used for
+ child nodes. If MXML_NO_CALLBACK is specified then all child nodes will
+ be either MXML_ELEMENT or MXML_TEXT nodes.
+<BR>
+<BR> The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ child nodes of the specified type.</P>
+<H3 class="function"><A name="mxmlLoadFile">mxmlLoadFile</A></H3>
+<P class="description">Load a file into an XML node tree.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlLoadFile (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;FILE *fp,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>fp</DT>
+<DD class="description">File to read from</DD>
+<DT>cb</DT>
+<DD class="description">Callback function or MXML_NO_CALLBACK</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">First node or NULL if the file could not be read.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The nodes in the specified file are added to the
+ specified top node. If no top node is provided, the XML file MUST be
+ well-formed with a single parent node like &lt;?xml&gt; for the entire file.
+ The callback function returns the value type that should be used for
+ child nodes. If MXML_NO_CALLBACK is specified then all child nodes will
+ be either MXML_ELEMENT or MXML_TEXT nodes.
+<BR>
+<BR> The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ child nodes of the specified type.</P>
+<H3 class="function"><A name="mxmlLoadString">mxmlLoadString</A></H3>
+<P class="description">Load a string into an XML node tree.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlLoadString
+ (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *s,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>s</DT>
+<DD class="description">String to load</DD>
+<DT>cb</DT>
+<DD class="description">Callback function or MXML_NO_CALLBACK</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">First node or NULL if the string has errors.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The nodes in the specified string are added to the
+ specified top node. If no top node is provided, the XML string MUST be
+ well-formed with a single parent node like &lt;?xml&gt; for the entire
+ string. The callback function returns the value type that should be
+ used for child nodes. If MXML_NO_CALLBACK is specified then all child
+ nodes will be either MXML_ELEMENT or MXML_TEXT nodes.
+<BR>
+<BR> The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ child nodes of the specified type.</P>
+<H3 class="function"><A NAME="8_2_20">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlNewCDATA">mxmlNewCDATA</A></A></H3>
+<P class="description">Create a new CDATA node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewCDATA (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *data
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>data</DT>
+<DD class="description">Data string</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new CDATA node is added to the end of the
+ specified parent's child list. The constant MXML_NO_PARENT can be used
+ to specify that the new CDATA node has no parent. The data string must
+ be nul-terminated and is copied into the new node. CDATA nodes use the
+ MXML_ELEMENT type.</P>
+<H3 class="function"><A NAME="8_2_21">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.1&nbsp;<A name="mxmlNewCustom">mxmlNewCustom</A></A></H3>
+<P class="description">Create a new custom data node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewCustom (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;void *data,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</A>
+ destroy
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>data</DT>
+<DD class="description">Pointer to data</DD>
+<DT>destroy</DT>
+<DD class="description">Function to destroy data</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new custom node is added to the end of the
+ specified parent's child list. The constant MXML_NO_PARENT can be used
+ to specify that the new element node has no parent. NULL can be passed
+ when the data in the node is not dynamically allocated or is separately
+ managed.</P>
+<H3 class="function"><A name="mxmlNewElement">mxmlNewElement</A></H3>
+<P class="description">Create a new element node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewElement
+ (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>name</DT>
+<DD class="description">Name of element</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new element node is added to the end of the
+ specified parent's child list. The constant MXML_NO_PARENT can be used
+ to specify that the new element node has no parent.</P>
+<H3 class="function"><A name="mxmlNewInteger">mxmlNewInteger</A></H3>
+<P class="description">Create a new integer node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewInteger
+ (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int integer
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>integer</DT>
+<DD class="description">Integer value</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new integer node is added to the end of the
+ specified parent's child list. The constant MXML_NO_PARENT can be used
+ to specify that the new integer node has no parent.</P>
+<H3 class="function"><A name="mxmlNewOpaque">mxmlNewOpaque</A></H3>
+<P class="description">Create a new opaque string.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewOpaque (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *opaque
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>opaque</DT>
+<DD class="description">Opaque string</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new opaque node is added to the end of the
+ specified parent's child list. The constant MXML_NO_PARENT can be used
+ to specify that the new opaque node has no parent. The opaque string
+ must be nul-terminated and is copied into the new node.</P>
+<H3 class="function"><A name="mxmlNewReal">mxmlNewReal</A></H3>
+<P class="description">Create a new real number node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewReal (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;double real
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>real</DT>
+<DD class="description">Real number value</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new real number node is added to the end of
+ the specified parent's child list. The constant MXML_NO_PARENT can be
+ used to specify that the new real number node has no parent.</P>
+<H3 class="function"><A name="mxmlNewText">mxmlNewText</A></H3>
+<P class="description">Create a new text fragment node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewText (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int whitespace,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *string
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>whitespace</DT>
+<DD class="description">1 = leading whitespace, 0 = no whitespace</DD>
+<DT>string</DT>
+<DD class="description">String</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new text node is added to the end of the
+ specified parent's child list. The constant MXML_NO_PARENT can be used
+ to specify that the new text node has no parent. The whitespace
+ parameter is used to specify whether leading whitespace is present
+ before the node. The text string must be nul-terminated and is copied
+ into the new node.</P>
+<H3 class="function"><A name="mxmlNewTextf">mxmlNewTextf</A></H3>
+<P class="description">Create a new formatted text fragment node.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewTextf (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *parent,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int whitespace,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *format,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;...
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>parent</DT>
+<DD class="description">Parent node or MXML_NO_PARENT</DD>
+<DT>whitespace</DT>
+<DD class="description">1 = leading whitespace, 0 = no whitespace</DD>
+<DT>format</DT>
+<DD class="description">Printf-style frmat string</DD>
+<DT>...</DT>
+<DD class="description">Additional args as needed</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The new text node is added to the end of the
+ specified parent's child list. The constant MXML_NO_PARENT can be used
+ to specify that the new text node has no parent. The whitespace
+ parameter is used to specify whether leading whitespace is present
+ before the node. The format string must be nul-terminated and is
+ formatted into the new node.</P>
+<H3 class="function"><A NAME="8_2_28">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlNewXML">mxmlNewXML</A></A></H3>
+<P class="description">Create a new XML document tree.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlNewXML (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *version
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>version</DT>
+<DD class="description">Version number to use</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New ?xml node</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The &quot;version&quot; argument specifies the version
+ number to put in the ?xml element node. If NULL, version 1.0 is
+ assumed.</P>
+<H3 class="function"><A NAME="8_2_29">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlRelease">mxmlRelease</A></A></H3>
+<P class="description">Release a node.</P>
+<P class="code"> int mxmlRelease (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New reference count</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">When the reference count reaches zero, the node
+ (and any children) is deleted via mxmlDelete().</P>
+<H3 class="function"><A name="mxmlRemove">mxmlRemove</A></H3>
+<P class="description">Remove a node from its parent.</P>
+<P class="code"> void mxmlRemove (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to remove</DD>
+</DL>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">Does not free memory used by the node - use
+ mxmlDelete() for that. This function does nothing if the node has no
+ parent.</P>
+<H3 class="function"><A NAME="8_2_31">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlRetain">mxmlRetain</A></A></H3>
+<P class="description">Retain a node.</P>
+<P class="code"> int mxmlRetain (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">New reference count</P>
+<H3 class="function"><A NAME="8_2_32">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSAXLoadFd">mxmlSAXLoadFd</A></A></H3>
+<P class="description">Load a file descriptor into an XML node tree
+ using a SAX callback.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlSAXLoadFd (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int fd,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_sax_cb_t">mxml_sax_cb_t</A> sax_cb,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;void *sax_data
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>fd</DT>
+<DD class="description">File descriptor to read from</DD>
+<DT>cb</DT>
+<DD class="description">Callback function or MXML_NO_CALLBACK</DD>
+<DT>sax_cb</DT>
+<DD class="description">SAX callback or MXML_NO_CALLBACK</DD>
+<DT>sax_data</DT>
+<DD class="description">SAX user data</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">First node or NULL if the file could not be read.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The nodes in the specified file are added to the
+ specified top node. If no top node is provided, the XML file MUST be
+ well-formed with a single parent node like &lt;?xml&gt; for the entire file.
+ The callback function returns the value type that should be used for
+ child nodes. If MXML_NO_CALLBACK is specified then all child nodes will
+ be either MXML_ELEMENT or MXML_TEXT nodes.
+<BR>
+<BR> The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ child nodes of the specified type.
+<BR>
+<BR> The SAX callback must call mxmlRetain() for any nodes that need to
+ be kept for later use. Otherwise, nodes are deleted when the parent
+ node is closed or after each data, comment, CDATA, or directive node.</P>
+<H3 class="function"><A NAME="8_2_33">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSAXLoadFile">mxmlSAXLoadFile</A></A></H3>
+<P class="description">Load a file into an XML node tree using a SAX
+ callback.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlSAXLoadFile
+ (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;FILE *fp,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_sax_cb_t">mxml_sax_cb_t</A> sax_cb,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;void *sax_data
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>fp</DT>
+<DD class="description">File to read from</DD>
+<DT>cb</DT>
+<DD class="description">Callback function or MXML_NO_CALLBACK</DD>
+<DT>sax_cb</DT>
+<DD class="description">SAX callback or MXML_NO_CALLBACK</DD>
+<DT>sax_data</DT>
+<DD class="description">SAX user data</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">First node or NULL if the file could not be read.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The nodes in the specified file are added to the
+ specified top node. If no top node is provided, the XML file MUST be
+ well-formed with a single parent node like &lt;?xml&gt; for the entire file.
+ The callback function returns the value type that should be used for
+ child nodes. If MXML_NO_CALLBACK is specified then all child nodes will
+ be either MXML_ELEMENT or MXML_TEXT nodes.
+<BR>
+<BR> The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ child nodes of the specified type.
+<BR>
+<BR> The SAX callback must call mxmlRetain() for any nodes that need to
+ be kept for later use. Otherwise, nodes are deleted when the parent
+ node is closed or after each data, comment, CDATA, or directive node.</P>
+<H3 class="function"><A NAME="8_2_34">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSAXLoadString">mxmlSAXLoadString</A></A></H3>
+<P class="description">Load a string into an XML node tree using a SAX
+ callback.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A>
+ *mxmlSAXLoadString (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *s,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_sax_cb_t">mxml_sax_cb_t</A> sax_cb,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;void *sax_data
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>s</DT>
+<DD class="description">String to load</DD>
+<DT>cb</DT>
+<DD class="description">Callback function or MXML_NO_CALLBACK</DD>
+<DT>sax_cb</DT>
+<DD class="description">SAX callback or MXML_NO_CALLBACK</DD>
+<DT>sax_data</DT>
+<DD class="description">SAX user data</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">First node or NULL if the string has errors.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The nodes in the specified string are added to the
+ specified top node. If no top node is provided, the XML string MUST be
+ well-formed with a single parent node like &lt;?xml&gt; for the entire
+ string. The callback function returns the value type that should be
+ used for child nodes. If MXML_NO_CALLBACK is specified then all child
+ nodes will be either MXML_ELEMENT or MXML_TEXT nodes.
+<BR>
+<BR> The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ child nodes of the specified type.
+<BR>
+<BR> The SAX callback must call mxmlRetain() for any nodes that need to
+ be kept for later use. Otherwise, nodes are deleted when the parent
+ node is closed or after each data, comment, CDATA, or directive node.</P>
+<H3 class="function"><A name="mxmlSaveAllocString">mxmlSaveAllocString</A>
+</H3>
+<P class="description">Save an XML node tree to an allocated string.</P>
+<P class="code"> char *mxmlSaveAllocString (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_save_cb_t">mxml_save_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to write</DD>
+<DT>cb</DT>
+<DD class="description">Whitespace callback or MXML_NO_CALLBACK</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Allocated string or NULL</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">This function returns a pointer to a string
+ containing the textual representation of the XML node tree. The string
+ should be freed using the free() function when you are done with it.
+ NULL is returned if the node would produce an empty string or if the
+ string cannot be allocated.
+<BR>
+<BR> The callback argument specifies a function that returns a
+ whitespace string or NULL before and after each element. If
+ MXML_NO_CALLBACK is specified, whitespace will only be added before
+ MXML_TEXT nodes with leading whitespace and before attribute names
+ inside opening element tags.</P>
+<H3 class="function"><A name="mxmlSaveFd">mxmlSaveFd</A></H3>
+<P class="description">Save an XML tree to a file descriptor.</P>
+<P class="code"> int mxmlSaveFd (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int fd,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_save_cb_t">mxml_save_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to write</DD>
+<DT>fd</DT>
+<DD class="description">File descriptor to write to</DD>
+<DT>cb</DT>
+<DD class="description">Whitespace callback or MXML_NO_CALLBACK</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on error.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The callback argument specifies a function that
+ returns a whitespace string or NULL before and after each element. If
+ MXML_NO_CALLBACK is specified, whitespace will only be added before
+ MXML_TEXT nodes with leading whitespace and before attribute names
+ inside opening element tags.</P>
+<H3 class="function"><A name="mxmlSaveFile">mxmlSaveFile</A></H3>
+<P class="description">Save an XML tree to a file.</P>
+<P class="code"> int mxmlSaveFile (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;FILE *fp,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_save_cb_t">mxml_save_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to write</DD>
+<DT>fp</DT>
+<DD class="description">File to write to</DD>
+<DT>cb</DT>
+<DD class="description">Whitespace callback or MXML_NO_CALLBACK</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on error.</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The callback argument specifies a function that
+ returns a whitespace string or NULL before and after each element. If
+ MXML_NO_CALLBACK is specified, whitespace will only be added before
+ MXML_TEXT nodes with leading whitespace and before attribute names
+ inside opening element tags.</P>
+<H3 class="function"><A name="mxmlSaveString">mxmlSaveString</A></H3>
+<P class="description">Save an XML node tree to a string.</P>
+<P class="code"> int mxmlSaveString (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;char *buffer,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int bufsize,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_save_cb_t">mxml_save_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to write</DD>
+<DT>buffer</DT>
+<DD class="description">String buffer</DD>
+<DT>bufsize</DT>
+<DD class="description">Size of string buffer</DD>
+<DT>cb</DT>
+<DD class="description">Whitespace callback or MXML_NO_CALLBACK</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Size of string</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">This function returns the total number of bytes
+ that would be required for the string but only copies (bufsize - 1)
+ characters into the specified buffer.
+<BR>
+<BR> The callback argument specifies a function that returns a
+ whitespace string or NULL before and after each element. If
+ MXML_NO_CALLBACK is specified, whitespace will only be added before
+ MXML_TEXT nodes with leading whitespace and before attribute names
+ inside opening element tags.</P>
+<H3 class="function"><A NAME="8_2_39">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSetCDATA">mxmlSetCDATA</A></A></H3>
+<P class="description">Set the element name of a CDATA node.</P>
+<P class="code"> int mxmlSetCDATA (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *data
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>data</DT>
+<DD class="description">New data string</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not a CDATA
+ element node.</P>
+<H3 class="function"><A NAME="8_2_40">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.1&nbsp;<A name="mxmlSetCustom">mxmlSetCustom</A></A></H3>
+<P class="description">Set the data and destructor of a custom data
+ node.</P>
+<P class="code"> int mxmlSetCustom (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;void *data,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</A>
+ destroy
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>data</DT>
+<DD class="description">New data pointer</DD>
+<DT>destroy</DT>
+<DD class="description">New destructor function</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not a custom
+ node.</P>
+<H3 class="function"><A name="mxmlSetCustomHandlers">
+mxmlSetCustomHandlers</A></H3>
+<P class="description">Set the handling functions for custom data.</P>
+<P class="code"> void mxmlSetCustomHandlers (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_custom_load_cb_t">mxml_custom_load_cb_t</A>
+ load,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_custom_save_cb_t">mxml_custom_save_cb_t</A> save
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>load</DT>
+<DD class="description">Load function</DD>
+<DT>save</DT>
+<DD class="description">Save function</DD>
+</DL>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The load function accepts a node pointer and a
+ data string and must return 0 on success and non-zero on error.
+<BR>
+<BR> The save function accepts a node pointer and must return a malloc'd
+ string on success and NULL on error.</P>
+<H3 class="function"><A name="mxmlSetElement">mxmlSetElement</A></H3>
+<P class="description">Set the name of an element node.</P>
+<P class="code"> int mxmlSetElement (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *name
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>name</DT>
+<DD class="description">New name string</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not an element
+ node.</P>
+<H3 class="function"><A name="mxmlSetErrorCallback">mxmlSetErrorCallback</A>
+</H3>
+<P class="description">Set the error message callback.</P>
+<P class="code"> void mxmlSetErrorCallback (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_error_cb_t">mxml_error_cb_t</A> cb
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>cb</DT>
+<DD class="description">Error callback function</DD>
+</DL>
+<H3 class="function"><A name="mxmlSetInteger">mxmlSetInteger</A></H3>
+<P class="description">Set the value of an integer node.</P>
+<P class="code"> int mxmlSetInteger (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int integer
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>integer</DT>
+<DD class="description">Integer value</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not an integer
+ node.</P>
+<H3 class="function"><A name="mxmlSetOpaque">mxmlSetOpaque</A></H3>
+<P class="description">Set the value of an opaque node.</P>
+<P class="code"> int mxmlSetOpaque (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *opaque
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>opaque</DT>
+<DD class="description">Opaque string</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not an opaque
+ node.</P>
+<H3 class="function"><A name="mxmlSetReal">mxmlSetReal</A></H3>
+<P class="description">Set the value of a real number node.</P>
+<P class="code"> int mxmlSetReal (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;double real
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>real</DT>
+<DD class="description">Real number value</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not a real number
+ node.</P>
+<H3 class="function"><A name="mxmlSetText">mxmlSetText</A></H3>
+<P class="description">Set the value of a text node.</P>
+<P class="code"> int mxmlSetText (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int whitespace,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *string
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>whitespace</DT>
+<DD class="description">1 = leading whitespace, 0 = no whitespace</DD>
+<DT>string</DT>
+<DD class="description">String</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not a text node.</P>
+<H3 class="function"><A name="mxmlSetTextf">mxmlSetTextf</A></H3>
+<P class="description">Set the value of a text node to a formatted
+ string.</P>
+<P class="code"> int mxmlSetTextf (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int whitespace,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;const char *format,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;...
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Node to set</DD>
+<DT>whitespace</DT>
+<DD class="description">1 = leading whitespace, 0 = no whitespace</DD>
+<DT>format</DT>
+<DD class="description">Printf-style format string</DD>
+<DT>...</DT>
+<DD class="description">Additional arguments as needed</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">0 on success, -1 on failure</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The node is not changed if it is not a text node.</P>
+<H3 class="function"><A NAME="8_2_49">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSetWrapMargin">mxmlSetWrapMargin</A></A></H3>
+<P class="description">Set the the wrap margin when saving XML data.</P>
+<P class="code"> void mxmlSetWrapMargin (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int column
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>column</DT>
+<DD class="description">Column for wrapping, 0 to disable wrapping</DD>
+</DL>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">Wrapping is disabled when &quot;column&quot; is 0.</P>
+<H3 class="function"><A name="mxmlWalkNext">mxmlWalkNext</A></H3>
+<P class="description">Walk to the next logical node in the tree.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlWalkNext (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int descend
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Current node</DD>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>descend</DT>
+<DD class="description">Descend into tree - MXML_DESCEND,
+ MXML_NO_DESCEND, or MXML_DESCEND_FIRST</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Next node or NULL</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The descend argument controls whether the first
+ child is considered to be the next node. The top node argument
+ constrains the walk to the node's children.</P>
+<H3 class="function"><A name="mxmlWalkPrev">mxmlWalkPrev</A></H3>
+<P class="description">Walk to the previous logical node in the tree.</P>
+<P class="code"> <A href="#mxml_node_t">mxml_node_t</A> *mxmlWalkPrev (
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *node,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> *top,
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int descend
+<BR> );</P>
+<H4 class="parameters">Parameters</H4>
+<DL>
+<DT>node</DT>
+<DD class="description">Current node</DD>
+<DT>top</DT>
+<DD class="description">Top node</DD>
+<DT>descend</DT>
+<DD class="description">Descend into tree - MXML_DESCEND,
+ MXML_NO_DESCEND, or MXML_DESCEND_FIRST</DD>
+</DL>
+<H4 class="returnvalue">Return Value</H4>
+<P class="description">Previous node or NULL</P>
+<H4 class="discussion">Discussion</H4>
+<P class="discussion">The descend argument controls whether the previous
+ node's last child is considered to be the previous node. The top node
+ argument constrains the walk to the node's children.</P>
+<H2 class="title"><A name="TYPES">Data Types</A></H2>
+<H3 class="typedef"><A name="mxml_attr_t">mxml_attr_t</A></H3>
+<P class="description">An XML element attribute value.</P>
+<P class="code"> typedef struct <A href="#mxml_attr_s">mxml_attr_s</A>
+ mxml_attr_t;</P>
+<H3 class="typedef"><A name="mxml_custom_destroy_cb_t">
+mxml_custom_destroy_cb_t</A></H3>
+<P class="description">Custom data destructor</P>
+<P class="code"> typedef void (*mxml_custom_destroy_cb_t)(void *);</P>
+<H3 class="typedef"><A name="mxml_custom_load_cb_t">
+mxml_custom_load_cb_t</A></H3>
+<P class="description">Custom data load callback function</P>
+<P class="code"> typedef int (*mxml_custom_load_cb_t)(<A href="#mxml_node_t">
+mxml_node_t</A> *, const char *);</P>
+<H3 class="typedef"><A name="mxml_custom_save_cb_t">
+mxml_custom_save_cb_t</A></H3>
+<P class="description">Custom data save callback function</P>
+<P class="code"> typedef char *(*mxml_custom_save_cb_t)(<A href="#mxml_node_t">
+mxml_node_t</A> *);</P>
+<H3 class="typedef"><A NAME="8_3_5">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.1&nbsp;<A name="mxml_custom_t">mxml_custom_t</A></A></H3>
+<P class="description">An XML custom value.</P>
+<P class="code"> typedef struct <A href="#mxml_custom_s">mxml_custom_s</A>
+ mxml_custom_t;</P>
+<H3 class="typedef"><A name="mxml_element_t">mxml_element_t</A></H3>
+<P class="description">An XML element value.</P>
+<P class="code"> typedef struct <A href="#mxml_element_s">mxml_element_s</A>
+ mxml_element_t;</P>
+<H3 class="typedef"><A name="mxml_entity_cb_t">mxml_entity_cb_t</A></H3>
+<P class="description">Entity callback function</P>
+<P class="code"> typedef int (*mxml_entity_cb_t)(const char *);</P>
+<H3 class="typedef"><A name="mxml_error_cb_t">mxml_error_cb_t</A></H3>
+<P class="description">Error callback function</P>
+<P class="code"> typedef void (*mxml_error_cb_t)(const char *);</P>
+<H3 class="typedef"><A name="mxml_index_t">mxml_index_t</A></H3>
+<P class="description">An XML node index.</P>
+<P class="code"> typedef struct <A href="#mxml_index_s">mxml_index_s</A>
+ mxml_index_t;</P>
+<H3 class="typedef"><A name="mxml_load_cb_t">mxml_load_cb_t</A></H3>
+<P class="description">Load callback function</P>
+<P class="code"> typedef <A href="#mxml_type_t">mxml_type_t</A>
+ (*mxml_load_cb_t)(<A href="#mxml_node_t">mxml_node_t</A> *);</P>
+<H3 class="typedef"><A name="mxml_node_t">mxml_node_t</A></H3>
+<P class="description">An XML node.</P>
+<P class="code"> typedef struct <A href="#mxml_node_s">mxml_node_s</A>
+ mxml_node_t;</P>
+<H3 class="typedef"><A name="mxml_save_cb_t">mxml_save_cb_t</A></H3>
+<P class="description">Save callback function</P>
+<P class="code"> typedef const char *(*mxml_save_cb_t)(<A href="#mxml_node_t">
+mxml_node_t</A> *, int);</P>
+<H3 class="typedef"><A name="mxml_sax_cb_t">mxml_sax_cb_t</A></H3>
+<P class="description">SAX callback function</P>
+<P class="code"> typedef void (*mxml_sax_cb_t)(<A href="#mxml_node_t">
+mxml_node_t</A> *, mxml_sax_event_t, void *);</P>
+<H3 class="typedef"><A name="mxml_sax_event_t">mxml_sax_event_t</A></H3>
+<P class="description">SAX event type.</P>
+<P class="code"> typedef enum <A href="#mxml_sax_event_e">
+mxml_sax_event_e</A> mxml_sax_event_t;</P>
+<H3 class="typedef"><A name="mxml_text_t">mxml_text_t</A></H3>
+<P class="description">An XML text value.</P>
+<P class="code"> typedef struct <A href="#mxml_text_s">mxml_text_s</A>
+ mxml_text_t;</P>
+<H3 class="typedef"><A name="mxml_type_t">mxml_type_t</A></H3>
+<P class="description">The XML node type.</P>
+<P class="code"> typedef enum <A href="#mxml_type_e">mxml_type_e</A>
+ mxml_type_t;</P>
+<H3 class="typedef"><A name="mxml_value_t">mxml_value_t</A></H3>
+<P class="description">An XML node value.</P>
+<P class="code"> typedef union <A href="#mxml_value_u">mxml_value_u</A>
+ mxml_value_t;</P>
+<H2 class="title"><A name="STRUCTURES">Structures</A></H2>
+<H3 class="struct"><A name="mxml_attr_s">mxml_attr_s</A></H3>
+<P class="description">An XML element attribute value.</P>
+<P class="code">struct mxml_attr_s {
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;char *name;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;char *value;
+<BR> };</P>
+<H4 class="members">Members</H4>
+<DL>
+<DT>name</DT>
+<DD class="description">Attribute name</DD>
+<DT>value</DT>
+<DD class="description">Attribute value</DD>
+</DL>
+<H3 class="struct"><A NAME="8_4_2">
+<!--span class=&quot;info&quot;-->
+&nbsp;Mini-XML 2.1&nbsp;<A name="mxml_custom_s">mxml_custom_s</A></A></H3>
+<P class="description">An XML custom value.</P>
+<P class="code">struct mxml_custom_s {
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;void *data;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</A>
+ destroy;
+<BR> };</P>
+<H4 class="members">Members</H4>
+<DL>
+<DT>data</DT>
+<DD class="description">Pointer to (allocated) custom data</DD>
+<DT>destroy</DT>
+<DD class="description">Pointer to destructor function</DD>
+</DL>
+<H3 class="struct"><A name="mxml_element_s">mxml_element_s</A></H3>
+<P class="description">An XML element value.</P>
+<P class="code">struct mxml_element_s {
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_attr_t">mxml_attr_t</A> *attrs;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;char *name;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int num_attrs;
+<BR> };</P>
+<H4 class="members">Members</H4>
+<DL>
+<DT>attrs</DT>
+<DD class="description">Attributes</DD>
+<DT>name</DT>
+<DD class="description">Name of element</DD>
+<DT>num_attrs</DT>
+<DD class="description">Number of attributes</DD>
+</DL>
+<H3 class="struct"><A name="mxml_index_s">mxml_index_s</A></H3>
+<P class="description">An XML node index.</P>
+<P class="code">struct mxml_index_s {
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int alloc_nodes;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;char *attr;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int cur_node;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> **nodes;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int num_nodes;
+<BR> };</P>
+<H4 class="members">Members</H4>
+<DL>
+<DT>alloc_nodes</DT>
+<DD class="description">Allocated nodes in index</DD>
+<DT>attr</DT>
+<DD class="description">Attribute used for indexing or NULL</DD>
+<DT>cur_node</DT>
+<DD class="description">Current node</DD>
+<DT>nodes</DT>
+<DD class="description">Node array</DD>
+<DT>num_nodes</DT>
+<DD class="description">Number of nodes in index</DD>
+</DL>
+<H3 class="struct"><A name="mxml_node_s">mxml_node_s</A></H3>
+<P class="description">An XML node.</P>
+<P class="code">struct mxml_node_s {
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> *child;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> *last_child;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> *next;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> *parent;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> *prev;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int ref_count;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_type_t">mxml_type_t</A> type;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;void *user_data;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_value_t">mxml_value_t</A> value;
+<BR> };</P>
+<H4 class="members">Members</H4>
+<DL>
+<DT>child</DT>
+<DD class="description">First child node</DD>
+<DT>last_child</DT>
+<DD class="description">Last child node</DD>
+<DT>next</DT>
+<DD class="description">Next node under same parent</DD>
+<DT>parent</DT>
+<DD class="description">Parent node</DD>
+<DT>prev</DT>
+<DD class="description">Previous node under same parent</DD>
+<DT>ref_count</DT>
+<DD class="description">Use count</DD>
+<DT>type</DT>
+<DD class="description">Node type</DD>
+<DT>user_data</DT>
+<DD class="description">User data</DD>
+<DT>value</DT>
+<DD class="description">Node value</DD>
+</DL>
+<H3 class="struct"><A name="mxml_text_s">mxml_text_s</A></H3>
+<P class="description">An XML text value.</P>
+<P class="code">struct mxml_text_s {
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;char *string;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int whitespace;
+<BR> };</P>
+<H4 class="members">Members</H4>
+<DL>
+<DT>string</DT>
+<DD class="description">Fragment string</DD>
+<DT>whitespace</DT>
+<DD class="description">Leading whitespace?</DD>
+</DL>
+<H2 class="title"><A name="UNIONS">Unions</A></H2>
+<H3 class="union"><A name="mxml_value_u">mxml_value_u</A></H3>
+<P class="description">An XML node value.</P>
+<P class="code">union mxml_value_u {
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_custom_t">mxml_custom_t</A> custom;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_element_t">mxml_element_t</A> element;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;int integer;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;char *opaque;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;double real;
+<BR> &nbsp;&nbsp;&nbsp;&nbsp;<A href="#mxml_text_t">mxml_text_t</A> text;
+<BR> };</P>
+<H4 class="members">Members</H4>
+<DL>
+<DT>custom
+<!--span class=&quot;info&quot;-->
+ &nbsp;Mini-XML 2.1&nbsp;</DT>
+<DD class="description">Custom data</DD>
+<DT>element</DT>
+<DD class="description">Element</DD>
+<DT>integer</DT>
+<DD class="description">Integer number</DD>
+<DT>opaque</DT>
+<DD class="description">Opaque string</DD>
+<DT>real</DT>
+<DD class="description">Real number</DD>
+<DT>text</DT>
+<DD class="description">Text fragment</DD>
+</DL>
+<H2 class="title"><A name="ENUMERATIONS">Constants</A></H2>
+<H3 class="enumeration"><A name="mxml_sax_event_e">mxml_sax_event_e</A></H3>
+<P class="description">SAX event type.</P>
+<H4 class="constants">Constants</H4>
+<DL>
+<DT>MXML_SAX_CDATA</DT>
+<DD class="description">CDATA node</DD>
+<DT>MXML_SAX_COMMENT</DT>
+<DD class="description">Comment node</DD>
+<DT>MXML_SAX_DATA</DT>
+<DD class="description">Data node</DD>
+<DT>MXML_SAX_DIRECTIVE</DT>
+<DD class="description">Processing directive node</DD>
+<DT>MXML_SAX_ELEMENT_CLOSE</DT>
+<DD class="description">Element closed</DD>
+<DT>MXML_SAX_ELEMENT_OPEN</DT>
+<DD class="description">Element opened</DD>
+</DL>
+<H3 class="enumeration"><A name="mxml_type_e">mxml_type_e</A></H3>
+<P class="description">The XML node type.</P>
+<H4 class="constants">Constants</H4>
+<DL>
+<DT>MXML_CUSTOM
+<!--span class=&quot;info&quot;-->
+ &nbsp;Mini-XML 2.1&nbsp;</DT>
+<DD class="description">Custom data</DD>
+<DT>MXML_ELEMENT</DT>
+<DD class="description">XML element with attributes</DD>
+<DT>MXML_IGNORE
+<!--span class=&quot;info&quot;-->
+ &nbsp;Mini-XML 2.3&nbsp;</DT>
+<DD class="description">Ignore/throw away node</DD>
+<DT>MXML_INTEGER</DT>
+<DD class="description">Integer value</DD>
+<DT>MXML_OPAQUE</DT>
+<DD class="description">Opaque string</DD>
+<DT>MXML_REAL</DT>
+<DD class="description">Real value</DD>
+<DT>MXML_TEXT</DT>
+<DD class="description">Text fragment</DD>
+</DL>
+</UL>
+</DIV><HR NOSHADE>
+<H1 align="right"><A name="SCHEMA"><IMG align="right" alt="D" height="100"
+hspace="10" src="D.gif" width="100"></A>XML Schema</H1>
+<P>This appendix provides the XML schema that is used for the XML files
+ produced by <TT>mxmldoc</TT>. This schema is available on-line at:</P>
+<PRE>
+    http://www.easysw.com/~mike/mxmldoc.xsd
+</PRE>
+<H2><A NAME="9_1">mxmldoc.xsd</A></H2>
+<PRE><SMALL>
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
+  &lt;xsd:annotation&gt;
+    &lt;xsd:documentation xml:lang=&quot;en&quot;&gt;
+      Mini-XML 2.3 documentation schema for mxmldoc output.
+      Copyright 2003-2007 by Michael Sweet.
+    &lt;/xsd:documentation&gt;
+  &lt;/xsd:annotation&gt;
+
+  &lt;!-- basic element definitions --&gt;
+  &lt;xsd:element name=&quot;argument&quot; type=&quot;argumentType&quot;/&gt;
+  &lt;xsd:element name=&quot;class&quot; type=&quot;classType&quot;/&gt;
+  &lt;xsd:element name=&quot;constant&quot; type=&quot;constantType&quot;/&gt;
+  &lt;xsd:element name=&quot;description&quot; type=&quot;xsd:string&quot;/&gt;
+  &lt;xsd:element name=&quot;enumeration&quot; type=&quot;enumerationType&quot;/&gt;
+  &lt;xsd:element name=&quot;function&quot; type=&quot;functionType&quot;/&gt;
+  &lt;xsd:element name=&quot;mxmldoc&quot; type=&quot;mxmldocType&quot;/&gt;
+  &lt;xsd:element name=&quot;namespace&quot; type=&quot;namespaceType&quot;/&gt;
+  &lt;xsd:element name=&quot;returnvalue&quot; type=&quot;returnvalueType&quot;/&gt;
+  &lt;xsd:element name=&quot;seealso&quot; type=&quot;identifierList&quot;/&gt;
+  &lt;xsd:element name=&quot;struct&quot; type=&quot;structType&quot;/&gt;
+  &lt;xsd:element name=&quot;typedef&quot; type=&quot;typedefType&quot;/&gt;
+  &lt;xsd:element name=&quot;type&quot; type=&quot;xsd:string&quot;/&gt;
+  &lt;xsd:element name=&quot;union&quot; type=&quot;unionType&quot;/&gt;
+  &lt;xsd:element name=&quot;variable&quot; type=&quot;variableType&quot;/&gt;
+
+  &lt;!-- descriptions of complex elements --&gt;
+  &lt;xsd:complexType name=&quot;argumentType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;type&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;default&quot; type=&quot;xsd:string&quot; use=&quot;optional&quot;/&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+    &lt;xsd:attribute name=&quot;direction&quot; type=&quot;direction&quot; use=&quot;optional&quot;
+     default=&quot;I&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;classType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
+	&lt;xsd:element ref=&quot;class&quot;/&gt;
+	&lt;xsd:element ref=&quot;enumeration&quot;/&gt;
+	&lt;xsd:element ref=&quot;function&quot;/&gt;
+	&lt;xsd:element ref=&quot;struct&quot;/&gt;
+	&lt;xsd:element ref=&quot;typedef&quot;/&gt;
+	&lt;xsd:element ref=&quot;union&quot;/&gt;
+	&lt;xsd:element ref=&quot;variable&quot;/&gt;
+      &lt;/xsd:choice&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+    &lt;xsd:attribute name=&quot;parent&quot; type=&quot;xsd:string&quot; use=&quot;optional&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;constantType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;enumerationType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;constant&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;functionType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;returnvalue&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;argument&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt;
+      &lt;xsd:element ref=&quot;seealso&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+    &lt;xsd:attribute name=&quot;scope&quot; type=&quot;scope&quot; use=&quot;optional&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;mxmldocType&quot;&gt;
+    &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
+      &lt;xsd:element ref=&quot;class&quot;/&gt;
+      &lt;xsd:element ref=&quot;enumeration&quot;/&gt;
+      &lt;xsd:element ref=&quot;function&quot;/&gt;
+      &lt;xsd:element ref=&quot;namespace&quot;/&gt;
+      &lt;xsd:element ref=&quot;struct&quot;/&gt;
+      &lt;xsd:element ref=&quot;typedef&quot;/&gt;
+      &lt;xsd:element ref=&quot;union&quot;/&gt;
+      &lt;xsd:element ref=&quot;variable&quot;/&gt;
+    &lt;/xsd:choice&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;namespaceType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
+	&lt;xsd:element ref=&quot;class&quot;/&gt;
+	&lt;xsd:element ref=&quot;enumeration&quot;/&gt;
+	&lt;xsd:element ref=&quot;function&quot;/&gt;
+	&lt;xsd:element ref=&quot;struct&quot;/&gt;
+	&lt;xsd:element ref=&quot;typedef&quot;/&gt;
+	&lt;xsd:element ref=&quot;union&quot;/&gt;
+	&lt;xsd:element ref=&quot;variable&quot;/&gt;
+      &lt;/xsd:choice&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;returnvalueType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;type&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;structType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
+	&lt;xsd:element ref=&quot;variable&quot;/&gt;
+	&lt;xsd:element ref=&quot;function&quot;/&gt;
+      &lt;/xsd:choice&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;typedefType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;type&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;unionType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;variable&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;xsd:complexType name=&quot;variableType&quot;&gt;
+    &lt;xsd:sequence&gt;
+      &lt;xsd:element ref=&quot;type&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;/&gt;
+      &lt;xsd:element ref=&quot;description&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
+    &lt;/xsd:sequence&gt;
+    &lt;xsd:attribute name=&quot;name&quot; type=&quot;identifier&quot; use=&quot;required&quot;/&gt;
+  &lt;/xsd:complexType&gt;
+
+  &lt;!-- data types --&gt;
+  &lt;xsd:simpleType name=&quot;direction&quot;&gt;
+    &lt;xsd:restriction base=&quot;xsd:string&quot;&gt;
+      &lt;xsd:enumeration value=&quot;I&quot;/&gt;
+      &lt;xsd:enumeration value=&quot;O&quot;/&gt;
+      &lt;xsd:enumeration value=&quot;IO&quot;/&gt;
+    &lt;/xsd:restriction&gt;
+  &lt;/xsd:simpleType&gt;
+
+  &lt;xsd:simpleType name=&quot;identifier&quot;&gt;
+    &lt;xsd:restriction base=&quot;xsd:string&quot;&gt;
+      &lt;xsd:pattern value=&quot;[a-zA-Z_(.]([a-zA-Z_(.,)* 0-9])*&quot;/&gt;
+    &lt;/xsd:restriction&gt;
+  &lt;/xsd:simpleType&gt;
+
+  &lt;xsd:simpleType name=&quot;identifierList&quot;&gt;
+    &lt;xsd:list itemType=&quot;identifier&quot;/&gt;
+  &lt;/xsd:simpleType&gt;
+
+  &lt;xsd:simpleType name=&quot;scope&quot;&gt;
+    &lt;xsd:restriction base=&quot;xsd:string&quot;&gt;
+      &lt;xsd:enumeration value=&quot;&quot;/&gt;
+      &lt;xsd:enumeration value=&quot;private&quot;/&gt;
+      &lt;xsd:enumeration value=&quot;protected&quot;/&gt;
+      &lt;xsd:enumeration value=&quot;public&quot;/&gt;
+    &lt;/xsd:restriction&gt;
+  &lt;/xsd:simpleType&gt;
+&lt;/xsd:schema&gt;
+</SMALL></PRE>
+</BODY>
+</HTML>
diff -Naur mxml-2.6/doc/mxmldoc.html mxml-2.6-haiku/doc/mxmldoc.html
--- mxml-2.6/doc/mxmldoc.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/mxmldoc.html	2009-05-17 06:04:58.000000000 +0000
@@ -0,0 +1,204 @@
+<html>
+<body>
+
+<h1 align='right'><a name='MXMLDOC'><img src="4.gif" align="right"
+hspace="10" width="100" height="100" alt="4"></a>Using the mxmldoc
+Utility</h1>
+
+<p>This chapter describes how to use <tt>mxmldoc(1)</tt> program to
+automatically generate documentation from C and C++ source
+files.</p>
+
+
+<h2>The Basics</h2>
+
+<p>Originally developed to generate the Mini-XML and CUPS API
+documentation, <tt>mxmldoc</tt> is now a general-purpose utility
+which scans C and C++ source files to produce HTML and man page
+documentation along with an XML file representing the functions,
+types, and definitions in those source files. Unlike popular
+documentation generators like Doxygen or Javadoc, <tt>mxmldoc</tt>
+uses in-line comments rather than comment headers, allowing for more
+"natural" code documentation.</p>
+
+<p>By default, <tt>mxmldoc</tt> produces HTML documentation. For
+example, the following command will scan all of the C source and
+header files in the current directory and produce a HTML
+documentation file called <var>filename.html</var>:</p>
+
+<pre>
+    <kbd>mxmldoc *.h *.c &gt;filename.html ENTER</kbd>
+</pre>
+
+<p>You can also specify an XML file to create which contains all of
+the information from the source files. For example, the following
+command creates an XML file called <var>filename.xml</var> in
+addition to the HTML file:</p>
+
+<pre>
+    <kbd>mxmldoc filename.xml *.h *.c &gt;filename.html ENTER</kbd>
+</pre>
+
+<p>The <tt>--no-output</tt> option disables the normal HTML
+output:</p>
+
+<pre>
+    <kbd>mxmldoc --no-output filename.xml *.h *.c ENTER</kbd>
+</pre>
+
+<p>You can then run <tt>mxmldoc</tt> again with the XML file alone
+to generate the HTML documentation:</p>
+
+<pre>
+    <kbd>mxmldoc filename.xml &gt;filename.html ENTER</kbd>
+</pre>
+
+<h3>Creating Man Pages</h3>
+
+<p>The <tt>--man filename</tt> option tells <tt>mxmldoc</tt> to
+create a man page instead of HTML documentation, for example:</p>
+
+<pre>
+    <kbd>mxmldoc --man filename filename.xml \
+        &gt;filename.man ENTER</kbd>
+
+    <kbd>mxmldoc --man filename *.h *.c \
+        &gt;filename.man ENTER</kbd>
+</pre>
+
+<h3>Creating Xcode Documentation Sets</h3>
+
+<p>The <tt>--docset directory.docset</tt> option tells <tt>mxmldoc</tt> to
+create an Xcode documentation set containing the HTML documentation, for
+example:</p>
+
+<pre>
+    <kbd>mxmldoc --docset foo.docset *.h *.c foo.xml ENTER</kbd>
+</pre>
+
+<p>Xcode documentation sets can only be built on Mac OS X with Xcode 3.0 or
+higher installed.</p>
+
+
+<h2>Commenting Your Code</h2>
+
+<p>As noted previously, <tt>mxmldoc</tt> looks for in-line comments
+to describe the functions, types, and constants in your code.
+<tt>Mxmldoc</tt> will document all public names it finds in your
+source files - any names starting with the underscore character (_) 
+or names that are documented with the <A
+HREF="#ATDIRECTIVES">@private@</A> directive are treated as private
+and are undocumented.</p>
+
+<p>Comments appearing directly before a function or type definition
+are used to document that function or type. Comments appearing after
+argument, definition, return type, or variable declarations are used
+to document that argument, definition, return type, or variable. For
+example, the following code excerpt defines a key/value structure
+and a function that creates a new instance of that structure:</p> 
+
+<pre>
+    /* A key/value pair. This is used with the
+       dictionary structure. */
+
+    struct keyval
+    {
+      char *key; /* Key string */
+      char *val; /* Value string */
+    };
+
+    /* Create a new key/value pair. */
+
+    struct keyval * /* New key/value pair */
+    new_keyval(
+        const char *key, /* Key string */
+	const char *val) /* Value string */
+    {
+      ...
+    }
+</pre>
+
+<p><tt>Mxmldoc</tt> also knows to remove extra asterisks (*) from
+the comment string, so the comment string:</p>
+
+<pre>
+    /*
+     * Compute the value of PI.
+     *
+     * The function connects to an Internet server
+     * that streams audio of mathematical monks
+     * chanting the first 100 digits of PI.
+     */
+</pre>
+
+<p>will be shown as:</p>
+
+<pre>
+    Compute the value of PI.
+
+    The function connects to an Internet server
+    that streams audio of mathematical monks
+    chanting the first 100 digits of PI.
+</pre>
+
+<p><a name="ATDIRECTIVES">Comments</a> can also include the
+following special <tt>@name ...@</tt> directive strings:</p>
+
+<ul>
+
+	<li><tt>@deprecated@</tt> - flags the item as deprecated to
+	discourage its use</li>
+
+	<li><tt>@private@</tt> - flags the item as private so it
+	will not be included in the documentation</li>
+
+	<li><tt>@since ...@</tt> - flags the item as new since a
+	particular release. The text following the <tt>@since</tt>
+	up to the closing <tt>@</tt> is highlighted in the generated
+	documentation, e.g. <tt>@since CUPS 1.3@</tt>.</li>
+
+</ul>
+
+
+<!-- NEED 10 -->
+<h2>Titles, Sections, and Introductions</h2>
+
+<p><tt>Mxmldoc</tt> also provides options to set the title, section,
+and introduction text for the generated documentation. The
+<tt>--title text</tt> option specifies the title for the
+documentation. The title string is usually put in quotes:</p>
+
+<pre>
+    <kbd>mxmldoc filename.xml \
+        --title "My Famous Documentation" \
+        &gt;filename.html ENTER</kbd>
+</pre>
+
+<p>The <tt>--section name</tt> option specifies the section for
+the documentation. For HTML documentation, the name is placed in
+a HTML comment such as:</p>
+
+<pre>
+    &lt;!-- SECTION: name -->
+</pre>
+
+<p>For man pages, the section name is usually just a number ("3"),
+or a number followed by a vendor name ("3acme"). The section name is
+used in the <tt>.TH</tt> directive in the man page:</p>
+
+<pre>
+    .TH mylibrary 3acme "My Title" ...
+</pre>
+
+<p>The default section name for man page output is "3". There is no
+default section name for HTML output.</p>
+
+<p>Finally, the <tt>--intro filename</tt> option specifies a file to
+embed after the title and section but before the generated
+documentation. For HTML documentation, the file must consist of
+valid HTML without the usual <tt>DOCTYPE</tt>, <tt>html</tt>, and
+<tt>body</tt> elements. For man page documentation, the file must
+consist of valid <tt>nroff(1)</tt> text.</p>
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/mxmldoc.man mxml-2.6-haiku/doc/mxmldoc.man
--- mxml-2.6/doc/mxmldoc.man	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/mxmldoc.man	2009-05-05 13:38:00.000000000 +0000
@@ -0,0 +1,198 @@
+.\"
+.\" "$Id: mxmldoc.man 390 2009-05-05 13:38:00Z mike $"
+.\"
+.\" mxmldoc man page for mini-XML, a small XML-like file parsing library.
+.\"
+.\" Copyright 2003-2009 by Michael Sweet.
+.\"
+.\" This program is free software; you can redistribute it and/or
+.\" modify it under the terms of the GNU Library General Public
+.\" License as published by the Free Software Foundation; either
+.\" version 2, or (at your option) any later version.
+.\"
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\"
+.TH mxmldoc 1 "Mini-XML" "4 May 2009" "Michael Sweet"
+.SH NAME
+mxmldoc \- mini-xml documentation generator
+.SH SYNOPSIS
+.B mxmldoc
+\-\-no-output [
+.I filename.xml
+]
+.I source file(s)
+]
+.br
+.B mxmldoc
+[ \-\-footer
+.I footerfile
+] [ \-\-header
+.I headerfile
+] [ \-\-intro
+.I introfile
+] [ \-\-section
+.I section
+] [ \-\-title
+.I title
+] [
+.I filename.xml
+] [
+.I source file(s)
+] >
+.I filename.html
+.br
+.B mxmldoc
+\-\-docset
+.I directory.docset
+[ \-\-docversion
+.I version
+] [ \-\-feedname
+.I name
+] [ \-\-feedurl
+.I url
+] [ \-\-footer
+.I footerfile
+] [ \-\-header
+.I headerfile
+] [ \-\-intro
+.I introfile
+] [ \-\-section
+.I section
+] [ \-\-title
+.I title
+] [
+.I filename.xml
+] [
+.I source file(s)
+]
+.br
+.B mxmldoc
+\-\-tokens
+.I path
+[
+.I filename.xml
+] [
+.I source file(s)
+] > tokens.xml
+.br
+.B mxmldoc
+\-\-framed
+.I basename
+[ \-\-footer
+.I footerfile
+] [ \-\-header
+.I headerfile
+] [ \-\-intro
+.I introfile
+] [ \-\-section
+.I section
+] [ \-\-title
+.I title
+] [
+.I filename.xml
+] [
+.I source file(s)
+]
+.br
+.B mxmldoc
+[ \-\-footer
+.I footerfile
+] [ \-\-header
+.I headerfile
+] [ \-\-intro
+.I introfile
+] \-\-man
+.I manpage
+[ \-\-section
+.I section
+] [ \-\-title
+.I title
+] [
+.I filename.xml
+] [
+.I source file(s)
+] >
+.I filename.man
+.SH DESCRIPTION
+\fImxmldoc\fR scans the specified C and C++ source files to produce
+an XML representation of globally accessible classes, constants,
+enumerations, functions, structures, typedefs, unions, and variables
+- the XML file is updated as necessary. By default, a HTML
+representation of the XML file is written to the standard output.
+Use the \fI\-\-no-output\fR option to disable the HTML output.
+.PP
+Man page source can be generated using the \fI\-\-man\fR option.
+.PP
+If no source files are specified then the current XML file is
+converted to the standard output.
+.PP
+In general, any C or C++ source code is handled by \fImxmldoc\fR,
+however it was specifically written to handle code with
+documentation that is formatted according to the CUPS Developer
+Guide which is available at "http://www.cups.org/documentation.php".
+.SH OPTIONS
+.TP 5
+\-\-docset directory.docset
+.br
+Creates an Xcode documentation set in the specified directory.
+.TP 5
+\-\-docversion version
+.br
+Specifies the version number for the Xcode documentation set.
+.TP 5
+\-\-feedname name
+.br
+Specifies the Xcode documentation set feed name, typically the project or
+company name.
+.TP 5
+\-\-feedurl url
+.br
+Specifies the Xcode documentation set feed URL which must point to an ATOM file
+linking to updates.
+.TP 5
+\-\-footer footerfile
+.br
+Inserts the specified file at the bottom of the output documentation.
+.TP 5
+\-\-framed basename
+.br
+Creates HTML documentation using frames - one for the table-of-contents and
+one for the body.
+.TP 5
+\-\-header headerfile
+.br
+Inserts the specified file at the top of the output documentation.
+.TP 5
+\-\-intro introfile
+.br
+Inserts the specified file before the table of contents.
+.TP 5
+\-\-man manpage
+.br
+Generated a man page instead of HTML documentation.
+.TP 5
+\-\-no-output
+.br
+Disables generation of documentation on the standard output.
+.TP 5
+\-\-section section
+.br
+Sets the section/keywords in the output documentation.
+.TP 5
+\-\-title title
+.br
+Sets the title of the output documentation.
+.TP 5
+\-\-tokens
+.br
+Generates a Tokens.xml file for use with the Xcode documentation tools.
+.SH SEE ALSO
+mxml(3), Mini-XML Programmers Manual, http://www.minixml.org/
+.SH COPYRIGHT
+Copyright 2003-2009 by Michael Sweet.
+.\"
+.\" End of "$Id: mxmldoc.man 390 2009-05-05 13:38:00Z mike $".
+.\"
diff -Naur mxml-2.6/doc/mxmldoc.xsd mxml-2.6-haiku/doc/mxmldoc.xsd
--- mxml-2.6/doc/mxmldoc.xsd	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/mxmldoc.xsd	2007-04-18 19:25:26.000000000 +0000
@@ -0,0 +1,189 @@
+<?xml version="1.0"?>
+<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <xsd:annotation>
+    <xsd:documentation xml:lang="en">
+      Mini-XML 2.3 documentation schema for mxmldoc output.
+      Copyright 2003-2007 by Michael Sweet.
+
+      This program is free software; you can redistribute it and/or
+      modify it under the terms of the GNU Library General Public
+      License as published by the Free Software Foundation; either
+      version 2, or (at your option) any later version.
+
+      This program is distributed in the hope that it will be useful,
+      but WITHOUT ANY WARRANTY; without even the implied warranty of
+      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+      GNU General Public License for more details.
+    </xsd:documentation>
+  </xsd:annotation>
+
+  <!-- basic element definitions -->
+  <xsd:element name="argument" type="argumentType"/>
+  <xsd:element name="class" type="classType"/>
+  <xsd:element name="constant" type="constantType"/>
+  <xsd:element name="description" type="xsd:string"/>
+  <xsd:element name="enumeration" type="enumerationType"/>
+  <xsd:element name="function" type="functionType"/>
+  <xsd:element name="mxmldoc" type="mxmldocType"/>
+  <xsd:element name="namespace" type="namespaceType"/>
+  <xsd:element name="returnvalue" type="returnvalueType"/>
+  <xsd:element name="seealso" type="identifierList"/>
+  <xsd:element name="struct" type="structType"/>
+  <xsd:element name="typedef" type="typedefType"/>
+  <xsd:element name="type" type="xsd:string"/>
+  <xsd:element name="union" type="unionType"/>
+  <xsd:element name="variable" type="variableType"/>
+
+  <!-- descriptions of complex elements -->
+  <xsd:complexType name="argumentType">
+    <xsd:sequence>
+      <xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    </xsd:sequence>
+    <xsd:attribute name="default" type="xsd:string" use="optional"/>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+    <xsd:attribute name="direction" type="direction" use="optional" default="I"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="classType">
+    <xsd:sequence>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      <xsd:choice minOccurs="0" maxOccurs="unbounded">
+	<xsd:element ref="class"/>
+	<xsd:element ref="enumeration"/>
+	<xsd:element ref="function"/>
+	<xsd:element ref="struct"/>
+	<xsd:element ref="typedef"/>
+	<xsd:element ref="union"/>
+	<xsd:element ref="variable"/>
+      </xsd:choice>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+    <xsd:attribute name="parent" type="xsd:string" use="optional"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="constantType">
+    <xsd:sequence>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="enumerationType">
+    <xsd:sequence>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      <xsd:element ref="constant" minOccurs="1" maxOccurs="unbounded"/>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="functionType">
+    <xsd:sequence>
+      <xsd:element ref="returnvalue" minOccurs="0" maxOccurs="1"/>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      <xsd:element ref="argument" minOccurs="1" maxOccurs="unbounded"/>
+      <xsd:element ref="seealso" minOccurs="0" maxOccurs="1"/>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+    <xsd:attribute name="scope" type="scope" use="optional"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="mxmldocType">
+    <xsd:choice minOccurs="0" maxOccurs="unbounded">
+      <xsd:element ref="class"/>
+      <xsd:element ref="enumeration"/>
+      <xsd:element ref="function"/>
+      <xsd:element ref="namespace"/>
+      <xsd:element ref="struct"/>
+      <xsd:element ref="typedef"/>
+      <xsd:element ref="union"/>
+      <xsd:element ref="variable"/>
+    </xsd:choice>
+  </xsd:complexType>
+
+  <xsd:complexType name="namespaceType">
+    <xsd:sequence>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      <xsd:choice minOccurs="0" maxOccurs="unbounded">
+	<xsd:element ref="class"/>
+	<xsd:element ref="enumeration"/>
+	<xsd:element ref="function"/>
+	<xsd:element ref="struct"/>
+	<xsd:element ref="typedef"/>
+	<xsd:element ref="union"/>
+	<xsd:element ref="variable"/>
+      </xsd:choice>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="returnvalueType">
+    <xsd:sequence>
+      <xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    </xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:complexType name="structType">
+    <xsd:sequence>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      <xsd:choice minOccurs="0" maxOccurs="unbounded">
+	<xsd:element ref="variable"/>
+	<xsd:element ref="function"/>
+      </xsd:choice>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="typedefType">
+    <xsd:sequence>
+      <xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="unionType">
+    <xsd:sequence>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      <xsd:element ref="variable" minOccurs="0" maxOccurs="unbounded"/>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+  </xsd:complexType>
+
+  <xsd:complexType name="variableType">
+    <xsd:sequence>
+      <xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      <xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    </xsd:sequence>
+    <xsd:attribute name="name" type="identifier" use="required"/>
+  </xsd:complexType>
+
+  <!-- data types -->
+  <xsd:simpleType name="direction">
+    <xsd:restriction base="xsd:string">
+      <xsd:enumeration value="I"/>
+      <xsd:enumeration value="O"/>
+      <xsd:enumeration value="IO"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="identifier">
+    <xsd:restriction base="xsd:string">
+      <xsd:pattern value="[a-zA-Z_(.]([a-zA-Z_(.,)* 0-9])*"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="identifierList">
+    <xsd:list itemType="identifier"/>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="scope">
+    <xsd:restriction base="xsd:string">
+      <xsd:enumeration value=""/>
+      <xsd:enumeration value="private"/>
+      <xsd:enumeration value="protected"/>
+      <xsd:enumeration value="public"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+</xsd:schema>
diff -Naur mxml-2.6/doc/reference.heading mxml-2.6-haiku/doc/reference.heading
--- mxml-2.6/doc/reference.heading	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/reference.heading	2008-01-26 20:50:28.000000000 +0000
@@ -0,0 +1,4 @@
+<h1 align='right'><a name='REFERENCE'><img src="C.gif" align="right"
+hspace="10" width="100" height="100" alt="C"></a>Library
+Reference</h1>
+
diff -Naur mxml-2.6/doc/reference.html mxml-2.6-haiku/doc/reference.html
--- mxml-2.6/doc/reference.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/reference.html	2009-10-26 02:35:54.000000000 +0000
@@ -0,0 +1,1635 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html>
+<head>
+<title>Documentation</title>
+<meta name="creator" content="Mini-XML v2.6">
+<style type="text/css"><!--
+body, p, h1, h2, h3, h4 {
+  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
+}
+div.body h1 {
+  font-size: 250%;
+  font-weight: bold;
+  margin: 0;
+}
+div.body h2 {
+  font-size: 250%;
+  margin-top: 1.5em;
+}
+div.body h3 {
+  font-size: 150%;
+  margin-bottom: 0.5em;
+  margin-top: 1.5em;
+}
+div.body h4 {
+  font-size: 110%;
+  margin-bottom: 0.5em;
+  margin-top: 1.5em;
+}
+div.body h5 {
+  font-size: 100%;
+  margin-bottom: 0.5em;
+  margin-top: 1.5em;
+}
+div.contents {
+  background: #e8e8e8;
+  border: solid thin black;
+  padding: 10px;
+}
+div.contents h1 {
+  font-size: 110%;
+}
+div.contents h2 {
+  font-size: 100%;
+}
+div.contents ul.contents {
+  font-size: 80%;
+}
+.class {
+  border-bottom: solid 2px gray;
+}
+.constants {
+}
+.description {
+  margin-top: 0.5em;
+}
+.discussion {
+}
+.enumeration {
+  border-bottom: solid 2px gray;
+}
+.function {
+  border-bottom: solid 2px gray;
+  margin-bottom: 0;
+}
+.members {
+}
+.method {
+}
+.parameters {
+}
+.returnvalue {
+}
+.struct {
+  border-bottom: solid 2px gray;
+}
+.typedef {
+  border-bottom: solid 2px gray;
+}
+.union {
+  border-bottom: solid 2px gray;
+}
+.variable {
+}
+code, p.code, pre, ul.code li {
+  font-family: monaco, courier, monospace;
+  font-size: 90%;
+}
+a:link, a:visited {
+  text-decoration: none;
+}
+span.info {
+  background: black;
+  border: solid thin black;
+  color: white;
+  font-size: 80%;
+  font-style: italic;
+  font-weight: bold;
+  white-space: nowrap;
+}
+h3 span.info, h4 span.info {
+  float: right;
+  font-size: 100%;
+}
+ul.code, ul.contents, ul.subcontents {
+  list-style-type: none;
+  margin: 0;
+  padding-left: 0;
+}
+ul.code li {
+  margin: 0;
+}
+ul.contents > li {
+  margin-top: 1em;
+}
+ul.contents li ul.code, ul.contents li ul.subcontents {
+  padding-left: 2em;
+}
+div.body dl {
+  margin-top: 0;
+}
+div.body dt {
+  font-style: italic;
+  margin-top: 0;
+}
+div.body dd {
+  margin-bottom: 0.5em;
+}
+h1.title {
+}
+h2.title {
+  border-bottom: solid 2px black;
+}
+h3.title {
+  border-bottom: solid 2px black;
+}
+--></style>
+</head>
+<body>
+<div class='body'>
+<h1 align='right'><a name='REFERENCE'><img src="C.gif" align="right"
+hspace="10" width="100" height="100" alt="C"></a>Library
+Reference</h1>
+
+<h2 class="title">Contents</h2>
+<ul class="contents">
+<li><a href="#FUNCTIONS">Functions</a><ul class="code">
+<li><a href="#mxmlAdd" title="Add a node to a tree.">mxmlAdd</a></li>
+<li><a href="#mxmlDelete" title="Delete a node and all of its children.">mxmlDelete</a></li>
+<li><a href="#mxmlElementDeleteAttr" title="Delete an attribute.">mxmlElementDeleteAttr</a></li>
+<li><a href="#mxmlElementGetAttr" title="Get an attribute.">mxmlElementGetAttr</a></li>
+<li><a href="#mxmlElementSetAttr" title="Set an attribute.">mxmlElementSetAttr</a></li>
+<li><a href="#mxmlElementSetAttrf" title="Set an attribute with a formatted value.">mxmlElementSetAttrf</a></li>
+<li><a href="#mxmlEntityAddCallback" title="Add a callback to convert entities to Unicode.">mxmlEntityAddCallback</a></li>
+<li><a href="#mxmlEntityGetName" title="Get the name that corresponds to the character value.">mxmlEntityGetName</a></li>
+<li><a href="#mxmlEntityGetValue" title="Get the character corresponding to a named entity.">mxmlEntityGetValue</a></li>
+<li><a href="#mxmlEntityRemoveCallback" title="Remove a callback.">mxmlEntityRemoveCallback</a></li>
+<li><a href="#mxmlFindElement" title="Find the named element.">mxmlFindElement</a></li>
+<li><a href="#mxmlIndexDelete" title="Delete an index.">mxmlIndexDelete</a></li>
+<li><a href="#mxmlIndexEnum" title="Return the next node in the index.">mxmlIndexEnum</a></li>
+<li><a href="#mxmlIndexFind" title="Find the next matching node.">mxmlIndexFind</a></li>
+<li><a href="#mxmlIndexNew" title="Create a new index.">mxmlIndexNew</a></li>
+<li><a href="#mxmlIndexReset" title="Reset the enumeration/find pointer in the index and
+return the first node in the index.">mxmlIndexReset</a></li>
+<li><a href="#mxmlLoadFd" title="Load a file descriptor into an XML node tree.">mxmlLoadFd</a></li>
+<li><a href="#mxmlLoadFile" title="Load a file into an XML node tree.">mxmlLoadFile</a></li>
+<li><a href="#mxmlLoadString" title="Load a string into an XML node tree.">mxmlLoadString</a></li>
+<li><a href="#mxmlNewCDATA" title="Create a new CDATA node.">mxmlNewCDATA</a></li>
+<li><a href="#mxmlNewCustom" title="Create a new custom data node.">mxmlNewCustom</a></li>
+<li><a href="#mxmlNewElement" title="Create a new element node.">mxmlNewElement</a></li>
+<li><a href="#mxmlNewInteger" title="Create a new integer node.">mxmlNewInteger</a></li>
+<li><a href="#mxmlNewOpaque" title="Create a new opaque string.">mxmlNewOpaque</a></li>
+<li><a href="#mxmlNewReal" title="Create a new real number node.">mxmlNewReal</a></li>
+<li><a href="#mxmlNewText" title="Create a new text fragment node.">mxmlNewText</a></li>
+<li><a href="#mxmlNewTextf" title="Create a new formatted text fragment node.">mxmlNewTextf</a></li>
+<li><a href="#mxmlNewXML" title="Create a new XML document tree.">mxmlNewXML</a></li>
+<li><a href="#mxmlRelease" title="Release a node.">mxmlRelease</a></li>
+<li><a href="#mxmlRemove" title="Remove a node from its parent.">mxmlRemove</a></li>
+<li><a href="#mxmlRetain" title="Retain a node.">mxmlRetain</a></li>
+<li><a href="#mxmlSAXLoadFd" title="Load a file descriptor into an XML node tree
+using a SAX callback.">mxmlSAXLoadFd</a></li>
+<li><a href="#mxmlSAXLoadFile" title="Load a file into an XML node tree
+using a SAX callback.">mxmlSAXLoadFile</a></li>
+<li><a href="#mxmlSAXLoadString" title="Load a string into an XML node tree
+using a SAX callback.">mxmlSAXLoadString</a></li>
+<li><a href="#mxmlSaveAllocString" title="Save an XML node tree to an allocated string.">mxmlSaveAllocString</a></li>
+<li><a href="#mxmlSaveFd" title="Save an XML tree to a file descriptor.">mxmlSaveFd</a></li>
+<li><a href="#mxmlSaveFile" title="Save an XML tree to a file.">mxmlSaveFile</a></li>
+<li><a href="#mxmlSaveString" title="Save an XML node tree to a string.">mxmlSaveString</a></li>
+<li><a href="#mxmlSetCDATA" title="Set the element name of a CDATA node.">mxmlSetCDATA</a></li>
+<li><a href="#mxmlSetCustom" title="Set the data and destructor of a custom data node.">mxmlSetCustom</a></li>
+<li><a href="#mxmlSetCustomHandlers" title="Set the handling functions for custom data.">mxmlSetCustomHandlers</a></li>
+<li><a href="#mxmlSetElement" title="Set the name of an element node.">mxmlSetElement</a></li>
+<li><a href="#mxmlSetErrorCallback" title="Set the error message callback.">mxmlSetErrorCallback</a></li>
+<li><a href="#mxmlSetInteger" title="Set the value of an integer node.">mxmlSetInteger</a></li>
+<li><a href="#mxmlSetOpaque" title="Set the value of an opaque node.">mxmlSetOpaque</a></li>
+<li><a href="#mxmlSetReal" title="Set the value of a real number node.">mxmlSetReal</a></li>
+<li><a href="#mxmlSetText" title="Set the value of a text node.">mxmlSetText</a></li>
+<li><a href="#mxmlSetTextf" title="Set the value of a text node to a formatted string.">mxmlSetTextf</a></li>
+<li><a href="#mxmlSetWrapMargin" title="Set the the wrap margin when saving XML data.">mxmlSetWrapMargin</a></li>
+<li><a href="#mxmlWalkNext" title="Walk to the next logical node in the tree.">mxmlWalkNext</a></li>
+<li><a href="#mxmlWalkPrev" title="Walk to the previous logical node in the tree.">mxmlWalkPrev</a></li>
+</ul></li>
+<li><a href="#TYPES">Data Types</a><ul class="code">
+	<li><a href="#mxml_attr_t" title="An XML element attribute value.">mxml_attr_t</a></li>
+	<li><a href="#mxml_custom_destroy_cb_t" title="Custom data destructor">mxml_custom_destroy_cb_t</a></li>
+	<li><a href="#mxml_custom_load_cb_t" title="Custom data load callback function">mxml_custom_load_cb_t</a></li>
+	<li><a href="#mxml_custom_save_cb_t" title="Custom data save callback function">mxml_custom_save_cb_t</a></li>
+	<li><a href="#mxml_custom_t" title="An XML custom value. ">mxml_custom_t</a></li>
+	<li><a href="#mxml_element_t" title="An XML element value.">mxml_element_t</a></li>
+	<li><a href="#mxml_entity_cb_t" title="Entity callback function">mxml_entity_cb_t</a></li>
+	<li><a href="#mxml_error_cb_t" title="Error callback function">mxml_error_cb_t</a></li>
+	<li><a href="#mxml_index_t" title="An XML node index.">mxml_index_t</a></li>
+	<li><a href="#mxml_load_cb_t" title="Load callback function">mxml_load_cb_t</a></li>
+	<li><a href="#mxml_node_t" title="An XML node.">mxml_node_t</a></li>
+	<li><a href="#mxml_save_cb_t" title="Save callback function">mxml_save_cb_t</a></li>
+	<li><a href="#mxml_sax_cb_t" title="SAX callback function">mxml_sax_cb_t</a></li>
+	<li><a href="#mxml_sax_event_t" title="SAX event type.">mxml_sax_event_t</a></li>
+	<li><a href="#mxml_text_t" title="An XML text value.">mxml_text_t</a></li>
+	<li><a href="#mxml_type_t" title="The XML node type.">mxml_type_t</a></li>
+	<li><a href="#mxml_value_t" title="An XML node value.">mxml_value_t</a></li>
+</ul></li>
+<li><a href="#STRUCTURES">Structures</a><ul class="code">
+	<li><a href="#mxml_attr_s" title="An XML element attribute value.">mxml_attr_s</a></li>
+	<li><a href="#mxml_custom_s" title="An XML custom value. ">mxml_custom_s</a></li>
+	<li><a href="#mxml_element_s" title="An XML element value.">mxml_element_s</a></li>
+	<li><a href="#mxml_index_s" title="An XML node index.">mxml_index_s</a></li>
+	<li><a href="#mxml_node_s" title="An XML node.">mxml_node_s</a></li>
+	<li><a href="#mxml_text_s" title="An XML text value.">mxml_text_s</a></li>
+</ul></li>
+<li><a href="#UNIONS">Unions</a><ul class="code">
+	<li><a href="#mxml_value_u" title="An XML node value.">mxml_value_u</a></li>
+</ul></li>
+<li><a href="#ENUMERATIONS">Constants</a><ul class="code">
+	<li><a href="#mxml_sax_event_e" title="SAX event type.">mxml_sax_event_e</a></li>
+	<li><a href="#mxml_type_e" title="The XML node type.">mxml_type_e</a></li>
+</ul></li>
+<h2 class="title"><a name="FUNCTIONS">Functions</a></h2>
+<h3 class="function"><a name="mxmlAdd">mxmlAdd</a></h3>
+<p class="description">Add a node to a tree.</p>
+<p class="code">
+void mxmlAdd (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int where,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *child,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node</dd>
+<dt>where</dt>
+<dd class="description">Where to add, MXML_ADD_BEFORE or MXML_ADD_AFTER</dd>
+<dt>child</dt>
+<dd class="description">Child node for where or MXML_ADD_TO_PARENT</dd>
+<dt>node</dt>
+<dd class="description">Node to add</dd>
+</dl>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">Adds the specified node to the parent. If the child argument is not
+NULL, puts the new node before or after the specified child depending
+on the value of the where argument. If the child argument is NULL,
+puts the new node at the beginning of the child list (MXML_ADD_BEFORE)
+or at the end of the child list (MXML_ADD_AFTER). The constant
+MXML_ADD_TO_PARENT can be used to specify a NULL child pointer.</p>
+<h3 class="function"><a name="mxmlDelete">mxmlDelete</a></h3>
+<p class="description">Delete a node and all of its children.</p>
+<p class="code">
+void mxmlDelete (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to delete</dd>
+</dl>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">If the specified node has a parent, this function first removes the
+node from its parent using the mxmlRemove() function.</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.4&nbsp;</span><a name="mxmlElementDeleteAttr">mxmlElementDeleteAttr</a></h3>
+<p class="description">Delete an attribute.</p>
+<p class="code">
+void mxmlElementDeleteAttr (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Element</dd>
+<dt>name</dt>
+<dd class="description">Attribute name</dd>
+</dl>
+<h3 class="function"><a name="mxmlElementGetAttr">mxmlElementGetAttr</a></h3>
+<p class="description">Get an attribute.</p>
+<p class="code">
+const char *mxmlElementGetAttr (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Element node</dd>
+<dt>name</dt>
+<dd class="description">Name of attribute</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Attribute value or NULL</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">This function returns NULL if the node is not an element or the
+named attribute does not exist.</p>
+<h3 class="function"><a name="mxmlElementSetAttr">mxmlElementSetAttr</a></h3>
+<p class="description">Set an attribute.</p>
+<p class="code">
+void mxmlElementSetAttr (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *value<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Element node</dd>
+<dt>name</dt>
+<dd class="description">Name of attribute</dd>
+<dt>value</dt>
+<dd class="description">Attribute value</dd>
+</dl>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">If the named attribute already exists, the value of the attribute
+is replaced by the new string value. The string value is copied
+into the element node. This function does nothing if the node is
+not an element.</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlElementSetAttrf">mxmlElementSetAttrf</a></h3>
+<p class="description">Set an attribute with a formatted value.</p>
+<p class="code">
+void mxmlElementSetAttrf (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *format,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;...<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Element node</dd>
+<dt>name</dt>
+<dd class="description">Name of attribute</dd>
+<dt>format</dt>
+<dd class="description">Printf-style attribute value</dd>
+<dt>...</dt>
+<dd class="description">Additional arguments as needed</dd>
+</dl>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">If the named attribute already exists, the value of the attribute
+is replaced by the new formatted string. The formatted string value is
+copied into the element node. This function does nothing if the node
+is not an element.
+
+</p>
+<h3 class="function"><a name="mxmlEntityAddCallback">mxmlEntityAddCallback</a></h3>
+<p class="description">Add a callback to convert entities to Unicode.</p>
+<p class="code">
+int mxmlEntityAddCallback (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_entity_cb_t">mxml_entity_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>cb</dt>
+<dd class="description">Callback function to add</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h3 class="function"><a name="mxmlEntityGetName">mxmlEntityGetName</a></h3>
+<p class="description">Get the name that corresponds to the character value.</p>
+<p class="code">
+const char *mxmlEntityGetName (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int val<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>val</dt>
+<dd class="description">Character value</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Entity name or NULL</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">If val does not need to be represented by a named entity, NULL is returned.</p>
+<h3 class="function"><a name="mxmlEntityGetValue">mxmlEntityGetValue</a></h3>
+<p class="description">Get the character corresponding to a named entity.</p>
+<p class="code">
+int mxmlEntityGetValue (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>name</dt>
+<dd class="description">Entity name</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Character value or -1 on error</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The entity name can also be a numeric constant. -1 is returned if the
+name is not known.</p>
+<h3 class="function"><a name="mxmlEntityRemoveCallback">mxmlEntityRemoveCallback</a></h3>
+<p class="description">Remove a callback.</p>
+<p class="code">
+void mxmlEntityRemoveCallback (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_entity_cb_t">mxml_entity_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>cb</dt>
+<dd class="description">Callback function to remove</dd>
+</dl>
+<h3 class="function"><a name="mxmlFindElement">mxmlFindElement</a></h3>
+<p class="description">Find the named element.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlFindElement (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *attr,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *value,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int descend<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Current node</dd>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>name</dt>
+<dd class="description">Element name or NULL for any</dd>
+<dt>attr</dt>
+<dd class="description">Attribute name, or NULL for none</dd>
+<dt>value</dt>
+<dd class="description">Attribute value, or NULL for any</dd>
+<dt>descend</dt>
+<dd class="description">Descend into tree - MXML_DESCEND, MXML_NO_DESCEND, or MXML_DESCEND_FIRST</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Element node or NULL</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The search is constrained by the name, attribute name, and value; any
+NULL names or values are treated as wildcards, so different kinds of
+searches can be implemented by looking for all elements of a given name
+or all elements with a specific attribute. The descend argument determines
+whether the search descends into child nodes; normally you will use
+MXML_DESCEND_FIRST for the initial search and MXML_NO_DESCEND to find
+additional direct descendents of the node. The top node argument
+constrains the search to a particular node's children.</p>
+<h3 class="function"><a name="mxmlIndexDelete">mxmlIndexDelete</a></h3>
+<p class="description">Delete an index.</p>
+<p class="code">
+void mxmlIndexDelete (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_index_t">mxml_index_t</a> *ind<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>ind</dt>
+<dd class="description">Index to delete</dd>
+</dl>
+<h3 class="function"><a name="mxmlIndexEnum">mxmlIndexEnum</a></h3>
+<p class="description">Return the next node in the index.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexEnum (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_index_t">mxml_index_t</a> *ind<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>ind</dt>
+<dd class="description">Index to enumerate</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Next node or NULL if there is none</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">Nodes are returned in the sorted order of the index.</p>
+<h3 class="function"><a name="mxmlIndexFind">mxmlIndexFind</a></h3>
+<p class="description">Find the next matching node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexFind (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_index_t">mxml_index_t</a> *ind,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *element,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *value<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>ind</dt>
+<dd class="description">Index to search</dd>
+<dt>element</dt>
+<dd class="description">Element name to find, if any</dd>
+<dt>value</dt>
+<dd class="description">Attribute value, if any</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Node or NULL if none found</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">You should call mxmlIndexReset() prior to using this function for
+the first time with a particular set of &quot;element&quot; and &quot;value&quot;
+strings. Passing NULL for both &quot;element&quot; and &quot;value&quot; is equivalent
+to calling mxmlIndexEnum().</p>
+<h3 class="function"><a name="mxmlIndexNew">mxmlIndexNew</a></h3>
+<p class="description">Create a new index.</p>
+<p class="code">
+<a href="#mxml_index_t">mxml_index_t</a> *mxmlIndexNew (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *element,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *attr<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">XML node tree</dd>
+<dt>element</dt>
+<dd class="description">Element to index or NULL for all</dd>
+<dt>attr</dt>
+<dd class="description">Attribute to index or NULL for none</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New index</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The index will contain all nodes that contain the named element and/or
+attribute. If both &quot;element&quot; and &quot;attr&quot; are NULL, then the index will
+contain a sorted list of the elements in the node tree.  Nodes are
+sorted by element name and optionally by attribute value if the &quot;attr&quot;
+argument is not NULL.</p>
+<h3 class="function"><a name="mxmlIndexReset">mxmlIndexReset</a></h3>
+<p class="description">Reset the enumeration/find pointer in the index and
+return the first node in the index.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexReset (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_index_t">mxml_index_t</a> *ind<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>ind</dt>
+<dd class="description">Index to reset</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">First node or NULL if there is none</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">This function should be called prior to using mxmlIndexEnum() or
+mxmlIndexFind() for the first time.</p>
+<h3 class="function"><a name="mxmlLoadFd">mxmlLoadFd</a></h3>
+<p class="description">Load a file descriptor into an XML node tree.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadFd (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int fd,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>fd</dt>
+<dd class="description">File descriptor to read from</dd>
+<dt>cb</dt>
+<dd class="description">Callback function or MXML_NO_CALLBACK</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">First node or NULL if the file could not be read.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The nodes in the specified file are added to the specified top node.
+If no top node is provided, the XML file MUST be well-formed with a
+single parent node like &lt;?xml&gt; for the entire file. The callback
+function returns the value type that should be used for child nodes.
+If MXML_NO_CALLBACK is specified then all child nodes will be either
+MXML_ELEMENT or MXML_TEXT nodes.<br>
+<br>
+The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+child nodes of the specified type.</p>
+<h3 class="function"><a name="mxmlLoadFile">mxmlLoadFile</a></h3>
+<p class="description">Load a file into an XML node tree.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadFile (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;FILE *fp,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>fp</dt>
+<dd class="description">File to read from</dd>
+<dt>cb</dt>
+<dd class="description">Callback function or MXML_NO_CALLBACK</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">First node or NULL if the file could not be read.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The nodes in the specified file are added to the specified top node.
+If no top node is provided, the XML file MUST be well-formed with a
+single parent node like &lt;?xml&gt; for the entire file. The callback
+function returns the value type that should be used for child nodes.
+If MXML_NO_CALLBACK is specified then all child nodes will be either
+MXML_ELEMENT or MXML_TEXT nodes.<br>
+<br>
+The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+child nodes of the specified type.</p>
+<h3 class="function"><a name="mxmlLoadString">mxmlLoadString</a></h3>
+<p class="description">Load a string into an XML node tree.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadString (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *s,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>s</dt>
+<dd class="description">String to load</dd>
+<dt>cb</dt>
+<dd class="description">Callback function or MXML_NO_CALLBACK</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">First node or NULL if the string has errors.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The nodes in the specified string are added to the specified top node.
+If no top node is provided, the XML string MUST be well-formed with a
+single parent node like &lt;?xml&gt; for the entire string. The callback
+function returns the value type that should be used for child nodes.
+If MXML_NO_CALLBACK is specified then all child nodes will be either
+MXML_ELEMENT or MXML_TEXT nodes.<br>
+<br>
+The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+child nodes of the specified type.</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlNewCDATA">mxmlNewCDATA</a></h3>
+<p class="description">Create a new CDATA node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCDATA (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *data<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>data</dt>
+<dd class="description">Data string</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new CDATA node is added to the end of the specified parent's child
+list. The constant MXML_NO_PARENT can be used to specify that the new
+CDATA node has no parent. The data string must be nul-terminated and
+is copied into the new node. CDATA nodes use the MXML_ELEMENT type.
+
+</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.1&nbsp;</span><a name="mxmlNewCustom">mxmlNewCustom</a></h3>
+<p class="description">Create a new custom data node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCustom (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;void *data,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a> destroy<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>data</dt>
+<dd class="description">Pointer to data</dd>
+<dt>destroy</dt>
+<dd class="description">Function to destroy data</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new custom node is added to the end of the specified parent's child
+list. The constant MXML_NO_PARENT can be used to specify that the new
+element node has no parent. NULL can be passed when the data in the
+node is not dynamically allocated or is separately managed.
+
+</p>
+<h3 class="function"><a name="mxmlNewElement">mxmlNewElement</a></h3>
+<p class="description">Create a new element node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewElement (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>name</dt>
+<dd class="description">Name of element</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new element node is added to the end of the specified parent's child
+list. The constant MXML_NO_PARENT can be used to specify that the new
+element node has no parent.</p>
+<h3 class="function"><a name="mxmlNewInteger">mxmlNewInteger</a></h3>
+<p class="description">Create a new integer node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewInteger (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int integer<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>integer</dt>
+<dd class="description">Integer value</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new integer node is added to the end of the specified parent's child
+list. The constant MXML_NO_PARENT can be used to specify that the new
+integer node has no parent.</p>
+<h3 class="function"><a name="mxmlNewOpaque">mxmlNewOpaque</a></h3>
+<p class="description">Create a new opaque string.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewOpaque (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *opaque<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>opaque</dt>
+<dd class="description">Opaque string</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new opaque node is added to the end of the specified parent's child
+list. The constant MXML_NO_PARENT can be used to specify that the new
+opaque node has no parent. The opaque string must be nul-terminated and
+is copied into the new node.</p>
+<h3 class="function"><a name="mxmlNewReal">mxmlNewReal</a></h3>
+<p class="description">Create a new real number node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewReal (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;double real<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>real</dt>
+<dd class="description">Real number value</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new real number node is added to the end of the specified parent's
+child list. The constant MXML_NO_PARENT can be used to specify that
+the new real number node has no parent.</p>
+<h3 class="function"><a name="mxmlNewText">mxmlNewText</a></h3>
+<p class="description">Create a new text fragment node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewText (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int whitespace,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *string<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>whitespace</dt>
+<dd class="description">1 = leading whitespace, 0 = no whitespace</dd>
+<dt>string</dt>
+<dd class="description">String</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new text node is added to the end of the specified parent's child
+list. The constant MXML_NO_PARENT can be used to specify that the new
+text node has no parent. The whitespace parameter is used to specify
+whether leading whitespace is present before the node. The text
+string must be nul-terminated and is copied into the new node.</p>
+<h3 class="function"><a name="mxmlNewTextf">mxmlNewTextf</a></h3>
+<p class="description">Create a new formatted text fragment node.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewTextf (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *parent,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int whitespace,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *format,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;...<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>parent</dt>
+<dd class="description">Parent node or MXML_NO_PARENT</dd>
+<dt>whitespace</dt>
+<dd class="description">1 = leading whitespace, 0 = no whitespace</dd>
+<dt>format</dt>
+<dd class="description">Printf-style frmat string</dd>
+<dt>...</dt>
+<dd class="description">Additional args as needed</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The new text node is added to the end of the specified parent's child
+list. The constant MXML_NO_PARENT can be used to specify that the new
+text node has no parent. The whitespace parameter is used to specify
+whether leading whitespace is present before the node. The format
+string must be nul-terminated and is formatted into the new node.</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlNewXML">mxmlNewXML</a></h3>
+<p class="description">Create a new XML document tree.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewXML (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *version<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>version</dt>
+<dd class="description">Version number to use</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New ?xml node</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The &quot;version&quot; argument specifies the version number to put in the
+?xml element node. If NULL, version 1.0 is assumed.
+
+</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlRelease">mxmlRelease</a></h3>
+<p class="description">Release a node.</p>
+<p class="code">
+int mxmlRelease (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New reference count</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">When the reference count reaches zero, the node (and any children)
+is deleted via mxmlDelete().
+
+</p>
+<h3 class="function"><a name="mxmlRemove">mxmlRemove</a></h3>
+<p class="description">Remove a node from its parent.</p>
+<p class="code">
+void mxmlRemove (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to remove</dd>
+</dl>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">Does not free memory used by the node - use mxmlDelete() for that.
+This function does nothing if the node has no parent.</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlRetain">mxmlRetain</a></h3>
+<p class="description">Retain a node.</p>
+<p class="code">
+int mxmlRetain (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">New reference count</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlSAXLoadFd">mxmlSAXLoadFd</a></h3>
+<p class="description">Load a file descriptor into an XML node tree
+using a SAX callback.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlSAXLoadFd (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int fd,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_sax_cb_t">mxml_sax_cb_t</a> sax_cb,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;void *sax_data<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>fd</dt>
+<dd class="description">File descriptor to read from</dd>
+<dt>cb</dt>
+<dd class="description">Callback function or MXML_NO_CALLBACK</dd>
+<dt>sax_cb</dt>
+<dd class="description">SAX callback or MXML_NO_CALLBACK</dd>
+<dt>sax_data</dt>
+<dd class="description">SAX user data</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">First node or NULL if the file could not be read.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The nodes in the specified file are added to the specified top node.
+If no top node is provided, the XML file MUST be well-formed with a
+single parent node like &lt;?xml&gt; for the entire file. The callback
+function returns the value type that should be used for child nodes.
+If MXML_NO_CALLBACK is specified then all child nodes will be either
+MXML_ELEMENT or MXML_TEXT nodes.<br>
+<br>
+The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+child nodes of the specified type.<br>
+<br>
+The SAX callback must call mxmlRetain() for any nodes that need to
+be kept for later use. Otherwise, nodes are deleted when the parent
+node is closed or after each data, comment, CDATA, or directive node.
+
+</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlSAXLoadFile">mxmlSAXLoadFile</a></h3>
+<p class="description">Load a file into an XML node tree
+using a SAX callback.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlSAXLoadFile (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;FILE *fp,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_sax_cb_t">mxml_sax_cb_t</a> sax_cb,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;void *sax_data<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>fp</dt>
+<dd class="description">File to read from</dd>
+<dt>cb</dt>
+<dd class="description">Callback function or MXML_NO_CALLBACK</dd>
+<dt>sax_cb</dt>
+<dd class="description">SAX callback or MXML_NO_CALLBACK</dd>
+<dt>sax_data</dt>
+<dd class="description">SAX user data</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">First node or NULL if the file could not be read.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The nodes in the specified file are added to the specified top node.
+If no top node is provided, the XML file MUST be well-formed with a
+single parent node like &lt;?xml&gt; for the entire file. The callback
+function returns the value type that should be used for child nodes.
+If MXML_NO_CALLBACK is specified then all child nodes will be either
+MXML_ELEMENT or MXML_TEXT nodes.<br>
+<br>
+The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+child nodes of the specified type.<br>
+<br>
+The SAX callback must call mxmlRetain() for any nodes that need to
+be kept for later use. Otherwise, nodes are deleted when the parent
+node is closed or after each data, comment, CDATA, or directive node.
+
+</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlSAXLoadString">mxmlSAXLoadString</a></h3>
+<p class="description">Load a string into an XML node tree
+using a SAX callback.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlSAXLoadString (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *s,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_sax_cb_t">mxml_sax_cb_t</a> sax_cb,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;void *sax_data<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>s</dt>
+<dd class="description">String to load</dd>
+<dt>cb</dt>
+<dd class="description">Callback function or MXML_NO_CALLBACK</dd>
+<dt>sax_cb</dt>
+<dd class="description">SAX callback or MXML_NO_CALLBACK</dd>
+<dt>sax_data</dt>
+<dd class="description">SAX user data</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">First node or NULL if the string has errors.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The nodes in the specified string are added to the specified top node.
+If no top node is provided, the XML string MUST be well-formed with a
+single parent node like &lt;?xml&gt; for the entire string. The callback
+function returns the value type that should be used for child nodes.
+If MXML_NO_CALLBACK is specified then all child nodes will be either
+MXML_ELEMENT or MXML_TEXT nodes.<br>
+<br>
+The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+child nodes of the specified type.<br>
+<br>
+The SAX callback must call mxmlRetain() for any nodes that need to
+be kept for later use. Otherwise, nodes are deleted when the parent
+node is closed or after each data, comment, CDATA, or directive node.
+
+</p>
+<h3 class="function"><a name="mxmlSaveAllocString">mxmlSaveAllocString</a></h3>
+<p class="description">Save an XML node tree to an allocated string.</p>
+<p class="code">
+char *mxmlSaveAllocString (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to write</dd>
+<dt>cb</dt>
+<dd class="description">Whitespace callback or MXML_NO_CALLBACK</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Allocated string or NULL</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">This function returns a pointer to a string containing the textual
+representation of the XML node tree.  The string should be freed
+using the free() function when you are done with it.  NULL is returned
+if the node would produce an empty string or if the string cannot be
+allocated.<br>
+<br>
+The callback argument specifies a function that returns a whitespace
+string or NULL before and after each element. If MXML_NO_CALLBACK
+is specified, whitespace will only be added before MXML_TEXT nodes
+with leading whitespace and before attribute names inside opening
+element tags.</p>
+<h3 class="function"><a name="mxmlSaveFd">mxmlSaveFd</a></h3>
+<p class="description">Save an XML tree to a file descriptor.</p>
+<p class="code">
+int mxmlSaveFd (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int fd,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to write</dd>
+<dt>fd</dt>
+<dd class="description">File descriptor to write to</dd>
+<dt>cb</dt>
+<dd class="description">Whitespace callback or MXML_NO_CALLBACK</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on error.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The callback argument specifies a function that returns a whitespace
+string or NULL before and after each element. If MXML_NO_CALLBACK
+is specified, whitespace will only be added before MXML_TEXT nodes
+with leading whitespace and before attribute names inside opening
+element tags.</p>
+<h3 class="function"><a name="mxmlSaveFile">mxmlSaveFile</a></h3>
+<p class="description">Save an XML tree to a file.</p>
+<p class="code">
+int mxmlSaveFile (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;FILE *fp,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to write</dd>
+<dt>fp</dt>
+<dd class="description">File to write to</dd>
+<dt>cb</dt>
+<dd class="description">Whitespace callback or MXML_NO_CALLBACK</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on error.</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The callback argument specifies a function that returns a whitespace
+string or NULL before and after each element. If MXML_NO_CALLBACK
+is specified, whitespace will only be added before MXML_TEXT nodes
+with leading whitespace and before attribute names inside opening
+element tags.</p>
+<h3 class="function"><a name="mxmlSaveString">mxmlSaveString</a></h3>
+<p class="description">Save an XML node tree to a string.</p>
+<p class="code">
+int mxmlSaveString (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;char *buffer,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int bufsize,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to write</dd>
+<dt>buffer</dt>
+<dd class="description">String buffer</dd>
+<dt>bufsize</dt>
+<dd class="description">Size of string buffer</dd>
+<dt>cb</dt>
+<dd class="description">Whitespace callback or MXML_NO_CALLBACK</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Size of string</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">This function returns the total number of bytes that would be
+required for the string but only copies (bufsize - 1) characters
+into the specified buffer.<br>
+<br>
+The callback argument specifies a function that returns a whitespace
+string or NULL before and after each element. If MXML_NO_CALLBACK
+is specified, whitespace will only be added before MXML_TEXT nodes
+with leading whitespace and before attribute names inside opening
+element tags.</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlSetCDATA">mxmlSetCDATA</a></h3>
+<p class="description">Set the element name of a CDATA node.</p>
+<p class="code">
+int mxmlSetCDATA (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *data<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>data</dt>
+<dd class="description">New data string</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not a CDATA element node.
+
+</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.1&nbsp;</span><a name="mxmlSetCustom">mxmlSetCustom</a></h3>
+<p class="description">Set the data and destructor of a custom data node.</p>
+<p class="code">
+int mxmlSetCustom (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;void *data,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a> destroy<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>data</dt>
+<dd class="description">New data pointer</dd>
+<dt>destroy</dt>
+<dd class="description">New destructor function</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not a custom node.
+
+</p>
+<h3 class="function"><a name="mxmlSetCustomHandlers">mxmlSetCustomHandlers</a></h3>
+<p class="description">Set the handling functions for custom data.</p>
+<p class="code">
+void mxmlSetCustomHandlers (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_custom_load_cb_t">mxml_custom_load_cb_t</a> load,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_custom_save_cb_t">mxml_custom_save_cb_t</a> save<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>load</dt>
+<dd class="description">Load function</dd>
+<dt>save</dt>
+<dd class="description">Save function</dd>
+</dl>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The load function accepts a node pointer and a data string and must
+return 0 on success and non-zero on error.<br>
+<br>
+The save function accepts a node pointer and must return a malloc'd
+string on success and NULL on error.</p>
+<h3 class="function"><a name="mxmlSetElement">mxmlSetElement</a></h3>
+<p class="description">Set the name of an element node.</p>
+<p class="code">
+int mxmlSetElement (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *name<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>name</dt>
+<dd class="description">New name string</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not an element node.</p>
+<h3 class="function"><a name="mxmlSetErrorCallback">mxmlSetErrorCallback</a></h3>
+<p class="description">Set the error message callback.</p>
+<p class="code">
+void mxmlSetErrorCallback (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_error_cb_t">mxml_error_cb_t</a> cb<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>cb</dt>
+<dd class="description">Error callback function</dd>
+</dl>
+<h3 class="function"><a name="mxmlSetInteger">mxmlSetInteger</a></h3>
+<p class="description">Set the value of an integer node.</p>
+<p class="code">
+int mxmlSetInteger (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int integer<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>integer</dt>
+<dd class="description">Integer value</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not an integer node.</p>
+<h3 class="function"><a name="mxmlSetOpaque">mxmlSetOpaque</a></h3>
+<p class="description">Set the value of an opaque node.</p>
+<p class="code">
+int mxmlSetOpaque (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *opaque<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>opaque</dt>
+<dd class="description">Opaque string</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not an opaque node.</p>
+<h3 class="function"><a name="mxmlSetReal">mxmlSetReal</a></h3>
+<p class="description">Set the value of a real number node.</p>
+<p class="code">
+int mxmlSetReal (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;double real<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>real</dt>
+<dd class="description">Real number value</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not a real number node.</p>
+<h3 class="function"><a name="mxmlSetText">mxmlSetText</a></h3>
+<p class="description">Set the value of a text node.</p>
+<p class="code">
+int mxmlSetText (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int whitespace,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *string<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>whitespace</dt>
+<dd class="description">1 = leading whitespace, 0 = no whitespace</dd>
+<dt>string</dt>
+<dd class="description">String</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not a text node.</p>
+<h3 class="function"><a name="mxmlSetTextf">mxmlSetTextf</a></h3>
+<p class="description">Set the value of a text node to a formatted string.</p>
+<p class="code">
+int mxmlSetTextf (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int whitespace,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;const char *format,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;...<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Node to set</dd>
+<dt>whitespace</dt>
+<dd class="description">1 = leading whitespace, 0 = no whitespace</dd>
+<dt>format</dt>
+<dd class="description">Printf-style format string</dd>
+<dt>...</dt>
+<dd class="description">Additional arguments as needed</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">0 on success, -1 on failure</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The node is not changed if it is not a text node.</p>
+<h3 class="function"><span class="info">&nbsp;Mini-XML 2.3&nbsp;</span><a name="mxmlSetWrapMargin">mxmlSetWrapMargin</a></h3>
+<p class="description">Set the the wrap margin when saving XML data.</p>
+<p class="code">
+void mxmlSetWrapMargin (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int column<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>column</dt>
+<dd class="description">Column for wrapping, 0 to disable wrapping</dd>
+</dl>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">Wrapping is disabled when &quot;column&quot; is 0.
+
+</p>
+<h3 class="function"><a name="mxmlWalkNext">mxmlWalkNext</a></h3>
+<p class="description">Walk to the next logical node in the tree.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlWalkNext (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int descend<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Current node</dd>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>descend</dt>
+<dd class="description">Descend into tree - MXML_DESCEND, MXML_NO_DESCEND, or MXML_DESCEND_FIRST</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Next node or NULL</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The descend argument controls whether the first child is considered
+to be the next node. The top node argument constrains the walk to
+the node's children.</p>
+<h3 class="function"><a name="mxmlWalkPrev">mxmlWalkPrev</a></h3>
+<p class="description">Walk to the previous logical node in the tree.</p>
+<p class="code">
+<a href="#mxml_node_t">mxml_node_t</a> *mxmlWalkPrev (<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *node,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> *top,<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int descend<br>
+);</p>
+<h4 class="parameters">Parameters</h4>
+<dl>
+<dt>node</dt>
+<dd class="description">Current node</dd>
+<dt>top</dt>
+<dd class="description">Top node</dd>
+<dt>descend</dt>
+<dd class="description">Descend into tree - MXML_DESCEND, MXML_NO_DESCEND, or MXML_DESCEND_FIRST</dd>
+</dl>
+<h4 class="returnvalue">Return Value</h4>
+<p class="description">Previous node or NULL</p>
+<h4 class="discussion">Discussion</h4>
+<p class="discussion">The descend argument controls whether the previous node's last child
+is considered to be the previous node. The top node argument constrains
+the walk to the node's children.</p>
+<h2 class="title"><a name="TYPES">Data Types</a></h2>
+<h3 class="typedef"><a name="mxml_attr_t">mxml_attr_t</a></h3>
+<p class="description">An XML element attribute value.</p>
+<p class="code">
+typedef struct <a href="#mxml_attr_s">mxml_attr_s</a> mxml_attr_t;
+</p>
+<h3 class="typedef"><a name="mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a></h3>
+<p class="description">Custom data destructor</p>
+<p class="code">
+typedef void (*mxml_custom_destroy_cb_t)(void *);
+</p>
+<h3 class="typedef"><a name="mxml_custom_load_cb_t">mxml_custom_load_cb_t</a></h3>
+<p class="description">Custom data load callback function</p>
+<p class="code">
+typedef int (*mxml_custom_load_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *, const char *);
+</p>
+<h3 class="typedef"><a name="mxml_custom_save_cb_t">mxml_custom_save_cb_t</a></h3>
+<p class="description">Custom data save callback function</p>
+<p class="code">
+typedef char *(*mxml_custom_save_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *);
+</p>
+<h3 class="typedef"><span class="info">&nbsp;Mini-XML 2.1&nbsp;</span><a name="mxml_custom_t">mxml_custom_t</a></h3>
+<p class="description">An XML custom value. </p>
+<p class="code">
+typedef struct <a href="#mxml_custom_s">mxml_custom_s</a> mxml_custom_t;
+</p>
+<h3 class="typedef"><a name="mxml_element_t">mxml_element_t</a></h3>
+<p class="description">An XML element value.</p>
+<p class="code">
+typedef struct <a href="#mxml_element_s">mxml_element_s</a> mxml_element_t;
+</p>
+<h3 class="typedef"><a name="mxml_entity_cb_t">mxml_entity_cb_t</a></h3>
+<p class="description">Entity callback function</p>
+<p class="code">
+typedef int (*mxml_entity_cb_t)(const char *);
+</p>
+<h3 class="typedef"><a name="mxml_error_cb_t">mxml_error_cb_t</a></h3>
+<p class="description">Error callback function</p>
+<p class="code">
+typedef void (*mxml_error_cb_t)(const char *);
+</p>
+<h3 class="typedef"><a name="mxml_index_t">mxml_index_t</a></h3>
+<p class="description">An XML node index.</p>
+<p class="code">
+typedef struct <a href="#mxml_index_s">mxml_index_s</a> mxml_index_t;
+</p>
+<h3 class="typedef"><a name="mxml_load_cb_t">mxml_load_cb_t</a></h3>
+<p class="description">Load callback function</p>
+<p class="code">
+typedef <a href="#mxml_type_t">mxml_type_t</a> (*mxml_load_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *);
+</p>
+<h3 class="typedef"><a name="mxml_node_t">mxml_node_t</a></h3>
+<p class="description">An XML node.</p>
+<p class="code">
+typedef struct <a href="#mxml_node_s">mxml_node_s</a> mxml_node_t;
+</p>
+<h3 class="typedef"><a name="mxml_save_cb_t">mxml_save_cb_t</a></h3>
+<p class="description">Save callback function</p>
+<p class="code">
+typedef const char *(*mxml_save_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *, int);
+</p>
+<h3 class="typedef"><a name="mxml_sax_cb_t">mxml_sax_cb_t</a></h3>
+<p class="description">SAX callback function</p>
+<p class="code">
+typedef void (*mxml_sax_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *, mxml_sax_event_t, void *);
+</p>
+<h3 class="typedef"><a name="mxml_sax_event_t">mxml_sax_event_t</a></h3>
+<p class="description">SAX event type.</p>
+<p class="code">
+typedef enum <a href="#mxml_sax_event_e">mxml_sax_event_e</a> mxml_sax_event_t;
+</p>
+<h3 class="typedef"><a name="mxml_text_t">mxml_text_t</a></h3>
+<p class="description">An XML text value.</p>
+<p class="code">
+typedef struct <a href="#mxml_text_s">mxml_text_s</a> mxml_text_t;
+</p>
+<h3 class="typedef"><a name="mxml_type_t">mxml_type_t</a></h3>
+<p class="description">The XML node type.</p>
+<p class="code">
+typedef enum <a href="#mxml_type_e">mxml_type_e</a> mxml_type_t;
+</p>
+<h3 class="typedef"><a name="mxml_value_t">mxml_value_t</a></h3>
+<p class="description">An XML node value.</p>
+<p class="code">
+typedef union <a href="#mxml_value_u">mxml_value_u</a> mxml_value_t;
+</p>
+<h2 class="title"><a name="STRUCTURES">Structures</a></h2>
+<h3 class="struct"><a name="mxml_attr_s">mxml_attr_s</a></h3>
+<p class="description">An XML element attribute value.</p>
+<p class="code">struct mxml_attr_s {<br>
+&nbsp;&nbsp;&nbsp;&nbsp;char *name;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;char *value;<br>
+};</p>
+<h4 class="members">Members</h4>
+<dl>
+<dt>name </dt>
+<dd class="description">Attribute name</dd>
+<dt>value </dt>
+<dd class="description">Attribute value</dd>
+</dl>
+<h3 class="struct"><span class="info">&nbsp;Mini-XML 2.1&nbsp;</span><a name="mxml_custom_s">mxml_custom_s</a></h3>
+<p class="description">An XML custom value. </p>
+<p class="code">struct mxml_custom_s {<br>
+&nbsp;&nbsp;&nbsp;&nbsp;void *data;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a> destroy;<br>
+};</p>
+<h4 class="members">Members</h4>
+<dl>
+<dt>data </dt>
+<dd class="description">Pointer to (allocated) custom data</dd>
+<dt>destroy </dt>
+<dd class="description">Pointer to destructor function</dd>
+</dl>
+<h3 class="struct"><a name="mxml_element_s">mxml_element_s</a></h3>
+<p class="description">An XML element value.</p>
+<p class="code">struct mxml_element_s {<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_attr_t">mxml_attr_t</a> *attrs;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;char *name;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int num_attrs;<br>
+};</p>
+<h4 class="members">Members</h4>
+<dl>
+<dt>attrs </dt>
+<dd class="description">Attributes</dd>
+<dt>name </dt>
+<dd class="description">Name of element</dd>
+<dt>num_attrs </dt>
+<dd class="description">Number of attributes</dd>
+</dl>
+<h3 class="struct"><a name="mxml_index_s">mxml_index_s</a></h3>
+<p class="description">An XML node index.</p>
+<p class="code">struct mxml_index_s {<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int alloc_nodes;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;char *attr;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int cur_node;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_node_t">mxml_node_t</a> **nodes;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int num_nodes;<br>
+};</p>
+<h4 class="members">Members</h4>
+<dl>
+<dt>alloc_nodes </dt>
+<dd class="description">Allocated nodes in index</dd>
+<dt>attr </dt>
+<dd class="description">Attribute used for indexing or NULL</dd>
+<dt>cur_node </dt>
+<dd class="description">Current node</dd>
+<dt>nodes </dt>
+<dd class="description">Node array</dd>
+<dt>num_nodes </dt>
+<dd class="description">Number of nodes in index</dd>
+</dl>
+<h3 class="struct"><a name="mxml_node_s">mxml_node_s</a></h3>
+<p class="description">An XML node.</p>
+<p class="code">struct mxml_node_s {<br>
+&nbsp;&nbsp;&nbsp;&nbsp;struct <a href="#mxml_node_s">mxml_node_s</a> *child;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;struct <a href="#mxml_node_s">mxml_node_s</a> *last_child;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;struct <a href="#mxml_node_s">mxml_node_s</a> *next;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;struct <a href="#mxml_node_s">mxml_node_s</a> *parent;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;struct <a href="#mxml_node_s">mxml_node_s</a> *prev;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int ref_count;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_type_t">mxml_type_t</a> type;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;void *user_data;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_value_t">mxml_value_t</a> value;<br>
+};</p>
+<h4 class="members">Members</h4>
+<dl>
+<dt>child </dt>
+<dd class="description">First child node</dd>
+<dt>last_child </dt>
+<dd class="description">Last child node</dd>
+<dt>next </dt>
+<dd class="description">Next node under same parent</dd>
+<dt>parent </dt>
+<dd class="description">Parent node</dd>
+<dt>prev </dt>
+<dd class="description">Previous node under same parent</dd>
+<dt>ref_count </dt>
+<dd class="description">Use count</dd>
+<dt>type </dt>
+<dd class="description">Node type</dd>
+<dt>user_data </dt>
+<dd class="description">User data</dd>
+<dt>value </dt>
+<dd class="description">Node value</dd>
+</dl>
+<h3 class="struct"><a name="mxml_text_s">mxml_text_s</a></h3>
+<p class="description">An XML text value.</p>
+<p class="code">struct mxml_text_s {<br>
+&nbsp;&nbsp;&nbsp;&nbsp;char *string;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int whitespace;<br>
+};</p>
+<h4 class="members">Members</h4>
+<dl>
+<dt>string </dt>
+<dd class="description">Fragment string</dd>
+<dt>whitespace </dt>
+<dd class="description">Leading whitespace?</dd>
+</dl>
+<h2 class="title"><a name="UNIONS">Unions</a></h2>
+<h3 class="union"><a name="mxml_value_u">mxml_value_u</a></h3>
+<p class="description">An XML node value.</p>
+<p class="code">union mxml_value_u {<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_custom_t">mxml_custom_t</a> custom;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_element_t">mxml_element_t</a> element;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;int integer;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;char *opaque;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;double real;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mxml_text_t">mxml_text_t</a> text;<br>
+};</p>
+<h4 class="members">Members</h4>
+<dl>
+<dt>custom <span class="info">&nbsp;Mini-XML 2.1&nbsp;</span></dt>
+<dd class="description">Custom data </dd>
+<dt>element </dt>
+<dd class="description">Element</dd>
+<dt>integer </dt>
+<dd class="description">Integer number</dd>
+<dt>opaque </dt>
+<dd class="description">Opaque string</dd>
+<dt>real </dt>
+<dd class="description">Real number</dd>
+<dt>text </dt>
+<dd class="description">Text fragment</dd>
+</dl>
+<h2 class="title"><a name="ENUMERATIONS">Constants</a></h2>
+<h3 class="enumeration"><a name="mxml_sax_event_e">mxml_sax_event_e</a></h3>
+<p class="description">SAX event type.</p>
+<h4 class="constants">Constants</h4>
+<dl>
+<dt>MXML_SAX_CDATA </dt>
+<dd class="description">CDATA node</dd>
+<dt>MXML_SAX_COMMENT </dt>
+<dd class="description">Comment node</dd>
+<dt>MXML_SAX_DATA </dt>
+<dd class="description">Data node</dd>
+<dt>MXML_SAX_DIRECTIVE </dt>
+<dd class="description">Processing directive node</dd>
+<dt>MXML_SAX_ELEMENT_CLOSE </dt>
+<dd class="description">Element closed</dd>
+<dt>MXML_SAX_ELEMENT_OPEN </dt>
+<dd class="description">Element opened</dd>
+</dl>
+<h3 class="enumeration"><a name="mxml_type_e">mxml_type_e</a></h3>
+<p class="description">The XML node type.</p>
+<h4 class="constants">Constants</h4>
+<dl>
+<dt>MXML_CUSTOM <span class="info">&nbsp;Mini-XML 2.1&nbsp;</span></dt>
+<dd class="description">Custom data </dd>
+<dt>MXML_ELEMENT </dt>
+<dd class="description">XML element with attributes</dd>
+<dt>MXML_IGNORE <span class="info">&nbsp;Mini-XML 2.3&nbsp;</span></dt>
+<dd class="description">Ignore/throw away node </dd>
+<dt>MXML_INTEGER </dt>
+<dd class="description">Integer value</dd>
+<dt>MXML_OPAQUE </dt>
+<dd class="description">Opaque string</dd>
+<dt>MXML_REAL </dt>
+<dd class="description">Real value</dd>
+<dt>MXML_TEXT </dt>
+<dd class="description">Text fragment</dd>
+</dl>
+</div>
+</body>
+</html>
diff -Naur mxml-2.6/doc/relnotes.html mxml-2.6-haiku/doc/relnotes.html
--- mxml-2.6/doc/relnotes.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/relnotes.html	2009-05-17 17:31:51.000000000 +0000
@@ -0,0 +1,518 @@
+<html>
+<body>
+
+<h1 align='right'><a name='RELNOTES'><img src="B.gif" align="right"
+hspace="10" width="100" height="100" alt="B"></a>Release Notes</h1>
+
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.6</h2>
+
+<ul>
+
+	<li>Documentation fixes (STR #91, STR #92)</li>
+
+	<li>The mxmldoc program did not handle typedef comments properly (STR
+	#72)</li>
+
+	<li>Added support for &quot;long long&quot; printf formats.</li>
+
+	<li>The XML parser now ignores BOMs in UTF-8 XML files (STR #89)</li>
+
+	<li>The mxmldoc program now supports generating Xcode documentation
+	sets.</li>
+
+	<li>mxmlSave*() did not output UTF-8 correctly on some platforms.</li>
+
+	<li>mxmlNewXML() now adds encoding=&quot;utf-8&quot; in the ?xml
+	directive to avoid problems with non-conformant XML parsers that assume
+	something other than UTF-8 as the default encoding.</li>
+
+	<li>Wrapping was not disabled when mxmlSetWrapMargin(0) was called, and
+	&quot;&lt;?xml ... ?&gt;&quot; was always followed by a newline
+	(STR #76)</li>
+
+	<li>The mxml.pc.in file was broken (STR #79)</li>
+
+	<li>The mxmldoc program now handles &quot;typedef enum name {}
+	name&quot; correctly (STR #72)</li>
+
+</ul>
+
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.5</h2>
+
+<ul>
+
+	<li>The mxmldoc program now makes greater use of CSS and
+	supports a --css option to embed an alternate stylesheet.</li>
+
+	<li>The mxmldoc program now supports --header and --footer
+	options to insert documentation content before and
+	after the generated content.</li>
+
+	<li>The mxmldoc program now supports a --framed option to
+	generate framed HTML output.</li>
+
+	<li>The mxmldoc program now creates a table of contents
+	including any headings in the --intro file when
+	generating HTML output.</li>
+
+	<li>The man pages and man page output from mxmldoc did
+	not use "\-" for dashes (STR #68)</li>
+
+	<li>The debug version of the Mini-XML DLL could not be
+	built (STR #65)</li>
+
+	<li>Processing instructions and directives did not work
+	when not at the top level of a document (STR #67)</li>
+
+	<li>Spaces around the "=" in attributes were not supported
+	(STR #67)</li>
+
+</ul>
+
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.4</h2>
+
+<ul>
+
+	<li>Fixed shared library build problems on HP-UX and Mac OS X.</li>
+
+	<li>The mxmldoc program did not output argument descriptions
+	for functions properly.</li>
+
+	<li>All global settings (custom, error, and entity callbacks
+	and the wrap margin) are now managed separately for each
+	thread.</li>
+
+	<li>Added mxmlElementDeleteAttr() function (STR #59)</li>
+
+	<li>mxmlElementSetAttrf() did not work (STR #57)</li>
+
+	<li>mxmlLoad*() incorrectly treated declarations as parent
+	elements (STR #56)</li>
+
+	<li>mxmlLoad*() incorrectly allowed attributes without
+	values (STR #47)</li>
+
+	<li>Fixed Visual C++ build problems (STR #49)</li>
+
+	<li>mxmlLoad*() did not return NULL when an element
+	contained an error (STR #46)</li>
+
+	<li>Added support for the apos character entity (STR
+	#54)</li> <li>Fixed whitespace detection with Unicode
+	characters (STR #48)</li>
+
+	<li>mxmlWalkNext() and mxmlWalkPrev() did not work correctly
+	when called with a node with no children as the top node
+	(STR #53)</li>
+
+</ul>
+
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.3</h2>
+
+<ul>
+
+	<li>Added two exceptions to the LGPL to support static
+	linking of applications against Mini-XML</li>
+
+	<li>The mxmldoc utility can now generate man pages,
+	too.</li>
+
+	<li>Added a mxmlNewXML() function</li>
+
+	<li>Added a mxmlElementSetAttrf() function (STR #43)</li>
+
+	<li>Added a snprintf() emulation function for the test
+	program (STR #32)</li>
+
+	<li>Added the _CRT_SECURE_NO_DEPRECATE definition when
+	building on VC++ 2005 (STR #36)</li>
+
+	<li>mxmlLoad*() did not detect missing > characters in
+	elements (STR #41)</li>
+
+	<li>mxmlLoad*() did not detect missing close tags at the
+	end of an XML document (STR #45)</li>
+
+	<li>Added user_data and ref_count members to mxml_node_t
+	structure</li>
+
+	<li>Added mxmlReleaseNode() and mxmlRetainNode() APIs for
+	reference-counted nodes</li>
+
+	<li>Added mxmlSetWrapMargin() to control the wrapping of
+	XML output</li>
+
+	<li>Added conditional check for EINTR error code for
+	certain Windows compilers that do not define it (STR
+	#33)</li>
+
+	<li>The mxmldoc program now generates correct HTML 4.0
+	output - previously it generated invalid XHTML</li>
+
+	<li>The mxmldoc program now supports "@deprecated@,
+	"@private@", and "@since version@" comments</li>
+
+	<li>Fixed function and enumeration type bugs in
+	mxmldoc</li>
+
+	<li>Fixed the XML schema for mxmldoc</li>
+
+	<li>The mxmldoc program now supports --intro, --section,
+	and --title options</li>
+
+	<li>The mxmlLoad*() functions could leak a node on an
+	error (STR #27)</li>
+
+	<li>The mxml_vsnprintf() function could get in an
+	infinite loop on a buffer overflow (STR #25)</li>
+
+	<li>Added new mxmlNewCDATA() and mxmlSetCDATA() functions
+	to create and set CDATA nodes, which are really just
+	special element nodes</li>
+
+	<li>Added new MXML_IGNORE type and MXML_IGNORE_CB
+	callback to ignore non-element nodes, e.g.
+	whitespace</li>
+
+	<li>mxmlLoad*() did not treat custom data as opaque, so
+	whitespace characters would be lost</li>
+
+</ul>
+
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.2.2</h2>
+
+<ul>
+
+	<li>mxmlLoad*() did not treat custom data as opaque, so
+	whitespace characters would be lost.</li>
+
+</ul>
+
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.2.1</h2>
+
+<ul>
+
+	<li>mxmlLoadFd(), mxmlLoadFile(), and mxmlLoadString()
+	now correctly return NULL on error (STR #21)</li>
+
+	<li>mxmlNewInteger(), mxmlNewOpaque(), mxmlNewReal(),
+	mxmlNewText(), and mxmlNewTextf() incorrectly required a
+	parent node (STR #22)</li>
+
+	<li>Fixed an XML output bug in mxmldoc.</li>
+
+	<li>The "make install" target now uses the install
+	command to set the proper permissions on
+	UNIX/Linux/OSX.</li>
+
+	<li>Fixed a MingW/Cygwin compilation problem (STR
+	#18)</li>
+
+</ul>
+
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.2</h2>
+
+<ul>
+
+	<li>Added shared library support (STR #17)</li>
+
+	<li>mxmlLoad*() now returns an error when an XML stream
+	contains illegal control characters (STR #10)</li>
+
+	<li>mxmlLoad*() now returns an error when an element
+	contains two attributes with the same name in
+	conformance with the XML spec (STR #16)</li>
+
+	<li>Added support for CDATA (STR #14, STR #15)</li>
+
+	<li>Updated comment and processing instruction handling -
+	no entity support per XML specification.</li>
+
+	<li>Added checking for invalid comment termination ("--->"
+	is not allowed)</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.1</h2>
+
+<ul>
+
+	<li>Added support for custom data nodes (STR #6)</li>
+
+	<li>Now treat UTF-8 sequences which are longer than
+	necessary as an error (STR #4)</li>
+
+	<li>Fixed entity number support (STR #8)</li>
+
+	<li>Fixed mxmlLoadString() bug with UTF-8 (STR #7)</li>
+
+	<li>Fixed entity lookup bug (STR #5)</li>
+
+	<li>Added mxmlLoadFd() and mxmlSaveFd() functions.</li>
+
+	<li>Fixed multi-word UTF-16 handling.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 2.0</h2>
+
+<ul>
+
+	<li>New programmers manual.</li>
+
+	<li>Added Visual C++ project files for Microsoft Windows
+	users.</li>
+
+	<li>Added optimizations to mxmldoc, mxmlSaveFile(), and
+	mxmlIndexNew() (STR #2)</li>
+
+	<li>mxmlEntityAddCallback() now returns an integer
+	status (STR #2)</li>
+
+	<li>Added UTF-16 support (input only; all output is
+	UTF-8)</li>
+
+	<li>Added index functions to build a searchable index of
+	XML nodes.</li>
+
+	<li>Added character entity callback interface to support
+	additional character entities beyond those defined in
+	the XHTML specification.</li>
+
+	<li>Added support for XHTML character entities.</li>
+
+	<li>The mxmldoc utility now produces XML output which
+	conforms to an updated XML schema, described in the file
+	"doc/mxmldoc.xsd".</li>
+
+	<li>Changed the whitespace callback interface to return
+	strings instead of a single character, allowing for
+	greater control over the formatting of XML files written
+	using Mini-XML.  THIS CHANGE WILL REQUIRE CHANGES TO
+	YOUR 1.x CODE IF YOU USE WHITESPACE CALLBACKS.</li>
+
+	<li>The mxmldoc utility now produces XML output which
+	conforms to an updated XML schema, described in the file
+	"doc/mxmldoc.xsd".</li>
+
+	<li>Changed the whitespace callback interface to return
+	strings instead of a single character, allowing for
+	greater control over the formatting of XML files written
+	using Mini-XML.  THIS CHANGE WILL REQUIRE CHANGES TO
+	YOUR 1.x CODE IF YOU USE WHITESPACE CALLBACKS.</li>
+
+	<li>The mxmldoc utility is now capable of documenting C++
+	classes, functions, and structures, and correctly
+	handles C++ comments.</li>
+
+	<li>Added new modular tests for mxmldoc.</li>
+
+	<li>Updated the mxmldoc output to be more compatible with
+	embedding in manuals produced with HTMLDOC.</li>
+
+	<li>The makefile incorrectly included a "/" separator
+	between the destination path and install path.  This
+	caused problems when building and installing with
+	MingW.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 1.3</h2>
+
+<ul>
+
+	<li>Fixes for mxmldoc.</li>
+
+	<li>Added support for reading standard HTML entity names.</li>
+
+	<li>mxmlLoadString/File() did not decode character
+	entities in element names, attribute names, or
+	attribute values.</li>
+
+	<li>mxmlLoadString/File() would crash when loading non-
+	conformant XML data under an existing parent (top)
+	node.</li>
+
+	<li>Fixed several bugs in the mxmldoc utility.</li>
+
+	<li>Added new error callback function to catch a variety
+	of errors and log them to someplace other than stderr.</li>
+
+	<li>The mxmlElementSetAttr() function now allows for NULL
+	attribute values.</li>
+
+	<li>The load and save functions now properly handle quoted
+	element and attribute name strings properly, e.g. for
+	!DOCTYPE declarations.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 1.2</h2>
+
+<ul>
+
+	<li>Added new "set" methods to set the value of a node.</li>
+
+	<li>Added new formatted text methods mxmlNewTextf() and
+	mxmlSetTextf() to create/set a text node value using
+	printf-style formats.</li>
+
+	<li>Added new standard callbacks for use with the mxmlLoad
+	functions.</li>
+
+	<li>Updated the HTML documentation to include examples of
+	the walk and load function output.</li>
+
+	<li>Added --with/without-ansi configure option to control
+	the strdup() function check.</li>
+
+	<li>Added --with/without-snprintf configure option to
+	control the snprintf() and vsnprintf() function
+	checks.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 1.1.2</h2>
+
+<ul>
+
+	<li>The mxml(3) man page wasn't updated for the string
+	functions.</li>
+
+	<li>mxmlSaveString() returned the wrong number of
+	characters.</li>
+
+	<li>mxml_add_char() updated the buffer pointer in the
+	wrong place.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 1.1.1</h2>
+
+<ul>
+
+	<li>The private mxml_add_ch() function did not update the
+	start-of-buffer pointer which could cause a crash when
+	using mxmlSaveString().</li>
+
+	<li>The private mxml_write_ws() function called putc()
+	instead of using the proper callback which could cause
+	a crash when using mxmlSaveString().</li>
+
+	<li>Added a mxmlSaveAllocString() convenience function for
+	saving an XML node tree to an allocated string.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 1.1</h2>
+
+<ul>
+
+	<li>The mxmlLoadFile() function now uses dynamically
+	allocated string buffers for element names, attribute
+	names, and attribute values.  Previously they were
+	capped at 16383, 255, and 255 bytes, respectively.</li>
+
+	<li>Added a new mxmlLoadString() function for loading an
+	XML node tree from a string.</li>
+
+	<li>Added a new mxmlSaveString() function for saving an
+	XML node tree to a string.</li>
+
+	<li>Add emulation of strdup() if the local platform does
+	not provide the function.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 1.0</h2>
+
+<ul>
+
+	<li>The mxmldoc program now handles function arguments,
+	structures, unions, enumerations, classes, and
+	typedefs properly.</li>
+
+	<li>Documentation provided via mxmldoc and more in-line
+	comments in the code.</li>
+
+	<li>Added man pages and packaging files.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 0.93</h2>
+
+<ul>
+
+	<li>New mxmldoc example program that is also used to
+	create and update code documentation using XML and
+	produce HTML reference pages.</li>
+
+	<li>Added mxmlAdd() and mxmlRemove() functions to add and
+	remove nodes from a tree.  This provides more
+	flexibility over where the nodes are inserted and
+	allows nodes to be moved within the tree as needed.</li>
+
+	<li>mxmlLoadFile() now correctly handles comments.</li>
+
+	<li>mxmlLoadFile() now supports the required "gt", "quot",
+	and "nbsp" character entities.</li>
+
+	<li>mxmlSaveFile() now uses newlines as whitespace
+	when valid to do so.</li>
+
+	<li>mxmlFindElement() now also takes attribute name and
+	attribute value string arguments to limit the search
+	to specific elements with attributes and/or values.</li>
+	NULL pointers can be used as "wildcards".</li>
+
+	<li>Added uninstall target to makefile, and auto-reconfig
+	if Makefile.in or configure.in are changed.</li>
+
+	<li>mxmlFindElement(), mxmlWalkNext(), and mxmlWalkPrev()
+	now all provide "descend" arguments to control whether
+	they descend into child nodes in the tree.</li>
+
+	<li>Fixed some whitespace issues in mxmlLoadFile().</li>
+
+	<li>Fixed Unicode output and whitespace issues in
+	mxmlSaveFile().</li>
+
+	<li>mxmlSaveFile() now supports a whitespace callback to
+	provide more human-readable XML output under program
+	control.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 0.92</h2>
+
+<ul>
+
+	<li>mxmlSaveFile() didn't return a value on success.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 0.91</h2>
+
+<ul>
+
+	<li>mxmlWalkNext() would go into an infinite loop.</li>
+
+</ul>
+
+<h2 _hd_omit_toc>Changes in Mini-XML 0.9</h2>
+
+<ul>
+
+	<li>Initial public release.</li>
+
+</ul>
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/schema.html mxml-2.6-haiku/doc/schema.html
--- mxml-2.6/doc/schema.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/schema.html	2007-04-26 22:21:37.000000000 +0000
@@ -0,0 +1,201 @@
+<html>
+<body>
+
+<h1 align='right'><a name='SCHEMA'><img src="D.gif" align="right"
+hspace="10" width="100" height="100" alt="D"></a>XML Schema</h1>
+
+<p>This appendix provides the XML schema that is used for the XML
+files produced by <tt>mxmldoc</tt>. This schema is available on-line
+at:</p>
+
+<pre>
+    http://www.easysw.com/~mike/mxmldoc.xsd
+</pre>
+
+<h2 _hd_omit_toc>mxmldoc.xsd</h2>
+
+<pre><small>
+&lt;?xml version="1.0"?>
+&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  &lt;xsd:annotation>
+    &lt;xsd:documentation xml:lang="en">
+      Mini-XML 2.3 documentation schema for mxmldoc output.
+      Copyright 2003-2007 by Michael Sweet.
+    &lt;/xsd:documentation>
+  &lt;/xsd:annotation>
+
+  &lt;!-- basic element definitions -->
+  &lt;xsd:element name="argument" type="argumentType"/>
+  &lt;xsd:element name="class" type="classType"/>
+  &lt;xsd:element name="constant" type="constantType"/>
+  &lt;xsd:element name="description" type="xsd:string"/>
+  &lt;xsd:element name="enumeration" type="enumerationType"/>
+  &lt;xsd:element name="function" type="functionType"/>
+  &lt;xsd:element name="mxmldoc" type="mxmldocType"/>
+  &lt;xsd:element name="namespace" type="namespaceType"/>
+  &lt;xsd:element name="returnvalue" type="returnvalueType"/>
+  &lt;xsd:element name="seealso" type="identifierList"/>
+  &lt;xsd:element name="struct" type="structType"/>
+  &lt;xsd:element name="typedef" type="typedefType"/>
+  &lt;xsd:element name="type" type="xsd:string"/>
+  &lt;xsd:element name="union" type="unionType"/>
+  &lt;xsd:element name="variable" type="variableType"/>
+
+  &lt;!-- descriptions of complex elements -->
+  &lt;xsd:complexType name="argumentType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="default" type="xsd:string" use="optional"/>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+    &lt;xsd:attribute name="direction" type="direction" use="optional"
+     default="I"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="classType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      &lt;xsd:choice minOccurs="0" maxOccurs="unbounded">
+	&lt;xsd:element ref="class"/>
+	&lt;xsd:element ref="enumeration"/>
+	&lt;xsd:element ref="function"/>
+	&lt;xsd:element ref="struct"/>
+	&lt;xsd:element ref="typedef"/>
+	&lt;xsd:element ref="union"/>
+	&lt;xsd:element ref="variable"/>
+      &lt;/xsd:choice>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+    &lt;xsd:attribute name="parent" type="xsd:string" use="optional"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="constantType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="enumerationType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      &lt;xsd:element ref="constant" minOccurs="1" maxOccurs="unbounded"/>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="functionType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="returnvalue" minOccurs="0" maxOccurs="1"/>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      &lt;xsd:element ref="argument" minOccurs="1" maxOccurs="unbounded"/>
+      &lt;xsd:element ref="seealso" minOccurs="0" maxOccurs="1"/>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+    &lt;xsd:attribute name="scope" type="scope" use="optional"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="mxmldocType">
+    &lt;xsd:choice minOccurs="0" maxOccurs="unbounded">
+      &lt;xsd:element ref="class"/>
+      &lt;xsd:element ref="enumeration"/>
+      &lt;xsd:element ref="function"/>
+      &lt;xsd:element ref="namespace"/>
+      &lt;xsd:element ref="struct"/>
+      &lt;xsd:element ref="typedef"/>
+      &lt;xsd:element ref="union"/>
+      &lt;xsd:element ref="variable"/>
+    &lt;/xsd:choice>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="namespaceType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      &lt;xsd:choice minOccurs="0" maxOccurs="unbounded">
+	&lt;xsd:element ref="class"/>
+	&lt;xsd:element ref="enumeration"/>
+	&lt;xsd:element ref="function"/>
+	&lt;xsd:element ref="struct"/>
+	&lt;xsd:element ref="typedef"/>
+	&lt;xsd:element ref="union"/>
+	&lt;xsd:element ref="variable"/>
+      &lt;/xsd:choice>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="returnvalueType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    &lt;/xsd:sequence>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="structType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      &lt;xsd:choice minOccurs="0" maxOccurs="unbounded">
+	&lt;xsd:element ref="variable"/>
+	&lt;xsd:element ref="function"/>
+      &lt;/xsd:choice>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="typedefType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="unionType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+      &lt;xsd:element ref="variable" minOccurs="0" maxOccurs="unbounded"/>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+  &lt;/xsd:complexType>
+
+  &lt;xsd:complexType name="variableType">
+    &lt;xsd:sequence>
+      &lt;xsd:element ref="type" minOccurs="1" maxOccurs="1"/>
+      &lt;xsd:element ref="description" minOccurs="0" maxOccurs="1"/>
+    &lt;/xsd:sequence>
+    &lt;xsd:attribute name="name" type="identifier" use="required"/>
+  &lt;/xsd:complexType>
+
+  &lt;!-- data types -->
+  &lt;xsd:simpleType name="direction">
+    &lt;xsd:restriction base="xsd:string">
+      &lt;xsd:enumeration value="I"/>
+      &lt;xsd:enumeration value="O"/>
+      &lt;xsd:enumeration value="IO"/>
+    &lt;/xsd:restriction>
+  &lt;/xsd:simpleType>
+
+  &lt;xsd:simpleType name="identifier">
+    &lt;xsd:restriction base="xsd:string">
+      &lt;xsd:pattern value="[a-zA-Z_(.]([a-zA-Z_(.,)* 0-9])*"/>
+    &lt;/xsd:restriction>
+  &lt;/xsd:simpleType>
+
+  &lt;xsd:simpleType name="identifierList">
+    &lt;xsd:list itemType="identifier"/>
+  &lt;/xsd:simpleType>
+
+  &lt;xsd:simpleType name="scope">
+    &lt;xsd:restriction base="xsd:string">
+      &lt;xsd:enumeration value=""/>
+      &lt;xsd:enumeration value="private"/>
+      &lt;xsd:enumeration value="protected"/>
+      &lt;xsd:enumeration value="public"/>
+    &lt;/xsd:restriction>
+  &lt;/xsd:simpleType>
+&lt;/xsd:schema>
+</small></pre>
+
+</body>
+</html>
diff -Naur mxml-2.6/doc/title.html mxml-2.6-haiku/doc/title.html
--- mxml-2.6/doc/title.html	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/doc/title.html	2009-05-17 06:04:58.000000000 +0000
@@ -0,0 +1,37 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+	<title>Mini-XML Programmers Manual</title>
+	<meta name="author" content="Michael R Sweet">
+	<meta name="copyright" content="Copyright 2003-2009">
+</head>
+<body>
+
+<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0" summary="">
+<tr><td height="100%">
+
+<H1 ALIGN="CENTER"><FONT SIZE="-1">Mini-XML Programmers Manual<br>
+Version 2.6</H1>
+
+<P ALIGN="CENTER">MICHAEL R. SWEET</P>
+
+</td></tr>
+</table>
+
+<!-- NEW PAGE -->
+<P><FONT SIZE="+1"><B>Mini-XML Programmers Manual, Version 2.6</B></FONT></P>
+
+<P><B>Copyright &copy; 2003-2009 by Michael R. Sweet</B></P>
+
+<P><SMALL>Permission is granted to copy, distribute and/or modify
+this document under the terms of the GNU Library General Public
+License, Version 2. A copy of this license is included in <A
+HREF="#LICENSE">Appendix A - Mini-XML License</A>.</SMALL></P>
+
+<P><SMALL>This book was created solely using free software
+tools.</SMALL></P>
+
+<P><SMALL>First Printing: April 2007</SMALL></P>
+
+</body>
+</html>
diff -Naur mxml-2.6/install-sh mxml-2.6-haiku/install-sh
--- mxml-2.6/install-sh	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/install-sh	2005-04-24 23:23:59.000000000 +0000
@@ -0,0 +1,251 @@
+#!/bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5 (mit/util/scripts/install.sh).
+#
+# Copyright 1991 by the Massachusetts Institute of Technology
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation, and that the name of M.I.T. not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  M.I.T. makes no representations about the
+# suitability of this software for any purpose.  It is provided "as is"
+# without express or implied warranty.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+transformbasename=""
+transform_arg=""
+instcmd="$mvprog"
+chmodcmd="$chmodprog 0755"
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+dir_arg=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-d) dir_arg=true
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
+	    shift
+	    continue;;
+
+	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		# this colon is to work around a 386BSD /bin/sh bug
+		:
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:	no input file specified"
+	exit 1
+else
+	:
+fi
+
+if [ x"$dir_arg" != x ]; then
+	dst=$src
+	src=""
+	
+	if [ -d $dst ]; then
+		instcmd=:
+		chmodcmd=""
+	else
+		instcmd=$mkdirprog
+	fi
+else
+
+# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
+# might cause directories to be created, which would be especially bad 
+# if $src (and thus $dsttmp) contains '*'.
+
+	if [ -f $src -o -d $src ]
+	then
+		:
+	else
+		echo "install:  $src does not exist"
+		exit 1
+	fi
+	
+	if [ x"$dst" = x ]
+	then
+		echo "install:	no destination specified"
+		exit 1
+	else
+		:
+	fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+	if [ -d $dst ]
+	then
+		dst="$dst"/`basename $src`
+	else
+		:
+	fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d "$dstdir" ]; then
+defaultIFS='
+	'
+IFS="${IFS-${defaultIFS}}"
+
+oIFS="${IFS}"
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS="${oIFS}"
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+	pathcomp="${pathcomp}${1}"
+	shift
+
+	if [ ! -d "${pathcomp}" ] ;
+        then
+		$mkdirprog "${pathcomp}"
+	else
+		:
+	fi
+
+	pathcomp="${pathcomp}/"
+done
+fi
+
+if [ x"$dir_arg" != x ]
+then
+	$doit $instcmd $dst &&
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else : ; fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else : ; fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else : ; fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else : ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+	if [ x"$transformarg" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		dstfile=`basename $dst $transformbasename | 
+			sed $transformarg`$transformbasename
+	fi
+
+# don't allow the sed command to completely eliminate the filename
+
+	if [ x"$dstfile" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		:
+	fi
+
+# Make a temp file name in the proper directory.
+
+	dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+	$doit $instcmd $src $dsttmp &&
+
+	trap "rm -f ${dsttmp}" 0 &&
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above "$doit $instcmd $src $dsttmp" command.
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else :;fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else :;fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else :;fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else :;fi &&
+
+# Now rename the file to the real destination.
+
+	$doit $rmcmd -f $dstdir/$dstfile &&
+	$doit $mvcmd $dsttmp $dstdir/$dstfile 
+
+fi &&
+
+
+exit 0
diff -Naur mxml-2.6/libmxml.so.2.6 mxml-2.6-haiku/libmxml.so.2.6
--- mxml-2.6/libmxml.so.2.6	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/libmxml.so.2.6	2009-10-26 02:44:10.000000000 +0000
@@ -0,0 +1,414 @@
+ELF                  4        4    (                  Dz  Dz           Dz  D  D               l  l  l              a   r   ^   ]      o   D   Y                                T   i           g   0   e   Z       #   j       d   f   A       \       U   R       `       )   c   -   I       m   a   n       b   '   ,       ?       1       /          O       8   V   !          2   P           q   Q      6   (   
+   W           p   4       h   S                              E           >   M       .   l                                                                                                                                                                   &                   +          "         %                   5                           =       9       ;       *       :           F   H          <   3   @          K           J          X   $           G   N       B       [           _   7            L       C       k                               |                        k       	     k       
+     D            \            d                                       G        c  \       d           _      (      U      I  )  B       (             k                  d  g  "                        2        b  6           <        ,c  ]                   i       H  a  O        0   C           h        j  {       \  $     5                       ;  x)  f        d  C       h%       y  $  N        |                     i       
+  \(       _      *                 g  #             ,            J        !             .                 '          "      e  W     k  d*  3     /              Lb  S       &  <       j  *           J      @      ;        *  $     <      ^     p            h&  `     -  ,f  G     :  f  R            `      4  <d  B     )  `  '               T         D  p#  W     Z  i       H  f  ~     s  g  Z       i            C        !  f       b  2        e                   U  Tg  Z       a  <     6      }        @'       Y  $*  @            )      *   i  v       '  9        k       	   0h  "     w  Y  )     W      .        *  (       t[  r                              Th  `        Z  r    
+  c  T       i         b  U     M         `         g  Y  T        |!  n       h  d          C       $  w       '       ?          "   U            0a  V           c                    _init _init_before _fini _term_before __deregister_frame_info __register_frame_info _gSharedObjectHaikuVersion _gSharedObjectHaikuABI get_image_symbol _init_after _term_after mxmlElementDeleteAttr strcmp free memmove mxmlElementGetAttr mxmlElementSetAttr strdup mxmlElementSetAttrf _mxml_vstrdupf mxml_error malloc realloc mxmlEntityAddCallback _mxml_global mxmlEntityGetName mxmlEntityGetValue mxmlEntityRemoveCallback _mxml_entity_cb mxmlLoadFd mxmlLoadFile mxmlLoadString mxmlSaveAllocString mxmlSaveString mxmlSaveFd mxmlSaveFile _single_threaded putc_unlocked putc mxmlSAXLoadFd mxmlSAXLoadFile mxmlSAXLoadString mxmlSetCustomHandlers mxmlSetErrorCallback mxmlSetWrapMargin _errnop read write getc_unlocked getc __ctype_b strtol mxmlNewInteger mxmlNewOpaque strtod mxmlNewReal mxmlNewText mxmlNewCustom mxmlDelete mxmlRelease strncmp mxmlNewElement sprintf strrchr mxmlIndexDelete mxmlIndexEnum mxmlIndexFind mxmlIndexNew calloc strerror mxmlFindElement mxmlIndexReset mxmlAdd mxmlRemove mxmlNewCDATA _mxml_strdupf mxmlNewTextf mxmlNewXML mxmlRetain mxmlWalkNext mxmlWalkPrev mxmlSetCustom mxmlSetCDATA mxmlSetElement mxmlSetInteger mxmlSetOpaque mxmlSetReal mxmlSetText mxmlSetTextf vsnprintf stderr fprintf mxml_ignore_cb mxml_integer_cb mxml_opaque_cb mxml_real_cb pthread_once pthread_getspecific pthread_setspecific pthread_key_create libroot.so _edata __bss_start _end libmxml.so.2   `                         (     L     h                         ,     P     p                         <     `                              4     X                              8     \                               X     |                         ,     P                              <     \                              (     H     `                          $     H     l                              D     \     t                              <                                                                        (     0     8     @     H     P     X     `     h     p     x                                                                                                                (     0     8     @     H     P     X     `     h     p     x                                                                                                                (     0     8     @     H     P     X     `     h     p     x                                                                                                                (     0     8     @     H     P     X     `     h     p     x                                                                                                                (     0     8     @     H     P     X     `     h     p     x                                                                                                                (     0     8     @     H     P     X     `     h     p     x                                                                                                                (     0     8     @     H     P     X     `     h     p     x                                                                                                                (     0     8     @     H     P     X     `     h     p     x                                                                                                2    ^    _    m  0  
+  4    8    <    @    D    H    L    P     T  !  X  '  \  *  `  +  d  -  h  .  l  0  p  1  t  2  x  5  |  9    :    <    A    O    R    U    [    m    p    q  Uu    N    ]               h       h      h      h      h        h(   $   h0   (   h8   p,   h@   `0   hH   P4   hP   @8   hX   0<   h`    @   hh   D   hp    H   hx   L   h   P   h   T   h   X   h   \   h   `   h   d   h   h   h   pl   h   `p   h   Pt   h   @x   h   0|   h       h       US    [x      uD   P       8 u    t P      ]]US    [ x  []US    [x      t  P P]]v US    [w  []UVS    [w  uEPjPVu	VEe[^]UVS    [ow  uEPjPVu	VEe[^]UVS    [+w  uEPjPVu	VEe[^]UVS    [v  uEPjPVRu	VEe[^]UWVS    [v  } tnE8 uf} t`px ~VEPPzu8PGPN ~VGPWEHNe[^_]UWVS    [v  Et>8 u9} u
+1v G+px ~EPPtN1e[^_]UWVS    [u  }EtE? u@} t:tPY    1VEPW   t	Ve[^_]UWVS    [*u  }Utc? u^} tXtTEPRH  u GPEPPF  %&    VEPW   t	Ve[^_]UWVS    [t  Exp ~A    URPuFt	PEF1   OUBuj=   PUB Pt3Ur BEPtUEV@1UBPEPPE  e[^_]UVS    [s  ?F  qc~\P~E  &    EQA1e[^]US    [Ss  E   +&    '    r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  {t& 
+1[]UWVS    [vr  E  1;~}UFR}G;~|e[^_]UWVS    [&r  D  1B9}FBEz}B};<u"AB9}%)P}WEPEEF9|e[^_]UWVS    [q  E    E   t& EE<   EPUR~t]}	}t& }E+EuUPEPEt$uUPEP%tUDe[^_]U1U t	t
+t
+u   ]v U    VS    [p  uEM j j PQRV  [^]UVS    [Op  uMUj j @PRQV  e[^]US    [p  MUj j PREPQV  ]]v U   WVS    [o  EPh     VEP{  ~@=  V0    xWtEPWVEP8  1[^_]U   WVS    [Ko  u}A   PPj WVEP;'   |~Vj
+  }	V	  [^_]v UWVS    [n  }uLA  PPj VEPW&   |7~C   8 tEPj
+|$t& EPj
+^}	&    1e[^_]UWVS    [*n  u@  UU}UWP Pj VWEP,&   }	/~Wj
+$  E;GrUED   E+Ee[^_]U   WVS    [m  E}MU RQPWVEP  [^_]UWVS    [6m  }uMUEPR@PQVWt  e[^_]UVS    [l  uMUEPRPQEPV1  e[^]UWVS    [l  u}D?      [^_]UVS    [l  u?  0[^]UVS    [[l  u>    [^]UWVS    [2l  }uEM9rz  	EM   UPMPu-UP#MP<P=     M)Eb&      :  $?$?$?1e[^_]v UWVS    [
+k  }UB9BrRD  S  UB0B6  	t      |)  
+    	       uFUB9BrR    UB0B        8t&    uHUB9BrRp    UB0B   g         %   =   udUB9BrR  )  UB1E@%   =     ?	  V  %   =      UB9BrR    UB1E@%   =     ?	UB9BrRX  g  UB1E@%   =   E  ?	  V       %   =     UB9BrR    UB1E@%   =     ?	UB9BrR    UB1E@%   =   v  ?	UB9BrR@  O  UB1E@%   =   -  ?	    V  t& UB9BrR     UB1E	@
+tt		    (=  5  UB9BrR{     UB8BB9BrRS  |iUB1E   UB9BrR&  |9UB1E	@)
+t$t	tV|P8      (=  wuUB9BrR   |UB8BB9BrR   |UB1E	@ $=  w  
+  	   e[^_]UVS    [e  uF9FrV   }VEF1e[^]v UWVS    [e  }u"K    w8  tj8
+  u+h    wVP|twDG1e[^_]UWVS    ["e  }uAGEG;Et1u9s$t& G)PVPJ|;wrEG1e[^_]UWVS    [d  }   8 tEPyEP{  V  	t      |)  
+    	       uF   8 tEPEP        1t&    uH   8 tEPEP        &    %   =   uh   8 tEPGEPI9        %  ?	  V  %   =         8 tEPEP          ?	   8 tEP}EPo        [  ?	  V6  t&     %   =        8 tEPt& EP          ?	   8 tEPEP        |  ?	   8 tEPQv EPP@        ,  ?	    V     8 tEPEP	
+tt		    (=  =     8 tEPEP   8 tEP\EP^      8 tEP0EP0	)
+t$t	tV|P2      (=  wz   8 tEPEP   8 tEPEP	 $=  w  
+  	   e[^_]v US    [`_  M   U8 tRQtv RQ2u1]]ULWVS    [_  }}Cv E9EsUBU+} tUBPP0  6t& EPURUt~    pu#tE  ;t%} tUBPEP<   }#u.}xujj EP^Ij
+j EPJ5W}&} tUBPW|P/  =
+t8t3	t.} tUBPVP/  t& e[^_]U<WVS    []  "0  Ej@yEu\PT/    EEE@   EE    E    E    } ttRME
+  E   }
+  }<t+}W!  }  }  E;E    E  +\t& \  o\  ]\  1\  \  j EPEPPMQa'  4EP}W'  @EPEP$EP'      EPURMQ'  t}   tdj j EP\&  EPV   t=} tUBPEPP-  V$  1 t& 1E8 t6} tMAPEP}uP&  E}EE    Wgt}Eu2}t,} tUBPM  P	  } t!}WjVEV'   u1} u0t,u'&    URt}uE   }<  } t]}uWPPMQ}W'&  } t!EPjVUVl'   u1} utuE    }<)  EE   }<  }&uFMQ}WEPURE  EPEPEPMQa  zEPEPEP}Ww?  UE)u	:?   ujdPRGtpUE)ujhPR!tJEEPURMEt,PGu}>t}/E9EE  Ud        EPEPEPEPV  URMQ}Et$>uEU9vz-tz-uz-u}>  E  EPEP#  u*} tUBPP5*    }   MQjV}V'%      1  h	        EPEPEPEPT  URMQ}Et$>ujPEPQu}>  E  EPEP"  u%} tUBP  t& } t!MQj V}V.$   u1  }   u  <?   #v EPEPEPEPW  URMQ}Et>uE;Evx?u}>  E  EPEP!  u!} tUBP|  }   MQjV}VB#      1  t& <!  }>tj}&u$MQEP}WEPEo  EPEPEPURO  EPMQ}Eu  E  EPEP&   u!} tUBP  } t!MQjV}VV"   u1  } uu}   u}     t& </   } tMAPBPt(} t}GPEPA  v }>t*}t$t& EPURME>tuu~}} tEPjVUVu!   } =  } 3  MQ}   REP  u!} tUBP\  MQt&}WEPURV  E\  /v }/u&MQ}WUE>  E/   } tMQjV}} uu}
+  }/t#u} tKtGVUE6t& } t+MQjV}V>    u9uuE    EE   t& }&u:EPURMQ}WEm  EPEPEPEP3t& }t}tURu EPEPEPMQP  }}WEPUEaEP} tjuFMIMA;Etu;ut6VtBPFPP$  }W     t   t& E   q[P<Ct& 3t& EPEPP#  Vh   QPl#  URE  EP1e[^_]UWVS    [:Q  j@1EuP#    &    E@   j@Eu%EP5\P"  >  t& E@     t& V  /t?u2EPURU>  WUBPV  <  >d  EE@E"t	'   M&u#UREPUREPg  EPEPEPVJ  9   UREPUu   &u#EPUREPUR  EPEPEPVJ  EPURUt(Vxu=t/t>t	?yE  EPEPy      UREPUtVu=m  EPURU  Vu  't"u|EEG&u#EPUREPURf  EPEPEPV  EPURU   9u   t& EE@EE&u#UREPUREPI  EPEPEPV,  UREPUtVu=t
+/t>uE  EPEPEP#v UBPEP   &    /t?u9EPURU>tBWUBPVP  #>tEPURU:EP:EP.LUBPEPUBPP  EPEPe[^_]UWVS    [nL  }2   uE8:  BE E  t  t& }    |<G  
+>  5  	,  Q|P    v    uz  E    N   uz  E    ,%   =   uCB%   =   _  B$?	   Q]%   =   u}rB%   =     F%   =     $?	B$?	  Q  \  t&         rB%   =   |  F%   =   h  F%   =   T  $?	B$?	B$?	  gQ6t& 1B	
+tt		 (=  7>    11F	7 $=       
+  	   1B	ur
+tt		x (=  7~ t<1V1	7 $=  w  
+  	   Oe[^_]UU
+;JsE1]UWVS    [H  u<"t<'   EPPU|lFEy   P4tSURj&U|7? tEPPU|G? uEPj;U}_EPPv Ft	:ExEPEPU}(t"t& EPPU|F> u1e[^_]v U  WVS    [G  }}   U  +|    lG  aB  A  A  @  @  EPWj UREPUR	  E Pj<U$  UB8?t;jdPBPtjhPUBPu.Ep> tEURPU  F> u"EPURUBP  UBtzt8*t1B8*t,B8*t'B
+utt   t   uBB)E|:U@R   tzt86t1F86t,F86t'Futt   t   uFF)HtKtzt80t1@80t,@80t'@utt   t   u@@)t0E  ~$>9~URj
+UI  1EPj U,  GEPURP=  x tpURj=U  EPj"U  EPURBP    EPj"U   REx m  URj>UI  EGPWjUREPUR   E PURWEPURUBPO   UB <!  <?  EPWjUREPUR  E Pj<U  EPj/U  EPURUBP  o  EPj>UV  UBtzt8*t1B8*t,B8*t'B
+utt   t   uBB)E|:PWj   UB <!t<?u EPj>U  EGREPj U  EPj/U  EPj>Uz  EPWjUREPUR/   ]  Ex tNU  ~'9~#EPj
+U  1     EPj U  GU BP,PVEPURV        EPURUBP    UBE  v Ex tHU  ~!9~EPj
+UR  1EPj U5  GE @$/PVLUREPV/     utt   t   u@@)  Ex tN~JU  ~#9~EPj
+U  1EPj Ul  GEPURUBP  I  UBtzt8*t1B8*t,B8*t'B
+utt   t   uBB)   U     UR   EPURV      j
+VuKtzt80t1@80t,@80t'@utt   t   u@@)Gtzt87t1G87t,G87t'Gutt   t   uGG)Vlt& E@EP[^_]UWVS    [>  }? tv P\tCEPj&U|Et& EPPU|(F> uEPj;EPPU}G? u1e[^_]UWVS    [.>  UuteEPEPtO? tJEPPU}.<
+u
+1    <	uyFFG? ue[^_]UVS    [=  ut0tP~ tFPVe[^]UUtJ;J|
+1    BB]v UWVS    [=  }F  ? u
+} 7  } u} uW  &    G  W   E    HE~xUU4GPEPEPW  u.N   GDPEPEPW  t   }u
+&    uE+Eu;ujGPEPEPWu  t>F;u~F    9}<GPEPEPWG  u#WGGt& FGG
+GG1e[^_]UWVS    [;  } u1F  jju)f PPj<PS  1  } tEP&} uO} uI}    PPF@P|P   VJ1   v jj EPEPEPPaF9F|9uh      PFPwpFF@VF<Fjj EPEPEPWD   uF~HPj V
+  e[^_]UEt@    x u1@ ]UWVS    [
+:  }uFPUBPu2t*PVPPEPPu1e[^_]v UWVS    [9  U}utFPRu#tE PVHPWiu1e[^_]UWVS    [29  &    UMuBE9}p    G;}}!EPUBPR~N;u~MQUBPR9}MAUBMAPEPQm~UBMUMBF9E}PEPUR
+Fu9ue[^_]UWVS    [8  }u      ~ t	VR  ~} t}tZ   } tE;Gt9xtGFGtpwwv UVBFBtpwEpY} tU;Wt9zt"~GFGt
+pt& ww$EUFBFBtpwEpe[^_]UWVS    [7  u   V[  FP~ u   +<6  6  C6  6  16  6  FtPF   19}7t& F tPF DtPG;~|F P8Ft4P&Ft"PyVtFt	RVWe[^_]UWVS    [5  }u1,j EPB  tWP9	  Fe[^_]US    [5  EjP  tEBEB]]UWVS    [R5  }u1%j EP  tWFe[^_]US    [5  EjPk  tEB]]UWVS    [4  }u1)t& jEP"  tW|Fe[^_]US    [x4  EjP  tEX]]UWVS    [B4  }u1+jEP  tEFWFe[^_]v UWVS    [3  }u13t& jEPB  tEUFRWb  Fe[^_]v UVMtLqtEQtAB	v AFQtAB	QABA    A    A    ^]U  VS    [,3  EuPPh    VVj [^]US    [2  UtB$HJ$R1]]UUuB$HJ$]UWVS    [v2  }j,ju1EF$   tVj jWe[^_]UWVS    [2  u}   }    } u   EPEPV   tp> uY~ tS} tEPFPu6v } t)EPVttPWu}ujv1e[^_]v UEMtDPt} u9t3Pt*v @t9tx u@9tt	@1]UEMt49t0Pt"Bt} tx t@x u	@9u1]UVS    [0  ut>t"VtFtREFEF1e[^]UWVS    [B0  u}t%> u tj PFPt)FtPLW	Pm  F1e[^_]UWVS    [/  u}t	> uu!FtPWmF1e[^_]UUt:tEB1]UWVS    [B/  u}t	>uu!FtPiWF1e[^_]UEt8tEX1]UWVS    [.  u}t	>uu'FtPEFWgF1e[^_]UWVS    [b.  u}t	>uu+FtPEUFRW  F1e[^_]U  WVS    [-  u   tCEPVh    V? tVVP    P[^_]U]U   ]U   ]U   ]UVS    [O-  ,P  P  P u;h  jSV  PA   F   F  H   e[^]US    [,  \P  PS]]US    [,  EP]]US    [h,  UEPR	   ]]U  WVS    [7,  EPEPh    V/=   wV(xWj<tEPEPWV[^_]UVS    [+  88t>u[^]v US    [+  []Uu1k]                       initialize_before initialize_after terminate_before terminate_after                             Unable to allocate memory for attribute '%s' in element %s!     Unable to add entity callback! amp lt gt quot zwnj zwj zeta yuml yen yacute xi weierp uuml upsilon upsih uml ugrave ucirc uarr uacute uArr trade times tilde thorn thinsp thetasym theta there4 tau szlig supe sup3 sup2 sup1 sup sum sube sub spades sim sigmaf sigma shy sect sdot scaron sbquo rsquo rsaquo rlm rho rfloor reg real rdquo rceil rarr raquo rang radic rArr psi prop prod prime pound plusmn piv pi phi perp permil part para ouml otimes otilde oslash ordm ordf or oplus omicron omega oline ograve oelig ocirc oacute nu ntilde nsub notin not ni ne ndash nbsp nabla mu minus middot micro mdash macr lsquo lsaquo lrm loz lowast lfloor le ldquo lceil larr laquo lang lambda lArr kappa iuml isin iquest iota int infin image igrave iexcl icirc iacute hibar hellip hearts harr hArr ge gamma frasl frac34 frac14 frac12 forall fnof exist euro euml eth eta equiv epsilon ensp emsp empty egrave ecirc eacute divide die diams delta deg darr dagger dArr curren cup crarr copy cong clubs circ chi cent cedil ccedil cap bull brvbar brkbar beta bdquo auml atilde asymp aring apos ang and alpha alefsym agrave aelig acute acirc aacute Zeta Yuml Yacute Xi Uuml Upsilon Ugrave Ucirc Uacute Theta Tau THORN Sigma Scaron Rho Psi Prime Pi Phi Ouml Otilde Oslash Omicron Omega Ograve Ocirc Oacute OElig Nu Ntilde Mu Lambda Kappa Iuml Iota Igrave Icirc Iacute Gamma Euml Eta Epsilon Egrave Ecirc Eacute ETH Dstrok Delta Dagger Chi Ccedil Beta Auml Atilde Aring Alpha Agrave Acirc Aacute AElig                             Unable to expand string buffer to %d bytes!                     Bad control character 0x%02x not allowed by XML standard!       Invalid UTF-8 sequence for character 0x%04x! null               Entity name too long under parent <%s>!                         Character entity "%s" not terminated under parent <%s>!         Entity name "%s;" not supported under parent <%s>!              Bad control character 0x%02x under parent <%s> not allowed by XML standard! MXML_CUSTOM MXML_TEXT MXML_REAL MXML_OPAQUE MXML_INTEGER MXML_ELEMENT               Unable to allocate string buffer!                               Bad custom value '%s' in parent <%s>! integer real              Bad %s value '%s' in parent <%s>!                               Unable to add value node of type %s to parent <%s>!  Bare < in element! !-- ![CDATA[ Early EOF in comment node!                 Unable to add comment node to parent <%s>! ]] Early EOF in CDATA node!                          Unable to add CDATA node to parent <%s>!                        Early EOF in processing instruction node!                       Unable to add processing instruction node to parent <%s>!       Early EOF in declaration node!  Unable to add declaration node to parent <%s>! (null)           Mismatched close tag <%s> under parent <%s>!                    Unable to add element node to parent <%s>!                      Expected > but got '%c' instead for element <%s/>!              Missing close tag </%s> under parent <%s>!                      Unable to allocate memory for name!                             Unable to allocate memory for value!                            Expected '>' after '%c' for element %s, but got '%c'! Bare < in element %s!                     Missing value for attribute '%s' in element %s! %d %f           Unable to allocate %d bytes for index - %s                      Unable to allocate %d bytes for index: %s                       ![CDATA[%s]] 1.0                ?xml version="%s" encoding="utf-8"? ![CDATA[ ![CDATA[%s]] mxml: %s
+         |               ABDAAt.    <   !  f   ABDAA}.    `   |!  n   ABDAAi.       !     ABDAAm.       x"     ABDAAi.        |         p#  W   ABDAe.      <   #     ABA     X   $  N   ABDAAg.$   |   $  w   ABD
+AAP.   $      h%     ABD
+AAH.           |        @&  %   AB    0   h&  `   ABGAD.     T   &  <   ABDAf.       x   '  9   ABDf.   $      @'     ABGAA`. (      '     ABGAAH. T. $      \(     ABDAAj. b. $     (     ABD
+AAv. _. $   <  x)  f   ABGAAH.     d  )  B   ABDAAj.       $*  @   ABDAj.          d*  3   ABDAA        *  $   ABDA       *  (   ABDA  $     *  %  ABDAAP.       8  ,  "  ABDAA^.    \  01  I   ABDA[.   $     |1  x   ABDAAD.   $     1  n   ABDAA@.         d2  Q  ABDAAa.     7  W   ABDb.  $     8  |  ABDAAI.       <  9  O  ABDAAY.    `  E    ABD
+AAQ.$     J  |  ABDAA.        $N     AB      @N    ABDAAk.8     \O    ABGJAKALf. V.. {.V. u.       $  @X     ABDAA^.    H  X     ABDAAa.        |         Y  T   ABDA].      <   Y  )   AB    T    Z  r  ABD
+AAv.4   x   t[  r  ABDAA`.T. H.M. H.. ^.      \  $   AB       ]  q   ABDAA`.       ]  c   ABDAAa.$     ]    ABDAAK.           |          _    ABDAAl.    <   `  '  ABDAA[.    `   0a  V   ABDAA`.      a  <   ABDU.         a  O   ABDAA`.      b  6   ABDU.         Lb  S   ABDAAd.     b  2   ABDU.      ,  b  U   ABDAA`.    P  ,c  ]   ABDAAd.   t  c  \   ABA       c  T   ABGAm.      <d  B   ABDf.       d      AB      d  X   ABDAAV.        |          e     ABDAA~.   <   e  W   AB   T   ,f  G   AB        |         f  R   ABDAq.       <   f  ~   ABDAAo.    `   Tg  Z   ABDAAq.      g  "   AB       g  Z   ABDAAq.      0h  "   AB       Th  `   ABDAAq.       h  d   ABDAAq.        |  $       i  v   ABGAAk.    @   i     AB   X   i     AB   p   i     AB      i     AB       i     ABDA].         Pj  0   ABD].        j  &   ABDS.          |        j  *   ABDW.      8   j  {   ABGFAGAH`.               B     e            |     k                  
+   r           $                      |             o]                                          l                        "  2  B  R  b  r                      "  2  B  R  b  r        h%                  h          >r     7r     1r     *r     $r    r     r     r     r    r     r    q  !   q    q     q     q     q     q     q    q    q     q    q     q     q     q    q     q    q    q    q     q    q  R  zq     tq     mq     gq    _q    Xq     Qq     Lq     Hq    Eq    ?q  3   ;q    7q    0q  `  *q    $q      q    q    q     q     q     p    p     p    p     p  x  p    p     p     p     p     p     p  5!  p    l  &   p  '"  p   "  p  '   p     p  H"  p     p     p     p    p     yp     tp  "   pp  )"  ip     cp     ^p     Zp    Up    Op  c&  Jp  E"  Ep     ?p  !  ;p  *"  4p     /p  !  (p      #p  !  p     p    p  f&  p     p     p     o     o     o  "  o     o     o    o  a"  o    o     o     o     o  "  o    o   "  o     o     o     o  D   o    o  e"  l  >   o  !  o  !  }o  e&  vo  &   po     io     co     ]o     Vo     Po  !  Jo  "  Fo  +"  Ao    :o     5o  "  0o     *o    %o  !  o    o  )#  o     o  !  o  #  o     n  d"  n  
+#  n  "  n  %  n     n  9   n     l  <   n     n     n     n     n  "  n    n  "  n     n     n  `"  n  "  n     n  	"  n  "  n     n    n     ~n     xn  S  qn     kn  >   en    ]n    Wn  "  Tn  ("  On     Jn     Cn     <n     5n  "  0n     +n     &n  "  n  0   n  "  n    n    n    n     n     m  2   m  "  m  "  m    l  "   m  !  m  "  m  *#  m     m  !  m  	#  m     m  !  m     m  #  m    m     m  :   m     m     m  a  m  "  m     m     m    zm    vm  <"  om  `&  km  "  fm  "  bm  "  ^m  "  Ym     Tm     Om     Jm  "  Dm     @m    9m  4"  3m    *m    #m  	   m     m    m     m  "!  m  !  l     l  !  l     l     l     l    l    l     l  !  l    l     l     l     l    l     l     et  Xt  Lt  Bt  8t  ,t   GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629  GCC: (GNU) 2.95.3-haiku-090629                              ?      p#                M%      @&  83              F      Y  t              Z       _                
+o       e  s              u      f                       i                0      j             n        ?  [   mxmlElementDeleteAttr   mxmlElementGetAttr   mxmlElementSetAttr R  mxmlElementSetAttrf         ?    ]   mxmlEntityAddCallback   mxmlEntityGetName   mxmlEntityGetValue !  mxmlEntityRemoveCallback v  _mxml_entity_cb        M%  a!  *  mxmlLoadFd :  mxmlLoadFile   mxmlLoadString   mxmlSaveAllocString t  mxmlSaveFd 	  mxmlSaveFile j
+  mxmlSaveString   mxmlSAXLoadFd C  mxmlSAXLoadFile   mxmlSAXLoadString /  mxmlSetCustomHandlers   mxmlSetErrorCallback   mxmlSetWrapMargin     j    F  U  \   mxmlIndexDelete   mxmlIndexEnum   mxmlIndexFind   mxmlIndexNew +  mxmlIndexReset         Z    [   mxmlAdd |  mxmlDelete   mxmlNewCDATA   mxmlNewCustom |  mxmlNewElement   mxmlNewInteger -  mxmlNewOpaque   mxmlNewReal   mxmlNewText D  mxmlNewTextf   mxmlRemove   mxmlNewXML I  mxmlRelease }  mxmlRetain     D    
+o  k    mxmlFindElement   mxmlWalkNext   mxmlWalkPrev         u    Z   mxmlSetCustom t  mxmlSetCDATA   mxmlSetElement   mxmlSetInteger I  mxmlSetOpaque   mxmlSetReal   mxmlSetText #  mxmlSetTextf     y      $  ^   mxml_error   mxml_ignore_cb   mxml_integer_cb   mxml_opaque_cb F  mxml_real_cb z  _mxml_global     3    0  #  ]   _mxml_strdupf    _mxml_vstrdupf     ;       mxml-attr.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629    m#         mxmlElementDeleteAttr 4   !  Unode 2l  name 3r  i 5  Vattr 6  W l  mxml_node_s ,type   # next D  #prev D  #parent D  #child D  #last_child D  #value J  #ref_count   #$user_data   #(    x  }  	char 	int   mxml_attr_s fname g  # value h  #   }  
+D  mxml_type_e UMXML_IGNORE MXML_ELEMENT  MXML_INTEGER MXML_OPAQUE MXML_REAL MXML_TEXT MXML_CUSTOM       mxml_value_u element   integer   opaque   real   text 	  custom D     mxml_element_s lname m  # num_attrs n  #attrs o  # 	double D  mxml_text_s swhitespace t  # string u  # |  mxml_custom_s ydata z  # destroy {  #      |    mxmlElementGetAttr or  !  z!  Unode ml  Pname nr  i p  Vattr q  W R  mxmlElementSetAttr |!  !  Unode l  Wname r  value r  Pvaluec   V   mxmlElementSetAttrf !  x"  Unode l  Wname r  format r  Rap   value   V }  8  mxml_set_attr   x"  m#  Unode l  name  r  value   i   Wattr   V u_long F  	long unsigned int u_int h  	unsigned int u_short   	short unsigned int u_char   	unsigned char ulong F  ushort   uint h  unchar   blkcnt_t   	long long int blksize_t   fsblkcnt_t   fsfilcnt_t   off_t    ino_t !  cnt_t "  dev_t #{  	long int pid_t ${  id_t %{  uid_t 'h  gid_t (h  mode_t )h  umode_t *h  nlink_t +  daddr_t -  caddr_t .  addr_t 0F  key_t 1{  ptrdiff_t v{  size_t F  ssize_t {  wchar_t   wint_t h  clock_t {  time_t {  suseconds_t {  useconds_t F    timespec tv_sec z  # tv_nsec {  #   itimerspec it_interval   # it_value   #   tm ,!tm_sec "  # tm_min #  #tm_hour $  #tm_mday %  #tm_mon &  #tm_year '  #tm_wday (  #tm_yday )  #tm_isdst *  # tm_gmtoff +  #$tm_zone ,  #( __gnuc_va_list G  va_list   fpos_t 6G  g	  _IO_marker i_next pg	  # _sbuf q  #_pos r  # $	    _IO_FILE q_flags v  # _IO_read_ptr {  #_IO_read_end |  #_IO_read_base }  #_IO_write_base ~  #_IO_write_ptr   #_IO_write_end   #_IO_buf_base   #_IO_buf_end   # _IO_save_base   #$_IO_backup_base   #(_IO_save_end   #,_markers g	  #0_chain   #4_fileno   #8_flags2   #<_old_offset G  #@_cur_column   #H_vtable_offset   #J_shortbuf   #K_lock   #L_offset G  #P_codecvt   #X_wide_data   #\_mode   #`_unused2   #d m	  	signed char   }    _IO_codecvt   _IO_wide_data     }  3 _IO_lock_t l_IO_FILE m	  FILE 	m	  L  
+quot 
+	  # rem 
+
+  # div_t 
+&    
+quot 
+{  # rem 
+{  # ldiv_t 
+Y    
+quot 
+  # rem 
+  # lldiv_t 
+    __convert_long_double O__convert_long_double_i P  __convert_long_double_d Q+   +  h   	long double   random_data fptr   # rptr   #state   #rand_type   #rand_deg   #rand_sep   #end_ptr   #   (  drand48_data "x #(  # a $(  #c %  #old_x &(  #init '  # 4     _compare_function M  S  h    h  h   n   !  _ISblank _IScntrl _ISpunct _ISalnum "_ISupper  "_ISlower  "_ISalpha  "_ISdigit  "_ISxdigit  "_ISspace   "_ISprint  @"_ISgraph   
+  mxml_sax_event_e KMXML_SAX_CDATA  MXML_SAX_COMMENT MXML_SAX_DATA MXML_SAX_DIRECTIVE MXML_SAX_ELEMENT_CLOSE MXML_SAX_ELEMENT_OPEN  mxml_sax_event_t R  mxml_type_t ]  mxml_custom_destroy_cb_t _  |  mxml_error_cb_t b      r   mxml_attr_t i  mxml_element_t p  mxml_text_t v	  mxml_custom_t |D  mxml_value_t J  mxml_node_t      mxml_index_s attr   # num_nodes   #alloc_nodes   #cur_node   #nodes   # l  mxml_index_t   mxml_custom_load_cb_t 4  :  O    l  r   mxml_custom_save_cb_t l  r      l   mxml_entity_cb_t         r   mxml_load_cb_t         l   mxml_save_cb_t       r  l     mxml_sax_cb_t "  (  >  l        
+     mxml-entity.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629 p#  3&       mxmlEntityAddCallback -   p#  #  Ucb ,   Pglobal .u  Q int              	   char    
+u  _mxml_global_s  error_cb !  # num_entity_cbs "   #entity_cbs #  #wrap $   #custom_load_cb %j  #custom_save_cb &  #          {      c                 j  mxml_node_s ,type   # next   #prev   #parent   #child   #last_child   #value 
+  #ref_count    #$user_data r  #(             p    mxml_type_e UMXML_IGNORE MXML_ELEMENT  MXML_INTEGER MXML_OPAQUE MXML_REAL MXML_TEXT MXML_CUSTOM    r  mxml_value_u element t  integer    opaque   real   text   custom      mxml_element_s lname m  # num_attrs n   #attrs o  # double   mxml_text_s swhitespace t   # string u  # <  mxml_custom_s ydata zr  # destroy {H  # H  r   <    mxml_attr_s fname g  # value h  # N    mxmlEntityGetName J   #  $  Uval I    !  mxmlEntityGetValue h   $  $  Uname g   i i   Wch j   Pglobal ku  V v  mxmlEntityRemoveCallback ~$  g%  Ucb }   i    Vglobal u  R '  _mxml_entity_cb    h%  3&  Uname    diff    Pcurrent    Wfirst    |last    x  name    # val    # entities 9     4  4    	  	'  u_long L  long unsigned int u_int n  unsigned int u_short   short unsigned int u_char   unsigned char ulong L  ushort   uint n  unchar   blkcnt_t   long long int blksize_t    fsblkcnt_t   fsfilcnt_t   off_t    ino_t !  cnt_t "   dev_t #  long int pid_t $  id_t %  uid_t 'n  gid_t (n  mode_t )n  umode_t *n  nlink_t +   daddr_t -   caddr_t .  addr_t 0L  key_t 1  ptrdiff_t v  size_t L  ssize_t   wchar_t    wint_t n  clock_t   time_t   suseconds_t   useconds_t L    timespec tv_sec   # tv_nsec   # %	  itimerspec it_interval   # it_value   # 	  tm ,!tm_sec "   # tm_min #   #tm_hour $   #tm_mday %   #tm_mon &   #tm_year '   #tm_wday (   #tm_yday )   #tm_isdst *   # tm_gmtoff +   #$tm_zone ,  #( __gnuc_va_list G  va_list 	  fpos_t 6M  m
+  _IO_marker 	i_next 	pm
+  # _sbuf 	q  #_pos 	r   # *
+    _IO_FILE 	q_flags 	v   # _IO_read_ptr 	{  #_IO_read_end 	|  #_IO_read_base 	}  #_IO_write_base 	~  #_IO_write_ptr 	  #_IO_write_end 	  #_IO_buf_base 	  #_IO_buf_end 	  # _IO_save_base 	  #$_IO_backup_base 	  #(_IO_save_end 	  #,_markers 	m
+  #0_chain 	  #4_fileno 	   #8_flags2 	   #<_old_offset 	M  #@_cur_column 	  #H_vtable_offset 	  #J_shortbuf 	  #K_lock 	  #L_offset 	M  #P_codecvt 	  #X_wide_data 	  #\_mode 	   #`_unused2 	  #d s
+  signed char        _IO_codecvt   _IO_wide_data        3 _IO_lock_t 	l_IO_FILE 	s
+  FILE 
+s
+  R  quot 	   # rem 
+   # div_t ,    quot   # rem   # ldiv_t _    quot   # rem   # lldiv_t   %  __convert_long_double O__convert_long_double_i P%  __convert_long_double_d Q1   1  n   long double   random_data fptr   # rptr   #state   #rand_type    #rand_deg    #rand_sep    #end_ptr   #    .  drand48_data "x #.  # a $.  #c %  #old_x &.  #init '   # :     _compare_function S  Y  n     n  n   t    _ISblank _IScntrl _ISpunct _ISalnum _ISupper  _ISlower  _ISalpha  _ISdigit  _ISxdigit  _ISspace   _ISprint  @_ISgraph     mxml_sax_event_e KMXML_SAX_CDATA  MXML_SAX_COMMENT MXML_SAX_DATA MXML_SAX_DIRECTIVE MXML_SAX_ELEMENT_CLOSE MXML_SAX_ELEMENT_OPEN  mxml_sax_event_t R  mxml_type_t ]  mxml_custom_destroy_cb_t _  <  mxml_error_cb_t b  mxml_attr_t iN  mxml_element_t pt  mxml_text_t v  mxml_custom_t |  mxml_value_t 
+  mxml_node_t     mxml_index_s attr   # num_nodes    #alloc_nodes    #cur_node    #nodes   #   mxml_index_t   mxml_custom_load_cb_t (    mxml_custom_save_cb_t K  p  mxml_entity_cb_t   mxml_load_cb_t            mxml_save_cb_t                mxml_sax_cb_t           r   _mxml_global_t '    ]!     mxml-file.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629 @&  xY       mxml_isspace p   @&  e&  Uch o   R int B  mxml_node_s ,type B  # next   #prev   #parent   #child   #last_child   #value   #ref_count    #$user_data (  #(   mxml_type_e UMXML_IGNORE 	MXML_ELEMENT  	MXML_INTEGER 	MXML_OPAQUE 	MXML_REAL 	MXML_TEXT 	MXML_CUSTOM  
+   (  mxml_value_u element   integer    opaque c  real q  text {  custom      mxmlLoadFd   h&  &  Utop   Vfd    Pcb   Qbuf    
+     B     
+    _mxml_fdbuf_s  Xfd Y   # current Z  #end [  #buffer \  # 
+  unsigned char      c  mxml_element_s lname mc  # num_attrs n   #attrs o4  # 
+i  char double   mxml_text_s swhitespace t   # string uc  #   mxml_custom_s ydata z(  # destroy {  #   (   
+  4  mxml_attr_s fname gc  # value hc  # 
+     mxmlLoadFile   &  '  Utop   Vfp   Qcb   R   _IO_FILE q_flags v   # _IO_read_ptr {c  #_IO_read_end |c  #_IO_read_base }c  #_IO_write_base ~c  #_IO_write_ptr c  #_IO_write_end c  #_IO_buf_base c  #_IO_buf_end c  # _IO_save_base c  #$_IO_backup_base c  #(_IO_save_end c  #,_markers   #0_chain 	  #4_fileno    #8_flags2    #<_old_offset   #@_cur_column   #H_vtable_offset .  #J_shortbuf =  #K_lock I  #L_offset   #P_codecvt Y  #X_wide_data o  #\_mode    #`_unused2 u  #d 
+    _IO_marker i_next p  # _sbuf q	  #_pos r   # 
+  
+  off_t short unsigned int signed char I  i    _IO_codecvt 
+K  _IO_wide_data 
+_    i  3   mxmlLoadString   '  ='  Utop   Qs   cb   R 
+  i  L  mxmlSaveAllocString c  @'  '  Unode   cb a  bytes    Pbuffer  g  @s c   a          
+L  t  i     mxmlSaveFd 7   '  Y(  Unode 4  fd 5   Vcb 6a  Wcol 8   Pbuf 9  global :	  P 	  _mxml_global_s  error_cb !	  # num_entity_cbs "   #entity_cbs #	  #wrap $   #custom_load_cb %	  #custom_save_cb &	  # 
+  	     
+	  	  	  c 	        
+	  	          
+	  	  c     
+	  j
+  mxmlSaveFile g   \(  (  Unode d  Wfp e  cb fa  Vcol h   Pglobal i	  P   mxmlSaveString    (  w)  Unode   buffer c  bufsize    cb a  Vcol    Pptr   xglobal 	  P   c     mxmlSAXLoadFd   x)  )  Utop   fd    Pcb   Wsax_cb =  Qsax_data (  Rbuf          (   =  mxml_sax_event_e K	MXML_SAX_CDATA  	MXML_SAX_COMMENT 	MXML_SAX_DATA 	MXML_SAX_DIRECTIVE 	MXML_SAX_ELEMENT_CLOSE 	MXML_SAX_ELEMENT_OPEN  
+    mxmlSAXLoadFile   )  "*  Utop    Wfp   Vcb   Qsax_cb =  Rsax_data (  P /  mxmlSAXLoadString +  $*  d*  Utop &  Vs '  cb (  Qsax_cb )=  Rsax_data *(  P   mxmlSetCustomHandlers Cd*  *  Uload A	  Vsave B	  Wglobal D	  P   mxmlSetErrorCallback S*  *  Ucb R  Vglobal T	  P 
+	     mxmlSetWrapMargin f*  *  Ucolumn e   Vglobal g	  P   mxml_add_char x   *  	,  Uch t   Wbufptr u  Vbuffer v  bufsize w  newbuffer yc  R 
+c  
+   N  mxml_fd_getc    ,  .1  Up (  encoding   Wbuf N  ch    Vtemp    R1  /  =0  lch    W M  0  "1  lch    W  
+    mxml_fd_putc    01  y1  Uch    Pp (  buf N  V   mxml_fd_read    |1  1  Ubuf N  Wbytes    P 6  mxml_fd_write >   1  b2  Ubuf =N  Wbytes ?   Pptr @  V   mxml_file_getc j   d2  7  Up h(  encoding i  Wch k   Vtemp l   Pfp m    l6  6  lch    R   /7  7  lch (   R    mxml_file_putc A   7  8  Uch ?   Qp @(  R   mxml_get_entity P   8  9  Uparent K  p L(  encoding M  getc_cb N  ch Q   Ventity R  @entptr Sc        (     
+    i  ? R  mxml_load_data   9  E  Utop   p (  cb   getc_cb R  sax_cb =  sax_data (   error E  node   Vfirst   lparent   hch    Pwhitespace    dbuffer c  pbufptr c  |bufsize    ttype B  `encoding    xglobal 	  \types i     
+  d  d     X  _  mxml_parse_element    E  J  Unode   p (  encoding   getc_cb R   error 	J  ch    Vquote    Wname c  xvalue c  lptr c  tnamesize    |valsize    p   mxml_string_getc 	   J  $N  Up 	(  Wencoding 	  ch 	   Qs 	    HM  M  lch 	   R   M  N  lch 	   R  
+  M  mxml_string_putc 
+   $N  >N  Uch 
+   Pp 
+(  pp 
+  R   mxml_write_name -
+   @N  YO  Us )
+  Vp *
+(  putc_cb +
+  quote .
+i  name /
+  W         (   
+    mxml_write_node z
+   \O  @X  Unode t
+  p u
+(  cb v
+a  col w
+   Wputc_cb x
+  global y
+	  i {
+   }width |
+   Vattr }
+4  }s ~
+  ~  7P  cP  ptr 
+  V   1W  X  data `c  Vnewline a  P  
+    i   a  mxml_write_string    @X  X  Us   Wp (  putc_cb   name   V   mxml_write_ws    X  xY  Unode   Pp (  cb a  Rws    Pcol    Vputc_cb   s   W !u_long   long unsigned int !u_int   unsigned int !u_short   !u_char   !ulong   !ushort   !uint   !unchar   !blkcnt_t   long long int !blksize_t    !fsblkcnt_t   !fsfilcnt_t   !off_t    !ino_t !  !cnt_t "   !dev_t #  long int !pid_t $  !id_t %  !uid_t '  !gid_t (  !mode_t )  !umode_t *  !nlink_t +   !daddr_t -   !caddr_t .c  !addr_t 0  !key_t 1  !ptrdiff_t v  !size_t   !ssize_t   !wchar_t    "wint_t   !clock_t   !time_t   !suseconds_t   !useconds_t   m  timespec tv_sec   # tv_nsec   #   itimerspec it_interval 8  # it_value 8  # |  tm ,!tm_sec "   # tm_min #   #tm_hour $   #tm_mday %   #tm_mon &   #tm_year '   #tm_wday (   #tm_yday )   #tm_isdst *   # tm_gmtoff +   #$tm_zone ,c  #( !__gnuc_va_list Gc  !va_list |  !fpos_t 	6  #_IO_lock_t l!_IO_FILE   !FILE 
+  $_single_threaded i  %  quot 	   # rem 
+   # !div_t   %L  quot   # rem   # !ldiv_t &  %  quot   # rem   # !lldiv_t Z    __convert_long_double O__convert_long_double_i P  __convert_long_double_d Q        long double   random_data fptr   # rptr   #state   #rand_type    #rand_deg    #rand_sep    #end_ptr   #   drand48_data "x #  # a $  #c %  #old_x &  #init '   #      !_compare_function   
+  /     /  /   
+5  &'  	_ISblank 	_IScntrl 	_ISpunct 	_ISalnum (_ISupper  (_ISlower  (_ISalpha  (_ISdigit  (_ISxdigit  (_ISspace   (_ISprint  @(_ISgraph   $__ctype_b ,  
+    !mxml_sax_event_t R  !mxml_type_t ]B  !mxml_custom_destroy_cb_t _5  
+  !mxml_error_cb_t b	  !mxml_attr_t i   !mxml_element_t p  !mxml_text_t v{  !mxml_custom_t |  !mxml_value_t   !mxml_node_t    <   mxml_index_s attr c  # num_nodes    #alloc_nodes    #cur_node    #nodes <   # 
+  !mxml_index_t   !mxml_custom_load_cb_t s   
+	  !mxml_custom_save_cb_t    
+	  !mxml_entity_cb_t 	  !mxml_load_cb_t    
+  !mxml_save_cb_t    
+L  !mxml_sax_cb_t !  
+  !_mxml_global_t '  !_mxml_getc_cb_t T  !_mxml_putc_cb_t U  !_mxml_fdbuf_t ]   Q   .  mxml-index.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629 Y  ^  P(     mxmlIndexDelete 8Y  Y  Uind 7   V    mxml_index_s attr   # num_nodes   #alloc_nodes   #cur_node   #nodes   #      char int   mxml_node_s ,type   # next N  #prev N  #parent N  #child N  #last_child N  #value T  #ref_count   #$user_data   #(     N  mxml_type_e U	MXML_IGNORE 
+MXML_ELEMENT  
+MXML_INTEGER 
+MXML_OPAQUE 
+MXML_REAL 
+MXML_TEXT 
+MXML_CUSTOM      mxml_value_u element   integer   opaque   real 	  text   custom N   	  mxml_element_s lname m  # num_attrs n  #attrs o  # double N  mxml_text_s swhitespace t  # string u  #   mxml_custom_s ydata z  # destroy {  #          mxml_attr_s fname g  # value h  #     mxmlIndexEnum V  Y  Y  Uind U   R   mxmlIndexFind v   Z  r[  Uind s   Welement t  value u  diff w  Pcurrent x  Vfirst y  |last z  x     +  mxmlIndexNew -   t[  \  Unode *  element +  attr ,  ind .   Vcurrent /  Wtemp 0  P a  mxmlIndexReset   \  ]  Uind    P   index_compare   ]  }]  Uind    Wfirst   second   Vdiff   P 7  index_find   ]  ]  Uind    Pelement   Rvalue   Wnode   Vdiff   P   index_sort @]  ^  Uind =   left >  right ?  pivot A  |temp B  Qtempl C  Wtempr D  V u_long   long unsigned int u_int   unsigned int u_short   short unsigned int u_char 9  unsigned char ulong   ushort   uint   unchar 9  blkcnt_t   long long int blksize_t   fsblkcnt_t   fsfilcnt_t   off_t    ino_t !  cnt_t "  dev_t #	  long int pid_t $	  id_t %	  uid_t '  gid_t (  mode_t )  umode_t *  nlink_t +  daddr_t -  caddr_t .  addr_t 0  key_t 1	  ptrdiff_t v	  size_t   ssize_t 	  wchar_t   wint_t   clock_t 	  time_t 	  suseconds_t 	  useconds_t   p	  timespec tv_sec 	  # tv_nsec 	  # 	  itimerspec it_interval ;	  # it_value ;	  # 
+  tm ,!tm_sec "  # tm_min #  #tm_hour $  #tm_mday %  #tm_mon &  #tm_year '  #tm_wday (  #tm_yday )  #tm_isdst *  # tm_gmtoff +  #$tm_zone ,  #( __gnuc_va_list G  va_list 
+  fpos_t 6  
+  _IO_marker i_next p
+  # _sbuf q1  #_pos r  # 
+  1  _IO_FILE q_flags v  # _IO_read_ptr {  #_IO_read_end |  #_IO_read_base }  #_IO_write_base ~  #_IO_write_ptr   #_IO_write_end   #_IO_buf_base   #_IO_buf_end   # _IO_save_base   #$_IO_backup_base   #(_IO_save_end   #,_markers 
+  #0_chain 1  #4_fileno   #8_flags2   #<_old_offset   #@_cur_column   #H_vtable_offset 7  #J_shortbuf F  #K_lock R  #L_offset   #P_codecvt b  #X_wide_data x  #\_mode   #`_unused2 ~  #d 
+  signed char R      _IO_codecvt T  _IO_wide_data h      3 _IO_lock_t l_IO_FILE 
+  FILE 	
+    
+quot 
+	  # rem 
+
+  # div_t 
+    
+quot 
+	  # rem 
+	  # ldiv_t 
+  A  
+quot 
+  # rem 
+  # lldiv_t 
+    __convert_long_double O__convert_long_double_i P  __convert_long_double_d Q        long double W  random_data fptr W  # rptr W  #state W  #rand_type   #rand_deg   #rand_sep   #end_ptr W  #     drand48_data "x #  # a $  #c %  #old_x &  #init '  #      _compare_function                 !  
+_ISblank 
+_IScntrl 
+_ISpunct 
+_ISalnum "_ISupper  "_ISlower  "_ISalpha  "_ISdigit  "_ISxdigit  "_ISspace   "_ISprint  @"_ISgraph   '  mxml_sax_event_e K
+MXML_SAX_CDATA  
+MXML_SAX_COMMENT 
+MXML_SAX_DATA 
+MXML_SAX_DIRECTIVE 
+MXML_SAX_ELEMENT_CLOSE 
+MXML_SAX_ELEMENT_OPEN  mxml_sax_event_t R  mxml_type_t ]  mxml_custom_destroy_cb_t _r    mxml_error_cb_t b         mxml_attr_t i  mxml_element_t p  mxml_text_t v  mxml_custom_t |N  mxml_value_t T  mxml_node_t   mxml_index_t    mxml_custom_load_cb_t J  P  e         mxml_custom_save_cb_t            mxml_entity_cb_t            mxml_load_cb_t       ?     mxml_save_cb_t     #         mxml_sax_cb_t 8  >  T    '           mxml-node.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629  _  d  .     mxmlAdd D _  `  Uparent @e  Wwhere Ak  child Be  node Ce  V e  mxml_node_s ,type r  # next   #prev   #parent   #child   #last_child   #value   #ref_count k  #$user_data X  #(    int   mxml_type_e U	MXML_IGNORE 
+MXML_ELEMENT  
+MXML_INTEGER 
+MXML_OPAQUE 
+MXML_REAL 
+MXML_TEXT 
+MXML_CUSTOM     X  mxml_value_u element Z  integer k  opaque   real   text   custom      mxml_element_s lname m  # num_attrs nk  #attrs ov  #   char double   mxml_text_s swhitespace tk  # string u  # 0  mxml_custom_s ydata zX  # destroy {<  # <  X   0  v  mxml_attr_s fname g  # value h  # B    mxmlDelete `  /a  Unode e  Vi k  W 	  mxmlNewCDATA 'e  0a  a  Uparent %e  Pdata &	  Wnode (e  V     |  mxmlNewCustom Re  a  a  Uparent Oe  Pdata PX  Pdestroy Q<  Pnode Se  R   mxmlNewElement te  a  b  Uparent re  Pname s	  Wnode ue  V -  mxmlNewInteger e  b  Jb  Uparent e  Pinteger k  Pnode e  R   mxmlNewOpaque e  Lb  b  Uparent e  Popaque 	  Wnode e  V   mxmlNewReal e  b  b  Uparent e  Preal   [node e  P D  mxmlNewText  e  b  )c  Uparent e  Pwhitespace k  Pstring 	  Wnode e  V   mxmlNewTextf -e  ,c  c  Uparent )e  Pwhitespace *k  Pformat +	  Wnode .e  Vap /       mxmlRemove Yc  c  Unode Xe  Q <  mxmlNewXML e  c  <d  Uversion 	  element <  x I     }  mxmlRelease k  <d  ~d  Unode e  R   mxmlRetain k  d  d  Unode e  R    mxml_new e  d  d  Uparent e  Wtype r  Pnode e  V u_long   long unsigned int u_int 0  unsigned int u_short O  short unsigned int u_char s  unsigned char ulong   ushort O  uint 0  unchar s  blkcnt_t   long long int blksize_t k  fsblkcnt_t   fsfilcnt_t   off_t    ino_t !  cnt_t "k  dev_t #C	  long int pid_t $C	  id_t %C	  uid_t '0  gid_t (0  mode_t )0  umode_t *0  nlink_t +k  daddr_t -k  caddr_t .  addr_t 0  key_t 1C	  ptrdiff_t vC	  size_t   ssize_t C	  wchar_t k  wint_t 0  clock_t C	  time_t C	  suseconds_t C	  useconds_t   
+  timespec tv_sec B
+  # tv_nsec C	  # 
+  itimerspec it_interval u
+  # it_value u
+  #   tm ,!tm_sec "k  # tm_min #k  #tm_hour $k  #tm_mday %k  #tm_mon &k  #tm_year 'k  #tm_wday (k  #tm_yday )k  #tm_isdst *k  # tm_gmtoff +k  #$tm_zone ,  #( __gnuc_va_list G  va_list   fpos_t 6	  /  _IO_marker i_next p/  # _sbuf qk  #_pos rk  #   k  _IO_FILE q_flags vk  # _IO_read_ptr {  #_IO_read_end |  #_IO_read_base }  #_IO_write_base ~  #_IO_write_ptr   #_IO_write_end   #_IO_buf_base   #_IO_buf_end   # _IO_save_base   #$_IO_backup_base   #(_IO_save_end   #,_markers /  #0_chain k  #4_fileno k  #8_flags2 k  #<_old_offset 	  #@_cur_column O  #H_vtable_offset q  #J_shortbuf   #K_lock   #L_offset 	  #P_codecvt   #X_wide_data   #\_mode k  #`_unused2   #d 5  signed char       _IO_codecvt   _IO_wide_data       3 _IO_lock_t l_IO_FILE 5  FILE 	5     
+quot 
+	k  # rem 
+
+k  # div_t 
+   G  
+quot 
+C	  # rem 
+C	  # ldiv_t 
+!   {  
+quot 
+  # rem 
+  # lldiv_t 
+U    __convert_long_double O__convert_long_double_i P  __convert_long_double_d Q     0   long double   random_data fptr   # rptr   #state   #rand_type k  #rand_deg k  #rand_sep k  #end_ptr   # k    drand48_data "x #  # a $  #c %O  #old_x &  #init 'k  #   O   _compare_function     !0  k  0  0   6  "#  
+_ISblank 
+_IScntrl 
+_ISpunct 
+_ISalnum $_ISupper  $_ISlower  $_ISalpha  $_ISdigit  $_ISxdigit  $_ISspace   $_ISprint  @$_ISgraph   a  mxml_sax_event_e K
+MXML_SAX_CDATA  
+MXML_SAX_COMMENT 
+MXML_SAX_DATA 
+MXML_SAX_DIRECTIVE 
+MXML_SAX_ELEMENT_CLOSE 
+MXML_SAX_ELEMENT_OPEN  mxml_sax_event_t R  mxml_type_t ]r  mxml_custom_destroy_cb_t _  0  mxml_error_cb_t b      	   mxml_attr_t iB  mxml_element_t pZ  mxml_text_t v  mxml_custom_t |  mxml_value_t   mxml_node_t      mxml_index_s attr   # num_nodes k  #alloc_nodes k  #cur_node k  #nodes   # e  mxml_index_t S  mxml_custom_load_cb_t     !  k  e  	   mxml_custom_save_cb_t 4  :  !J    e   mxml_entity_cb_t b  h  !x  k  	   mxml_load_cb_t     !  y  e   mxml_save_cb_t     !  	  e  k   mxml_sax_cb_t       e  a  X    g     mxml-search.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629  e  sf  /6    mxml_node_s ,type   # next   #prev   #parent   #child   #last_child   #value   #ref_count   #$user_data   #(   mxml_type_e UMXML_IGNORE MXML_ELEMENT  MXML_INTEGER MXML_OPAQUE MXML_REAL MXML_TEXT MXML_CUSTOM  ]     mxml_value_u 	element   	integer   	opaque   	real   	text   	custom <   
+int   mxmlFindElement 6   e  e  Unode 0  Vtop 1  name 2  attr 3  value 4  Wdescend 5  temp 7  P ]       
+char   mxml_element_s lname m  # num_attrs n  #attrs o  #   
+double <  mxml_text_s swhitespace t  # string u  # t  mxml_custom_s ydata z  # destroy {  #      t    mxml_attr_s fname g  # value h  #     mxmlWalkNext   e  +f  Unode   Ptop   Qdescend    d  mxmlWalkPrev   ,f  sf  Unode   Ptop   Qdescend    u_long r  
+long unsigned int u_int   
+unsigned int u_short   
+short unsigned int u_char   
+unsigned char ulong r  ushort   uint   unchar   blkcnt_t -  
+long long int blksize_t   fsblkcnt_t -  fsfilcnt_t -  off_t  -  ino_t !-  cnt_t "  dev_t #  
+long int pid_t $  id_t %  uid_t '  gid_t (  mode_t )  umode_t *  nlink_t +  daddr_t -  caddr_t .  addr_t 0r  key_t 1  ptrdiff_t v  size_t r  ssize_t   wchar_t   wint_t   clock_t   time_t   suseconds_t   useconds_t r    timespec tv_sec   # tv_nsec   # K  itimerspec it_interval   # it_value   #   tm ,!tm_sec "  # tm_min #  #tm_hour $  #tm_mday %  #tm_mon &  #tm_year '  #tm_wday (  #tm_yday )  #tm_isdst *  # tm_gmtoff +  #$tm_zone ,  #( __gnuc_va_list G  va_list   fpos_t 6s    _IO_marker i_next p  # _sbuf q
+  #_pos r  # P  
+  _IO_FILE q_flags v  # _IO_read_ptr {  #_IO_read_end |  #_IO_read_base }  #_IO_write_base ~  #_IO_write_ptr   #_IO_write_end   #_IO_buf_base   #_IO_buf_end   # _IO_save_base   #$_IO_backup_base   #(_IO_save_end   #,_markers   #0_chain 
+  #4_fileno   #8_flags2   #<_old_offset s  #@_cur_column   #H_vtable_offset 
+  #J_shortbuf 
+  #K_lock 
+  #L_offset s  #P_codecvt    #X_wide_data   #\_mode   #`_unused2   #d   
+signed char 
+      _IO_codecvt 
+  _IO_wide_data   (    3 _IO_lock_t l_IO_FILE   FILE 	  x  
+quot 
+	  # rem 
+
+  # div_t 
+R    
+quot 
+  # rem 
+  # ldiv_t 
+    
+quot 
+-  # rem 
+-  # lldiv_t 
+  K  __convert_long_double O	__convert_long_double_i PK  	__convert_long_double_d QW   W     
+long double   random_data fptr   # rptr   #state   #rand_type   #rand_deg   #rand_sep   #end_ptr   #   T  drand48_data "x #T  # a $T  #c %  #old_x &T  #init '  # `     _compare_function y               1  _ISblank _IScntrl _ISpunct _ISalnum _ISupper  _ISlower  _ISalpha  _ISdigit  _ISxdigit  _ISspace   _ISprint  @_ISgraph     mxml_sax_event_e KMXML_SAX_CDATA  MXML_SAX_COMMENT MXML_SAX_DATA MXML_SAX_DIRECTIVE MXML_SAX_ELEMENT_CLOSE MXML_SAX_ELEMENT_OPEN  mxml_sax_event_t R1  mxml_type_t ]  mxml_custom_destroy_cb_t _  t  mxml_error_cb_t b-  3  ?     mxml_attr_t i  mxml_element_t p  mxml_text_t v  mxml_custom_t |<  mxml_value_t   mxml_node_t ]   )  mxml_index_s attr   # num_nodes   #alloc_nodes   #cur_node   #nodes )  #   mxml_index_t   mxml_custom_load_cb_t `  f  {         mxml_custom_save_cb_t            mxml_entity_cb_t            mxml_load_cb_t            mxml_save_cb_t   $  9         mxml_sax_cb_t N  T  j             	  mxml-set.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629 f  i  :     mxmlSetCustom 3   f  f  Unode 0d  Vdata 1j  Pdestroy 2x  P int d  mxml_node_s ,type ~  # next   #prev   #parent   #child   #last_child   #value   #ref_count    #$user_data j  #(    	x  
+j   l    mxml_type_e UMXML_IGNORE MXML_ELEMENT  MXML_INTEGER MXML_OPAQUE MXML_REAL MXML_TEXT MXML_CUSTOM     d  mxml_value_u element d  integer    opaque   real   text   custom      mxml_element_s lname m  # num_attrs n   #attrs on  #   char double   mxml_text_s swhitespace t   # string u  # :  mxml_custom_s ydata zj  # destroy {x  # n  mxml_attr_s fname g  # value h  # :    mxmlSetCDATA T   f  Rg  Unode Rd  Vdata S  W       mxmlSetElement s   Tg  g  Unode qd  Vname r  W I  mxmlSetInteger    g  g  Unode d  Rinteger    P   mxmlSetOpaque    g  .h  Unode d  Vopaque   W   mxmlSetReal    0h  Rh  Unode d  Preal   [ #  mxmlSetText    Th  h  Unode d  Vwhitespace    Pstring   W   mxmlSetTextf    h  i  Unode d  Vwhitespace    Pformat   Wap      u_long   long unsigned int u_int   unsigned int u_short   short unsigned int u_char   unsigned char ulong   ushort   uint   unchar   blkcnt_t Y  long long int blksize_t    fsblkcnt_t Y  fsfilcnt_t Y  off_t  Y  ino_t !Y  cnt_t "   dev_t #  long int pid_t $  id_t %  uid_t '  gid_t (  mode_t )  umode_t *  nlink_t +   daddr_t -   caddr_t .  addr_t 0  key_t 1  ptrdiff_t v  size_t   ssize_t   wchar_t    wint_t   clock_t   time_t   suseconds_t   useconds_t   :  timespec tv_sec   # tv_nsec   # w  itimerspec it_interval   # it_value   # I	  tm ,!tm_sec "   # tm_min #   #tm_hour $   #tm_mday %   #tm_mon &   #tm_year '   #tm_wday (   #tm_yday )   #tm_isdst *   # tm_gmtoff +   #$tm_zone ,  #( __gnuc_va_list G  va_list I	  fpos_t 6  	  _IO_marker i_next p	  # _sbuf q  #_pos r   # |	    _IO_FILE q_flags v   # _IO_read_ptr {  #_IO_read_end |  #_IO_read_base }  #_IO_write_base ~  #_IO_write_ptr   #_IO_write_end   #_IO_buf_base   #_IO_buf_end   # _IO_save_base   #$_IO_backup_base   #(_IO_save_end   #,_markers 	  #0_chain   #4_fileno    #8_flags2    #<_old_offset   #@_cur_column   #H_vtable_offset   #J_shortbuf   #K_lock   #L_offset   #P_codecvt ,  #X_wide_data B  #\_mode    #`_unused2 H  #d 	  signed char       _IO_codecvt   _IO_wide_data 2  T    3 _IO_lock_t l_IO_FILE 	  FILE 		    
+quot 
+	   # rem 
+
+   # div_t 
+~    
+quot 
+  # rem 
+  # ldiv_t 
+    
+quot 
+Y  # rem 
+Y  # lldiv_t 
+  w  __convert_long_double O__convert_long_double_i Pw  __convert_long_double_d Q        long double !  random_data fptr !  # rptr !  #state !  #rand_type    #rand_deg    #rand_sep    #end_ptr !  #      drand48_data "x #  # a $  #c %  #old_x &  #init '   #      _compare_function          
+  
+     ]  _ISblank _IScntrl _ISpunct _ISalnum _ISupper  _ISlower  _ISalpha  _ISdigit  _ISxdigit  _ISspace   _ISprint  @_ISgraph     mxml_sax_event_e KMXML_SAX_CDATA  MXML_SAX_COMMENT MXML_SAX_DATA MXML_SAX_DIRECTIVE MXML_SAX_ELEMENT_CLOSE MXML_SAX_ELEMENT_OPEN  mxml_sax_event_t R]  mxml_type_t ]~  mxml_custom_destroy_cb_t _<  l  mxml_error_cb_t bY  _  	k  
+   mxml_attr_t i:  mxml_element_t pd  mxml_text_t v  mxml_custom_t |  mxml_value_t   mxml_node_t    U  mxml_index_s attr   # num_nodes    #alloc_nodes    #cur_node    #nodes U  # d  mxml_index_t   mxml_custom_load_cb_t          
+d  
+   mxml_custom_save_cb_t         
+d   mxml_entity_cb_t          
+   mxml_load_cb_t   $  4  	  
+d   mxml_save_cb_t J  P  e    
+d  
+    mxml_sax_cb_t z    	  
+d  
+  
+j        s  mxml-private.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629  i  j  >     mxml_error ) i  i  Uformat '   Vap *   s +   xglobal ,y  W       	char    
+       y  _mxml_global_s  error_cb !  # num_entity_cbs "  #entity_cbs #  #wrap $  #custom_load_cb %  #custom_save_cb &  #            	int 
+    c                         mxml_node_s ,type   # next   #prev   #parent   #child   #last_child   #value %  #ref_count   #$user_data   #(                 mxml_type_e UMXML_IGNORE MXML_ELEMENT  MXML_INTEGER MXML_OPAQUE MXML_REAL MXML_TEXT MXML_CUSTOM      mxml_value_u element   integer   opaque   real   text   custom      mxml_element_s lname m  # num_attrs n  #attrs o  # 	double   mxml_text_s swhitespace t  # string u  # W  mxml_custom_s ydata z  # destroy {c  # c     W    mxml_attr_s fname g  # value h  # i    mxml_ignore_cb R  i  i  Unode Q     mxml_integer_cb _  i  i  Unode ^   F  mxml_opaque_cb l  i  i  Unode k   z  mxml_real_cb y  i  i  Unode x     _mxml_global y  i  Pj  Uglobal y  V _mxml_init Pj  j  U  _mxml_destructor j  j  Ug   P u_long   	long unsigned int u_int '  	unsigned int u_short F  	short unsigned int u_char j  	unsigned char ulong   ushort F  uint '  unchar j  blkcnt_t   	long long int blksize_t   fsblkcnt_t   fsfilcnt_t   off_t    ino_t !  cnt_t "  dev_t #:  	long int pid_t $:  id_t %:  uid_t ''  gid_t ('  mode_t )'  umode_t *'  nlink_t +  daddr_t -  caddr_t .  addr_t 0  key_t 1:  ptrdiff_t v:  size_t   ssize_t :  wchar_t   wint_t '  clock_t :  time_t :  suseconds_t :  useconds_t     timespec tv_sec 9  # tv_nsec :  #   itimerspec it_interval l  # it_value l  # 	  tm ,!tm_sec "  # tm_min #  #tm_hour $  #tm_mday %  #tm_mon &  #tm_year '  #tm_wday (  #tm_yday )  #tm_isdst *  # tm_gmtoff +  #$tm_zone ,  #( __gnuc_va_list G  va_list 	  fpos_t 6  &
+  _IO_marker 	i_next 	p&
+  # _sbuf 	qb  #_pos 	r  # 	  b  _IO_FILE 	q_flags 	v  # _IO_read_ptr 	{  #_IO_read_end 	|  #_IO_read_base 	}  #_IO_write_base 	~  #_IO_write_ptr 	  #_IO_write_end 	  #_IO_buf_base 	  #_IO_buf_end 	  # _IO_save_base 	  #$_IO_backup_base 	  #(_IO_save_end 	  #,_markers 	&
+  #0_chain 	b  #4_fileno 	  #8_flags2 	  #<_old_offset 	  #@_cur_column 	F  #H_vtable_offset 	h  #J_shortbuf 	w  #K_lock 	  #L_offset 	  #P_codecvt 	  #X_wide_data 	  #\_mode 	  #`_unused2 	  #d ,
+  	signed char 
+       _IO_codecvt   _IO_wide_data   
+     3 _IO_lock_t 	l_IO_FILE 	,
+  FILE 
+,
+   stderr <    !!  quot 	  # rem 
+  # div_t   !T  quot :  # rem :  # ldiv_t .  !  quot   # rem   # lldiv_t b    __convert_long_double O__convert_long_double_i P  __convert_long_double_d Q    
+   '   	long double   random_data fptr   # rptr   #state   #rand_type   #rand_deg   #rand_sep   #end_ptr   #     drand48_data "x #  # a $  #c %F  #old_x &  #init '  # 
+	  F   _compare_function "  (  =    =  =   C  "#  _ISblank _IScntrl _ISpunct _ISalnum $_ISupper  $_ISlower  $_ISalpha  $_ISdigit  $_ISxdigit  $_ISspace   $_ISprint  @$_ISgraph   n  mxml_sax_event_e KMXML_SAX_CDATA  MXML_SAX_COMMENT MXML_SAX_DATA MXML_SAX_DIRECTIVE MXML_SAX_ELEMENT_CLOSE MXML_SAX_ELEMENT_OPEN  mxml_sax_event_t R  mxml_type_t ]  mxml_custom_destroy_cb_t _  W  mxml_error_cb_t b  mxml_attr_t ii  mxml_element_t p  mxml_text_t v  mxml_custom_t |  mxml_value_t %  mxml_node_t     mxml_index_s attr   # num_nodes   #alloc_nodes   #cur_node   #nodes   #   mxml_index_t N  mxml_custom_load_cb_t     mxml_custom_save_cb_t     mxml_entity_cb_t   mxml_load_cb_t N  T  d       mxml_save_cb_t z              mxml_sax_cb_t         n     _mxml_global_t '   int8_t h  uint8_t j  int16_t   	short int uint16_t F  int32_t   uint32_t '  int64_t   uint64_t c  	long long unsigned int int_least8_t   uint_least8_t   int_least16_t   uint_least16_t   int_least32_t %  uint_least32_t  4  int_least64_t "D  uint_least64_t #S  int_fast8_t &%  uint_fast8_t '4  int_fast16_t )%  uint_fast16_t *4  int_fast32_t ,%  uint_fast32_t -4  int_fast64_t /D  uint_fast64_t 0S  intptr_t 3%  uintptr_t 44  intmax_t 7  uintmax_t 8c  u_int8_t   u_int16_t   u_int32_t 4  u_int64_t S  _pthread_thread pthread_t q  N  _pthread_attr pthread_attr_t   w    _pthread_mutex flags 4  # count  %  #sem !%  #owner "%  #owner_count #%  # pthread_mutex_t   _pthread_mutexattr pthread_mutexattr_t V  &    _pthread_cond flags '4  # sem (%  #mutex )  #waiter_count *%  #event_counter +%  #   pthread_cond_t \  _pthread_condattr pthread_condattr_t     pthread_key_t   \  _pthread_once state /%  #  pthread_once_t 5    _pthread_rwlock  flags 34  # owner 4%  #%  # &  @shared 8  local ?   !  8sem 7%  #  !_  ?lock_sem :%  # lock_count ;%  #reader_count <%  #writer_count =%  #waiters >_  # 
+k     pthread_rwlock_t r  _pthread_rwlockattr pthread_rwlockattr_t     ;  pthread_mutex_type CPTHREAD_MUTEX_DEFAULT  PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECK PTHREAD_MUTEX_RECURSIVE    pthread_process_shared JPTHREAD_PROCESS_PRIVATE  PTHREAD_PROCESS_SHARED    __pthread_cleanup_handler mprevious n  # function o  #argument p  #   _mxml_key      _mxml_key_once \        J  mxml-string.c /boot/home/Desktop/mxml-2.6 GNU C 2.95.3-haiku-090629 j  Wk  ~B     _mxml_strdupf W   j  j  Uformat U   Rap X   s Y   P    char    	      
+B  _mxml_vstrdupf    j  Wk  Uformat    ap    bytes B  Pbuffer    Vtemp I  ~ int U      u_long c  long unsigned int u_int   unsigned int u_short   short unsigned int u_char   unsigned char ulong c  ushort   uint   unchar   blkcnt_t   long long int blksize_t B  fsblkcnt_t   fsfilcnt_t   off_t    ino_t !  cnt_t "B  dev_t #  long int pid_t $  id_t %  uid_t '  gid_t (  mode_t )  umode_t *  nlink_t +B  daddr_t -B  caddr_t .   addr_t 0c  key_t 1  ptrdiff_t v  size_t c  ssize_t   wchar_t B  wint_t   clock_t   time_t   suseconds_t   useconds_t c    timespec tv_sec   # tv_nsec   # <  itimerspec it_interval   # it_value   #   tm ,!tm_sec "B  # tm_min #B  #tm_hour $B  #tm_mday %B  #tm_mon &B  #tm_year 'B  #tm_wday (B  #tm_yday )B  #tm_isdst *B  # tm_gmtoff +B  #$tm_zone ,   #( __gnuc_va_list G   va_list   fpos_t 6d    _IO_marker i_next p  # _sbuf q  #_pos rB  # A    _IO_FILE q_flags vB  # _IO_read_ptr {   #_IO_read_end |   #_IO_read_base }   #_IO_write_base ~   #_IO_write_ptr    #_IO_write_end    #_IO_buf_base    #_IO_buf_end    # _IO_save_base    #$_IO_backup_base    #(_IO_save_end    #,_markers   #0_chain   #4_fileno B  #8_flags2 B  #<_old_offset d  #@_cur_column   #H_vtable_offset   #J_shortbuf   #K_lock   #L_offset d  #P_codecvt   #X_wide_data   #\_mode B  #`_unused2   #d   signed char        _IO_codecvt   _IO_wide_data        3 _IO_lock_t l_IO_FILE   FILE   i  	quot 		B  # rem 	
+B  # div_t 	C    	quot 	  # rem 	  # ldiv_t 	v    	quot 	  # rem 	  # lldiv_t 	  <	  __convert_long_double 
+O__convert_long_double_i 
+P<	  __convert_long_double_d 
+QH	   H	     long double 	  random_data fptr 	  # rptr 	  #state 	  #rand_type B  #rand_deg B  #rand_sep B  #end_ptr 	  # B  E
+  drand48_data "x #E
+  # a $E
+  #c %  #old_x &E
+  #init 'B  # Q
+     _compare_function j
+  p
+  
+  B  
+  
+   
+  "  _ISblank _IScntrl _ISpunct _ISalnum _ISupper  _ISlower  _ISalpha  _ISdigit  _ISxdigit  _ISspace   _ISprint  @_ISgraph    %  .?:;'@
+   :;I
+  4 :;I
+  :;   :;I8
+   I  & I  	$ >  
+:;  (   (   :;   :;I     '   I  .?:;'I@
+     4 :;I  .:;'I@
+   :;I
+  4 :;I
+   :;I   :;I  I  ! /   <   :;  :;  'I   &   !:;  "(    %  .?:;'I@
+   :;I
+  4 :;I
+  $ >  'I   I   I  	& I  
+:;   :;I8
+  '  I  ! /  :;  :;  (   (   :;   :;I     .?:;'@
+  :;  ! /   :;I   :;I   <   :;  &   :;  (    %  .:;'I@
+   :;I
+  $ >  :;   :;I8
+  :;  (   	(   
+ I  :;   :;I     .?:;'I@
+  4 :;I
+  'I   I  :;  I  ! /  '  ! /   <  & I  4 :;I
+  4 :;I  .?:;'I@
+   :;I
+  .?:;'@
+  .:;'I@
+     
+ :;  ! :;I  " :;I  # :;  $4 :;I?<  %:;  &&   ':;  ((    %  .?:;'@
+   :;I
+  :;   :;I8
+   I  $ >  :;  	(   
+(   :;   :;I     '   I  .?:;'I@
+  4 :;I
+  & I  .?:;'I@
+   :;I
+  4 :;I
+  .:;'I@
+  .:;'@
+   :;I   :;I  I  ! /   <   :;  :;  'I   &   !:;  "(    %  .?:;'@
+   :;I
+  :;   :;I8
+   I  $ >  :;  	(   
+(   :;   :;I     '   I  4 :;I
+  .?:;'I@
+   :;I
+  4 :;I
+  & I     4 :;I  .?:;'@
+  I  ! /  .:;'I@
+   :;I   :;I  ! /   <   :;   :;  !'I  "&   #:;  $(    %  :;   :;I8
+  :;  (   (    I  :;  	 :;I  
+$ >     .?:;'I@
+   :;I
+  4 :;I
+  & I  '   I   :;I   :;I  I  ! /   <   :;  :;  'I  &   :;  (    %  .?:;'I@
+   :;I
+  $ >  :;   :;I8
+   I     	'  
+ I  :;  (   (   :;   :;I  & I  .?:;'I@
+   :;I
+     4 :;I   :;I   :;I  I  ! /   <   :;  :;  'I  &   :;  (    %  .?:;'@
+   :;I
+     4 :;I  4 :;I
+   I  & I  	$ >  
+I  ! /  :;   :;I8
+  '   I  ! /  'I  :;  :;  (   (   :;   :;I     .?:;'I@
+  . :;'@
+  .:;'@
+   :;I   :;I   <   :;   4 :;I?<  !:;  "&   #:;  $(   % I8
+  &:;   %  .?:;'I@
+   :;I
+     4 :;I  4 :;I
+   I  $ >  	& I  
+.?:;'I@
+   :;I
+  4 :;I
+  I  ! /   :;I   :;I  :;   :;I8
+      <   :;  :;  :;   :;I  'I   I  &   :;  (   (         
+     mxml-attr.c    mxml.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h         U                                         !  l !   	!  , !  ! ,!  " ;!   @!  ' E!  s K!   P!   f!   j!   n!  , z!   |!  $ !  ! !   !   !   !   !   !   !  ' "  # "   "   )"   0"   P"   e"   n"   x"  ( "   "   "   "   "   "   "  t "   "  ( "   "   #   #   #   #   "#   4#   7#   :#   =#   @#   D#   ^#   m#   m#                       
+     mxml-entity.c    mxml-private.h    mxml.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h      p#  A #   #   #   #   #   #   #   #    t$   $   $   $   $   $  % $   $   $   $   $   $    %   #%   .%   4%   8%   N%   P%  s ]%  # h%   %   %   %   %   %   %   %   %   %   &   "&  o "&  # 3&   3&                  >     
+     mxml-file.c    mxml.h    /boot/develop/headers/posix/libio.h    mxml-private.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/stdio_post.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h      @&   E&   H&   h&  @ &   &   &   &   &   &  * &   '  + '   @'  7 q'   x'   '   '   '   '   '   '   '  % '   '   '   (   	(   ((   *(   <(   C(   Y(   \(  % w(   |(   (   (   (   (   (   (  * )   	)   )   )   7)   @)   D)   O)   W)   d)   g)   w)   x)  3 )   )   )   )   )   )  4 *   $*  5 D*   d*  ' *   *   *   *   *   *   *   *   *  ! *   *   *   *    *   +   +   #+   .+   K+   Y+   n+   x+   +   +   +   +   +   +   +   +   +   +   +   +   +   +   +   	,   ,   $,   $,   /,   C,   O,   s,   y,   ,   ,   ,   ,   ,   ,   ,   ,   ,   ,   -   -   #-   /-   5-   @-   N-   Y-   m-   }-   -   -   -   -   -   -   -   -   -   .   .   .   /.   ?.   Q.   Y.   a.   k.   p.   |.   .   .   .   .   .   .   .   .   .   /    /   (/   3/   G/   W/   i/   q/   }/   /   /    /   /   /   /   /   /   /   /   /   /   /   0   0   0   0    0   -0   00   30   =0   =0   B0   M0   ]0   j0   o0   r0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   "1   "1   .1   01   G1   O1   \1   c1   n1   y1   |1   1   1   1   1   1   1   1   1  t 1   1   1   2   2   2   %2   %2   02   I2   P2   V2   b2   d2   |2   |2   2   2   2   2   2   3   
+3   43   @3   F3   P3   X3   3   3   3   3   3   3   3   4   4   4   (4   m4   x4   4   4   4   4   4   4   4   5   L5   W5   5   5   5   5    6   
+6   6    C6   [6   l6   6   6   6   6   7   7   "7   /7   7   7   7   7   7   7   7   7   7   8  ( +8   08   88   E8   g8   l8   8   8   8   8   8   8   8   8   8   8   9   9   9   >9   R9   u9   9   9   9  . 9  % 9   9   9   9   9   9   9   9   9   9   9    :   :   :   ":   _:   b:   :   :   :   :   :   :   :   	;   ;   ;   .;   E;   k;   t;   v;   y;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   <   #<   )<   8<   H<   J<   T<   W<   `<   y<   <   <   <   <   <   <   <   <   <   <   <   <   =   =   =   6=   V=   X=   x=   =   =  l >   >  ) ">   ?>   A>   a>   |>   >   >   >  # >   >   >   >   >   ?    ?   "?   '?   A?   C?   c?   ~?   ?   ?   ?  # ?   ?   ?   ?   ?   @   @   @   )@   ,@   1@   ;@   @@   `@   {@   @   @   @  " @   @   @   @   @   @   A   A  $ A   A   A   $A   HA   hA   A   A  " A   A   A   A   A   A   A   A   A   A    B   
+B   B   B    B   (B   HB   hB   pB   B   B   B   B   B   B   B   B   B   B   B   C   "C   'C   :C   [C   `C   fC   C   C   C   C   C   C   C   C   C   C   C   C   C   C   
+D   D   D    D   &D   JD   ZD   `D   D   D   D   D   D   D   D   D   D   E   *E   0E   4E   @E   HE  | QE   SE  L \E   `E  L iE   pE  ^ yE   E   E   E   E  } E   E   E   E   E   E  / F   F    F   'F   ;F   GF   VF   `F   gF   pF   F   F   F   F   F   F   F   F   F   F   F   F   F   F   G   7G   ?G   YG   ^G   `G   eG   G   G   G  u G   G    G   H   H   :H   CH   qH   zH   H   H   H   H   H   H   H   H   H  
+ H   H     I   I   I   I   I   8I   UI   oI  
+ I   I   I   I   I   I   I   I   I   I   	J   J   J   J   J   6J   BJ   NJ   RJ   fJ   hJ   ~J   J   J   J   J   J   J   J   J   J   K   K   8K   HK   PK   XK   bK   kK   mK   rK   zK   K   K   K   K   K   K   K   K   K   K   K   K   L   <L   AL   IL   SL   XL   dL   pL   L   L   L   L   L   M   M  % M   M   7M   HM   HM   SM   aM   fM   wM   M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   N   N   N   $N   $N   *N   1N   6N   8N   >N   @N    XN   fN   }N   N   N   N   N   N   N   N   N   N   N    O   O   O   %O  i %O   %O   %O  ) 'O   0O   GO   HO   MO   YO   \O  " wO   O   O   O   O   7P   7P   BP   ]P   cP   eP   P   P   P   P   P   P   GQ   TQ   Q   Q   Q   Q   Q   Q   Q   R   R   3R   LR   qR   R   R  [ R   R  = R   R   R   R   R   R   S   2S   OS   kS   S   S   S   S   S   T   T   T   T    T   0T   IT   IT   LT   MT   PT   iT   T   T   T   T   T   T   T   T   T   T   T   T    U   U   U   7U   SU   [U   `U   U   U   U   U   U   U   U   U   U   U    V   V   NV   SV   `V   qV   V   V   V   V   V   V   W    W   1W   1W   GW   cW   uW   W   X   X   X   X    X   )X   1X   @X   @X    XX   `X   uX   X   X   X   X   X   X   X   X   X   X   X   X   X  " Y   Y   "Y   9Y   @Y   FY   PY   TY   WY   cY   eY   fY   gY   lY   xY   xY                  >     
+     mxml-index.c    mxml.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h      Y  K Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y    Z  ' Z  $ /Z  # ;Z   PZ   [Z  " fZ   mZ   qZ   vZ   Z   Z   Z   Z   Z   Z   Z  ! Z   Z   Z   Z   Z   Z   [   [  .  [   =[   P[  d V[   `[  5 f[   r[   t[  4 [   [   [   [   [   [   [   [    \  ' *\   6\   @\  j T\   V\   ^\   b\   q\   \   \  " \   \   \   \   \  9 \   \  9 \   \  ! \   \   \   \   ]   ]  " ']   A]   G]   q]   }]   ]    ]   ]   ]   ]   ]   ]   ]  ,  ^   ^   	^   ^   ^   ^   ^    ^   !^   D^   F^   G^   j^   n^   w^   }^   ^  f ^  7 ^   ^   ^   ^   ^   ^   ^                  _     
+     mxml-node.c    mxml.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h       _  W _   +_  & 1_   :_   =_   P_   c_   i_   p_   u_   x_   {_   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _  # `     `    (`   1`   3`   H`   x`   `   `   `   `   `   `   `   `   `   `   `   `   `   `   `   a   a   a   a   %a   0a  % Ha  ! La   Pa   ga   za   a   a  ' a  ! a   a   a   a   a  " a  ! a   a   a   b   b   b  " *b    ;b   Ab   Jb   Lb  # db  ! hb   pb   b   b   b   b  " b    b   b   b   b  % b  ! b   b   c   c   c   )c   ,c  & Dc  " Hc   Pc   gc   jc   mc   pc   }c   c   c    c   c  ( c   c   c   c   c   c   c   c   c  " c  " d   %d   <d   <d  " Rd   Vd   ed   nd   rd   d    d   d   d   d  ! d    d   d   d   d   d   d   d   d                       
+     mxml-search.c    mxml.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h       e  I e   ;e   ;e   Ne   Ue   e   e   e   e   e   e   e   e   e   e   e  # e   e   e   e   e    f   f   f   f    f   %f   ,f  $ 5f   =f   Df   Qf   Wf   `f   bf   ff   mf   of   sf                  ^   ~  
+     mxml-set.c    mxml.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h      f  F f   f   f   f   f   f   f   f  # f   g    g   'g   3g   Fg   Tg  ! og   |g   g   g   g   g   g  ! g   g   g   g   g  ! g   g   h   
+h   h   "h   0h  ! 6h   ?h   Fh   Lh   Th  " oh   |h   h   h   h   h   h   h  # h   h   h   h   h   h   h   h   i   i   i                       
+     mxml-private.c    mxml-private.h    mxml.h    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h    /boot/develop/headers/posix/stdint.h    /boot/develop/headers/posix/pthread.h       i  < ;i   Bi   Fi   Ii   \i   di   pi   i   i    i  ! i  ! i  ! i  , i   
+j   j   +j   1j   8j   ;j   Ej   Pj   Pj   j   j   j                     w  
+     mxml-string.c    /boot/develop/headers/posix/sys/types.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stddef.h    /boot/develop/headers/posix/time.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/stdarg.h    /boot/develop/headers/posix/stdio.h    /boot/develop/headers/posix/libio.h    /boot/develop/headers/posix/stdio_pre.h    /boot/develop/headers/posix/div_t.h    /boot/develop/tools/gnupro/lib/gcc-lib/i586-pc-haiku/2.95.3-haiku-090629/include/float.h    /boot/develop/headers/posix/stdlib.h    /boot/develop/headers/posix/ctype.h      j  j j   j   j   j   j   k   k   "k   9k   Hk   Wk   Wk                   .symtab .strtab .shstrtab .hash .dynsym .dynstr .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .dynamic .got .data .bss .comment .debug_aranges .debug_pubnames .debug_info .debug_abbrev .debug_line                                                          T               !                   
+         )             r                 1   	      |  |                 :   	                         C         |  |                    >                             I              M                 O         k  k                    U         k  k  d                  ]         D  Dz                   g         \  \                    n         d  d                    u         l  l                  ~         $  $                                8                                                                                               x                                                                     S                               O                                ^ E                               >                                 T p     _         	               	                                                                          |                        |                                    k       	     k       
+     D            \            d            l            $                                                                                                                                                                          L           P   d        ^           j              D                                           L                      \           `k           `           k                      h          X                   d           t             x"         D                                                      @&  %       ,  "      9  O      d2  Q      J  |      01  I       \O      *  1  n     8  7  W     G  $N       X  *  %    f  |1  x     s  8  |                E        @N        X         @X                               ]  c       ]        ]  q       <                       d  X       p                      |         #                      .           =         G         V  Pj  0     a  j  &                 r                         l        $            G        c  \       d           _            U        )  B       (             k                    g  "     '            /      2      8  b  6     G      <      U  ,c  ]     b            l  i       {  a  O       0   C           h        j  {       \  $                              x)  f       d  C       h%         $  N       |                     i       $  \(       1      *      9           @  #       R      ,      Y      J      _  !       s      .      {                    "     e  W       d*  3                   Lb  S       &  <       j  *           J            ;        *  $     !      ^     )         @  h&  `     K  ,f  G     X  f  R     f      `      m  <d  B     y  `  '                         p#  W       i         f  ~       g  Z       i           C       !  f       b  2        e       -            5  Tg  Z     D  a  <     R      }      W  @'       k  $*  @     }      )         i  v       '  9       k       	   0h  "       Y  )           .        *  (       t[  r                              Th  `     	   Z  r      c  T     "  i       2  b  U     >         E         J  Y  T     Z  |!  n     m  h  d     z    C       $  w       '                "              0a  V           c                   /home/michaelvoliveira/develop/haiku/trunk/src/system/glue/arch/x86/crti.S p.3 __DTOR_LIST__ completed.4 __do_global_dtors_aux __EH_FRAME_BEGIN__ fini_dummy object.11 frame_dummy init_dummy force_to_data __CTOR_LIST__ __do_global_ctors_aux __CTOR_END__ __DTOR_END__ __FRAME_END__ /home/michaelvoliveira/develop/haiku/trunk/src/system/glue/arch/x86/crtn.S init_term_dyn.c mxml-attr.c mxml_set_attr __FRAME_BEGIN__ mxml-entity.c entities.15 mxml-file.c mxml_isspace mxml_fd_getc mxml_load_data mxml_file_getc mxml_string_getc mxml_fd_putc mxml_write_node mxml_fd_write mxml_file_putc mxml_string_putc mxml_add_char mxml_fd_read mxml_get_entity types.69 mxml_parse_element mxml_write_name mxml_write_ws mxml_write_string mxml-index.c index_find index_sort index_compare mxml-node.c mxml_new mxml-search.c mxml-set.c mxml-private.c _mxml_key _mxml_key_once _mxml_init _mxml_destructor mxml-string.c _DYNAMIC _GLOBAL_OFFSET_TABLE_ get_image_symbol mxmlRemove mxmlRetain mxmlAdd putc_unlocked mxmlSAXLoadFile mxmlSaveString pthread_getspecific strerror mxmlSetInteger memmove snprintf mxmlNewInteger getc_unlocked mxmlNewTextf __ctype_b mxml_opaque_cb mxmlNewElement _term_after getc _mxml_vstrdupf mxmlIndexReset malloc vsnprintf mxmlSAXLoadFd _init_before _mxml_entity_cb mxmlEntityGetValue _init strtol mxml_ignore_cb mxmlSaveFile strrchr calloc mxmlEntityGetName strtod write mxmlElementSetAttrf fprintf pthread_once __deregister_frame_info mxmlWalkNext mxmlSetCustomHandlers pthread_key_create mxmlNewOpaque mxmlLoadFile _mxml_strdupf read strncmp mxmlSetErrorCallback realloc _gSharedObjectHaikuABI mxmlLoadFd mxmlWalkPrev mxmlSetCustom strdup mxmlRelease mxmlDelete mxmlElementDeleteAttr __bss_start mxmlEntityAddCallback _mxml_global mxmlSetCDATA mxmlSetOpaque mxml_real_cb _term_before mxmlElementGetAttr mxmlNewReal mxmlFindElement _errnop mxmlSetElement mxmlNewCustom putc mxmlSaveAllocString mxmlSAXLoadString strcmp mxml_error mxmlLoadString _fini mxmlSetReal mxmlIndexEnum sprintf mxmlSetWrapMargin mxmlIndexNew _single_threaded stderr mxmlSetText mxmlIndexFind mxmlNewXML mxml_integer_cb mxmlNewText _edata _end mxmlIndexDelete mxmlElementSetAttr mxmlSetTextf _init_after mxmlEntityRemoveCallback mxmlSaveFd __register_frame_info _gSharedObjectHaikuVersion mxmlNewCDATA pthread_setspecific free 
\ No newline at end of file
diff -Naur mxml-2.6/mxml-attr.c mxml-2.6-haiku/mxml-attr.c
--- mxml-2.6/mxml-attr.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-attr.c	2007-09-15 20:04:56.000000000 +0000
@@ -0,0 +1,321 @@
+/*
+ * "$Id: mxml-attr.c 308 2007-09-15 20:04:56Z mike $"
+ *
+ * Attribute support code for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2007 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxmlElementDeleteAttr() - Delete an attribute.
+ *   mxmlElementGetAttr()    - Get an attribute.
+ *   mxmlElementSetAttr()    - Set an attribute.
+ *   mxmlElementSetAttrf()   - Set an attribute with a formatted value.
+ *   mxml_set_attr()         - Set or add an attribute name/value pair.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+
+
+/*
+ * Local functions...
+ */
+
+static int	mxml_set_attr(mxml_node_t *node, const char *name,
+		              char *value);
+
+
+/*
+ * 'mxmlElementDeleteAttr()' - Delete an attribute.
+ *
+ * @since Mini-XML 2.4@
+ */
+
+void
+mxmlElementDeleteAttr(mxml_node_t *node,/* I - Element */
+                      const char  *name)/* I - Attribute name */
+{
+  int		i;			/* Looping var */
+  mxml_attr_t	*attr;			/* Cirrent attribute */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlElementDeleteAttr(node=%p, name=\"%s\")\n",
+          node, name ? name : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return;
+
+ /*
+  * Look for the attribute...
+  */
+
+  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+       i > 0;
+       i --, attr ++)
+  {
+#ifdef DEBUG
+    printf("    %s=\"%s\"\n", attr->name, attr->value);
+#endif /* DEBUG */
+
+    if (!strcmp(attr->name, name))
+    {
+     /*
+      * Delete this attribute...
+      */
+
+      free(attr->name);
+      free(attr->value);
+
+      i --;
+      if (i > 0)
+        memmove(attr, attr + 1, i * sizeof(mxml_attr_t));
+
+      node->value.element.num_attrs --;
+      return;
+    }
+  }
+}
+
+
+/*
+ * 'mxmlElementGetAttr()' - Get an attribute.
+ *
+ * This function returns NULL if the node is not an element or the
+ * named attribute does not exist.
+ */
+
+const char *				/* O - Attribute value or NULL */
+mxmlElementGetAttr(mxml_node_t *node,	/* I - Element node */
+                   const char  *name)	/* I - Name of attribute */
+{
+  int		i;			/* Looping var */
+  mxml_attr_t	*attr;			/* Cirrent attribute */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlElementGetAttr(node=%p, name=\"%s\")\n",
+          node, name ? name : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return (NULL);
+
+ /*
+  * Look for the attribute...
+  */
+
+  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+       i > 0;
+       i --, attr ++)
+  {
+#ifdef DEBUG
+    printf("    %s=\"%s\"\n", attr->name, attr->value);
+#endif /* DEBUG */
+
+    if (!strcmp(attr->name, name))
+    {
+#ifdef DEBUG
+      printf("    Returning \"%s\"!\n", attr->value);
+#endif /* DEBUG */
+      return (attr->value);
+    }
+  }
+
+ /*
+  * Didn't find attribute, so return NULL...
+  */
+
+#ifdef DEBUG
+  puts("    Returning NULL!\n");
+#endif /* DEBUG */
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxmlElementSetAttr()' - Set an attribute.
+ *
+ * If the named attribute already exists, the value of the attribute
+ * is replaced by the new string value. The string value is copied
+ * into the element node. This function does nothing if the node is
+ * not an element.
+ */
+
+void
+mxmlElementSetAttr(mxml_node_t *node,	/* I - Element node */
+                   const char  *name,	/* I - Name of attribute */
+                   const char  *value)	/* I - Attribute value */
+{
+  char	*valuec;			/* Copy of value */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlElementSetAttr(node=%p, name=\"%s\", value=\"%s\")\n",
+          node, name ? name : "(null)", value ? value : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return;
+
+  if (value)
+    valuec = strdup(value);
+  else
+    valuec = NULL;
+
+  if (mxml_set_attr(node, name, valuec))
+    free(valuec);
+}
+
+
+/*
+ * 'mxmlElementSetAttrf()' - Set an attribute with a formatted value.
+ *
+ * If the named attribute already exists, the value of the attribute
+ * is replaced by the new formatted string. The formatted string value is
+ * copied into the element node. This function does nothing if the node
+ * is not an element.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+void
+mxmlElementSetAttrf(mxml_node_t *node,	/* I - Element node */
+                    const char  *name,	/* I - Name of attribute */
+                    const char  *format,/* I - Printf-style attribute value */
+		    ...)		/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Argument pointer */
+  char		*value;			/* Value */
+
+
+#ifdef DEBUG
+  fprintf(stderr,
+          "mxmlElementSetAttrf(node=%p, name=\"%s\", format=\"%s\", ...)\n",
+          node, name ? name : "(null)", format ? format : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name || !format)
+    return;
+
+ /*
+  * Format the value...
+  */
+
+  va_start(ap, format);
+  value = _mxml_vstrdupf(format, ap);
+  va_end(ap);
+
+  if (!value)
+    mxml_error("Unable to allocate memory for attribute '%s' in element %s!",
+               name, node->value.element.name);
+  else if (mxml_set_attr(node, name, value))
+    free(value);
+}
+
+
+/*
+ * 'mxml_set_attr()' - Set or add an attribute name/value pair.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_set_attr(mxml_node_t *node,	/* I - Element node */
+              const char  *name,	/* I - Attribute name */
+              char        *value)	/* I - Attribute value */
+{
+  int		i;			/* Looping var */
+  mxml_attr_t	*attr;			/* New attribute */
+
+
+ /*
+  * Look for the attribute...
+  */
+
+  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+       i > 0;
+       i --, attr ++)
+    if (!strcmp(attr->name, name))
+    {
+     /*
+      * Free the old value as needed...
+      */
+
+      if (attr->value)
+        free(attr->value);
+
+      attr->value = value;
+
+      return (0);
+    }
+
+ /*
+  * Add a new attribute...
+  */
+
+  if (node->value.element.num_attrs == 0)
+    attr = malloc(sizeof(mxml_attr_t));
+  else
+    attr = realloc(node->value.element.attrs,
+                   (node->value.element.num_attrs + 1) * sizeof(mxml_attr_t));
+
+  if (!attr)
+  {
+    mxml_error("Unable to allocate memory for attribute '%s' in element %s!",
+               name, node->value.element.name);
+    return (-1);
+  }
+
+  node->value.element.attrs = attr;
+  attr += node->value.element.num_attrs;
+
+  if ((attr->name = strdup(name)) == NULL)
+  {
+    mxml_error("Unable to allocate memory for attribute '%s' in element %s!",
+               name, node->value.element.name);
+    return (-1);
+  }
+
+  attr->value = value;
+
+  node->value.element.num_attrs ++;
+
+  return (0);
+}
+
+
+/*
+ * End of "$Id: mxml-attr.c 308 2007-09-15 20:04:56Z mike $".
+ */
diff -Naur mxml-2.6/mxml-entity.c mxml-2.6-haiku/mxml-entity.c
--- mxml-2.6/mxml-entity.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-entity.c	2009-03-19 05:38:52.000000000 +0000
@@ -0,0 +1,462 @@
+/*
+ * "$Id: mxml-entity.c 385 2009-03-19 05:38:52Z mike $"
+ *
+ * Character entity support code for Mini-XML, a small XML-like
+ * file parsing library.
+ *
+ * Copyright 2003-2009 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxmlEntityAddCallback()    - Add a callback to convert entities to
+ *                                Unicode.
+ *   mxmlEntityGetName()        - Get the name that corresponds to the
+ *                                character value.
+ *   mxmlEntityGetValue()       - Get the character corresponding to a named
+ *                                entity.
+ *   mxmlEntityRemoveCallback() - Remove a callback.
+ *   _mxml_entity_cb()          - Lookup standard (X)HTML entities.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "mxml-private.h"
+
+
+/*
+ * 'mxmlEntityAddCallback()' - Add a callback to convert entities to Unicode.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlEntityAddCallback(
+    mxml_entity_cb_t cb)		/* I - Callback function to add */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  if (global->num_entity_cbs < (int)(sizeof(global->entity_cbs) / sizeof(global->entity_cbs[0])))
+  {
+    global->entity_cbs[global->num_entity_cbs] = cb;
+    global->num_entity_cbs ++;
+
+    return (0);
+  }
+  else
+  {
+    mxml_error("Unable to add entity callback!");
+
+    return (-1);
+  }
+}
+
+
+/*
+ * 'mxmlEntityGetName()' - Get the name that corresponds to the character value.
+ *
+ * If val does not need to be represented by a named entity, NULL is returned.
+ */
+
+const char *				/* O - Entity name or NULL */
+mxmlEntityGetName(int val)		/* I - Character value */
+{
+  switch (val)
+  {
+    case '&' :
+        return ("amp");
+
+    case '<' :
+        return ("lt");
+
+    case '>' :
+        return ("gt");
+
+    case '\"' :
+        return ("quot");
+
+    default :
+        return (NULL);
+  }
+}
+
+
+/*
+ * 'mxmlEntityGetValue()' - Get the character corresponding to a named entity.
+ *
+ * The entity name can also be a numeric constant. -1 is returned if the
+ * name is not known.
+ */
+
+int					/* O - Character value or -1 on error */
+mxmlEntityGetValue(const char *name)	/* I - Entity name */
+{
+  int		i;			/* Looping var */
+  int		ch;			/* Character value */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  for (i = 0; i < global->num_entity_cbs; i ++)
+    if ((ch = (global->entity_cbs[i])(name)) >= 0)
+      return (ch);
+
+  return (-1);
+}
+
+
+/*
+ * 'mxmlEntityRemoveCallback()' - Remove a callback.
+ */
+
+void
+mxmlEntityRemoveCallback(
+    mxml_entity_cb_t cb)		/* I - Callback function to remove */
+{
+  int		i;			/* Looping var */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  for (i = 0; i < global->num_entity_cbs; i ++)
+    if (cb == global->entity_cbs[i])
+    {
+     /*
+      * Remove the callback...
+      */
+
+      global->num_entity_cbs --;
+
+      if (i < global->num_entity_cbs)
+        memmove(global->entity_cbs + i, global->entity_cbs + i + 1,
+	        (global->num_entity_cbs - i) * sizeof(global->entity_cbs[0]));
+
+      return;
+    }
+}
+
+
+/*
+ * '_mxml_entity_cb()' - Lookup standard (X)HTML entities.
+ */
+
+int					/* O - Unicode value or -1 */
+_mxml_entity_cb(const char *name)	/* I - Entity name */
+{
+  int	diff,				/* Difference between names */
+	current,			/* Current entity in search */
+	first,				/* First entity in search */
+	last;				/* Last entity in search */
+  static const struct
+  {
+    const char	*name;			/* Entity name */
+    int		val;			/* Character value */
+  }	entities[] =
+  {
+    { "AElig",		198 },
+    { "Aacute",		193 },
+    { "Acirc",		194 },
+    { "Agrave",		192 },
+    { "Alpha",		913 },
+    { "Aring",		197 },
+    { "Atilde",		195 },
+    { "Auml",		196 },
+    { "Beta",		914 },
+    { "Ccedil",		199 },
+    { "Chi",		935 },
+    { "Dagger",		8225 },
+    { "Delta",		916 },
+    { "Dstrok",		208 },
+    { "ETH",		208 },
+    { "Eacute",		201 },
+    { "Ecirc",		202 },
+    { "Egrave",		200 },
+    { "Epsilon",	917 },
+    { "Eta",		919 },
+    { "Euml",		203 },
+    { "Gamma",		915 },
+    { "Iacute",		205 },
+    { "Icirc",		206 },
+    { "Igrave",		204 },
+    { "Iota",		921 },
+    { "Iuml",		207 },
+    { "Kappa",		922 },
+    { "Lambda",		923 },
+    { "Mu",		924 },
+    { "Ntilde",		209 },
+    { "Nu",		925 },
+    { "OElig",		338 },
+    { "Oacute",		211 },
+    { "Ocirc",		212 },
+    { "Ograve",		210 },
+    { "Omega",		937 },
+    { "Omicron",	927 },
+    { "Oslash",		216 },
+    { "Otilde",		213 },
+    { "Ouml",		214 },
+    { "Phi",		934 },
+    { "Pi",		928 },
+    { "Prime",		8243 },
+    { "Psi",		936 },
+    { "Rho",		929 },
+    { "Scaron",		352 },
+    { "Sigma",		931 },
+    { "THORN",		222 },
+    { "Tau",		932 },
+    { "Theta",		920 },
+    { "Uacute",		218 },
+    { "Ucirc",		219 },
+    { "Ugrave",		217 },
+    { "Upsilon",	933 },
+    { "Uuml",		220 },
+    { "Xi",		926 },
+    { "Yacute",		221 },
+    { "Yuml",		376 },
+    { "Zeta",		918 },
+    { "aacute",		225 },
+    { "acirc",		226 },
+    { "acute",		180 },
+    { "aelig",		230 },
+    { "agrave",		224 },
+    { "alefsym",	8501 },
+    { "alpha",		945 },
+    { "amp",		'&' },
+    { "and",		8743 },
+    { "ang",		8736 },
+    { "apos",           '\'' },
+    { "aring",		229 },
+    { "asymp",		8776 },
+    { "atilde",		227 },
+    { "auml",		228 },
+    { "bdquo",		8222 },
+    { "beta",		946 },
+    { "brkbar",		166 },
+    { "brvbar",		166 },
+    { "bull",		8226 },
+    { "cap",		8745 },
+    { "ccedil",		231 },
+    { "cedil",		184 },
+    { "cent",		162 },
+    { "chi",		967 },
+    { "circ",		710 },
+    { "clubs",		9827 },
+    { "cong",		8773 },
+    { "copy",		169 },
+    { "crarr",		8629 },
+    { "cup",		8746 },
+    { "curren",		164 },
+    { "dArr",		8659 },
+    { "dagger",		8224 },
+    { "darr",		8595 },
+    { "deg",		176 },
+    { "delta",		948 },
+    { "diams",		9830 },
+    { "die",		168 },
+    { "divide",		247 },
+    { "eacute",		233 },
+    { "ecirc",		234 },
+    { "egrave",		232 },
+    { "empty",		8709 },
+    { "emsp",		8195 },
+    { "ensp",		8194 },
+    { "epsilon",	949 },
+    { "equiv",		8801 },
+    { "eta",		951 },
+    { "eth",		240 },
+    { "euml",		235 },
+    { "euro",		8364 },
+    { "exist",		8707 },
+    { "fnof",		402 },
+    { "forall",		8704 },
+    { "frac12",		189 },
+    { "frac14",		188 },
+    { "frac34",		190 },
+    { "frasl",		8260 },
+    { "gamma",		947 },
+    { "ge",		8805 },
+    { "gt",		'>' },
+    { "hArr",		8660 },
+    { "harr",		8596 },
+    { "hearts",		9829 },
+    { "hellip",		8230 },
+    { "hibar",		175 },
+    { "iacute",		237 },
+    { "icirc",		238 },
+    { "iexcl",		161 },
+    { "igrave",		236 },
+    { "image",		8465 },
+    { "infin",		8734 },
+    { "int",		8747 },
+    { "iota",		953 },
+    { "iquest",		191 },
+    { "isin",		8712 },
+    { "iuml",		239 },
+    { "kappa",		954 },
+    { "lArr",		8656 },
+    { "lambda",		955 },
+    { "lang",		9001 },
+    { "laquo",		171 },
+    { "larr",		8592 },
+    { "lceil",		8968 },
+    { "ldquo",		8220 },
+    { "le",		8804 },
+    { "lfloor",		8970 },
+    { "lowast",		8727 },
+    { "loz",		9674 },
+    { "lrm",		8206 },
+    { "lsaquo",		8249 },
+    { "lsquo",		8216 },
+    { "lt",		'<' },
+    { "macr",		175 },
+    { "mdash",		8212 },
+    { "micro",		181 },
+    { "middot",		183 },
+    { "minus",		8722 },
+    { "mu",		956 },
+    { "nabla",		8711 },
+    { "nbsp",		160 },
+    { "ndash",		8211 },
+    { "ne",		8800 },
+    { "ni",		8715 },
+    { "not",		172 },
+    { "notin",		8713 },
+    { "nsub",		8836 },
+    { "ntilde",		241 },
+    { "nu",		957 },
+    { "oacute",		243 },
+    { "ocirc",		244 },
+    { "oelig",		339 },
+    { "ograve",		242 },
+    { "oline",		8254 },
+    { "omega",		969 },
+    { "omicron",	959 },
+    { "oplus",		8853 },
+    { "or",		8744 },
+    { "ordf",		170 },
+    { "ordm",		186 },
+    { "oslash",		248 },
+    { "otilde",		245 },
+    { "otimes",		8855 },
+    { "ouml",		246 },
+    { "para",		182 },
+    { "part",		8706 },
+    { "permil",		8240 },
+    { "perp",		8869 },
+    { "phi",		966 },
+    { "pi",		960 },
+    { "piv",		982 },
+    { "plusmn",		177 },
+    { "pound",		163 },
+    { "prime",		8242 },
+    { "prod",		8719 },
+    { "prop",		8733 },
+    { "psi",		968 },
+    { "quot",		'\"' },
+    { "rArr",		8658 },
+    { "radic",		8730 },
+    { "rang",		9002 },
+    { "raquo",		187 },
+    { "rarr",		8594 },
+    { "rceil",		8969 },
+    { "rdquo",		8221 },
+    { "real",		8476 },
+    { "reg",		174 },
+    { "rfloor",		8971 },
+    { "rho",		961 },
+    { "rlm",		8207 },
+    { "rsaquo",		8250 },
+    { "rsquo",		8217 },
+    { "sbquo",		8218 },
+    { "scaron",		353 },
+    { "sdot",		8901 },
+    { "sect",		167 },
+    { "shy",		173 },
+    { "sigma",		963 },
+    { "sigmaf",		962 },
+    { "sim",		8764 },
+    { "spades",		9824 },
+    { "sub",		8834 },
+    { "sube",		8838 },
+    { "sum",		8721 },
+    { "sup",		8835 },
+    { "sup1",		185 },
+    { "sup2",		178 },
+    { "sup3",		179 },
+    { "supe",		8839 },
+    { "szlig",		223 },
+    { "tau",		964 },
+    { "there4",		8756 },
+    { "theta",		952 },
+    { "thetasym",	977 },
+    { "thinsp",		8201 },
+    { "thorn",		254 },
+    { "tilde",		732 },
+    { "times",		215 },
+    { "trade",		8482 },
+    { "uArr",		8657 },
+    { "uacute",		250 },
+    { "uarr",		8593 },
+    { "ucirc",		251 },
+    { "ugrave",		249 },
+    { "uml",		168 },
+    { "upsih",		978 },
+    { "upsilon",	965 },
+    { "uuml",		252 },
+    { "weierp",		8472 },
+    { "xi",		958 },
+    { "yacute",		253 },
+    { "yen",		165 },
+    { "yuml",		255 },
+    { "zeta",		950 },
+    { "zwj",		8205 },
+    { "zwnj",		8204 }
+  };
+
+
+ /*
+  * Do a binary search for the named entity...
+  */
+
+  first = 0;
+  last  = (int)(sizeof(entities) / sizeof(entities[0]) - 1);
+
+  while ((last - first) > 1)
+  {
+    current = (first + last) / 2;
+
+    if ((diff = strcmp(name, entities[current].name)) == 0)
+      return (entities[current].val);
+    else if (diff < 0)
+      last = current;
+    else
+      first = current;
+  }
+
+ /*
+  * If we get here, there is a small chance that there is still
+  * a match; check first and last...
+  */
+
+  if (!strcmp(name, entities[first].name))
+    return (entities[first].val);
+  else if (!strcmp(name, entities[last].name))
+    return (entities[last].val);
+  else
+    return (-1);
+}
+
+
+/*
+ * End of "$Id: mxml-entity.c 385 2009-03-19 05:38:52Z mike $".
+ */
diff -Naur mxml-2.6/mxml-file.c mxml-2.6-haiku/mxml-file.c
--- mxml-2.6/mxml-file.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-file.c	2009-05-17 05:20:52.000000000 +0000
@@ -0,0 +1,3027 @@
+/*
+ * "$Id: mxml-file.c 391 2009-05-17 05:20:52Z mike $"
+ *
+ * File loading code for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2009 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxmlLoadFd()            - Load a file descriptor into an XML node tree.
+ *   mxmlLoadFile()          - Load a file into an XML node tree.
+ *   mxmlLoadString()        - Load a string into an XML node tree.
+ *   mxmlSaveAllocString()   - Save an XML node tree to an allocated string.
+ *   mxmlSaveFd()            - Save an XML tree to a file descriptor.
+ *   mxmlSaveFile()          - Save an XML tree to a file.
+ *   mxmlSaveString()        - Save an XML node tree to a string.
+ *   mxmlSAXLoadFd()         - Load a file descriptor into an XML node tree
+ *                             using a SAX callback.
+ *   mxmlSAXLoadFile()       - Load a file into an XML node tree
+ *                             using a SAX callback.
+ *   mxmlSAXLoadString()     - Load a string into an XML node tree
+ *                             using a SAX callback.
+ *   mxmlSetCustomHandlers() - Set the handling functions for custom data.
+ *   mxmlSetErrorCallback()  - Set the error message callback.
+ *   mxmlSetWrapMargin()     - Set the the wrap margin when saving XML data.
+ *   mxml_add_char()         - Add a character to a buffer, expanding as needed.
+ *   mxml_fd_getc()          - Read a character from a file descriptor.
+ *   mxml_fd_putc()          - Write a character to a file descriptor.
+ *   mxml_fd_read()          - Read a buffer of data from a file descriptor.
+ *   mxml_fd_write()         - Write a buffer of data to a file descriptor.
+ *   mxml_file_getc()        - Get a character from a file.
+ *   mxml_file_putc()        - Write a character to a file.
+ *   mxml_get_entity()       - Get the character corresponding to an entity...
+ *   mxml_load_data()        - Load data into an XML node tree.
+ *   mxml_parse_element()    - Parse an element for any attributes...
+ *   mxml_string_getc()      - Get a character from a string.
+ *   mxml_string_putc()      - Write a character to a string.
+ *   mxml_write_name()       - Write a name string.
+ *   mxml_write_node()       - Save an XML node to a file.
+ *   mxml_write_string()     - Write a string, escaping & and < as needed.
+ *   mxml_write_ws()         - Do whitespace callback...
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#ifndef WIN32
+#  include <unistd.h>
+#endif /* !WIN32 */
+#include "mxml-private.h"
+
+
+/*
+ * Character encoding...
+ */
+
+#define ENCODE_UTF8	0		/* UTF-8 */
+#define ENCODE_UTF16BE	1		/* UTF-16 Big-Endian */
+#define ENCODE_UTF16LE	2		/* UTF-16 Little-Endian */
+
+
+/*
+ * Macro to test for a bad XML character...
+ */
+
+#define mxml_bad_char(ch) ((ch) < ' ' && (ch) != '\n' && (ch) != '\r' && (ch) != '\t')
+
+
+/*
+ * Types and structures...
+ */
+
+typedef int (*_mxml_getc_cb_t)(void *, int *);
+typedef int (*_mxml_putc_cb_t)(int, void *);
+
+typedef struct _mxml_fdbuf_s		/**** File descriptor buffer ****/
+{
+  int		fd;			/* File descriptor */
+  unsigned char	*current,		/* Current position in buffer */
+		*end,			/* End of buffer */
+		buffer[8192];		/* Character buffer */
+} _mxml_fdbuf_t;
+
+
+/*
+ * Local functions...
+ */
+
+static int		mxml_add_char(int ch, char **ptr, char **buffer,
+			              int *bufsize);
+static int		mxml_fd_getc(void *p, int *encoding);
+static int		mxml_fd_putc(int ch, void *p);
+static int		mxml_fd_read(_mxml_fdbuf_t *buf);
+static int		mxml_fd_write(_mxml_fdbuf_t *buf);
+static int		mxml_file_getc(void *p, int *encoding);
+static int		mxml_file_putc(int ch, void *p);
+static int		mxml_get_entity(mxml_node_t *parent, void *p,
+			                int *encoding,
+					_mxml_getc_cb_t getc_cb);
+static inline int	mxml_isspace(int ch)
+			{
+			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
+			          ch == '\n');
+			}
+static mxml_node_t	*mxml_load_data(mxml_node_t *top, void *p,
+			                mxml_load_cb_t cb,
+			                _mxml_getc_cb_t getc_cb,
+                                        mxml_sax_cb_t sax_cb, void *sax_data);
+static int		mxml_parse_element(mxml_node_t *node, void *p,
+			                   int *encoding,
+					   _mxml_getc_cb_t getc_cb);
+static int		mxml_string_getc(void *p, int *encoding);
+static int		mxml_string_putc(int ch, void *p);
+static int		mxml_write_name(const char *s, void *p,
+					_mxml_putc_cb_t putc_cb);
+static int		mxml_write_node(mxml_node_t *node, void *p,
+			                mxml_save_cb_t cb, int col,
+					_mxml_putc_cb_t putc_cb,
+					_mxml_global_t *global);
+static int		mxml_write_string(const char *s, void *p,
+					  _mxml_putc_cb_t putc_cb);
+static int		mxml_write_ws(mxml_node_t *node, void *p, 
+			              mxml_save_cb_t cb, int ws,
+				      int col, _mxml_putc_cb_t putc_cb);
+
+
+/*
+ * 'mxmlLoadFd()' - Load a file descriptor into an XML node tree.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * If MXML_NO_CALLBACK is specified then all child nodes will be either
+ * MXML_ELEMENT or MXML_TEXT nodes.
+ *
+ * The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ * MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ * child nodes of the specified type.
+ */
+
+mxml_node_t *				/* O - First node or NULL if the file could not be read. */
+mxmlLoadFd(mxml_node_t    *top,		/* I - Top node */
+           int            fd,		/* I - File descriptor to read from */
+           mxml_load_cb_t cb)		/* I - Callback function or MXML_NO_CALLBACK */
+{
+  _mxml_fdbuf_t	buf;			/* File descriptor buffer */
+
+
+ /*
+  * Initialize the file descriptor buffer...
+  */
+
+  buf.fd      = fd;
+  buf.current = buf.buffer;
+  buf.end     = buf.buffer;
+
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, MXML_NO_CALLBACK, NULL));
+}
+
+
+/*
+ * 'mxmlLoadFile()' - Load a file into an XML node tree.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * If MXML_NO_CALLBACK is specified then all child nodes will be either
+ * MXML_ELEMENT or MXML_TEXT nodes.
+ *
+ * The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ * MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ * child nodes of the specified type.
+ */
+
+mxml_node_t *				/* O - First node or NULL if the file could not be read. */
+mxmlLoadFile(mxml_node_t    *top,	/* I - Top node */
+             FILE           *fp,	/* I - File to read from */
+             mxml_load_cb_t cb)		/* I - Callback function or MXML_NO_CALLBACK */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, fp, cb, mxml_file_getc, MXML_NO_CALLBACK, NULL));
+}
+
+
+/*
+ * 'mxmlLoadString()' - Load a string into an XML node tree.
+ *
+ * The nodes in the specified string are added to the specified top node.
+ * If no top node is provided, the XML string MUST be well-formed with a
+ * single parent node like <?xml> for the entire string. The callback
+ * function returns the value type that should be used for child nodes.
+ * If MXML_NO_CALLBACK is specified then all child nodes will be either
+ * MXML_ELEMENT or MXML_TEXT nodes.
+ *
+ * The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ * MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ * child nodes of the specified type.
+ */
+
+mxml_node_t *				/* O - First node or NULL if the string has errors. */
+mxmlLoadString(mxml_node_t    *top,	/* I - Top node */
+               const char     *s,	/* I - String to load */
+               mxml_load_cb_t cb)	/* I - Callback function or MXML_NO_CALLBACK */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, MXML_NO_CALLBACK,
+                         NULL));
+}
+
+
+/*
+ * 'mxmlSaveAllocString()' - Save an XML node tree to an allocated string.
+ *
+ * This function returns a pointer to a string containing the textual
+ * representation of the XML node tree.  The string should be freed
+ * using the free() function when you are done with it.  NULL is returned
+ * if the node would produce an empty string or if the string cannot be
+ * allocated.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element. If MXML_NO_CALLBACK
+ * is specified, whitespace will only be added before MXML_TEXT nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+char *					/* O - Allocated string or NULL */
+mxmlSaveAllocString(
+    mxml_node_t    *node,		/* I - Node to write */
+    mxml_save_cb_t cb)			/* I - Whitespace callback or MXML_NO_CALLBACK */
+{
+  int	bytes;				/* Required bytes */
+  char	buffer[8192];			/* Temporary buffer */
+  char	*s;				/* Allocated string */
+
+
+ /*
+  * Write the node to the temporary buffer...
+  */
+
+  bytes = mxmlSaveString(node, buffer, sizeof(buffer), cb);
+
+  if (bytes <= 0)
+    return (NULL);
+
+  if (bytes < (int)(sizeof(buffer) - 1))
+  {
+   /*
+    * Node fit inside the buffer, so just duplicate that string and
+    * return...
+    */
+
+    return (strdup(buffer));
+  }
+
+ /*
+  * Allocate a buffer of the required size and save the node to the
+  * new buffer...
+  */
+
+  if ((s = malloc(bytes + 1)) == NULL)
+    return (NULL);
+
+  mxmlSaveString(node, s, bytes + 1, cb);
+
+ /*
+  * Return the allocated string...
+  */
+
+  return (s);
+}
+
+
+/*
+ * 'mxmlSaveFd()' - Save an XML tree to a file descriptor.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element. If MXML_NO_CALLBACK
+ * is specified, whitespace will only be added before MXML_TEXT nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+int					/* O - 0 on success, -1 on error. */
+mxmlSaveFd(mxml_node_t    *node,	/* I - Node to write */
+           int            fd,		/* I - File descriptor to write to */
+	   mxml_save_cb_t cb)		/* I - Whitespace callback or MXML_NO_CALLBACK */
+{
+  int		col;			/* Final column */
+  _mxml_fdbuf_t	buf;			/* File descriptor buffer */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Initialize the file descriptor buffer...
+  */
+
+  buf.fd      = fd;
+  buf.current = buf.buffer;
+  buf.end     = buf.buffer + sizeof(buf.buffer);
+
+ /*
+  * Write the node...
+  */
+
+  if ((col = mxml_write_node(node, &buf, cb, 0, mxml_fd_putc, global)) < 0)
+    return (-1);
+
+  if (col > 0)
+    if (mxml_fd_putc('\n', &buf) < 0)
+      return (-1);
+
+ /*
+  * Flush and return...
+  */
+
+  return (mxml_fd_write(&buf));
+}
+
+
+/*
+ * 'mxmlSaveFile()' - Save an XML tree to a file.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element. If MXML_NO_CALLBACK
+ * is specified, whitespace will only be added before MXML_TEXT nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+int					/* O - 0 on success, -1 on error. */
+mxmlSaveFile(mxml_node_t    *node,	/* I - Node to write */
+             FILE           *fp,	/* I - File to write to */
+	     mxml_save_cb_t cb)		/* I - Whitespace callback or MXML_NO_CALLBACK */
+{
+  int	col;				/* Final column */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Write the node...
+  */
+
+  if ((col = mxml_write_node(node, fp, cb, 0, mxml_file_putc, global)) < 0)
+    return (-1);
+
+  if (col > 0)
+    if (putc('\n', fp) < 0)
+      return (-1);
+
+ /*
+  * Return 0 (success)...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSaveString()' - Save an XML node tree to a string.
+ *
+ * This function returns the total number of bytes that would be
+ * required for the string but only copies (bufsize - 1) characters
+ * into the specified buffer.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element. If MXML_NO_CALLBACK
+ * is specified, whitespace will only be added before MXML_TEXT nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+int					/* O - Size of string */
+mxmlSaveString(mxml_node_t    *node,	/* I - Node to write */
+               char           *buffer,	/* I - String buffer */
+               int            bufsize,	/* I - Size of string buffer */
+               mxml_save_cb_t cb)	/* I - Whitespace callback or MXML_NO_CALLBACK */
+{
+  int	col;				/* Final column */
+  char	*ptr[2];			/* Pointers for putc_cb */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Write the node...
+  */
+
+  ptr[0] = buffer;
+  ptr[1] = buffer + bufsize;
+
+  if ((col = mxml_write_node(node, ptr, cb, 0, mxml_string_putc, global)) < 0)
+    return (-1);
+
+  if (col > 0)
+    mxml_string_putc('\n', ptr);
+
+ /*
+  * Nul-terminate the buffer...
+  */
+
+  if (ptr[0] >= ptr[1])
+    buffer[bufsize - 1] = '\0';
+  else
+    ptr[0][0] = '\0';
+
+ /*
+  * Return the number of characters...
+  */
+
+  return (ptr[0] - buffer);
+}
+
+
+/*
+ * 'mxmlSAXLoadFd()' - Load a file descriptor into an XML node tree
+ *                     using a SAX callback.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * If MXML_NO_CALLBACK is specified then all child nodes will be either
+ * MXML_ELEMENT or MXML_TEXT nodes.
+ *
+ * The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ * MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ * child nodes of the specified type.
+ *
+ * The SAX callback must call mxmlRetain() for any nodes that need to
+ * be kept for later use. Otherwise, nodes are deleted when the parent
+ * node is closed or after each data, comment, CDATA, or directive node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - First node or NULL if the file could not be read. */
+mxmlSAXLoadFd(mxml_node_t    *top,	/* I - Top node */
+              int            fd,	/* I - File descriptor to read from */
+              mxml_load_cb_t cb,	/* I - Callback function or MXML_NO_CALLBACK */
+              mxml_sax_cb_t  sax_cb,	/* I - SAX callback or MXML_NO_CALLBACK */
+              void           *sax_data)	/* I - SAX user data */
+{
+  _mxml_fdbuf_t	buf;			/* File descriptor buffer */
+
+
+ /*
+  * Initialize the file descriptor buffer...
+  */
+
+  buf.fd      = fd;
+  buf.current = buf.buffer;
+  buf.end     = buf.buffer;
+
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, sax_cb, sax_data));
+}
+
+
+/*
+ * 'mxmlSAXLoadFile()' - Load a file into an XML node tree
+ *                       using a SAX callback.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * If MXML_NO_CALLBACK is specified then all child nodes will be either
+ * MXML_ELEMENT or MXML_TEXT nodes.
+ *
+ * The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ * MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ * child nodes of the specified type.
+ *
+ * The SAX callback must call mxmlRetain() for any nodes that need to
+ * be kept for later use. Otherwise, nodes are deleted when the parent
+ * node is closed or after each data, comment, CDATA, or directive node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - First node or NULL if the file could not be read. */
+mxmlSAXLoadFile(
+    mxml_node_t    *top,		/* I - Top node */
+    FILE           *fp,			/* I - File to read from */
+    mxml_load_cb_t cb,			/* I - Callback function or MXML_NO_CALLBACK */
+    mxml_sax_cb_t  sax_cb,		/* I - SAX callback or MXML_NO_CALLBACK */
+    void           *sax_data)		/* I - SAX user data */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, fp, cb, mxml_file_getc, sax_cb, sax_data));
+}
+
+
+/*
+ * 'mxmlSAXLoadString()' - Load a string into an XML node tree
+ *                         using a SAX callback.
+ *
+ * The nodes in the specified string are added to the specified top node.
+ * If no top node is provided, the XML string MUST be well-formed with a
+ * single parent node like <?xml> for the entire string. The callback
+ * function returns the value type that should be used for child nodes.
+ * If MXML_NO_CALLBACK is specified then all child nodes will be either
+ * MXML_ELEMENT or MXML_TEXT nodes.
+ *
+ * The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
+ * MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
+ * child nodes of the specified type.
+ *
+ * The SAX callback must call mxmlRetain() for any nodes that need to
+ * be kept for later use. Otherwise, nodes are deleted when the parent
+ * node is closed or after each data, comment, CDATA, or directive node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - First node or NULL if the string has errors. */
+mxmlSAXLoadString(
+    mxml_node_t    *top,		/* I - Top node */
+    const char     *s,			/* I - String to load */
+    mxml_load_cb_t cb,			/* I - Callback function or MXML_NO_CALLBACK */
+    mxml_sax_cb_t  sax_cb,		/* I - SAX callback or MXML_NO_CALLBACK */
+    void           *sax_data)		/* I - SAX user data */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, sax_cb, sax_data));
+}
+
+
+/*
+ * 'mxmlSetCustomHandlers()' - Set the handling functions for custom data.
+ *
+ * The load function accepts a node pointer and a data string and must
+ * return 0 on success and non-zero on error.
+ *
+ * The save function accepts a node pointer and must return a malloc'd
+ * string on success and NULL on error.
+ * 
+ */
+
+void
+mxmlSetCustomHandlers(
+    mxml_custom_load_cb_t load,		/* I - Load function */
+    mxml_custom_save_cb_t save)		/* I - Save function */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  global->custom_load_cb = load;
+  global->custom_save_cb = save;
+}
+
+
+/*
+ * 'mxmlSetErrorCallback()' - Set the error message callback.
+ */
+
+void
+mxmlSetErrorCallback(mxml_error_cb_t cb)/* I - Error callback function */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  global->error_cb = cb;
+}
+
+
+/*
+ * 'mxmlSetWrapMargin()' - Set the the wrap margin when saving XML data.
+ *
+ * Wrapping is disabled when "column" is 0.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+void
+mxmlSetWrapMargin(int column)		/* I - Column for wrapping, 0 to disable wrapping */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  global->wrap = column;
+}
+
+
+/*
+ * 'mxml_add_char()' - Add a character to a buffer, expanding as needed.
+ */
+
+static int				/* O  - 0 on success, -1 on error */
+mxml_add_char(int  ch,			/* I  - Character to add */
+              char **bufptr,		/* IO - Current position in buffer */
+	      char **buffer,		/* IO - Current buffer */
+	      int  *bufsize)		/* IO - Current buffer size */
+{
+  char	*newbuffer;			/* New buffer value */
+
+
+  if (*bufptr >= (*buffer + *bufsize - 4))
+  {
+   /*
+    * Increase the size of the buffer...
+    */
+
+    if (*bufsize < 1024)
+      (*bufsize) *= 2;
+    else
+      (*bufsize) += 1024;
+
+    if ((newbuffer = realloc(*buffer, *bufsize)) == NULL)
+    {
+      free(*buffer);
+
+      mxml_error("Unable to expand string buffer to %d bytes!", *bufsize);
+
+      return (-1);
+    }
+
+    *bufptr = newbuffer + (*bufptr - *buffer);
+    *buffer = newbuffer;
+  }
+
+  if (ch < 0x80)
+  {
+   /*
+    * Single byte ASCII...
+    */
+
+    *(*bufptr)++ = ch;
+  }
+  else if (ch < 0x800)
+  {
+   /*
+    * Two-byte UTF-8...
+    */
+
+    *(*bufptr)++ = 0xc0 | (ch >> 6);
+    *(*bufptr)++ = 0x80 | (ch & 0x3f);
+  }
+  else if (ch < 0x10000)
+  {
+   /*
+    * Three-byte UTF-8...
+    */
+
+    *(*bufptr)++ = 0xe0 | (ch >> 12);
+    *(*bufptr)++ = 0x80 | ((ch >> 6) & 0x3f);
+    *(*bufptr)++ = 0x80 | (ch & 0x3f);
+  }
+  else
+  {
+   /*
+    * Four-byte UTF-8...
+    */
+
+    *(*bufptr)++ = 0xf0 | (ch >> 18);
+    *(*bufptr)++ = 0x80 | ((ch >> 12) & 0x3f);
+    *(*bufptr)++ = 0x80 | ((ch >> 6) & 0x3f);
+    *(*bufptr)++ = 0x80 | (ch & 0x3f);
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_fd_getc()' - Read a character from a file descriptor.
+ */
+
+static int				/* O  - Character or EOF */
+mxml_fd_getc(void *p,			/* I  - File descriptor buffer */
+             int  *encoding)		/* IO - Encoding */
+{
+  _mxml_fdbuf_t	*buf;			/* File descriptor buffer */
+  int		ch,			/* Current character */
+		temp;			/* Temporary character */
+
+
+ /*
+  * Grab the next character in the buffer...
+  */
+
+  buf = (_mxml_fdbuf_t *)p;
+
+  if (buf->current >= buf->end)
+    if (mxml_fd_read(buf) < 0)
+      return (EOF);
+
+  ch = *(buf->current)++;
+
+  switch (*encoding)
+  {
+    case ENCODE_UTF8 :
+       /*
+	* Got a UTF-8 character; convert UTF-8 to Unicode and return...
+	*/
+
+	if (!(ch & 0x80))
+	{
+#if DEBUG > 1
+          printf("mxml_fd_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+
+	  return (ch);
+        }
+	else if (ch == 0xfe)
+	{
+	 /*
+	  * UTF-16 big-endian BOM?
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  ch = *(buf->current)++;
+          
+	  if (ch != 0xff)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16BE;
+
+	  return (mxml_fd_getc(p, encoding));
+	}
+	else if (ch == 0xff)
+	{
+	 /*
+	  * UTF-16 little-endian BOM?
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  ch = *(buf->current)++;
+          
+	  if (ch != 0xfe)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16LE;
+
+	  return (mxml_fd_getc(p, encoding));
+	}
+	else if ((ch & 0xe0) == 0xc0)
+	{
+	 /*
+	  * Two-byte value...
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x1f) << 6) | (temp & 0x3f);
+
+	  if (ch < 0x80)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else if ((ch & 0xf0) == 0xe0)
+	{
+	 /*
+	  * Three-byte value...
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x800)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+
+         /*
+	  * Ignore (strip) Byte Order Mark (BOM)...
+	  */
+
+	  if (ch == 0xfeff)
+	    return (mxml_fd_getc(p, encoding));
+	}
+	else if ((ch & 0xf8) == 0xf0)
+	{
+	 /*
+	  * Four-byte value...
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x10000)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else
+	  return (EOF);
+	break;
+
+    case ENCODE_UTF16BE :
+       /*
+        * Read UTF-16 big-endian char...
+	*/
+
+	if (buf->current >= buf->end)
+	  if (mxml_fd_read(buf) < 0)
+	    return (EOF);
+
+	temp = *(buf->current)++;
+
+	ch = (ch << 8) | temp;
+
+	if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  lch = *(buf->current)++;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  lch = (lch << 8) | temp;
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+
+    case ENCODE_UTF16LE :
+       /*
+        * Read UTF-16 little-endian char...
+	*/
+
+	if (buf->current >= buf->end)
+	  if (mxml_fd_read(buf) < 0)
+	    return (EOF);
+
+	temp = *(buf->current)++;
+
+	ch |= (temp << 8);
+
+        if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  lch = *(buf->current)++;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  lch |= (temp << 8);
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+  }
+
+#if DEBUG > 1
+  printf("mxml_fd_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+  return (ch);
+}
+
+
+/*
+ * 'mxml_fd_putc()' - Write a character to a file descriptor.
+ */
+
+static int				/* O - 0 on success, -1 on error */
+mxml_fd_putc(int  ch,			/* I - Character */
+             void *p)			/* I - File descriptor buffer */
+{
+  _mxml_fdbuf_t	*buf;			/* File descriptor buffer */
+
+
+ /*
+  * Flush the write buffer as needed...
+  */
+
+  buf = (_mxml_fdbuf_t *)p;
+
+  if (buf->current >= buf->end)
+    if (mxml_fd_write(buf) < 0)
+      return (-1);
+
+  *(buf->current)++ = ch;
+
+ /*
+  * Return successfully...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_fd_read()' - Read a buffer of data from a file descriptor.
+ */
+
+static int				/* O - 0 on success, -1 on error */
+mxml_fd_read(_mxml_fdbuf_t *buf)		/* I - File descriptor buffer */
+{
+  int	bytes;				/* Bytes read... */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!buf)
+    return (-1);
+
+ /*
+  * Read from the file descriptor...
+  */
+
+  while ((bytes = read(buf->fd, buf->buffer, sizeof(buf->buffer))) < 0)
+#ifdef EINTR
+    if (errno != EAGAIN && errno != EINTR)
+#else
+    if (errno != EAGAIN)
+#endif /* EINTR */
+      return (-1);
+
+  if (bytes == 0)
+    return (-1);
+
+ /*
+  * Update the pointers and return success...
+  */
+
+  buf->current = buf->buffer;
+  buf->end     = buf->buffer + bytes;
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_fd_write()' - Write a buffer of data to a file descriptor.
+ */
+
+static int				/* O - 0 on success, -1 on error */
+mxml_fd_write(_mxml_fdbuf_t *buf)	/* I - File descriptor buffer */
+{
+  int		bytes;			/* Bytes written */
+  unsigned char	*ptr;			/* Pointer into buffer */
+
+
+ /*
+  * Range check...
+  */
+
+  if (!buf)
+    return (-1);
+
+ /*
+  * Return 0 if there is nothing to write...
+  */
+
+  if (buf->current == buf->buffer)
+    return (0);
+
+ /*
+  * Loop until we have written everything...
+  */
+
+  for (ptr = buf->buffer; ptr < buf->current; ptr += bytes)
+    if ((bytes = write(buf->fd, ptr, buf->current - ptr)) < 0)
+      return (-1);
+
+ /*
+  * All done, reset pointers and return success...
+  */
+
+  buf->current = buf->buffer;
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_file_getc()' - Get a character from a file.
+ */
+
+static int				/* O  - Character or EOF */
+mxml_file_getc(void *p,			/* I  - Pointer to file */
+               int  *encoding)		/* IO - Encoding */
+{
+  int	ch,				/* Character from file */
+	temp;				/* Temporary character */
+  FILE	*fp;				/* Pointer to file */
+
+
+ /*
+  * Read a character from the file and see if it is EOF or ASCII...
+  */
+
+  fp = (FILE *)p;
+  ch = getc(fp);
+
+  if (ch == EOF)
+    return (EOF);
+
+  switch (*encoding)
+  {
+    case ENCODE_UTF8 :
+       /*
+	* Got a UTF-8 character; convert UTF-8 to Unicode and return...
+	*/
+
+	if (!(ch & 0x80))
+	{
+	  if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+
+#if DEBUG > 1
+          printf("mxml_file_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  return (ch);
+        }
+	else if (ch == 0xfe)
+	{
+	 /*
+	  * UTF-16 big-endian BOM?
+	  */
+
+          ch = getc(fp);
+	  if (ch != 0xff)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16BE;
+
+	  return (mxml_file_getc(p, encoding));
+	}
+	else if (ch == 0xff)
+	{
+	 /*
+	  * UTF-16 little-endian BOM?
+	  */
+
+          ch = getc(fp);
+	  if (ch != 0xfe)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16LE;
+
+	  return (mxml_file_getc(p, encoding));
+	}
+	else if ((ch & 0xe0) == 0xc0)
+	{
+	 /*
+	  * Two-byte value...
+	  */
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x1f) << 6) | (temp & 0x3f);
+
+	  if (ch < 0x80)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else if ((ch & 0xf0) == 0xe0)
+	{
+	 /*
+	  * Three-byte value...
+	  */
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x800)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+
+         /*
+	  * Ignore (strip) Byte Order Mark (BOM)...
+	  */
+
+	  if (ch == 0xfeff)
+	    return (mxml_file_getc(p, encoding));
+	}
+	else if ((ch & 0xf8) == 0xf0)
+	{
+	 /*
+	  * Four-byte value...
+	  */
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x10000)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else
+	  return (EOF);
+	break;
+
+    case ENCODE_UTF16BE :
+       /*
+        * Read UTF-16 big-endian char...
+	*/
+
+	ch = (ch << 8) | getc(fp);
+
+	if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch = (getc(fp) << 8) | getc(fp);
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+
+    case ENCODE_UTF16LE :
+       /*
+        * Read UTF-16 little-endian char...
+	*/
+
+	ch |= (getc(fp) << 8);
+
+        if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch = getc(fp) | (getc(fp) << 8);
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+  }
+
+#if DEBUG > 1
+  printf("mxml_file_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+  return (ch);
+}
+
+
+/*
+ * 'mxml_file_putc()' - Write a character to a file.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_file_putc(int  ch,			/* I - Character to write */
+               void *p)			/* I - Pointer to file */
+{
+  return (putc(ch, (FILE *)p) == EOF ? -1 : 0);
+}
+
+
+/*
+ * 'mxml_get_entity()' - Get the character corresponding to an entity...
+ */
+
+static int				/* O  - Character value or EOF on error */
+mxml_get_entity(mxml_node_t *parent,	/* I  - Parent node */
+		void        *p,		/* I  - Pointer to source */
+		int         *encoding,	/* IO - Character encoding */
+                int         (*getc_cb)(void *, int *))
+					/* I  - Get character function */
+{
+  int	ch;				/* Current character */
+  char	entity[64],			/* Entity string */
+	*entptr;			/* Pointer into entity */
+
+
+  entptr = entity;
+
+  while ((ch = (*getc_cb)(p, encoding)) != EOF)
+    if (ch > 126 || (!isalnum(ch) && ch != '#'))
+      break;
+    else if (entptr < (entity + sizeof(entity) - 1))
+      *entptr++ = ch;
+    else
+    {
+      mxml_error("Entity name too long under parent <%s>!",
+	         parent ? parent->value.element.name : "null");
+      break;
+    }
+
+  *entptr = '\0';
+
+  if (ch != ';')
+  {
+    mxml_error("Character entity \"%s\" not terminated under parent <%s>!",
+	       entity, parent ? parent->value.element.name : "null");
+    return (EOF);
+  }
+
+  if (entity[0] == '#')
+  {
+    if (entity[1] == 'x')
+      ch = strtol(entity + 2, NULL, 16);
+    else
+      ch = strtol(entity + 1, NULL, 10);
+  }
+  else if ((ch = mxmlEntityGetValue(entity)) < 0)
+    mxml_error("Entity name \"%s;\" not supported under parent <%s>!",
+	       entity, parent ? parent->value.element.name : "null");
+
+  if (mxml_bad_char(ch))
+  {
+    mxml_error("Bad control character 0x%02x under parent <%s> not allowed by XML standard!",
+               ch, parent ? parent->value.element.name : "null");
+    return (EOF);
+  }
+
+  return (ch);
+}
+
+
+/*
+ * 'mxml_load_data()' - Load data into an XML node tree.
+ */
+
+static mxml_node_t *			/* O - First node or NULL if the file could not be read. */
+mxml_load_data(
+    mxml_node_t     *top,		/* I - Top node */
+    void            *p,			/* I - Pointer to data */
+    mxml_load_cb_t  cb,			/* I - Callback function or MXML_NO_CALLBACK */
+    _mxml_getc_cb_t getc_cb,		/* I - Read function */
+    mxml_sax_cb_t   sax_cb,		/* I - SAX callback or MXML_NO_CALLBACK */
+    void            *sax_data)		/* I - SAX user data */
+{
+  mxml_node_t	*node,			/* Current node */
+		*first,			/* First node added */
+		*parent;		/* Current parent node */
+  int		ch,			/* Character from file */
+		whitespace;		/* Non-zero if whitespace seen */
+  char		*buffer,		/* String buffer */
+		*bufptr;		/* Pointer into buffer */
+  int		bufsize;		/* Size of buffer */
+  mxml_type_t	type;			/* Current node type */
+  int		encoding;		/* Character encoding */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+  static const char * const types[] =	/* Type strings... */
+		{
+		  "MXML_ELEMENT",	/* XML element with attributes */
+		  "MXML_INTEGER",	/* Integer value */
+		  "MXML_OPAQUE",	/* Opaque string */
+		  "MXML_REAL",		/* Real value */
+		  "MXML_TEXT",		/* Text fragment */
+		  "MXML_CUSTOM"		/* Custom data */
+		};
+
+
+ /*
+  * Read elements and other nodes from the file...
+  */
+
+  if ((buffer = malloc(64)) == NULL)
+  {
+    mxml_error("Unable to allocate string buffer!");
+    return (NULL);
+  }
+
+  bufsize    = 64;
+  bufptr     = buffer;
+  parent     = top;
+  first      = NULL;
+  whitespace = 0;
+  encoding   = ENCODE_UTF8;
+
+  if (cb && parent)
+    type = (*cb)(parent);
+  else
+    type = MXML_TEXT;
+
+  while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+  {
+    if ((ch == '<' ||
+         (mxml_isspace(ch) && type != MXML_OPAQUE && type != MXML_CUSTOM)) &&
+        bufptr > buffer)
+    {
+     /*
+      * Add a new value node...
+      */
+
+      *bufptr = '\0';
+
+      switch (type)
+      {
+	case MXML_INTEGER :
+            node = mxmlNewInteger(parent, strtol(buffer, &bufptr, 0));
+	    break;
+
+	case MXML_OPAQUE :
+            node = mxmlNewOpaque(parent, buffer);
+	    break;
+
+	case MXML_REAL :
+            node = mxmlNewReal(parent, strtod(buffer, &bufptr));
+	    break;
+
+	case MXML_TEXT :
+            node = mxmlNewText(parent, whitespace, buffer);
+	    break;
+
+	case MXML_CUSTOM :
+	    if (global->custom_load_cb)
+	    {
+	     /*
+	      * Use the callback to fill in the custom data...
+	      */
+
+              node = mxmlNewCustom(parent, NULL, NULL);
+
+	      if ((*global->custom_load_cb)(node, buffer))
+	      {
+	        mxml_error("Bad custom value '%s' in parent <%s>!",
+		           buffer, parent ? parent->value.element.name : "null");
+		mxmlDelete(node);
+		node = NULL;
+	      }
+	      break;
+	    }
+
+        default : /* Ignore... */
+	    node = NULL;
+	    break;
+      }	  
+
+      if (*bufptr)
+      {
+       /*
+        * Bad integer/real number value...
+	*/
+
+        mxml_error("Bad %s value '%s' in parent <%s>!",
+	           type == MXML_INTEGER ? "integer" : "real", buffer,
+		   parent ? parent->value.element.name : "null");
+	break;
+      }
+
+      bufptr     = buffer;
+      whitespace = mxml_isspace(ch) && type == MXML_TEXT;
+
+      if (!node && type != MXML_IGNORE)
+      {
+       /*
+	* Print error and return...
+	*/
+
+	mxml_error("Unable to add value node of type %s to parent <%s>!",
+	           types[type], parent ? parent->value.element.name : "null");
+	goto error;
+      }
+
+      if (sax_cb)
+      {
+        (*sax_cb)(node, MXML_SAX_DATA, sax_data);
+
+        if (!mxmlRelease(node))
+          node = NULL;
+      }
+
+      if (!first && node)
+        first = node;
+    }
+    else if (mxml_isspace(ch) && type == MXML_TEXT)
+      whitespace = 1;
+
+   /*
+    * Add lone whitespace node if we have an element and existing
+    * whitespace...
+    */
+
+    if (ch == '<' && whitespace && type == MXML_TEXT)
+    {
+      node = mxmlNewText(parent, whitespace, "");
+
+      if (sax_cb)
+      {
+        (*sax_cb)(node, MXML_SAX_DATA, sax_data);
+
+        if (!mxmlRelease(node))
+          node = NULL;
+      }
+
+      if (!first && node)
+        first = node;
+
+      whitespace = 0;
+    }
+
+    if (ch == '<')
+    {
+     /*
+      * Start of open/close tag...
+      */
+
+      bufptr = buffer;
+
+      while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+        if (mxml_isspace(ch) || ch == '>' || (ch == '/' && bufptr > buffer))
+	  break;
+	else if (ch == '<')
+	{
+	  mxml_error("Bare < in element!");
+	  goto error;
+	}
+	else if (ch == '&')
+	{
+	  if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb)) == EOF)
+	    goto error;
+
+	  if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+	}
+	else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	  goto error;
+	else if (((bufptr - buffer) == 1 && buffer[0] == '?') ||
+	         ((bufptr - buffer) == 3 && !strncmp(buffer, "!--", 3)) ||
+	         ((bufptr - buffer) == 8 && !strncmp(buffer, "![CDATA[", 8)))
+	  break;
+
+      *bufptr = '\0';
+
+      if (!strcmp(buffer, "!--"))
+      {
+       /*
+        * Gather rest of comment...
+	*/
+
+	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+	{
+	  if (ch == '>' && bufptr > (buffer + 4) &&
+	      bufptr[-3] != '-' && bufptr[-2] == '-' && bufptr[-1] == '-')
+	    break;
+	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+	}
+
+       /*
+        * Error out if we didn't get the whole comment...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in comment node!");
+	  goto error;
+	}
+
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Just print error for now...
+	  */
+
+	  mxml_error("Unable to add comment node to parent <%s>!",
+	             parent ? parent->value.element.name : "null");
+	  break;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_COMMENT, sax_data);
+
+          if (!mxmlRelease(node))
+            node = NULL;
+        }
+
+	if (node && !first)
+	  first = node;
+      }
+      else if (!strcmp(buffer, "![CDATA["))
+      {
+       /*
+        * Gather CDATA section...
+	*/
+
+	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+	{
+	  if (ch == '>' && !strncmp(bufptr - 2, "]]", 2))
+	    break;
+	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+	}
+
+       /*
+        * Error out if we didn't get the whole comment...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in CDATA node!");
+	  goto error;
+	}
+
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Unable to add CDATA node to parent <%s>!",
+	             parent ? parent->value.element.name : "null");
+	  goto error;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_CDATA, sax_data);
+
+          if (!mxmlRelease(node))
+            node = NULL;
+        }
+
+	if (node && !first)
+	  first = node;
+      }
+      else if (buffer[0] == '?')
+      {
+       /*
+        * Gather rest of processing instruction...
+	*/
+
+	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+	{
+	  if (ch == '>' && bufptr > buffer && bufptr[-1] == '?')
+	    break;
+	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+	}
+
+       /*
+        * Error out if we didn't get the whole processing instruction...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in processing instruction node!");
+	  goto error;
+	}
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Unable to add processing instruction node to parent <%s>!",
+	             parent ? parent->value.element.name : "null");
+	  goto error;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_DIRECTIVE, sax_data);
+
+          if (!mxmlRelease(node))
+            node = NULL;
+        }
+
+        if (node)
+	{
+	  if (!first)
+            first = node;
+
+	  if (!parent)
+	  {
+	    parent = node;
+
+	    if (cb)
+	      type = (*cb)(parent);
+	  }
+	}
+      }
+      else if (buffer[0] == '!')
+      {
+       /*
+        * Gather rest of declaration...
+	*/
+
+	do
+	{
+	  if (ch == '>')
+	    break;
+	  else
+	  {
+            if (ch == '&')
+	      if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb)) == EOF)
+		goto error;
+
+	    if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	      goto error;
+	  }
+	}
+        while ((ch = (*getc_cb)(p, &encoding)) != EOF);
+
+       /*
+        * Error out if we didn't get the whole declaration...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in declaration node!");
+	  goto error;
+	}
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Unable to add declaration node to parent <%s>!",
+	             parent ? parent->value.element.name : "null");
+	  goto error;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_DIRECTIVE, sax_data);
+
+          if (!mxmlRelease(node))
+            node = NULL;
+        }
+
+        if (node)
+	{
+	  if (!first)
+            first = node;
+
+	  if (!parent)
+	  {
+	    parent = node;
+
+	    if (cb)
+	      type = (*cb)(parent);
+	  }
+	}
+      }
+      else if (buffer[0] == '/')
+      {
+       /*
+        * Handle close tag...
+	*/
+
+        if (!parent || strcmp(buffer + 1, parent->value.element.name))
+	{
+	 /*
+	  * Close tag doesn't match tree; print an error for now...
+	  */
+
+	  mxml_error("Mismatched close tag <%s> under parent <%s>!",
+	             buffer, parent ? parent->value.element.name : "(null)");
+          goto error;
+	}
+
+       /*
+        * Keep reading until we see >...
+	*/
+
+        while (ch != '>' && ch != EOF)
+	  ch = (*getc_cb)(p, &encoding);
+
+        node   = parent;
+        parent = parent->parent;
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_ELEMENT_CLOSE, sax_data);
+
+          mxmlRelease(node);
+        }
+
+       /*
+	* Ascend into the parent and set the value type as needed...
+	*/
+
+	if (cb && parent)
+	  type = (*cb)(parent);
+      }
+      else
+      {
+       /*
+        * Handle open tag...
+	*/
+
+        if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Just print error for now...
+	  */
+
+	  mxml_error("Unable to add element node to parent <%s>!",
+	             parent ? parent->value.element.name : "null");
+	  goto error;
+	}
+
+        if (mxml_isspace(ch))
+        {
+	  if ((ch = mxml_parse_element(node, p, &encoding, getc_cb)) == EOF)
+	    goto error;
+        }
+        else if (ch == '/')
+	{
+	  if ((ch = (*getc_cb)(p, &encoding)) != '>')
+	  {
+	    mxml_error("Expected > but got '%c' instead for element <%s/>!",
+	               ch, buffer);
+            mxmlDelete(node);
+            goto error;
+	  }
+
+	  ch = '/';
+	}
+
+        if (sax_cb)
+          (*sax_cb)(node, MXML_SAX_ELEMENT_OPEN, sax_data);
+
+        if (!first)
+	  first = node;
+
+	if (ch == EOF)
+	  break;
+
+        if (ch != '/')
+	{
+	 /*
+	  * Descend into this node, setting the value type as needed...
+	  */
+
+	  parent = node;
+
+	  if (cb && parent)
+	    type = (*cb)(parent);
+	}
+        else if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_ELEMENT_CLOSE, sax_data);
+
+          if (!mxmlRelease(node) && first == node)
+            first = NULL;
+        }
+      }
+
+      bufptr  = buffer;
+    }
+    else if (ch == '&')
+    {
+     /*
+      * Add character entity to current buffer...
+      */
+
+      if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb)) == EOF)
+	goto error;
+
+      if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	goto error;
+    }
+    else if (type == MXML_OPAQUE || type == MXML_CUSTOM || !mxml_isspace(ch))
+    {
+     /*
+      * Add character to current buffer...
+      */
+
+      if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	goto error;
+    }
+  }
+
+ /*
+  * Free the string buffer - we don't need it anymore...
+  */
+
+  free(buffer);
+
+ /*
+  * Find the top element and return it...
+  */
+
+  if (parent)
+  {
+    node = parent;
+
+    while (parent->parent != top && parent->parent)
+      parent = parent->parent;
+
+    if (node != parent)
+    {
+      mxml_error("Missing close tag </%s> under parent <%s>!",
+	         node->value.element.name,
+		 node->parent ? node->parent->value.element.name : "(null)");
+
+      mxmlDelete(first);
+
+      return (NULL);
+    }
+  }
+
+  if (parent)
+    return (parent);
+  else
+    return (first);
+
+ /*
+  * Common error return...
+  */
+
+error:
+
+  mxmlDelete(first);
+
+  free(buffer);
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxml_parse_element()' - Parse an element for any attributes...
+ */
+
+static int				/* O  - Terminating character */
+mxml_parse_element(
+    mxml_node_t     *node,		/* I  - Element node */
+    void            *p,			/* I  - Data to read from */
+    int             *encoding,		/* IO - Encoding */
+    _mxml_getc_cb_t getc_cb)		/* I  - Data callback */
+{
+  int	ch,				/* Current character in file */
+	quote;				/* Quoting character */
+  char	*name,				/* Attribute name */
+	*value,				/* Attribute value */
+	*ptr;				/* Pointer into name/value */
+  int	namesize,			/* Size of name string */
+	valsize;			/* Size of value string */
+
+
+ /*
+  * Initialize the name and value buffers...
+  */
+
+  if ((name = malloc(64)) == NULL)
+  {
+    mxml_error("Unable to allocate memory for name!");
+    return (EOF);
+  }
+
+  namesize = 64;
+
+  if ((value = malloc(64)) == NULL)
+  {
+    free(name);
+    mxml_error("Unable to allocate memory for value!");
+    return (EOF);
+  }
+
+  valsize = 64;
+
+ /*
+  * Loop until we hit a >, /, ?, or EOF...
+  */
+
+  while ((ch = (*getc_cb)(p, encoding)) != EOF)
+  {
+#if DEBUG > 1
+    fprintf(stderr, "parse_element: ch='%c'\n", ch);
+#endif /* DEBUG > 1 */
+
+   /*
+    * Skip leading whitespace...
+    */
+
+    if (mxml_isspace(ch))
+      continue;
+
+   /*
+    * Stop at /, ?, or >...
+    */
+
+    if (ch == '/' || ch == '?')
+    {
+     /*
+      * Grab the > character and print an error if it isn't there...
+      */
+
+      quote = (*getc_cb)(p, encoding);
+
+      if (quote != '>')
+      {
+        mxml_error("Expected '>' after '%c' for element %s, but got '%c'!",
+	           ch, node->value.element.name, quote);
+        goto error;
+      }
+
+      break;
+    }
+    else if (ch == '<')
+    {
+      mxml_error("Bare < in element %s!", node->value.element.name);
+      goto error;
+    }
+    else if (ch == '>')
+      break;
+
+   /*
+    * Read the attribute name...
+    */
+
+    name[0] = ch;
+    ptr     = name + 1;
+
+    if (ch == '\"' || ch == '\'')
+    {
+     /*
+      * Name is in quotes, so get a quoted string...
+      */
+
+      quote = ch;
+
+      while ((ch = (*getc_cb)(p, encoding)) != EOF)
+      {
+        if (ch == '&')
+	  if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
+	    goto error;
+
+	if (mxml_add_char(ch, &ptr, &name, &namesize))
+	  goto error;
+
+	if (ch == quote)
+          break;
+      }
+    }
+    else
+    {
+     /*
+      * Grab an normal, non-quoted name...
+      */
+
+      while ((ch = (*getc_cb)(p, encoding)) != EOF)
+	if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>' ||
+	    ch == '?')
+          break;
+	else
+	{
+          if (ch == '&')
+	    if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
+	      goto error;
+
+	  if (mxml_add_char(ch, &ptr, &name, &namesize))
+	    goto error;
+	}
+    }
+
+    *ptr = '\0';
+
+    if (mxmlElementGetAttr(node, name))
+      goto error;
+
+    while (ch != EOF && mxml_isspace(ch))
+      ch = (*getc_cb)(p, encoding);
+
+    if (ch == '=')
+    {
+     /*
+      * Read the attribute value...
+      */
+
+      while ((ch = (*getc_cb)(p, encoding)) != EOF && mxml_isspace(ch));
+
+      if (ch == EOF)
+      {
+        mxml_error("Missing value for attribute '%s' in element %s!",
+	           name, node->value.element.name);
+        goto error;
+      }
+
+      if (ch == '\'' || ch == '\"')
+      {
+       /*
+        * Read quoted value...
+	*/
+
+        quote = ch;
+	ptr   = value;
+
+        while ((ch = (*getc_cb)(p, encoding)) != EOF)
+	  if (ch == quote)
+	    break;
+	  else
+	  {
+	    if (ch == '&')
+	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
+	        goto error;
+	      
+	    if (mxml_add_char(ch, &ptr, &value, &valsize))
+	      goto error;
+	  }
+
+        *ptr = '\0';
+      }
+      else
+      {
+       /*
+        * Read unquoted value...
+	*/
+
+	value[0] = ch;
+	ptr      = value + 1;
+
+	while ((ch = (*getc_cb)(p, encoding)) != EOF)
+	  if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>')
+            break;
+	  else
+	  {
+	    if (ch == '&')
+	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
+	        goto error;
+	      
+	    if (mxml_add_char(ch, &ptr, &value, &valsize))
+	      goto error;
+	  }
+
+        *ptr = '\0';
+      }
+
+     /*
+      * Set the attribute with the given string value...
+      */
+
+      mxmlElementSetAttr(node, name, value);
+    }
+    else
+    {
+      mxml_error("Missing value for attribute '%s' in element %s!",
+	         name, node->value.element.name);
+      goto error;
+    }
+
+   /*
+    * Check the end character...
+    */
+
+    if (ch == '/' || ch == '?')
+    {
+     /*
+      * Grab the > character and print an error if it isn't there...
+      */
+
+      quote = (*getc_cb)(p, encoding);
+
+      if (quote != '>')
+      {
+        mxml_error("Expected '>' after '%c' for element %s, but got '%c'!",
+	           ch, node->value.element.name, quote);
+        ch = EOF;
+      }
+
+      break;
+    }
+    else if (ch == '>')
+      break;
+  }
+
+ /*
+  * Free the name and value buffers and return...
+  */
+
+  free(name);
+  free(value);
+
+  return (ch);
+
+ /*
+  * Common error return point...
+  */
+
+error:
+
+  free(name);
+  free(value);
+
+  return (EOF);
+}
+
+
+/*
+ * 'mxml_string_getc()' - Get a character from a string.
+ */
+
+static int				/* O  - Character or EOF */
+mxml_string_getc(void *p,		/* I  - Pointer to file */
+                 int  *encoding)	/* IO - Encoding */
+{
+  int		ch;			/* Character */
+  const char	**s;			/* Pointer to string pointer */
+
+
+  s = (const char **)p;
+
+  if ((ch = (*s)[0] & 255) != 0 || *encoding == ENCODE_UTF16LE)
+  {
+   /*
+    * Got character; convert UTF-8 to integer and return...
+    */
+
+    (*s)++;
+
+    switch (*encoding)
+    {
+      case ENCODE_UTF8 :
+	  if (!(ch & 0x80))
+	  {
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    if (mxml_bad_char(ch))
+	    {
+	      mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        		 ch);
+	      return (EOF);
+	    }
+
+	    return (ch);
+          }
+	  else if (ch == 0xfe)
+	  {
+	   /*
+	    * UTF-16 big-endian BOM?
+	    */
+
+            if (((*s)[0] & 255) != 0xff)
+	      return (EOF);
+
+	    *encoding = ENCODE_UTF16BE;
+	    (*s)++;
+
+	    return (mxml_string_getc(p, encoding));
+	  }
+	  else if (ch == 0xff)
+	  {
+	   /*
+	    * UTF-16 little-endian BOM?
+	    */
+
+            if (((*s)[0] & 255) != 0xfe)
+	      return (EOF);
+
+	    *encoding = ENCODE_UTF16LE;
+	    (*s)++;
+
+	    return (mxml_string_getc(p, encoding));
+	  }
+	  else if ((ch & 0xe0) == 0xc0)
+	  {
+	   /*
+	    * Two-byte value...
+	    */
+
+	    if (((*s)[0] & 0xc0) != 0x80)
+              return (EOF);
+
+	    ch = ((ch & 0x1f) << 6) | ((*s)[0] & 0x3f);
+
+	    (*s)++;
+
+	    if (ch < 0x80)
+	    {
+	      mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	      return (EOF);
+	    }
+
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    return (ch);
+	  }
+	  else if ((ch & 0xf0) == 0xe0)
+	  {
+	   /*
+	    * Three-byte value...
+	    */
+
+	    if (((*s)[0] & 0xc0) != 0x80 ||
+        	((*s)[1] & 0xc0) != 0x80)
+              return (EOF);
+
+	    ch = ((((ch & 0x0f) << 6) | ((*s)[0] & 0x3f)) << 6) | ((*s)[1] & 0x3f);
+
+	    (*s) += 2;
+
+	    if (ch < 0x800)
+	    {
+	      mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	      return (EOF);
+	    }
+
+	   /*
+	    * Ignore (strip) Byte Order Mark (BOM)...
+	    */
+
+	    if (ch == 0xfeff)
+	      return (mxml_string_getc(p, encoding));
+
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    return (ch);
+	  }
+	  else if ((ch & 0xf8) == 0xf0)
+	  {
+	   /*
+	    * Four-byte value...
+	    */
+
+	    if (((*s)[0] & 0xc0) != 0x80 ||
+        	((*s)[1] & 0xc0) != 0x80 ||
+        	((*s)[2] & 0xc0) != 0x80)
+              return (EOF);
+
+	    ch = ((((((ch & 0x07) << 6) | ((*s)[0] & 0x3f)) << 6) |
+        	   ((*s)[1] & 0x3f)) << 6) | ((*s)[2] & 0x3f);
+
+	    (*s) += 3;
+
+	    if (ch < 0x10000)
+	    {
+	      mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	      return (EOF);
+	    }
+
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    return (ch);
+	  }
+	  else
+	    return (EOF);
+
+      case ENCODE_UTF16BE :
+	 /*
+          * Read UTF-16 big-endian char...
+	  */
+
+	  ch = (ch << 8) | ((*s)[0] & 255);
+	  (*s) ++;
+
+          if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+          else if (ch >= 0xd800 && ch <= 0xdbff)
+	  {
+	   /*
+	    * Multi-word UTF-16 char...
+	    */
+
+            int lch;			/* Lower word */
+
+
+            if (!(*s)[0])
+	      return (EOF);
+
+            lch = (((*s)[0] & 255) << 8) | ((*s)[1] & 255);
+	    (*s) += 2;
+
+            if (lch < 0xdc00 || lch >= 0xdfff)
+	      return (EOF);
+
+            ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	  }
+
+#if DEBUG > 1
+          printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  return (ch);
+
+      case ENCODE_UTF16LE :
+	 /*
+          * Read UTF-16 little-endian char...
+	  */
+
+	  ch = ch | (((*s)[0] & 255) << 8);
+
+	  if (!ch)
+	  {
+	    (*s) --;
+	    return (EOF);
+	  }
+
+	  (*s) ++;
+
+          if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+          else if (ch >= 0xd800 && ch <= 0xdbff)
+	  {
+	   /*
+	    * Multi-word UTF-16 char...
+	    */
+
+            int lch;			/* Lower word */
+
+
+            if (!(*s)[1])
+	      return (EOF);
+
+            lch = (((*s)[1] & 255) << 8) | ((*s)[0] & 255);
+	    (*s) += 2;
+
+            if (lch < 0xdc00 || lch >= 0xdfff)
+	      return (EOF);
+
+            ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	  }
+
+#if DEBUG > 1
+          printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  return (ch);
+    }
+  }
+
+  return (EOF);
+}
+
+
+/*
+ * 'mxml_string_putc()' - Write a character to a string.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_string_putc(int  ch,		/* I - Character to write */
+                 void *p)		/* I - Pointer to string pointers */
+{
+  char	**pp;				/* Pointer to string pointers */
+
+
+  pp = (char **)p;
+
+  if (pp[0] < pp[1])
+    pp[0][0] = ch;
+
+  pp[0] ++;
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_write_name()' - Write a name string.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_write_name(const char *s,		/* I - Name to write */
+                void       *p,		/* I - Write pointer */
+		int        (*putc_cb)(int, void *))
+					/* I - Write callback */
+{
+  char		quote;			/* Quote character */
+  const char	*name;			/* Entity name */
+
+
+  if (*s == '\"' || *s == '\'')
+  {
+   /*
+    * Write a quoted name string...
+    */
+
+    if ((*putc_cb)(*s, p) < 0)
+      return (-1);
+
+    quote = *s++;
+
+    while (*s && *s != quote)
+    {
+      if ((name = mxmlEntityGetName(*s)) != NULL)
+      {
+	if ((*putc_cb)('&', p) < 0)
+          return (-1);
+
+        while (*name)
+	{
+	  if ((*putc_cb)(*name, p) < 0)
+            return (-1);
+
+          name ++;
+	}
+
+	if ((*putc_cb)(';', p) < 0)
+          return (-1);
+      }
+      else if ((*putc_cb)(*s, p) < 0)
+	return (-1);
+
+      s ++;
+    }
+
+   /*
+    * Write the end quote...
+    */
+
+    if ((*putc_cb)(quote, p) < 0)
+      return (-1);
+  }
+  else
+  {
+   /*
+    * Write a non-quoted name string...
+    */
+
+    while (*s)
+    {
+      if ((*putc_cb)(*s, p) < 0)
+	return (-1);
+
+      s ++;
+    }
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_write_node()' - Save an XML node to a file.
+ */
+
+static int				/* O - Column or -1 on error */
+mxml_write_node(mxml_node_t     *node,	/* I - Node to write */
+                void            *p,	/* I - File to write to */
+	        mxml_save_cb_t  cb,	/* I - Whitespace callback */
+		int             col,	/* I - Current column */
+		_mxml_putc_cb_t putc_cb,/* I - Output callback */
+		_mxml_global_t  *global)/* I - Global data */
+{
+  int		i,			/* Looping var */
+		width;			/* Width of attr + value */
+  mxml_attr_t	*attr;			/* Current attribute */
+  char		s[255];			/* Temporary string */
+
+
+  while (node != NULL)
+  {
+   /*
+    * Print the node value...
+    */
+
+    switch (node->type)
+    {
+      case MXML_ELEMENT :
+          col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_OPEN, col, putc_cb);
+
+          if ((*putc_cb)('<', p) < 0)
+	    return (-1);
+          if (node->value.element.name[0] == '?' ||
+	      !strncmp(node->value.element.name, "!--", 3) ||
+	      !strncmp(node->value.element.name, "![CDATA[", 8))
+          {
+	   /*
+	    * Comments, CDATA, and processing instructions do not
+	    * use character entities.
+	    */
+
+	    const char	*ptr;		/* Pointer into name */
+
+
+	    for (ptr = node->value.element.name; *ptr; ptr ++)
+	      if ((*putc_cb)(*ptr, p) < 0)
+	        return (-1);
+	  }
+	  else if (mxml_write_name(node->value.element.name, p, putc_cb) < 0)
+	    return (-1);
+
+          col += strlen(node->value.element.name) + 1;
+
+	  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+	       i > 0;
+	       i --, attr ++)
+	  {
+	    width = strlen(attr->name);
+
+	    if (attr->value)
+	      width += strlen(attr->value) + 3;
+
+	    if (global->wrap > 0 && (col + width) > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+	        return (-1);
+
+	      col = 0;
+	    }
+	    else
+	    {
+	      if ((*putc_cb)(' ', p) < 0)
+	        return (-1);
+
+	      col ++;
+	    }
+
+            if (mxml_write_name(attr->name, p, putc_cb) < 0)
+	      return (-1);
+
+	    if (attr->value)
+	    {
+              if ((*putc_cb)('=', p) < 0)
+		return (-1);
+              if ((*putc_cb)('\"', p) < 0)
+		return (-1);
+	      if (mxml_write_string(attr->value, p, putc_cb) < 0)
+		return (-1);
+              if ((*putc_cb)('\"', p) < 0)
+		return (-1);
+            }
+
+            col += width;
+	  }
+
+	  if (node->child)
+	  {
+           /*
+	    * Write children...
+	    */
+
+	    if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+
+            col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+
+	    if ((col = mxml_write_node(node->child, p, cb, col, putc_cb,
+	                               global)) < 0)
+	      return (-1);
+
+           /*
+	    * The ? and ! elements are special-cases and have no end tags...
+	    */
+
+            if (node->value.element.name[0] != '!' &&
+	        node->value.element.name[0] != '?')
+	    {
+              col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);
+
+              if ((*putc_cb)('<', p) < 0)
+		return (-1);
+              if ((*putc_cb)('/', p) < 0)
+		return (-1);
+              if (mxml_write_string(node->value.element.name, p, putc_cb) < 0)
+		return (-1);
+              if ((*putc_cb)('>', p) < 0)
+		return (-1);
+
+              col += strlen(node->value.element.name) + 3;
+
+              col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
+	    }
+	  }
+	  else if (node->value.element.name[0] == '!' ||
+	           node->value.element.name[0] == '?')
+	  {
+           /*
+	    * The ? and ! elements are special-cases...
+	    */
+
+	    if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+
+            col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+          }
+	  else
+	  {
+            if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+            if ((*putc_cb)('/', p) < 0)
+	      return (-1);
+            if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+
+	    col += 3;
+
+            col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+	  }
+          break;
+
+      case MXML_INTEGER :
+	  if (node->prev)
+	  {
+	    if (global->wrap > 0 && col > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+	        return (-1);
+
+	      col = 0;
+	    }
+	    else if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+          }
+
+          sprintf(s, "%d", node->value.integer);
+	  if (mxml_write_string(s, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(s);
+          break;
+
+      case MXML_OPAQUE :
+          if (mxml_write_string(node->value.opaque, p, putc_cb) < 0)
+	    return (-1);
+
+          col += strlen(node->value.opaque);
+          break;
+
+      case MXML_REAL :
+	  if (node->prev)
+	  {
+	    if (global->wrap > 0 && col > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+	        return (-1);
+
+	      col = 0;
+	    }
+	    else if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+          }
+
+          sprintf(s, "%f", node->value.real);
+	  if (mxml_write_string(s, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(s);
+          break;
+
+      case MXML_TEXT :
+	  if (node->value.text.whitespace && col > 0)
+	  {
+	    if (global->wrap > 0 && col > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+	        return (-1);
+
+	      col = 0;
+	    }
+	    else if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+          }
+
+          if (mxml_write_string(node->value.text.string, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(node->value.text.string);
+          break;
+
+      case MXML_CUSTOM :
+          if (global->custom_save_cb)
+	  {
+	    char	*data;		/* Custom data string */
+	    const char	*newline;	/* Last newline in string */
+
+
+            if ((data = (*global->custom_save_cb)(node)) == NULL)
+	      return (-1);
+
+            if (mxml_write_string(data, p, putc_cb) < 0)
+	      return (-1);
+
+            if ((newline = strrchr(data, '\n')) == NULL)
+	      col += strlen(data);
+	    else
+              col = strlen(newline);
+
+            free(data);
+	    break;
+	  }
+
+      default : /* Should never happen */
+          return (-1);
+    }
+
+   /*
+    * Next node...
+    */
+
+    node = node->next;
+  }
+
+  return (col);
+}
+
+
+/*
+ * 'mxml_write_string()' - Write a string, escaping & and < as needed.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_write_string(
+    const char      *s,			/* I - String to write */
+    void            *p,			/* I - Write pointer */
+    _mxml_putc_cb_t putc_cb)		/* I - Write callback */
+{
+  const char	*name;			/* Entity name, if any */
+
+
+  while (*s)
+  {
+    if ((name = mxmlEntityGetName(*s)) != NULL)
+    {
+      if ((*putc_cb)('&', p) < 0)
+        return (-1);
+
+      while (*name)
+      {
+	if ((*putc_cb)(*name, p) < 0)
+          return (-1);
+        name ++;
+      }
+
+      if ((*putc_cb)(';', p) < 0)
+        return (-1);
+    }
+    else if ((*putc_cb)(*s, p) < 0)
+      return (-1);
+
+    s ++;
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_write_ws()' - Do whitespace callback...
+ */
+
+static int				/* O - New column */
+mxml_write_ws(mxml_node_t     *node,	/* I - Current node */
+              void            *p,	/* I - Write pointer */
+              mxml_save_cb_t  cb,	/* I - Callback function */
+	      int             ws,	/* I - Where value */
+	      int             col,	/* I - Current column */
+              _mxml_putc_cb_t putc_cb)	/* I - Write callback */
+{
+  const char	*s;			/* Whitespace string */
+
+
+  if (cb && (s = (*cb)(node, ws)) != NULL)
+  {
+    while (*s)
+    {
+      if ((*putc_cb)(*s, p) < 0)
+	return (-1);
+      else if (*s == '\n')
+	col = 0;
+      else if (*s == '\t')
+      {
+	col += MXML_TAB;
+	col = col - (col % MXML_TAB);
+      }
+      else
+	col ++;
+
+      s ++;
+    }
+  }
+
+  return (col);
+}
+
+
+/*
+ * End of "$Id: mxml-file.c 391 2009-05-17 05:20:52Z mike $".
+ */
diff -Naur mxml-2.6/mxml-index.c mxml-2.6-haiku/mxml-index.c
--- mxml-2.6/mxml-index.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-index.c	2005-01-29 07:21:44.000000000 +0000
@@ -0,0 +1,649 @@
+/*
+ * "$Id: mxml-index.c 184 2005-01-29 07:21:44Z mike $"
+ *
+ * Index support code for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2005 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxmlIndexDelete()   - Delete an index.
+ *   mxmlIndexEnum()     - Return the next node in the index.
+ *   mxmlIndexFind()     - Find the next matching node.
+ *   mxmlIndexNew()      - Create a new index.
+ *   mxmlIndexReset()    - Reset the enumeration/find pointer in the index and
+ *                         return the first node in the index.
+ *   index_compare()     - Compare two nodes.
+ *   index_find()        - Compare a node with index values.
+ *   index_sort()        - Sort the nodes in the index...
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+
+
+/*
+ * Sort functions...
+ */
+
+static int	index_compare(mxml_index_t *ind, mxml_node_t *first,
+		              mxml_node_t *second);
+static int	index_find(mxml_index_t *ind, const char *element,
+		           const char *value, mxml_node_t *node);
+static void	index_sort(mxml_index_t *ind, int left, int right);
+
+
+/*
+ * 'mxmlIndexDelete()' - Delete an index.
+ */
+
+void
+mxmlIndexDelete(mxml_index_t *ind)	/* I - Index to delete */
+{
+ /*
+  * Range check input..
+  */
+
+  if (!ind)
+    return;
+
+ /*
+  * Free memory...
+  */
+
+  if (ind->attr)
+    free(ind->attr);
+
+  if (ind->alloc_nodes)
+    free(ind->nodes);
+
+  free(ind);
+}
+
+
+/*
+ * 'mxmlIndexEnum()' - Return the next node in the index.
+ *
+ * Nodes are returned in the sorted order of the index.
+ */
+
+mxml_node_t *				/* O - Next node or NULL if there is none */
+mxmlIndexEnum(mxml_index_t *ind)	/* I - Index to enumerate */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!ind)
+    return (NULL);
+
+ /*
+  * Return the next node...
+  */
+
+  if (ind->cur_node < ind->num_nodes)
+    return (ind->nodes[ind->cur_node ++]);
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'mxmlIndexFind()' - Find the next matching node.
+ *
+ * You should call mxmlIndexReset() prior to using this function for
+ * the first time with a particular set of "element" and "value"
+ * strings. Passing NULL for both "element" and "value" is equivalent
+ * to calling mxmlIndexEnum().
+ */
+
+mxml_node_t *				/* O - Node or NULL if none found */
+mxmlIndexFind(mxml_index_t *ind,	/* I - Index to search */
+              const char   *element,	/* I - Element name to find, if any */
+	      const char   *value)	/* I - Attribute value, if any */
+{
+  int		diff,			/* Difference between names */
+		current,		/* Current entity in search */
+		first,			/* First entity in search */
+		last;			/* Last entity in search */
+
+
+#ifdef DEBUG
+  printf("mxmlIndexFind(ind=%p, element=\"%s\", value=\"%s\")\n",
+         ind, element ? element : "(null)", value ? value : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!ind || (!ind->attr && value))
+  {
+#ifdef DEBUG
+    puts("    returning NULL...");
+    printf("    ind->attr=\"%s\"\n", ind->attr ? ind->attr : "(null)");
+#endif /* DEBUG */
+
+    return (NULL);
+  }
+
+ /*
+  * If both element and value are NULL, just enumerate the nodes in the
+  * index...
+  */
+
+  if (!element && !value)
+    return (mxmlIndexEnum(ind));
+
+ /*
+  * If there are no nodes in the index, return NULL...
+  */
+
+  if (!ind->num_nodes)
+  {
+#ifdef DEBUG
+    puts("    returning NULL...");
+    puts("    no nodes!");
+#endif /* DEBUG */
+
+    return (NULL);
+  }
+
+ /*
+  * If cur_node == 0, then find the first matching node...
+  */
+
+  if (ind->cur_node == 0)
+  {
+   /*
+    * Find the first node using a modified binary search algorithm...
+    */
+
+    first = 0;
+    last  = ind->num_nodes - 1;
+
+#ifdef DEBUG
+    printf("    find first time, num_nodes=%d...\n", ind->num_nodes);
+#endif /* DEBUG */
+
+    while ((last - first) > 1)
+    {
+      current = (first + last) / 2;
+
+#ifdef DEBUG
+      printf("    first=%d, last=%d, current=%d\n", first, last, current);
+#endif /* DEBUG */
+
+      if ((diff = index_find(ind, element, value, ind->nodes[current])) == 0)
+      {
+       /*
+        * Found a match, move back to find the first...
+	*/
+
+#ifdef DEBUG
+        puts("    match!");
+#endif /* DEBUG */
+
+        while (current > 0 &&
+	       !index_find(ind, element, value, ind->nodes[current - 1]))
+	  current --;
+
+#ifdef DEBUG
+        printf("    returning first match=%d\n", current);
+#endif /* DEBUG */
+
+       /*
+        * Return the first match and save the index to the next...
+	*/
+
+        ind->cur_node = current + 1;
+
+	return (ind->nodes[current]);
+      }
+      else if (diff < 0)
+	last = current;
+      else
+	first = current;
+
+#ifdef DEBUG
+      printf("    diff=%d\n", diff);
+#endif /* DEBUG */
+    }
+
+   /*
+    * If we get this far, then we found exactly 0 or 1 matches...
+    */
+
+    for (current = first; current <= last; current ++)
+      if (!index_find(ind, element, value, ind->nodes[current]))
+      {
+       /*
+	* Found exactly one (or possibly two) match...
+	*/
+
+#ifdef DEBUG
+	printf("    returning only match %d...\n", current);
+#endif /* DEBUG */
+
+	ind->cur_node = current + 1;
+
+	return (ind->nodes[current]);
+      }
+
+   /*
+    * No matches...
+    */
+
+    ind->cur_node = ind->num_nodes;
+
+#ifdef DEBUG
+    puts("    returning NULL...");
+#endif /* DEBUG */
+
+    return (NULL);
+  }
+  else if (ind->cur_node < ind->num_nodes &&
+           !index_find(ind, element, value, ind->nodes[ind->cur_node]))
+  {
+   /*
+    * Return the next matching node...
+    */
+
+#ifdef DEBUG
+    printf("    returning next match %d...\n", ind->cur_node);
+#endif /* DEBUG */
+
+    return (ind->nodes[ind->cur_node ++]);
+  }
+
+ /*
+  * If we get this far, then we have no matches...
+  */
+
+  ind->cur_node = ind->num_nodes;
+
+#ifdef DEBUG
+  puts("    returning NULL...");
+#endif /* DEBUG */
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxmlIndexNew()' - Create a new index.
+ *
+ * The index will contain all nodes that contain the named element and/or
+ * attribute. If both "element" and "attr" are NULL, then the index will
+ * contain a sorted list of the elements in the node tree.  Nodes are
+ * sorted by element name and optionally by attribute value if the "attr"
+ * argument is not NULL.
+ */
+
+mxml_index_t *				/* O - New index */
+mxmlIndexNew(mxml_node_t *node,		/* I - XML node tree */
+             const char  *element,	/* I - Element to index or NULL for all */
+             const char  *attr)		/* I - Attribute to index or NULL for none */
+{
+  mxml_index_t	*ind;			/* New index */
+  mxml_node_t	*current,		/* Current node in index */
+  		**temp;			/* Temporary node pointer array */
+
+
+ /*
+  * Range check input...
+  */
+
+#ifdef DEBUG
+  printf("mxmlIndexNew(node=%p, element=\"%s\", attr=\"%s\")\n",
+         node, element ? element : "(null)", attr ? attr : "(null)");
+#endif /* DEBUG */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Create a new index...
+  */
+
+  if ((ind = calloc(1, sizeof(mxml_index_t))) == NULL)
+  {
+    mxml_error("Unable to allocate %d bytes for index - %s",
+               sizeof(mxml_index_t), strerror(errno));
+    return (NULL);
+  }
+
+  if (attr)
+    ind->attr = strdup(attr);
+
+  if (!element && !attr)
+    current = node;
+  else
+    current = mxmlFindElement(node, node, element, attr, NULL, MXML_DESCEND);
+
+  while (current)
+  {
+    if (ind->num_nodes >= ind->alloc_nodes)
+    {
+      if (!ind->alloc_nodes)
+        temp = malloc(64 * sizeof(mxml_node_t *));
+      else
+        temp = realloc(ind->nodes, (ind->alloc_nodes + 64) * sizeof(mxml_node_t *));
+
+      if (!temp)
+      {
+       /*
+        * Unable to allocate memory for the index, so abort...
+	*/
+
+        mxml_error("Unable to allocate %d bytes for index: %s",
+	           (ind->alloc_nodes + 64) * sizeof(mxml_node_t *),
+		   strerror(errno));
+
+        mxmlIndexDelete(ind);
+	return (NULL);
+      }
+
+      ind->nodes       = temp;
+      ind->alloc_nodes += 64;
+    }
+
+    ind->nodes[ind->num_nodes ++] = current;
+
+    current = mxmlFindElement(current, node, element, attr, NULL, MXML_DESCEND);
+  }
+
+ /*
+  * Sort nodes based upon the search criteria...
+  */
+
+#ifdef DEBUG
+  {
+    int i;				/* Looping var */
+
+
+    printf("%d node(s) in index.\n\n", ind->num_nodes);
+
+    if (attr)
+    {
+      printf("Node      Address   Element         %s\n", attr);
+      puts("--------  --------  --------------  ------------------------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %-14.14s  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name,
+	       mxmlElementGetAttr(ind->nodes[i], attr));
+    }
+    else
+    {
+      puts("Node      Address   Element");
+      puts("--------  --------  --------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name);
+    }
+
+    putchar('\n');
+  }
+#endif /* DEBUG */
+
+  if (ind->num_nodes > 1)
+    index_sort(ind, 0, ind->num_nodes - 1);
+
+#ifdef DEBUG
+  {
+    int i;				/* Looping var */
+
+
+    puts("After sorting:\n");
+
+    if (attr)
+    {
+      printf("Node      Address   Element         %s\n", attr);
+      puts("--------  --------  --------------  ------------------------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %-14.14s  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name,
+	       mxmlElementGetAttr(ind->nodes[i], attr));
+    }
+    else
+    {
+      puts("Node      Address   Element");
+      puts("--------  --------  --------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name);
+    }
+
+    putchar('\n');
+  }
+#endif /* DEBUG */
+
+ /*
+  * Return the new index...
+  */
+
+  return (ind);
+}
+
+
+/*
+ * 'mxmlIndexReset()' - Reset the enumeration/find pointer in the index and
+ *                      return the first node in the index.
+ *
+ * This function should be called prior to using mxmlIndexEnum() or
+ * mxmlIndexFind() for the first time.
+ */
+
+mxml_node_t *				/* O - First node or NULL if there is none */
+mxmlIndexReset(mxml_index_t *ind)	/* I - Index to reset */
+{
+#ifdef DEBUG
+  printf("mxmlIndexReset(ind=%p)\n", ind);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!ind)
+    return (NULL);
+
+ /*
+  * Set the index to the first element...
+  */
+
+  ind->cur_node = 0;
+
+ /*
+  * Return the first node...
+  */
+
+  if (ind->num_nodes)
+    return (ind->nodes[0]);
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'index_compare()' - Compare two nodes.
+ */
+
+static int				/* O - Result of comparison */
+index_compare(mxml_index_t *ind,	/* I - Index */
+              mxml_node_t  *first,	/* I - First node */
+              mxml_node_t  *second)	/* I - Second node */
+{
+  int	diff;				/* Difference */
+
+
+ /*
+  * Check the element name...
+  */
+
+  if ((diff = strcmp(first->value.element.name,
+                     second->value.element.name)) != 0)
+    return (diff);
+
+ /*
+  * Check the attribute value...
+  */
+
+  if (ind->attr)
+  {
+    if ((diff = strcmp(mxmlElementGetAttr(first, ind->attr),
+                       mxmlElementGetAttr(second, ind->attr))) != 0)
+      return (diff);
+  }
+
+ /*
+  * No difference, return 0...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'index_find()' - Compare a node with index values.
+ */
+
+static int				/* O - Result of comparison */
+index_find(mxml_index_t *ind,		/* I - Index */
+           const char   *element,	/* I - Element name or NULL */
+	   const char   *value,		/* I - Attribute value or NULL */
+           mxml_node_t  *node)		/* I - Node */
+{
+  int	diff;				/* Difference */
+
+
+ /*
+  * Check the element name...
+  */
+
+  if (element)
+  {
+    if ((diff = strcmp(element, node->value.element.name)) != 0)
+      return (diff);
+  }
+
+ /*
+  * Check the attribute value...
+  */
+
+  if (value)
+  {
+    if ((diff = strcmp(value, mxmlElementGetAttr(node, ind->attr))) != 0)
+      return (diff);
+  }
+
+ /*
+  * No difference, return 0...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'index_sort()' - Sort the nodes in the index...
+ *
+ * This function implements the classic quicksort algorithm...
+ */
+
+static void
+index_sort(mxml_index_t *ind,		/* I - Index to sort */
+           int          left,		/* I - Left node in partition */
+	   int          right)		/* I - Right node in partition */
+{
+  mxml_node_t	*pivot,			/* Pivot node */
+		*temp;			/* Swap node */
+  int		templ,			/* Temporary left node */
+		tempr;			/* Temporary right node */
+
+
+ /*
+  * Loop until we have sorted all the way to the right...
+  */
+
+  do
+  {
+   /*
+    * Sort the pivot in the current partition...
+    */
+
+    pivot = ind->nodes[left];
+
+    for (templ = left, tempr = right; templ < tempr;)
+    {
+     /*
+      * Move left while left node <= pivot node...
+      */
+
+      while ((templ < right) &&
+             index_compare(ind, ind->nodes[templ], pivot) <= 0)
+	templ ++;
+
+     /*
+      * Move right while right node > pivot node...
+      */
+
+      while ((tempr > left) &&
+             index_compare(ind, ind->nodes[tempr], pivot) > 0)
+	tempr --;
+
+     /*
+      * Swap nodes if needed...
+      */
+
+      if (templ < tempr)
+      {
+	temp              = ind->nodes[templ];
+	ind->nodes[templ] = ind->nodes[tempr];
+	ind->nodes[tempr] = temp;
+      }
+    }
+
+   /*
+    * When we get here, the right (tempr) node is the new position for the
+    * pivot node...
+    */
+
+    if (index_compare(ind, pivot, ind->nodes[tempr]) > 0)
+    {
+      ind->nodes[left]  = ind->nodes[tempr];
+      ind->nodes[tempr] = pivot;
+    }
+
+   /*
+    * Recursively sort the left partition as needed...
+    */
+
+    if (left < (tempr - 1))
+      index_sort(ind, left, tempr - 1);
+  }
+  while (right > (left = tempr + 1));
+}
+
+
+/*
+ * End of "$Id: mxml-index.c 184 2005-01-29 07:21:44Z mike $".
+ */
diff -Naur mxml-2.6/mxml-node.c mxml-2.6-haiku/mxml-node.c
--- mxml-2.6/mxml-node.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-node.c	2008-10-26 18:28:05.000000000 +0000
@@ -0,0 +1,780 @@
+/*
+ * "$Id: mxml-node.c 363 2008-10-26 18:28:05Z mike $"
+ *
+ * Node support code for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2007 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxmlAdd()        - Add a node to a tree.
+ *   mxmlDelete()     - Delete a node and all of its children.
+ *   mxmlNewCDATA()   - Create a new CDATA node.
+ *   mxmlNewCustom()  - Create a new custom data node.
+ *   mxmlNewElement() - Create a new element node.
+ *   mxmlNewInteger() - Create a new integer node.
+ *   mxmlNewOpaque()  - Create a new opaque string.
+ *   mxmlNewReal()    - Create a new real number node.
+ *   mxmlNewText()    - Create a new text fragment node.
+ *   mxmlNewTextf()   - Create a new formatted text fragment node.
+ *   mxmlNewXML()     - Create a new XML document tree.
+ *   mxmlRelease()    - Release a node.
+ *   mxmlRemove()     - Remove a node from its parent.
+ *   mxmlRetain()     - Retain a node.
+ *   mxml_new()       - Create a new node.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+
+
+/*
+ * Local functions...
+ */
+
+static mxml_node_t	*mxml_new(mxml_node_t *parent, mxml_type_t type);
+
+
+/*
+ * 'mxmlAdd()' - Add a node to a tree.
+ *
+ * Adds the specified node to the parent. If the child argument is not
+ * NULL, puts the new node before or after the specified child depending
+ * on the value of the where argument. If the child argument is NULL,
+ * puts the new node at the beginning of the child list (MXML_ADD_BEFORE)
+ * or at the end of the child list (MXML_ADD_AFTER). The constant
+ * MXML_ADD_TO_PARENT can be used to specify a NULL child pointer.
+ */
+
+void
+mxmlAdd(mxml_node_t *parent,		/* I - Parent node */
+        int         where,		/* I - Where to add, MXML_ADD_BEFORE or MXML_ADD_AFTER */
+        mxml_node_t *child,		/* I - Child node for where or MXML_ADD_TO_PARENT */
+	mxml_node_t *node)		/* I - Node to add */
+{
+#ifdef DEBUG
+  fprintf(stderr, "mxmlAdd(parent=%p, where=%d, child=%p, node=%p)\n", parent,
+          where, child, node);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!parent || !node)
+    return;
+
+#if DEBUG > 1
+  fprintf(stderr, "    BEFORE: node->parent=%p\n", node->parent);
+  if (parent)
+  {
+    fprintf(stderr, "    BEFORE: parent->child=%p\n", parent->child);
+    fprintf(stderr, "    BEFORE: parent->last_child=%p\n", parent->last_child);
+    fprintf(stderr, "    BEFORE: parent->prev=%p\n", parent->prev);
+    fprintf(stderr, "    BEFORE: parent->next=%p\n", parent->next);
+  }
+#endif /* DEBUG > 1 */
+
+ /*
+  * Remove the node from any existing parent...
+  */
+
+  if (node->parent)
+    mxmlRemove(node);
+
+ /*
+  * Reset pointers...
+  */
+
+  node->parent = parent;
+
+  switch (where)
+  {
+    case MXML_ADD_BEFORE :
+        if (!child || child == parent->child || child->parent != parent)
+	{
+	 /*
+	  * Insert as first node under parent...
+	  */
+
+	  node->next = parent->child;
+
+	  if (parent->child)
+	    parent->child->prev = node;
+	  else
+	    parent->last_child = node;
+
+	  parent->child = node;
+	}
+	else
+	{
+	 /*
+	  * Insert node before this child...
+	  */
+
+	  node->next = child;
+	  node->prev = child->prev;
+
+	  if (child->prev)
+	    child->prev->next = node;
+	  else
+	    parent->child = node;
+
+	  child->prev = node;
+	}
+        break;
+
+    case MXML_ADD_AFTER :
+        if (!child || child == parent->last_child || child->parent != parent)
+	{
+	 /*
+	  * Insert as last node under parent...
+	  */
+
+	  node->parent = parent;
+	  node->prev   = parent->last_child;
+
+	  if (parent->last_child)
+	    parent->last_child->next = node;
+	  else
+	    parent->child = node;
+
+	  parent->last_child = node;
+        }
+	else
+	{
+	 /*
+	  * Insert node after this child...
+	  */
+
+	  node->prev = child;
+	  node->next = child->next;
+
+	  if (child->next)
+	    child->next->prev = node;
+	  else
+	    parent->last_child = node;
+
+	  child->next = node;
+	}
+        break;
+  }
+
+#if DEBUG > 1
+  fprintf(stderr, "    AFTER: node->parent=%p\n", node->parent);
+  if (parent)
+  {
+    fprintf(stderr, "    AFTER: parent->child=%p\n", parent->child);
+    fprintf(stderr, "    AFTER: parent->last_child=%p\n", parent->last_child);
+    fprintf(stderr, "    AFTER: parent->prev=%p\n", parent->prev);
+    fprintf(stderr, "    AFTER: parent->next=%p\n", parent->next);
+  }
+#endif /* DEBUG > 1 */
+}
+
+
+/*
+ * 'mxmlDelete()' - Delete a node and all of its children.
+ *
+ * If the specified node has a parent, this function first removes the
+ * node from its parent using the mxmlRemove() function.
+ */
+
+void
+mxmlDelete(mxml_node_t *node)		/* I - Node to delete */
+{
+  int	i;				/* Looping var */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlDelete(node=%p)\n", node);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return;
+
+ /*
+  * Remove the node from its parent, if any...
+  */
+
+  mxmlRemove(node);
+
+ /*
+  * Delete children...
+  */
+
+  while (node->child)
+    mxmlDelete(node->child);
+
+ /*
+  * Now delete any node data...
+  */
+
+  switch (node->type)
+  {
+    case MXML_ELEMENT :
+        if (node->value.element.name)
+	  free(node->value.element.name);
+
+	if (node->value.element.num_attrs)
+	{
+	  for (i = 0; i < node->value.element.num_attrs; i ++)
+	  {
+	    if (node->value.element.attrs[i].name)
+	      free(node->value.element.attrs[i].name);
+	    if (node->value.element.attrs[i].value)
+	      free(node->value.element.attrs[i].value);
+	  }
+
+          free(node->value.element.attrs);
+	}
+        break;
+    case MXML_INTEGER :
+       /* Nothing to do */
+        break;
+    case MXML_OPAQUE :
+        if (node->value.opaque)
+	  free(node->value.opaque);
+        break;
+    case MXML_REAL :
+       /* Nothing to do */
+        break;
+    case MXML_TEXT :
+        if (node->value.text.string)
+	  free(node->value.text.string);
+        break;
+    case MXML_CUSTOM :
+        if (node->value.custom.data &&
+	    node->value.custom.destroy)
+	  (*(node->value.custom.destroy))(node->value.custom.data);
+	break;
+    default :
+        break;
+  }
+
+ /*
+  * Free this node...
+  */
+
+  free(node);
+}
+
+
+/*
+ * 'mxmlNewCDATA()' - Create a new CDATA node.
+ *
+ * The new CDATA node is added to the end of the specified parent's child
+ * list. The constant MXML_NO_PARENT can be used to specify that the new
+ * CDATA node has no parent. The data string must be nul-terminated and
+ * is copied into the new node. CDATA nodes use the MXML_ELEMENT type.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewCDATA(mxml_node_t *parent,	/* I - Parent node or MXML_NO_PARENT */
+	     const char  *data)		/* I - Data string */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewCDATA(parent=%p, data=\"%s\")\n",
+          parent, data ? data : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!data)
+    return (NULL);
+
+ /*
+  * Create the node and set the name value...
+  */
+
+  if ((node = mxml_new(parent, MXML_ELEMENT)) != NULL)
+    node->value.element.name = _mxml_strdupf("![CDATA[%s]]", data);
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewCustom()' - Create a new custom data node.
+ *
+ * The new custom node is added to the end of the specified parent's child
+ * list. The constant MXML_NO_PARENT can be used to specify that the new
+ * element node has no parent. NULL can be passed when the data in the
+ * node is not dynamically allocated or is separately managed.
+ *
+ * @since Mini-XML 2.1@
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewCustom(
+    mxml_node_t              *parent,	/* I - Parent node or MXML_NO_PARENT */
+    void                     *data,	/* I - Pointer to data */
+    mxml_custom_destroy_cb_t destroy)	/* I - Function to destroy data */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewCustom(parent=%p, data=%p, destroy=%p)\n", parent,
+          data, destroy);
+#endif /* DEBUG */
+
+ /*
+  * Create the node and set the value...
+  */
+
+  if ((node = mxml_new(parent, MXML_CUSTOM)) != NULL)
+  {
+    node->value.custom.data    = data;
+    node->value.custom.destroy = destroy;
+  }
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewElement()' - Create a new element node.
+ *
+ * The new element node is added to the end of the specified parent's child
+ * list. The constant MXML_NO_PARENT can be used to specify that the new
+ * element node has no parent.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewElement(mxml_node_t *parent,	/* I - Parent node or MXML_NO_PARENT */
+               const char  *name)	/* I - Name of element */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewElement(parent=%p, name=\"%s\")\n", parent,
+          name ? name : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!name)
+    return (NULL);
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_ELEMENT)) != NULL)
+    node->value.element.name = strdup(name);
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewInteger()' - Create a new integer node.
+ *
+ * The new integer node is added to the end of the specified parent's child
+ * list. The constant MXML_NO_PARENT can be used to specify that the new
+ * integer node has no parent.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewInteger(mxml_node_t *parent,	/* I - Parent node or MXML_NO_PARENT */
+               int         integer)	/* I - Integer value */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewInteger(parent=%p, integer=%d)\n", parent, integer);
+#endif /* DEBUG */
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_INTEGER)) != NULL)
+    node->value.integer = integer;
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewOpaque()' - Create a new opaque string.
+ *
+ * The new opaque node is added to the end of the specified parent's child
+ * list. The constant MXML_NO_PARENT can be used to specify that the new
+ * opaque node has no parent. The opaque string must be nul-terminated and
+ * is copied into the new node.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewOpaque(mxml_node_t *parent,	/* I - Parent node or MXML_NO_PARENT */
+              const char  *opaque)	/* I - Opaque string */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewOpaque(parent=%p, opaque=\"%s\")\n", parent,
+          opaque ? opaque : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!opaque)
+    return (NULL);
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_OPAQUE)) != NULL)
+    node->value.opaque = strdup(opaque);
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewReal()' - Create a new real number node.
+ *
+ * The new real number node is added to the end of the specified parent's
+ * child list. The constant MXML_NO_PARENT can be used to specify that
+ * the new real number node has no parent.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewReal(mxml_node_t *parent,	/* I - Parent node or MXML_NO_PARENT */
+            double      real)		/* I - Real number value */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewReal(parent=%p, real=%g)\n", parent, real);
+#endif /* DEBUG */
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_REAL)) != NULL)
+    node->value.real = real;
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewText()' - Create a new text fragment node.
+ *
+ * The new text node is added to the end of the specified parent's child
+ * list. The constant MXML_NO_PARENT can be used to specify that the new
+ * text node has no parent. The whitespace parameter is used to specify
+ * whether leading whitespace is present before the node. The text
+ * string must be nul-terminated and is copied into the new node.  
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewText(mxml_node_t *parent,	/* I - Parent node or MXML_NO_PARENT */
+            int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+	    const char  *string)	/* I - String */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewText(parent=%p, whitespace=%d, string=\"%s\")\n",
+          parent, whitespace, string ? string : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!string)
+    return (NULL);
+
+ /*
+  * Create the node and set the text value...
+  */
+
+  if ((node = mxml_new(parent, MXML_TEXT)) != NULL)
+  {
+    node->value.text.whitespace = whitespace;
+    node->value.text.string     = strdup(string);
+  }
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewTextf()' - Create a new formatted text fragment node.
+ *
+ * The new text node is added to the end of the specified parent's child
+ * list. The constant MXML_NO_PARENT can be used to specify that the new
+ * text node has no parent. The whitespace parameter is used to specify
+ * whether leading whitespace is present before the node. The format
+ * string must be nul-terminated and is formatted into the new node.  
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewTextf(mxml_node_t *parent,	/* I - Parent node or MXML_NO_PARENT */
+             int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+	     const char  *format,	/* I - Printf-style frmat string */
+	     ...)			/* I - Additional args as needed */
+{
+  mxml_node_t	*node;			/* New node */
+  va_list	ap;			/* Pointer to arguments */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewTextf(parent=%p, whitespace=%d, format=\"%s\", ...)\n",
+          parent, whitespace, format ? format : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!format)
+    return (NULL);
+
+ /*
+  * Create the node and set the text value...
+  */
+
+  if ((node = mxml_new(parent, MXML_TEXT)) != NULL)
+  {
+    va_start(ap, format);
+
+    node->value.text.whitespace = whitespace;
+    node->value.text.string     = _mxml_vstrdupf(format, ap);
+
+    va_end(ap);
+  }
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlRemove()' - Remove a node from its parent.
+ *
+ * Does not free memory used by the node - use mxmlDelete() for that.
+ * This function does nothing if the node has no parent.
+ */
+
+void
+mxmlRemove(mxml_node_t *node)		/* I - Node to remove */
+{
+#ifdef DEBUG
+  fprintf(stderr, "mxmlRemove(node=%p)\n", node);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || !node->parent)
+    return;
+
+ /*
+  * Remove from parent...
+  */
+
+#if DEBUG > 1
+  fprintf(stderr, "    BEFORE: node->parent=%p\n", node->parent);
+  if (node->parent)
+  {
+    fprintf(stderr, "    BEFORE: node->parent->child=%p\n", node->parent->child);
+    fprintf(stderr, "    BEFORE: node->parent->last_child=%p\n", node->parent->last_child);
+  }
+  fprintf(stderr, "    BEFORE: node->child=%p\n", node->child);
+  fprintf(stderr, "    BEFORE: node->last_child=%p\n", node->last_child);
+  fprintf(stderr, "    BEFORE: node->prev=%p\n", node->prev);
+  fprintf(stderr, "    BEFORE: node->next=%p\n", node->next);
+#endif /* DEBUG > 1 */
+
+  if (node->prev)
+    node->prev->next = node->next;
+  else
+    node->parent->child = node->next;
+
+  if (node->next)
+    node->next->prev = node->prev;
+  else
+    node->parent->last_child = node->prev;
+
+  node->parent = NULL;
+  node->prev   = NULL;
+  node->next   = NULL;
+
+#if DEBUG > 1
+  fprintf(stderr, "    AFTER: node->parent=%p\n", node->parent);
+  if (node->parent)
+  {
+    fprintf(stderr, "    AFTER: node->parent->child=%p\n", node->parent->child);
+    fprintf(stderr, "    AFTER: node->parent->last_child=%p\n", node->parent->last_child);
+  }
+  fprintf(stderr, "    AFTER: node->child=%p\n", node->child);
+  fprintf(stderr, "    AFTER: node->last_child=%p\n", node->last_child);
+  fprintf(stderr, "    AFTER: node->prev=%p\n", node->prev);
+  fprintf(stderr, "    AFTER: node->next=%p\n", node->next);
+#endif /* DEBUG > 1 */
+}
+
+
+/*
+ * 'mxmlNewXML()' - Create a new XML document tree.
+ *
+ * The "version" argument specifies the version number to put in the
+ * ?xml element node. If NULL, version 1.0 is assumed.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - New ?xml node */
+mxmlNewXML(const char *version)		/* I - Version number to use */
+{
+  char	element[1024];			/* Element text */
+
+
+  snprintf(element, sizeof(element), "?xml version=\"%s\" encoding=\"utf-8\"?",
+           version ? version : "1.0");
+
+  return (mxmlNewElement(NULL, element));
+}
+
+
+/*
+ * 'mxmlRelease()' - Release a node.
+ *
+ * When the reference count reaches zero, the node (and any children)
+ * is deleted via mxmlDelete().
+ *
+ * @since Mini-XML 2.3@
+ */
+
+int					/* O - New reference count */
+mxmlRelease(mxml_node_t *node)		/* I - Node */
+{
+  if (node)
+  {
+    if ((-- node->ref_count) <= 0)
+    {
+      mxmlDelete(node);
+      return (0);
+    }
+    else
+      return (node->ref_count);
+  }
+  else
+    return (-1);
+}
+
+
+/*
+ * 'mxmlRetain()' - Retain a node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+int					/* O - New reference count */
+mxmlRetain(mxml_node_t *node)		/* I - Node */
+{
+  if (node)
+    return (++ node->ref_count);
+  else
+    return (-1);
+}
+
+
+/*
+ * 'mxml_new()' - Create a new node.
+ */
+
+static mxml_node_t *			/* O - New node */
+mxml_new(mxml_node_t *parent,		/* I - Parent node */
+         mxml_type_t type)		/* I - Node type */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#if DEBUG > 1
+  fprintf(stderr, "mxml_new(parent=%p, type=%d)\n", parent, type);
+#endif /* DEBUG > 1 */
+
+ /*
+  * Allocate memory for the node...
+  */
+
+  if ((node = calloc(1, sizeof(mxml_node_t))) == NULL)
+  {
+#if DEBUG > 1
+    fputs("    returning NULL\n", stderr);
+#endif /* DEBUG > 1 */
+
+    return (NULL);
+  }
+
+#if DEBUG > 1
+  fprintf(stderr, "    returning %p\n", node);
+#endif /* DEBUG > 1 */
+
+ /*
+  * Set the node type...
+  */
+
+  node->type      = type;
+  node->ref_count = 1;
+
+ /*
+  * Add to the parent if present...
+  */
+
+  if (parent)
+    mxmlAdd(parent, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, node);
+
+ /*
+  * Return the new node...
+  */
+
+  return (node);
+}
+
+
+/*
+ * End of "$Id: mxml-node.c 363 2008-10-26 18:28:05Z mike $".
+ */
diff -Naur mxml-2.6/mxml-private.c mxml-2.6-haiku/mxml-private.c
--- mxml-2.6/mxml-private.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-private.c	2007-11-22 18:01:52.000000000 +0000
@@ -0,0 +1,285 @@
+/*
+ * "$Id: mxml-private.c 315 2007-11-22 18:01:52Z mike $"
+ *
+ * Private functions for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2007 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxml_error()      - Display an error message.
+ *   mxml_integer_cb() - Default callback for integer values.
+ *   mxml_opaque_cb()  - Default callback for opaque values.
+ *   mxml_real_cb()    - Default callback for real number values.
+ *   _mxml_global()    - Get global data.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "mxml-private.h"
+
+
+/*
+ * 'mxml_error()' - Display an error message.
+ */
+
+void
+mxml_error(const char *format,		/* I - Printf-style format string */
+           ...)				/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Pointer to arguments */
+  char		s[1024];		/* Message string */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!format)
+    return;
+
+ /*
+  * Format the error message string...
+  */
+
+  va_start(ap, format);
+
+  vsnprintf(s, sizeof(s), format, ap);
+
+  va_end(ap);
+
+ /*
+  * And then display the error message...
+  */
+
+  if (global->error_cb)
+    (*global->error_cb)(s);
+  else
+    fprintf(stderr, "mxml: %s\n", s);
+}
+
+
+/*
+ * 'mxml_ignore_cb()' - Default callback for ignored values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_ignore_cb(mxml_node_t *node)	/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_IGNORE);
+}
+
+
+/*
+ * 'mxml_integer_cb()' - Default callback for integer values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_integer_cb(mxml_node_t *node)	/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_INTEGER);
+}
+
+
+/*
+ * 'mxml_opaque_cb()' - Default callback for opaque values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_opaque_cb(mxml_node_t *node)	/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_OPAQUE);
+}
+
+
+/*
+ * 'mxml_real_cb()' - Default callback for real number values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_real_cb(mxml_node_t *node)		/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_REAL);
+}
+
+
+#ifdef HAVE_PTHREAD_H			/**** POSIX threading ****/
+#  include <pthread.h>
+
+static pthread_key_t	_mxml_key = -1;	/* Thread local storage key */
+static pthread_once_t	_mxml_key_once = PTHREAD_ONCE_INIT;
+					/* One-time initialization object */
+static void		_mxml_init(void);
+static void		_mxml_destructor(void *g);
+
+
+/*
+ * '_mxml_global()' - Get global data.
+ */
+
+_mxml_global_t *			/* O - Global data */
+_mxml_global(void)
+{
+  _mxml_global_t	*global;	/* Global data */
+
+
+  pthread_once(&_mxml_key_once, _mxml_init);
+
+  if ((global = (_mxml_global_t *)pthread_getspecific(_mxml_key)) == NULL)
+  {
+    global = (_mxml_global_t *)calloc(1, sizeof(_mxml_global_t));
+    pthread_setspecific(_mxml_key, global);
+
+    global->num_entity_cbs = 1;
+    global->entity_cbs[0]  = _mxml_entity_cb;
+    global->wrap           = 72;
+  }
+
+  return (global);
+}
+
+
+/*
+ * '_mxml_init()' - Initialize global data...
+ */
+
+static void
+_mxml_init(void)
+{
+  pthread_key_create(&_mxml_key, _mxml_destructor);
+}
+
+
+/*
+ * '_mxml_destructor()' - Free memory used for globals...
+ */
+
+static void
+_mxml_destructor(void *g)		/* I - Global data */
+{
+  free(g);
+}
+
+
+#elif defined(WIN32)			/**** WIN32 threading ****/
+#  include <windows.h>
+
+static DWORD _mxml_tls_index;		/* Index for global storage */
+
+
+/*
+ * 'DllMain()' - Main entry for library.
+ */
+ 
+BOOL WINAPI				/* O - Success/failure */
+DllMain(HINSTANCE hinst,		/* I - DLL module handle */
+        DWORD     reason,		/* I - Reason */
+        LPVOID    reserved)		/* I - Unused */
+{
+  _mxml_global_t	*global;	/* Global data */
+
+
+  (void)hinst;
+  (void)reserved;
+
+  switch (reason) 
+  { 
+    case DLL_PROCESS_ATTACH :		/* Called on library initialization */
+        if ((_mxml_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) 
+          return (FALSE); 
+        break; 
+
+    case DLL_THREAD_DETACH :		/* Called when a thread terminates */
+        if ((global = (_mxml_global_t *)TlsGetValue(_mxml_tls_index)) != NULL)
+          free(global);
+        break; 
+
+    case DLL_PROCESS_DETACH :		/* Called when library is unloaded */
+        if ((global = (_mxml_global_t *)TlsGetValue(_mxml_tls_index)) != NULL)
+          free(global);
+
+        TlsFree(_mxml_tls_index); 
+        break; 
+
+    default: 
+        break; 
+  } 
+
+  return (TRUE);
+}
+
+
+/*
+ * '_mxml_global()' - Get global data.
+ */
+
+_mxml_global_t *			/* O - Global data */
+_mxml_global(void)
+{
+  _mxml_global_t	*global;	/* Global data */
+
+
+  if ((global = (_mxml_global_t *)TlsGetValue(_mxml_tls_index)) == NULL)
+  {
+    global = (_mxml_global_t *)calloc(1, sizeof(_mxml_global_t));
+
+    global->num_entity_cbs = 1;
+    global->entity_cbs[0]  = _mxml_entity_cb;
+    global->wrap           = 72;
+
+    TlsSetValue(_mxml_tls_index, (LPVOID)global); 
+  }
+
+  return (global);
+}
+
+
+#else					/**** No threading ****/
+/*
+ * '_mxml_global()' - Get global data.
+ */
+
+_mxml_global_t *			/* O - Global data */
+_mxml_global(void)
+{
+  static _mxml_global_t	global =	/* Global data */
+  {
+    NULL,				/* error_cb */
+    1,					/* num_entity_cbs */
+    { _mxml_entity_cb },		/* entity_cbs */
+    72,					/* wrap */
+    NULL,				/* custom_load_cb */
+    NULL				/* custom_save_cb */
+  };
+
+
+  return (&global);
+}
+#endif /* HAVE_PTHREAD_H */
+
+
+/*
+ * End of "$Id: mxml-private.c 315 2007-11-22 18:01:52Z mike $".
+ */
diff -Naur mxml-2.6/mxml-private.h mxml-2.6-haiku/mxml-private.h
--- mxml-2.6/mxml-private.h	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-private.h	2007-09-21 04:46:02.000000000 +0000
@@ -0,0 +1,52 @@
+/*
+ * "$Id: mxml-private.h 309 2007-09-21 04:46:02Z mike $"
+ *
+ * Private definitions for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2007 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+
+
+/*
+ * Global, per-thread data...
+ */
+
+typedef struct _mxml_global_s
+{
+  void	(*error_cb)(const char *);
+  int	num_entity_cbs;
+  int	(*entity_cbs[100])(const char *name);
+  int	wrap;
+  mxml_custom_load_cb_t	custom_load_cb;
+  mxml_custom_save_cb_t	custom_save_cb;
+} _mxml_global_t;
+
+
+/*
+ * Functions...
+ */
+
+extern _mxml_global_t	*_mxml_global(void);
+extern int		_mxml_entity_cb(const char *name);
+
+
+/*
+ * End of "$Id: mxml-private.h 309 2007-09-21 04:46:02Z mike $".
+ */
diff -Naur mxml-2.6/mxml-search.c mxml-2.6-haiku/mxml-search.c
--- mxml-2.6/mxml-search.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-search.c	2007-09-09 07:16:52.000000000 +0000
@@ -0,0 +1,201 @@
+/*
+ * "$Id: mxml-search.c 297 2007-09-09 07:16:52Z mike $"
+ *
+ * Search/navigation functions for Mini-XML, a small XML-like file
+ * parsing library.
+ *
+ * Copyright 2003-2007 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxmlFindElement() - Find the named element.
+ *   mxmlWalkNext()    - Walk to the next logical node in the tree.
+ *   mxmlWalkPrev()    - Walk to the previous logical node in the tree.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+
+
+/*
+ * 'mxmlFindElement()' - Find the named element.
+ *
+ * The search is constrained by the name, attribute name, and value; any
+ * NULL names or values are treated as wildcards, so different kinds of
+ * searches can be implemented by looking for all elements of a given name
+ * or all elements with a specific attribute. The descend argument determines
+ * whether the search descends into child nodes; normally you will use
+ * MXML_DESCEND_FIRST for the initial search and MXML_NO_DESCEND to find
+ * additional direct descendents of the node. The top node argument
+ * constrains the search to a particular node's children.
+ */
+
+mxml_node_t *				/* O - Element node or NULL */
+mxmlFindElement(mxml_node_t *node,	/* I - Current node */
+                mxml_node_t *top,	/* I - Top node */
+                const char  *name,	/* I - Element name or NULL for any */
+		const char  *attr,	/* I - Attribute name, or NULL for none */
+		const char  *value,	/* I - Attribute value, or NULL for any */
+		int         descend)	/* I - Descend into tree - MXML_DESCEND, MXML_NO_DESCEND, or MXML_DESCEND_FIRST */
+{
+  const char	*temp;			/* Current attribute value */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || !top || (!attr && value))
+    return (NULL);
+
+ /*
+  * Start with the next node...
+  */
+
+  node = mxmlWalkNext(node, top, descend);
+
+ /*
+  * Loop until we find a matching element...
+  */
+
+  while (node != NULL)
+  {
+   /*
+    * See if this node matches...
+    */
+
+    if (node->type == MXML_ELEMENT &&
+        node->value.element.name &&
+	(!name || !strcmp(node->value.element.name, name)))
+    {
+     /*
+      * See if we need to check for an attribute...
+      */
+
+      if (!attr)
+        return (node);			/* No attribute search, return it... */
+
+     /*
+      * Check for the attribute...
+      */
+
+      if ((temp = mxmlElementGetAttr(node, attr)) != NULL)
+      {
+       /*
+        * OK, we have the attribute, does it match?
+	*/
+
+	if (!value || !strcmp(value, temp))
+	  return (node);		/* Yes, return it... */
+      }
+    }
+
+   /*
+    * No match, move on to the next node...
+    */
+
+    if (descend == MXML_DESCEND)
+      node = mxmlWalkNext(node, top, MXML_DESCEND);
+    else
+      node = node->next;
+  }
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxmlWalkNext()' - Walk to the next logical node in the tree.
+ *
+ * The descend argument controls whether the first child is considered
+ * to be the next node. The top node argument constrains the walk to
+ * the node's children.
+ */
+
+mxml_node_t *				/* O - Next node or NULL */
+mxmlWalkNext(mxml_node_t *node,		/* I - Current node */
+             mxml_node_t *top,		/* I - Top node */
+             int         descend)	/* I - Descend into tree - MXML_DESCEND, MXML_NO_DESCEND, or MXML_DESCEND_FIRST */
+{
+  if (!node)
+    return (NULL);
+  else if (node->child && descend)
+    return (node->child);
+  else if (node == top)
+    return (NULL);
+  else if (node->next)
+    return (node->next);
+  else if (node->parent && node->parent != top)
+  {
+    node = node->parent;
+
+    while (!node->next)
+      if (node->parent == top || !node->parent)
+        return (NULL);
+      else
+        node = node->parent;
+
+    return (node->next);
+  }
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'mxmlWalkPrev()' - Walk to the previous logical node in the tree.
+ *
+ * The descend argument controls whether the previous node's last child
+ * is considered to be the previous node. The top node argument constrains
+ * the walk to the node's children.
+ */
+
+mxml_node_t *				/* O - Previous node or NULL */
+mxmlWalkPrev(mxml_node_t *node,		/* I - Current node */
+             mxml_node_t *top,		/* I - Top node */
+             int         descend)	/* I - Descend into tree - MXML_DESCEND, MXML_NO_DESCEND, or MXML_DESCEND_FIRST */
+{
+  if (!node || node == top)
+    return (NULL);
+  else if (node->prev)
+  {
+    if (node->prev->last_child && descend)
+    {
+     /*
+      * Find the last child under the previous node...
+      */
+
+      node = node->prev->last_child;
+
+      while (node->last_child)
+        node = node->last_child;
+
+      return (node);
+    }
+    else
+      return (node->prev);
+  }
+  else if (node->parent != top)
+    return (node->parent);
+  else
+    return (NULL);
+}
+
+
+/*
+ * End of "$Id: mxml-search.c 297 2007-09-09 07:16:52Z mike $".
+ */
diff -Naur mxml-2.6/mxml-set.c mxml-2.6-haiku/mxml-set.c
--- mxml-2.6/mxml-set.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-set.c	2007-04-23 21:48:03.000000000 +0000
@@ -0,0 +1,294 @@
+/*
+ * "$Id: mxml-set.c 270 2007-04-23 21:48:03Z mike $"
+ *
+ * Node set functions for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2007 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   mxmlSetCustom()  - Set the data and destructor of a custom data node.
+ *   mxmlSetCDATA()   - Set the element name of a CDATA node.
+ *   mxmlSetElement() - Set the name of an element node.
+ *   mxmlSetInteger() - Set the value of an integer node.
+ *   mxmlSetOpaque()  - Set the value of an opaque node.
+ *   mxmlSetReal()    - Set the value of a real number node.
+ *   mxmlSetText()    - Set the value of a text node.
+ *   mxmlSetTextf()   - Set the value of a text node to a formatted string.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+
+
+/*
+ * 'mxmlSetCustom()' - Set the data and destructor of a custom data node.
+ *
+ * The node is not changed if it is not a custom node.
+ *
+ * @since Mini-XML 2.1@
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetCustom(
+    mxml_node_t              *node,	/* I - Node to set */
+    void                     *data,	/* I - New data pointer */
+    mxml_custom_destroy_cb_t destroy)	/* I - New destructor function */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_CUSTOM)
+    return (-1);
+
+ /*
+  * Free any old element value and set the new value...
+  */
+
+  if (node->value.custom.data && node->value.custom.destroy)
+    (*(node->value.custom.destroy))(node->value.custom.data);
+
+  node->value.custom.data    = data;
+  node->value.custom.destroy = destroy;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetCDATA()' - Set the element name of a CDATA node.
+ *
+ * The node is not changed if it is not a CDATA element node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetCDATA(mxml_node_t *node,		/* I - Node to set */
+             const char  *data)		/* I - New data string */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !data ||
+      strncmp(node->value.element.name, "![CDATA[", 8))
+    return (-1);
+
+ /*
+  * Free any old element value and set the new value...
+  */
+
+  if (node->value.element.name)
+    free(node->value.element.name);
+
+  node->value.element.name = _mxml_strdupf("![CDATA[%s]]", data);
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetElement()' - Set the name of an element node.
+ *
+ * The node is not changed if it is not an element node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetElement(mxml_node_t *node,	/* I - Node to set */
+               const char  *name)	/* I - New name string */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return (-1);
+
+ /*
+  * Free any old element value and set the new value...
+  */
+
+  if (node->value.element.name)
+    free(node->value.element.name);
+
+  node->value.element.name = strdup(name);
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetInteger()' - Set the value of an integer node.
+ *
+ * The node is not changed if it is not an integer node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetInteger(mxml_node_t *node,	/* I - Node to set */
+               int         integer)	/* I - Integer value */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_INTEGER)
+    return (-1);
+
+ /*
+  * Set the new value and return...
+  */
+
+  node->value.integer = integer;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetOpaque()' - Set the value of an opaque node.
+ *
+ * The node is not changed if it is not an opaque node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetOpaque(mxml_node_t *node,	/* I - Node to set */
+              const char  *opaque)	/* I - Opaque string */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_OPAQUE || !opaque)
+    return (-1);
+
+ /*
+  * Free any old opaque value and set the new value...
+  */
+
+  if (node->value.opaque)
+    free(node->value.opaque);
+
+  node->value.opaque = strdup(opaque);
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetReal()' - Set the value of a real number node.
+ *
+ * The node is not changed if it is not a real number node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetReal(mxml_node_t *node,		/* I - Node to set */
+            double      real)		/* I - Real number value */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_REAL)
+    return (-1);
+
+ /*
+  * Set the new value and return...
+  */
+
+  node->value.real = real;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetText()' - Set the value of a text node.
+ *
+ * The node is not changed if it is not a text node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetText(mxml_node_t *node,		/* I - Node to set */
+            int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+	    const char  *string)	/* I - String */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_TEXT || !string)
+    return (-1);
+
+ /*
+  * Free any old string value and set the new value...
+  */
+
+  if (node->value.text.string)
+    free(node->value.text.string);
+
+  node->value.text.whitespace = whitespace;
+  node->value.text.string     = strdup(string);
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetTextf()' - Set the value of a text node to a formatted string.
+ *
+ * The node is not changed if it is not a text node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetTextf(mxml_node_t *node,		/* I - Node to set */
+             int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+             const char  *format,	/* I - Printf-style format string */
+	     ...)			/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Pointer to arguments */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_TEXT || !format)
+    return (-1);
+
+ /*
+  * Free any old string value and set the new value...
+  */
+
+  if (node->value.text.string)
+    free(node->value.text.string);
+
+  va_start(ap, format);
+
+  node->value.text.whitespace = whitespace;
+  node->value.text.string     = _mxml_strdupf(format, ap);
+
+  va_end(ap);
+
+  return (0);
+}
+
+
+/*
+ * End of "$Id: mxml-set.c 270 2007-04-23 21:48:03Z mike $".
+ */
diff -Naur mxml-2.6/mxml-string.c mxml-2.6-haiku/mxml-string.c
--- mxml-2.6/mxml-string.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml-string.c	2009-04-18 17:05:52.000000000 +0000
@@ -0,0 +1,462 @@
+/*
+ * "$Id: mxml-string.c 387 2009-04-18 17:05:52Z mike $"
+ *
+ * String functions for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2009 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   _mxml_snprintf()  - Format a string.
+ *   _mxml_strdup()    - Duplicate a string.
+ *   _mxml_strdupf()   - Format and duplicate a string.
+ *   _mxml_vsnprintf() - Format a string into a fixed size buffer.
+ *   _mxml_vstrdupf()  - Format and duplicate a string.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+
+
+#ifndef HAVE_SNPRINTF
+/*
+ * '_mxml_snprintf()' - Format a string.
+ */
+
+int					/* O - Number of bytes formatted */
+_mxml_snprintf(char       *buffer,	/* I - Output buffer */
+               size_t     bufsize,	/* I - Size of output buffer */
+	       const char *format,	/* I - Printf-style format string */
+	       ...)			/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Argument list */
+  int		bytes;			/* Number of bytes formatted */
+
+
+  va_start(ap, format);
+  bytes = vsnprintf(buffer, bufsize, format, ap);
+  va_end(ap);
+
+  return (bytes);
+}
+#endif /* !HAVE_SNPRINTF */
+
+
+/*
+ * '_mxml_strdup()' - Duplicate a string.
+ */
+
+#ifndef HAVE_STRDUP
+char 	*				/* O - New string pointer */
+_mxml_strdup(const char *s)		/* I - String to duplicate */
+{
+  char	*t;				/* New string pointer */
+
+
+  if (s == NULL)
+    return (NULL);
+
+  if ((t = malloc(strlen(s) + 1)) == NULL)
+    return (NULL);
+
+  return (strcpy(t, s));
+}
+#endif /* !HAVE_STRDUP */
+
+
+/*
+ * '_mxml_strdupf()' - Format and duplicate a string.
+ */
+
+char *					/* O - New string pointer */
+_mxml_strdupf(const char *format,	/* I - Printf-style format string */
+              ...)			/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Pointer to additional arguments */
+  char		*s;			/* Pointer to formatted string */
+
+
+ /*
+  * Get a pointer to the additional arguments, format the string,
+  * and return it...
+  */
+
+  va_start(ap, format);
+  s = _mxml_vstrdupf(format, ap);
+  va_end(ap);
+
+  return (s);
+}
+
+
+#ifndef HAVE_VSNPRINTF
+/*
+ * '_mxml_vsnprintf()' - Format a string into a fixed size buffer.
+ */
+
+int					/* O - Number of bytes formatted */
+_mxml_vsnprintf(char       *buffer,	/* O - Output buffer */
+                size_t     bufsize,	/* O - Size of output buffer */
+		const char *format,	/* I - Printf-style format string */
+ 		va_list    ap)		/* I - Pointer to additional arguments */
+{
+  char		*bufptr,		/* Pointer to position in buffer */
+		*bufend,		/* Pointer to end of buffer */
+		sign,			/* Sign of format width */
+		size,			/* Size character (h, l, L) */
+		type;			/* Format type character */
+  int		width,			/* Width of field */
+		prec;			/* Number of characters of precision */
+  char		tformat[100],		/* Temporary format string for sprintf() */
+		*tptr,			/* Pointer into temporary format */
+		temp[1024];		/* Buffer for formatted numbers */
+  char		*s;			/* Pointer to string */
+  int		slen;			/* Length of string */
+  int		bytes;			/* Total number of bytes needed */
+
+
+ /*
+  * Loop through the format string, formatting as needed...
+  */
+
+  bufptr = buffer;
+  bufend = buffer + bufsize - 1;
+  bytes  = 0;
+
+  while (*format)
+  {
+    if (*format == '%')
+    {
+      tptr = tformat;
+      *tptr++ = *format++;
+
+      if (*format == '%')
+      {
+        if (bufptr && bufptr < bufend) *bufptr++ = *format;
+        bytes ++;
+        format ++;
+	continue;
+      }
+      else if (strchr(" -+#\'", *format))
+      {
+        *tptr++ = *format;
+        sign = *format++;
+      }
+      else
+        sign = 0;
+
+      if (*format == '*')
+      {
+       /*
+        * Get width from argument...
+	*/
+
+	format ++;
+	width = va_arg(ap, int);
+
+	snprintf(tptr, sizeof(tformat) - (tptr - tformat), "%d", width);
+	tptr += strlen(tptr);
+      }
+      else
+      {
+	width = 0;
+
+	while (isdigit(*format & 255))
+	{
+	  if (tptr < (tformat + sizeof(tformat) - 1))
+	    *tptr++ = *format;
+
+	  width = width * 10 + *format++ - '0';
+	}
+      }
+
+      if (*format == '.')
+      {
+	if (tptr < (tformat + sizeof(tformat) - 1))
+	  *tptr++ = *format;
+
+        format ++;
+
+        if (*format == '*')
+	{
+         /*
+	  * Get precision from argument...
+	  */
+
+	  format ++;
+	  prec = va_arg(ap, int);
+
+	  snprintf(tptr, sizeof(tformat) - (tptr - tformat), "%d", prec);
+	  tptr += strlen(tptr);
+	}
+	else
+	{
+	  prec = 0;
+
+	  while (isdigit(*format & 255))
+	  {
+	    if (tptr < (tformat + sizeof(tformat) - 1))
+	      *tptr++ = *format;
+
+	    prec = prec * 10 + *format++ - '0';
+	  }
+	}
+      }
+      else
+        prec = -1;
+
+      if (*format == 'l' && format[1] == 'l')
+      {
+        size = 'L';
+
+	if (tptr < (tformat + sizeof(tformat) - 2))
+	{
+	  *tptr++ = 'l';
+	  *tptr++ = 'l';
+	}
+
+	format += 2;
+      }
+      else if (*format == 'h' || *format == 'l' || *format == 'L')
+      {
+	if (tptr < (tformat + sizeof(tformat) - 1))
+	  *tptr++ = *format;
+
+        size = *format++;
+      }
+
+      if (!*format)
+        break;
+
+      if (tptr < (tformat + sizeof(tformat) - 1))
+        *tptr++ = *format;
+
+      type  = *format++;
+      *tptr = '\0';
+
+      switch (type)
+      {
+	case 'E' : /* Floating point formats */
+	case 'G' :
+	case 'e' :
+	case 'f' :
+	case 'g' :
+	    if ((width + 2) > sizeof(temp))
+	      break;
+
+	    sprintf(temp, tformat, va_arg(ap, double));
+
+            bytes += strlen(temp);
+
+            if (bufptr)
+	    {
+	      if ((bufptr + strlen(temp)) > bufend)
+	      {
+		strncpy(bufptr, temp, (size_t)(bufend - bufptr));
+		bufptr = bufend;
+	      }
+	      else
+	      {
+		strcpy(bufptr, temp);
+		bufptr += strlen(temp);
+	      }
+	    }
+	    break;
+
+        case 'B' : /* Integer formats */
+	case 'X' :
+	case 'b' :
+        case 'd' :
+	case 'i' :
+	case 'o' :
+	case 'u' :
+	case 'x' :
+	    if ((width + 2) > sizeof(temp))
+	      break;
+
+#ifdef HAVE_LONG_LONG
+	    if (size == 'L')
+	      sprintf(temp, tformat, va_arg(ap, long long));
+	    else
+#endif /* HAVE_LONG_LONG */
+	    sprintf(temp, tformat, va_arg(ap, int));
+
+            bytes += strlen(temp);
+
+	    if (bufptr)
+	    {
+	      if ((bufptr + strlen(temp)) > bufend)
+	      {
+		strncpy(bufptr, temp, (size_t)(bufend - bufptr));
+		bufptr = bufend;
+	      }
+	      else
+	      {
+		strcpy(bufptr, temp);
+		bufptr += strlen(temp);
+	      }
+	    }
+	    break;
+
+	case 'p' : /* Pointer value */
+	    if ((width + 2) > sizeof(temp))
+	      break;
+
+	    sprintf(temp, tformat, va_arg(ap, void *));
+
+            bytes += strlen(temp);
+
+	    if (bufptr)
+	    {
+	      if ((bufptr + strlen(temp)) > bufend)
+	      {
+		strncpy(bufptr, temp, (size_t)(bufend - bufptr));
+		bufptr = bufend;
+	      }
+	      else
+	      {
+		strcpy(bufptr, temp);
+		bufptr += strlen(temp);
+	      }
+	    }
+	    break;
+
+        case 'c' : /* Character or character array */
+	    bytes += width;
+
+	    if (bufptr)
+	    {
+	      if (width <= 1)
+	        *bufptr++ = va_arg(ap, int);
+	      else
+	      {
+		if ((bufptr + width) > bufend)
+		  width = bufend - bufptr;
+
+		memcpy(bufptr, va_arg(ap, char *), (size_t)width);
+		bufptr += width;
+	      }
+	    }
+	    break;
+
+	case 's' : /* String */
+	    if ((s = va_arg(ap, char *)) == NULL)
+	      s = "(null)";
+
+	    slen = strlen(s);
+	    if (slen > width && prec != width)
+	      width = slen;
+
+            bytes += width;
+
+	    if (bufptr)
+	    {
+	      if ((bufptr + width) > bufend)
+	        width = bufend - bufptr;
+
+              if (slen > width)
+	        slen = width;
+
+	      if (sign == '-')
+	      {
+		strncpy(bufptr, s, (size_t)slen);
+		memset(bufptr + slen, ' ', (size_t)(width - slen));
+	      }
+	      else
+	      {
+		memset(bufptr, ' ', (size_t)(width - slen));
+		strncpy(bufptr + width - slen, s, (size_t)slen);
+	      }
+
+	      bufptr += width;
+	    }
+	    break;
+
+	case 'n' : /* Output number of chars so far */
+	    *(va_arg(ap, int *)) = bytes;
+	    break;
+      }
+    }
+    else
+    {
+      bytes ++;
+
+      if (bufptr && bufptr < bufend)
+        *bufptr++ = *format;
+
+      format ++;
+    }
+  }
+
+ /*
+  * Nul-terminate the string and return the number of characters needed.
+  */
+
+  *bufptr = '\0';
+
+  return (bytes);
+}
+#endif /* !HAVE_VSNPRINTF */
+
+
+/*
+ * '_mxml_vstrdupf()' - Format and duplicate a string.
+ */
+
+char *					/* O - New string pointer */
+_mxml_vstrdupf(const char *format,	/* I - Printf-style format string */
+               va_list    ap)		/* I - Pointer to additional arguments */
+{
+  int	bytes;				/* Number of bytes required */
+  char	*buffer,			/* String buffer */
+	temp[256];			/* Small buffer for first vsnprintf */
+
+
+ /*
+  * First format with a tiny buffer; this will tell us how many bytes are
+  * needed...
+  */
+
+  bytes = vsnprintf(temp, sizeof(temp), format, ap);
+
+  if (bytes < sizeof(temp))
+  {
+   /*
+    * Hey, the formatted string fits in the tiny buffer, so just dup that...
+    */
+
+    return (strdup(temp));
+  }
+
+ /*
+  * Allocate memory for the whole thing and reformat to the new, larger
+  * buffer...
+  */
+
+  if ((buffer = calloc(1, bytes + 1)) != NULL)
+    vsnprintf(buffer, bytes + 1, format, ap);
+
+ /*
+  * Return the new string...
+  */
+
+  return (buffer);
+}
+
+
+/*
+ * End of "$Id: mxml-string.c 387 2009-04-18 17:05:52Z mike $".
+ */
diff -Naur mxml-2.6/mxml.h mxml-2.6-haiku/mxml.h
--- mxml-2.6/mxml.h	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml.h	2009-03-19 05:38:52.000000000 +0000
@@ -0,0 +1,308 @@
+/*
+ * "$Id: mxml.h 385 2009-03-19 05:38:52Z mike $"
+ *
+ * Header file for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2009 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Prevent multiple inclusion...
+ */
+
+#ifndef _mxml_h_
+#  define _mxml_h_
+
+/*
+ * Include necessary headers...
+ */
+
+#  include <stdio.h>
+#  include <stdlib.h>
+#  include <string.h>
+#  include <ctype.h>
+#  include <errno.h>
+
+
+/*
+ * Constants...
+ */
+
+#  define MXML_TAB		8	/* Tabs every N columns */
+
+#  define MXML_NO_CALLBACK	0	/* Don't use a type callback */
+#  define MXML_INTEGER_CALLBACK	mxml_integer_cb
+					/* Treat all data as integers */
+#  define MXML_OPAQUE_CALLBACK	mxml_opaque_cb
+					/* Treat all data as opaque */
+#  define MXML_REAL_CALLBACK	mxml_real_cb
+					/* Treat all data as real numbers */
+#  define MXML_TEXT_CALLBACK	0	/* Treat all data as text */
+#  define MXML_IGNORE_CALLBACK	mxml_ignore_cb
+					/* Ignore all non-element content */
+
+#  define MXML_NO_PARENT	0	/* No parent for the node */
+
+#  define MXML_DESCEND		1	/* Descend when finding/walking */
+#  define MXML_NO_DESCEND	0	/* Don't descend when finding/walking */
+#  define MXML_DESCEND_FIRST	-1	/* Descend for first find */
+
+#  define MXML_WS_BEFORE_OPEN	0	/* Callback for before open tag */
+#  define MXML_WS_AFTER_OPEN	1	/* Callback for after open tag */
+#  define MXML_WS_BEFORE_CLOSE	2	/* Callback for before close tag */
+#  define MXML_WS_AFTER_CLOSE	3	/* Callback for after close tag */
+
+#  define MXML_ADD_BEFORE	0	/* Add node before specified node */
+#  define MXML_ADD_AFTER	1	/* Add node after specified node */
+#  define MXML_ADD_TO_PARENT	NULL	/* Add node relative to parent */
+
+
+/*
+ * Data types...
+ */
+
+typedef enum mxml_sax_event_e		/**** SAX event type. ****/
+{
+  MXML_SAX_CDATA,			/* CDATA node */
+  MXML_SAX_COMMENT,			/* Comment node */
+  MXML_SAX_DATA,			/* Data node */
+  MXML_SAX_DIRECTIVE,			/* Processing directive node */
+  MXML_SAX_ELEMENT_CLOSE,		/* Element closed */
+  MXML_SAX_ELEMENT_OPEN			/* Element opened */
+} mxml_sax_event_t;
+
+typedef enum mxml_type_e		/**** The XML node type. ****/
+{
+  MXML_IGNORE = -1,			/* Ignore/throw away node @since Mini-XML 2.3@ */
+  MXML_ELEMENT,				/* XML element with attributes */
+  MXML_INTEGER,				/* Integer value */
+  MXML_OPAQUE,				/* Opaque string */
+  MXML_REAL,				/* Real value */
+  MXML_TEXT,				/* Text fragment */
+  MXML_CUSTOM				/* Custom data @since Mini-XML 2.1@ */
+} mxml_type_t;
+
+typedef void (*mxml_custom_destroy_cb_t)(void *);
+					/**** Custom data destructor ****/
+
+typedef void (*mxml_error_cb_t)(const char *);  
+					/**** Error callback function ****/
+
+typedef struct mxml_attr_s		/**** An XML element attribute value. ****/
+{
+  char			*name;		/* Attribute name */
+  char			*value;		/* Attribute value */
+} mxml_attr_t;
+
+typedef struct mxml_element_s		/**** An XML element value. ****/
+{
+  char			*name;		/* Name of element */
+  int			num_attrs;	/* Number of attributes */
+  mxml_attr_t		*attrs;		/* Attributes */
+} mxml_element_t;
+
+typedef struct mxml_text_s		/**** An XML text value. ****/
+{
+  int			whitespace;	/* Leading whitespace? */
+  char			*string;	/* Fragment string */
+} mxml_text_t;
+
+typedef struct mxml_custom_s		/**** An XML custom value. @since Mini-XML 2.1@ ****/
+{
+  void			*data;		/* Pointer to (allocated) custom data */
+  mxml_custom_destroy_cb_t destroy;	/* Pointer to destructor function */
+} mxml_custom_t;
+
+typedef union mxml_value_u		/**** An XML node value. ****/
+{
+  mxml_element_t	element;	/* Element */
+  int			integer;	/* Integer number */
+  char			*opaque;	/* Opaque string */
+  double		real;		/* Real number */
+  mxml_text_t		text;		/* Text fragment */
+  mxml_custom_t		custom;		/* Custom data @since Mini-XML 2.1@ */
+} mxml_value_t;
+
+typedef struct mxml_node_s		/**** An XML node. ****/
+{
+  mxml_type_t		type;		/* Node type */
+  struct mxml_node_s	*next;		/* Next node under same parent */
+  struct mxml_node_s	*prev;		/* Previous node under same parent */
+  struct mxml_node_s	*parent;	/* Parent node */
+  struct mxml_node_s	*child;		/* First child node */
+  struct mxml_node_s	*last_child;	/* Last child node */
+  mxml_value_t		value;		/* Node value */
+  int			ref_count;	/* Use count */
+  void			*user_data;	/* User data */
+} mxml_node_t;
+
+typedef struct mxml_index_s		/**** An XML node index. ****/
+{
+  char			*attr;		/* Attribute used for indexing or NULL */
+  int			num_nodes;	/* Number of nodes in index */
+  int			alloc_nodes;	/* Allocated nodes in index */
+  int			cur_node;	/* Current node */
+  mxml_node_t		**nodes;	/* Node array */
+} mxml_index_t;
+
+typedef int (*mxml_custom_load_cb_t)(mxml_node_t *, const char *);
+					/**** Custom data load callback function ****/
+
+typedef char *(*mxml_custom_save_cb_t)(mxml_node_t *);  
+					/**** Custom data save callback function ****/
+
+typedef int (*mxml_entity_cb_t)(const char *);
+					/**** Entity callback function */
+
+typedef mxml_type_t (*mxml_load_cb_t)(mxml_node_t *);
+					/**** Load callback function ****/
+
+typedef const char *(*mxml_save_cb_t)(mxml_node_t *, int);
+					/**** Save callback function ****/
+
+typedef void (*mxml_sax_cb_t)(mxml_node_t *, mxml_sax_event_t, void *);  
+					/**** SAX callback function ****/
+
+
+/*
+ * C++ support...
+ */
+
+#  ifdef __cplusplus
+extern "C" {
+#  endif /* __cplusplus */
+
+/*
+ * Prototypes...
+ */
+
+extern void		mxmlAdd(mxml_node_t *parent, int where,
+			        mxml_node_t *child, mxml_node_t *node);
+extern void		mxmlDelete(mxml_node_t *node);
+extern void		mxmlElementDeleteAttr(mxml_node_t *node,
+			                      const char *name);
+extern const char	*mxmlElementGetAttr(mxml_node_t *node, const char *name);
+extern void		mxmlElementSetAttr(mxml_node_t *node, const char *name,
+			                   const char *value);
+extern void		mxmlElementSetAttrf(mxml_node_t *node, const char *name,
+			                    const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 3, 4)))
+#    endif /* __GNUC__ */
+;
+extern int		mxmlEntityAddCallback(mxml_entity_cb_t cb);
+extern const char	*mxmlEntityGetName(int val);
+extern int		mxmlEntityGetValue(const char *name);
+extern void		mxmlEntityRemoveCallback(mxml_entity_cb_t cb);
+extern mxml_node_t	*mxmlFindElement(mxml_node_t *node, mxml_node_t *top,
+			                 const char *name, const char *attr,
+					 const char *value, int descend);
+extern void		mxmlIndexDelete(mxml_index_t *ind);
+extern mxml_node_t	*mxmlIndexEnum(mxml_index_t *ind);
+extern mxml_node_t	*mxmlIndexFind(mxml_index_t *ind,
+			               const char *element,
+			               const char *value);
+extern mxml_index_t	*mxmlIndexNew(mxml_node_t *node, const char *element,
+			              const char *attr);
+extern mxml_node_t	*mxmlIndexReset(mxml_index_t *ind);
+extern mxml_node_t	*mxmlLoadFd(mxml_node_t *top, int fd,
+			            mxml_type_t (*cb)(mxml_node_t *));
+extern mxml_node_t	*mxmlLoadFile(mxml_node_t *top, FILE *fp,
+			              mxml_type_t (*cb)(mxml_node_t *));
+extern mxml_node_t	*mxmlLoadString(mxml_node_t *top, const char *s,
+			                mxml_type_t (*cb)(mxml_node_t *));
+extern mxml_node_t	*mxmlNewCDATA(mxml_node_t *parent, const char *string);
+extern mxml_node_t	*mxmlNewCustom(mxml_node_t *parent, void *data,
+			               mxml_custom_destroy_cb_t destroy);
+extern mxml_node_t	*mxmlNewElement(mxml_node_t *parent, const char *name);
+extern mxml_node_t	*mxmlNewInteger(mxml_node_t *parent, int integer);
+extern mxml_node_t	*mxmlNewOpaque(mxml_node_t *parent, const char *opaque);
+extern mxml_node_t	*mxmlNewReal(mxml_node_t *parent, double real);
+extern mxml_node_t	*mxmlNewText(mxml_node_t *parent, int whitespace,
+			             const char *string);
+extern mxml_node_t	*mxmlNewTextf(mxml_node_t *parent, int whitespace,
+			              const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 3, 4)))
+#    endif /* __GNUC__ */
+;
+extern mxml_node_t	*mxmlNewXML(const char *version);
+extern int		mxmlRelease(mxml_node_t *node);
+extern void		mxmlRemove(mxml_node_t *node);
+extern int		mxmlRetain(mxml_node_t *node);
+extern char		*mxmlSaveAllocString(mxml_node_t *node,
+			        	     mxml_save_cb_t cb);
+extern int		mxmlSaveFd(mxml_node_t *node, int fd,
+			           mxml_save_cb_t cb);
+extern int		mxmlSaveFile(mxml_node_t *node, FILE *fp,
+			             mxml_save_cb_t cb);
+extern int		mxmlSaveString(mxml_node_t *node, char *buffer,
+			               int bufsize, mxml_save_cb_t cb);
+extern mxml_node_t	*mxmlSAXLoadFd(mxml_node_t *top, int fd,
+			               mxml_type_t (*cb)(mxml_node_t *),
+			               mxml_sax_cb_t sax, void *sax_data);
+extern mxml_node_t	*mxmlSAXLoadFile(mxml_node_t *top, FILE *fp,
+			                 mxml_type_t (*cb)(mxml_node_t *),
+			                 mxml_sax_cb_t sax, void *sax_data);
+extern mxml_node_t	*mxmlSAXLoadString(mxml_node_t *top, const char *s,
+			                   mxml_type_t (*cb)(mxml_node_t *),
+			                   mxml_sax_cb_t sax, void *sax_data);
+extern int		mxmlSetCDATA(mxml_node_t *node, const char *data);
+extern int		mxmlSetCustom(mxml_node_t *node, void *data,
+			              mxml_custom_destroy_cb_t destroy);
+extern void		mxmlSetCustomHandlers(mxml_custom_load_cb_t load,
+			                      mxml_custom_save_cb_t save);
+extern int		mxmlSetElement(mxml_node_t *node, const char *name);
+extern void		mxmlSetErrorCallback(mxml_error_cb_t cb);
+extern int		mxmlSetInteger(mxml_node_t *node, int integer);
+extern int		mxmlSetOpaque(mxml_node_t *node, const char *opaque);
+extern int		mxmlSetReal(mxml_node_t *node, double real);
+extern int		mxmlSetText(mxml_node_t *node, int whitespace,
+			            const char *string);
+extern int		mxmlSetTextf(mxml_node_t *node, int whitespace,
+			             const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 3, 4)))
+#    endif /* __GNUC__ */
+;
+extern void		mxmlSetWrapMargin(int column);
+extern mxml_node_t	*mxmlWalkNext(mxml_node_t *node, mxml_node_t *top,
+			              int descend);
+extern mxml_node_t	*mxmlWalkPrev(mxml_node_t *node, mxml_node_t *top,
+			              int descend);
+
+
+/*
+ * Semi-private functions...
+ */
+
+extern void		mxml_error(const char *format, ...);
+extern mxml_type_t	mxml_ignore_cb(mxml_node_t *node);
+extern mxml_type_t	mxml_integer_cb(mxml_node_t *node);
+extern mxml_type_t	mxml_opaque_cb(mxml_node_t *node);
+extern mxml_type_t	mxml_real_cb(mxml_node_t *node);
+
+
+/*
+ * C++ support...
+ */
+
+#  ifdef __cplusplus
+}
+#  endif /* __cplusplus */
+#endif /* !_mxml_h_ */
+
+
+/*
+ * End of "$Id: mxml.h 385 2009-03-19 05:38:52Z mike $".
+ */
diff -Naur mxml-2.6/mxml.list mxml-2.6-haiku/mxml.list
--- mxml-2.6/mxml.list	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml.list	2009-10-26 02:28:22.000000000 +0000
@@ -0,0 +1,107 @@
+#
+# "$Id: mxml.list.in 399 2009-05-17 17:20:51Z mike $"
+#
+# EPM software list file for Mini-XML, a small XML library.
+#
+# Copyright 2003-2009 by Michael Sweet.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+
+# Directories...
+$prefix=/boot/common
+$exec_prefix=/boot/common
+$bindir=${exec_prefix}/bin
+$datarootdir=${prefix}/share
+$docdir=${datarootdir}/doc/mxml
+$includedir=${prefix}/include
+$libdir=${exec_prefix}/lib
+$mandir=${datarootdir}/man
+$srcdir=.
+
+$PICFLAG=0
+
+# Product information
+%product mxml
+%copyright 2003-2009 by Michael Sweet
+%vendor Michael Sweet
+%license ${srcdir}/COPYING
+%readme ${srcdir}/README
+%version 2.6
+
+%description <<EOF
+Mini-XML is a small XML parsing library that you can use to read
+XML and XML-like data files in your application without
+requiring large non-standard libraries.  Mini-XML provides the
+following functionality:
+
+    - Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded
+      XML files and strings.
+    - Data is stored in a linked-list tree structure, preserving
+      the XML data hierarchy.
+    - Supports arbitrary element names, attributes, and
+      attribute values with no preset limits, just available
+      memory.
+    - Supports integer, real, opaque ("cdata"), and text data
+      types in "leaf" nodes.
+    - Functions for creating and managing trees of data.
+    - "Find" and "walk" functions for easily locating and
+      navigating trees of data.
+
+Mini-XML doesn't do validation or other types of processing on
+the data based upon schema files or other sources of definition
+information, nor does it support character entities other than
+those required by the XML specification.
+EOF
+
+# Executables
+f 0555 root sys ${bindir}/mxmldoc mxmldoc
+
+# Header files
+f 0444 root sys ${includedir}/mxml.h mxml.h
+
+# Libraries
+%if $PICFLAG
+%system hpux
+f 0555 root sys ${libdir}/libmxml.sl.1 libmxml.sl.1
+l 0555 root sys ${libdir}/libmxml.sl libmxml.sl.1
+
+%system darwin
+f 0555 root sys ${libdir}/libmxml.1.dylib libmxml.1.dylib
+l 0555 root sys ${libdir}/libmxml.dylib libmxml.1.dylib
+
+%system freebsd irix linux netbsd openbsd solaris tru64
+f 0555 root sys ${libdir}/libmxml.so.1.4 libmxml.so.1.4
+l 0555 root sys ${libdir}/libmxml.so.1 libmxml.so.1.4
+l 0555 root sys ${libdir}/libmxml.so libmxml.so.1.4
+
+%system all
+%endif
+
+f 0444 root sys ${libdir}/libmxml.a libmxml.a
+
+# pkg-config info
+f 0444 root sys $(libdir)/pkgconfig/mxml.pc mxml.pc
+
+# Documentation
+f 0444 root sys ${docdir}/README $srcdir/README
+f 0444 root sys ${docdir}/COPYING $srcdir/COPYING
+f 0444 root sys ${docdir}/CHANGES $srcdir/CHANGES
+f 0444 root sys ${docdir}/mxml.html $srcdir/doc/mxml.html
+f 0444 root sys ${docdir}/mxml.pdf $srcdir/doc/mxml.pdf
+
+# Man pages
+f 0444 root sys ${mandir}/man1/mxmldoc.1 $srcdir/mxmldoc.man
+f 0444 root sys ${mandir}/man3/mxml.3 $srcdir/mxml.man
+
+#
+# End of "$Id: mxml.list.in 399 2009-05-17 17:20:51Z mike $".
+#
diff -Naur mxml-2.6/mxml.list.in mxml-2.6-haiku/mxml.list.in
--- mxml-2.6/mxml.list.in	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml.list.in	2009-05-17 17:20:51.000000000 +0000
@@ -0,0 +1,107 @@
+#
+# "$Id: mxml.list.in 399 2009-05-17 17:20:51Z mike $"
+#
+# EPM software list file for Mini-XML, a small XML library.
+#
+# Copyright 2003-2009 by Michael Sweet.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+
+# Directories...
+$prefix=@prefix@
+$exec_prefix=@exec_prefix@
+$bindir=@bindir@
+$datarootdir=@datarootdir@
+$docdir=@docdir@
+$includedir=@includedir@
+$libdir=@libdir@
+$mandir=@mandir@
+$srcdir=@srcdir@
+
+$PICFLAG=@PICFLAG@
+
+# Product information
+%product mxml
+%copyright 2003-2009 by Michael Sweet
+%vendor Michael Sweet
+%license ${srcdir}/COPYING
+%readme ${srcdir}/README
+%version @VERSION@
+
+%description <<EOF
+Mini-XML is a small XML parsing library that you can use to read
+XML and XML-like data files in your application without
+requiring large non-standard libraries.  Mini-XML provides the
+following functionality:
+
+    - Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded
+      XML files and strings.
+    - Data is stored in a linked-list tree structure, preserving
+      the XML data hierarchy.
+    - Supports arbitrary element names, attributes, and
+      attribute values with no preset limits, just available
+      memory.
+    - Supports integer, real, opaque ("cdata"), and text data
+      types in "leaf" nodes.
+    - Functions for creating and managing trees of data.
+    - "Find" and "walk" functions for easily locating and
+      navigating trees of data.
+
+Mini-XML doesn't do validation or other types of processing on
+the data based upon schema files or other sources of definition
+information, nor does it support character entities other than
+those required by the XML specification.
+EOF
+
+# Executables
+f 0555 root sys ${bindir}/mxmldoc mxmldoc
+
+# Header files
+f 0444 root sys ${includedir}/mxml.h mxml.h
+
+# Libraries
+%if $PICFLAG
+%system hpux
+f 0555 root sys ${libdir}/libmxml.sl.1 libmxml.sl.1
+l 0555 root sys ${libdir}/libmxml.sl libmxml.sl.1
+
+%system darwin
+f 0555 root sys ${libdir}/libmxml.1.dylib libmxml.1.dylib
+l 0555 root sys ${libdir}/libmxml.dylib libmxml.1.dylib
+
+%system freebsd irix linux netbsd openbsd solaris tru64
+f 0555 root sys ${libdir}/libmxml.so.1.4 libmxml.so.1.4
+l 0555 root sys ${libdir}/libmxml.so.1 libmxml.so.1.4
+l 0555 root sys ${libdir}/libmxml.so libmxml.so.1.4
+
+%system all
+%endif
+
+f 0444 root sys ${libdir}/libmxml.a libmxml.a
+
+# pkg-config info
+f 0444 root sys $(libdir)/pkgconfig/mxml.pc mxml.pc
+
+# Documentation
+f 0444 root sys ${docdir}/README $srcdir/README
+f 0444 root sys ${docdir}/COPYING $srcdir/COPYING
+f 0444 root sys ${docdir}/CHANGES $srcdir/CHANGES
+f 0444 root sys ${docdir}/mxml.html $srcdir/doc/mxml.html
+f 0444 root sys ${docdir}/mxml.pdf $srcdir/doc/mxml.pdf
+
+# Man pages
+f 0444 root sys ${mandir}/man1/mxmldoc.1 $srcdir/mxmldoc.man
+f 0444 root sys ${mandir}/man3/mxml.3 $srcdir/mxml.man
+
+#
+# End of "$Id: mxml.list.in 399 2009-05-17 17:20:51Z mike $".
+#
diff -Naur mxml-2.6/mxml.pc mxml-2.6-haiku/mxml.pc
--- mxml-2.6/mxml.pc	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml.pc	2009-10-26 02:28:22.000000000 +0000
@@ -0,0 +1,10 @@
+prefix=/boot/common
+exec_prefix=/boot/common
+libdir=${exec_prefix}/lib
+includedir=${prefix}/include
+
+Name: Mini-XML
+Description: Lightweight XML support library
+Version: 2.6
+Libs: -L${exec_prefix}/lib -lmxml -pthread
+Cflags: -I${prefix}/include -D_THREAD_SAFE -D_REENTRANT
diff -Naur mxml-2.6/mxml.pc.in mxml-2.6-haiku/mxml.pc.in
--- mxml-2.6/mxml.pc.in	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml.pc.in	2008-03-21 04:31:07.000000000 +0000
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: Mini-XML
+Description: Lightweight XML support library
+Version: @VERSION@
+Libs: @PC_LIBS@ @PTHREAD_LIBS@
+Cflags: @PC_CFLAGS@ @PTHREAD_FLAGS@
diff -Naur mxml-2.6/mxml.spec mxml-2.6-haiku/mxml.spec
--- mxml-2.6/mxml.spec	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxml.spec	2009-05-17 17:20:51.000000000 +0000
@@ -0,0 +1,95 @@
+#
+# "$Id: mxml.spec 399 2009-05-17 17:20:51Z mike $"
+#
+# RPM "spec" file for Mini-XML, a small XML library.
+#
+# Copyright 2003-2009 by Michael Sweet.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+
+Summary: Miniature XML development library
+Name: mxml
+Version: 2.6
+Release: 1
+License: LGPL
+Group: Development/Libraries
+Source: http://www.easysw.com/~mike/mxml/mxml-%{version}.tar.gz
+Url: http://www.easysw.com/~mike/mxml/
+Packager: Michael Sweet <mxml@easysw.com>
+Vendor: Michael Sweet
+
+# Use buildroot so as not to disturb the version already installed
+BuildRoot: /var/tmp/%{name}-root
+
+%description
+Mini-XML is a small XML parsing library that you can use to read
+XML and XML-like data files in your application without
+requiring large non-standard libraries.  Mini-XML provides the
+following functionality:
+
+    - Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded
+      XML files and strings.
+    - Data is stored in a linked-list tree structure, preserving
+      the XML data hierarchy.
+    - Supports arbitrary element names, attributes, and
+      attribute values with no preset limits, just available
+      memory.
+    - Supports integer, real, opaque ("cdata"), and text data
+      types in "leaf" nodes.
+    - Functions for creating and managing trees of data.
+    - "Find" and "walk" functions for easily locating and
+      navigating trees of data.
+
+Mini-XML doesn't do validation or other types of processing on
+the data based upon schema files or other sources of definition
+information, nor does it support character entities other than
+those required by the XML specification.
+
+%prep
+%setup
+
+%build
+CFLAGS="$RPM_OPT_FLAGS" CXXFLAGS="$RPM_OPT_FLAGS" LDFLAGS="$RPM_OPT_FLAGS" ./configure --enable-shared --prefix=/usr
+
+# If we got this far, all prerequisite libraries must be here.
+make
+
+%install
+# Make sure the RPM_BUILD_ROOT directory exists.
+rm -rf $RPM_BUILD_ROOT
+
+make BUILDROOT=$RPM_BUILD_ROOT install
+
+%clean
+rm -rf $RPM_BUILD_ROOT
+
+%files
+%defattr(-,root,root)
+
+%dir /usr/bin
+/usr/bin/*
+%dir /usr/include
+/usr/include/mxml.h
+%dir /usr/lib
+/usr/lib/*
+%dir /usr/lib/pkgconfig
+/usr/lib/pkgconfig/mxml.pc
+%dir /usr/share/doc/mxml
+/usr/share/doc/mxml/*
+%dir /usr/share/man/man1
+/usr/share/man/man1/*
+%dir /usr/share/man/man3
+/usr/share/man/man3/*
+
+#
+# End of "$Id: mxml.spec 399 2009-05-17 17:20:51Z mike $".
+#
diff -Naur mxml-2.6/mxmldoc.c mxml-2.6-haiku/mxmldoc.c
--- mxml-2.6/mxmldoc.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/mxmldoc.c	2009-05-05 13:38:00.000000000 +0000
@@ -0,0 +1,5772 @@
+/*#define DEBUG 1*/
+/*
+ * "$Id: mxmldoc.c 390 2009-05-05 13:38:00Z mike $"
+ *
+ * Documentation generator using Mini-XML, a small XML-like file parsing
+ * library.
+ *
+ * Copyright 2003-2009 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   main()              - Main entry for test program.
+ *   add_variable()      - Add a variable or argument.
+ *   find_public()       - Find a public function, type, etc.
+ *   get_comment_info()  - Get info from comment.
+ *   get_text()          - Get the text for a node.
+ *   load_cb()           - Set the type of child nodes.
+ *   new_documentation() - Create a new documentation tree.
+ *   remove_directory()  - Remove a directory.
+ *   safe_strcpy()       - Copy a string allowing for overlapping strings.
+ *   scan_file()         - Scan a source file.
+ *   sort_node()         - Insert a node sorted into a tree.
+ *   update_comment()    - Update a comment node.
+ *   usage()             - Show program usage...
+ *   write_description() - Write the description text.
+ *   write_element()     - Write an element's text nodes.
+ *   write_file()        - Copy a file to the output.
+ *   write_function()    - Write documentation for a function.
+ *   write_html()        - Write HTML documentation.
+ *   write_html_head()   - Write the standard HTML header.
+ *   write_man()         - Write manpage documentation.
+ *   write_scu()         - Write a structure, class, or union.
+ *   write_string()      - Write a string, quoting HTML special chars as needed.
+ *   write_toc()         - Write a table-of-contents.
+ *   write_tokens()      - Write <Token> nodes for all APIs.
+ *   ws_cb()             - Whitespace callback for saving.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+#include <time.h>
+#include <sys/stat.h>
+#ifndef WIN32
+#  include <dirent.h>
+#  include <unistd.h>
+#  include <spawn.h>
+#  include <sys/wait.h>
+extern char **environ;
+#endif /* !WIN32 */
+
+
+/*
+ * This program scans source and header files and produces public API
+ * documentation for code that conforms to the CUPS Configuration
+ * Management Plan (CMP) coding standards.  Please see the following web
+ * page for details:
+ *
+ *     http://www.cups.org/cmp.html
+ *
+ * Using Mini-XML, this program creates and maintains an XML representation
+ * of the public API code documentation which can then be converted to HTML
+ * as desired.  The following is a poor-man's schema:
+ *
+ * <?xml version="1.0"?>
+ * <mxmldoc xmlns="http://www.easysw.com"
+ *  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+ *  xsi:schemaLocation="http://www.minixml.org/mxmldoc.xsd">
+ *
+ *   <namespace name="">                        [optional...]
+ *     <constant name="">
+ *       <description>descriptive text</description>
+ *     </constant>
+ *  
+ *     <enumeration name="">
+ *       <description>descriptive text</description>
+ *       <constant name="">...</constant>
+ *     </enumeration>
+ *  
+ *     <typedef name="">
+ *       <description>descriptive text</description>
+ *       <type>type string</type>
+ *     </typedef>
+ *  
+ *     <function name="" scope="">
+ *       <description>descriptive text</description>
+ *       <argument name="" direction="I|O|IO" default="">
+ *         <description>descriptive text</description>
+ *         <type>type string</type>
+ *       </argument>
+ *       <returnvalue>
+ *         <description>descriptive text</description>
+ *         <type>type string</type>
+ *       </returnvalue>
+ *       <seealso>function names separated by spaces</seealso>
+ *     </function>
+ *  
+ *     <variable name="" scope="">
+ *       <description>descriptive text</description>
+ *       <type>type string</type>
+ *     </variable>
+ *  
+ *     <struct name="">
+ *       <description>descriptive text</description>
+ *       <variable name="">...</variable>
+ *       <function name="">...</function>
+ *     </struct>
+ *  
+ *     <union name="">
+ *       <description>descriptive text</description>
+ *       <variable name="">...</variable>
+ *     </union>
+ *  
+ *     <class name="" parent="">
+ *       <description>descriptive text</description>
+ *       <class name="">...</class>
+ *       <enumeration name="">...</enumeration>
+ *       <function name="">...</function>
+ *       <struct name="">...</struct>
+ *       <variable name="">...</variable>
+ *     </class>
+ *   </namespace>
+ * </mxmldoc>
+ */
+ 
+
+/*
+ * Basic states for file parser...
+ */
+
+#define STATE_NONE		0	/* No state - whitespace, etc. */
+#define STATE_PREPROCESSOR	1	/* Preprocessor directive */
+#define STATE_C_COMMENT		2	/* Inside a C comment */
+#define STATE_CXX_COMMENT	3	/* Inside a C++ comment */
+#define STATE_STRING		4	/* Inside a string constant */
+#define STATE_CHARACTER		5	/* Inside a character constant */
+#define STATE_IDENTIFIER	6	/* Inside a keyword/identifier */
+
+
+/*
+ * Output modes...
+ */
+
+#define OUTPUT_NONE		0	/* No output */
+#define OUTPUT_HTML		1	/* Output HTML */
+#define OUTPUT_XML		2	/* Output XML */
+#define OUTPUT_MAN		3	/* Output nroff/man */
+#define OUTPUT_TOKENS		4	/* Output docset Tokens.xml file */
+
+
+/*
+ * Local functions...
+ */
+
+static mxml_node_t	*add_variable(mxml_node_t *parent, const char *name,
+			              mxml_node_t *type);
+static mxml_node_t	*find_public(mxml_node_t *node, mxml_node_t *top,
+			             const char *name);
+static char		*get_comment_info(mxml_node_t *description);
+static char		*get_text(mxml_node_t *node, char *buffer, int buflen);
+static mxml_type_t	load_cb(mxml_node_t *node);
+static mxml_node_t	*new_documentation(mxml_node_t **mxmldoc);
+static int		remove_directory(const char *path);
+static void		safe_strcpy(char *dst, const char *src);
+static int		scan_file(const char *filename, FILE *fp,
+			          mxml_node_t *doc);
+static void		sort_node(mxml_node_t *tree, mxml_node_t *func);
+static void		update_comment(mxml_node_t *parent,
+			               mxml_node_t *comment);
+static void		usage(const char *option);
+static void		write_description(FILE *out, mxml_node_t *description,
+			                  const char *element, int summary);
+static void		write_element(FILE *out, mxml_node_t *doc,
+			              mxml_node_t *element, int mode);
+static void		write_file(FILE *out, const char *file);
+static void		write_function(FILE *out, mxml_node_t *doc,
+			               mxml_node_t *function, int level);
+static void		write_html(const char *section, const char *title,
+			           const char *footerfile,
+			           const char *headerfile,
+				   const char *introfile, const char *cssfile,
+				   const char *framefile,
+				   const char *docset, const char *docversion,
+				   const char *feedname, const char *feedurl,
+				   mxml_node_t *doc);
+static void		write_html_head(FILE *out, const char *section,
+			                const char *title, const char *cssfile);
+static void		write_man(const char *man_name, const char *section,
+			          const char *title, const char *headerfile,
+				  const char *footerfile, const char *introfile,
+				  mxml_node_t *doc);
+static void		write_scu(FILE *out, mxml_node_t *doc,
+			          mxml_node_t *scut);
+static void		write_string(FILE *out, const char *s, int mode);
+static void		write_toc(FILE *out, mxml_node_t *doc,
+			          const char *introfile, const char *target,
+				  int xml);
+static void		write_tokens(FILE *out, mxml_node_t *doc,
+			             const char *path);
+static const char	*ws_cb(mxml_node_t *node, int where);
+
+
+/*
+ * 'main()' - Main entry for test program.
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line args */
+     char *argv[])			/* I - Command-line args */
+{
+  int		i;			/* Looping var */
+  int		len;			/* Length of argument */
+  FILE		*fp;			/* File to read */
+  mxml_node_t	*doc;			/* XML documentation tree */
+  mxml_node_t	*mxmldoc;		/* mxmldoc node */
+  const char	*cssfile,		/* CSS stylesheet file */
+		*docset,		/* Documentation set directory */
+		*docversion,		/* Documentation set version */
+		*feedname,		/* Feed name for documentation set */
+		*feedurl,		/* Feed URL for documentation set */
+		*footerfile,		/* Footer file */
+		*framefile,		/* Framed HTML basename */
+		*headerfile,		/* Header file */
+		*introfile,		/* Introduction file */
+		*name,			/* Name of manpage */
+		*path,			/* Path to help file for tokens */
+		*section,		/* Section/keywords of documentation */
+		*title,			/* Title of documentation */
+		*xmlfile;		/* XML file */
+  int		mode,			/* Output mode */
+		update;			/* Updated XML file */
+
+
+ /*
+  * Check arguments...
+  */
+
+  cssfile     = NULL;
+  doc         = NULL;
+  docset      = NULL;
+  docversion  = NULL;
+  feedname    = NULL;
+  feedurl     = NULL;
+  footerfile  = NULL;
+  framefile   = NULL;
+  headerfile  = NULL;
+  introfile   = NULL;
+  mode        = OUTPUT_HTML;
+  mxmldoc     = NULL;
+  name        = NULL;
+  path        = NULL;
+  section     = NULL;
+  title       = NULL;
+  update      = 0;
+  xmlfile     = NULL;
+
+  for (i = 1; i < argc; i ++)
+    if (!strcmp(argv[i], "--help"))
+    {
+     /*
+      * Show help...
+      */
+
+      usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--css") && !cssfile)
+    {
+     /*
+      * Set CSS stylesheet file...
+      */
+
+      i ++;
+      if (i < argc)
+        cssfile = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--docset") && !docset)
+    {
+     /*
+      * Set documentation set directory...
+      */
+
+      i ++;
+      if (i < argc)
+        docset = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--docversion") && !docversion)
+    {
+     /*
+      * Set documentation set directory...
+      */
+
+      i ++;
+      if (i < argc)
+        docversion = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--footer") && !footerfile)
+    {
+     /*
+      * Set footer file...
+      */
+
+      i ++;
+      if (i < argc)
+        footerfile = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--feedname") && !feedname)
+    {
+     /*
+      * Set documentation set feed name...
+      */
+
+      i ++;
+      if (i < argc)
+        feedname = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--feedurl") && !feedurl)
+    {
+     /*
+      * Set documentation set feed name...
+      */
+
+      i ++;
+      if (i < argc)
+        feedurl = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--framed") && !framefile)
+    {
+     /*
+      * Set base filename for framed HTML output...
+      */
+
+      i ++;
+      if (i < argc)
+        framefile = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--header") && !headerfile)
+    {
+     /*
+      * Set header file...
+      */
+
+      i ++;
+      if (i < argc)
+        headerfile = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--intro") && !introfile)
+    {
+     /*
+      * Set intro file...
+      */
+
+      i ++;
+      if (i < argc)
+        introfile = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--man") && !name)
+    {
+     /*
+      * Output manpage...
+      */
+
+      i ++;
+      if (i < argc)
+      {
+        mode = OUTPUT_MAN;
+        name = argv[i];
+      }
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--no-output"))
+      mode = OUTPUT_NONE;
+    else if (!strcmp(argv[i], "--section") && !section)
+    {
+     /*
+      * Set section/keywords...
+      */
+
+      i ++;
+      if (i < argc)
+        section = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--title") && !title)
+    {
+     /*
+      * Set title...
+      */
+
+      i ++;
+      if (i < argc)
+        title = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (!strcmp(argv[i], "--tokens"))
+    {
+     /*
+      * Output Tokens.xml file...
+      */
+
+      mode = OUTPUT_TOKENS;
+
+      i ++;
+      if (i < argc)
+        path = argv[i];
+      else
+        usage(NULL);
+    }
+    else if (argv[i][0] == '-')
+    {
+     /*
+      * Unknown/bad option...
+      */
+
+      usage(argv[i]);
+    }
+    else
+    {
+     /*
+      * Process XML or source file...
+      */
+
+      len = (int)strlen(argv[i]);
+      if (len > 4 && !strcmp(argv[i] + len - 4, ".xml"))
+      {
+       /*
+        * Set XML file...
+	*/
+
+        if (xmlfile)
+	  usage(NULL);
+
+        xmlfile = argv[i];
+
+        if (!doc)
+	{
+	  if ((fp = fopen(argv[i], "r")) != NULL)
+	  {
+	   /*
+	    * Read the existing XML file...
+	    */
+
+	    doc = mxmlLoadFile(NULL, fp, load_cb);
+
+	    fclose(fp);
+
+	    if (!doc)
+	    {
+	      mxmldoc = NULL;
+
+	      fprintf(stderr,
+	              "mxmldoc: Unable to read the XML documentation file "
+		      "\"%s\"!\n", argv[i]);
+	    }
+	    else if ((mxmldoc = mxmlFindElement(doc, doc, "mxmldoc", NULL,
+                                        	NULL, MXML_DESCEND)) == NULL)
+	    {
+	      fprintf(stderr,
+	              "mxmldoc: XML documentation file \"%s\" is missing "
+		      "<mxmldoc> node!!\n", argv[i]);
+
+	      mxmlDelete(doc);
+	      doc = NULL;
+	    }
+	  }
+	  else
+	  {
+	    doc     = NULL;
+	    mxmldoc = NULL;
+	  }
+
+	  if (!doc)
+	    doc = new_documentation(&mxmldoc);
+        }
+      }
+      else
+      {
+       /*
+        * Load source file...
+	*/
+
+        update = 1;
+
+	if (!doc)
+	  doc = new_documentation(&mxmldoc);
+
+	if ((fp = fopen(argv[i], "r")) == NULL)
+	{
+	  fprintf(stderr, "mxmldoc: Unable to open source file \"%s\": %s\n",
+	          argv[i], strerror(errno));
+	  mxmlDelete(doc);
+	  return (1);
+	}
+	else if (scan_file(argv[i], fp, mxmldoc))
+	{
+	  fclose(fp);
+	  mxmlDelete(doc);
+	  return (1);
+	}
+	else
+	  fclose(fp);
+      }
+    }
+
+  if (update && xmlfile)
+  {
+   /*
+    * Save the updated XML documentation file...
+    */
+
+    if ((fp = fopen(xmlfile, "w")) != NULL)
+    {
+     /*
+      * Write over the existing XML file...
+      */
+
+      mxmlSetWrapMargin(0);
+
+      if (mxmlSaveFile(doc, fp, ws_cb))
+      {
+	fprintf(stderr,
+	        "mxmldoc: Unable to write the XML documentation file \"%s\": "
+		"%s!\n", xmlfile, strerror(errno));
+	fclose(fp);
+	mxmlDelete(doc);
+	return (1);
+      }
+
+      fclose(fp);
+    }
+    else
+    {
+      fprintf(stderr,
+              "mxmldoc: Unable to create the XML documentation file \"%s\": "
+	      "%s!\n", xmlfile, strerror(errno));
+      mxmlDelete(doc);
+      return (1);
+    }
+  }
+
+  switch (mode)
+  {
+    case OUTPUT_HTML :
+       /*
+        * Write HTML documentation...
+        */
+
+        write_html(section, title ? title : "Documentation", footerfile,
+	           headerfile, introfile, cssfile, framefile, docset,
+		   docversion, feedname, feedurl, mxmldoc);
+        break;
+
+    case OUTPUT_MAN :
+       /*
+        * Write manpage documentation...
+        */
+
+        write_man(name, section, title, footerfile, headerfile, introfile,
+	          mxmldoc);
+        break;
+
+    case OUTPUT_TOKENS :
+	fputs("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+	      "<Tokens version=\"1.0\">\n", stdout);
+
+	write_tokens(stdout, mxmldoc, path);
+
+	fputs("</Tokens>\n", stdout);
+        break;
+  }
+
+ /*
+  * Delete the tree and return...
+  */
+
+  mxmlDelete(doc);
+
+  return (0);
+}
+
+
+/*
+ * 'add_variable()' - Add a variable or argument.
+ */
+
+static mxml_node_t *			/* O - New variable/argument */
+add_variable(mxml_node_t *parent,	/* I - Parent node */
+             const char  *name,		/* I - "argument" or "variable" */
+             mxml_node_t *type)		/* I - Type nodes */
+{
+  mxml_node_t	*variable,		/* New variable */
+		*node,			/* Current node */
+		*next;			/* Next node */
+  char		buffer[16384],		/* String buffer */
+		*bufptr;		/* Pointer into buffer */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "add_variable(parent=%p, name=\"%s\", type=%p)\n",
+          parent, name, type);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!type || !type->child)
+    return (NULL);
+
+ /*
+  * Create the variable/argument node...
+  */
+
+  variable = mxmlNewElement(parent, name);
+
+ /*
+  * Check for a default value...
+  */
+
+  for (node = type->child; node; node = node->next)
+    if (!strcmp(node->value.text.string, "="))
+      break;
+
+  if (node)
+  {
+   /*
+    * Default value found, copy it and add as a "default" attribute...
+    */
+
+    for (bufptr = buffer; node; bufptr += strlen(bufptr))
+    {
+      if (node->value.text.whitespace && bufptr > buffer)
+	*bufptr++ = ' ';
+
+      strcpy(bufptr, node->value.text.string);
+
+      next = node->next;
+      mxmlDelete(node);
+      node = next;
+    }
+
+    mxmlElementSetAttr(variable, "default", buffer);
+  }
+
+ /*
+  * Extract the argument/variable name...
+  */
+
+  if (type->last_child->value.text.string[0] == ')')
+  {
+   /*
+    * Handle "type (*name)(args)"...
+    */
+
+    for (node = type->child; node; node = node->next)
+      if (node->value.text.string[0] == '(')
+	break;
+
+    for (bufptr = buffer; node; bufptr += strlen(bufptr))
+    {
+      if (node->value.text.whitespace && bufptr > buffer)
+	*bufptr++ = ' ';
+
+      strcpy(bufptr, node->value.text.string);
+
+      next = node->next;
+      mxmlDelete(node);
+      node = next;
+    }
+  }
+  else
+  {
+   /*
+    * Handle "type name"...
+    */
+
+    strcpy(buffer, type->last_child->value.text.string);
+    mxmlDelete(type->last_child);
+  }
+
+ /*
+  * Set the name...
+  */
+
+  mxmlElementSetAttr(variable, "name", buffer);
+
+ /*
+  * Add the remaining type information to the variable node...
+  */
+
+  mxmlAdd(variable, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, type);
+
+ /*
+  * Add new new variable node...
+  */
+
+  return (variable);
+}
+
+
+/*
+ * 'find_public()' - Find a public function, type, etc.
+ */
+
+static mxml_node_t *			/* I - Found node or NULL */
+find_public(mxml_node_t *node,		/* I - Current node */
+            mxml_node_t *top,		/* I - Top node */
+            const char  *name)		/* I - Name of element */
+{
+  mxml_node_t	*description,		/* Description node */
+		*comment;		/* Comment node */
+
+
+  for (node = mxmlFindElement(node, top, name, NULL, NULL,
+                              node == top ? MXML_DESCEND_FIRST :
+			                    MXML_NO_DESCEND);
+       node;
+       node = mxmlFindElement(node, top, name, NULL, NULL, MXML_NO_DESCEND))
+  {
+   /*
+    * Get the description for this node...
+    */
+
+    description = mxmlFindElement(node, node, "description", NULL, NULL,
+                                  MXML_DESCEND_FIRST);
+
+   /*
+    * A missing or empty description signals a private node...
+    */
+
+    if (!description)
+      continue;
+
+   /*
+    * Look for @private@ in the comment text...
+    */
+
+    for (comment = description->child; comment; comment = comment->next)
+      if ((comment->type == MXML_TEXT &&
+           strstr(comment->value.text.string, "@private@")) ||
+          (comment->type == MXML_OPAQUE &&
+           strstr(comment->value.opaque, "@private@")))
+        break;
+
+    if (!comment)
+    {
+     /*
+      * No @private@, so return this node...
+      */
+
+      return (node);
+    }
+  }
+
+ /*
+  * If we get here, there are no (more) public nodes...
+  */
+
+  return (NULL);
+}
+
+
+/*
+ * 'get_comment_info()' - Get info from comment.
+ */
+
+static char *				/* O - Info from comment */
+get_comment_info(
+    mxml_node_t *description)		/* I - Description node */
+{
+  char		text[10240],		/* Description text */
+		since[255],		/* @since value */
+		*ptr;			/* Pointer into text */
+  static char	info[1024];		/* Info string */
+
+
+  if (!description)
+    return ("");
+
+  get_text(description, text, sizeof(text));
+
+  for (ptr = strchr(text, '@'); ptr; ptr = strchr(ptr + 1, '@'))
+  {
+    if (!strncmp(ptr, "@deprecated@", 12))
+      return ("<span class=\"info\">&nbsp;DEPRECATED&nbsp;</span>");
+    else if (!strncmp(ptr, "@since ", 7))
+    {
+      strncpy(since, ptr + 7, sizeof(since) - 1);
+      since[sizeof(since) - 1] = '\0';
+
+      if ((ptr = strchr(since, '@')) != NULL)
+        *ptr = '\0';
+
+      snprintf(info, sizeof(info), "<span class=\"info\">&nbsp;%s&nbsp;</span>", since);
+      return (info);
+    }
+  }
+
+  return ("");
+}
+
+
+/*
+ * 'get_text()' - Get the text for a node.
+ */
+
+static char *				/* O - Text in node */
+get_text(mxml_node_t *node,		/* I - Node to get */
+         char        *buffer,		/* I - Buffer */
+	 int         buflen)		/* I - Size of buffer */
+{
+  char		*ptr,			/* Pointer into buffer */
+		*end;			/* End of buffer */
+  int		len;			/* Length of node */
+  mxml_node_t	*current;		/* Current node */
+
+
+  ptr = buffer;
+  end = buffer + buflen - 1;
+
+  for (current = node->child; current && ptr < end; current = current->next)
+  {
+    if (current->type == MXML_TEXT)
+    {
+      if (current->value.text.whitespace)
+        *ptr++ = ' ';
+
+      len = (int)strlen(current->value.text.string);
+      if (len > (int)(end - ptr))
+        len = (int)(end - ptr);
+
+      memcpy(ptr, current->value.text.string, len);
+      ptr += len;
+    }
+    else if (current->type == MXML_OPAQUE)
+    {
+      len = (int)strlen(current->value.opaque);
+      if (len > (int)(end - ptr))
+        len = (int)(end - ptr);
+
+      memcpy(ptr, current->value.opaque, len);
+      ptr += len;
+    }
+  }
+
+  *ptr = '\0';
+
+  return (buffer);
+}
+
+
+/*
+ * 'load_cb()' - Set the type of child nodes.
+ */
+
+static mxml_type_t			/* O - Node type */
+load_cb(mxml_node_t *node)		/* I - Node */
+{
+  if (!strcmp(node->value.element.name, "description"))
+    return (MXML_OPAQUE);
+  else
+    return (MXML_TEXT);
+}
+
+
+/*
+ * 'new_documentation()' - Create a new documentation tree.
+ */
+
+static mxml_node_t *			/* O - New documentation */
+new_documentation(mxml_node_t **mxmldoc)/* O - mxmldoc node */
+{
+  mxml_node_t	*doc;			/* New documentation */
+
+
+ /*
+  * Create an empty XML documentation file...
+  */
+
+  doc = mxmlNewXML(NULL);
+
+  *mxmldoc = mxmlNewElement(doc, "mxmldoc");
+
+  mxmlElementSetAttr(*mxmldoc, "xmlns", "http://www.easysw.com");
+  mxmlElementSetAttr(*mxmldoc, "xmlns:xsi",
+                     "http://www.w3.org/2001/XMLSchema-instance");
+  mxmlElementSetAttr(*mxmldoc, "xsi:schemaLocation",
+                     "http://www.minixml.org/mxmldoc.xsd");
+
+  return (doc);
+}
+
+
+/*
+ * 'remove_directory()' - Remove a directory.
+ */
+
+static int				/* O - 1 on success, 0 on failure */
+remove_directory(const char *path)	/* I - Directory to remove */
+{
+#ifdef WIN32
+  /* TODO: Add Windows directory removal code */
+
+#else
+  DIR		*dir;			/* Directory */
+  struct dirent	*dent;			/* Current directory entry */
+  char		filename[1024];		/* Current filename */
+  struct stat	fileinfo;		/* File information */
+
+
+  if ((dir = opendir(path)) == NULL)
+  {
+    fprintf(stderr, "mxmldoc: Unable to open directory \"%s\": %s\n", path,
+            strerror(errno));
+    return (0);
+  }
+
+  while ((dent = readdir(dir)) != NULL)
+  {
+   /*
+    * Skip "." and ".."...
+    */
+
+    if (!strcmp(dent->d_name, ".") || !strcmp(dent->d_name, ".."))
+      continue;
+
+   /*
+    * See if we have a file or directory...
+    */
+
+    snprintf(filename, sizeof(filename), "%s/%s", path, dent->d_name);
+
+    if (stat(filename, &fileinfo))
+    {
+      fprintf(stderr, "mxmldoc: Unable to stat \"%s\": %s\n", filename,
+	      strerror(errno));
+      closedir(dir);
+      return (0);
+    }
+
+    if (S_ISDIR(fileinfo.st_mode))
+    {
+      if (!remove_directory(filename))
+      {
+        closedir(dir);
+	return (0);
+      }
+    }
+    else if (unlink(filename))
+    {
+      fprintf(stderr, "mxmldoc: Unable to remove \"%s\": %s\n", filename,
+	      strerror(errno));
+      closedir(dir);
+      return (0);
+    }
+  }
+
+  closedir(dir);
+
+  if (rmdir(path))
+  {
+    fprintf(stderr, "mxmldoc: Unable to remove directory \"%s\": %s\n", path,
+            strerror(errno));
+    return (0);
+  }
+#endif /* WIN32 */
+
+  return (1);
+}
+
+
+/*
+ * 'safe_strcpy()' - Copy a string allowing for overlapping strings.
+ */
+
+static void
+safe_strcpy(char       *dst,		/* I - Destination string */
+            const char *src)		/* I - Source string */
+{
+  while (*src)
+    *dst++ = *src++;
+
+  *dst = '\0';
+}
+
+
+/*
+ * 'scan_file()' - Scan a source file.
+ */
+
+static int				/* O - 0 on success, -1 on error */
+scan_file(const char  *filename,	/* I - Filename */
+          FILE        *fp,		/* I - File to scan */
+          mxml_node_t *tree)		/* I - Function tree */
+{
+  int		state,			/* Current parser state */
+		braces,			/* Number of braces active */
+		parens;			/* Number of active parenthesis */
+  int		ch;			/* Current character */
+  char		buffer[65536],		/* String buffer */
+		*bufptr;		/* Pointer into buffer */
+  const char	*scope;			/* Current variable/function scope */
+  mxml_node_t	*comment,		/* <comment> node */
+		*constant,		/* <constant> node */
+		*enumeration,		/* <enumeration> node */
+		*function,		/* <function> node */
+		*fstructclass,		/* function struct/class node */
+		*structclass,		/* <struct> or <class> node */
+		*typedefnode,		/* <typedef> node */
+		*variable,		/* <variable> or <argument> node */
+		*returnvalue,		/* <returnvalue> node */
+		*type,			/* <type> node */
+		*description,		/* <description> node */
+		*node,			/* Current node */
+		*next;			/* Next node */
+#if DEBUG > 1
+  mxml_node_t	*temp;			/* Temporary node */
+  int		oldstate,		/* Previous state */
+		oldch;			/* Old character */
+  static const char *states[] =		/* State strings */
+		{
+		  "STATE_NONE",
+		  "STATE_PREPROCESSOR",
+		  "STATE_C_COMMENT",
+		  "STATE_CXX_COMMENT",
+		  "STATE_STRING",
+		  "STATE_CHARACTER",
+		  "STATE_IDENTIFIER"
+		};
+#endif /* DEBUG > 1 */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "scan_file(filename=\"%s\", fp=%p, tree=%p)\n", filename,
+          fp, tree);
+#endif /* DEBUG */
+
+ /*
+  * Initialize the finite state machine...
+  */
+
+  state        = STATE_NONE;
+  braces       = 0;
+  parens       = 0;
+  bufptr       = buffer;
+
+  comment      = mxmlNewElement(MXML_NO_PARENT, "temp");
+  constant     = NULL;
+  enumeration  = NULL;
+  function     = NULL;
+  variable     = NULL;
+  returnvalue  = NULL;
+  type         = NULL;
+  description  = NULL;
+  typedefnode  = NULL;
+  structclass  = NULL;
+  fstructclass = NULL;
+
+  if (!strcmp(tree->value.element.name, "class"))
+    scope = "private";
+  else
+    scope = NULL;
+
+ /*
+  * Read until end-of-file...
+  */
+
+  while ((ch = getc(fp)) != EOF)
+  {
+#if DEBUG > 1
+    oldstate = state;
+    oldch    = ch;
+#endif /* DEBUG > 1 */
+
+    switch (state)
+    {
+      case STATE_NONE :			/* No state - whitespace, etc. */
+          switch (ch)
+	  {
+	    case '/' :			/* Possible C/C++ comment */
+	        ch     = getc(fp);
+		bufptr = buffer;
+
+		if (ch == '*')
+		  state = STATE_C_COMMENT;
+		else if (ch == '/')
+		  state = STATE_CXX_COMMENT;
+		else
+		{
+		  ungetc(ch, fp);
+
+		  if (type)
+		  {
+#ifdef DEBUG
+                    fputs("Identifier: <<<< / >>>\n", stderr);
+#endif /* DEBUG */
+                    ch = type->last_child->value.text.string[0];
+		    mxmlNewText(type, isalnum(ch) || ch == '_', "/");
+		  }
+		}
+		break;
+
+	    case '#' :			/* Preprocessor */
+#ifdef DEBUG
+	        fputs("    #preprocessor...\n", stderr);
+#endif /* DEBUG */
+	        state = STATE_PREPROCESSOR;
+		break;
+
+            case '\'' :			/* Character constant */
+	        state = STATE_CHARACTER;
+		bufptr = buffer;
+		*bufptr++ = ch;
+		break;
+
+            case '\"' :			/* String constant */
+	        state = STATE_STRING;
+		bufptr = buffer;
+		*bufptr++ = ch;
+		break;
+
+            case '{' :
+#ifdef DEBUG
+	        fprintf(stderr, "    open brace, function=%p, type=%p...\n",
+		        function, type);
+                if (type)
+                  fprintf(stderr, "    type->child=\"%s\"...\n",
+		          type->child->value.text.string);
+#endif /* DEBUG */
+
+	        if (function)
+		{
+		  if (fstructclass)
+		  {
+		    sort_node(fstructclass, function);
+		    fstructclass = NULL;
+		  }
+		  else
+		    sort_node(tree, function);
+
+		  function = NULL;
+		}
+		else if (type && type->child &&
+		         ((!strcmp(type->child->value.text.string, "typedef") &&
+			   type->child->next &&
+			   (!strcmp(type->child->next->value.text.string, "struct") ||
+			    !strcmp(type->child->next->value.text.string, "union") ||
+			    !strcmp(type->child->next->value.text.string, "class"))) ||
+			  !strcmp(type->child->value.text.string, "union") ||
+			  !strcmp(type->child->value.text.string, "struct") ||
+			  !strcmp(type->child->value.text.string, "class")))
+		{
+		 /*
+		  * Start of a class or structure...
+		  */
+
+		  if (!strcmp(type->child->value.text.string, "typedef"))
+		  {
+#ifdef DEBUG
+                    fputs("    starting typedef...\n", stderr);
+#endif /* DEBUG */
+
+		    typedefnode = mxmlNewElement(MXML_NO_PARENT, "typedef");
+		    mxmlDelete(type->child);
+		  }
+		  else
+		    typedefnode = NULL;
+	
+		  structclass = mxmlNewElement(MXML_NO_PARENT,
+		                               type->child->value.text.string);
+
+#ifdef DEBUG
+                  fprintf(stderr, "%c%s: <<<< %s >>>\n",
+		          toupper(type->child->value.text.string[0]),
+			  type->child->value.text.string + 1,
+			  type->child->next ?
+			      type->child->next->value.text.string : "(noname)");
+
+                  fputs("    type =", stderr);
+                  for (node = type->child; node; node = node->next)
+		    fprintf(stderr, " \"%s\"", node->value.text.string);
+		  putc('\n', stderr);
+
+                  fprintf(stderr, "    scope = %s\n", scope ? scope : "(null)");
+#endif /* DEBUG */
+
+                  if (type->child->next)
+		  {
+		    mxmlElementSetAttr(structclass, "name",
+		                       type->child->next->value.text.string);
+		    sort_node(tree, structclass);
+		  }
+
+                  if (typedefnode && type->child)
+		    type->child->value.text.whitespace = 0;
+                  else if (structclass && type->child &&
+		           type->child->next && type->child->next->next)
+		  {
+		    for (bufptr = buffer, node = type->child->next->next;
+		         node;
+			 bufptr += strlen(bufptr))
+		    {
+		      if (node->value.text.whitespace && bufptr > buffer)
+			*bufptr++ = ' ';
+
+		      strcpy(bufptr, node->value.text.string);
+
+		      next = node->next;
+		      mxmlDelete(node);
+		      node = next;
+		    }
+
+		    mxmlElementSetAttr(structclass, "parent", buffer);
+
+		    mxmlDelete(type);
+		    type = NULL;
+		  }
+		  else
+		  {
+		    mxmlDelete(type);
+		    type = NULL;
+		  }
+
+		  if (typedefnode && comment->last_child)
+		  {
+		   /*
+		    * Copy comment for typedef as well as class/struct/union...
+		    */
+
+		    mxmlNewText(comment, 0,
+		                comment->last_child->value.text.string);
+		    description = mxmlNewElement(typedefnode, "description");
+#ifdef DEBUG
+		    fprintf(stderr,
+		            "    duplicating comment %p/%p for typedef...\n",
+			    comment->last_child, comment->child);
+#endif /* DEBUG */
+		    update_comment(typedefnode, comment->last_child);
+		    mxmlAdd(description, MXML_ADD_AFTER, MXML_ADD_TO_PARENT,
+		            comment->last_child);
+		  }
+
+		  description = mxmlNewElement(structclass, "description");
+#ifdef DEBUG
+		  fprintf(stderr, "    adding comment %p/%p to %s...\n",
+		          comment->last_child, comment->child,
+			  structclass->value.element.name);
+#endif /* DEBUG */
+		  update_comment(structclass, comment->last_child);
+		  mxmlAdd(description, MXML_ADD_AFTER, MXML_ADD_TO_PARENT,
+		          comment->last_child);
+
+                  if (scan_file(filename, fp, structclass))
+		  {
+		    mxmlDelete(comment);
+		    return (-1);
+		  }
+
+#ifdef DEBUG
+                  fputs("    ended typedef...\n", stderr);
+#endif /* DEBUG */
+                  structclass = NULL;
+                  break;
+                }
+		else if (type && type->child && type->child->next &&
+		         (!strcmp(type->child->value.text.string, "enum") ||
+			  (!strcmp(type->child->value.text.string, "typedef") &&
+			   !strcmp(type->child->next->value.text.string, "enum"))))
+                {
+		 /*
+		  * Enumeration type...
+		  */
+
+		  if (!strcmp(type->child->value.text.string, "typedef"))
+		  {
+#ifdef DEBUG
+                    fputs("    starting typedef...\n", stderr);
+#endif /* DEBUG */
+
+		    typedefnode = mxmlNewElement(MXML_NO_PARENT, "typedef");
+		    mxmlDelete(type->child);
+		  }
+		  else
+		    typedefnode = NULL;
+	
+		  enumeration = mxmlNewElement(MXML_NO_PARENT, "enumeration");
+
+#ifdef DEBUG
+                  fprintf(stderr, "Enumeration: <<<< %s >>>\n",
+			  type->child->next ?
+			      type->child->next->value.text.string : "(noname)");
+#endif /* DEBUG */
+
+                  if (type->child->next)
+		  {
+		    mxmlElementSetAttr(enumeration, "name",
+		                       type->child->next->value.text.string);
+		    sort_node(tree, enumeration);
+		  }
+
+                  if (typedefnode && type->child)
+		    type->child->value.text.whitespace = 0;
+                  else
+		  {
+		    mxmlDelete(type);
+		    type = NULL;
+		  }
+
+		  if (typedefnode && comment->last_child)
+		  {
+		   /*
+		    * Copy comment for typedef as well as class/struct/union...
+		    */
+
+		    mxmlNewText(comment, 0,
+		                comment->last_child->value.text.string);
+		    description = mxmlNewElement(typedefnode, "description");
+#ifdef DEBUG
+		    fprintf(stderr,
+		            "    duplicating comment %p/%p for typedef...\n",
+			    comment->last_child, comment->child);
+#endif /* DEBUG */
+		    update_comment(typedefnode, comment->last_child);
+		    mxmlAdd(description, MXML_ADD_AFTER, MXML_ADD_TO_PARENT,
+		            comment->last_child);
+		  }
+
+		  description = mxmlNewElement(enumeration, "description");
+#ifdef DEBUG
+		  fprintf(stderr, "    adding comment %p/%p to enumeration...\n",
+		          comment->last_child, comment->child);
+#endif /* DEBUG */
+		  update_comment(enumeration, comment->last_child);
+		  mxmlAdd(description, MXML_ADD_AFTER, MXML_ADD_TO_PARENT,
+		          comment->last_child);
+		}
+		else if (type && type->child &&
+		         !strcmp(type->child->value.text.string, "extern"))
+                {
+                  if (scan_file(filename, fp, tree))
+		  {
+		    mxmlDelete(comment);
+		    return (-1);
+		  }
+                }
+		else if (type)
+		{
+		  mxmlDelete(type);
+		  type = NULL;
+		}
+
+	        braces ++;
+		function = NULL;
+		variable = NULL;
+		break;
+
+            case '}' :
+#ifdef DEBUG
+	        fputs("    close brace...\n", stderr);
+#endif /* DEBUG */
+
+                if (structclass)
+		  scope = NULL;
+
+                if (!typedefnode)
+		  enumeration = NULL;
+
+		constant    = NULL;
+		structclass = NULL;
+
+	        if (braces > 0)
+		  braces --;
+		else
+		{
+		  mxmlDelete(comment);
+		  return (0);
+		}
+		break;
+
+            case '(' :
+		if (type)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< ( >>>\n", stderr);
+#endif /* DEBUG */
+		  mxmlNewText(type, 0, "(");
+		}
+
+	        parens ++;
+		break;
+
+            case ')' :
+		if (type && parens)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< ) >>>\n", stderr);
+#endif /* DEBUG */
+		  mxmlNewText(type, 0, ")");
+		}
+
+                if (function && type && !parens)
+		{
+		 /*
+		  * Check for "void" argument...
+		  */
+
+		  if (type->child && type->child->next)
+		    variable = add_variable(function, "argument", type);
+		  else
+		    mxmlDelete(type);
+
+		  type = NULL;
+		}
+
+	        if (parens > 0)
+		  parens --;
+		break;
+
+	    case ';' :
+#ifdef DEBUG
+                fputs("Identifier: <<<< ; >>>\n", stderr);
+		fprintf(stderr, "    enumeration=%p, function=%p, type=%p, type->child=%p, typedefnode=%p\n",
+		        enumeration, function, type, type ? type->child : NULL, typedefnode);
+#endif /* DEBUG */
+
+		if (function)
+		{
+		  if (!strcmp(tree->value.element.name, "class"))
+		  {
+#ifdef DEBUG
+		    fputs("    ADDING FUNCTION TO CLASS\n", stderr);
+#endif /* DEBUG */
+		    sort_node(tree, function);
+		  }
+		  else
+		    mxmlDelete(function);
+
+		  function = NULL;
+		  variable = NULL;
+		}
+
+		if (type)
+		{
+		 /*
+		  * See if we have a typedef...
+		  */
+
+		  if (type->child &&
+		      !strcmp(type->child->value.text.string, "typedef"))
+		  {
+		   /*
+		    * Yes, add it!
+		    */
+
+		    typedefnode = mxmlNewElement(MXML_NO_PARENT, "typedef");
+
+		    for (node = type->child->next; node; node = node->next)
+		      if (!strcmp(node->value.text.string, "("))
+			break;
+
+                    if (node)
+		    {
+		      for (node = node->next; node; node = node->next)
+			if (strcmp(node->value.text.string, "*"))
+			  break;
+                    }
+
+                    if (!node)
+		      node = type->last_child;
+
+#ifdef DEBUG
+		    fprintf(stderr, "    ADDING TYPEDEF FOR %p(%s)...\n",
+		            node, node->value.text.string);
+#endif /* DEBUG */
+
+		    mxmlElementSetAttr(typedefnode, "name",
+				       node->value.text.string);
+		    sort_node(tree, typedefnode);
+
+                    if (type->child != node)
+		      mxmlDelete(type->child);
+
+		    mxmlDelete(node);
+
+		    if (type->child)
+		      type->child->value.text.whitespace = 0;
+
+		    mxmlAdd(typedefnode, MXML_ADD_AFTER, MXML_ADD_TO_PARENT,
+			    type);
+		    type = NULL;
+		    break;
+		  }
+		  else if (typedefnode && enumeration)
+		  {
+		   /*
+		    * Add enum typedef...
+		    */
+
+                    node = type->child;
+
+#ifdef DEBUG
+		    fprintf(stderr, "    ADDING TYPEDEF FOR %p(%s)...\n",
+		            node, node->value.text.string);
+#endif /* DEBUG */
+
+		    mxmlElementSetAttr(typedefnode, "name",
+				       node->value.text.string);
+		    sort_node(tree, typedefnode);
+		    mxmlDelete(type);
+
+		    type = mxmlNewElement(typedefnode, "type");
+                    mxmlNewText(type, 0, "enum");
+		    mxmlNewText(type, 1,
+		                mxmlElementGetAttr(enumeration, "name"));
+		    enumeration = NULL;
+		    type = NULL;
+		    break;
+		  }
+		  
+		  mxmlDelete(type);
+		  type = NULL;
+		}
+		break;
+
+	    case ':' :
+		if (type)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< : >>>\n", stderr);
+#endif /* DEBUG */
+		  mxmlNewText(type, 1, ":");
+		}
+		break;
+
+	    case '*' :
+		if (type)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< * >>>\n", stderr);
+#endif /* DEBUG */
+                  ch = type->last_child->value.text.string[0];
+		  mxmlNewText(type, isalnum(ch) || ch == '_', "*");
+		}
+		break;
+
+	    case ',' :
+		if (type && !enumeration)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< , >>>\n", stderr);
+#endif /* DEBUG */
+		  mxmlNewText(type, 0, ",");
+		}
+		break;
+
+	    case '&' :
+		if (type)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< & >>>\n", stderr);
+#endif /* DEBUG */
+		  mxmlNewText(type, 1, "&");
+		}
+		break;
+
+	    case '+' :
+		if (type)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< + >>>\n", stderr);
+#endif /* DEBUG */
+                  ch = type->last_child->value.text.string[0];
+		  mxmlNewText(type, isalnum(ch) || ch == '_', "+");
+		}
+		break;
+
+	    case '-' :
+		if (type)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< - >>>\n", stderr);
+#endif /* DEBUG */
+                  ch = type->last_child->value.text.string[0];
+		  mxmlNewText(type, isalnum(ch) || ch == '_', "-");
+		}
+		break;
+
+	    case '=' :
+		if (type)
+		{
+#ifdef DEBUG
+                  fputs("Identifier: <<<< = >>>\n", stderr);
+#endif /* DEBUG */
+                  ch = type->last_child->value.text.string[0];
+		  mxmlNewText(type, isalnum(ch) || ch == '_', "=");
+		}
+		break;
+
+            default :			/* Other */
+	        if (isalnum(ch) || ch == '_' || ch == '.' || ch == ':' || ch == '~')
+		{
+		  state     = STATE_IDENTIFIER;
+		  bufptr    = buffer;
+		  *bufptr++ = ch;
+		}
+		break;
+          }
+          break;
+
+      case STATE_PREPROCESSOR :		/* Preprocessor directive */
+          if (ch == '\n')
+	    state = STATE_NONE;
+	  else if (ch == '\\')
+	    getc(fp);
+          break;
+
+      case STATE_C_COMMENT :		/* Inside a C comment */
+          switch (ch)
+	  {
+	    case '\n' :
+	        while ((ch = getc(fp)) != EOF)
+		  if (ch == '*')
+		  {
+		    ch = getc(fp);
+
+		    if (ch == '/')
+		    {
+		      *bufptr = '\0';
+
+        	      if (comment->child != comment->last_child)
+		      {
+#ifdef DEBUG
+			fprintf(stderr, "    removing comment %p(%20.20s), last comment %p(%20.20s)...\n",
+				comment->child,
+				comment->child ? comment->child->value.text.string : "",
+				comment->last_child,
+				comment->last_child ? comment->last_child->value.text.string : "");
+#endif /* DEBUG */
+			mxmlDelete(comment->child);
+#ifdef DEBUG
+			fprintf(stderr, "    new comment %p, last comment %p...\n",
+				comment->child, comment->last_child);
+#endif /* DEBUG */
+		      }
+
+#ifdef DEBUG
+                      fprintf(stderr,
+		              "    processing comment, variable=%p, "
+		              "constant=%p, typedefnode=%p, tree=\"%s\"\n",
+		              variable, constant, typedefnode,
+			      tree->value.element.name);
+#endif /* DEBUG */
+
+		      if (variable)
+		      {
+		        if (strstr(buffer, "@private@"))
+			{
+			 /*
+			  * Delete private variables...
+			  */
+
+			  mxmlDelete(variable);
+			}
+			else
+			{
+			  description = mxmlNewElement(variable, "description");
+#ifdef DEBUG
+			  fprintf(stderr,
+			          "    adding comment %p/%p to variable...\n",
+			          comment->last_child, comment->child);
+#endif /* DEBUG */
+			  mxmlNewText(comment, 0, buffer);
+			  update_comment(variable,
+					 mxmlNewText(description, 0, buffer));
+                        }
+
+			variable = NULL;
+		      }
+		      else if (constant)
+		      {
+		        if (strstr(buffer, "@private@"))
+			{
+			 /*
+			  * Delete private constants...
+			  */
+
+			  mxmlDelete(constant);
+			}
+			else
+			{
+			  description = mxmlNewElement(constant, "description");
+#ifdef DEBUG
+			  fprintf(stderr,
+			          "    adding comment %p/%p to constant...\n",
+				  comment->last_child, comment->child);
+#endif /* DEBUG */
+			  mxmlNewText(comment, 0, buffer);
+			  update_comment(constant,
+					 mxmlNewText(description, 0, buffer));
+			}
+
+			constant = NULL;
+		      }
+		      else if (typedefnode)
+		      {
+		        if (strstr(buffer, "@private@"))
+			{
+			 /*
+			  * Delete private typedefs...
+			  */
+
+			  mxmlDelete(typedefnode);
+
+			  if (structclass)
+			  {
+			    mxmlDelete(structclass);
+			    structclass = NULL;
+			  }
+
+			  if (enumeration)
+			  {
+			    mxmlDelete(enumeration);
+			    enumeration = NULL;
+			  }
+			}
+			else
+			{
+			  description = mxmlNewElement(typedefnode, "description");
+#ifdef DEBUG
+			  fprintf(stderr,
+			          "    adding comment %p/%p to typedef %s...\n",
+				  comment->last_child, comment->child,
+				  mxmlElementGetAttr(typedefnode, "name"));
+#endif /* DEBUG */
+			  mxmlNewText(comment, 0, buffer);
+			  update_comment(typedefnode,
+					 mxmlNewText(description, 0, buffer));
+
+			  if (structclass)
+			  {
+			    description = mxmlNewElement(structclass, "description");
+			    update_comment(structclass,
+					   mxmlNewText(description, 0, buffer));
+			  }
+			  else if (enumeration)
+			  {
+			    description = mxmlNewElement(enumeration, "description");
+			    update_comment(enumeration,
+					   mxmlNewText(description, 0, buffer));
+			  }
+			}
+
+			typedefnode = NULL;
+		      }
+		      else if (strcmp(tree->value.element.name, "mxmldoc") &&
+		               !mxmlFindElement(tree, tree, "description",
+			                        NULL, NULL, MXML_DESCEND_FIRST))
+                      {
+        		description = mxmlNewElement(tree, "description");
+#ifdef DEBUG
+			fprintf(stderr, "    adding comment %p/%p to parent...\n",
+			        comment->last_child, comment->child);
+#endif /* DEBUG */
+        		mxmlNewText(comment, 0, buffer);
+			update_comment(tree,
+			               mxmlNewText(description, 0, buffer));
+		      }
+		      else
+		      {
+#ifdef DEBUG
+		        fprintf(stderr, "    before adding comment, child=%p, last_child=%p\n",
+			        comment->child, comment->last_child);
+#endif /* DEBUG */
+        		mxmlNewText(comment, 0, buffer);
+#ifdef DEBUG
+		        fprintf(stderr, "    after adding comment, child=%p, last_child=%p\n",
+			        comment->child, comment->last_child);
+#endif /* DEBUG */
+                      }
+#ifdef DEBUG
+		      fprintf(stderr, "C comment: <<<< %s >>>\n", buffer);
+#endif /* DEBUG */
+
+		      state = STATE_NONE;
+		      break;
+		    }
+		    else
+		      ungetc(ch, fp);
+		  }
+		  else if (ch == '\n' && bufptr > buffer &&
+		           bufptr < (buffer + sizeof(buffer) - 1))
+		    *bufptr++ = ch;
+		  else if (!isspace(ch))
+		    break;
+
+		if (ch != EOF)
+		  ungetc(ch, fp);
+
+                if (bufptr > buffer && bufptr < (buffer + sizeof(buffer) - 1))
+		  *bufptr++ = '\n';
+		break;
+
+	    case '/' :
+	        if (ch == '/' && bufptr > buffer && bufptr[-1] == '*')
+		{
+		  while (bufptr > buffer &&
+		         (bufptr[-1] == '*' || isspace(bufptr[-1] & 255)))
+		    bufptr --;
+		  *bufptr = '\0';
+
+        	  if (comment->child != comment->last_child)
+		  {
+#ifdef DEBUG
+		    fprintf(stderr, "    removing comment %p(%20.20s), last comment %p(%20.20s)...\n",
+			    comment->child,
+			    comment->child ? comment->child->value.text.string : "",
+			    comment->last_child,
+			    comment->last_child ? comment->last_child->value.text.string : "");
+#endif /* DEBUG */
+		    mxmlDelete(comment->child);
+#ifdef DEBUG
+		    fprintf(stderr, "    new comment %p, last comment %p...\n",
+			    comment->child, comment->last_child);
+#endif /* DEBUG */
+		  }
+
+#ifdef DEBUG
+                  fprintf(stderr,
+		          "    processing comment, variable=%p, "
+		          "constant=%p, typedefnode=%p, tree=\"%s\"\n",
+		          variable, constant, typedefnode,
+			  tree->value.element.name);
+#endif /* DEBUG */
+
+		  if (variable)
+		  {
+		    if (strstr(buffer, "@private@"))
+		    {
+		     /*
+		      * Delete private variables...
+		      */
+
+		      mxmlDelete(variable);
+		    }
+		    else
+		    {
+		      description = mxmlNewElement(variable, "description");
+#ifdef DEBUG
+		      fprintf(stderr, "    adding comment %p/%p to variable...\n",
+		              comment->last_child, comment->child);
+#endif /* DEBUG */
+		      mxmlNewText(comment, 0, buffer);
+		      update_comment(variable,
+				     mxmlNewText(description, 0, buffer));
+                    }
+
+		    variable = NULL;
+		  }
+		  else if (constant)
+		  {
+		    if (strstr(buffer, "@private@"))
+		    {
+		     /*
+		      * Delete private constants...
+		      */
+
+		      mxmlDelete(constant);
+		    }
+		    else
+		    {
+		      description = mxmlNewElement(constant, "description");
+#ifdef DEBUG
+		      fprintf(stderr, "    adding comment %p/%p to constant...\n",
+		              comment->last_child, comment->child);
+#endif /* DEBUG */
+		      mxmlNewText(comment, 0, buffer);
+		      update_comment(constant,
+				     mxmlNewText(description, 0, buffer));
+		    }
+
+		    constant = NULL;
+		  }
+		  else if (typedefnode)
+		  {
+		    if (strstr(buffer, "@private@"))
+		    {
+		     /*
+		      * Delete private typedefs...
+		      */
+
+		      mxmlDelete(typedefnode);
+
+		      if (structclass)
+		      {
+			mxmlDelete(structclass);
+			structclass = NULL;
+		      }
+
+		      if (enumeration)
+		      {
+			mxmlDelete(enumeration);
+			enumeration = NULL;
+		      }
+		    }
+		    else
+		    {
+		      description = mxmlNewElement(typedefnode, "description");
+#ifdef DEBUG
+		      fprintf(stderr,
+		              "    adding comment %p/%p to typedef %s...\n",
+			      comment->last_child, comment->child,
+			      mxmlElementGetAttr(typedefnode, "name"));
+#endif /* DEBUG */
+		      mxmlNewText(comment, 0, buffer);
+		      update_comment(typedefnode,
+				     mxmlNewText(description, 0, buffer));
+
+		      if (structclass)
+		      {
+			description = mxmlNewElement(structclass, "description");
+			update_comment(structclass,
+				       mxmlNewText(description, 0, buffer));
+		      }
+		      else if (enumeration)
+		      {
+			description = mxmlNewElement(enumeration, "description");
+			update_comment(enumeration,
+				       mxmlNewText(description, 0, buffer));
+		      }
+		    }
+
+		    typedefnode = NULL;
+		  }
+		  else if (strcmp(tree->value.element.name, "mxmldoc") &&
+		           !mxmlFindElement(tree, tree, "description",
+			                    NULL, NULL, MXML_DESCEND_FIRST))
+                  {
+        	    description = mxmlNewElement(tree, "description");
+#ifdef DEBUG
+		    fprintf(stderr, "    adding comment %p/%p to parent...\n",
+		            comment->last_child, comment->child);
+#endif /* DEBUG */
+		    mxmlNewText(comment, 0, buffer);
+		    update_comment(tree,
+			           mxmlNewText(description, 0, buffer));
+		  }
+		  else
+        	    mxmlNewText(comment, 0, buffer);
+
+#ifdef DEBUG
+		  fprintf(stderr, "C comment: <<<< %s >>>\n", buffer);
+#endif /* DEBUG */
+
+		  state = STATE_NONE;
+		  break;
+		}
+
+	    default :
+	        if (ch == ' ' && bufptr == buffer)
+		  break;
+
+	        if (bufptr < (buffer + sizeof(buffer) - 1))
+		  *bufptr++ = ch;
+		break;
+          }
+          break;
+
+      case STATE_CXX_COMMENT :		/* Inside a C++ comment */
+          if (ch == '\n')
+	  {
+	    state = STATE_NONE;
+	    *bufptr = '\0';
+
+            if (comment->child != comment->last_child)
+	    {
+#ifdef DEBUG
+	      fprintf(stderr, "    removing comment %p(%20.20s), last comment %p(%20.20s)...\n",
+		      comment->child,
+		      comment->child ? comment->child->value.text.string : "",
+		      comment->last_child,
+		      comment->last_child ? comment->last_child->value.text.string : "");
+#endif /* DEBUG */
+	      mxmlDelete(comment->child);
+#ifdef DEBUG
+	      fprintf(stderr, "    new comment %p, last comment %p...\n",
+		      comment->child, comment->last_child);
+#endif /* DEBUG */
+	    }
+
+	    if (variable)
+	    {
+	      if (strstr(buffer, "@private@"))
+	      {
+	       /*
+		* Delete private variables...
+		*/
+
+		mxmlDelete(variable);
+	      }
+	      else
+	      {
+		description = mxmlNewElement(variable, "description");
+#ifdef DEBUG
+		fprintf(stderr, "    adding comment %p/%p to variable...\n",
+		        comment->last_child, comment->child);
+#endif /* DEBUG */
+		mxmlNewText(comment, 0, buffer);
+		update_comment(variable,
+			       mxmlNewText(description, 0, buffer));
+              }
+
+	      variable = NULL;
+	    }
+	    else if (constant)
+	    {
+	      if (strstr(buffer, "@private@"))
+	      {
+	       /*
+		* Delete private constants...
+		*/
+
+		mxmlDelete(constant);
+	      }
+	      else
+	      {
+		description = mxmlNewElement(constant, "description");
+#ifdef DEBUG
+		fprintf(stderr, "    adding comment %p/%p to constant...\n",
+		        comment->last_child, comment->child);
+#endif /* DEBUG */
+		mxmlNewText(comment, 0, buffer);
+		update_comment(constant,
+			       mxmlNewText(description, 0, buffer));
+              }
+
+	      constant = NULL;
+	    }
+	    else if (typedefnode)
+	    {
+	      if (strstr(buffer, "@private@"))
+	      {
+	       /*
+		* Delete private typedefs...
+		*/
+
+		mxmlDelete(typedefnode);
+		typedefnode = NULL;
+
+		if (structclass)
+		{
+		  mxmlDelete(structclass);
+		  structclass = NULL;
+		}
+
+		if (enumeration)
+		{
+		  mxmlDelete(enumeration);
+		  enumeration = NULL;
+		}
+	      }
+	      else
+	      {
+		description = mxmlNewElement(typedefnode, "description");
+#ifdef DEBUG
+		fprintf(stderr, "    adding comment %p/%p to typedef %s...\n",
+			comment->last_child, comment->child,
+			mxmlElementGetAttr(typedefnode, "name"));
+#endif /* DEBUG */
+		mxmlNewText(comment, 0, buffer);
+		update_comment(typedefnode,
+			       mxmlNewText(description, 0, buffer));
+
+		if (structclass)
+		{
+		  description = mxmlNewElement(structclass, "description");
+		  update_comment(structclass,
+				 mxmlNewText(description, 0, buffer));
+		}
+		else if (enumeration)
+		{
+		  description = mxmlNewElement(enumeration, "description");
+		  update_comment(enumeration,
+				 mxmlNewText(description, 0, buffer));
+		}
+              }
+	    }
+	    else if (strcmp(tree->value.element.name, "mxmldoc") &&
+		     !mxmlFindElement(tree, tree, "description",
+			              NULL, NULL, MXML_DESCEND_FIRST))
+            {
+              description = mxmlNewElement(tree, "description");
+#ifdef DEBUG
+	      fprintf(stderr, "    adding comment %p/%p to parent...\n",
+	              comment->last_child, comment->child);
+#endif /* DEBUG */
+	      mxmlNewText(comment, 0, buffer);
+	      update_comment(tree,
+			     mxmlNewText(description, 0, buffer));
+	    }
+	    else
+              mxmlNewText(comment, 0, buffer);
+
+#ifdef DEBUG
+	    fprintf(stderr, "C++ comment: <<<< %s >>>\n", buffer);
+#endif /* DEBUG */
+	  }
+	  else if (ch == ' ' && bufptr == buffer)
+	    break;
+	  else if (bufptr < (buffer + sizeof(buffer) - 1))
+	    *bufptr++ = ch;
+          break;
+
+      case STATE_STRING :		/* Inside a string constant */
+	  *bufptr++ = ch;
+
+          if (ch == '\\')
+	    *bufptr++ = getc(fp);
+	  else if (ch == '\"')
+	  {
+	    *bufptr = '\0';
+
+	    if (type)
+	      mxmlNewText(type, type->child != NULL, buffer);
+
+	    state = STATE_NONE;
+	  }
+          break;
+
+      case STATE_CHARACTER :		/* Inside a character constant */
+	  *bufptr++ = ch;
+
+          if (ch == '\\')
+	    *bufptr++ = getc(fp);
+	  else if (ch == '\'')
+	  {
+	    *bufptr = '\0';
+
+	    if (type)
+	      mxmlNewText(type, type->child != NULL, buffer);
+
+	    state = STATE_NONE;
+	  }
+          break;
+
+      case STATE_IDENTIFIER :		/* Inside a keyword or identifier */
+	  if (isalnum(ch) || ch == '_' || ch == '[' || ch == ']' ||
+	      (ch == ',' && (parens > 1 || (type && !enumeration && !function))) ||
+	      ch == ':' || ch == '.' || ch == '~')
+	  {
+	    if (bufptr < (buffer + sizeof(buffer) - 1))
+	      *bufptr++ = ch;
+	  }
+	  else
+	  {
+	    ungetc(ch, fp);
+	    *bufptr = '\0';
+	    state   = STATE_NONE;
+
+#ifdef DEBUG
+            fprintf(stderr, "    braces=%d, type=%p, type->child=%p, buffer=\"%s\"\n",
+	            braces, type, type ? type->child : NULL, buffer);
+#endif /* DEBUG */
+
+            if (!braces)
+	    {
+	      if (!type || !type->child)
+	      {
+		if (!strcmp(tree->value.element.name, "class"))
+		{
+		  if (!strcmp(buffer, "public") ||
+	              !strcmp(buffer, "public:"))
+		  {
+		    scope = "public";
+#ifdef DEBUG
+		    fputs("    scope = public\n", stderr);
+#endif /* DEBUG */
+		    break;
+		  }
+		  else if (!strcmp(buffer, "private") ||
+	                   !strcmp(buffer, "private:"))
+		  {
+		    scope = "private";
+#ifdef DEBUG
+		    fputs("    scope = private\n", stderr);
+#endif /* DEBUG */
+		    break;
+		  }
+		  else if (!strcmp(buffer, "protected") ||
+	                   !strcmp(buffer, "protected:"))
+		  {
+		    scope = "protected";
+#ifdef DEBUG
+		    fputs("    scope = protected\n", stderr);
+#endif /* DEBUG */
+		    break;
+		  }
+		}
+	      }
+
+	      if (!type)
+                type = mxmlNewElement(MXML_NO_PARENT, "type");
+
+#ifdef DEBUG
+              fprintf(stderr, "    function=%p (%s), type->child=%p, ch='%c', parens=%d\n",
+	              function,
+		      function ? mxmlElementGetAttr(function, "name") : "null",
+	              type->child, ch, parens);
+#endif /* DEBUG */
+
+              if (!function && ch == '(')
+	      {
+	        if (type->child &&
+		    !strcmp(type->child->value.text.string, "extern"))
+		{
+		 /*
+		  * Remove external declarations...
+		  */
+
+		  mxmlDelete(type);
+		  type = NULL;
+		  break;
+		}
+
+	        if (type->child &&
+		    !strcmp(type->child->value.text.string, "static") &&
+		    !strcmp(tree->value.element.name, "mxmldoc"))
+		{
+		 /*
+		  * Remove static functions...
+		  */
+
+		  mxmlDelete(type);
+		  type = NULL;
+		  break;
+		}
+
+	        function = mxmlNewElement(MXML_NO_PARENT, "function");
+		if ((bufptr = strchr(buffer, ':')) != NULL && bufptr[1] == ':')
+		{
+		  *bufptr = '\0';
+		  bufptr += 2;
+
+		  if ((fstructclass =
+		           mxmlFindElement(tree, tree, "class", "name", buffer,
+		                           MXML_DESCEND_FIRST)) == NULL)
+		    fstructclass =
+		        mxmlFindElement(tree, tree, "struct", "name", buffer,
+		                        MXML_DESCEND_FIRST);
+		}
+		else
+		  bufptr = buffer;
+
+		mxmlElementSetAttr(function, "name", bufptr);
+
+		if (scope)
+		  mxmlElementSetAttr(function, "scope", scope);
+
+#ifdef DEBUG
+                fprintf(stderr, "function: %s\n", buffer);
+		fprintf(stderr, "    scope = %s\n", scope ? scope : "(null)");
+		fprintf(stderr, "    comment = %p\n", comment);
+		fprintf(stderr, "    child = (%p) %s\n",
+		        comment->child,
+			comment->child ?
+			    comment->child->value.text.string : "(null)");
+		fprintf(stderr, "    last_child = (%p) %s\n",
+		        comment->last_child,
+			comment->last_child ?
+			    comment->last_child->value.text.string : "(null)");
+#endif /* DEBUG */
+
+                if (type->last_child &&
+		    strcmp(type->last_child->value.text.string, "void"))
+		{
+                  returnvalue = mxmlNewElement(function, "returnvalue");
+
+		  mxmlAdd(returnvalue, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, type);
+
+		  description = mxmlNewElement(returnvalue, "description");
+#ifdef DEBUG
+		  fprintf(stderr, "    adding comment %p/%p to returnvalue...\n",
+		          comment->last_child, comment->child);
+#endif /* DEBUG */
+		  update_comment(returnvalue, comment->last_child);
+		  mxmlAdd(description, MXML_ADD_AFTER, MXML_ADD_TO_PARENT,
+		          comment->last_child);
+                }
+		else
+		  mxmlDelete(type);
+
+		description = mxmlNewElement(function, "description");
+#ifdef DEBUG
+		  fprintf(stderr, "    adding comment %p/%p to function...\n",
+		          comment->last_child, comment->child);
+#endif /* DEBUG */
+		update_comment(function, comment->last_child);
+		mxmlAdd(description, MXML_ADD_AFTER, MXML_ADD_TO_PARENT,
+		        comment->last_child);
+
+		type = NULL;
+	      }
+	      else if (function && ((ch == ')' && parens == 1) || ch == ','))
+	      {
+	       /*
+	        * Argument definition...
+		*/
+
+                if (strcmp(buffer, "void"))
+		{
+	          mxmlNewText(type, type->child != NULL &&
+		                    type->last_child->value.text.string[0] != '(' &&
+				    type->last_child->value.text.string[0] != '*',
+			      buffer);
+
+#ifdef DEBUG
+                  fprintf(stderr, "Argument: <<<< %s >>>\n", buffer);
+#endif /* DEBUG */
+
+	          variable = add_variable(function, "argument", type);
+		}
+		else
+		  mxmlDelete(type);
+
+		type = NULL;
+	      }
+              else if (type->child && !function && (ch == ';' || ch == ','))
+	      {
+#ifdef DEBUG
+	        fprintf(stderr, "    got semicolon, typedefnode=%p, structclass=%p\n",
+		        typedefnode, structclass);
+#endif /* DEBUG */
+
+	        if (typedefnode || structclass)
+		{
+#ifdef DEBUG
+                  fprintf(stderr, "Typedef/struct/class: <<<< %s >>>>\n", buffer);
+#endif /* DEBUG */
+
+		  if (typedefnode)
+		  {
+		    mxmlElementSetAttr(typedefnode, "name", buffer);
+
+                    sort_node(tree, typedefnode);
+		  }
+
+		  if (structclass && !mxmlElementGetAttr(structclass, "name"))
+		  {
+#ifdef DEBUG
+		    fprintf(stderr, "setting struct/class name to %s!\n",
+		            type->last_child->value.text.string);
+#endif /* DEBUG */
+		    mxmlElementSetAttr(structclass, "name", buffer);
+
+		    sort_node(tree, structclass);
+		    structclass = NULL;
+		  }
+
+		  if (typedefnode)
+		    mxmlAdd(typedefnode, MXML_ADD_BEFORE, MXML_ADD_TO_PARENT,
+		            type);
+                  else
+		    mxmlDelete(type);
+
+		  type        = NULL;
+		  typedefnode = NULL;
+		}
+		else if (type->child &&
+		         !strcmp(type->child->value.text.string, "typedef"))
+		{
+		 /*
+		  * Simple typedef...
+		  */
+
+#ifdef DEBUG
+                  fprintf(stderr, "Typedef: <<<< %s >>>\n", buffer);
+#endif /* DEBUG */
+
+		  typedefnode = mxmlNewElement(MXML_NO_PARENT, "typedef");
+		  mxmlElementSetAttr(typedefnode, "name", buffer);
+		  mxmlDelete(type->child);
+
+                  sort_node(tree, typedefnode);
+
+                  if (type->child)
+		    type->child->value.text.whitespace = 0;
+
+		  mxmlAdd(typedefnode, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, type);
+		  type = NULL;
+		}
+		else if (!parens)
+		{
+		 /*
+	          * Variable definition...
+		  */
+
+	          if (type->child &&
+		      !strcmp(type->child->value.text.string, "static") &&
+		      !strcmp(tree->value.element.name, "mxmldoc"))
+		  {
+		   /*
+		    * Remove static functions...
+		    */
+
+		    mxmlDelete(type);
+		    type = NULL;
+		    break;
+		  }
+
+	          mxmlNewText(type, type->child != NULL &&
+		                    type->last_child->value.text.string[0] != '(' &&
+				    type->last_child->value.text.string[0] != '*',
+			      buffer);
+
+#ifdef DEBUG
+                  fprintf(stderr, "Variable: <<<< %s >>>>\n", buffer);
+                  fprintf(stderr, "    scope = %s\n", scope ? scope : "(null)");
+#endif /* DEBUG */
+
+	          variable = add_variable(MXML_NO_PARENT, "variable", type);
+		  type     = NULL;
+
+		  sort_node(tree, variable);
+
+		  if (scope)
+		    mxmlElementSetAttr(variable, "scope", scope);
+		}
+              }
+	      else
+              {
+#ifdef DEBUG
+                fprintf(stderr, "Identifier: <<<< %s >>>>\n", buffer);
+#endif /* DEBUG */
+
+	        mxmlNewText(type, type->child != NULL &&
+		                  type->last_child->value.text.string[0] != '(' &&
+				  type->last_child->value.text.string[0] != '*',
+			    buffer);
+	      }
+	    }
+	    else if (enumeration && !isdigit(buffer[0] & 255))
+	    {
+#ifdef DEBUG
+	      fprintf(stderr, "Constant: <<<< %s >>>\n", buffer);
+#endif /* DEBUG */
+
+	      constant = mxmlNewElement(MXML_NO_PARENT, "constant");
+	      mxmlElementSetAttr(constant, "name", buffer);
+	      sort_node(enumeration, constant);
+	    }
+	    else if (type)
+	    {
+	      mxmlDelete(type);
+	      type = NULL;
+	    }
+	  }
+          break;
+    }
+
+#if DEBUG > 1
+    if (state != oldstate)
+    {
+      fprintf(stderr, "    changed states from %s to %s on receipt of character '%c'...\n",
+              states[oldstate], states[state], oldch);
+      fprintf(stderr, "    variable = %p\n", variable);
+      if (type)
+      {
+        fputs("    type =", stderr);
+        for (temp = type->child; temp; temp = temp->next)
+	  fprintf(stderr, " \"%s\"", temp->value.text.string);
+	fputs("\n", stderr);
+      }
+    }
+#endif /* DEBUG > 1 */
+  }
+
+  mxmlDelete(comment);
+
+ /*
+  * All done, return with no errors...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'sort_node()' - Insert a node sorted into a tree.
+ */
+
+static void
+sort_node(mxml_node_t *tree,		/* I - Tree to sort into */
+          mxml_node_t *node)		/* I - Node to add */
+{
+  mxml_node_t	*temp;			/* Current node */
+  const char	*tempname,		/* Name of current node */
+		*nodename,		/* Name of node */
+		*scope;			/* Scope */
+
+
+#if DEBUG > 1
+  fprintf(stderr, "    sort_node(tree=%p, node=%p)\n", tree, node);
+#endif /* DEBUG > 1 */
+
+ /*
+  * Range check input...
+  */
+
+  if (!tree || !node || node->parent == tree)
+    return;
+
+ /*
+  * Get the node name...
+  */
+
+  if ((nodename = mxmlElementGetAttr(node, "name")) == NULL)
+    return;
+
+  if (nodename[0] == '_')
+    return;				/* Hide private names */
+
+#if DEBUG > 1
+  fprintf(stderr, "        nodename=%p (\"%s\")\n", nodename, nodename);
+#endif /* DEBUG > 1 */
+
+ /*
+  * Delete any existing definition at this level, if one exists...
+  */
+
+  if ((temp = mxmlFindElement(tree, tree, node->value.element.name,
+                              "name", nodename, MXML_DESCEND_FIRST)) != NULL)
+  {
+   /*
+    * Copy the scope if needed...
+    */
+
+    if ((scope = mxmlElementGetAttr(temp, "scope")) != NULL &&
+        mxmlElementGetAttr(node, "scope") == NULL)
+    {
+#ifdef DEBUG
+      fprintf(stderr, "    copying scope %s for %s\n", scope, nodename);
+#endif /* DEBUG */
+
+      mxmlElementSetAttr(node, "scope", scope);
+    }
+
+    mxmlDelete(temp);
+  }
+
+ /*
+  * Add the node into the tree at the proper place...
+  */
+
+  for (temp = tree->child; temp; temp = temp->next)
+  {
+#if DEBUG > 1
+    fprintf(stderr, "        temp=%p\n", temp);
+#endif /* DEBUG > 1 */
+
+    if ((tempname = mxmlElementGetAttr(temp, "name")) == NULL)
+      continue;
+
+#if DEBUG > 1
+    fprintf(stderr, "        tempname=%p (\"%s\")\n", tempname, tempname);
+#endif /* DEBUG > 1 */
+
+    if (strcmp(nodename, tempname) < 0)
+      break;
+  }
+
+  if (temp)
+    mxmlAdd(tree, MXML_ADD_BEFORE, temp, node);
+  else
+    mxmlAdd(tree, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, node);
+}
+
+
+/*
+ * 'update_comment()' - Update a comment node.
+ */
+
+static void
+update_comment(mxml_node_t *parent,	/* I - Parent node */
+               mxml_node_t *comment)	/* I - Comment node */
+{
+  char	*ptr;				/* Pointer into comment */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "update_comment(parent=%p, comment=%p)\n",
+          parent, comment);
+#endif /* DEBUG */
+
+ /*
+  * Range check the input...
+  */
+
+  if (!parent || !comment)
+    return;
+ 
+ /*
+  * Update the comment...
+  */
+
+  ptr = comment->value.text.string;
+
+  if (*ptr == '\'')
+  {
+   /*
+    * Convert "'name()' - description" to "description".
+    */
+
+    for (ptr ++; *ptr && *ptr != '\''; ptr ++);
+
+    if (*ptr == '\'')
+    {
+      ptr ++;
+      while (isspace(*ptr & 255))
+        ptr ++;
+
+      if (*ptr == '-')
+        ptr ++;
+
+      while (isspace(*ptr & 255))
+        ptr ++;
+
+      safe_strcpy(comment->value.text.string, ptr);
+    }
+  }
+  else if (!strncmp(ptr, "I ", 2) || !strncmp(ptr, "O ", 2) ||
+           !strncmp(ptr, "IO ", 3))
+  {
+   /*
+    * 'Convert "I - description", "IO - description", or "O - description"
+    * to description + directory attribute.
+    */
+
+    ptr = strchr(ptr, ' ');
+    *ptr++ = '\0';
+
+    if (!strcmp(parent->value.element.name, "argument"))
+      mxmlElementSetAttr(parent, "direction", comment->value.text.string);
+
+    while (isspace(*ptr & 255))
+      ptr ++;
+
+    if (*ptr == '-')
+      ptr ++;
+
+    while (isspace(*ptr & 255))
+      ptr ++;
+
+    safe_strcpy(comment->value.text.string, ptr);
+  }
+
+ /*
+  * Eliminate leading and trailing *'s...
+  */
+
+  for (ptr = comment->value.text.string; *ptr == '*'; ptr ++);
+  for (; isspace(*ptr & 255); ptr ++);
+  if (ptr > comment->value.text.string)
+    safe_strcpy(comment->value.text.string, ptr);
+
+  for (ptr = comment->value.text.string + strlen(comment->value.text.string) - 1;
+       ptr > comment->value.text.string && *ptr == '*';
+       ptr --)
+    *ptr = '\0';
+  for (; ptr > comment->value.text.string && isspace(*ptr & 255); ptr --)
+    *ptr = '\0';
+
+#ifdef DEBUG
+  fprintf(stderr, "    updated comment = %s\n", comment->value.text.string);
+#endif /* DEBUG */
+}
+
+
+/*
+ * 'usage()' - Show program usage...
+ */
+
+static void
+usage(const char *option)		/* I - Unknown option */
+{
+  if (option)
+    printf("mxmldoc: Bad option \"%s\"!\n\n", option);
+
+  puts("Usage: mxmldoc [options] [filename.xml] [source files] >filename.html");
+  puts("Options:");
+  puts("    --css filename.css         Set CSS stylesheet file");
+  puts("    --docset bundleid.docset   Generate documentation set");
+  puts("    --docversion version       Set documentation version");
+  puts("    --feedname name            Set documentation set feed name");
+  puts("    --feedurl url              Set documentation set feed URL");
+  puts("    --footer footerfile        Set footer file");
+  puts("    --framed basename          Generate framed HTML to basename*.html");
+  puts("    --header headerfile        Set header file");
+  puts("    --intro introfile          Set introduction file");
+  puts("    --man name                 Generate man page");
+  puts("    --no-output                Do no generate documentation file");
+  puts("    --section section          Set section name");
+  puts("    --title title              Set documentation title");
+  puts("    --tokens path              Generate Xcode docset Tokens.xml file");
+
+  exit(1);
+}
+
+
+/*
+ * 'write_description()' - Write the description text.
+ */
+
+static void
+write_description(
+    FILE        *out,			/* I - Output file */
+    mxml_node_t *description,		/* I - Description node */
+    const char  *element,		/* I - HTML element, if any */
+    int         summary)		/* I - Show summary */
+{
+  char	text[10240],			/* Text for description */
+        *start,				/* Start of code/link */
+	*ptr;				/* Pointer into text */
+  int	col;				/* Current column */
+
+
+  if (!description)
+    return;
+
+  get_text(description, text, sizeof(text));
+
+  ptr = strstr(text, "\n\n");
+
+  if (summary)
+  {
+    if (ptr)
+      *ptr = '\0';
+
+    ptr = text;
+  }
+  else if (!ptr || !ptr[2])
+    return;
+  else
+    ptr += 2;
+
+  if (element && *element)
+    fprintf(out, "<%s class=\"%s\">", element,
+            summary ? "description" : "discussion");
+  else if (!summary)
+    fputs(".PP\n", out);
+
+  for (col = 0; *ptr; ptr ++)
+  {
+    if (*ptr == '@' &&
+        (!strncmp(ptr + 1, "deprecated@", 11) ||
+         !strncmp(ptr + 1, "since ", 6)))
+    {
+      ptr ++;
+      while (*ptr && *ptr != '@')
+        ptr ++;
+
+      if (!*ptr)
+        return;
+    }
+    else if (!strncmp(ptr, "@code ", 6))
+    {
+      for (ptr += 6; isspace(*ptr & 255); ptr ++);
+
+      for (start = ptr, ptr ++; *ptr && *ptr != '@'; ptr ++);
+
+      if (*ptr)
+        *ptr = '\0';
+      else
+        ptr --;
+
+      if (element && *element)
+        fprintf(out, "<code>%s</code>", start);
+      else if (element)
+        fputs(start, out);
+      else
+        fprintf(out, "\\fB%s\\fR", start);
+    }
+    else if (!strncmp(ptr, "@link ", 6))
+    {
+      for (ptr += 6; isspace(*ptr & 255); ptr ++);
+
+      for (start = ptr, ptr ++; *ptr && *ptr != '@'; ptr ++);
+
+      if (*ptr)
+        *ptr = '\0';
+      else
+        ptr --;
+
+      if (element && *element)
+        fprintf(out, "<a href=\"#%s\"><code>%s</code></a>", start, start);
+      else if (element)
+        fputs(start, out);
+      else
+        fprintf(out, "\\fI%s\\fR", start);
+    }
+    else if (element)
+    {
+      if (*ptr == '&')
+        fputs("&amp;", out);
+      else if (*ptr == '<')
+        fputs("&lt;", out);
+      else if (*ptr == '>')
+        fputs("&gt;", out);
+      else if (*ptr == '\"')
+        fputs("&quot;", out);
+      else if (*ptr & 128)
+      {
+       /*
+        * Convert UTF-8 to Unicode constant...
+        */
+
+        int	ch;			/* Unicode character */
+
+
+        ch = *ptr & 255;
+
+        if ((ch & 0xe0) == 0xc0)
+        {
+          ch = ((ch & 0x1f) << 6) | (ptr[1] & 0x3f);
+	  ptr ++;
+        }
+        else if ((ch & 0xf0) == 0xe0)
+        {
+          ch = ((((ch * 0x0f) << 6) | (ptr[1] & 0x3f)) << 6) | (ptr[2] & 0x3f);
+	  ptr += 2;
+        }
+
+        if (ch == 0xa0)
+        {
+         /*
+          * Handle non-breaking space as-is...
+	  */
+
+          fputs("&nbsp;", out);
+        }
+        else
+          fprintf(out, "&#x%x;", ch);
+      }
+      else if (*ptr == '\n' && ptr[1] == '\n' && ptr[2] && ptr[2] != '@')
+      {
+        fputs("<br>\n<br>\n", out);
+        ptr ++;
+      }
+      else
+        putc(*ptr, out);
+    }
+    else if (*ptr == '\n' && ptr[1] == '\n' && ptr[2] && ptr[2] != '@')
+    {
+      fputs("\n.PP\n", out);
+      ptr ++;
+    }
+    else
+    {
+      if (*ptr == '\\' || (*ptr == '.' && col == 0))
+        putc('\\', out);
+
+      putc(*ptr, out);
+
+      if (*ptr == '\n')
+        col = 0;
+      else
+        col ++;
+    }
+  }
+
+  if (element && *element)
+    fprintf(out, "</%s>\n", element);
+  else if (!element)
+    putc('\n', out);
+}
+
+
+/*
+ * 'write_element()' - Write an element's text nodes.
+ */
+
+static void
+write_element(FILE        *out,		/* I - Output file */
+              mxml_node_t *doc,		/* I - Document tree */
+              mxml_node_t *element,	/* I - Element to write */
+              int         mode)		/* I - Output mode */
+{
+  mxml_node_t	*node;			/* Current node */
+
+
+  if (!element)
+    return;
+
+  for (node = element->child;
+       node;
+       node = mxmlWalkNext(node, element, MXML_NO_DESCEND))
+    if (node->type == MXML_TEXT)
+    {
+      if (node->value.text.whitespace)
+	putc(' ', out);
+
+      if (mode == OUTPUT_HTML &&
+          (mxmlFindElement(doc, doc, "class", "name", node->value.text.string,
+                           MXML_DESCEND) ||
+	   mxmlFindElement(doc, doc, "enumeration", "name",
+	                   node->value.text.string, MXML_DESCEND) ||
+	   mxmlFindElement(doc, doc, "struct", "name", node->value.text.string,
+                           MXML_DESCEND) ||
+	   mxmlFindElement(doc, doc, "typedef", "name", node->value.text.string,
+                           MXML_DESCEND) ||
+	   mxmlFindElement(doc, doc, "union", "name", node->value.text.string,
+                           MXML_DESCEND)))
+      {
+        fputs("<a href=\"#", out);
+        write_string(out, node->value.text.string, mode);
+	fputs("\">", out);
+        write_string(out, node->value.text.string, mode);
+	fputs("</a>", out);
+      }
+      else
+        write_string(out, node->value.text.string, mode);
+    }
+
+  if (!strcmp(element->value.element.name, "type") &&
+      element->last_child->value.text.string[0] != '*')
+    putc(' ', out);
+}
+
+
+/*
+ * 'write_file()' - Copy a file to the output.
+ */
+
+static void
+write_file(FILE       *out,		/* I - Output file */
+           const char *file)		/* I - File to copy */
+{
+  FILE		*fp;			/* Copy file */
+  char		line[8192];		/* Line from file */
+
+
+  if ((fp = fopen(file, "r")) == NULL)
+  {
+    fprintf(stderr, "mxmldoc: Unable to open \"%s\": %s\n", file,
+            strerror(errno));
+    return;
+  }
+
+  while (fgets(line, sizeof(line), fp))
+    fputs(line, out);
+
+  fclose(fp);
+}
+
+
+/*
+ * 'write_function()' - Write documentation for a function.
+ */
+
+static void
+write_function(FILE        *out,	/* I - Output file */
+               mxml_node_t *doc,	/* I - Document */
+               mxml_node_t *function,	/* I - Function */
+	       int         level)	/* I - Base heading level */
+{
+  mxml_node_t	*arg,			/* Current argument */
+		*adesc,			/* Description of argument */
+		*description,		/* Description of function */
+		*type,			/* Type for argument */
+		*node;			/* Node in description */
+  const char	*name,			/* Name of function/type */
+		*defval;		/* Default value */
+  char		prefix;			/* Prefix character */
+  char		*sep;			/* Newline separator */
+
+
+  name        = mxmlElementGetAttr(function, "name");
+  description = mxmlFindElement(function, function, "description", NULL,
+				NULL, MXML_DESCEND_FIRST);
+
+  fprintf(out, "<h%d class=\"%s\">%s<a name=\"%s\">%s</a></h%d>\n",
+	  level, level == 3 ? "function" : "method",
+	  get_comment_info(description), name, name, level);
+
+  if (description)
+    write_description(out, description, "p", 1);
+
+  fputs("<p class=\"code\">\n", out);
+
+  arg = mxmlFindElement(function, function, "returnvalue", NULL,
+			NULL, MXML_DESCEND_FIRST);
+
+  if (arg)
+    write_element(out, doc, mxmlFindElement(arg, arg, "type", NULL,
+					    NULL, MXML_DESCEND_FIRST),
+		  OUTPUT_HTML);
+  else
+    fputs("void ", out);
+
+  fprintf(out, "%s ", name);
+  for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+			     MXML_DESCEND_FIRST), prefix = '(';
+       arg;
+       arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+			     MXML_NO_DESCEND), prefix = ',')
+  {
+    type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+			   MXML_DESCEND_FIRST);
+
+    fprintf(out, "%c<br>\n&nbsp;&nbsp;&nbsp;&nbsp;", prefix);
+    if (type->child)
+      write_element(out, doc, type, OUTPUT_HTML);
+
+    fputs(mxmlElementGetAttr(arg, "name"), out);
+    if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+      fprintf(out, " %s", defval);
+  }
+
+  if (prefix == '(')
+    fputs("(void);</p>\n", out);
+  else
+  {
+    fprintf(out,
+            "<br>\n);</p>\n"
+	    "<h%d class=\"parameters\">Parameters</h%d>\n"
+	    "<dl>\n", level + 1, level + 1);
+
+    for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+			       MXML_DESCEND_FIRST);
+	 arg;
+	 arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+			       MXML_NO_DESCEND))
+    {
+      fprintf(out, "<dt>%s</dt>\n", mxmlElementGetAttr(arg, "name"));
+
+      adesc = mxmlFindElement(arg, arg, "description", NULL, NULL,
+			      MXML_DESCEND_FIRST);
+
+      write_description(out, adesc, "dd", 1);
+      write_description(out, adesc, "dd", 0);
+    }
+
+    fputs("</dl>\n", out);
+  }
+
+  arg = mxmlFindElement(function, function, "returnvalue", NULL,
+			NULL, MXML_DESCEND_FIRST);
+
+  if (arg)
+  {
+    fprintf(out, "<h%d class=\"returnvalue\">Return Value</h%d>\n", level + 1,
+            level + 1);
+
+    adesc = mxmlFindElement(arg, arg, "description", NULL, NULL,
+			    MXML_DESCEND_FIRST);
+
+    write_description(out, adesc, "p", 1);
+    write_description(out, adesc, "p", 0);
+  }
+
+  if (description)
+  {
+    for (node = description->child; node; node = node->next)
+      if (node->value.text.string &&
+	  (sep = strstr(node->value.text.string, "\n\n")) != NULL)
+      {
+	sep += 2;
+	if (*sep && strncmp(sep, "@since ", 7) &&
+	    strncmp(sep, "@deprecated@", 12))
+	  break;
+      }
+
+    if (node)
+    {
+      fprintf(out, "<h%d class=\"discussion\">Discussion</h%d>\n", level + 1,
+	      level + 1);
+      write_description(out, description, "p", 0);
+    }
+  }
+}
+
+
+/*
+ * 'write_html()' - Write HTML documentation.
+ */
+
+static void
+write_html(const char  *section,	/* I - Section */
+	   const char  *title,		/* I - Title */
+	   const char  *footerfile,	/* I - Footer file */
+	   const char  *headerfile,	/* I - Header file */
+	   const char  *introfile,	/* I - Intro file */
+	   const char  *cssfile,	/* I - Stylesheet file */
+	   const char  *framefile,	/* I - Framed HTML basename */
+	   const char  *docset,		/* I - Documentation set directory */
+	   const char  *docversion,	/* I - Documentation set version */
+	   const char  *feedname,	/* I - Feed name for doc set */
+	   const char  *feedurl,	/* I - Feed URL for doc set */
+	   mxml_node_t *doc)		/* I - XML documentation */
+{
+  FILE		*out;			/* Output file */
+  mxml_node_t	*function,		/* Current function */
+		*scut,			/* Struct/class/union/typedef */
+		*arg,			/* Current argument */
+		*description,		/* Description of function/var */
+		*type;			/* Type for argument */
+  const char	*name,			/* Name of function/type */
+		*defval,		/* Default value */
+		*basename;		/* Base filename for framed output */
+  char		filename[1024];		/* Current output filename */
+
+
+  if (framefile)
+  {
+   /*
+    * Get the basename of the frame file...
+    */
+
+    if ((basename = strrchr(framefile, '/')) != NULL)
+      basename ++;
+    else
+      basename = framefile;
+
+    if (strstr(basename, ".html"))
+      fputs("mxmldoc: Frame base name should not contain .html extension!\n",
+            stderr);
+
+   /*
+    * Create the container HTML file for the frames...
+    */
+
+    snprintf(filename, sizeof(filename), "%s.html", framefile);
+
+    if ((out = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+    fputs("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" "
+          "\"http://www.w3.org/TR/html4/frameset.dtd\">\n"
+	  "<html>\n"
+	  "<head>\n"
+	  "<title>", out);
+    write_string(out, title, OUTPUT_HTML);
+    fputs("</title>\n", out);
+
+    if (section)
+      fprintf(out, "<meta name=\"keywords\" content=\"%s\">\n", section);
+
+    fputs("<meta name=\"creator\" content=\"" MXML_VERSION "\">\n"
+          "<frameset cols=\"250,*\">\n", out);
+    fprintf(out, "<frame src=\"%s-toc.html\">\n", basename);
+    fprintf(out, "<frame name=\"body\" src=\"%s-body.html\">\n", basename);
+    fputs("</frameset>\n"
+          "<noframes>\n"
+	  "<h1>", out);
+    write_string(out, title, OUTPUT_HTML);
+    fprintf(out,
+            "</h1>\n"
+            "<ul>\n"
+	    "\t<li><a href=\"%s-toc.html\">Table of Contents</a></li>\n"
+	    "\t<li><a href=\"%s-body.html\">Body</a></li>\n"
+	    "</ul>\n", basename, basename);
+    fputs("</noframes>\n"
+          "</html>\n", out);
+    fclose(out);
+
+   /*
+    * Write the table-of-contents file...
+    */
+
+    snprintf(filename, sizeof(filename), "%s-toc.html", framefile);
+
+    if ((out = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+    write_html_head(out, section, title, cssfile);
+
+    snprintf(filename, sizeof(filename), "%s-body.html", basename);
+
+    fputs("<div class=\"contents\">\n", out);
+    fprintf(out, "<h1 class=\"title\"><a href=\"%s\" target=\"body\">",
+            filename);
+    write_string(out, title, OUTPUT_HTML);
+    fputs("</a></h1>\n", out);
+
+    write_toc(out, doc, introfile, filename, 0);
+
+    fputs("</div>\n"
+          "</body>\n"
+          "</html>\n", out);
+    fclose(out);
+
+   /*
+    * Finally, open the body file...
+    */
+
+    snprintf(filename, sizeof(filename), "%s-body.html", framefile);
+
+    if ((out = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+  }
+  else if (docset)
+  {
+   /*
+    * Create an Xcode documentation set - start by removing any existing
+    * output directory...
+    */
+
+#ifdef __APPLE__
+    const char	*id;			/* Identifier */
+
+
+    if (!access(docset, 0) && !remove_directory(docset))
+      return;
+
+   /*
+    * Then make the Apple standard bundle directory structure...
+    */
+
+    if (mkdir(docset, 0755))
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", docset,
+              strerror(errno));
+      return;
+    }
+
+    snprintf(filename, sizeof(filename), "%s/Contents", docset);
+    if (mkdir(filename, 0755))
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+    snprintf(filename, sizeof(filename), "%s/Contents/Resources", docset);
+    if (mkdir(filename, 0755))
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+    snprintf(filename, sizeof(filename), "%s/Contents/Resources/Documentation",
+             docset);
+    if (mkdir(filename, 0755))
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+   /*
+    * The Info.plist file, which describes the documentation set...
+    */
+
+    if ((id = strrchr(docset, '/')) != NULL)
+      id ++;
+    else
+      id = docset;
+
+    snprintf(filename, sizeof(filename), "%s/Contents/Info.plist", docset);
+    if ((out = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+    fputs("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+          "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n"
+          "<plist version=\"1.0\">\n"
+          "<dict>\n"
+	  "\t<key>CFBundleIdentifier</key>\n"
+	  "\t<string>", out);
+    write_string(out, id, OUTPUT_HTML);
+    fputs("</string>\n"
+          "\t<key>CFBundleName</key>\n"
+	  "\t<string>", out);
+    write_string(out, title, OUTPUT_HTML);
+    fputs("</string>\n"
+          "\t<key>CFBundleVersion</key>\n"
+	  "\t<string>", out);
+    write_string(out, docversion ? docversion : "0.0", OUTPUT_HTML);
+    fputs("</string>\n", out);
+
+    if (feedname)
+    {
+      fputs("\t<key>DocSetFeedName</key>\n"
+	    "\t<string>", out);
+      write_string(out, feedname ? feedname : title, OUTPUT_HTML);
+      fputs("</string>\n", out);
+    }
+
+    if (feedurl)
+    {
+      fputs("\t<key>DocSetFeedURL</key>\n"
+	    "\t<string>", out);
+      write_string(out, feedurl, OUTPUT_HTML);
+      fputs("</string>\n", out);
+    }
+
+    fputs("</dict>\n"
+          "</plist>\n", out);
+
+    fclose(out);
+
+   /*
+    * Next the Nodes.xml file...
+    */
+
+    snprintf(filename, sizeof(filename), "%s/Contents/Resources/Nodes.xml",
+             docset);
+    if ((out = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+    fputs("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+          "<DocSetNodes version=\"1.0\">\n"
+	  "<TOC>\n"
+	  "<Node id=\"0\">\n"
+	  "<Name>", out);
+    write_string(out, title, OUTPUT_HTML);
+    fputs("</Name>\n"
+          "<Path>Documentation/index.html</Path>\n"
+	  "<Subnodes>\n", out);
+
+    write_toc(out, doc, introfile, NULL, 1);
+
+    fputs("</Subnodes>\n"
+          "</Node>\n"
+          "</TOC>\n"
+          "</DocSetNodes>\n", out);
+
+    fclose(out);
+
+   /*
+    * Then the Tokens.xml file...
+    */
+
+    snprintf(filename, sizeof(filename), "%s/Contents/Resources/Tokens.xml",
+             docset);
+    if ((out = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+    fputs("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+          "<Tokens version=\"1.0\">\n", out);
+
+    write_tokens(out, doc, "index.html");
+
+    fputs("</Tokens>\n", out);
+
+    fclose(out);
+
+   /*
+    * Finally the HTML file...
+    */
+
+    snprintf(filename, sizeof(filename),
+             "%s/Contents/Resources/Documentation/index.html",
+             docset);
+    if ((out = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "mxmldoc: Unable to create \"%s\": %s\n", filename,
+              strerror(errno));
+      return;
+    }
+
+#else
+    fputs("mxmldoc: Xcode documentation sets can only be created on "
+          "Mac OS X.\n", stderr);
+    return;
+#endif /* __APPLE__ */
+  }
+  else
+    out = stdout;
+
+ /*
+  * Standard header...
+  */
+
+  write_html_head(out, section, title, cssfile);
+
+  fputs("<div class='body'>\n", out);
+
+ /*
+  * Header...
+  */
+
+  if (headerfile)
+  {
+   /*
+    * Use custom header...
+    */
+
+    write_file(out, headerfile);
+  }
+  else
+  {
+   /*
+    * Use standard header...
+    */
+
+    fputs("<h1 class=\"title\">", out);
+    write_string(out, title, OUTPUT_HTML);
+    fputs("</h1>\n", out);
+  }
+
+ /*
+  * Table of contents...
+  */
+
+  if (!framefile)
+    write_toc(out, doc, introfile, NULL, 0);
+
+ /*
+  * Intro...
+  */
+
+  if (introfile)
+    write_file(out, introfile);
+
+ /*
+  * List of classes...
+  */
+
+  if ((scut = find_public(doc, doc, "class")) != NULL)
+  {
+    fputs("<h2 class=\"title\"><a name=\"CLASSES\">Classes</a></h2>\n", out);
+
+    while (scut)
+    {
+      write_scu(out, doc, scut);
+
+      scut = find_public(scut, doc, "class");
+    }
+  }
+
+ /*
+  * List of functions...
+  */
+
+  if ((function = find_public(doc, doc, "function")) != NULL)
+  {
+    fputs("<h2 class=\"title\"><a name=\"FUNCTIONS\">Functions</a></h2>\n", out);
+
+    while (function)
+    {
+      write_function(out, doc, function, 3);
+
+      function = find_public(function, doc, "function");
+    }
+  }
+
+ /*
+  * List of types...
+  */
+
+  if ((scut = find_public(doc, doc, "typedef")) != NULL)
+  {
+    fputs("<h2 class=\"title\"><a name=\"TYPES\">Data Types</a></h2>\n", out);
+
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      fprintf(out, "<h3 class=\"typedef\">%s<a name=\"%s\">%s</a></h3>\n",
+	      get_comment_info(description), name, name);
+
+      if (description)
+	write_description(out, description, "p", 1);
+
+      fputs("<p class=\"code\">\n"
+	    "typedef ", out);
+
+      type = mxmlFindElement(scut, scut, "type", NULL, NULL,
+                             MXML_DESCEND_FIRST);
+
+      for (type = type->child; type; type = type->next)
+        if (!strcmp(type->value.text.string, "("))
+	  break;
+	else
+	{
+	  if (type->value.text.whitespace)
+	    putc(' ', out);
+
+	  if (mxmlFindElement(doc, doc, "class", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "enumeration", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "struct", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "typedef", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "union", "name",
+	                      type->value.text.string, MXML_DESCEND))
+	  {
+            fputs("<a href=\"#", out);
+            write_string(out, type->value.text.string, OUTPUT_HTML);
+	    fputs("\">", out);
+            write_string(out, type->value.text.string, OUTPUT_HTML);
+	    fputs("</a>", out);
+	  }
+	  else
+            write_string(out, type->value.text.string, OUTPUT_HTML);
+        }
+
+      if (type)
+      {
+       /*
+        * Output function type...
+	*/
+
+        if (type->prev && type->prev->value.text.string[0] != '*')
+	  putc(' ', out);
+
+        fprintf(out, "(*%s", name);
+
+	for (type = type->next->next; type; type = type->next)
+	{
+	  if (type->value.text.whitespace)
+	    putc(' ', out);
+
+	  if (mxmlFindElement(doc, doc, "class", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "enumeration", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "struct", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "typedef", "name",
+	                      type->value.text.string, MXML_DESCEND) ||
+	      mxmlFindElement(doc, doc, "union", "name",
+	                      type->value.text.string, MXML_DESCEND))
+	  {
+            fputs("<a href=\"#", out);
+            write_string(out, type->value.text.string, OUTPUT_HTML);
+	    fputs("\">", out);
+            write_string(out, type->value.text.string, OUTPUT_HTML);
+	    fputs("</a>", out);
+	  }
+	  else
+            write_string(out, type->value.text.string, OUTPUT_HTML);
+        }
+
+        fputs(";\n", out);
+      }
+      else
+      {
+	type = mxmlFindElement(scut, scut, "type", NULL, NULL,
+			       MXML_DESCEND_FIRST);
+        if (type->last_child->value.text.string[0] != '*')
+	  putc(' ', out);
+
+	fprintf(out, "%s;\n", name);
+      }
+
+      fputs("</p>\n", out);
+
+      scut = find_public(scut, doc, "typedef");
+    }
+  }
+
+ /*
+  * List of structures...
+  */
+
+  if ((scut = find_public(doc, doc, "struct")) != NULL)
+  {
+    fputs("<h2 class=\"title\"><a name=\"STRUCTURES\">Structures</a></h2>\n",
+          out);
+
+    while (scut)
+    {
+      write_scu(out, doc, scut);
+
+      scut = find_public(scut, doc, "struct");
+    }
+  }
+
+ /*
+  * List of unions...
+  */
+
+  if ((scut = find_public(doc, doc, "union")) != NULL)
+  {
+    fputs("<h2 class=\"title\"><a name=\"UNIONS\">Unions</a></h2>\n", out);
+
+    while (scut)
+    {
+      write_scu(out, doc, scut);
+
+      scut = find_public(scut, doc, "union");
+    }
+  }
+
+ /*
+  * Variables...
+  */
+
+  if ((arg = find_public(doc, doc, "variable")) != NULL)
+  {
+    fputs("<h2 class=\"title\"><a name=\"VARIABLES\">Variables</a></h2>\n",
+          out);
+
+    while (arg)
+    {
+      name        = mxmlElementGetAttr(arg, "name");
+      description = mxmlFindElement(arg, arg, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      fprintf(out, "<h3 class=\"variable\">%s<a name=\"%s\">%s</a></h3>\n",
+	      get_comment_info(description), name, name);
+
+      if (description)
+	write_description(out, description, "p", 1);
+
+      fputs("<p class=\"code\">", out);
+
+      write_element(out, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                              NULL, MXML_DESCEND_FIRST),
+                    OUTPUT_HTML);
+      fputs(mxmlElementGetAttr(arg, "name"), out);
+      if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	fprintf(out, " %s", defval);
+      fputs(";</p>\n", out);
+
+      arg = find_public(arg, doc, "variable");
+    }
+  }
+
+ /*
+  * List of enumerations...
+  */
+
+  if ((scut = find_public(doc, doc, "enumeration")) != NULL)
+  {
+    fputs("<h2 class=\"title\"><a name=\"ENUMERATIONS\">Constants</a></h2>\n",
+          out);
+
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      fprintf(out, "<h3 class=\"enumeration\">%s<a name=\"%s\">%s</a></h3>\n",
+              get_comment_info(description), name, name);
+
+      if (description)
+	write_description(out, description, "p", 1);
+
+      fputs("<h4 class=\"constants\">Constants</h4>\n"
+            "<dl>\n", out);
+
+      for (arg = mxmlFindElement(scut, scut, "constant", NULL, NULL,
+                        	 MXML_DESCEND_FIRST);
+	   arg;
+	   arg = mxmlFindElement(arg, scut, "constant", NULL, NULL,
+                        	 MXML_NO_DESCEND))
+      {
+	description = mxmlFindElement(arg, arg, "description", NULL,
+                                      NULL, MXML_DESCEND_FIRST);
+	fprintf(out, "<dt>%s %s</dt>\n",
+	        mxmlElementGetAttr(arg, "name"), get_comment_info(description));
+
+	write_description(out, description, "dd", 1);
+	write_description(out, description, "dd", 0);
+      }
+
+      fputs("</dl>\n", out);
+
+      scut = find_public(scut, doc, "enumeration");
+    }
+  }
+
+ /*
+  * Footer...
+  */
+
+  if (footerfile)
+  {
+   /*
+    * Use custom footer...
+    */
+
+    write_file(out, footerfile);
+  }
+
+  fputs("</div>\n"
+        "</body>\n"
+        "</html>\n", out);
+
+ /*
+  * Close output file as needed...
+  */
+
+  if (out != stdout)
+    fclose(out);
+
+#ifdef __APPLE__
+ /*
+  * When generating document sets, run the docsetutil program to index it...
+  */
+
+  if (docset)
+  {
+    const char	*args[4];		/* Argument array */
+    pid_t	pid;			/* Process ID */
+    int		status;			/* Exit status */
+
+
+    args[0] = "/Developer/usr/bin/docsetutil";
+    args[1] = "index";
+    args[2] = docset;
+    args[3] = NULL;
+
+    if (posix_spawn(&pid, args[0], NULL, NULL, (char **)args, environ))
+    {
+      fprintf(stderr, "mxmldoc: Unable to index documentation set \"%s\": %s\n",
+              docset, strerror(errno));
+    }
+    else
+    {
+      while (wait(&status) != pid);
+
+      if (status)
+      {
+        if (WIFEXITED(status))
+	  fprintf(stderr, "mxmldoc: docsetutil exited with status %d\n",
+		  WEXITSTATUS(status));
+        else
+	  fprintf(stderr, "mxmldoc: docsetutil crashed with signal %d\n",
+		  WTERMSIG(status));
+      }
+      else
+      {
+       /*
+        * Remove unneeded temporary XML files...
+	*/
+
+	snprintf(filename, sizeof(filename), "%s/Contents/Resources/Nodes.xml",
+		 docset);
+        unlink(filename);
+
+	snprintf(filename, sizeof(filename), "%s/Contents/Resources/Tokens.xml",
+		 docset);
+        unlink(filename);
+      }
+    }
+  }
+#endif /* __APPLE__ */
+}
+
+
+/*
+ * 'write_html_head()' - Write the standard HTML header.
+ */
+
+static void
+write_html_head(FILE       *out,	/* I - Output file */
+                const char *section,	/* I - Section */
+                const char *title,	/* I - Title */
+		const char *cssfile)	/* I - Stylesheet */
+{
+  fputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" "
+        "\"http://www.w3.org/TR/html4/loose.dtd\">\n"
+        "<html>\n", out);
+
+  if (section)
+    fprintf(out, "<!-- SECTION: %s -->\n", section);
+
+  fputs("<head>\n"
+        "<title>", out);
+  write_string(out, title, OUTPUT_HTML);
+  fputs("</title>\n", out);
+
+  if (section)
+    fprintf(out, "<meta name=\"keywords\" content=\"%s\">\n", section);
+
+  fputs("<meta name=\"creator\" content=\"" MXML_VERSION "\">\n"
+        "<style type=\"text/css\"><!--\n", out);
+
+  if (cssfile)
+  {
+   /*
+    * Use custom stylesheet file...
+    */
+
+    write_file(out, cssfile);
+  }
+  else
+  {
+   /*
+    * Use standard stylesheet...
+    */
+
+    fputs("body, p, h1, h2, h3, h4 {\n"
+	  "  font-family: lucida grande, geneva, helvetica, arial, sans-serif;\n"
+	  "}\n"
+	  "div.body h1 {\n"
+	  "  font-size: 250%;\n"
+	  "  font-weight: bold;\n"
+	  "  margin: 0;\n"
+	  "}\n"
+	  "div.body h2 {\n"
+	  "  font-size: 250%;\n"
+	  "  margin-top: 1.5em;\n"
+	  "}\n"
+	  "div.body h3 {\n"
+	  "  font-size: 150%;\n"
+	  "  margin-bottom: 0.5em;\n"
+	  "  margin-top: 1.5em;\n"
+	  "}\n"
+	  "div.body h4 {\n"
+	  "  font-size: 110%;\n"
+	  "  margin-bottom: 0.5em;\n"
+	  "  margin-top: 1.5em;\n"
+	  "}\n"
+	  "div.body h5 {\n"
+	  "  font-size: 100%;\n"
+	  "  margin-bottom: 0.5em;\n"
+	  "  margin-top: 1.5em;\n"
+	  "}\n"
+	  "div.contents {\n"
+	  "  background: #e8e8e8;\n"
+	  "  border: solid thin black;\n"
+	  "  padding: 10px;\n"
+	  "}\n"
+	  "div.contents h1 {\n"
+	  "  font-size: 110%;\n"
+	  "}\n"
+	  "div.contents h2 {\n"
+	  "  font-size: 100%;\n"
+	  "}\n"
+	  "div.contents ul.contents {\n"
+	  "  font-size: 80%;\n"
+	  "}\n"
+	  ".class {\n"
+	  "  border-bottom: solid 2px gray;\n"
+	  "}\n"
+	  ".constants {\n"
+	  "}\n"
+	  ".description {\n"
+	  "  margin-top: 0.5em;\n"
+	  "}\n"
+	  ".discussion {\n"
+	  "}\n"
+	  ".enumeration {\n"
+	  "  border-bottom: solid 2px gray;\n"
+	  "}\n"
+	  ".function {\n"
+	  "  border-bottom: solid 2px gray;\n"
+	  "  margin-bottom: 0;\n"
+	  "}\n"
+	  ".members {\n"
+	  "}\n"
+	  ".method {\n"
+	  "}\n"
+	  ".parameters {\n"
+	  "}\n"
+	  ".returnvalue {\n"
+	  "}\n"
+	  ".struct {\n"
+	  "  border-bottom: solid 2px gray;\n"
+	  "}\n"
+	  ".typedef {\n"
+	  "  border-bottom: solid 2px gray;\n"
+	  "}\n"
+	  ".union {\n"
+	  "  border-bottom: solid 2px gray;\n"
+	  "}\n"
+	  ".variable {\n"
+	  "}\n"
+	  "code, p.code, pre, ul.code li {\n"
+	  "  font-family: monaco, courier, monospace;\n"
+	  "  font-size: 90%;\n"
+	  "}\n"
+	  "a:link, a:visited {\n"
+	  "  text-decoration: none;\n"
+	  "}\n"
+	  "span.info {\n"
+	  "  background: black;\n"
+	  "  border: solid thin black;\n"
+	  "  color: white;\n"
+	  "  font-size: 80%;\n"
+	  "  font-style: italic;\n"
+	  "  font-weight: bold;\n"
+	  "  white-space: nowrap;\n"
+	  "}\n"
+	  "h3 span.info, h4 span.info {\n"
+	  "  float: right;\n"
+	  "  font-size: 100%;\n"
+	  "}\n"
+	  "ul.code, ul.contents, ul.subcontents {\n"
+	  "  list-style-type: none;\n"
+	  "  margin: 0;\n"
+	  "  padding-left: 0;\n"
+	  "}\n"
+	  "ul.code li {\n"
+	  "  margin: 0;\n"
+	  "}\n"
+	  "ul.contents > li {\n"
+	  "  margin-top: 1em;\n"
+	  "}\n"
+	  "ul.contents li ul.code, ul.contents li ul.subcontents {\n"
+	  "  padding-left: 2em;\n"
+	  "}\n"
+	  "div.body dl {\n"
+	  "  margin-top: 0;\n"
+	  "}\n"
+	  "div.body dt {\n"
+	  "  font-style: italic;\n"
+	  "  margin-top: 0;\n"
+	  "}\n"
+	  "div.body dd {\n"
+	  "  margin-bottom: 0.5em;\n"
+	  "}\n"
+	  "h1.title {\n"
+	  "}\n"
+	  "h2.title {\n"
+	  "  border-bottom: solid 2px black;\n"
+	  "}\n"
+	  "h3.title {\n"
+	  "  border-bottom: solid 2px black;\n"
+	  "}\n", out);
+  }
+
+  fputs("--></style>\n"
+        "</head>\n"
+        "<body>\n", out);
+}
+
+
+/*
+ * 'write_man()' - Write manpage documentation.
+ */
+
+static void
+write_man(const char  *man_name,	/* I - Name of manpage */
+	  const char  *section,		/* I - Section */
+	  const char  *title,		/* I - Title */
+	  const char  *footerfile,	/* I - Footer file */
+	  const char  *headerfile,	/* I - Header file */
+	  const char  *introfile,	/* I - Intro file */
+	  mxml_node_t *doc)		/* I - XML documentation */
+{
+  int		i;			/* Looping var */
+  mxml_node_t	*function,		/* Current function */
+		*scut,			/* Struct/class/union/typedef */
+		*arg,			/* Current argument */
+		*description,		/* Description of function/var */
+		*type;			/* Type for argument */
+  const char	*name,			/* Name of function/type */
+		*cname,			/* Class name */
+		*defval,		/* Default value */
+		*parent;		/* Parent class */
+  int		inscope;		/* Variable/method scope */
+  char		prefix;			/* Prefix character */
+  time_t	curtime;		/* Current time */
+  struct tm	*curdate;		/* Current date */
+  char		buffer[1024];		/* String buffer */
+  static const char * const scopes[] =	/* Scope strings */
+		{
+		  "private",
+		  "protected",
+		  "public"
+		};
+
+
+ /*
+  * Standard man page...
+  */
+
+  curtime = time(NULL);
+  curdate = localtime(&curtime);
+  strftime(buffer, sizeof(buffer), "%x", curdate);
+
+  printf(".TH %s %s \"%s\" \"%s\" \"%s\"\n", man_name, section ? section : "3",
+         title ? title : "", buffer, title ? title : "");
+
+ /*
+  * Header...
+  */
+
+  if (headerfile)
+  {
+   /*
+    * Use custom header...
+    */
+
+    write_file(stdout, headerfile);
+  }
+  else
+  {
+   /*
+    * Use standard header...
+    */
+
+    puts(".SH NAME");
+    printf("%s \\- %s\n", man_name, title ? title : man_name);
+  }
+
+ /*
+  * Intro...
+  */
+
+  if (introfile)
+    write_file(stdout, introfile);
+
+ /*
+  * List of classes...
+  */
+
+  if (find_public(doc, doc, "class"))
+  {
+    puts(".SH CLASSES");
+
+    for (scut = find_public(doc, doc, "class");
+	 scut;
+	 scut = find_public(scut, doc, "class"))
+    {
+      cname       = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      printf(".SS %s\n", cname);
+
+      write_description(stdout, description, NULL, 1);
+
+      printf(".PP\n"
+             ".nf\n"
+             "class %s", cname);
+      if ((parent = mxmlElementGetAttr(scut, "parent")) != NULL)
+        printf(" %s", parent);
+      puts("\n{");
+
+      for (i = 0; i < 3; i ++)
+      {
+        inscope = 0;
+
+	for (arg = mxmlFindElement(scut, scut, "variable", "scope", scopes[i],
+                        	   MXML_DESCEND_FIRST);
+	     arg;
+	     arg = mxmlFindElement(arg, scut, "variable", "scope", scopes[i],
+                        	   MXML_NO_DESCEND))
+	{
+          if (!inscope)
+	  {
+	    inscope = 1;
+	    printf("  %s:\n", scopes[i]);
+	  }
+
+	  printf("    ");
+	  write_element(stdout, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                                     NULL, MXML_DESCEND_FIRST),
+                        OUTPUT_MAN);
+	  printf("%s;\n", mxmlElementGetAttr(arg, "name"));
+	}
+
+	for (function = mxmlFindElement(scut, scut, "function", "scope",
+	                                scopes[i], MXML_DESCEND_FIRST);
+	     function;
+	     function = mxmlFindElement(function, scut, "function", "scope",
+	                                scopes[i], MXML_NO_DESCEND))
+	{
+          if (!inscope)
+	  {
+	    inscope = 1;
+	    printf("  %s:\n", scopes[i]);
+	  }
+
+          name = mxmlElementGetAttr(function, "name");
+
+          printf("    ");
+
+	  arg = mxmlFindElement(function, function, "returnvalue", NULL,
+                        	NULL, MXML_DESCEND_FIRST);
+
+	  if (arg)
+	    write_element(stdout, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                                       NULL, MXML_DESCEND_FIRST),
+                          OUTPUT_MAN);
+	  else if (strcmp(cname, name) && strcmp(cname, name + 1))
+	    fputs("void ", stdout);
+
+	  printf("%s", name);
+
+	  for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+                        	     MXML_DESCEND_FIRST), prefix = '(';
+	       arg;
+	       arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+                        	     MXML_NO_DESCEND), prefix = ',')
+	  {
+	    type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+	                	   MXML_DESCEND_FIRST);
+
+	    putchar(prefix);
+	    if (prefix == ',')
+	      putchar(' ');
+
+	    if (type->child)
+	      write_element(stdout, doc, type, OUTPUT_MAN);
+	    fputs(mxmlElementGetAttr(arg, "name"), stdout);
+            if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	      printf(" %s", defval);
+	  }
+
+	  if (prefix == '(')
+	    puts("(void);");
+	  else
+	    puts(");");
+	}
+      }
+
+      puts("};\n"
+           ".fi");
+
+      write_description(stdout, description, NULL, 0);
+    }
+  }
+
+ /*
+  * List of enumerations...
+  */
+
+  if (find_public(doc, doc, "enumeration"))
+  {
+    puts(".SH ENUMERATIONS");
+
+    for (scut = find_public(doc, doc, "enumeration");
+	 scut;
+	 scut = find_public(scut, doc, "enumeration"))
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      printf(".SS %s\n", name);
+
+      write_description(stdout, description, NULL, 1);
+      write_description(stdout, description, NULL, 0);
+
+      for (arg = mxmlFindElement(scut, scut, "constant", NULL, NULL,
+                        	 MXML_DESCEND_FIRST);
+	   arg;
+	   arg = mxmlFindElement(arg, scut, "constant", NULL, NULL,
+                        	 MXML_NO_DESCEND))
+      {
+	description = mxmlFindElement(arg, arg, "description", NULL,
+                                      NULL, MXML_DESCEND_FIRST);
+	printf(".TP 5\n%s\n.br\n", mxmlElementGetAttr(arg, "name"));
+	write_description(stdout, description, NULL, 1);
+      }
+    }
+  }
+
+ /*
+  * List of functions...
+  */
+
+  if (find_public(doc, doc, "function"))
+  {
+    puts(".SH FUNCTIONS");
+
+    for (function = find_public(doc, doc, "function");
+	 function;
+	 function = find_public(function, doc, "function"))
+    {
+      name        = mxmlElementGetAttr(function, "name");
+      description = mxmlFindElement(function, function, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      printf(".SS %s\n", name);
+
+      write_description(stdout, description, NULL, 1);
+
+      puts(".PP\n"
+           ".nf");
+
+      arg = mxmlFindElement(function, function, "returnvalue", NULL,
+                            NULL, MXML_DESCEND_FIRST);
+
+      if (arg)
+	write_element(stdout, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                                   NULL, MXML_DESCEND_FIRST),
+                      OUTPUT_MAN);
+      else
+	fputs("void", stdout);
+
+      printf(" %s ", name);
+      for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+                        	 MXML_DESCEND_FIRST), prefix = '(';
+	   arg;
+	   arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+                        	 MXML_NO_DESCEND), prefix = ',')
+      {
+        type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+	                       MXML_DESCEND_FIRST);
+
+	printf("%c\n    ", prefix);
+	if (type->child)
+	  write_element(stdout, doc, type, OUTPUT_MAN);
+	fputs(mxmlElementGetAttr(arg, "name"), stdout);
+        if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	  printf(" %s", defval);
+      }
+
+      if (prefix == '(')
+	puts("(void);");
+      else
+	puts("\n);");
+
+      puts(".fi");
+
+      write_description(stdout, description, NULL, 0);
+    }
+  }
+
+ /*
+  * List of structures...
+  */
+
+  if (find_public(doc, doc, "struct"))
+  {
+    puts(".SH STRUCTURES");
+
+    for (scut = find_public(doc, doc, "struct");
+	 scut;
+	 scut = find_public(scut, doc, "struct"))
+    {
+      cname       = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      printf(".SS %s\n", cname);
+
+      write_description(stdout, description, NULL, 1);
+
+      printf(".PP\n"
+             ".nf\n"
+	     "struct %s\n{\n", cname);
+      for (arg = mxmlFindElement(scut, scut, "variable", NULL, NULL,
+                        	 MXML_DESCEND_FIRST);
+	   arg;
+	   arg = mxmlFindElement(arg, scut, "variable", NULL, NULL,
+                        	 MXML_NO_DESCEND))
+      {
+	printf("  ");
+	write_element(stdout, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                                   NULL, MXML_DESCEND_FIRST),
+                      OUTPUT_MAN);
+	printf("%s;\n", mxmlElementGetAttr(arg, "name"));
+      }
+
+      for (function = mxmlFindElement(scut, scut, "function", NULL, NULL,
+                                      MXML_DESCEND_FIRST);
+	   function;
+	   function = mxmlFindElement(function, scut, "function", NULL, NULL,
+                                      MXML_NO_DESCEND))
+      {
+        name = mxmlElementGetAttr(function, "name");
+
+        printf("  ");
+
+	arg = mxmlFindElement(function, function, "returnvalue", NULL,
+                              NULL, MXML_DESCEND_FIRST);
+
+	if (arg)
+	  write_element(stdout, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                                     NULL, MXML_DESCEND_FIRST),
+                        OUTPUT_MAN);
+	else if (strcmp(cname, name) && strcmp(cname, name + 1))
+	  fputs("void ", stdout);
+
+	fputs(name, stdout);
+
+	for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+                        	   MXML_DESCEND_FIRST), prefix = '(';
+	     arg;
+	     arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+                        	   MXML_NO_DESCEND), prefix = ',')
+	{
+	  type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+	                	 MXML_DESCEND_FIRST);
+
+	  putchar(prefix);
+	  if (prefix == ',')
+	    putchar(' ');
+
+	  if (type->child)
+	    write_element(stdout, doc, type, OUTPUT_MAN);
+	  fputs(mxmlElementGetAttr(arg, "name"), stdout);
+          if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	    printf(" %s", defval);
+	}
+
+	if (prefix == '(')
+	  puts("(void);");
+	else
+	  puts(");");
+      }
+
+      puts("};\n"
+           ".fi");
+
+      write_description(stdout, description, NULL, 0);
+    }
+  }
+
+ /*
+  * List of types...
+  */
+
+  if (find_public(doc, doc, "typedef"))
+  {
+    puts(".SH TYPES");
+
+    for (scut = find_public(doc, doc, "typedef");
+	 scut;
+	 scut = find_public(scut, doc, "typedef"))
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      printf(".SS %s\n", name);
+
+      write_description(stdout, description, NULL, 1);
+
+      fputs(".PP\n"
+            ".nf\n"
+	    "typedef ", stdout);
+
+      type = mxmlFindElement(scut, scut, "type", NULL, NULL,
+                             MXML_DESCEND_FIRST);
+
+      for (type = type->child; type; type = type->next)
+        if (!strcmp(type->value.text.string, "("))
+	  break;
+	else
+	{
+	  if (type->value.text.whitespace)
+	    putchar(' ');
+
+          write_string(stdout, type->value.text.string, OUTPUT_MAN);
+        }
+
+      if (type)
+      {
+       /*
+        * Output function type...
+	*/
+
+        printf(" (*%s", name);
+
+	for (type = type->next->next; type; type = type->next)
+	{
+	  if (type->value.text.whitespace)
+	    putchar(' ');
+
+          write_string(stdout, type->value.text.string, OUTPUT_MAN);
+        }
+
+        puts(";");
+      }
+      else
+	printf(" %s;\n", name);
+
+      puts(".fi");
+
+      write_description(stdout, description, NULL, 0);
+    }
+  }
+
+ /*
+  * List of unions...
+  */
+
+  if (find_public(doc, doc, "union"))
+  {
+    puts(".SH UNIONS");
+
+    for (scut = find_public(doc, doc, "union");
+	 scut;
+	 scut = find_public(scut, doc, "union"))
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      printf(".SS %s\n", name);
+
+      write_description(stdout, description, NULL, 1);
+
+      printf(".PP\n"
+             ".nf\n"
+	     "union %s\n{\n", name);
+      for (arg = mxmlFindElement(scut, scut, "variable", NULL, NULL,
+                        	 MXML_DESCEND_FIRST);
+	   arg;
+	   arg = mxmlFindElement(arg, scut, "variable", NULL, NULL,
+                        	 MXML_NO_DESCEND))
+      {
+	printf("  ");
+	write_element(stdout, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                                   NULL, MXML_DESCEND_FIRST),
+                      OUTPUT_MAN);
+	printf("%s;\n", mxmlElementGetAttr(arg, "name"));
+      }
+
+      puts("};\n"
+           ".fi");
+
+      write_description(stdout, description, NULL, 0);
+    }
+  }
+
+ /*
+  * Variables...
+  */
+
+  if (find_public(doc, doc, "variable"))
+  {
+    puts(".SH VARIABLES");
+
+    for (arg = find_public(doc, doc, "variable");
+	 arg;
+	 arg = find_public(arg, doc, "variable"))
+    {
+      name        = mxmlElementGetAttr(arg, "name");
+      description = mxmlFindElement(arg, arg, "description", NULL,
+                                    NULL, MXML_DESCEND_FIRST);
+      printf(".SS %s\n", name);
+
+      write_description(stdout, description, NULL, 1);
+
+      puts(".PP\n"
+           ".nf");
+
+      write_element(stdout, doc, mxmlFindElement(arg, arg, "type", NULL,
+                                                 NULL, MXML_DESCEND_FIRST),
+                    OUTPUT_MAN);
+      fputs(mxmlElementGetAttr(arg, "name"), stdout);
+      if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	printf(" %s", defval);
+      puts(";\n"
+           ".fi");
+
+      write_description(stdout, description, NULL, 0);
+    }
+  }
+
+  if (footerfile)
+  {
+   /*
+    * Use custom footer...
+    */
+
+    write_file(stdout, footerfile);
+  }
+}
+
+
+/*
+ * 'write_scu()' - Write a structure, class, or union.
+ */
+
+static void
+write_scu(FILE        *out,	/* I - Output file */
+          mxml_node_t *doc,	/* I - Document */
+          mxml_node_t *scut)	/* I - Structure, class, or union */
+{
+  int		i;			/* Looping var */
+  mxml_node_t	*function,		/* Current function */
+		*arg,			/* Current argument */
+		*description,		/* Description of function/var */
+		*type;			/* Type for argument */
+  const char	*name,			/* Name of function/type */
+		*cname,			/* Class name */
+		*defval,		/* Default value */
+		*parent,		/* Parent class */
+		*scope;			/* Scope for variable/function */
+  int		inscope,		/* Variable/method scope */
+		maxscope;		/* Maximum scope */
+  char		prefix;			/* Prefix character */
+  static const char * const scopes[] =	/* Scope strings */
+		{
+		  "private",
+		  "protected",
+		  "public"
+		};
+
+
+  cname       = mxmlElementGetAttr(scut, "name");
+  description = mxmlFindElement(scut, scut, "description", NULL,
+				NULL, MXML_DESCEND_FIRST);
+
+  fprintf(out, "<h3 class=\"%s\">%s<a name=\"%s\">%s</a></h3>\n",
+	  scut->value.element.name, get_comment_info(description), cname,
+	  cname);
+
+  if (description)
+    write_description(out, description, "p", 1);
+
+  fprintf(out, "<p class=\"code\">%s %s", scut->value.element.name, cname);
+  if ((parent = mxmlElementGetAttr(scut, "parent")) != NULL)
+    fprintf(out, " %s", parent);
+  fputs(" {<br>\n", out);
+
+  maxscope = !strcmp(scut->value.element.name, "class") ? 3 : 1;
+
+  for (i = 0; i < maxscope; i ++)
+  {
+    inscope = maxscope == 1;
+
+    for (arg = mxmlFindElement(scut, scut, "variable", NULL, NULL,
+			       MXML_DESCEND_FIRST);
+	 arg;
+	 arg = mxmlFindElement(arg, scut, "variable", NULL, NULL,
+			       MXML_NO_DESCEND))
+    {
+      if (maxscope > 1 &&
+          ((scope = mxmlElementGetAttr(arg, "scope")) == NULL ||
+	   strcmp(scope, scopes[i])))
+	continue;
+
+      if (!inscope)
+      {
+	inscope = 1;
+	fprintf(out, "&nbsp;&nbsp;%s:<br>\n", scopes[i]);
+      }
+
+      fputs("&nbsp;&nbsp;&nbsp;&nbsp;", out);
+      write_element(out, doc, mxmlFindElement(arg, arg, "type", NULL,
+					      NULL, MXML_DESCEND_FIRST),
+		    OUTPUT_HTML);
+      fprintf(out, "%s;<br>\n", mxmlElementGetAttr(arg, "name"));
+    }
+
+    for (function = mxmlFindElement(scut, scut, "function", NULL, NULL,
+                                    MXML_DESCEND_FIRST);
+	 function;
+	 function = mxmlFindElement(function, scut, "function", NULL, NULL,
+	                            MXML_NO_DESCEND))
+    {
+      if (maxscope > 1 &&
+          ((scope = mxmlElementGetAttr(arg, "scope")) == NULL ||
+	   strcmp(scope, scopes[i])))
+	continue;
+
+      if (!inscope)
+      {
+	inscope = 1;
+	fprintf(out, "&nbsp;&nbsp;%s:<br>\n", scopes[i]);
+      }
+
+      name = mxmlElementGetAttr(function, "name");
+
+      fputs("&nbsp;&nbsp;&nbsp;&nbsp;", out);
+
+      arg = mxmlFindElement(function, function, "returnvalue", NULL,
+			    NULL, MXML_DESCEND_FIRST);
+
+      if (arg)
+	write_element(out, doc, mxmlFindElement(arg, arg, "type", NULL,
+						NULL, MXML_DESCEND_FIRST),
+		      OUTPUT_HTML);
+      else if (strcmp(cname, name) && strcmp(cname, name + 1))
+	fputs("void ", out);
+
+      fprintf(out, "<a href=\"#%s.%s\">%s</a>", cname, name, name);
+
+      for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+				 MXML_DESCEND_FIRST), prefix = '(';
+	   arg;
+	   arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+				 MXML_NO_DESCEND), prefix = ',')
+      {
+	type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+			       MXML_DESCEND_FIRST);
+
+	putc(prefix, out);
+	if (prefix == ',')
+	  putc(' ', out);
+
+	if (type->child)
+	  write_element(out, doc, type, OUTPUT_HTML);
+
+	fputs(mxmlElementGetAttr(arg, "name"), out);
+	if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	  fprintf(out, " %s", defval);
+      }
+
+      if (prefix == '(')
+	fputs("(void);<br>\n", out);
+      else
+	fputs(");<br>\n", out);
+    }
+  }
+
+  fputs("};</p>\n"
+	"<h4 class=\"members\">Members</h4>\n"
+	"<dl>\n", out);
+
+  for (arg = mxmlFindElement(scut, scut, "variable", NULL, NULL,
+			     MXML_DESCEND_FIRST);
+       arg;
+       arg = mxmlFindElement(arg, scut, "variable", NULL, NULL,
+			     MXML_NO_DESCEND))
+  {
+    description = mxmlFindElement(arg, arg, "description", NULL,
+				  NULL, MXML_DESCEND_FIRST);
+
+    fprintf(out, "<dt>%s %s</dt>\n",
+	    mxmlElementGetAttr(arg, "name"), get_comment_info(description));
+
+    write_description(out, description, "dd", 1);
+    write_description(out, description, "dd", 0);
+  }
+
+  fputs("</dl>\n", out);
+
+  for (function = mxmlFindElement(scut, scut, "function", NULL, NULL,
+				  MXML_DESCEND_FIRST);
+       function;
+       function = mxmlFindElement(function, scut, "function", NULL, NULL,
+				  MXML_NO_DESCEND))
+  {
+    write_function(out, doc, function, 4);
+  }
+}
+
+
+/*
+ * 'write_string()' - Write a string, quoting HTML special chars as needed.
+ */
+
+static void
+write_string(FILE       *out,		/* I - Output file */
+             const char *s,		/* I - String to write */
+             int        mode)		/* I - Output mode */
+{
+  switch (mode)
+  {
+    case OUTPUT_HTML :
+    case OUTPUT_XML :
+        while (*s)
+        {
+          if (*s == '&')
+            fputs("&amp;", out);
+          else if (*s == '<')
+            fputs("&lt;", out);
+          else if (*s == '>')
+            fputs("&gt;", out);
+          else if (*s == '\"')
+            fputs("&quot;", out);
+          else if (*s & 128)
+          {
+           /*
+            * Convert UTF-8 to Unicode constant...
+            */
+
+            int	ch;			/* Unicode character */
+
+
+            ch = *s & 255;
+
+            if ((ch & 0xe0) == 0xc0)
+            {
+              ch = ((ch & 0x1f) << 6) | (s[1] & 0x3f);
+	      s ++;
+            }
+            else if ((ch & 0xf0) == 0xe0)
+            {
+              ch = ((((ch * 0x0f) << 6) | (s[1] & 0x3f)) << 6) | (s[2] & 0x3f);
+	      s += 2;
+            }
+
+            if (ch == 0xa0)
+            {
+             /*
+              * Handle non-breaking space as-is...
+	      */
+
+              fputs("&nbsp;", out);
+            }
+            else
+              fprintf(out, "&#x%x;", ch);
+          }
+          else
+            putc(*s, out);
+
+          s ++;
+        }
+        break;
+
+    case OUTPUT_MAN :
+        while (*s)
+        {
+          if (*s == '\\' || *s == '-')
+            putc('\\', out);
+
+          putc(*s++, out);
+        }
+        break;
+  }
+}
+
+
+/*
+ * 'write_toc()' - Write a table-of-contents.
+ */
+
+static void
+write_toc(FILE        *out,		/* I - Output file */
+          mxml_node_t *doc,		/* I - Document */
+          const char  *introfile,	/* I - Introduction file */
+	  const char  *target,		/* I - Target name */
+	  int         xml)		/* I - Write XML nodes? */
+{
+  FILE		*fp;			/* Intro file */
+  mxml_node_t	*function,		/* Current function */
+		*scut,			/* Struct/class/union/typedef */
+		*arg,			/* Current argument */
+		*description;		/* Description of function/var */
+  const char	*name,			/* Name of function/type */
+		*targetattr;		/* Target attribute, if any */
+  int		xmlid = 1;		/* Current XML node ID */
+
+
+ /*
+  * If target is set, it is the frame file that contains the body.
+  * Otherwise, we are creating a single-file...
+  */
+
+  if (target)
+    targetattr = " target=\"body\"";
+  else
+    targetattr = "";
+
+ /*
+  * The table-of-contents is a nested unordered list.  Start by
+  * reading any intro file to see if there are any headings there.
+  */
+
+  if (!xml)
+    fputs("<h2 class=\"title\">Contents</h2>\n"
+          "<ul class=\"contents\">\n", out);
+
+  if (introfile && (fp = fopen(introfile, "r")) != NULL)
+  {
+    char	line[8192],		/* Line from file */
+		*ptr,			/* Pointer in line */
+		*end,			/* End of line */
+		*anchor,		/* Anchor name */
+		quote,			/* Quote character for value */
+		level = '1',		/* Current heading level */
+		newlevel;		/* New heading level */
+    int		inelement;		/* In an element? */
+
+
+    while (fgets(line, sizeof(line), fp))
+    {
+     /*
+      * See if this line has a heading...
+      */
+
+      if ((ptr = strstr(line, "<h")) == NULL &&
+          (ptr = strstr(line, "<H")) == NULL)
+	continue;
+
+      if (ptr[2] != '2' && ptr[2] != '3')
+        continue;
+
+      newlevel = ptr[2];
+
+     /*
+      * Make sure we have the whole heading...
+      */
+
+      while (!strstr(line, "</h") && !strstr(line, "</H"))
+      {
+        end = line + strlen(line);
+
+	if (end == (line + sizeof(line) - 1) ||
+	    !fgets(end, (int)(sizeof(line) - (end - line)), fp))
+	  break;
+      }
+
+     /*
+      * Convert newlines and tabs to spaces...
+      */
+
+      for (ptr = line; *ptr; ptr ++)
+        if (isspace(*ptr & 255))
+	  *ptr = ' ';
+
+     /*
+      * Find the anchor and text...
+      */
+
+      for (ptr = strchr(line, '<'); ptr; ptr = strchr(ptr + 1, '<'))
+        if (!strncmp(ptr, "<A NAME=", 8) || !strncmp(ptr, "<a name=", 8))
+	  break;
+
+      if (!ptr)
+        continue;
+
+      ptr += 8;
+      inelement = 1;
+
+      if (*ptr == '\'' || *ptr == '\"')
+      {
+       /*
+        * Quoted anchor...
+	*/
+
+        quote  = *ptr++;
+	anchor = ptr;
+
+	while (*ptr && *ptr != quote)
+	  ptr ++;
+
+        if (!*ptr)
+	  continue;
+
+        *ptr++ = '\0';
+      }
+      else
+      {
+       /*
+        * Non-quoted anchor...
+	*/
+
+        anchor = ptr;
+
+	while (*ptr && *ptr != '>' && !isspace(*ptr & 255))
+	  ptr ++;
+
+        if (!*ptr)
+	  continue;
+
+        if (*ptr == '>')
+	  inelement = 0;
+
+	*ptr++ = '\0';
+      }
+
+     /*
+      * Write text until we see "</A>"...
+      */
+
+      if (xml)
+      {
+	if (newlevel < level)
+	  fputs("</Node>\n"
+		"</Subnodes></Node>\n", out);
+	else if (newlevel > level && newlevel == '3')
+	  fputs("<Subnodes>\n", out);
+	else if (xmlid > 1)
+	  fputs("</Node>\n", out);
+
+	level = newlevel;
+
+	fprintf(out, "<Node id=\"%d\">\n"
+                     "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>", xmlid ++, anchor);
+
+	quote = 0;
+
+	while (*ptr)
+	{
+	  if (inelement)
+	  {
+	    if (*ptr == quote)
+	      quote = 0;
+	    else if (*ptr == '>')
+	      inelement = 0;
+	    else if (*ptr == '\'' || *ptr == '\"')
+	      quote = *ptr;
+	  }
+	  else if (*ptr == '<')
+	  {
+	    if (!strncmp(ptr, "</A>", 4) || !strncmp(ptr, "</a>", 4))
+	      break;
+
+	    inelement = 1;
+	  }
+	  else
+	    putc(*ptr, out);
+
+	  ptr ++;
+	}
+
+	fputs("</Name>\n", out);
+      }
+      else
+      {
+	if (newlevel < level)
+	  fputs("</li>\n"
+		"</ul></li>\n", out);
+	else if (newlevel > level)
+	  fputs("<ul class=\"subcontents\">\n", out);
+	else if (xmlid > 1)
+	  fputs("</li>\n", out);
+
+	level = newlevel;
+	xmlid ++;
+
+	fprintf(out, "<li><a href=\"%s#%s\"%s>", target ? target : "", anchor,
+		targetattr);
+
+	quote = 0;
+
+	while (*ptr)
+	{
+	  if (inelement)
+	  {
+	    if (*ptr == quote)
+	      quote = 0;
+	    else if (*ptr == '>')
+	      inelement = 0;
+	    else if (*ptr == '\'' || *ptr == '\"')
+	      quote = *ptr;
+	  }
+	  else if (*ptr == '<')
+	  {
+	    if (!strncmp(ptr, "</A>", 4) || !strncmp(ptr, "</a>", 4))
+	      break;
+
+	    inelement = 1;
+	  }
+	  else
+	    putc(*ptr, out);
+
+	  ptr ++;
+	}
+
+	fputs("</a>", out);
+      }
+    }
+
+    if (level > '1')
+    {
+      if (xml)
+      {
+	fputs("</Node>\n", out);
+
+	if (level == '3')
+	  fputs("</Subnodes></Node>\n", out);
+      }
+      else
+      {
+	fputs("</li>\n", out);
+
+	if (level == '3')
+	  fputs("</ul></li>\n", out);
+      }
+    }
+  
+    fclose(fp);
+  }
+
+ /*
+  * Next the classes...
+  */
+
+  if ((scut = find_public(doc, doc, "class")) != NULL)
+  {
+    if (xml)
+      fprintf(out, "<Node id=\"%d\">\n"
+		   "<Path>Documentation/index.html</Path>\n"
+	           "<Anchor>CLASSES</Anchor>\n"
+		   "<Name>Classes</Name>\n"
+		   "<Subnodes>\n", xmlid ++);
+    else
+      fprintf(out, "<li><a href=\"%s#CLASSES\"%s>Classes</a>"
+		   "<ul class=\"code\">\n",
+	      target ? target : "", targetattr);
+
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      if (xml)
+      {
+	fprintf(out, "<Node id=\"%d\">\n"
+	             "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>%s</Name>\n"
+		     "</Node>\n", xmlid ++, name, name);
+      }
+      else
+      {
+	fprintf(out, "<li><a href=\"%s#%s\"%s title=\"",
+		target ? target : "", name, targetattr);
+	write_description(out, description, "", 1);
+	fprintf(out, "\">%s</a></li>\n", name);
+      }
+
+      scut = find_public(scut, doc, "class");
+    }
+
+    if (xml)
+      fputs("</Subnodes></Node>\n", out);
+    else
+      fputs("</ul></li>\n", out);
+  }
+
+ /*
+  * Functions...
+  */
+
+  if ((function = find_public(doc, doc, "function")) != NULL)
+  {
+    if (xml)
+      fprintf(out, "<Node id=\"%d\">\n"
+		   "<Path>Documentation/index.html</Path>\n"
+	           "<Anchor>FUNCTIONS</Anchor>\n"
+		   "<Name>Functions</Name>\n"
+		   "<Subnodes>\n", xmlid ++);
+    else
+      fprintf(out, "<li><a href=\"%s#FUNCTIONS\"%s>Functions</a>"
+		   "<ul class=\"code\">\n", target ? target : "", targetattr);
+
+    while (function)
+    {
+      name        = mxmlElementGetAttr(function, "name");
+      description = mxmlFindElement(function, function, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      if (xml)
+      {
+	fprintf(out, "<Node id=\"%d\">\n"
+	             "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>%s</Name>\n"
+		     "</Node>\n", xmlid ++, name, name);
+      }
+      else
+      {
+	fprintf(out, "<li><a href=\"%s#%s\"%s title=\"",
+		target ? target : "", name, targetattr);
+	write_description(out, description, "", 1);
+	fprintf(out, "\">%s</a></li>\n", name);
+      }
+
+      function = find_public(function, doc, "function");
+    }
+
+    if (xml)
+      fputs("</Subnodes></Node>\n", out);
+    else
+      fputs("</ul></li>\n", out);
+  }
+
+ /*
+  * Data types...
+  */
+
+  if ((scut = find_public(doc, doc, "typedef")) != NULL)
+  {
+    if (xml)
+      fprintf(out, "<Node id=\"%d\">\n"
+		   "<Path>Documentation/index.html</Path>\n"
+	           "<Anchor>TYPES</Anchor>\n"
+		   "<Name>Data Types</Name>\n"
+		   "<Subnodes>\n", xmlid ++);
+    else
+      fprintf(out, "<li><a href=\"%s#TYPES\"%s>Data Types</a>"
+		   "<ul class=\"code\">\n", target ? target : "", targetattr);
+
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      if (xml)
+      {
+	fprintf(out, "<Node id=\"%d\">\n"
+	             "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>%s</Name>\n"
+		     "</Node>\n", xmlid ++, name, name);
+      }
+      else
+      {
+	fprintf(out, "\t<li><a href=\"%s#%s\"%s title=\"",
+		target ? target : "", name, targetattr);
+	write_description(out, description, "", 1);
+	fprintf(out, "\">%s</a></li>\n", name);
+      }
+
+      scut = find_public(scut, doc, "typedef");
+    }
+
+    if (xml)
+      fputs("</Subnodes></Node>\n", out);
+    else
+      fputs("</ul></li>\n", out);
+  }
+
+ /*
+  * Structures...
+  */
+
+  if ((scut = find_public(doc, doc, "struct")) != NULL)
+  {
+    if (xml)
+      fprintf(out, "<Node id=\"%d\">\n"
+		   "<Path>Documentation/index.html</Path>\n"
+	           "<Anchor>STRUCTURES</Anchor>\n"
+		   "<Name>Structures</Name>\n"
+		   "<Subnodes>\n", xmlid ++);
+    else
+      fprintf(out, "<li><a href=\"%s#STRUCTURES\"%s>Structures</a>"
+		   "<ul class=\"code\">\n", target ? target : "", targetattr);
+
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      if (xml)
+      {
+	fprintf(out, "<Node id=\"%d\">\n"
+	             "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>%s</Name>\n"
+		     "</Node>\n", xmlid ++, name, name);
+      }
+      else
+      {
+	fprintf(out, "\t<li><a href=\"%s#%s\"%s title=\"",
+		target ? target : "", name, targetattr);
+	write_description(out, description, "", 1);
+	fprintf(out, "\">%s</a></li>\n", name);
+      }
+
+      scut = find_public(scut, doc, "struct");
+    }
+
+    if (xml)
+      fputs("</Subnodes></Node>\n", out);
+    else
+      fputs("</ul></li>\n", out);
+  }
+
+ /*
+  * Unions...
+  */
+
+  if ((scut = find_public(doc, doc, "union")) != NULL)
+  {
+    if (xml)
+      fprintf(out, "<Node id=\"%d\">\n"
+		   "<Path>Documentation/index.html</Path>\n"
+	           "<Anchor>UNIONS</Anchor>\n"
+		   "<Name>Unions</Name>\n"
+		   "<Subnodes>\n", xmlid ++);
+    else
+      fprintf(out,
+              "<li><a href=\"%s#UNIONS\"%s>Unions</a><ul class=\"code\">\n",
+	      target ? target : "", targetattr);
+
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      if (xml)
+      {
+	fprintf(out, "<Node id=\"%d\">\n"
+	             "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>%s</Name>\n"
+		     "</Node>\n", xmlid ++, name, name);
+      }
+      else
+      {
+	fprintf(out, "\t<li><a href=\"%s#%s\"%s title=\"",
+		target ? target : "", name, targetattr);
+	write_description(out, description, "", 1);
+	fprintf(out, "\">%s</a></li>\n", name);
+      }
+
+      scut = find_public(scut, doc, "union");
+    }
+
+    if (xml)
+      fputs("</Subnodes></Node>\n", out);
+    else
+      fputs("</ul></li>\n", out);
+  }
+
+ /*
+  * Globals variables...
+  */
+
+  if ((arg = find_public(doc, doc, "variable")) != NULL)
+  {
+    if (xml)
+      fprintf(out, "<Node id=\"%d\">\n"
+		   "<Path>Documentation/index.html</Path>\n"
+	           "<Anchor>VARIABLES</Anchor>\n"
+		   "<Name>Variables</Name>\n"
+		   "<Subnodes>\n", xmlid ++);
+    else
+      fprintf(out, "<li><a href=\"%s#VARIABLES\"%s>Variables</a>"
+		   "<ul class=\"code\">\n", target ? target : "", targetattr);
+
+    while (arg)
+    {
+      name        = mxmlElementGetAttr(arg, "name");
+      description = mxmlFindElement(arg, arg, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      if (xml)
+      {
+	fprintf(out, "<Node id=\"%d\">\n"
+	             "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>%s</Name>\n"
+		     "</Node>\n", xmlid ++, name, name);
+      }
+      else
+      {
+	fprintf(out, "\t<li><a href=\"%s#%s\"%s title=\"",
+		target ? target : "", name, targetattr);
+	write_description(out, description, "", 1);
+	fprintf(out, "\">%s</a></li>\n", name);
+      }
+
+      arg = find_public(arg, doc, "variable");
+    }
+
+    if (xml)
+      fputs("</Subnodes></Node>\n", out);
+    else
+      fputs("</ul></li>\n", out);
+  }
+
+ /*
+  * Enumerations/constants...
+  */
+
+  if ((scut = find_public(doc, doc, "enumeration")) != NULL)
+  {
+    if (xml)
+      fprintf(out, "<Node id=\"%d\">\n"
+		   "<Path>Documentation/index.html</Path>\n"
+	           "<Anchor>ENUMERATIONS</Anchor>\n"
+		   "<Name>Constants</Name>\n"
+		   "<Subnodes>\n", xmlid ++);
+    else
+      fprintf(out, "<li><a href=\"%s#ENUMERATIONS\"%s>Constants</a>"
+		   "<ul class=\"code\">\n", target ? target : "", targetattr);
+
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      if (xml)
+      {
+	fprintf(out, "<Node id=\"%d\">\n"
+	             "<Path>Documentation/index.html</Path>\n"
+	             "<Anchor>%s</Anchor>\n"
+		     "<Name>%s</Name>\n"
+		     "</Node>\n", xmlid ++, name, name);
+      }
+      else
+      {
+	fprintf(out, "\t<li><a href=\"%s#%s\"%s title=\"",
+		target ? target : "", name, targetattr);
+	write_description(out, description, "", 1);
+	fprintf(out, "\">%s</a></li>\n", name);
+      }
+
+      scut = find_public(scut, doc, "enumeration");
+    }
+
+    if (xml)
+      fputs("</Subnodes></Node>\n", out);
+    else
+      fputs("</ul></li>\n", out);
+  }
+}
+
+
+/*
+ * 'write_tokens()' - Write <Token> nodes for all APIs.
+ */
+
+static void
+write_tokens(FILE        *out,		/* I - Output file */
+             mxml_node_t *doc,		/* I - Document */
+	     const char  *path)		/* I - Path to help file */
+{
+  mxml_node_t	*function,		/* Current function */
+		*scut,			/* Struct/class/union/typedef */
+		*arg,			/* Current argument */
+		*description,		/* Description of function/var */
+		*type,			/* Type node */
+		*node;			/* Current child node */
+  const char	*name,			/* Name of function/type */
+		*cename,		/* Current class/enum name */
+		*defval;		/* Default value for argument */
+  char		prefix;			/* Prefix for declarations */
+
+
+ /*
+  * Classes...
+  */
+
+  if ((scut = find_public(doc, doc, "class")) != NULL)
+  {
+    while (scut)
+    {
+      cename      = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      fprintf(out, "<Token>\n"
+		   "<Path>Documentation/%s</Path>\n"
+		   "<Anchor>%s</Anchor>\n"
+		   "<TokenIdentifier>//apple_ref/cpp/cl/%s</TokenIdentifier>\n"
+		   "<Abstract>", path, cename, cename);
+      write_description(out, description, "", 1);
+      fputs("</Abstract>\n"
+            "</Token>\n", out);
+
+      if ((function = find_public(scut, scut, "function")) != NULL)
+      {
+	while (function)
+	{
+	  name        = mxmlElementGetAttr(function, "name");
+	  description = mxmlFindElement(function, function, "description",
+					NULL, NULL, MXML_DESCEND_FIRST);
+
+	  fprintf(out, "<Token>\n"
+		       "<Path>Documentation/%s</Path>\n"
+		       "<Anchor>%s.%s</Anchor>\n"
+		       "<TokenIdentifier>//apple_ref/cpp/clm/%s/%s", path,
+		  cename, name, cename, name);
+
+	  arg = mxmlFindElement(function, function, "returnvalue", NULL,
+				NULL, MXML_DESCEND_FIRST);
+
+	  if (arg && (type = mxmlFindElement(arg, arg, "type", NULL,
+					     NULL, MXML_DESCEND_FIRST)) != NULL)
+          {
+	    for (node = type->child; node; node = node->next)
+	      fputs(node->value.text.string, out);
+	  }
+	  else if (strcmp(cename, name) && strcmp(cename, name + 1))
+	    fputs("void", out);
+
+	  fputs("/", out);
+
+	  for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+				     MXML_DESCEND_FIRST), prefix = '(';
+	       arg;
+	       arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+				     MXML_NO_DESCEND), prefix = ',')
+	  {
+	    type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+				   MXML_DESCEND_FIRST);
+
+	    putc(prefix, out);
+
+	    for (node = type->child; node; node = node->next)
+	      fputs(node->value.text.string, out);
+
+	    fputs(mxmlElementGetAttr(arg, "name"), out);
+	  }
+
+	  if (prefix == '(')
+	    fputs("(void", out);
+
+	  fputs(")</TokenIdentifier>\n"
+	        "<Abstract>", out);
+	  write_description(out, description, "", 1);
+	  fputs("</Abstract>\n"
+		"<Declaration>", out);
+
+	  arg = mxmlFindElement(function, function, "returnvalue", NULL,
+				NULL, MXML_DESCEND_FIRST);
+
+	  if (arg)
+	    write_element(out, doc, mxmlFindElement(arg, arg, "type", NULL,
+						    NULL, MXML_DESCEND_FIRST),
+			  OUTPUT_XML);
+	  else if (strcmp(cename, name) && strcmp(cename, name + 1))
+	    fputs("void ", out);
+
+	  fputs(name, out);
+
+	  for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+				     MXML_DESCEND_FIRST), prefix = '(';
+	       arg;
+	       arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+				     MXML_NO_DESCEND), prefix = ',')
+	  {
+	    type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+				   MXML_DESCEND_FIRST);
+
+	    putc(prefix, out);
+	    if (prefix == ',')
+	      putc(' ', out);
+
+	    if (type->child)
+	      write_element(out, doc, type, OUTPUT_XML);
+
+	    fputs(mxmlElementGetAttr(arg, "name"), out);
+	    if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	      fprintf(out, " %s", defval);
+	  }
+
+	  if (prefix == '(')
+	    fputs("(void);", out);
+	  else
+	    fputs(");", out);
+
+	  fputs("</Declaration>\n"
+		"</Token>\n", out);
+
+	  function = find_public(function, doc, "function");
+	}
+      }
+      scut = find_public(scut, doc, "class");
+    }
+  }
+
+ /*
+  * Functions...
+  */
+
+  if ((function = find_public(doc, doc, "function")) != NULL)
+  {
+    while (function)
+    {
+      name        = mxmlElementGetAttr(function, "name");
+      description = mxmlFindElement(function, function, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      fprintf(out, "<Token>\n"
+		   "<Path>Documentation/%s</Path>\n"
+		   "<Anchor>%s</Anchor>\n"
+		   "<TokenIdentifier>//apple_ref/c/func/%s</TokenIdentifier>\n"
+		   "<Abstract>", path, name, name);
+      write_description(out, description, "", 1);
+      fputs("</Abstract>\n"
+            "<Declaration>", out);
+
+      arg = mxmlFindElement(function, function, "returnvalue", NULL,
+			    NULL, MXML_DESCEND_FIRST);
+
+      if (arg)
+	write_element(out, doc, mxmlFindElement(arg, arg, "type", NULL,
+						NULL, MXML_DESCEND_FIRST),
+		      OUTPUT_XML);
+      else // if (strcmp(cname, name) && strcmp(cname, name + 1))
+	fputs("void ", out);
+
+      fputs(name, out);
+
+      for (arg = mxmlFindElement(function, function, "argument", NULL, NULL,
+				 MXML_DESCEND_FIRST), prefix = '(';
+	   arg;
+	   arg = mxmlFindElement(arg, function, "argument", NULL, NULL,
+				 MXML_NO_DESCEND), prefix = ',')
+      {
+	type = mxmlFindElement(arg, arg, "type", NULL, NULL,
+			       MXML_DESCEND_FIRST);
+
+	putc(prefix, out);
+	if (prefix == ',')
+	  putc(' ', out);
+
+	if (type->child)
+	  write_element(out, doc, type, OUTPUT_XML);
+
+	fputs(mxmlElementGetAttr(arg, "name"), out);
+	if ((defval = mxmlElementGetAttr(arg, "default")) != NULL)
+	  fprintf(out, " %s", defval);
+      }
+
+      if (prefix == '(')
+	fputs("(void);", out);
+      else
+	fputs(");", out);
+
+      fputs("</Declaration>\n"
+            "</Token>\n", out);
+
+      function = find_public(function, doc, "function");
+    }
+  }
+
+ /*
+  * Data types...
+  */
+
+  if ((scut = find_public(doc, doc, "typedef")) != NULL)
+  {
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      fprintf(out, "<Token>\n"
+		   "<Path>Documentation/%s</Path>\n"
+		   "<Anchor>%s</Anchor>\n"
+		   "<TokenIdentifier>//apple_ref/c/tdef/%s</TokenIdentifier>\n"
+		   "<Abstract>", path, name, name);
+      write_description(out, description, "", 1);
+      fputs("</Abstract>\n"
+            "</Token>\n", out);
+
+      scut = find_public(scut, doc, "typedef");
+    }
+  }
+
+ /*
+  * Structures...
+  */
+
+  if ((scut = find_public(doc, doc, "struct")) != NULL)
+  {
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      fprintf(out, "<Token>\n"
+		   "<Path>Documentation/%s</Path>\n"
+		   "<Anchor>%s</Anchor>\n"
+		   "<TokenIdentifier>//apple_ref/c/tag/%s</TokenIdentifier>\n"
+		   "<Abstract>", path, name, name);
+      write_description(out, description, "", 1);
+      fputs("</Abstract>\n"
+            "</Token>\n", out);
+
+      scut = find_public(scut, doc, "struct");
+    }
+  }
+
+ /*
+  * Unions...
+  */
+
+  if ((scut = find_public(doc, doc, "union")) != NULL)
+  {
+    while (scut)
+    {
+      name        = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      fprintf(out, "<Token>\n"
+		   "<Path>Documentation/%s</Path>\n"
+		   "<Anchor>%s</Anchor>\n"
+		   "<TokenIdentifier>//apple_ref/c/tag/%s</TokenIdentifier>\n"
+		   "<Abstract>", path, name, name);
+      write_description(out, description, "", 1);
+      fputs("</Abstract>\n"
+            "</Token>\n", out);
+
+      scut = find_public(scut, doc, "union");
+    }
+  }
+
+ /*
+  * Globals variables...
+  */
+
+  if ((arg = find_public(doc, doc, "variable")) != NULL)
+  {
+    while (arg)
+    {
+      name        = mxmlElementGetAttr(arg, "name");
+      description = mxmlFindElement(arg, arg, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      fprintf(out, "<Token>\n"
+		   "<Path>Documentation/%s</Path>\n"
+		   "<Anchor>%s</Anchor>\n"
+		   "<TokenIdentifier>//apple_ref/c/data/%s</TokenIdentifier>\n"
+		   "<Abstract>", path, name, name);
+      write_description(out, description, "", 1);
+      fputs("</Abstract>\n"
+            "</Token>\n", out);
+
+      arg = find_public(arg, doc, "variable");
+    }
+  }
+
+ /*
+  * Enumerations/constants...
+  */
+
+  if ((scut = find_public(doc, doc, "enumeration")) != NULL)
+  {
+    while (scut)
+    {
+      cename      = mxmlElementGetAttr(scut, "name");
+      description = mxmlFindElement(scut, scut, "description",
+				    NULL, NULL, MXML_DESCEND_FIRST);
+
+      fprintf(out, "<Token>\n"
+		   "<Path>Documentation/%s</Path>\n"
+		   "<Anchor>%s</Anchor>\n"
+		   "<TokenIdentifier>//apple_ref/c/tag/%s</TokenIdentifier>\n"
+		   "<Abstract>", path, cename, cename);
+      write_description(out, description, "", 1);
+      fputs("</Abstract>\n"
+            "</Token>\n", out);
+
+      for (arg = mxmlFindElement(scut, scut, "constant", NULL, NULL,
+                        	 MXML_DESCEND_FIRST);
+	   arg;
+	   arg = mxmlFindElement(arg, scut, "constant", NULL, NULL,
+                        	 MXML_NO_DESCEND))
+      {
+        name        = mxmlElementGetAttr(arg, "name");
+	description = mxmlFindElement(arg, arg, "description", NULL,
+                                      NULL, MXML_DESCEND_FIRST);
+	fprintf(out, "<Token>\n"
+		     "<Path>Documentation/%s</Path>\n"
+		     "<Anchor>%s</Anchor>\n"
+		     "<TokenIdentifier>//apple_ref/c/econst/%s</TokenIdentifier>\n"
+		     "<Abstract>", path, cename, name);
+	write_description(out, description, "", 1);
+	fputs("</Abstract>\n"
+	      "</Token>\n", out);
+      }
+
+      scut = find_public(scut, doc, "enumeration");
+    }
+  }
+}
+
+
+/*
+ * 'ws_cb()' - Whitespace callback for saving.
+ */
+
+static const char *			/* O - Whitespace string or NULL for none */
+ws_cb(mxml_node_t *node,		/* I - Element node */
+      int         where)		/* I - Where value */
+{
+  const char *name;			/* Name of element */
+  int	depth;				/* Depth of node */
+  static const char *spaces = "                                        ";
+					/* Whitespace (40 spaces) for indent */
+
+
+  name = node->value.element.name;
+
+  switch (where)
+  {
+    case MXML_WS_BEFORE_CLOSE :
+        if (strcmp(name, "argument") &&
+	    strcmp(name, "class") &&
+	    strcmp(name, "constant") &&
+	    strcmp(name, "enumeration") &&
+	    strcmp(name, "function") &&
+	    strcmp(name, "mxmldoc") &&
+	    strcmp(name, "namespace") &&
+	    strcmp(name, "returnvalue") &&
+	    strcmp(name, "struct") &&
+	    strcmp(name, "typedef") &&
+	    strcmp(name, "union") &&
+	    strcmp(name, "variable"))
+	  return (NULL);
+
+	for (depth = -4; node; node = node->parent, depth += 2);
+	if (depth > 40)
+	  return (spaces);
+	else if (depth < 2)
+	  return (NULL);
+	else
+	  return (spaces + 40 - depth);
+
+    case MXML_WS_AFTER_CLOSE :
+	return ("\n");
+
+    case MXML_WS_BEFORE_OPEN :
+	for (depth = -4; node; node = node->parent, depth += 2);
+	if (depth > 40)
+	  return (spaces);
+	else if (depth < 2)
+	  return (NULL);
+	else
+	  return (spaces + 40 - depth);
+
+    default :
+    case MXML_WS_AFTER_OPEN :
+        if (strcmp(name, "argument") &&
+	    strcmp(name, "class") &&
+	    strcmp(name, "constant") &&
+	    strcmp(name, "enumeration") &&
+	    strcmp(name, "function") &&
+	    strcmp(name, "mxmldoc") &&
+	    strcmp(name, "namespace") &&
+	    strcmp(name, "returnvalue") &&
+	    strcmp(name, "struct") &&
+	    strcmp(name, "typedef") &&
+	    strcmp(name, "union") &&
+	    strcmp(name, "variable") &&
+	    strncmp(name, "?xml", 4))
+	  return (NULL);
+	else
+          return ("\n");
+  }
+}
+
+
+/*
+ * End of "$Id: mxmldoc.c 390 2009-05-05 13:38:00Z mike $".
+ */
diff -Naur mxml-2.6/temp1.xmlfd mxml-2.6-haiku/temp1.xmlfd
--- mxml-2.6/temp1.xmlfd	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/temp1.xmlfd	2009-10-26 02:35:54.000000000 +0000
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<group>
+	<option>
+		<keyword type="opaque">InputSlot</keyword>
+		<default type="opaque">Auto</default>
+		<text>Media Source</text>
+		<order type="real">10.000000</order>
+		<choice>
+			<keyword type="opaque">Auto</keyword>
+			<text>Auto Tray Selection</text>
+			<code type="opaque" />
+		</choice>
+		<choice>
+			<keyword type="opaque">Upper</keyword>
+			<text>Tray 1</text>
+			<code type="opaque">&lt;&lt;/MediaPosition 0&gt;&gt;setpagedevice</code>
+		</choice>
+		<choice>
+			<keyword type="opaque">Lower</keyword>
+			<text>Tray 2</text>
+			<code type="opaque">&lt;&lt;/MediaPosition 1&gt;&gt;setpagedevice</code>
+		</choice>
+	</option>
+	<integer>123</integer>
+	<string>Now is the time for all good men to come to the aid of their
+country.</string>
+	<!-- this is a comment -->
+	<![CDATA[this is CDATA 0123456789ABCDEF]]>
+</group>
diff -Naur mxml-2.6/test/class.cxx mxml-2.6-haiku/test/class.cxx
--- mxml-2.6/test/class.cxx	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test/class.cxx	2008-01-26 23:27:19.000000000 +0000
@@ -0,0 +1,84 @@
+class foo_c : public bar_c		// Foo class derived from bar
+{
+  float	foo;				/* Real number */
+  int	bar;				/* Integer */
+
+  public:
+
+  foo_c(float f, int b);
+  ~foo_c();
+
+  // 'get_bar()' - Get the value of bar.
+  int // O - Value of bar
+  get_bar()
+  {
+    return (bar);
+  }
+
+  // 'get_foo()' - Get the value of foo.
+  float // O - Value of foo
+  get_foo()
+  {
+    return (foo);
+  }
+
+  // 'set_bar()' - Set the value of bar.
+  void
+  set_bar(int b) // I - Value of bar
+  {
+    bar = b;
+  }
+
+  // 'set_foo()' - Set the value of foo.
+  void
+  set_foo(float f) // I - Value of foo
+  {
+    foo = f;
+  }
+
+  // 'set_foobar()' - Set foo and optionally bar (should show default args).
+  void
+  set_foobar(float f, // I - Value of foo
+             int b = 0) // I - Value of bar
+  {
+    foo = f;
+    bar = b;
+  }
+
+  protected:
+
+  static int global;			/* Global integer */
+
+  // 'get_global()' - Get the global integer.
+  int // O - Integer
+  get_global()
+  {
+    return (global);
+  }
+
+  private:
+
+  int barfoo; // Another private integer
+
+  public: 
+
+  // 'get_barfoo()' - Get the barfoo value.
+  int // O - Barfoo value
+  get_barfoo()
+  {
+    return (barfoo);
+  }
+}
+
+// 'foo_c::foo_c()' - Create a foo_c class.
+foo_c::foo_c(float f, // I - Value of foo
+             int b) // I - Value of bar
+{
+  foo = f;
+  bar = b;
+}
+
+// 'foo_c::~foo_c()' - Destroy a foo_c class.
+foo_c::~foo_c()
+{
+}
diff -Naur mxml-2.6/test/dotest.sh mxml-2.6-haiku/test/dotest.sh
--- mxml-2.6/test/dotest.sh	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test/dotest.sh	2008-03-19 21:09:21.000000000 +0000
@@ -0,0 +1,47 @@
+#!/bin/sh
+(cd ..; make mxmldoc-static)
+
+files=""
+mode=""
+
+while test $# -gt 0; do
+	arg="$1"
+	shift
+
+	case "$arg" in
+		-f) framed="--framed framed" ;;
+		-g) mode="gdb" ;;
+		-v) mode="valgrind" ;;
+		*.h | *.c | *.cxx) files="$files $arg" ;;
+		*)
+			echo "Usage: ./dotest.sh [-f] [-g] [-v] [files]"
+			exit 1
+			;;
+	esac
+done
+
+if test "$files" = ""; then
+	files=*.cxx
+fi
+
+rm -f test.xml
+
+case "$mode" in
+	gdb)
+		echo "break malloc_error_break" >.gdbcmds
+		echo "set env DYLD_INSERT_LIBRARIES /usr/lib/libgmalloc.dylib" >>.gdbcmds
+		echo "run $framed test.xml $files >test.html 2>test.log" >>.gdbcmds
+		gdb -x .gdbcmds ../mxmldoc-static
+		;;
+
+	valgrind)
+		valgrind --log-fd=3 --leak-check=yes \
+			../mxmldoc-static $framed test.xml $files \
+			>test.html 2>test.log 3>test.valgrind
+		;;
+
+	*)
+		../mxmldoc-static $framed test.xml $files >test.html 2>test.log
+		;;
+esac
+
diff -Naur mxml-2.6/test/enum.cxx mxml-2.6-haiku/test/enum.cxx
--- mxml-2.6/test/enum.cxx	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test/enum.cxx	2009-05-05 04:43:18.000000000 +0000
@@ -0,0 +1,17 @@
+typedef enum foo_enum_e			/* Sample enumeration type */
+{
+  FOO_ONE,				/* One fish */
+  FOO_TWO,				/* Two fish */
+  FOO_RED,				/* Red fish */
+  FOO_BLUE,				/* Blue fish */
+  FOO_PRIVATE				/* Private fish @private@ */
+} foo_enum_t;
+
+typedef enum foo_enum2_e		/* Sample enumeration type #2 */
+{
+  FOO2_ONE,				/* One fish #2 */
+  FOO2_TWO,				/* Two fish #2 */
+  FOO2_RED,				/* Red fish #2 */
+  FOO2_BLUE,				/* Blue fish #2 */
+  FOO2_PRIVATE				/* Private fish #2 @private@ */
+} foo_enum2_t;
diff -Naur mxml-2.6/test/function.cxx mxml-2.6-haiku/test/function.cxx
--- mxml-2.6/test/function.cxx	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test/function.cxx	2008-01-27 08:01:43.000000000 +0000
@@ -0,0 +1,107 @@
+/*
+ * 'foo_void_function()' - Do foo with bar.
+ *
+ * Use the @link foo_float_function@ or @link foo_int_function@ functions
+ * instead.  Pass @code NULL@ for "three" then there is no string to print.
+ *
+ * @deprecated@
+ */
+
+void
+foo_void_function(int        one,	/* I - Integer */
+                  float      *two,	/* O - Real number */
+                  const char *three)	/* I - String */
+{
+  if (one)
+  {
+    puts("Hello, World!");
+  }
+  else
+    puts(three);
+
+  *two = 2.0f;
+}
+
+
+/*
+ * 'foo_float_function()' - Do foo with bar.
+ *
+ * @since 1.2@
+ */
+
+float					/* O - Real number */
+foo_float_function(int        one,	/* I - Integer */
+                   const char *two)	/* I - String */
+{
+  if (one)
+  {
+    puts("Hello, World!");
+  }
+  else
+    puts(two);
+
+  return (2.0f);
+}
+
+
+/*
+ * 'foo_default_string()' - Do something with a defaulted string arg.
+ */
+
+int					/* O - Integer value */
+foo_default_string(int one,		/* I - Integer */
+                   const char *two = "2")
+					/* I - String */
+{
+  if (one)
+  {
+    puts("Hello, World!");
+  }
+  else
+    puts(two);
+
+  return (2);
+}
+
+
+/*
+ * 'foo_default_int()' - Do something with a defaulted int arg.
+ */
+
+int					/* O - Integer value */
+foo_default_int(int one,		/* I - Integer */
+                int two = 2)		/* I - Integer */
+{
+  if (one)
+  {
+    puts("Hello, World!");
+  }
+  else
+    puts(two);
+
+  return (2);
+}
+
+
+/*
+ * 'foo_void_func()' - Function taking no arguments.
+ */
+
+void
+foo_void_func(void)
+{
+  puts("foo_void_func()");
+}
+
+
+/*
+ * 'foo_private_func()' - Private function.
+ *
+ * @private@
+ */
+
+void
+foo_private_func(void)
+{
+  puts("foo_private_func()");
+}
diff -Naur mxml-2.6/test/functype.cxx mxml-2.6-haiku/test/functype.cxx
--- mxml-2.6/test/functype.cxx	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test/functype.cxx	2005-09-29 02:20:19.000000000 +0000
@@ -0,0 +1 @@
+typedef int (*foo_func_t)(void *foo, int bar);	/**** Foo function type ****/
diff -Naur mxml-2.6/test/struct.cxx mxml-2.6-haiku/test/struct.cxx
--- mxml-2.6/test/struct.cxx	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test/struct.cxx	2008-01-26 20:50:28.000000000 +0000
@@ -0,0 +1,55 @@
+typedef struct foo_s			/* Foo structure */
+{
+  float	foo;				/* Real number */
+  int	bar;				/* Integer */
+
+  foo_s(float f, int b);
+  ~foo_s();
+
+  // 'get_bar()' - Get the value of bar.
+  int // O - Value of bar
+  get_bar()
+  {
+    return (bar);
+  }
+
+  // 'get_foo()' - Get the value of foo.
+  float // O - Value of foo
+  get_foo()
+  {
+    return (foo);
+  }
+
+  // 'set_bar()' - Set the value of bar.
+  void
+  set_bar(int b) // I - Value of bar
+  {
+    bar = b;
+  }
+
+  // 'set_foo()' - Set the value of foo.
+  void
+  set_foo(float f) // I - Value of foo
+  {
+    foo = f;
+  }
+} foo_t;
+
+// 'foo_s::foo_s()' - Create a foo_s structure.
+foo_s::foo_s(float f, // I - Value of foo
+             int b) // I - Value of bar
+{
+  foo = f;
+  bar = b;
+}
+
+// 'foo_s::~foo_s()' - Destroy a foo_s structure.
+foo_s::~foo_s()
+{
+}
+
+typedef struct foo_private_s		/* @private@ */
+{
+  int	a;				/* Value of "a" */
+  char	b[255];				/* Value of "b" */
+} foo_private_t;
diff -Naur mxml-2.6/test/type.cxx mxml-2.6-haiku/test/type.cxx
--- mxml-2.6/test/type.cxx	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test/type.cxx	2005-11-30 15:31:58.000000000 +0000
@@ -0,0 +1,3 @@
+typedef int foo_simple_t;		/* Simple integer type */
+
+typedef int foo_simple_private_t;	/* @private@ */
diff -Naur mxml-2.6/test.xml mxml-2.6-haiku/test.xml
--- mxml-2.6/test.xml	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/test.xml	2005-01-29 17:03:33.000000000 +0000
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<group>
+	<option>
+		<keyword type="opaque">InputSlot</keyword>
+		<default type="opaque">Auto</default>
+		<text>Media Source</text>
+		<order type="real">10.000000</order>
+		<choice>
+			<keyword type="opaque">Auto</keyword>
+			<text>Auto Tray Selection</text>
+			<code type="opaque" />
+		</choice>
+		<choice>
+			<keyword type="opaque">Upper</keyword>
+			<text>Tray 1</text>
+			<code type="opaque">&lt;&lt;/MediaPosition 0&gt;&gt;setpagedevice</code>
+		</choice>
+		<choice>
+			<keyword type="opaque">Lower</keyword>
+			<text>Tray 2</text>
+			<code type="opaque">&lt;&lt;/MediaPosition 1&gt;&gt;setpagedevice</code>
+		</choice>
+	</option>
+	<integer>123</integer>
+	<string>Now is the time for all good men to come to the aid of their
+country.</string>
+	<!-- this is a comment -->
+	<![CDATA[this is CDATA 0123456789ABCDEF]]>
+</group>
diff -Naur mxml-2.6/testmxml.c mxml-2.6-haiku/testmxml.c
--- mxml-2.6/testmxml.c	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/testmxml.c	2009-02-05 06:06:11.000000000 +0000
@@ -0,0 +1,748 @@
+/*
+ * "$Id: testmxml.c 381 2009-02-05 06:06:11Z mike $"
+ *
+ * Test program for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2007 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Contents:
+ *
+ *   main()          - Main entry for test program.
+ *   sax_cb()        - SAX callback.
+ *   type_cb()       - XML data type callback for mxmlLoadFile()...
+ *   whitespace_cb() - Let the mxmlSaveFile() function know when to insert
+ *                     newlines and tabs...
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+#ifndef WIN32
+#  include <unistd.h>
+#endif /* !WIN32 */
+#include <fcntl.h>
+#ifndef O_BINARY
+#  define O_BINARY 0
+#endif /* !O_BINARY */
+
+
+/*
+ * Globals...
+ */
+
+int		event_counts[6];
+
+
+/*
+ * Local functions...
+ */
+
+void		sax_cb(mxml_node_t *node, mxml_sax_event_t event, void *data);
+mxml_type_t	type_cb(mxml_node_t *node);
+const char	*whitespace_cb(mxml_node_t *node, int where);
+
+
+/*
+ * 'main()' - Main entry for test program.
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line args */
+     char *argv[])			/* I - Command-line args */
+{
+  int			i;		/* Looping var */
+  FILE			*fp;		/* File to read */
+  int			fd;		/* File descriptor */
+  mxml_node_t		*tree,		/* XML tree */
+			*node;		/* Node which should be in test.xml */
+  mxml_index_t		*ind;		/* XML index */
+  char			buffer[16384];	/* Save string */
+  static const char	*types[] =	/* Strings for node types */
+			{
+			  "MXML_ELEMENT",
+			  "MXML_INTEGER",
+			  "MXML_OPAQUE",
+			  "MXML_REAL",
+			  "MXML_TEXT"
+			};
+
+
+ /*
+  * Check arguments...
+  */
+
+  if (argc != 2)
+  {
+    fputs("Usage: testmxml filename.xml\n", stderr);
+    return (1);
+  }
+
+ /*
+  * Test the basic functionality...
+  */
+
+  tree = mxmlNewElement(MXML_NO_PARENT, "element");
+
+  if (!tree)
+  {
+    fputs("ERROR: No parent node in basic test!\n", stderr);
+    return (1);
+  }
+
+  if (tree->type != MXML_ELEMENT)
+  {
+    fprintf(stderr, "ERROR: Parent has type %s (%d), expected MXML_ELEMENT!\n",
+            tree->type < MXML_ELEMENT || tree->type > MXML_TEXT ?
+	        "UNKNOWN" : types[tree->type], tree->type);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (strcmp(tree->value.element.name, "element"))
+  {
+    fprintf(stderr, "ERROR: Parent value is \"%s\", expected \"element\"!\n",
+            tree->value.element.name);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlNewInteger(tree, 123);
+  mxmlNewOpaque(tree, "opaque");
+  mxmlNewReal(tree, 123.4f);
+  mxmlNewText(tree, 1, "text");
+
+  mxmlLoadString(tree, "<group type='string'>string string string</group>",
+                 MXML_NO_CALLBACK);
+  mxmlLoadString(tree, "<group type='integer'>1 2 3</group>",
+                 MXML_INTEGER_CALLBACK);
+  mxmlLoadString(tree, "<group type='real'>1.0 2.0 3.0</group>",
+                 MXML_REAL_CALLBACK);
+  mxmlLoadString(tree, "<group>opaque opaque opaque</group>",
+                 MXML_OPAQUE_CALLBACK);
+
+  node = tree->child;
+
+  if (!node)
+  {
+    fputs("ERROR: No first child node in basic test!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (node->type != MXML_INTEGER)
+  {
+    fprintf(stderr, "ERROR: First child has type %s (%d), expected MXML_INTEGER!\n",
+            node->type < MXML_ELEMENT || node->type > MXML_TEXT ?
+	        "UNKNOWN" : types[node->type], node->type);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (node->value.integer != 123)
+  {
+    fprintf(stderr, "ERROR: First child value is %d, expected 123!\n",
+            node->value.integer);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  node = node->next;
+
+  if (!node)
+  {
+    fputs("ERROR: No second child node in basic test!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (node->type != MXML_OPAQUE)
+  {
+    fprintf(stderr, "ERROR: Second child has type %s (%d), expected MXML_OPAQUE!\n",
+            node->type < MXML_ELEMENT || node->type > MXML_TEXT ?
+	        "UNKNOWN" : types[node->type], node->type);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (!node->value.opaque || strcmp(node->value.opaque, "opaque"))
+  {
+    fprintf(stderr, "ERROR: Second child value is \"%s\", expected \"opaque\"!\n",
+            node->value.opaque ? node->value.opaque : "(null)");
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  node = node->next;
+
+  if (!node)
+  {
+    fputs("ERROR: No third child node in basic test!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (node->type != MXML_REAL)
+  {
+    fprintf(stderr, "ERROR: Third child has type %s (%d), expected MXML_REAL!\n",
+            node->type < MXML_ELEMENT || node->type > MXML_TEXT ?
+	        "UNKNOWN" : types[node->type], node->type);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (node->value.real != 123.4f)
+  {
+    fprintf(stderr, "ERROR: Third child value is %f, expected 123.4!\n",
+            node->value.real);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  node = node->next;
+
+  if (!node)
+  {
+    fputs("ERROR: No fourth child node in basic test!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (node->type != MXML_TEXT)
+  {
+    fprintf(stderr, "ERROR: Fourth child has type %s (%d), expected MXML_TEXT!\n",
+            node->type < MXML_ELEMENT || node->type > MXML_TEXT ?
+	        "UNKNOWN" : types[node->type], node->type);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (!node->value.text.whitespace ||
+      !node->value.text.string || strcmp(node->value.text.string, "text"))
+  {
+    fprintf(stderr, "ERROR: Fourth child value is %d,\"%s\", expected 1,\"text\"!\n",
+            node->value.text.whitespace,
+	    node->value.text.string ? node->value.text.string : "(null)");
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  for (i = 0; i < 4; i ++)
+  {
+    node = node->next;
+
+    if (!node)
+    {
+      fprintf(stderr, "ERROR: No group #%d child node in basic test!\n", i + 1);
+      mxmlDelete(tree);
+      return (1);
+    }
+
+    if (node->type != MXML_ELEMENT)
+    {
+      fprintf(stderr, "ERROR: Group child #%d has type %s (%d), expected MXML_ELEMENT!\n",
+              i + 1, node->type < MXML_ELEMENT || node->type > MXML_TEXT ?
+	                 "UNKNOWN" : types[node->type], node->type);
+      mxmlDelete(tree);
+      return (1);
+    }
+  }
+
+ /*
+  * Test indices...
+  */
+
+  ind = mxmlIndexNew(tree, NULL, NULL);
+  if (!ind)
+  {
+    fputs("ERROR: Unable to create index of all nodes!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (ind->num_nodes != 5)
+  {
+    fprintf(stderr, "ERROR: Index of all nodes contains %d "
+                    "nodes; expected 5!\n", ind->num_nodes);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexReset(ind);
+  if (!mxmlIndexFind(ind, "group", NULL))
+  {
+    fputs("ERROR: mxmlIndexFind for \"group\" failed!\n", stderr);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexDelete(ind);
+
+  ind = mxmlIndexNew(tree, "group", NULL);
+  if (!ind)
+  {
+    fputs("ERROR: Unable to create index of groups!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (ind->num_nodes != 4)
+  {
+    fprintf(stderr, "ERROR: Index of groups contains %d "
+                    "nodes; expected 4!\n", ind->num_nodes);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexReset(ind);
+  if (!mxmlIndexEnum(ind))
+  {
+    fputs("ERROR: mxmlIndexEnum failed!\n", stderr);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexDelete(ind);
+
+  ind = mxmlIndexNew(tree, NULL, "type");
+  if (!ind)
+  {
+    fputs("ERROR: Unable to create index of type attributes!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (ind->num_nodes != 3)
+  {
+    fprintf(stderr, "ERROR: Index of type attributes contains %d "
+                    "nodes; expected 3!\n", ind->num_nodes);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexReset(ind);
+  if (!mxmlIndexFind(ind, NULL, "string"))
+  {
+    fputs("ERROR: mxmlIndexFind for \"string\" failed!\n", stderr);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexDelete(ind);
+
+  ind = mxmlIndexNew(tree, "group", "type");
+  if (!ind)
+  {
+    fputs("ERROR: Unable to create index of elements and attributes!\n", stderr);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  if (ind->num_nodes != 3)
+  {
+    fprintf(stderr, "ERROR: Index of elements and attributes contains %d "
+                    "nodes; expected 3!\n", ind->num_nodes);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexReset(ind);
+  if (!mxmlIndexFind(ind, "group", "string"))
+  {
+    fputs("ERROR: mxmlIndexFind for \"string\" failed!\n", stderr);
+    mxmlIndexDelete(ind);
+    mxmlDelete(tree);
+    return (1);
+  }
+
+  mxmlIndexDelete(ind);
+
+ /*
+  * Check the mxmlDelete() works properly...
+  */
+
+  for (i = 0; i < 8; i ++)
+  {
+    if (tree->child)
+      mxmlDelete(tree->child);
+    else
+    {
+      fprintf(stderr, "ERROR: Child pointer prematurely NULL on child #%d\n",
+              i + 1);
+      mxmlDelete(tree);
+      return (1);
+    }
+  }
+
+  if (tree->child)
+  {
+    fputs("ERROR: Child pointer not NULL after deleting all children!\n", stderr);
+    return (1);
+  }
+
+  if (tree->last_child)
+  {
+    fputs("ERROR: Last child pointer not NULL after deleting all children!\n", stderr);
+    return (1);
+  }
+
+  mxmlDelete(tree);
+
+ /*
+  * Open the file...
+  */
+
+  if (argv[1][0] == '<')
+    tree = mxmlLoadString(NULL, argv[1], type_cb);
+  else if ((fp = fopen(argv[1], "rb")) == NULL)
+  {
+    perror(argv[1]);
+    return (1);
+  }
+  else
+  {
+   /*
+    * Read the file...
+    */
+
+    tree = mxmlLoadFile(NULL, fp, type_cb);
+
+    fclose(fp);
+  }
+
+  if (!tree)
+  {
+    fputs("Unable to read XML file!\n", stderr);
+    return (1);
+  }
+
+  if (!strcmp(argv[1], "test.xml"))
+  {
+   /*
+    * Verify that mxmlFindElement() and indirectly mxmlWalkNext() work
+    * properly...
+    */
+
+    if ((node = mxmlFindElement(tree, tree, "choice", NULL, NULL,
+                                MXML_DESCEND)) == NULL)
+    {
+      fputs("Unable to find first <choice> element in XML tree!\n", stderr);
+      mxmlDelete(tree);
+      return (1);
+    }
+
+    if (!mxmlFindElement(node, tree, "choice", NULL, NULL, MXML_NO_DESCEND))
+    {
+      fputs("Unable to find second <choice> element in XML tree!\n", stderr);
+      mxmlDelete(tree);
+      return (1);
+    }
+  }
+
+ /*
+  * Print the XML tree...
+  */
+
+  mxmlSaveFile(tree, stdout, whitespace_cb);
+
+ /*
+  * Save the XML tree to a string and print it...
+  */
+
+  if (mxmlSaveString(tree, buffer, sizeof(buffer), whitespace_cb) > 0)
+    fputs(buffer, stderr);
+
+ /*
+  * Delete the tree...
+  */
+
+  mxmlDelete(tree);
+
+ /*
+  * Read from/write to file descriptors...
+  */
+
+  if (argv[1][0] != '<')
+  {
+   /*
+    * Open the file again...
+    */
+
+    if ((fd = open(argv[1], O_RDONLY | O_BINARY)) < 0)
+    {
+      perror(argv[1]);
+      return (1);
+    }
+
+   /*
+    * Read the file...
+    */
+
+    tree = mxmlLoadFd(NULL, fd, type_cb);
+
+    close(fd);
+
+   /*
+    * Create filename.xmlfd...
+    */
+
+    snprintf(buffer, sizeof(buffer), "%sfd", argv[1]);
+
+    if ((fd = open(buffer, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666)) < 0)
+    {
+      perror(buffer);
+      mxmlDelete(tree);
+      return (1);
+    }
+
+   /*
+    * Write the file...
+    */
+
+    mxmlSaveFd(tree, fd, whitespace_cb);
+
+    close(fd);
+
+   /*
+    * Delete the tree...
+    */
+
+    mxmlDelete(tree);
+  }
+
+ /*
+  * Test SAX methods...
+  */
+
+  memset(event_counts, 0, sizeof(event_counts));
+
+  if (argv[1][0] == '<')
+    mxmlSAXLoadString(NULL, argv[1], type_cb, sax_cb, NULL);
+  else if ((fp = fopen(argv[1], "rb")) == NULL)
+  {
+    perror(argv[1]);
+    return (1);
+  }
+  else
+  {
+   /*
+    * Read the file...
+    */
+
+    mxmlSAXLoadFile(NULL, fp, type_cb, sax_cb, NULL);
+
+    fclose(fp);
+  }
+
+  if (!strcmp(argv[1], "test.xml"))
+  {
+    if (event_counts[MXML_SAX_CDATA] != 1)
+    {
+      fprintf(stderr, "MXML_SAX_CDATA seen %d times, expected 1 times!\n",
+              event_counts[MXML_SAX_CDATA]);
+      return (1);
+    }
+
+    if (event_counts[MXML_SAX_COMMENT] != 1)
+    {
+      fprintf(stderr, "MXML_SAX_COMMENT seen %d times, expected 1 times!\n",
+              event_counts[MXML_SAX_COMMENT]);
+      return (1);
+    }
+
+    if (event_counts[MXML_SAX_DATA] != 61)
+    {
+      fprintf(stderr, "MXML_SAX_DATA seen %d times, expected 61 times!\n",
+              event_counts[MXML_SAX_DATA]);
+      return (1);
+    }
+
+    if (event_counts[MXML_SAX_DIRECTIVE] != 1)
+    {
+      fprintf(stderr, "MXML_SAX_DIRECTIVE seen %d times, expected 1 times!\n",
+              event_counts[MXML_SAX_DIRECTIVE]);
+      return (1);
+    }
+
+    if (event_counts[MXML_SAX_ELEMENT_CLOSE] != 20)
+    {
+      fprintf(stderr, "MXML_SAX_ELEMENT_CLOSE seen %d times, expected 20 times!\n",
+              event_counts[MXML_SAX_ELEMENT_CLOSE]);
+      return (1);
+    }
+
+    if (event_counts[MXML_SAX_ELEMENT_OPEN] != 20)
+    {
+      fprintf(stderr, "MXML_SAX_ELEMENT_OPEN seen %d times, expected 20 times!\n",
+              event_counts[MXML_SAX_ELEMENT_OPEN]);
+      return (1);
+    }
+  }
+
+ /*
+  * Return...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'sax_cb()' - Process nodes via SAX.
+ */
+
+void
+sax_cb(mxml_node_t      *node,		/* I - Current node */
+       mxml_sax_event_t event,		/* I - SAX event */
+       void             *data)		/* I - SAX user data */
+{
+ /*
+  * This SAX callback just counts the different events.
+  */
+
+  event_counts[event] ++;
+}
+
+
+/*
+ * 'type_cb()' - XML data type callback for mxmlLoadFile()...
+ */
+
+mxml_type_t				/* O - Data type */
+type_cb(mxml_node_t *node)		/* I - Element node */
+{
+  const char	*type;			/* Type string */
+
+
+ /*
+  * You can lookup attributes and/or use the element name, hierarchy, etc...
+  */
+
+  if ((type = mxmlElementGetAttr(node, "type")) == NULL)
+    type = node->value.element.name;
+
+  if (!strcmp(type, "integer"))
+    return (MXML_INTEGER);
+  else if (!strcmp(type, "opaque") || !strcmp(type, "pre"))
+    return (MXML_OPAQUE);
+  else if (!strcmp(type, "real"))
+    return (MXML_REAL);
+  else
+    return (MXML_TEXT);
+}
+
+
+/*
+ * 'whitespace_cb()' - Let the mxmlSaveFile() function know when to insert
+ *                     newlines and tabs...
+ */
+
+const char *				/* O - Whitespace string or NULL */
+whitespace_cb(mxml_node_t *node,	/* I - Element node */
+              int         where)	/* I - Open or close tag? */
+{
+  mxml_node_t	*parent;		/* Parent node */
+  int		level;			/* Indentation level */
+  const char	*name;			/* Name of element */
+  static const char *tabs = "\t\t\t\t\t\t\t\t";
+					/* Tabs for indentation */
+
+
+ /*
+  * We can conditionally break to a new line before or after any element.
+  * These are just common HTML elements...
+  */
+
+  name = node->value.element.name;
+
+  if (!strcmp(name, "html") || !strcmp(name, "head") || !strcmp(name, "body") ||
+      !strcmp(name, "pre") || !strcmp(name, "p") ||
+      !strcmp(name, "h1") || !strcmp(name, "h2") || !strcmp(name, "h3") ||
+      !strcmp(name, "h4") || !strcmp(name, "h5") || !strcmp(name, "h6"))
+  {
+   /*
+    * Newlines before open and after close...
+    */
+
+    if (where == MXML_WS_BEFORE_OPEN || where == MXML_WS_AFTER_CLOSE)
+      return ("\n");
+  }
+  else if (!strcmp(name, "dl") || !strcmp(name, "ol") || !strcmp(name, "ul"))
+  {
+   /*
+    * Put a newline before and after list elements...
+    */
+
+    return ("\n");
+  }
+  else if (!strcmp(name, "dd") || !strcmp(name, "dt") || !strcmp(name, "li"))
+  {
+   /*
+    * Put a tab before <li>'s, <dd>'s, and <dt>'s, and a newline after them...
+    */
+
+    if (where == MXML_WS_BEFORE_OPEN)
+      return ("\t");
+    else if (where == MXML_WS_AFTER_CLOSE)
+      return ("\n");
+  }
+  else if (!strncmp(name, "?xml", 4))
+  {
+    if (where == MXML_WS_AFTER_OPEN)
+      return ("\n");
+    else
+      return (NULL);
+  }
+  else if (where == MXML_WS_BEFORE_OPEN ||
+           ((!strcmp(name, "choice") || !strcmp(name, "option")) &&
+	    where == MXML_WS_BEFORE_CLOSE))
+  {
+    for (level = -1, parent = node->parent;
+         parent;
+	 level ++, parent = parent->parent);
+
+    if (level > 8)
+      level = 8;
+    else if (level < 0)
+      level = 0;
+
+    return (tabs + 8 - level);
+  }
+  else if (where == MXML_WS_AFTER_CLOSE ||
+           ((!strcmp(name, "group") || !strcmp(name, "option") ||
+	     !strcmp(name, "choice")) &&
+            where == MXML_WS_AFTER_OPEN))
+    return ("\n");
+  else if (where == MXML_WS_AFTER_OPEN && !node->child)
+    return ("\n");
+
+ /*
+  * Return NULL for no added whitespace...
+  */
+
+  return (NULL);
+}
+
+
+/*
+ * End of "$Id: testmxml.c 381 2009-02-05 06:06:11Z mike $".
+ */
diff -Naur mxml-2.6/vcnet/config.h mxml-2.6-haiku/vcnet/config.h
--- mxml-2.6/vcnet/config.h	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/vcnet/config.h	2009-04-18 17:05:52.000000000 +0000
@@ -0,0 +1,125 @@
+/*
+ * "$Id: config.h 387 2009-04-18 17:05:52Z mike $"
+ *
+ * Configuration file for Mini-XML, a small XML-like file parsing library.
+ *
+ * Copyright 2003-2009 by Michael Sweet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Beginning with VC2005, Microsoft breaks ISO C and POSIX conformance
+ * by deprecating a number of functions in the name of security, even
+ * when many of the affected functions are otherwise completely secure.
+ * The _CRT_SECURE_NO_DEPRECATE definition ensures that we won't get
+ * warnings from their use...
+ *
+ * Then Microsoft decided that they should ignore this in VC2008 and use
+ * yet another define (_CRT_SECURE_NO_WARNINGS) instead.  Bastards.
+ */
+
+#define _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_WARNINGS
+
+
+/*
+ * Include necessary headers...
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <io.h>
+
+
+/*
+ * Microsoft also renames the POSIX functions to _name, and introduces
+ * a broken compatibility layer using the original names.  As a result,
+ * random crashes can occur when, for example, strdup() allocates memory
+ * from a different heap than used by malloc() and free().
+ *
+ * To avoid moronic problems like this, we #define the POSIX function
+ * names to the corresponding non-standard Microsoft names.
+ */
+
+#define close		_close
+#define open		_open
+#define read	        _read
+#define snprintf 	_snprintf
+#define strdup		_strdup
+#define vsnprintf 	_vsnprintf
+#define write		_write
+
+
+/*
+ * Version number...
+ */
+
+#define MXML_VERSION "Mini-XML v2.6"
+
+
+/*
+ * Inline function support...
+ */
+
+#define inline _inline
+
+
+/*
+ * Long long support...
+ */
+
+#define HAVE_LONG_LONG 1
+
+
+/*
+ * Do we have the snprintf() and vsnprintf() functions?
+ */
+
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+
+
+/*
+ * Do we have the strXXX() functions?
+ */
+
+#define HAVE_STRDUP 1
+
+
+/*
+ * Define prototypes for string functions as needed...
+ */
+
+#  ifndef HAVE_STRDUP
+extern char	*_mxml_strdup(const char *);
+#    define strdup _mxml_strdup
+#  endif /* !HAVE_STRDUP */
+
+extern char	*_mxml_strdupf(const char *, ...);
+extern char	*_mxml_vstrdupf(const char *, va_list);
+
+#  ifndef HAVE_SNPRINTF
+extern int	_mxml_snprintf(char *, size_t, const char *, ...);
+#    define snprintf _mxml_snprintf
+#  endif /* !HAVE_SNPRINTF */
+
+#  ifndef HAVE_VSNPRINTF
+extern int	_mxml_vsnprintf(char *, size_t, const char *, va_list);
+#    define vsnprintf _mxml_vsnprintf
+#  endif /* !HAVE_VSNPRINTF */
+
+/*
+ * End of "$Id: config.h 387 2009-04-18 17:05:52Z mike $".
+ */
diff -Naur mxml-2.6/vcnet/mxml.sln mxml-2.6-haiku/vcnet/mxml.sln
--- mxml-2.6/vcnet/mxml.sln	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/vcnet/mxml.sln	2009-05-17 16:10:38.000000000 +0000
@@ -0,0 +1,37 @@
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mxmldoc", "mxmldoc.vcproj", "{D909892E-520A-4322-9A47-DAEBDA9CC7A7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{E5AA9476-9751-4654-8109-B1A2112D5E73} = {E5AA9476-9751-4654-8109-B1A2112D5E73}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mxml1", "mxml1.vcproj", "{E5AA9476-9751-4654-8109-B1A2112D5E73}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testmxml", "testmxml.vcproj", "{75CAC6C4-A6BC-4935-A3C9-8F0AE0744227}"
+	ProjectSection(ProjectDependencies) = postProject
+		{E5AA9476-9751-4654-8109-B1A2112D5E73} = {E5AA9476-9751-4654-8109-B1A2112D5E73}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{D909892E-520A-4322-9A47-DAEBDA9CC7A7}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D909892E-520A-4322-9A47-DAEBDA9CC7A7}.Debug|Win32.Build.0 = Debug|Win32
+		{D909892E-520A-4322-9A47-DAEBDA9CC7A7}.Release|Win32.ActiveCfg = Release|Win32
+		{D909892E-520A-4322-9A47-DAEBDA9CC7A7}.Release|Win32.Build.0 = Release|Win32
+		{E5AA9476-9751-4654-8109-B1A2112D5E73}.Debug|Win32.ActiveCfg = Debug|Win32
+		{E5AA9476-9751-4654-8109-B1A2112D5E73}.Debug|Win32.Build.0 = Debug|Win32
+		{E5AA9476-9751-4654-8109-B1A2112D5E73}.Release|Win32.ActiveCfg = Release|Win32
+		{E5AA9476-9751-4654-8109-B1A2112D5E73}.Release|Win32.Build.0 = Release|Win32
+		{75CAC6C4-A6BC-4935-A3C9-8F0AE0744227}.Debug|Win32.ActiveCfg = Debug|Win32
+		{75CAC6C4-A6BC-4935-A3C9-8F0AE0744227}.Debug|Win32.Build.0 = Debug|Win32
+		{75CAC6C4-A6BC-4935-A3C9-8F0AE0744227}.Release|Win32.ActiveCfg = Release|Win32
+		{75CAC6C4-A6BC-4935-A3C9-8F0AE0744227}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -Naur mxml-2.6/vcnet/mxml1.def mxml-2.6-haiku/vcnet/mxml1.def
--- mxml-2.6/vcnet/mxml1.def	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/vcnet/mxml1.def	2007-12-06 06:07:50.000000000 +0000
@@ -0,0 +1,59 @@
+LIBRARY "MXML1"
+EXPORTS
+ _mxml_strdupf
+ _mxml_vstrdupf
+ mxml_ignore_cb
+ mxml_integer_cb
+ mxml_opaque_cb
+ mxml_real_cb
+ mxmlAdd
+ mxmlDelete
+ mxmlElementDeleteAttr
+ mxmlElementGetAttr
+ mxmlElementSetAttr
+ mxmlElementSetAttrf
+ mxmlEntityAddCallback
+ mxmlEntityGetName
+ mxmlEntityGetValue
+ mxmlEntityRemoveCallback
+ mxmlFindElement
+ mxmlIndexDelete
+ mxmlIndexEnum
+ mxmlIndexFind
+ mxmlIndexNew
+ mxmlIndexReset
+ mxmlLoadFd
+ mxmlLoadFile
+ mxmlLoadString
+ mxmlNewCDATA
+ mxmlNewCustom
+ mxmlNewElement
+ mxmlNewInteger
+ mxmlNewOpaque
+ mxmlNewReal
+ mxmlNewText
+ mxmlNewTextf
+ mxmlNewXML
+ mxmlRelease
+ mxmlRemove
+ mxmlRetain
+ mxmlSaveAllocString
+ mxmlSaveFd
+ mxmlSaveFile
+ mxmlSaveString
+ mxmlSAXLoadFd
+ mxmlSAXLoadFile
+ mxmlSAXLoadString
+ mxmlSetCDATA
+ mxmlSetCustom
+ mxmlSetCustomHandlers
+ mxmlSetElement
+ mxmlSetErrorCallback
+ mxmlSetInteger
+ mxmlSetOpaque
+ mxmlSetReal
+ mxmlSetText
+ mxmlSetTextf
+ mxmlSetWrapMargin
+ mxmlWalkNext
+ mxmlWalkPrev
diff -Naur mxml-2.6/vcnet/mxml1.vcproj mxml-2.6-haiku/vcnet/mxml1.vcproj
--- mxml-2.6/vcnet/mxml1.vcproj	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/vcnet/mxml1.vcproj	2008-10-26 19:44:57.000000000 +0000
@@ -0,0 +1,255 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="mxml1"
+	ProjectGUID="{E5AA9476-9751-4654-8109-B1A2112D5E73}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\vcnet;.."
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;MXML1_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="1"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="mxml1.dll"
+				LinkIncremental="2"
+				IgnoreDefaultLibraryNames="oldnames.lib"
+				ModuleDefinitionFile=".\mxml1.def"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/mxml1.pdb"
+				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				ImportLibrary="mxml1.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..\vcnet;.."
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;MXML1_EXPORTS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="1"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="mxml1.dll"
+				LinkIncremental="1"
+				IgnoreDefaultLibraryNames="oldnames.lib"
+				ModuleDefinitionFile=".\mxml1.def"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				ImportLibrary="mxml1.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\mxml-attr.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-entity.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-file.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-index.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-node.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-private.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-search.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-set.c"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-string.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\vcnet\config.h"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml-private.h"
+				>
+			</File>
+			<File
+				RelativePath="..\mxml.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\mxml1.def"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur mxml-2.6/vcnet/mxmldoc.vcproj mxml-2.6-haiku/vcnet/mxmldoc.vcproj
--- mxml-2.6/vcnet/mxmldoc.vcproj	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/vcnet/mxmldoc.vcproj	2008-10-26 19:44:57.000000000 +0000
@@ -0,0 +1,203 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="mxmldoc"
+	ProjectGUID="{D909892E-520A-4322-9A47-DAEBDA9CC7A7}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../vcnet,.."
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../mxmldoc.exe"
+				LinkIncremental="2"
+				IgnoreDefaultLibraryNames="oldnames.lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/mxmldoc.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../vcnet,.."
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../mxmldoc.exe"
+				LinkIncremental="1"
+				IgnoreDefaultLibraryNames="oldnames.lib"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\mxmldoc.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur mxml-2.6/vcnet/testmxml.vcproj mxml-2.6-haiku/vcnet/testmxml.vcproj
--- mxml-2.6/vcnet/testmxml.vcproj	1970-01-01 00:00:00.000000000 +0000
+++ mxml-2.6-haiku/vcnet/testmxml.vcproj	2008-10-26 19:44:57.000000000 +0000
@@ -0,0 +1,203 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="testmxml"
+	ProjectGUID="{75CAC6C4-A6BC-4935-A3C9-8F0AE0744227}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../vcnet,.."
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../testmxml.exe"
+				LinkIncremental="2"
+				IgnoreDefaultLibraryNames="oldnames.lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/testmxml.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../vcnet,.."
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="../testmxml.exe"
+				LinkIncremental="1"
+				IgnoreDefaultLibraryNames="oldnames.lib"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\testmxml.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
