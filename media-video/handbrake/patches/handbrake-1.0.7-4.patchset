From: Ken Mays <kmays2000@gmail.com>
Date: Fri Aug 10 13:01:42 GMT 2018 
Subject: fix for FFmpeg 4.x dependency


--- HandBrake-1.0.7/libhb/encavcodec.c.old	2018-08-10 11:50:45.138674176 +0000
+++ HandBrake-1.0.7/libhb/encavcodec.c	2018-08-10 11:52:56.821559296 +0000
@@ -235,7 +235,7 @@
         /* Constant quantizer */
         // These settings produce better image quality than
         // what was previously used
-        context->flags |= CODEC_FLAG_QSCALE;
+        context->flags |= AV_CODEC_FLAG_QSCALE;
         context->global_quality = FF_QP2LAMBDA * job->vquality + 0.5;
         //Set constant quality for libvpx
         if ( w->codec_param == AV_CODEC_ID_VP8 ||
@@ -278,11 +278,11 @@
 
     if( job->mux & HB_MUX_MASK_MP4 )
     {
-        context->flags |= CODEC_FLAG_GLOBAL_HEADER;
+        context->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
     }
     if( job->grayscale )
     {
-        context->flags |= CODEC_FLAG_GRAY;
+        context->flags |= AV_CODEC_FLAG_GRAY;
     }
 
     if( job->pass_id == HB_PASS_ENCODE_1ST ||
@@ -302,7 +302,7 @@
                 ret = 1;
                 goto done;
             }
-            context->flags |= CODEC_FLAG_PASS1;
+            context->flags |= AV_CODEC_FLAG_PASS1;
         }
         else
         {
@@ -341,7 +341,7 @@
             fclose( pv->file );
             pv->file = NULL;
 
-            context->flags    |= CODEC_FLAG_PASS2;
+            context->flags    |= AV_CODEC_FLAG_PASS2;
             context->stats_in  = log;
         }
     }
--- HandBrake-1.0.7/libhb/muxavformat.c.old	2018-08-10 11:54:00.651165696 +0000
+++ HandBrake-1.0.7/libhb/muxavformat.c	2018-08-10 11:58:45.343408640 +0000
@@ -220,7 +220,7 @@
             /* Taken from x264 muxers.c */
             priv_size = 5 + 1 + 2 + job->config.h264.sps_length + 1 + 2 +
                         job->config.h264.pps_length;
-            priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (priv_data == NULL)
             {
                 hb_error("H.264 extradata: malloc failure");
@@ -256,7 +256,7 @@
             if (job->config.mpeg4.length != 0)
             {
                 priv_size = job->config.mpeg4.length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("MPEG4 extradata: malloc failure");
@@ -272,7 +272,7 @@
             if (job->config.mpeg4.length != 0)
             {
                 priv_size = job->config.mpeg4.length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("MPEG2 extradata: malloc failure");
@@ -308,7 +308,7 @@
             }
 
             priv_size = size;
-            priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (priv_data == NULL)
             {
                 hb_error("Theora extradata: malloc failure");
@@ -336,7 +336,7 @@
             if (job->config.h265.headers_length > 0)
             {
                 priv_size = job->config.h265.headers_length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("H.265 extradata: malloc failure");
@@ -447,7 +447,7 @@
                 }
 
                 priv_size = size;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("Vorbis extradata: malloc failure");
@@ -470,7 +470,7 @@
                 if (audio->priv.config.extradata.length)
                 {
                     priv_size = audio->priv.config.extradata.length;
-                    priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                    priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                     if (priv_data == NULL)
                     {
                         hb_error("OPUS extradata: malloc failure");
@@ -488,7 +488,7 @@
                 if (audio->priv.config.extradata.length)
                 {
                     priv_size = audio->priv.config.extradata.length;
-                    priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                    priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                     if (priv_data == NULL)
                     {
                         hb_error("FLAC extradata: malloc failure");
@@ -514,7 +514,7 @@
                 //
                 // So allocate extra bytes
                 priv_size = audio->priv.config.extradata.length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("AAC extradata: malloc failure");
@@ -755,7 +755,7 @@
                         rgb[12], rgb[13], rgb[14], rgb[15]);
 
                 priv_size = len + 1;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("VOBSUB extradata: malloc failure");
@@ -788,7 +788,7 @@
                     if (subtitle->extradata_size)
                     {
                         priv_size = subtitle->extradata_size;
-                        priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                        priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                         if (priv_data == NULL)
                         {
                             hb_error("SSA extradata: malloc failure");
@@ -838,7 +838,7 @@
             properties[17] = width & 0xff;
 
             priv_size = sizeof(properties);
-            priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (priv_data == NULL)
             {
                 hb_error("TX3G extradata: malloc failure");
@@ -895,7 +895,7 @@
                 }
 
                 priv_size = attachment->size;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("Font extradata: malloc failure");
@@ -1445,7 +1445,7 @@
 
                     priv_size = audio->priv.config.extradata.length;
                     priv_data = av_realloc(st->codecpar->extradata, priv_size +
-                                           FF_INPUT_BUFFER_PADDING_SIZE);
+                                           AV_INPUT_BUFFER_PADDING_SIZE);
                     if (priv_data == NULL)
                     {
                         break;
--- HandBrake-1.0.7/libhb/decavcodec.c.old	2018-08-10 12:00:22.051380224 +0000
+++ HandBrake-1.0.7/libhb/decavcodec.c	2018-08-10 12:02:05.595853312 +0000
@@ -1563,7 +1563,7 @@
             {
                 pv->context->extradata_size = size;
                 pv->context->extradata =
-                                av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);
+                                av_malloc(size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (pv->context->extradata == NULL)
                     return 1;
                 memcpy(pv->context->extradata, in->data, size);
--- HandBrake-1.0.7/libhb/encavcodecaudio.c.old	2018-08-10 12:04:20.422313984 +0000
+++ HandBrake-1.0.7/libhb/encavcodecaudio.c	2018-08-10 12:13:51.791150592 +0000
@@ -174,7 +174,7 @@
     else if (audio->config.out.quality >= 0)
     {
         context->global_quality = audio->config.out.quality * FF_QP2LAMBDA;
-        context->flags |= CODEC_FLAG_QSCALE;
+        context->flags |= AV_CODEC_FLAG_QSCALE;
         if (audio->config.out.codec == HB_ACODEC_FDK_AAC ||
             audio->config.out.codec == HB_ACODEC_FDK_HAAC)
         {
@@ -193,7 +193,7 @@
     // so that it fills extradata with global header information.
     // If this flag is not set, it inserts the data into each
     // packet instead.
-    context->flags |= CODEC_FLAG_GLOBAL_HEADER;
+    context->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 
     if (hb_avcodec_open(context, codec, &av_opts, 0))
     {
@@ -216,7 +216,7 @@
     pv->input_buf         = malloc(pv->input_samples * sizeof(float));
     // Some encoders in libav (e.g. fdk-aac) fail if the output buffer
     // size is not some minumum value.  8K seems to be enough :(
-    pv->max_output_bytes  = MAX(FF_MIN_BUFFER_SIZE,
+    pv->max_output_bytes  = MAX(AV_INPUT_BUFFER_MIN_SIZE,
                                 (pv->input_samples *
                                  av_get_bytes_per_sample(context->sample_fmt)));
 
--- HandBrake-1.0.7/libhb/hb.c.old	2018-08-10 12:15:17.572522496 +0000
+++ HandBrake-1.0.7/libhb/hb.c	2018-08-10 12:15:58.936640512 +0000
@@ -133,7 +133,7 @@
         avctx->thread_count = 1;
     }
 
-    if (codec->capabilities & CODEC_CAP_EXPERIMENTAL)
+    if (codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL)
     {
         // "experimental" encoders will not open without this
         avctx->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
