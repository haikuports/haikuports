From 765c940b22eadef31f5916de07b62ef5e8a973ef Mon Sep 17 00:00:00 2001
From: Humdinger <humdingerb@gmail.com>
Date: Fri, 20 Jan 2017 19:56:14 +0100
Subject: undef PAGESIZE on HAIKU


diff --git a/src/main/curve.c b/src/main/curve.c
index 2aeb15e..83efd76 100644
--- a/src/main/curve.c
+++ b/src/main/curve.c
@@ -30,6 +30,7 @@
 #include <ieeefp.h>
 #endif
 #include <string.h>
+#include <strings.h>
 #include <stdlib.h>
 #include <limits.h>
 #include <unistd.h>
diff --git a/src/main/escp2-papers.c b/src/main/escp2-papers.c
index 19d1b98..3580842 100644
--- a/src/main/escp2-papers.c
+++ b/src/main/escp2-papers.c
@@ -22,6 +22,7 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
+#include <strings.h>
 #include <gutenprint/gutenprint.h>
 #include "gutenprint-internal.h"
 #include <gutenprint/gutenprint-intl-internal.h>
diff --git a/src/main/print-ps.c b/src/main/print-ps.c
index 751424d..2838983 100644
--- a/src/main/print-ps.c
+++ b/src/main/print-ps.c
@@ -32,6 +32,7 @@
 #include "gutenprint-internal.h"
 #include <time.h>
 #include <string.h>
+#include <strings.h>
 #include <math.h>
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
diff --git a/src/testpattern/testpatternl.l b/src/testpattern/testpatternl.l
index 31d6197..27d0998 100644
--- a/src/testpattern/testpatternl.l
+++ b/src/testpattern/testpatternl.l
@@ -27,6 +27,9 @@
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef __HAIKU__
+#undef PAGESIZE
+#endif
 #include "testpattern.h"
 
 #pragma GCC diagnostic ignored "-Wredundant-decls"
diff --git a/src/testpattern/testpatterny.y b/src/testpattern/testpatterny.y
index 4678949..d2ab025 100644
--- a/src/testpattern/testpatterny.y
+++ b/src/testpattern/testpatterny.y
@@ -28,6 +28,9 @@
 #include <strings.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef __HAIKU__
+#undef PAGESIZE
+#endif
 #include "testpattern.h"
 
 extern int mylineno;
-- 
2.37.3


From f8f39c3abf84031ed4a308985c2574acb74fb077 Mon Sep 17 00:00:00 2001
From: Adrien Destugues <pulkomandy@pulkomandy.tk>
Date: Sat, 1 Apr 2017 15:24:54 +0200
Subject: Make gcc2 happy.


diff --git a/src/main/print-canon.c b/src/main/print-canon.c
index 2dc443b..0dffa4c 100644
--- a/src/main/print-canon.c
+++ b/src/main/print-canon.c
@@ -3833,7 +3833,6 @@ canon_init_setPageMargins2(const stp_vars_t *v, canon_privdata_t *init)
      rather than calculated.
   */
   unsigned char arg_ESCP_1 = (init->pt) ? canon_size_type(v,init->caps) : 0x03; /* default size A4 */
-  stp_dprintf(STP_DBG_CANON, v,"setPageMargins2: arg_ESCP_1 = '%x'\n",arg_ESCP_1);
 
   /* TOFIX: what exactly is to be sent?
    * Is it the printable length or the bottom border?
@@ -3847,6 +3846,7 @@ canon_init_setPageMargins2(const stp_vars_t *v, canon_privdata_t *init)
   const char* input_slot = stp_get_string_parameter(v, "InputSlot");
   int print_cd = (input_slot && (!strcmp(input_slot, "CD")));
 
+  stp_dprintf(STP_DBG_CANON, v,"setPageMargins2: arg_ESCP_1 = '%x'\n",arg_ESCP_1);
   stp_dprintf(STP_DBG_CANON, v,"setPageMargins2: print_cd = %d\n",print_cd);
 
   test_cd = 1;
-- 
2.37.3


From d09ab769548944b1341912a7e772f090dff8f04e Mon Sep 17 00:00:00 2001
From: Schrijvers Luc <Begasus@users.noreply.github.com>
Date: Mon, 21 May 2018 07:42:56 +0200
Subject: Make gcc2 happy, suite.


diff --git a/src/main/channel.c b/src/main/channel.c
index 6cd4ca9..a19d6a7 100644
--- a/src/main/channel.c
+++ b/src/main/channel.c
@@ -1201,6 +1201,7 @@ stp_channel_get_output_8bit(const stp_vars_t *v)
   if (! cg->output_data_8bit)
     cg->output_data_8bit = stp_malloc(sizeof(unsigned char) *
 				      cg->total_channels * cg->width);
+  {
   int i;
   (void) memset(cg->output_data_8bit, 0, sizeof(unsigned char) *
 		cg->total_channels * cg->width);
@@ -1208,4 +1209,5 @@ stp_channel_get_output_8bit(const stp_vars_t *v)
     cg->output_data_8bit[i] = cg->output_data[i] / (unsigned short) 257;
   cg->valid_8bit = 1;
   return cg->output_data_8bit;
+  }
 }
-- 
2.37.3


From be2bcdbcf5d11bba7045972234a04025862259f3 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Sun, 14 Apr 2019 20:56:21 +0200
Subject: gcc2 patch for 5.3.1


diff --git a/src/main/color-conversions.c b/src/main/color-conversions.c
index e5a31a8..bc24618 100644
--- a/src/main/color-conversions.c
+++ b/src/main/color-conversions.c
@@ -380,6 +380,9 @@ color_##bits##_to_color(const stp_vars_t *vars, const unsigned char *in, \
   int bright_color_adjustment = 0;					\
   int hue_only_color_adjustment = 0;					\
   int do_user_adjustment = 0;						\
+  const double *hue_map;							\
+  const double *lum_map;							\
+  const double *sat_map;							\
   if (lut->color_correction->correction == COLOR_CORRECTION_BRIGHT)	\
     bright_color_adjustment = 1;					\
   if (lut->color_correction->correction == COLOR_CORRECTION_HUE)	\
@@ -408,9 +411,9 @@ color_##bits##_to_color(const stp_vars_t *vars, const unsigned char *in, \
   (void) stp_curve_cache_get_double_data(&(lut->hue_map));		\
   (void) stp_curve_cache_get_double_data(&(lut->lum_map));		\
   (void) stp_curve_cache_get_double_data(&(lut->sat_map));		\
-  const double *hue_map = CURVE_CACHE_FAST_DOUBLE(&(lut->hue_map));	\
-  const double *lum_map = CURVE_CACHE_FAST_DOUBLE(&(lut->lum_map));	\
-  const double *sat_map = CURVE_CACHE_FAST_DOUBLE(&(lut->sat_map));	\
+  hue_map = CURVE_CACHE_FAST_DOUBLE(&(lut->hue_map));	\
+  lum_map = CURVE_CACHE_FAST_DOUBLE(&(lut->lum_map));	\
+  sat_map = CURVE_CACHE_FAST_DOUBLE(&(lut->sat_map));	\
 									\
   if (split_saturation)							\
     ssat = sqrt(ssat);							\
@@ -485,6 +488,9 @@ color_##bits##_to_kcmy(const stp_vars_t *vars, const unsigned char *in,	\
   int bright_color_adjustment = 0;					\
   int hue_only_color_adjustment = 0;					\
   int do_user_adjustment = 0;						\
+  const double *hue_map;							\
+  const double *lum_map;							\
+  const double *sat_map;							\
   if (lut->color_correction->correction == COLOR_CORRECTION_BRIGHT)	\
     bright_color_adjustment = 1;					\
   if (lut->color_correction->correction == COLOR_CORRECTION_HUE)	\
@@ -514,9 +520,9 @@ color_##bits##_to_kcmy(const stp_vars_t *vars, const unsigned char *in,	\
   (void) stp_curve_cache_get_double_data(&(lut->hue_map));		\
   (void) stp_curve_cache_get_double_data(&(lut->lum_map));		\
   (void) stp_curve_cache_get_double_data(&(lut->sat_map));		\
-  const double *hue_map = CURVE_CACHE_FAST_DOUBLE(&(lut->hue_map));	\
-  const double *lum_map = CURVE_CACHE_FAST_DOUBLE(&(lut->lum_map));	\
-  const double *sat_map = CURVE_CACHE_FAST_DOUBLE(&(lut->sat_map));	\
+  hue_map = CURVE_CACHE_FAST_DOUBLE(&(lut->hue_map));	\
+  lum_map = CURVE_CACHE_FAST_DOUBLE(&(lut->lum_map));	\
+  sat_map = CURVE_CACHE_FAST_DOUBLE(&(lut->sat_map));	\
 									\
   if (split_saturation)							\
     ssat = sqrt(ssat);							\
diff --git a/src/main/escp2-channels.c b/src/main/escp2-channels.c
index 9e3b4e7..30b3c5f 100644
--- a/src/main/escp2-channels.c
+++ b/src/main/escp2-channels.c
@@ -408,9 +408,9 @@ load_inkgroup(const char *name)
       stp_mxml_node_t *node =
 	stp_xml_parse_file_from_path_uncached_safe(name, "escp2InkGroup", NULL);
       stp_mxml_node_t *child = node->child;
+      size_t count = 0;
       igl = stp_zalloc(sizeof(inkgroup_t));
       stp_refcache_add_item("escpInkgroup", name, igl);
-      size_t count = 0;
       while (child)
 	{
 	  if (child->type == STP_MXML_ELEMENT &&
diff --git a/src/main/print-escp2-data.c b/src/main/print-escp2-data.c
index 6e580d9..fdaa1ff 100644
--- a/src/main/print-escp2-data.c
+++ b/src/main/print-escp2-data.c
@@ -410,9 +410,10 @@ void
 stpi_escp2_load_model(const stp_vars_t *v, int model)
 {
   char buf[MAXPATHLEN+1];
+  int model_id_from_file;
   stp_xml_init();
   snprintf(buf, MAXPATHLEN, "escp2/model/model_%d.xml", model);
-  int model_id_from_file = load_model_from_file(v, buf, 0);
+  model_id_from_file = load_model_from_file(v, buf, 0);
   stp_xml_exit();
   STPI_ASSERT(model_id_from_file == model, v);
 }
diff --git a/src/main/print-escp2.c b/src/main/print-escp2.c
index f76563b..d321320 100644
--- a/src/main/print-escp2.c
+++ b/src/main/print-escp2.c
@@ -2247,8 +2247,9 @@ escp2_parameters(const stp_vars_t *v, const char *name,
 		 stp_parameter_t *description)
 {
   int		i;
+  int found;
   description->p_type = STP_PARAMETER_TYPE_INVALID;
-  int found = 0;
+  found = 0;
   if (name == NULL)
     return;
 
@@ -4517,6 +4518,7 @@ escp2_do_print(stp_vars_t *v, stp_image_t *image, int print_op)
   int i;
 
   escp2_privdata_t *pd;
+  int page_number;
 
   if (strcmp(stp_get_string_parameter(v, "PrintingMode"), "BW") == 0 &&
       (stp_get_string_parameter(v, "InkType") &&
@@ -4543,7 +4545,7 @@ escp2_do_print(stp_vars_t *v, stp_image_t *image, int print_op)
   if (strcmp(stp_get_string_parameter(v, "InputImageType"), "Raw") == 0 &&
       !set_raw_ink_type(v))
     return 0;
-  int page_number = stp_get_int_parameter(v, "PageNumber");
+  page_number = stp_get_int_parameter(v, "PageNumber");
 
   pd = (escp2_privdata_t *) stp_zalloc(sizeof(escp2_privdata_t));
 
diff --git a/src/main/print-papers.c b/src/main/print-papers.c
index c457295..737c023 100644
--- a/src/main/print-papers.c
+++ b/src/main/print-papers.c
@@ -468,6 +468,8 @@ stpi_get_papersize_list_named(const char *name, const char *file)
   else
     {
       char buf[MAXPATHLEN+1];
+      stp_mxml_node_t *node;
+      const char *stmp;
       stp_deprintf(STP_DBG_PAPER, "Loading paper list %s from %s\n",
 		   name, file ? file : "(null)");
       if (! file)
@@ -476,9 +478,9 @@ stpi_get_papersize_list_named(const char *name, const char *file)
 	(void) snprintf(buf, MAXPATHLEN, "papers/%s.xml", name);
       else
 	strncpy(buf, file, MAXPATHLEN);
-      stp_mxml_node_t *node =
+      node =
 	stp_xml_parse_file_from_path_safe(buf, "paperdef", NULL);
-      const char *stmp = stp_mxmlElementGetAttr(node, "name");
+      stmp = stp_mxmlElementGetAttr(node, "name");
       STPI_ASSERT(stmp && !strcmp(name, stmp), NULL);
       impl = stp_malloc(sizeof(papersize_list_impl_t));
       impl->name = stp_strdup(name);
diff --git a/src/main/print-util.c b/src/main/print-util.c
index 1119484..56171b4 100644
--- a/src/main/print-util.c
+++ b/src/main/print-util.c
@@ -338,10 +338,11 @@ void
 stp_eprintf(const stp_vars_t *v, const char *format, ...)
 {
   int bytes;
+  void * errdata;
   stp_outfunc_t errfunc = stp_get_errfunc(v);
   if (! errfunc)
     errfunc = global_errfunc;
-  void * errdata = stp_get_errdata(v);
+  errdata = stp_get_errdata(v);
   if (! errdata)
     errdata = global_errdata;
   if (errfunc)
@@ -424,6 +425,7 @@ stp_dprintf(unsigned long level, const stp_vars_t *v, const char *format, ...)
   stpi_init_debug();
   if (level & stpi_debug_level)
     {
+      void *dbgdata;
       stp_outfunc_t dbgfunc = stp_get_dbgfunc(v);
       if (! dbgfunc)
 	dbgfunc = global_dbgfunc;
@@ -431,7 +433,7 @@ stp_dprintf(unsigned long level, const stp_vars_t *v, const char *format, ...)
 	dbgfunc = stp_get_errfunc(v);
       if (! dbgfunc)
 	dbgfunc = global_errfunc;
-      void *dbgdata = stp_get_dbgdata(v);
+      dbgdata = stp_get_dbgdata(v);
       if (! dbgdata)
 	dbgdata = global_dbgdata;
       if (! dbgdata)
diff --git a/src/main/printers.c b/src/main/printers.c
index 0a35ca0..9ab844f 100644
--- a/src/main/printers.c
+++ b/src/main/printers.c
@@ -503,12 +503,14 @@ stp_describe_output(const stp_vars_t *v)
 int
 stp_verify(stp_vars_t *v)
 {
+  const stp_printfuncs_t *printfuncs;
+  stp_vars_t *nv;
+  int status;
   if (stp_get_verified(v))
     return 1;
-  const stp_printfuncs_t *printfuncs =
+  printfuncs =
     stpi_get_printfuncs(stp_get_printer(v));
-  stp_vars_t *nv = stp_vars_create_copy(v);
-  int status;
+  nv = stp_vars_create_copy(v);
   stp_prune_inactive_options(nv);
   status = (printfuncs->verify)(nv);
   stp_set_verified(v, stp_get_verified(nv));
diff --git a/src/main/refcache.c b/src/main/refcache.c
index 9664528..0cdc0d1 100644
--- a/src/main/refcache.c
+++ b/src/main/refcache.c
@@ -113,8 +113,9 @@ stp_refcache_create(const char *name)
 static stp_refcache_t *
 find_cache_named(const char *cache)
 {
+  stp_list_item_t *item;
   check_stp_cache();
-  stp_list_item_t *item = stp_list_get_item_by_name(global_cache_list, cache);
+  item = stp_list_get_item_by_name(global_cache_list, cache);
   if (item)
     return (stp_refcache_t *) stp_list_item_get_data(item);
   else
@@ -124,8 +125,9 @@ find_cache_named(const char *cache)
 static stp_refcache_t *
 find_or_create_cache_named(const char *cache)
 {
+  stp_list_item_t *item;
   check_stp_cache();
-  stp_list_item_t *item = stp_list_get_item_by_name(global_cache_list, cache);
+  item = stp_list_get_item_by_name(global_cache_list, cache);
   if (!item)
     {
       stp_refcache_create(cache);
@@ -207,8 +209,9 @@ stp_refcache_replace_item(const char *cache, const char *item, void *data)
 void
 stp_refcache_destroy(const char *cache)
 {
+  stp_list_item_t *item;
   check_stp_cache();
-  stp_list_item_t *item = stp_list_get_item_by_name(global_cache_list, cache);
+  item = stp_list_get_item_by_name(global_cache_list, cache);
   if (item)
     {
       stp_list_item_destroy(global_cache_list, item);
diff --git a/src/main/sequence.c b/src/main/sequence.c
index 8be0911..482c4cb 100644
--- a/src/main/sequence.c
+++ b/src/main/sequence.c
@@ -383,13 +383,14 @@ stp_sequence_create_from_xmltree(stp_mxml_node_t *da)
 	  if (child->type == STP_MXML_TEXT)
 	    {
 	      char *endptr;
+	      double tmpval;
 	      /*
 	       * Explicitly documented that callers to strtod should clear
 	       * errno before calling it if they want to check the return
 	       * status.
 	       */
 	      errno = 0;
-	      double tmpval = strtod(child->value.text.string, &endptr);
+	      tmpval = strtod(child->value.text.string, &endptr);
 	      if (endptr == child->value.text.string)
 		{
 		  stp_erprintf
diff --git a/src/main/xml.c b/src/main/xml.c
index 5587a12..1755131 100644
--- a/src/main/xml.c
+++ b/src/main/xml.c
@@ -308,8 +308,9 @@ xml_try_parse_file_1(const char *pathname, const char *topnodename)
 static stp_mxml_node_t *
 xml_try_parse_file(const char *pathname, const char *topnodename)
 {
+  stp_mxml_node_t *answer;
   stp_xml_init();
-  stp_mxml_node_t *answer = xml_try_parse_file_1(pathname, topnodename);
+  answer = xml_try_parse_file_1(pathname, topnodename);
   stp_xml_exit();
   return answer;
 }
@@ -423,11 +424,12 @@ void
 stp_xml_free_parsed_file(stp_mxml_node_t *node)
 {
   char *addr_string;
+  stp_param_string_t *cache_entry;
   /* free(NULL) is legal and a no-op. */
   if (! node)
     return;
   stp_asprintf(&addr_string, "%p", (void *) node);
-  stp_param_string_t *cache_entry =
+  cache_entry =
     stp_string_list_find(cached_xml_files, addr_string);
   if (! cache_entry)
     {
diff --git a/src/testpattern/testpattern.c b/src/testpattern/testpattern.c
index 2474d69..84e6375 100644
--- a/src/testpattern/testpattern.c
+++ b/src/testpattern/testpattern.c
@@ -36,6 +36,9 @@
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
+#ifdef __HAIKU__
+#undef PAGESIZE
+#endif
 #include "testpattern.h"
 #include <gutenprint/gutenprint-intl.h>
 #include <errno.h>
@@ -610,12 +613,12 @@ fill_channels_##bits(unsigned char *data, size_t len, size_t scount)	\
 {									\
   int i;								\
   int c;								\
-  scount = global_channel_depth;					\
   T *s_data = (T *) data;						\
   unsigned black_val = global_ink_limit * ((1 << bits) - 1);		\
-  unsigned blocksize = len / scount;					\
-  unsigned blocks = blocksize * scount;					\
+  unsigned blocksize = len / global_channel_depth;					\
+  unsigned blocks = blocksize * global_channel_depth;					\
   unsigned extra = len - blocks;					\
+  scount = global_channel_depth;					\
   memset(s_data, 0, sizeof(T) * len * scount);				\
   for (c = 0; c < scount; c++)						\
     {									\
-- 
2.37.3


From da92ad621c744386b01b816e1f202dde2379aefd Mon Sep 17 00:00:00 2001
From: Ken Mays <kmays2000@gmail.com>
Date: Fri, 4 Nov 2022 05:12:14 +0100
Subject: Fix sizeof issue on HAIKU R1B4


diff --git a/src/main/path.c b/src/main/path.c
index 8a0ec1b..b08133b 100644
--- a/src/main/path.c
+++ b/src/main/path.c
@@ -289,7 +289,7 @@ stp_path_split(stp_list_t *list, /* List to add directories to */
 #  define _D_EXACT_NAMLEN(d) (strlen ((d)->d_name))
 # endif
 # ifndef _D_ALLOC_NAMLEN
-#  ifdef _DIRENT_HAVE_D_RECLEN
+#  if defined _DIRENT_HAVE_D_RECLEN || defined(__HAIKU__)
 #   define _D_ALLOC_NAMLEN(d) (((char *) (d) + (d)->d_reclen) - &(d)->d_name[0])
 #  else
 #   define _D_ALLOC_NAMLEN(d) (sizeof (d)->d_name > 1 ? sizeof (d)->d_name : \
-- 
2.37.3


From a9288e9cc8c287c17aa11b318884201f400b86b9 Mon Sep 17 00:00:00 2001
From: Ken Mays <kmays2000@gmail.com>
Date: Mon, 7 Nov 2022 06:03:47 +0100
Subject: Added Canon SELPHY CP1500 and Olmec OP1000 dyesub support (upstream)


diff --git a/NEWS b/NEWS
index 1a78c1d..c71b420 100644
--- a/NEWS
+++ b/NEWS
@@ -99,6 +99,7 @@ II) MAJOR CHANGES FROM PREVIOUS RELEASES
 
   3) Support for the following dye sublimation & thermal printers has been added:
 
+     Canon SELPHY CP1500
      Citizen CX-02W
      Citizen CZ-01
      DNP QW410
@@ -112,6 +113,7 @@ II) MAJOR CHANGES FROM PREVIOUS RELEASES
      Mitsubishi CP30D series
      Mitsubishi CP-D70DW-S
      Mitsubishi CP-M1 & CP-M15 series
+     Olmec OP1000
      Sony UP-CX1
      Sony UP-971AD
      Sony UP-991AD (EXPERIMENTAL)
diff --git a/src/cups/backend_canonselphyneo.c b/src/cups/backend_canonselphyneo.c
index 0f48fa0..645dd19 100644
--- a/src/cups/backend_canonselphyneo.c
+++ b/src/cups/backend_canonselphyneo.c
@@ -1,7 +1,7 @@
 /*
  *   Canon SELPHY CPneo series CUPS backend -- libusb-1.0 version
  *
- *   (c) 2016-2021 Solomon Peachy <pizza@shaftnet.org>
+ *   (c) 2016-2022 Solomon Peachy <pizza@shaftnet.org>
  *
  *   The latest version of this program can be found at:
  *
@@ -79,22 +79,38 @@ static const char *selphyneo_errors(uint8_t err)
 	switch(err) {
 	case 0x00:
 		return "None";
+	case 0x01:
+		return "Low battery";
 	case 0x02:
-		return "Paper Feed";
+		return "Paper Feed (No Paper?)";
 	case 0x03:
-		return "No Paper";
+		return "No Paper Tray";
+	case 0x04:
+		return "Incorrect Paper Tray";
 	case 0x05:
 		return "Incorrect Paper loaded";
 	case 0x06:
 		return "Ink Cassette Empty";
 	case 0x07:
 		return "No Ink";
+	case 0x08:
+		return "Incorrect Ink loaded";
 	case 0x09:
 		return "No Paper and Ink";
 	case 0x0A:
-		return "Incorrect media for job";
+		return "Incorrect paper tray and ink for job";
 	case 0x0B:
 		return "Paper jam";
+	case 0x0C:
+		return "Ink jam";
+	case 0x0D:
+		return "Ink illegal";
+	case 0x0E:
+		return "Unknown Ink";
+	case 0x0F:
+		return "Unknown Paper";
+	case 0x10:
+		return "Unknown Command";
 	default:
 		return "Unknown Error";
 	}
@@ -116,6 +132,20 @@ static const char *selphynew_pgcodes(uint8_t type) {
 	}
 }
 
+static const char *selphyneo_powers(uint8_t sts) {
+
+	switch (sts & 0x3) {
+	case 0x00:
+		return "Line Power";
+	case 0x01:
+		return "Battery OK";
+	case 0x03:
+		return "Battery Low";
+	default:
+		return "Unknown";
+	}
+}
+
 static int selphyneo_send_reset(struct selphyneo_ctx *ctx)
 {
 	uint8_t rstcmd[12] = { 0x40, 0x10, 0x00, 0x00,
@@ -150,6 +180,7 @@ static int selphyneo_get_status(struct selphyneo_ctx *ctx)
 		return CUPS_BACKEND_FAILED;
 
 	INFO("Printer state: %s\n", selphyneo_statuses(rdback.data[0]));
+	INFO("Printer power state: %s\n", selphyneo_powers(rdback.data[7]));
 	INFO("Media type: %s\n", selphynew_pgcodes(rdback.data[6]));
 	if (rdback.data[2]) {
 		INFO("Printer error: %s\n", selphyneo_errors(rdback.data[2]));
@@ -503,7 +534,7 @@ static const char *canonselphyneo_prefixes[] = {
 
 const struct dyesub_backend canonselphyneo_backend = {
 	.name = "Canon SELPHY CP (new)",
-	.version = "0.22",
+	.version = "0.24",
 	.uri_prefixes = canonselphyneo_prefixes,
 	.cmdline_usage = selphyneo_cmdline,
 	.cmdline_arg = selphyneo_cmdline_arg,
@@ -519,6 +550,7 @@ const struct dyesub_backend canonselphyneo_backend = {
 		{ 0x04a9, 0x32ae, P_CP910, NULL, "canon-cp1000"},
 		{ 0x04a9, 0x32b1, P_CP910, NULL, "canon-cp1200"},
 		{ 0x04a9, 0x32db, P_CP910, NULL, "canon-cp1300"},
+		{ 0x04a9, 0x3302, P_CP910, NULL, "canon-cp1500"},
 		{ 0, 0, 0, NULL, NULL}
 	}
 };
@@ -529,7 +561,7 @@ const struct dyesub_backend canonselphyneo_backend = {
 	Stream formats and readback codes for supported printers
 
  ***************************************************************************
- Selphy CP820/CP910/CP1000/CP1200/CP1300:
+ Selphy CP820/CP910/CP1000/CP1200/CP1300/CP1500:
 
   Radically different spool file format from older Selphy models.
   300dpi, same nominal print sizes but slightly different dimensions.
@@ -547,7 +579,7 @@ const struct dyesub_backend canonselphyneo_backend = {
         4c                 80 04       c0 05          1152 * 1472  (L)
         43                 40 04       9c 02          1088 * 668   (C)
 
-  ZZ == 00  Y'CbCr data follows
+  ZZ == 00  YUV444 data follows
      == 01  CMY    data follows
 
   Followed by three planes of image data:
@@ -556,8 +588,11 @@ const struct dyesub_backend canonselphyneo_backend = {
   L == 5087264 (1695744 * 3)
   C == 2180384 (726784  * 3)
 
-  It is worth mentioning that the Y'CbCr image data is surmised to use the
-  JPEG coefficients, although we realistically have no way of confirming this.
+  RGB -> YUV444 is as follows:
+
+    Y = ( 77 * R + 150 * G + 29 * B + 128 ) >> 8
+    U = ( ( -43 * R + 85 * G + 128 * B + 128 ) >> 8 ) + 128
+    V = ( ( 128 * R - 107 * G - 21 * B + 128 ) >> 8 ) + 128
 
   Other questions:
 
@@ -566,11 +601,10 @@ const struct dyesub_backend canonselphyneo_backend = {
       - Pattern 1 (Matte)
       - Pattern 2 (Fine Matte)
       - Pattern 3 (Grid - not all models?)
-    * How to detect battery pack
 
  Data Readback:
 
-  XX 00 YY 00  00 00 ZZ 00  00 00 00 00
+  XX 00 YY 00  00 00 ZZ PP  00 00 00 00
 
   XX == Status
 
@@ -592,7 +626,7 @@ const struct dyesub_backend canonselphyneo_backend = {
    0A  Media/Job mismatch
    0B  Paper Jam
 
-  ZZ == Media?
+  ZZ == Media
 
    01
    10
@@ -601,9 +635,15 @@ const struct dyesub_backend canonselphyneo_backend = {
    ^-- Paper
 
     1 == P
-    2 == L (??)
+    2 == L
     3 == C
 
+  PP == Power state
+
+   00 = A/C power
+   01 = Battery OK
+   03 = Battery Low
+
 Also, the first time a readback happens after plugging in the printer:
 
 34 44 35 31  01 00 01 00  01 00 45 00      "4D51" ...??
diff --git a/src/cups/backend_hiti.c b/src/cups/backend_hiti.c
index 143b6a9..a61c3b2 100644
--- a/src/cups/backend_hiti.c
+++ b/src/cups/backend_hiti.c
@@ -1,7 +1,7 @@
 /*
  *   HiTi Photo Printer CUPS backend -- libusb-1.0 version
  *
- *   (c) 2019-2021 Solomon Peachy <pizza@shaftnet.org>
+ *   (c) 2019-2022 Solomon Peachy <pizza@shaftnet.org>
  *
  *   The latest version of this program can be found at:
  *
@@ -205,6 +205,7 @@ struct hiti_job_qqa {
 #define QQA_STATUS_PRINTING 0x00
 #define QQA_STATUS_WAITING  0x01
 #define QQA_STATUS_SUSPENDED 0x03
+#define QQA_STATUS_ERROR     0x80 // ???
 
 /* CMD_JC_QJC */
 struct hiti_jc_qjc {
@@ -273,6 +274,21 @@ struct hiti_heattable_v1b {  /* P51x (newer) */
 
 STATIC_ASSERT(sizeof(struct hiti_heattable_v1b) == 12917);
 
+/* All fields are little endian */
+struct hiti_heattable_entry_v2 {
+	uint16_t  type;
+	uint8_t   unknown;
+	uint16_t  zero;
+	uint32_t  offset;
+} __attribute((packed));
+
+struct hiti_heattable_hdr_v2 {
+	uint8_t num_headers;
+	struct hiti_heattable_entry_v2 entries[];
+} __attribute((packed));
+
+#define HEATTABLE_V2_MAX_SIZE (1024*128)
+
 /* All fields are LE */
 struct hiti_gpjobhdr {
 	uint32_t cookie;  /* "GPHT" */
@@ -376,6 +392,27 @@ struct hiti_matrix {
 /* @100 */
 } __attribute__((packed));
 
+struct hiti_ribbon {
+	uint16_t unk;
+	uint8_t type;  /* RIBBON_TYPE_XXX */
+	uint16_t unk2;
+} __attribute__((packed));
+
+#define RIBBON_TYPE_4x6    0x01
+#define RIBBON_TYPE_5x7    0x02
+#define RIBBON_TYPE_6x9    0x03
+#define RIBBON_TYPE_6x8    0x04
+
+struct hiti_paper {
+	uint8_t unk;
+	uint8_t type;  /* PAPER_TYPE_XXX */
+	uint16_t unk2;
+} __attribute__((packed));
+
+#define PAPER_TYPE_5INCH   0x02
+#define PAPER_TYPE_6INCH   0x01
+#define PAPER_TYPE_NONE    0x00
+
 /* Private data structure */
 struct hiti_printjob {
 	struct dyesub_job_common common;
@@ -401,8 +438,8 @@ struct hiti_ctx {
 	char     version[256];
 	char     id[256];
 	uint8_t  matrix[256];  // XXX convert to struct matrix */
-	uint8_t  supplies[5];  /* Ribbon */ // XXX convert to struct
-	uint8_t  supplies2[4]; /* Paper */  // XXX convert to struct
+	struct hiti_ribbon ribbon;
+	struct hiti_paper  paper;
 	struct hiti_calibration calibration;
 	uint8_t  led_calibration[10]; // XXX convert to struct
 	uint8_t  unk_8010[15]; // XXX
@@ -412,6 +449,14 @@ struct hiti_ctx {
 	struct hiti_rpidm rpidm;
 	uint16_t ribbonvendor; // low byte = media subtype, high byte = type.
 	uint32_t media_remain; // XXX could be array?
+
+	uint8_t *heattable_buf;
+	struct hiti_heattable_v2 {
+		uint16_t type;
+		uint8_t  *data;
+		uint32_t len;
+	} *heattable_v2;
+	uint8_t num_heattable_entries;
 };
 
 /* Prototypes */
@@ -607,15 +652,11 @@ static const char *hiti_jobstatuses(uint8_t code)
 	case QQA_STATUS_PRINTING:  return "Printing";
 	case QQA_STATUS_WAITING:   return "Waiting";
 	case QQA_STATUS_SUSPENDED: return "Suspended";
+	case QQA_STATUS_ERROR: return "Unknown Error";
 	default: return "Unknown";
 	}
 }
 
-#define RIBBON_TYPE_4x6    0x01
-#define RIBBON_TYPE_5x7    0x02
-#define RIBBON_TYPE_6x9    0x03
-#define RIBBON_TYPE_6x8    0x04
-
 static const char* hiti_ribbontypes(uint8_t code)
 {
 	switch (code) {
@@ -638,10 +679,6 @@ static unsigned int hiti_ribboncounts(uint8_t code)
 	}
 }
 
-#define PAPER_TYPE_5INCH   0x02
-#define PAPER_TYPE_6INCH   0x01
-#define PAPER_TYPE_NONE    0x00
-
 static const char* hiti_papers(uint8_t code)
 {
 	switch (code) {
@@ -906,19 +943,19 @@ static int hiti_get_status(struct hiti_ctx *ctx)
 	     hiti_errors(err), err);
 
 	INFO("Media: %s (%02x / %04x) : %03u/%03u\n",
-	     hiti_ribbontypes(ctx->supplies[2]),
-	     ctx->supplies[2],
+	     hiti_ribbontypes(ctx->ribbon.type),
+	     ctx->ribbon.type,
 	     ctx->ribbonvendor,
-	     ctx->media_remain, hiti_ribboncounts(ctx->supplies[2]));
+	     ctx->media_remain, hiti_ribboncounts(ctx->ribbon.type));
 	INFO("Paper: %s (%02x)\n",
-	     hiti_papers(ctx->supplies2[0]),
-	     ctx->supplies2[0]);
+	     hiti_papers(ctx->paper.type),
+	     ctx->paper.type);
 
 	/* Find out if we have any jobs outstanding */
 	struct hiti_job job = { 0 };
 	hiti_query_job_qa(ctx, &job, &qqa);
 	for (i = 0 ; i < qqa.count ; i++) {
-		INFO("JobID %02x %04x (%s)\n",
+		INFO("JobID %02x %04x (status %s)\n",
 		     qqa.row[i].job.lun,
 		     be16_to_cpu(qqa.row[i].job.jobid),
 		     hiti_jobstatuses(qqa.row[i].status));
@@ -1008,21 +1045,21 @@ static int hiti_attach(void *vctx, struct dyesub_connection *conn, uint8_t jobid
 		}
 		// do real stuff
 	} else {
-		ctx->supplies2[0] = PAPER_TYPE_6INCH;
-		ctx->supplies[2] = RIBBON_TYPE_4x6;
+		ctx->paper.type = PAPER_TYPE_6INCH;
+		ctx->ribbon.type = RIBBON_TYPE_4x6;
 
 		if (getenv("MEDIA_CODE")) {
 			// set fake fw version?
-			ctx->supplies[2] = atoi(getenv("MEDIA_CODE"));
-			if (ctx->supplies[2] ==  RIBBON_TYPE_5x7)
-				ctx->supplies2[0] = PAPER_TYPE_5INCH;
+			ctx->ribbon.type = atoi(getenv("MEDIA_CODE"));
+			if (ctx->ribbon.type == RIBBON_TYPE_5x7)
+				ctx->paper.type = PAPER_TYPE_5INCH;
 		}
 	}
 
 	ctx->marker.color = "#00FFFF#FF00FF#FFFF00";
-	ctx->marker.name = hiti_ribbontypes(ctx->supplies[2]);
-	ctx->marker.numtype = ctx->supplies[2];
-	ctx->marker.levelmax = hiti_ribboncounts(ctx->supplies[2]);
+	ctx->marker.name = hiti_ribbontypes(ctx->ribbon.type);
+	ctx->marker.numtype = ctx->ribbon.type;
+	ctx->marker.levelmax = hiti_ribboncounts(ctx->ribbon.type);
 	ctx->marker.levelnow = 0;
 
 	return CUPS_BACKEND_OK;
@@ -1046,7 +1083,7 @@ static uint8_t *hiti_get_correction_data(struct hiti_ctx *ctx, uint8_t mode)
 	int ret, len;
 
 	int mediaver = ctx->ribbonvendor & 0x3f;
-	int mediatype = ((ctx->ribbonvendor & 0xf000) == 0x1000);
+	int mediatype = ctx->ribbonvendor & 0xf000;
 
 	switch (ctx->conn->type)
 	{
@@ -1054,15 +1091,8 @@ static uint8_t *hiti_get_correction_data(struct hiti_ctx *ctx, uint8_t mode)
 		fname = "CS2xx_CMPBcd.bin";
 		break;
 	case P_HITI_51X:
-		if (!mediatype) { /* DNP media */
-			if (mode) {
-				fname = "P51x_CMQPra.bin";
-				break;
-			} else {
-				fname = "P51x_CMPPra.bin";
-				break;
-			}
-		} else { /* CHC media */
+		if (mediatype == 0x1000) { /* CHC media */
+
 			if (mode) {
 				switch(mediaver) {
 				case 0:
@@ -1105,6 +1135,14 @@ static uint8_t *hiti_get_correction_data(struct hiti_ctx *ctx, uint8_t mode)
 					break;
 				}
 			}
+		} else { /* DNP media */
+			if (mode) {
+				fname = "P51x_CMQPra.bin";
+				break;
+			} else {
+				fname = "P51x_CMPPra.bin";
+				break;
+			}
 		}
 		break;
 	case P_HITI_52X:
@@ -1134,15 +1172,7 @@ static uint8_t *hiti_get_correction_data(struct hiti_ctx *ctx, uint8_t mode)
 		}
 		break;
 	case P_HITI_720:
-		if (!mediatype) {
-			if (mode) {
-				fname = "P72x_CMQPrd.bin";
-				break;
-			} else {
-				fname = "P72x_CMPPrd.bin";
-				break;
-			}
-		} else {
+		if (mediatype == 0x1000) {
 			if (mode) {
 				switch(mediaver) {
 				case 0:
@@ -1194,6 +1224,14 @@ static uint8_t *hiti_get_correction_data(struct hiti_ctx *ctx, uint8_t mode)
 					break;
 				}
 			}
+		} else {
+			if (mode) {
+				fname = "P72x_CMQPrd.bin";
+				break;
+			} else {
+				fname = "P72x_CMPPrd.bin";
+				break;
+			}
 		}
 		break;
 	case P_HITI_750:
@@ -1336,75 +1374,140 @@ static int hiti_cvd(struct hiti_ctx *ctx, uint8_t *buf, uint32_t buf_len)
 	return ret;
 }
 
-static int hiti_send_heat_data(struct hiti_ctx *ctx, uint8_t mode, uint8_t matte)
+static const char* hiti_get_heat_file(struct hiti_ctx *ctx, uint8_t mode)
 {
-	const char *fname = NULL;
-	union {
-		struct hiti_heattable_v1a v1a;
-		struct hiti_heattable_v1a v1b;
-	} table;
-	uint8_t *y, *m, *c, *o, *om, *cvd;
-
-	int ret, len;
-
 	int mediaver = ctx->ribbonvendor & 0x3f;
-	int mediatype = ((ctx->ribbonvendor & 0xf000) == 0x1000);
+	int mediatype = ctx->ribbonvendor & 0xf000;
 
 	// XXX if field_0x70 != 100) send blank/empty tables..
 	// no idea what sets this field.
-	switch (ctx->conn->type)
-	{
+	switch (ctx->conn->type) {
 	case P_HITI_51X:
-		if (!mediatype) { /* DNP media */
-			if (mode) {
-				fname = "P51x_heatqhra.bin";
-				break;
-			} else {
-				fname = "P51x_heatthra.bin";
-				break;
-			}
-		} else { /* CHC media */
+		if (mediatype == 0x1000) { /* CHC media */
+                        // what mode does 'P' (PC) match?
 			if (mode) {
 				switch(mediaver) {
 				case 0:
-					fname = "P51x_hea0qcra.bin";
-					break;
+					return "P51x_hea0qcra.bin";
 				case 1:
-					fname = "P51x_hea1qcra.bin";
-					break;
+					return "P51x_hea1qcra.bin";
 				case 2:
-					fname = "P51x_hea2qcra.bin";
-					break;
+					return "P51x_hea2qcra.bin";
 				case 3:
+					return "P51x_hea3qcra.bin";
+				case 4:
+					return "P51x_hea4qcra.bin";
 				default:
-					fname = "P51x_hea3qcra.bin";
-					break;
+					return "P51x_heatqcra.bin";
 				}
 			} else {
 				switch(mediaver) {
 				case 0:
-					fname = "P51x_hea0tcra.bin";
-					break;
+					return "P51x_hea0tcra.bin";
 				case 1:
-					fname = "P51x_hea1tcra.bin";
-					break;
+					return "P51x_hea1tcra.bin";
 				case 2:
-					fname = "P51x_hea2tcra.bin";
-					break;
+					return "P51x_hea2tcra.bin";
 				case 3:
+					return "P51x_hea3tcra.bin";
+				case 4:
+					return "P51x_hea4tcra.bin";
+				case 5:
+					return "P51x_hea5tcra.bin";
 				default:
-					fname = "P51x_hea3tcra.bin";
-					break;
+					return "P51x_heattcra.bin";
 				}
 			}
+		} else { /* DNP media */
+                        // what mode does 'P' or 'R' (PH, RH) match?
+			if (mode) {
+				return "P51x_heatqhra.bin";
+			} else {
+				return "P51x_heatthra.bin";
+			}
 		}
 		break;
-	case P_HITI_52X:
 	case P_HITI_720:
-	default:
-		fname = NULL;
+		if (mediatype == 0x1000) { /* CHC media */
+			if (mode) {
+				// what mode does 'P' (PC) match?
+				switch(mediaver) {
+				case 3:
+					return "P72x_hea3qcrd.bin";
+				case 4:
+					return "P72x_hea4qcrd.bin";
+				case 5:
+					return "P72x_hea5qcrd.bin";
+				case 7:
+					return "P72x_hea7qcrd.bin";
+				case 8:
+					return "P72x_hea8qcrd.bin";
+				case 9:
+					return "P72x_hea9qcrd.bin";
+				default:
+					return "P72x_heatqcrd.bin";
+				}
+			} else {
+				switch(mediaver) {
+				case 3:
+					return "P72x_hea3tcrd.bin";
+				case 4:
+					return "P72x_hea4tcrd.bin";
+				default:
+					return "P72x_heattcrd.bin";
+				}
+			}
+		} else {
+			// what mode does 'P' (PH) match?
+			if (mode) {
+				return "P72x_heatqhrd.bin";
+			} else {
+				return "P72x_heatthrd.bin";
+			}
+		}
 		break;
+	case P_HITI_750:
+		// what mode does 'P' (PC) match?
+		if (mode) {
+			switch(mediaver) {
+			case 1:
+				return "P75x_hea1qcrh.bin";
+			case 2:
+				return "P75x_hea2qcrh.bin";
+			case 3:
+				return "P75x_hea3qcrh.bin";
+			case 4:
+				return "P75x_hea4qcrh.bin";
+			case 5:
+				return "P75x_hea5qcrh.bin";
+			case 7:
+				return "P75x_hea7qcrh.bin";
+			default:
+				return "P75x_heatqcrh.bin";
+			}
+		} else {
+			return "P75x_heattcrh.bin";
+		}
+		break;
+	case P_HITI_52X:
+	default:
+		return NULL;
 	}
+}
+
+static int hiti_send_heat_data(struct hiti_ctx *ctx, uint8_t mode, uint8_t matte)
+{
+	const char *fname = NULL;
+	union {
+		struct hiti_heattable_v1a v1a;
+		struct hiti_heattable_v1a v1b;
+	} table;
+	uint8_t *y, *m, *c, *o, *om, *cvd;
+
+	int ret, len;
+
+	fname = hiti_get_heat_file(ctx, mode);
+
 	if (fname) {
 		char full[2048];
 		snprintf(full, sizeof(full), "%s/%s", corrtable_path, fname);
@@ -1754,7 +1857,7 @@ static int hiti_read_parse(void *vctx, const void **vjob, int data_fd, int copie
 	}
 
 	/* Sanity check against paper */
-	switch (ctx->supplies2[0]) {
+	switch (ctx->paper.type) {
 	case PAPER_TYPE_5INCH:
 		if (job->hdr.cols != 1548) {
 			ERROR("Illegal job on 5-inch paper!\n");
@@ -1770,19 +1873,19 @@ static int hiti_read_parse(void *vctx, const void **vjob, int data_fd, int copie
 		}
 		break;
 	default:
-		ERROR("Unknown paper type (%d)!\n", ctx->supplies2[0]);
+		ERROR("Unknown paper type (%d)!\n", ctx->paper.type);
 		hiti_cleanup_job(job);
 		return CUPS_BACKEND_CANCEL;
 	}
 
 	/* Sanity check against ribbon type */
-	switch (ctx->supplies[2]) {
+	switch (ctx->ribbon.type) {
 	case RIBBON_TYPE_4x6:
 		if (job->hdr.code != PRINT_TYPE_6x4 &&
 		    job->hdr.code != PRINT_TYPE_6x4_2UP &&
 		    job->hdr.code != PRINT_TYPE_6x2) {
 			ERROR("Invalid ribbon type vs job (%02x/%02x)\n",
-			      ctx->supplies[2], job->hdr.code);
+			      ctx->ribbon.type, job->hdr.code);
 			hiti_cleanup_job(job);
 			return CUPS_BACKEND_CANCEL;
 		}
@@ -1792,7 +1895,7 @@ static int hiti_read_parse(void *vctx, const void **vjob, int data_fd, int copie
 		    job->hdr.code != PRINT_TYPE_5x3_5 &&
 		    job->hdr.code != PRINT_TYPE_5x7_2UP) {
 			ERROR("Invalid ribbon type vs job (%02x/%02x)\n",
-			      ctx->supplies[2], job->hdr.code);
+			      ctx->ribbon.type, job->hdr.code);
 			hiti_cleanup_job(job);
 			return CUPS_BACKEND_CANCEL;
 		}
@@ -1803,7 +1906,7 @@ static int hiti_read_parse(void *vctx, const void **vjob, int data_fd, int copie
 		    job->hdr.code != PRINT_TYPE_6x8 &&
 		    job->hdr.code != PRINT_TYPE_6x2) {
 			ERROR("Invalid ribbon type vs job (%02x/%02x)\n",
-			      ctx->supplies[2], job->hdr.code);
+			      ctx->ribbon.type, job->hdr.code);
 			hiti_cleanup_job(job);
 			return CUPS_BACKEND_CANCEL;
 		}
@@ -1816,7 +1919,7 @@ static int hiti_read_parse(void *vctx, const void **vjob, int data_fd, int copie
 		    job->hdr.code != PRINT_TYPE_6x9 &&
 		    job->hdr.code != PRINT_TYPE_6x9_2UP) {
 			ERROR("Invalid ribbon type vs job (%02x/%02x)\n",
-			      ctx->supplies[2], job->hdr.code);
+			      ctx->ribbon.type, job->hdr.code);
 			hiti_cleanup_job(job);
 			return CUPS_BACKEND_CANCEL;
 		}
@@ -1981,7 +2084,7 @@ static int hiti_main_loop(void *vctx, const void *vjob, int wait_for_return)
 	sf.rows_res = cpu_to_be16(job->hdr.row_dpi);
 	sf.cols = cpu_to_be16(job->hdr.cols);
 	sf.rows = cpu_to_be16(rows);
-	sf.rows_offset = calc_offset(ctx->calibration.vert, 5, 8, 4);
+	sf.rows_offset = calc_offset(5, ctx->calibration.vert, 8, 4);
 	sf.cols_offset = calc_offset(ctx->calibration.horiz, 6, 11, 4);
 	sf.colorSeq = 0x87 + (job->hdr.overcoat ? 0xc0 : 0);
 	sf.copies = job->common.copies;
@@ -1990,9 +2093,9 @@ static int hiti_main_loop(void *vctx, const void *vjob, int wait_for_return)
 	if (ret)
 		return CUPS_BACKEND_FAILED;
 
-	// XXX msg 8011 sent here..
+	// XXX msg 8011 sent here on P52x (and maybe others?)
 
-	/* XXX startjob returns actual jobid */
+	/* Initialize jobid structure */
 	jobid.lun = 0;
 	jobid.jobid = cpu_to_be16(ctx->jobid);
 
@@ -2021,15 +2124,14 @@ static int hiti_main_loop(void *vctx, const void *vjob, int wait_for_return)
 		ret = hiti_docmd(ctx, CMD_EFD_CHS, chs, sizeof(chs), &resplen);
 		if (ret)
 			return CUPS_BACKEND_FAILED;
+
+		// XXX send CMD_ESD_SHTPC (Heating Parameters & Tone Curve, ~7KB payload) instead?
 	}
 
 	ret = hiti_docmd(ctx, CMD_EPC_SP, NULL, 0, &resplen);
 	if (ret)
 		return CUPS_BACKEND_FAILED;
 
-	// XXX send ESD_SHTPC  w/ heat table.  Unknown.
-	// CMD_ESD_SHPTC // Heating Parameters & Tone Curve (~7Kb, seen on windows..)
-	/* Send heat table data  */
 
 resend_y:
 	INFO("Sending yellow plane\n");
@@ -2043,7 +2145,6 @@ resend_y:
 	if (ret)
 		return CUPS_BACKEND_FAILED;
 	__usleep(200*1000);
-	sent += rows * cols;
 	ret = hiti_query_status(ctx, sts, &err);
 	if (ret)
 		return ret;
@@ -2056,6 +2157,7 @@ resend_y:
 		WARNING("Printer requested resend\n");
 		goto resend_y;
 	}
+	sent += rows * cols;
 
 resend_m:
 	INFO("Sending magenta plane\n");
@@ -2068,7 +2170,6 @@ resend_m:
 	ret = send_data(ctx->conn, job->databuf + sent, rows * cols);
 	if (ret)
 		return CUPS_BACKEND_FAILED;
-	sent += rows * cols;
 	__usleep(200*1000);
 	ret = hiti_query_status(ctx, sts, &err);
 	if (ret)
@@ -2082,6 +2183,7 @@ resend_m:
 		WARNING("Printer requested resend\n");
 		goto resend_m;
 	}
+	sent += rows * cols;
 
 resend_c:
 	INFO("Sending cyan plane\n");
@@ -2095,7 +2197,7 @@ resend_c:
 	if (ret)
 		return CUPS_BACKEND_FAILED;
 	__usleep(200*1000);
-	sent += rows * cols;
+
 	ret = hiti_query_status(ctx, sts, &err);
 	if (ret)
 		return ret;
@@ -2108,6 +2210,7 @@ resend_c:
 		WARNING("Printer requested resend\n");
 		goto resend_c;
 	}
+	sent += rows * cols;
 
 	INFO("Sending Print start\n");
 	ret = hiti_docmd(ctx, CMD_EPC_EP, NULL, 0, &resplen);
@@ -2148,6 +2251,14 @@ resend_c:
 		if (qqa.count == 0 || qqa.row[0].job.jobid == 0)
 			break;
 
+		for (int i = 0 ; i < qqa.count ; i++) {
+			if (qqa.row[i].job.jobid == jobid.jobid) {
+				if (qqa.row[i].status > QQA_STATUS_SUSPENDED) {
+					ERROR("Printer reported abnormal job status %02x\n", qqa.row[i].status);
+					return CUPS_BACKEND_FAILED;
+				}
+			}
+		}
 	} while(1);
 
 	INFO("Print complete\n");
@@ -2374,15 +2485,15 @@ static int hiti_query_tphv(struct hiti_ctx *ctx)
 static int hiti_query_supplies(struct hiti_ctx *ctx)
 {
 	int ret;
-	uint16_t len = 5;
+	uint16_t len = sizeof(ctx->ribbon);
 	uint8_t arg = 0;
 
-	ret = hiti_docmd_resp(ctx, CMD_RDS_RSUS, &arg, sizeof(arg), ctx->supplies, &len);
+	ret = hiti_docmd_resp(ctx, CMD_RDS_RSUS, &arg, sizeof(arg), (uint8_t*)&ctx->ribbon, &len);
 	if (ret)
 		return ret;
 
-	len = 4;
-	ret = hiti_docmd_resp(ctx, CMD_RDS_RIS, NULL, 0, ctx->supplies2, &len);
+	len = sizeof(ctx->paper);
+	ret = hiti_docmd_resp(ctx, CMD_RDS_RIS, NULL, 0, (uint8_t*)&ctx->paper, &len);
 	if (ret)
 		return ret;
 
@@ -2539,6 +2650,59 @@ static int hiti_query_stats(void *vctx, struct printerstats *stats)
 	return CUPS_BACKEND_OK;
 }
 
+static int hiti_read_heattable_v2(struct hiti_ctx *ctx, char* fname) {
+	int len = 0;
+	int ret;
+	char full[2048];
+	int i;
+	struct hiti_heattable_hdr_v2 *hdr;
+
+	ctx->num_heattable_entries = 0;
+	if (ctx->heattable_buf) {
+		free(ctx->heattable_buf);
+		ctx->heattable_buf = NULL;
+	}
+	if (ctx->heattable_v2) {
+		free(ctx->heattable_v2);
+		ctx->heattable_v2 = NULL;
+	}
+
+	ctx->heattable_buf = malloc(HEATTABLE_V2_MAX_SIZE);
+	if (!ctx->heattable_buf) {
+		ERROR("Memory allocation failed!\n");
+		return CUPS_BACKEND_FAILED;
+	}
+	snprintf(full, sizeof(full), "%s/%s", corrtable_path, fname);
+	ret = dyesub_read_file(full, ctx->heattable_buf, HEATTABLE_V2_MAX_SIZE, &len);
+	if (ret) {
+		return ret;
+	}
+	hdr = (struct hiti_heattable_hdr_v2 *) ctx->heattable_buf;
+
+	ctx->heattable_v2 = malloc(hdr->num_headers * sizeof(struct hiti_heattable_v2));
+	if (!ctx->heattable_buf) {
+		ERROR("Memory allocation failed!\n");
+		return CUPS_BACKEND_FAILED;
+	}
+
+	ctx->num_heattable_entries = hdr->num_headers;
+
+	for (i = 0 ; i < hdr->num_headers ; i++) {
+		DEBUG("Found: %04x %02x @ %d\n",
+		      le16_to_cpu(hdr->entries[i].type),
+		      hdr->entries[i].unknown,
+		      le32_to_cpu(hdr->entries[i].offset));
+
+		ctx->heattable_v2[i].type = le16_to_cpu(hdr->entries[i].type);
+		ctx->heattable_v2[i].data = ctx->heattable_buf + hdr->entries[i].offset;
+		if (i > 0) {
+			ctx->heattable_v2[i-1].len = le32_to_cpu(hdr->entries[i].offset) - le32_to_cpu(hdr->entries[i-1].offset);
+		}
+	}
+	ctx->heattable_v2[i-1].len = len - le32_to_cpu(hdr->entries[i-1].offset);
+
+	return CUPS_BACKEND_OK;
+};
 
 static const char *hiti_prefixes[] = {
 	"hiti", // Family name
@@ -2548,7 +2712,7 @@ static const char *hiti_prefixes[] = {
 
 const struct dyesub_backend hiti_backend = {
 	.name = "HiTi Photo Printers",
-	.version = "0.40",
+	.version = "0.44",
 	.uri_prefixes = hiti_prefixes,
 	.cmdline_usage = hiti_cmdline,
 	.cmdline_arg = hiti_cmdline_arg,
@@ -2582,7 +2746,6 @@ const struct dyesub_backend hiti_backend = {
 };
 
 /*
-#define USB_PID_HITI_P530    0x000F
 #define USB_PID_HITI_P110S   0x0110
 #define USB_PID_HITI_P310L   0x0503
 #define USB_PID_HITI_P310W   0x050A
@@ -2618,7 +2781,6 @@ const struct dyesub_backend hiti_backend = {
    - Start research into P530D, X610
    - Incorporate changes for CS-series card printers
    - More "Matrix table" decoding work
-   - Investigate Suspicion that HiTi keeps tweaking LUTs and/or Heat tables
-   - Pull in heat tables & LUTs from windows drivers
+   - Pull in updated heat tables & LUTs from windows drivers
 
 */
diff --git a/src/cups/blacklist b/src/cups/blacklist
index a9dda04..af08233 100644
--- a/src/cups/blacklist
+++ b/src/cups/blacklist
@@ -93,6 +93,9 @@
 # Canon SELPHY CP1300
 0x04a9 0x32db blacklist
 
+# Canon SELPHY CP1500
+0x04a9 0x3302 blacklist
+
 # Canon SELPHY ES1
 0x04a9 0x3141 blacklist
 
@@ -146,6 +149,8 @@
 
 # Shinko CHC-S2145 (aka Sinfonia S2)
 0x10ce 0x000e blacklist
+# Olmec OP1000
+0x10ce 0x0011 blacklist
 
 # Shinko CHC-S2245 (aka Sinfonia S3)
 0x10ce 0x0039 blacklist
diff --git a/src/xml/printers/dyesub.xml b/src/xml/printers/dyesub.xml
index f63aef9..7cbc506 100644
--- a/src/xml/printers/dyesub.xml
+++ b/src/xml/printers/dyesub.xml
@@ -84,6 +84,7 @@
       <printer translate="name" name="Canon SELPHY CP1000" deviceid="MFG:Canon;CMD:Raster3;MDL:CP1000;CLS:PRINTER;DES:Canon CP1000;VER:1.00;CID:CA_YCC_ICP;" driver="canon-cp1000" manufacturer="Canon" model="1011" />
       <printer translate="name" name="Canon SELPHY CP1200" deviceid="MFG:Canon;CMD:Raster3;MDL:SELPHY CP1200;CLS:PRINTER;DES:Canon SELPHY CP1200;VER:1.00;CID:CA_YCC_ICP;" driver="canon-cp1200" manufacturer="Canon" model="1011"/>
       <printer translate="name" name="Canon SELPHY CP1300" deviceid="MFG:Canon;CMD:Raster3;MDL:SELPHY CP1300;CLS:PRINTER;DES:Canon SELPHY CP1300;VER:1.00;CID:CA_YCC_ICP;" driver="canon-cp1300" manufacturer="Canon" model="1011"/>
+      <printer translate="name" name="Canon SELPHY CP1500" deviceid="MFG:Canon;CMD:Raster3;MDL:SELPHY CP1500;CLS:PRINTER;DES:Canon SELPHY CP1300;VER:1.00;CID:CA_YCC_ICP;" driver="canon-cp1500" manufacturer="Canon" model="1011"/>
       <printer translate="name" name="Canon SELPHY ES1" deviceid="MFG:Canon;CMD:Raster3;MDL:ES1;CLS:PRINTER;DES:Canon SELPHY ES1;VER:1.00;" driver="canon-es1" manufacturer="Canon" model="1003" />
       <printer translate="name" name="Canon SELPHY ES2" deviceid="MFG:Canon;CMD:Raster3;MDL:ES2;CLS:PRINTER;DES:Canon SELPHY ES2;VER:1.00;" driver="canon-es2" manufacturer="Canon" model="1005" />
       <printer translate="name" name="Canon SELPHY ES3" deviceid="MFG:Canon;CMD:Raster3;MDL:ES3;CLS:PRINTER;DES:Canon SELPHY ES3;VER:1.00;" driver="canon-es3" manufacturer="Canon" model="1006" />
@@ -184,6 +185,7 @@
       <printer translate="name" name="Nidac Copal DPB-4000"  driver="nidalcopac-dpb-4000" manufacturer="Nidac Copal" model="4201">EXPERIMENTAL</printer>
       <printer translate="name" name="Nidac Copal DPB-6000"  driver="nidalcopac-dpb-6000" manufacturer="Nidac Copal" model="4200" />
       <printer translate="name" name="Nidac Copal DPB-7000"  driver="nidalcopac-dpb-7000" manufacturer="Nidac Copal" model="4200">EXPERIMENTAL</printer>
+      <printer translate="name" name="Olmec OP1000" driver="olmec-op1000" manufacturer="Olmec" model="5001" />
       <printer translate="name" name="Shinko CHC-S1245" driver="shinko-chcs1245" manufacturer="Shinko" model="5002" />
       <printer translate="name" name="Shinko CHC-S2145" deviceid="MFG:SHINKO;CMD:SUPCC;MDL:CHC-S2145;CLS:PRINTER;DES:SHINKO CHC-S2145;" driver="shinko-chcs2145" manufacturer="Shinko" model="5001" />
       <printer translate="name" name="Shinko CHC-S6145" driver="shinko-chcs6145" manufacturer="Shinko" model="5004" />
-- 
2.37.3

